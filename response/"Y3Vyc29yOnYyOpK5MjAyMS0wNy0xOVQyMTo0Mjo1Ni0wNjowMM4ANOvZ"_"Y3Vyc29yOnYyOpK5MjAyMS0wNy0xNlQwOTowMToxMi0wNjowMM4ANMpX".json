{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNy0xNlQwOTowMToxMi0wNjowMM4ANMpX"
    },
    "edges": [
      {
        "node": {
          "title": "How to SetSide only on the outside of the domain",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi all,\nJust wondering on how to How to SetSide only on the outside of the domain?\nThis is what I use\n  [add_side_sets]\n    type = SideSetsFromNormalsGenerator\n    input = mesh\n    normals = '0  0  1\n               0  1  0\n               1  0  0\n               0  0 -1\n               0 -1  0\n              -1  0  0'\n    fixed_normal = true\n    new_boundary = 'front top right back bottom left'\n    variance = 0.5\n    #\n  []\n\n\nI don't want the middle planes to be considered as a side, does anyone know how to fix this?\nThank you!\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/18376",
          "updatedAt": "2024-09-06T04:15:45Z",
          "publishedAt": "2021-07-19T13:37:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre these inner sidesets perfectly horizontal? If not, you could tighten down the variance.\nIf so, I would use another sideset generator for the horizontal sides.\nLike a ParsedSideSetGenerator with z < eps or a SidesetAroundSubdomainGenerator , which will also accept a normal and should stick to external faces.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18376#discussioncomment-1022086",
                  "updatedAt": "2024-09-13T19:09:00Z",
                  "publishedAt": "2021-07-19T14:13:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "awesome, got it thanks @GiudGiud\na quick question, can the function take min/max value? for example 'z = max'",
                          "url": "https://github.com/idaholab/moose/discussions/18376#discussioncomment-1024629",
                          "updatedAt": "2024-09-13T19:09:01Z",
                          "publishedAt": "2021-07-20T03:16:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would avoid an equal, because this could fail with numerical precision errors. But I think that would be parsed correctly",
                          "url": "https://github.com/idaholab/moose/discussions/18376#discussioncomment-1024634",
                          "updatedAt": "2024-09-13T19:09:01Z",
                          "publishedAt": "2021-07-20T03:19:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Lack of contact despite enforced glued contact",
          "author": {
            "login": "klaw13"
          },
          "bodyText": "Hello,\nI've been running into some problems with getting the following volumes to stay in contact with one another.\n\nI'm using the contact module and the glued model, but the volumes detached from one another during simulation when the four cylindrical components are pressurized.\nI then constrained the variables (disp_x, disp_y, and disp_z) on each side of each volume using the EqualValueBoundaryConstraint. In Paraview, it seems that the parts now stay together, but the simulation still generates the following message:\n*** Warning ***\nWarning in PenetrationLocator. Penetration is not detected for one or more secondary nodes. This could be because those secondary nodes simply do not project to faces on the primary surface. However, this could also be because contact should be enforced on those nodes, but the faces that they project to are outside the contact patch, which will give an erroneous result. Use appropriate options for 'patch_size' and 'patch_update_strategy' in the Mesh block to avoid this issue. Setting 'patch_update_strategy=iteration' is recommended because it completely avoids this potential issue. Also note that this warning is printed only once, so a similar situation could occur multiple times during the simulation but this warning is printed only at the first occurrence.\" \n\nDoes anyone have any suggestions as to how to resolve this?\nThanks!\nKelsey",
          "url": "https://github.com/idaholab/moose/discussions/17591",
          "updatedAt": "2022-06-02T07:05:40Z",
          "publishedAt": "2021-04-13T03:33:46Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@lindsayad @bwspenc on constraints / contact",
                  "url": "https://github.com/idaholab/moose/discussions/17591#discussioncomment-705541",
                  "updatedAt": "2022-06-02T07:05:59Z",
                  "publishedAt": "2021-05-06T17:24:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "My first thought is that the blocks might not actually be touching each other initially.",
                          "url": "https://github.com/idaholab/moose/discussions/17591#discussioncomment-987127",
                          "updatedAt": "2022-06-02T07:06:01Z",
                          "publishedAt": "2021-07-09T23:54:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Could you share your inputs?",
                          "url": "https://github.com/idaholab/moose/discussions/17591#discussioncomment-1002875",
                          "updatedAt": "2022-06-02T07:06:01Z",
                          "publishedAt": "2021-07-14T09:08:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Thanks for all your input! Seems our system was weakly constrained. We put in additional boundary conditions at the points of contact and were able to resolve the issue.",
                          "url": "https://github.com/idaholab/moose/discussions/17591#discussioncomment-1014824",
                          "updatedAt": "2022-06-02T07:06:01Z",
                          "publishedAt": "2021-07-16T20:37:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jbadger95"
                          },
                          "bodyText": "@klaw13 3D mortar constraints are coming soon, still putting the finishing touches on it and the contact kernels will need some tweaks but in case you're interested #18203.",
                          "url": "https://github.com/idaholab/moose/discussions/17591#discussioncomment-1020011",
                          "updatedAt": "2022-06-02T07:06:07Z",
                          "publishedAt": "2021-07-19T05:38:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Good to know, thanks @jbadger95!",
                          "url": "https://github.com/idaholab/moose/discussions/17591#discussioncomment-1024091",
                          "updatedAt": "2022-06-02T07:06:07Z",
                          "publishedAt": "2021-07-19T22:57:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "RVE periodic boundary condition",
          "author": {
            "login": "ada-ayy"
          },
          "bodyText": "Dear MOOSE\uff0c\nI have a problem with the RVE periodic boundary condition: U^2-U^1=f(t), where the enforced displacement f(t) is applied on the opposite boundaries U^2 and U^1.\nI learn from #16419, then copy and modify the codes from EqualValueBoundaryConstraint and https://github.com/crswong888/scorpion/blob/master/src/constraints/EqualValuePlusConstant.C\nThis is my code:\nFunctionValueBoundaryConstraint-C.txt\nFunctionValueBoundaryConstraint-h.txt\nHowever, I don't know exactly how to test the validity of the codes. But I find it always works like DirichletBC, as the nodes of U^1(U^2) always keep the same value. So are there any problems with my codes? Or other methods to achieve this boundary condition?",
          "url": "https://github.com/idaholab/moose/discussions/18367",
          "updatedAt": "2022-10-03T02:28:35Z",
          "publishedAt": "2021-07-17T02:10:24Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Well, if the values are equal, then it's clearly not working...\nAlso, did you see @SudiptaBiswas 's reply in your original post? #16419 (comment)",
                  "url": "https://github.com/idaholab/moose/discussions/18367#discussioncomment-1015924",
                  "updatedAt": "2022-10-03T02:29:01Z",
                  "publishedAt": "2021-07-17T11:20:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "Really thank you for your reply! But I am unfamiliar with the global strain system, and so I am still confused that how should I apply an increased strain on the whole model rather than the constant stress?\nThanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/18367#discussioncomment-1018562",
                          "updatedAt": "2022-10-03T02:29:01Z",
                          "publishedAt": "2021-07-18T13:43:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jbadger95"
                          },
                          "bodyText": "I saw on your original post you were asking about using Lagrange multipliers to accomplish this. In case you're still interested, the answer is yes in 2D (although you'd need to modify the residual like suggested before) and almost in 3D. I have a PR up right now #18203, I'm still putting the finishing touches on it but the code (in theory) is fully functional.\nIf you modify the EqualValueConstraint (see test/tests/mortar/solution-continuity/ for an example use of this constraint) and set periodic = true, it might work. For how to modify the residual, the continuity constraint is actually enforced when the LM variable acts as a test function. So if you think of the 2x2 block structure for the system, the constraint is enforced in the lower-left block and you'd essentially be adding a non-zero forcing term on the LM variable (so where you have (secondary - primary)*test you'd instead have (secondary - primary - your_value)*test ).\nFrom a math perspective this gives me pause though, the solution will essentially be discontinuous and using a trace (the Lagrange multiplier) assumes you have enough regularity for it to be well-defined. Good luck!",
                          "url": "https://github.com/idaholab/moose/discussions/18367#discussioncomment-1019988",
                          "updatedAt": "2022-10-03T02:29:01Z",
                          "publishedAt": "2021-07-19T05:26:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "@ada-ayy The global-strain system might just work for you. There are some examples here, https://github.com/idaholab/moose/tree/next/modules/combined/examples/periodic_strain on how to set this up. You can find several applications of how to utilize the system here, https://www.sciencedirect.com/science/article/pii/S0168874X20301165.",
                          "url": "https://github.com/idaholab/moose/discussions/18367#discussioncomment-1023157",
                          "updatedAt": "2022-10-03T02:29:02Z",
                          "publishedAt": "2021-07-19T17:36:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to calculate the radius of bubble in the MOOSE?",
          "author": {
            "login": "wenpeng231024"
          },
          "bodyText": "Dear MOOSE group,\nI try to use Laplace's equation (2\u03b3/R) to calculate the pressure produced by the surface tension. \u03b3 is the surface tension. R is the radius of the bubble.\nSurface tension can be obtained using \"ComputeSurfaceTensionKKS\".\nFor a single bubble, we can use the order parameters to obtain the bubble area, then calculate the radius of the bubble.\nBut how can we calculate different radii of multi-bubbles in the MOOSE? Or how can we calculate the curvature of the bubbles?\nThanks,\nPeng",
          "url": "https://github.com/idaholab/moose/discussions/18379",
          "updatedAt": "2022-12-20T00:10:00Z",
          "publishedAt": "2021-07-19T17:16:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "You can use FeatureVolumeVectorPostprocessor to output the volume/area of the bubbles. https://mooseframework.inl.gov/source/vectorpostprocessors/FeatureVolumeVectorPostprocessor.html",
                  "url": "https://github.com/idaholab/moose/discussions/18379#discussioncomment-1023128",
                  "updatedAt": "2022-12-20T00:10:00Z",
                  "publishedAt": "2021-07-19T17:27:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wenpeng231024"
                          },
                          "bodyText": "Great. I will try this. Many thanks!\nPeng",
                          "url": "https://github.com/idaholab/moose/discussions/18379#discussioncomment-1023153",
                          "updatedAt": "2022-12-20T00:10:08Z",
                          "publishedAt": "2021-07-19T17:35:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using Postprocessor on blocks",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "While I run several simulations, some conditions gave me values, but some didn't.\nI tried to figure it out what was the difference between those simulations through input file.\nCase 1. Some codes in an input file giving me a value\n[Mesh]\n  [./interface_YSZ_CA]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = meshScale\n    primary_block = 'PT_YSZ_C_TET4'\n    paired_block = 'PT_YSZ_A_TET4'\n    new_boundary = 'interface_CA'\n  [../]\n\n  [./interface_YSZ_AC]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = interface_YSZ_CA\n    primary_block = 'PT_YSZ_A_TET4'\n    paired_block = 'PT_YSZ_C_TET4'\n    new_boundary = 'interface_AC'\n  [../]\n[]\n\n[Materials]\n  [./CounterElectrode_for_C]\n    type  = ParsedMaterial\n    block = 'PT_YSZ_C_TET4 PT_TPB_C_TET4'\n    f_name = 'eff_pO2_A'\n    constant_names        = 'R          T        z     F'        # (J/K/mol), (K),  (# of electron), (C/mol)\n    constant_expressions  = '8.3144598  1073.0   4   96485.3329'\n    postprocessor_names = 'numerical_phi_YSZ_C'\n    function = 'if(numerical_phi_YSZ_C=0, exp(z * F / R / T * (-0.55442)), exp(z * F / R / T * (numerical_phi_YSZ_C)))'\n  [../]\n\n  [./CounterElectrode_for_A]\n    type  = ParsedMaterial\n    block = 'PT_YSZ_A_TET4 PT_TPB_A_TET4'\n    f_name = 'eff_pO2_C'\n    constant_names        = 'R          T        z     F'        # (J/K/mol), (K),  (# of electron), (C/mol)\n    constant_expressions  = '8.3144598  1073.0   4   96485.3329'\n    postprocessor_names = 'numerical_phi_YSZ_A'\n    function = 'if(numerical_phi_YSZ_A=0, exp(z * F / R / T * (-0.55442)), exp(z * F / R / T * (numerical_phi_YSZ_A)))'\n  [../]\n[]\n\n[Postprocessors]\n  [./I_YSZ_bottom_Cathode]\n    type = SideDiffusiveFluxIntegral\n    variable = phi_YSZ_C\n    diffusivity = 'sigma_YSZ'\n    boundary = 'interface_CA'\n    outputs = 'console csv'\n  [../]\n\n  [./numerical_phi_YSZ_C]\n    type = AverageNodalVariableValue\n    boundary = 'interface_CA'\n    variable = phi_YSZ_C\n    execute_on = 'timestep_begin nonlinear timestep_end'\n  [../]\n\n  [./I_YSZ_bottom_Anode]\n    type = SideDiffusiveFluxIntegral\n    variable = phi_YSZ_A\n    diffusivity = 'sigma_YSZ'\n    boundary = 'interface_AC' \n    outputs = 'console csv'\n  [../]\n\n  [./numerical_phi_YSZ_A]\n    type = AverageNodalVariableValue\n    boundary = 'interface_AC'\n    variable = phi_YSZ_A\n    execute_on = 'timestep_begin nonlinear timestep_end'\n  [../]\n[]\n\nCase 2. Some codes in an input file not giving me a value\n[Mesh]\n  [./interface_YSZ_CA]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = meshScale\n    primary_block = 'PT_YSZ_C_TET4'\n    paired_block = 'PT_YSZ_A_TET4'\n    new_boundary = 'interface_CA'\n  [../]\n\n  [./interface_YSZ_AC]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = interface_YSZ_CA\n    primary_block = 'PT_YSZ_A_TET4'\n    paired_block = 'PT_YSZ_C_TET4'\n    new_boundary = 'interface_AC'\n  [../]\n[]\n\n[Materials]\n  [./CounterElectrode]\n    type  = ParsedMaterial\n    block = 'PT_YSZ_C_TET4 PT_TPB_C_TET4 PT_YSZ_A_TET4 PT_TPB_A_TET4'\n    f_name = 'eff_pO2'\n    constant_names        = 'R          T        z     F'        # (J/K/mol), (K),  (# of electron), (C/mol)\n    constant_expressions  = '8.3144598  1073.0   4   96485.3329'\n    postprocessor_names = 'numerical_phi_YSZ'\n    function = 'if(numerical_phi_YSZ=0, exp(z * F / R / T * (-0.55442)), exp(z * F / R / T * (numerical_phi_YSZ)))'\n  [../]\n[]\n\n[Postprocessors]\n  [./I_YSZ_bottom_Cathode]\n    type = SideDiffusiveFluxIntegral\n    variable = phi_YSZ_C\n    diffusivity = 'sigma_YSZ'\n    boundary = 'interface_CA'\n    outputs = 'console csv'\n  [../]\n\n  [./I_YSZ_bottom_Anode]\n    type = SideDiffusiveFluxIntegral\n    variable = phi_YSZ_A\n    diffusivity = 'sigma_YSZ'\n    boundary = 'interface_AC' \n    outputs = 'console csv'\n  [../]\n\n  [./numerical_phi_YSZ]\n    type = AverageNodalVariableValue\n    boundary = 'interface_CA'\n    variable = phi_YSZ_C\n    execute_on = 'timestep_begin nonlinear timestep_end'\n  [../]\n[]\n\nTechnically, I tried to integrate the CounterElectrode by introducing one postprocessor \"numerical_phi_YSZ\" at Case 2 and use the number coming from the postprocessor \"numerical_phi_YSZ\" for calculating CounterElectrode.\nBut, I didn't get values for I_YSZ_bottom_Anode at Case 2.\nI think a postprocessor is entangled with a variable (phi_YSZ_C).\nSo, even if I passed the postprocessor value to CounterElectrode applied on \"TPT_YSZ_A_TET4 PT_TPB_A_TET4\", it would not work.\nThose blocks did not have a variable (phi_YSZ_C), but it had a variable (phi_YSZ_A).\nIn my opinion, if I use still two variables (phi_YSZ_A, phi_YSZ_C), I should use two postprocessors even two functions work the same.\nAlso, if I want to optimize the Case 1, I could use one boundary(interface_CA or interface_AC).\nAm I correct?",
          "url": "https://github.com/idaholab/moose/discussions/18363",
          "updatedAt": "2022-06-19T08:02:19Z",
          "publishedAt": "2021-07-16T22:08:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat do you mean you did not get a value? Do you mean you got a 0 output?\nIs there anything that creates a gradient on either side of the anode/cathode interface? What is the connection between the two variables? Is there an interface kernel?\nDo you need to use two variables? Do you expect I_YSZ_bottom_Cathode and I_YSZ_bottom_Anode to be different given that they are on both sides of the same interface (eg is flux supposed to be discontinuous?)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18363#discussioncomment-1018871",
                  "updatedAt": "2022-06-19T08:02:25Z",
                  "publishedAt": "2021-07-18T16:52:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Initialize the material properties at qp",
          "author": {
            "login": "cooperliu101"
          },
          "bodyText": "Hello, everyone!\nIn my problem I want to calculate the material property at qp only once at the beginning. initQpStatefulProperties seems to be the solution, but I found initQpStatefulProperties is called only when the material is stateful.\nIs there any function like initQpProperties?",
          "url": "https://github.com/idaholab/moose/discussions/18370",
          "updatedAt": "2023-03-15T01:19:03Z",
          "publishedAt": "2021-07-17T12:35:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If you want a material property that persists its value in all time, then it's essentially stateful, right?\nI can think of two easy ways of achieving this in moose:\n\n\nYou can compute its value in initQpStatefulProperties, and in computeQpProproties, assign the old value into the current property.\n\n\nYou can save the value as an AuxVariable and compute it at INITIAL.\n\n\nI'm sure there are other ways.",
                  "url": "https://github.com/idaholab/moose/discussions/18370#discussioncomment-1016090",
                  "updatedAt": "2023-03-15T01:19:03Z",
                  "publishedAt": "2021-07-17T13:11:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "BTW, initQpStatefulProperties is always called, not only on stateful properties.",
                          "url": "https://github.com/idaholab/moose/discussions/18370#discussioncomment-1016091",
                          "updatedAt": "2023-03-15T01:22:32Z",
                          "publishedAt": "2021-07-17T13:12:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cooperliu101"
                          },
                          "bodyText": "Thanks\uff01\nIn my moose version \uff08around 2021.4\uff09initQpStatefulProperties is not always called.\nI need to update and check.\naccording to the latest\n\n  \n    \n      moose/framework/src/loops/ComputeMaterialsObjectThread.C\n    \n    \n         Line 104\n      in\n      4ee8eed\n    \n  \n  \n    \n\n        \n          \n           if (_has_stateful_props) \n        \n    \n  \n\n\n\n  \n    \n      moose/framework/src/materials/MaterialPropertyStorage.C\n    \n    \n         Line 256\n      in\n      06bc1f7\n    \n  \n  \n    \n\n        \n          \n           mat->initStatefulProperties(n_qpoints); \n        \n    \n  \n\n\n\n  \n    \n      moose/framework/src/materials/MaterialBase.C\n    \n    \n         Line 108\n      in\n      66c7cd4\n    \n  \n  \n    \n\n        \n          \n           MaterialBase::initStatefulProperties(unsigned int n_points) \n        \n    \n  \n\n\ninitQpStatefulProperties seems only called when the material has stateful properties?",
                          "url": "https://github.com/idaholab/moose/discussions/18370#discussioncomment-1016194",
                          "updatedAt": "2023-03-15T01:22:32Z",
                          "publishedAt": "2021-07-17T14:24:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Ah you are absolutely correct. I forget about that.",
                          "url": "https://github.com/idaholab/moose/discussions/18370#discussioncomment-1016424",
                          "updatedAt": "2023-03-15T01:23:27Z",
                          "publishedAt": "2021-07-17T15:40:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Help about Moose example for thermal creep behavior",
          "author": {
            "login": "xchengood"
          },
          "bodyText": "Hi Moose experts or users,\nI know Moose is a powerful tool to study the thermal creep behavior of alloys. Could anyone share the Moose code for this paper (https://link.springer.com/article/10.1007/s11661-017-4011-3) or the relevant Moose examples with me? It would be helpful for me to learn more about how to achieve the constitutive model presented in the paper in Moose.\nI am appreciative of your help.\n@dewenyushu",
          "url": "https://github.com/idaholab/moose/discussions/18318",
          "updatedAt": "2022-08-28T18:06:18Z",
          "publishedAt": "2021-07-13T15:18:48Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You should contact the corresponding author of that paper insteading of asking here.",
                  "url": "https://github.com/idaholab/moose/discussions/18318#discussioncomment-1016117",
                  "updatedAt": "2022-08-28T18:06:18Z",
                  "publishedAt": "2021-07-17T13:25:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How can I create bound for conserved parameter in CH Equation?",
          "author": {
            "login": "ashiqueimran9539"
          },
          "bodyText": "I am trying to develop a phase-filed based code for sintering and I ran into some convergence issue. The conserved parameter c seems to turn negative at some points when it's suppose to be between 0 and 1. How can I enforce a bound to set the value between that range after each time step? So far I have tried using   BoundingValueNodalDamper,  LowerBoundNodalKernel and  ConstantBoundsAux to implement the bound but none of them worked as I had hoped.\n\nExample input file\n[GlobalParams]\n  op_num = 2\n  var_name_base = gr\n[]\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 80\n  ny = 40\n  xmin = 0\n  xmax = 40\n  ymin = 0\n  ymax = 20\n  elem_type = QUAD4\n  uniform_refine=2\n  []\n\n[Variables]\n  [./c]\n  [../]\n  [./w]\n  [../]\n  [./PolycrystalVariables] # Automatically creates order parameter variables\n  [../]\n  []\n\n[AuxVariables]\n  [./bnds]\n  [../]\n  [./force]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./free_energy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./unique_grains]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./var_indices]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./centroids]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./mobility]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./dt_w_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./ch_rbm_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./ch_wres_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./ch_parsed_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  #eta1_variables\n\n  [./eta1_dot_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./vdv_eta1_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./acint_eta1_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./acbulk_eta1_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  #eta2_variables\n\n  [./eta2_dot_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./vdv_eta2_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./acint_eta2_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./acbulk_eta2_residue]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./dummy_upper]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./dummy_lower]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n[]\n\n[Kernels]\n\n    #Added for splitting------------------------------------------------------\n\n    #gr0_kernels\n\n    [./eta1_dot]\n      type = TimeDerivative\n      variable = gr0\n      save_in=eta1_dot_residue\n    [../]\n    [./vadv_eta1]\n      # advection kernel corrsponding to AC equation\n      type = SingleGrainRigidBodyMotion\n      variable = gr0\n      c = c\n      v = gr0\n      grain_tracker_object = grain_center\n      grain_force = grain_force\n      grain_volumes = grain_volumes\n      save_in=vdv_eta1_residue\n    [../]\n    [./acint_eta1]\n      type = ACInterface\n      variable = gr0\n      mob_name = L\n      args = c\n      kappa_name = kappa_op\n      save_in=acint_eta1_residue\n    [../]\n    [./acbulk_eta1]\n      type = AllenCahn\n      variable = gr0\n      mob_name = L\n      f_name = f_loc\n      args = c\n      save_in=acbulk_eta1_residue\n    [../]\n\n    #eta2_kernels\n\n    [./eta2_dot]\n      type = TimeDerivative\n      variable = gr1\n      save_in=eta2_dot_residue\n    [../]\n    [./vadv_eta2]\n      # advection kernel corrsponding to AC equation\n      type = SingleGrainRigidBodyMotion\n      variable = gr1\n      c = c\n      v = gr1\n      grain_tracker_object = grain_center\n      grain_force = grain_force\n      grain_volumes = grain_volumes\n      save_in=vdv_eta2_residue\n    [../]\n    [./acint_eta2]\n      type = ACInterface\n      variable = gr1\n      mob_name = L\n      args = c\n      kappa_name = kappa_op\n      save_in=acint_eta2_residue\n    [../]\n    [./acbulk_eta2]\n      type = AllenCahn\n      variable = gr1\n      mob_name = L\n      f_name = f_loc\n      args = c\n      save_in=acbulk_eta2_residue\n    [../]\n\n#spliting-----------------------------------------------------\n\n\n  # Cahn Hilliard kernels\n  [./dt_w]\n    type = CoupledTimeDerivative\n    variable = w\n    v = c\n    save_in=dt_w_residue\n    [../]\n  [./CH_wres]\n    type = SplitCHWRes\n    variable = w\n    mob_name = D\n    save_in=ch_wres_residue\n  [../]\n  [./CH_Parsed]\n    type = SplitCHParsed\n    variable = c\n    f_name = f_loc\n    w = w\n    kappa_name = kappa_c\n    args = 'gr0 gr1' # Must be changed as op_num changes. Copy/paste from line 4\n    save_in=ch_parsed_residue\n    [../]\n  [./CH_RBM]\n    type = MultiGrainRigidBodyMotion\n    variable = w\n    c = c\n    v = 'gr0 gr1'\n    grain_force = grain_force\n    grain_volumes = grain_volumes\n    grain_tracker_object = grain_center\n    save_in=ch_rbm_residue\n  [../]\n[]\n\n[AuxKernels]\n\n  [./unique_grains]\n    type = FeatureFloodCountAux\n    variable = unique_grains\n    flood_counter = grain_center\n    field_display = UNIQUE_REGION\n    execute_on = timestep_begin\n  [../]\n  [./var_indices]\n    type = FeatureFloodCountAux\n    variable = var_indices\n    flood_counter = grain_center\n    field_display = VARIABLE_COLORING\n    execute_on = timestep_begin\n  [../]\n  [./centroids]\n    type = FeatureFloodCountAux\n    variable = centroids\n    execute_on = timestep_begin\n    field_display = CENTROID\n    flood_counter = grain_center\n  [../]\n  [./bnds]\n    type = BndsCalcAux\n    variable = bnds\n  [../]\n  []\n\n  [BCs]\n    [./bcs]\n      #zero flux BC\n      type = NeumannBC\n      value = 0\n      variable = c\n      boundary = '0 1 2 3'\n    [../]\n  []\n\n[Materials]\n\n  [./free_energy]\n    type = DerivativeParsedMaterial\n    f_name = f_loc\n    constant_names = 'A B'\n    constant_expressions = '16 1'\n    args = 'c gr0 gr1' #Must be changed as op_num changes. Copy/paste from line 4\n    function = 'A*c^2*(1-c)^2+B*(c^2+6*(1-c)*(gr0^2+gr1^2)\n                -4*(2-c)*(gr0^3+gr1^3)\n                +3*(gr0^2+gr1^2)^2)'\n                                 #Copy/paste from lines 5-6\n    derivative_order = 2\n    outputs=exodus\n  [../]\n  [./mobility]\n    type = PF_Sintering_Mobility_2\n    block=0\n    c=c\n    eta='gr0 gr1'\n    outputs=exodus\n  [../]\n  [./force_density]\n    type = ForceDensityMaterial\n    c = c\n    etas='gr0 gr1'\n  [../]\n[]\n\n[Postprocessors]\n  [./total_energy]\n    type = ElementIntegralVariablePostprocessor\n    variable = free_energy\n    execute_on = 'initial timestep_end'\n    outputs=exodus\n  [../]\n[]\n\n[VectorPostprocessors]\n  [./forces]\n    type = GrainForcesPostprocessor\n    grain_force = grain_force\n  [../]\n  [./grain_volumes]\n    type = FeatureVolumeVectorPostprocessor\n    flood_counter = grain_center\n    execute_on = 'initial timestep_begin'\n  [../]\n[]\n\n[UserObjects]\n  [./grain_center]\n    type = GrainTracker\n    outputs = none\n    compute_var_to_feature_map = true\n    execute_on = 'initial timestep_begin'\n  [../]\n  [./grain_force]\n    type = ComputeGrainForceAndTorque\n    grain_data = grain_center\n    c = c\n    etas = 'gr0 gr1'\n    force_density = force_density\n    execute_on = 'initial linear nonlinear'\n   [../]\n[]\n\n[Preconditioning]\n[./standard]\n  type = SMP\n  full = true\n  petsc_options = '-snes_converged_reason'\n  petsc_options_iname = '-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -snes_atol -snes_rtol -snes_max_it -ksp_rtol -ksp_atol'\n  petsc_options_value = 'gmres asm lu NONZERO 1E-10 1E-10 60 1E-20 1E-20'\n[../]\n[]\n\n[Bounds]\n  [./c_upper_bound]\n    type = ConstantBoundsAux\n    variable = dummy_upper\n    bounded_variable = c\n    bound_type = upper\n    bound_value = 1.0\n  [../]\n  [./c_lower_bound]\n    type = ConstantBoundsAux\n    variable = dummy_lower\n    bounded_variable = c\n    bound_type = lower\n    bound_value = 0.0001\n  [../]\n[]\n\n[Executioner]\n  # Preconditioned JFNK (default)\n  type = Transient\n  scheme = BDF2\n  solve_type = NEWTON\n  l_max_its = 35\n  l_tol = 1.0e-3\n  nl_rel_tol = 1.0e-10\n  start_time = 0.0\n  end_time = 100\n  dt = 0.1\n[]\n\n[Outputs]\n  exodus = true\n  perf_graph = true\n  [./display]\n    type = Console\n    max_rows = 12\n  [../]\n[]\n\n[ICs]\n  [./concentration_IC]\n    type = SpecifiedSmoothCircleIC\n    x_positions = '12 28'\n    y_positions = '10 10'\n    z_positions = '0   0  '\n    radii =       '7.5 7.5'\n    variable = c\n    invalue = 1.0\n    outvalue = 0.0\n    int_width = 4\n  [../]\n  [./gr0_IC]\n    type = SmoothCircleIC\n    variable = gr0\n    x1 = 12\n    y1 = 10\n    radius = 7.5\n    invalue = 1.0\n    outvalue = 0.0\n    int_width = 4\n  [../]\n  [./gr1_IC]\n    type = SmoothCircleIC\n    variable = gr1\n    x1 = 28\n    y1 = 10\n    radius = 7.5\n    invalue = 1.0\n    outvalue = 0.0\n    int_width = 4\n  [../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/18280",
          "updatedAt": "2022-06-14T11:50:23Z",
          "publishedAt": "2021-07-07T18:46:31Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "I'm not sure I fully understand the question- usually when we say \"convergence issue\" we are referring to the solver failing to converge or dropping to impractically small time steps. So did that also happen in addition to the order parameter going outside the range of 0 to 1? Or was it just that the order parameter went outside the range 0 to 1? (If so, that would not normally be referred to as a \"convergence issue\".)",
                  "url": "https://github.com/idaholab/moose/discussions/18280#discussioncomment-987023",
                  "updatedAt": "2022-06-14T11:50:24Z",
                  "publishedAt": "2021-07-09T22:53:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashiqueimran9539"
                          },
                          "bodyText": "Yes\nThe solver fails to converge and the time step drops to a very small value(until it reaches the set lower limit and kills the simulation).",
                          "url": "https://github.com/idaholab/moose/discussions/18280#discussioncomment-1004873",
                          "updatedAt": "2022-06-14T11:51:57Z",
                          "publishedAt": "2021-07-14T16:40:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Your free energy should diverge to infinity once you approach 0 (or 1) with a concentration order parameter. That's just the physics, you should not need to add unphysical bounds on concentration parameters. Your model does not exhibit this physical behavior as it is lacking entropy contributions.\nHowever if your system becomes severely nonlinear in these cases you can think about strategies to help the solver. Bounding to (0,1) is not a feasible strategy. Using Taylor expansions in the entropy terms is.\nP.S.: I edited your question to embed the input code. That's more convenient than downloading an attachment.",
                  "url": "https://github.com/idaholab/moose/discussions/18280#discussioncomment-1004914",
                  "updatedAt": "2022-06-14T11:51:56Z",
                  "publishedAt": "2021-07-14T16:47:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I didn't know you can use drop-down in GitHub markdown!",
                          "url": "https://github.com/idaholab/moose/discussions/18280#discussioncomment-1016107",
                          "updatedAt": "2022-06-14T11:51:56Z",
                          "publishedAt": "2021-07-17T13:22:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "can MOOSE do Multi-point constraints (MPCs)?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nI just wondering if MOOSE can perform Multi-point constraints (MPCs)?\nfrom a quick search, I see MOOSE has EqualValueEmbeddedConstraint https://mooseframework.inl.gov/moose/source/constraints/EqualValueEmbeddedConstraint.html\nBut this might not be what I am looking for\nI want something that can match 2 DOFs as follow\n\nThanks guys\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/18342",
          "updatedAt": "2023-11-07T03:11:29Z",
          "publishedAt": "2021-07-15T07:18:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "I think LinearNodalConstraint is the one\nhttps://mooseframework.inl.gov/source/constraints/LinearNodalConstraint.html\nDoes anyone know how to make a variable of node A = node B?\nwhat should I set the value of penalty and weights to?",
                  "url": "https://github.com/idaholab/moose/discussions/18342#discussioncomment-1011626",
                  "updatedAt": "2023-11-07T03:12:01Z",
                  "publishedAt": "2021-07-16T06:32:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If you are asking \"whether moose can do MPC\", the answer is definitely yes -- the infrastructure is there.\nBut I'm not sure if there are already some classes implemented for MPC. I think you are in the right direction. Classes like LinearNodalConstraint and EqualValueBoundaryConstraint can be a good starting point if you want to implement MPC in your own application.",
                  "url": "https://github.com/idaholab/moose/discussions/18342#discussioncomment-1015936",
                  "updatedAt": "2023-11-07T03:12:02Z",
                  "publishedAt": "2021-07-17T11:28:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The temperature only compute once in thermo-mechanical analysis",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hi there,\nI'm trying on a simple thermo-mechanical analysis of a rectangle plate, with the initial temperature 600K and the boundaries temperature as 300K, but the results shows the temperature only compute one time step and don't change anymore. What's missing of the problem? The input file is as follows. Thank you.\n_[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n[Mesh]\n  type = FileMesh\n  file = 'plate/plate.msh'\n[]\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [temperature]\n    initial_condition = 600.0\n  []\n[]\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = SMALL\n    eigenstrain_names = eigenstrain\n    use_automatic_differentiation = true\n    generate_output = 'vonmises_stress elastic_strain_xx elastic_strain_yy strain_xx strain_yy'\n  []\n[]\n[Kernels]\n  [heat_conduction]\n    type = ADHeatConduction\n    variable = temperature\n    thermal_conductivity = k\n  []\n  [heat_conduction_time_derivative]\n    type = ADHeatConductionTimeDerivative\n    variable = temperature\n    density_name = rho\n    specific_heat = c\n  []\n[]\n[BCs]\n  [x_symmetry]\n    type = DirichletBC\n    variable = disp_x\n    boundary = right\n    value = 0\n  []\n  [heatflux_symmetry]\n    type = NeumannBC\n    variable = temperature\n    boundary = right\n    value = 0\n  []\n  [Temperature_fix_left]\n    type = DirichletBC\n    variable = temperature\n    boundary = left\n    value = 300\n  []\n  [Temperature_fix_top]\n    type = DirichletBC\n    variable = temperature\n    boundary = top\n    value = 300\n  []\n  [Temperature_fix_bottom]\n    type = DirichletBC\n    variable = temperature\n    boundary = bottom\n    value = 300\n  []\n[]\n\n[Materials]\n  [bulk]\n    type = ADGenericConstantMaterial\n    prop_names = 'rho c k'\n    prop_values = ' ${rho} ${c} ${k}'\n  []\n  [./elasticity_tensor]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 218.4e3\n    poissons_ratio = 0.2\n  [../]\n  [./stress]\n    type = ADComputeLinearElasticStress\n  [../]\n  [thermal_strain]\n    type = ADComputeThermalExpansionEigenstrain\n    stress_free_temperature = 300\n    eigenstrain_name = eigenstrain\n    temperature = temperature\n    thermal_expansion_coeff = 7.5e-6\n  []\n[]\n[Executioner]\n  type = Transient\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu       superlu_dist                 '\n  automatic_scaling = true\n  dt = 0.1e-6\n  end_time = 200e-6\n  nl_rel_tol = 1e-08\n  nl_abs_tol = 1e-10\n\n  picard_max_its = 100\n  picard_abs_tol = 1e-50\n  picard_rel_tol = 1e-03\n  accept_on_max_picard_iteration = true\n[]\n[Outputs]\n  exodus = true\n[]__",
          "url": "https://github.com/idaholab/moose/discussions/18326",
          "updatedAt": "2022-08-13T03:37:20Z",
          "publishedAt": "2021-07-14T08:36:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou expect the solution to be slow cooling from 600 to 300K ?\nWhat does it stop at?\nbtw\n\n\nyou have a bunch of deprecated Picard iteration parameters at the bottom of your input. Use fixed_point_ instead of picard_ there.\nIf you dont have a multiapps setup I dont think you need them either.\n\n\nwhen using automatic_differentiation, you want to use Newton to solve the system, not PJFNK, because AD provides you with a good jacobian\n\n\nWe'll tag some mechanics people on this\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1004554",
                  "updatedAt": "2022-08-29T13:59:32Z",
                  "publishedAt": "2021-07-14T15:38:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thank you.\nYes, I want to cool it down, and the simulation continues to the end, but the result shows the temperature only changes from 0 to the first time step and doesn't change in the following steps.\nYes, the code above is part of a multiapps setup, which has problems. I'm trying to figure what's wrong by commenting multiapps part out. Thanks for reminding that.",
                          "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1004905",
                          "updatedAt": "2023-11-03T13:16:54Z",
                          "publishedAt": "2021-07-14T16:46:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The initial condition of the temperature is 600 not 0 though?",
                          "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1004968",
                          "updatedAt": "2023-11-03T13:16:54Z",
                          "publishedAt": "2021-07-14T17:00:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Yes, the initial conditions of the temperature is set as 600, cooling to 300",
                          "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1005004",
                          "updatedAt": "2023-11-03T13:17:11Z",
                          "publishedAt": "2021-07-14T17:10:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh ok I misread 0 as the initial value not the time.\n@hugary1995 any idea what is going wrong here?",
                          "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1005030",
                          "updatedAt": "2023-11-03T13:17:14Z",
                          "publishedAt": "2021-07-14T17:14:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "What are your thermal material properties and how long do you expect it to take to cool down? You are only running your model for 200E-6 seconds so for it to get to equilibrium 300 K in that time would require a mean cooling rate of 1.5 million K/s, is that what you are intending? Do you need to run at such a small time step? I suspect your time scales need to be closer to orders of 10s of seconds to see some temperature changes in its current form.",
                          "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1007683",
                          "updatedAt": "2023-11-03T13:17:16Z",
                          "publishedAt": "2021-07-15T08:49:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thanks for replying.\nYes, that's a good point, I'll try that. But even though the end time is small, it has 2000 time steps, the question is the temperature only changes in the first time step and keeps the same in the rest.",
                          "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1009750",
                          "updatedAt": "2022-08-29T13:59:32Z",
                          "publishedAt": "2021-07-15T17:31:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Does changing the time step fix it?\nIf not, I dont see the definitions for ${rho} ${c} ${k}' in your input file? What are those values? Extreme values here could affect the solution",
                          "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1011092",
                          "updatedAt": "2022-08-29T13:59:33Z",
                          "publishedAt": "2021-07-16T01:44:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "So the first time step is effectively finding the initial solution that meets your initial conditions (as my understanding works, correct me if I'm wrong). In the rest of your current scenario the temperature will be changing but very insignificantly - have you checked the numbers to see if they are changing at all? The number of time steps does not matter, it is the total time. Think of it like this: if you cook something in the oven at 200 C (so roughly 500 K), when you take it out and serve it at room temperature (roughly 300 K), it will stay warm for a long time (many minutes). How often you check it (equivalent to the number of time steps) does not matter as the physics doesn't care how often you measure it, it is how long you leave it for (the total model time) that matters.",
                          "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1012311",
                          "updatedAt": "2022-08-29T13:59:33Z",
                          "publishedAt": "2021-07-16T09:38:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@GiudGiud @ABallisat Yes, it is the matter of time scale. When I set dt=1e-3 and total time = 200e-3, the temperature transfers all the way to the end. But what I do not quite understand is when the total time is smaller, shouldn't the temperature change more dramatically than a longer time scale? Why does it not change anymore in the rest steps of the total time of 200e-6?",
                          "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1013543",
                          "updatedAt": "2022-08-29T13:59:33Z",
                          "publishedAt": "2021-07-16T14:44:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "changing how long you simulate the system does not change the way the real system would evolve.\nIf it takes 10 second to cool down by 50K in the real world, then if you only simulate 200 micros you won't see much of that cooling happen.",
                          "url": "https://github.com/idaholab/moose/discussions/18326#discussioncomment-1013615",
                          "updatedAt": "2022-08-29T13:59:33Z",
                          "publishedAt": "2021-07-16T15:01:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}