{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wMy0yM1QwOToxODoyNC0wNjowMM4AS8Lo"
    },
    "edges": [
      {
        "node": {
          "title": "Shape Functions and Node",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "Within an element, are the order of the nodes and the order of the shape functions the same? If I know that a node is the third node of the element, does the third \"phi\" correspond to that node?",
          "url": "https://github.com/idaholab/moose/discussions/23841",
          "updatedAt": "2023-03-25T21:05:55Z",
          "publishedAt": "2023-03-25T20:21:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Within an element, are the order of the nodes and the order of the shape functions the same? If I know that a node is the third node of the element, does the third \"phi\" correspond to that node?\n\nThat should be the case.\n@maxnezdyur btw, are you a hurricane fan?",
                  "url": "https://github.com/idaholab/moose/discussions/23841#discussioncomment-5428837",
                  "updatedAt": "2023-03-25T21:03:54Z",
                  "publishedAt": "2023-03-25T21:03:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Perfect, that's what I was hoping for. Of course, always supporting my Canes.",
                          "url": "https://github.com/idaholab/moose/discussions/23841#discussioncomment-5428842",
                          "updatedAt": "2023-03-25T21:05:52Z",
                          "publishedAt": "2023-03-25T21:05:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "BAD TERMINATION",
          "author": {
            "login": "Richard-happy"
          },
          "bodyText": "Hello,when I ran my input file, it was OK using 202020 mesh. However, it seemed someting went wrong when using 505050 mesh.Here is the report.\n===================================================================================\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 13193 RUNNING AT ml64\n=   EXIT CODE: 9\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\n===================================================================================\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Killed (signal 9)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions\n\nAnd my input file is appended.\nnonlinear_TE.txt",
          "url": "https://github.com/idaholab/moose/discussions/23836",
          "updatedAt": "2023-03-25T10:46:02Z",
          "publishedAt": "2023-03-24T13:49:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "Using your input, a simulation with a 50x50x50 mesh contains quite a large number of nonlinear DoFs (530,000+) and over 1.5 million auxiliary DoFs. My first guess would be that you ran out of memory on your machine.  I ran this input over 10 cores on a laptop with 64GB of RAM, and it was quickly filled up.\nMy suggestion is to coarsen the mesh to something less than 50x50x50. For a simple input like you've shown here, you should be able to get by with something much less fine. If you end up deciding that refinement is necessary as your input file becomes more complex, look into mesh adaptivity or running this on a higher memory machine (like a cluster or HPC system).",
                  "url": "https://github.com/idaholab/moose/discussions/23836#discussioncomment-5420716",
                  "updatedAt": "2023-03-24T16:41:30Z",
                  "publishedAt": "2023-03-24T16:41:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Richard-happy"
                          },
                          "bodyText": "OK, thank you for your suggestion, cticenhour",
                          "url": "https://github.com/idaholab/moose/discussions/23836#discussioncomment-5425905",
                          "updatedAt": "2023-03-25T10:45:56Z",
                          "publishedAt": "2023-03-25T10:45:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solve Did NOT Converge when the BC for simple diffusion problem is large",
          "author": {
            "login": "lipxisi"
          },
          "bodyText": "Hello\nI create a simple diffusion problem like example02 where the diffusion coefficient and absorption coefficient are 0.008 and 0.085. At runtime, it is found that when the bottom boundary is very large for example, the bottom is 1e10 and no top BC, the calculation does not converge but it converges when it's less than a certain value like 1e6. Supposedly, the value at the bottom only magnifies or diminishes the calculated result, and will not affect the convergence. So  why it doesn't converge when the boundary conditions are large, and how to solve these problems. In addition, I want to ask what the terminal output 17 Linear |R| = 6.686767e+03 and 200 Nonlinear |R| = 4.442370e+08 represent.\nThanks very much",
          "url": "https://github.com/idaholab/moose/discussions/23827",
          "updatedAt": "2023-03-24T22:43:20Z",
          "publishedAt": "2023-03-23T09:05:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\ncan you turn on automatic scaling in the executioner block?\nthere are other threads that explain what the residual is, I ll try to paste one later today\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23827#discussioncomment-5406833",
                  "updatedAt": "2023-03-23T14:20:20Z",
                  "publishedAt": "2023-03-23T14:20:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lipxisi"
                  },
                  "bodyText": "Thanks Guillaume\nI used automatic_scaling = true, nl_rel_tol=1e-04 and nl_abs_tol=1e-04, then the problem converging.\n2363 Nonlinear |R| = 5.338276e+07\n0 Linear |R| = 5.338276e+07\n1 Linear |R| = 2.127353e+06\n2 Linear |R| = 4.831955e+05\n3 Linear |R| = 1.575160e+05\n4 Linear |R| = 5.433509e+04\n5 Linear |R| = 2.601507e+04\n6 Linear |R| = 1.455736e+04\n7 Linear |R| = 8.501569e+03\n8 Linear |R| = 5.372774e+03\n9 Linear |R| = 3.722465e+03\n10 Linear |R| = 3.015211e+03\n11 Linear |R| = 2.499467e+03\n12 Linear |R| = 1.227849e+03\n13 Linear |R| = 2.657926e+02\n2364 Nonlinear |R| = 2.766357e+06\nSolve Converged!\nSo what is the mean of  2364 Nonlinear |R| = 2.766357e+06, whether the converging is valid or not.",
                  "url": "https://github.com/idaholab/moose/discussions/23827#discussioncomment-5417641",
                  "updatedAt": "2023-03-24T12:53:47Z",
                  "publishedAt": "2023-03-24T12:53:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The petsc manual is the best reference for the meaning of the non linear residual\nhttps://petsc.org/release/docs/manual/snes/",
                          "url": "https://github.com/idaholab/moose/discussions/23827#discussioncomment-5423455",
                          "updatedAt": "2023-03-24T22:43:21Z",
                          "publishedAt": "2023-03-24T22:43:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Forcing function using an Aux Variable",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "for a transient heat transfer problem can I update the value of my variable in my problem domain prior to the next time step, with the value of an aux variable value at the nearest neighboring mesh and then solve the next time step with the imposed value?",
          "url": "https://github.com/idaholab/moose/discussions/23835",
          "updatedAt": "2023-04-29T03:07:21Z",
          "publishedAt": "2023-03-24T05:51:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe typically do not allow modifying nonlinear variable values but you can do it using a MultiApp. You send the value you want to impose then send them back using a transfer.\nThe cannon way to do this would be to write a UserObject that modifies the nonlinear variables. We dont have one that can do what you want afaik\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23835#discussioncomment-5417109",
                  "updatedAt": "2023-03-24T11:52:52Z",
                  "publishedAt": "2023-03-24T11:52:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "I was able to use the MultiApp to transfer between APPs. I noticed that the transferred value smears the solutions and seems to override the contribution of the original solutions.",
                          "url": "https://github.com/idaholab/moose/discussions/23835#discussioncomment-5420034",
                          "updatedAt": "2023-03-24T15:42:43Z",
                          "publishedAt": "2023-03-24T15:42:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Here is a snapshot of what the solutions look like.",
                          "url": "https://github.com/idaholab/moose/discussions/23835#discussioncomment-5420522",
                          "updatedAt": "2023-03-24T16:22:33Z",
                          "publishedAt": "2023-03-24T16:22:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Well whether it smears or not depends on the algorithm in the transfer\nIf you use the exact same mesh and the exact same variable type (finitelement family and order) the copy transfer will not smear",
                          "url": "https://github.com/idaholab/moose/discussions/23835#discussioncomment-5423036",
                          "updatedAt": "2023-03-24T21:26:17Z",
                          "publishedAt": "2023-03-24T21:26:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Coding dirichletbc from material property",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "I have written the include and src files for executing Dirichlet boundary condition taking values from material property. This runs well on simple problems. However, this is leading to convergence issues for complex problems. I have used IntegratedBC as the parent class. Please look into my code (attached)\nheader file\n#pragma once\n\n#include \"IntegratedBC.h\"\n\nclass EgMatDirichlet : public IntegratedBC\n{\npublic:\n  EgMatDirichlet(const InputParameters & parameters);\n\n  static InputParameters validParams();\n\nprotected:\n  virtual Real computeQpResidual() override;\n\nprivate:\n  const MaterialProperty<Real> & _boundary_prop;\n};\n\nsrc file\n#include \"EgMatDirichlet.h\"\n\nregisterMooseObject(\"goldfishApp\", EgMatDirichlet);\n\nInputParameters\nEgMatDirichlet::validParams()\n{\n  InputParameters params = IntegratedBC::validParams();\n\n  // Specify input parameters that we want users to be able to set:\n  params.addRequiredParam<MaterialPropertyName>(\"boundary_material\", \"Value on the boundary\");\n  return params;\n}\n\nEgMatDirichlet::EgMatDirichlet(const InputParameters & parameters)\n  : IntegratedBC(parameters),\n    // store the user-specified parameters from the input file...\n    _boundary_prop(getMaterialProperty<Real>(\"boundary_material\"))\n    \n{\n}\n\nReal\nEgMatDirichlet::computeQpResidual()\n{\n  \n  return _boundary_prop[_qp] - _u[_qp];\n}",
          "url": "https://github.com/idaholab/moose/discussions/23797",
          "updatedAt": "2023-03-27T04:11:50Z",
          "publishedAt": "2023-03-21T06:47:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nYou are missing the contribution to the Jacobian. Does it converge with PJFNK for the solve_type?\nYou should just use AD to make this boundary condition and it will handle that part if you want to make it work with Newton\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5382970",
                  "updatedAt": "2023-03-21T15:51:10Z",
                  "publishedAt": "2023-03-21T15:51:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Yes, it converges with PJFNK for a simple diffusion problem. However, when i have two coupled equations is fails to converge.\nAs per your suggestion I have used AD with PJFNK solver. It converges now, however computation time is too long.",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5389402",
                          "updatedAt": "2023-03-22T07:02:01Z",
                          "publishedAt": "2023-03-22T07:02:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "It looks like you are using an integrated BC class to set a Dirichlet BC. I think you need a penalty parameter to have the values match closer. You will also need to multiply by the test function.  Try the below:\nreturn _penalty * _test[_i][_qp] * (_u[_qp] - _boundary_prop[_qp]); where _penalty is a large number like 1e7 (problem dependent).",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5391786",
                          "updatedAt": "2023-03-22T11:10:59Z",
                          "publishedAt": "2023-03-22T11:10:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Yes, I am using ADIntegratedBC class as for ADNodalBC I couldn't find the getADMaterialProperty<Real> as a Public Member Function.\nIs there a way to do this for ADNodalBC ? (I have a limited knowledge of C++)\nI tried your method, but this also leads to non-convergence for the simple diffusion problem\nADReal\nADEgMatDirichlet::computeQpResidual()\n{\n  Real penalty = 1e7;\n  return penalty * _test[_i][_qp] * (_u[_qp] - _boundary_prop[_qp]);\n}\n\nmy input file for simple diffusion:\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    xmin = 0\n    xmax = 200e-6\n    nx = 200\n[]\n  \n[Variables]\n    [c]\n    []\n[]\n\n# Initial conditions.\n[ICs]\n    [conc]\n        variable = c\n        type = FunctionIC\n        function = ic_func_c\n    []\n[]\n\n[BCs]\n    [left_c]\n        type = DirichletBC\n        variable = c\n        boundary = 'left'\n        value = 1000\n    []\n    [right_c]\n        type = ADEgMatDirichlet\n        variable = c\n        boundary = 'right'\n        boundary_material=bndconst\n    []\n[]\n  \n[Functions]\n    [ic_func_c]\n        type = ParsedFunction\n        expression = 1000\n    []\n[]\n  \n[Kernels]\n    [cdot]\n        type = TimeDerivative\n        variable = c\n    []\n    [c_diff]\n        type=MatDiffusion\n        diffusivity= 7.5e-11\n        variable = c\n    []\n[]\n\n\n[Materials]\n    [matconstant]\n        type = ADGenericConstantMaterial\n        prop_names = 'bndconst'\n        prop_values = '300'\n    []\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'PJFNK'\n    dt=2\n    end_time = 200\n[]\n\n[Postprocessors]\n    [left_c]\n      type = PointValue\n      point = '0 0 0'\n      variable = c\n    []\n    [right_phi]\n      type = PointValue\n      point = '200e-6 0 0'\n      variable = c\n    []\n  \n  []\n[Outputs]\n    exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5393414",
                          "updatedAt": "2023-03-22T13:55:25Z",
                          "publishedAt": "2023-03-22T13:55:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Material properties aren\u2019t well defined on nodes because nodes can be shared between subdomains and we wouldn\u2019t know which subdomain to pick to evaluate the property (their expression can vary by subdomain)\nhence why there is not getMatProp on nodal classes\nnow that you are using AD, does Newton converge with the old integrated BC?",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5393539",
                          "updatedAt": "2023-03-22T14:06:26Z",
                          "publishedAt": "2023-03-22T14:06:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Thanks for the help.\nNewton converges for the diffusion problem. However the constant material property value 300 is showing in postprocessor as 2.999999e+02 :\ntime           | left_c         | right_c        |\n+----------------+----------------+----------------+\n:                :                :                :\n|   1.905000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.907500e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.912500e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.915000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.920000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.925000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.935000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.945000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.950000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.960000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.980000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.990000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.992500e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.995000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   2.000000e+02 |   1.000000e+03 |   2.999999e+02 |\n\nHowever, in case of my original problem newton doesn't converges at all.\nPJFNK works well with DirichletBC and the computation time is almost double for ADEgMatDirichlet",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5400386",
                          "updatedAt": "2023-03-23T04:50:41Z",
                          "publishedAt": "2023-03-23T04:27:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in ADEgMatDirichlet, how do you retrieve the material property?\nIs this an AD material property? If not you re still missing terms in the Jacobian",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5400427",
                          "updatedAt": "2023-03-23T04:35:55Z",
                          "publishedAt": "2023-03-23T04:35:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "vermaprk"
                  },
                  "bodyText": "ADEgMatDirichlet.C\n#include \"ADEgMatDirichlet.h\"\n\nregisterMooseObject(\"goldfishApp\", ADEgMatDirichlet);\n\nInputParameters\nADEgMatDirichlet::validParams()\n{\n  InputParameters params = ADIntegratedBC::validParams();\n\n  // Specify input parameters that we want users to be able to set:\n  params.addRequiredParam<MaterialPropertyName>(\"boundary_material\", \"Value on the boundary\");\n  return params;\n}\n\nADEgMatDirichlet::ADEgMatDirichlet(const InputParameters & parameters)\n  : ADIntegratedBC(parameters),\n    // store the user-specified parameters from the input file...\n    _boundary_prop(getADMaterialProperty<Real>(\"boundary_material\"))\n    \n{\n}\n\nADReal\nADEgMatDirichlet::computeQpResidual()\n{\n  \n  return _boundary_prop[_qp] - _u[_qp];\n}\n\nAnd the input file material block is:\n[Materials]\n    [matconstant]\n        type = ADGenericConstantMaterial\n        prop_names = 'bndconst'\n        prop_values = '300'\n    []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5400548",
                  "updatedAt": "2023-03-23T05:06:54Z",
                  "publishedAt": "2023-03-23T05:06:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "shouldn't it be\n_u[_qp] - _boundary_prop[_qp];",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5400606",
                          "updatedAt": "2023-03-23T05:19:12Z",
                          "publishedAt": "2023-03-23T05:19:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "vermaprk"
                  },
                  "bodyText": "Aren't both same, as the residue has to be near to zero.\nI tried the following change on simplediffusion.i.\nADReal\nADEgMatDirichlet::computeQpResidual()\n{\n  \n  return _u[_qp] - _boundary_prop[_qp];\n}\n\nThe postprocessor gives:\nPostprocessor Values:\n+----------------+----------------+----------------+\n| time           | left_c         | right_c        |\n+----------------+----------------+----------------+\n:                :                :                :\n|   1.785000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.795000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.815000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.835000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.855000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.875000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.895000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.915000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.925000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.945000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.965000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.975000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.985000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.992500e+02 |   1.000000e+03 |   3.000001e+02 |\n|   2.000000e+02 |   1.000000e+03 |   3.000001e+02 |\n+----------------+----------------+----------------+\n\nInterestingly, this change made in ADEgMatDirichlet leads to convergence issue on the original problem at the end time steps for PJFNK. Before, this change the code was running completely with PJFNK.\nSolve Did NOT Converge!\nAborting as solve did not converge\n\nTime Step 177, time = 199.999, dt = 1e-13\n 0 Nonlinear |R| = 4.105825e-06\n      0 Linear |R| = 4.105825e-06\n      1 Linear |R| = 8.327757e-13\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\n\n*** ERROR ***\nThe following error occurred in the object \"TimeStepper\", of type \"ConstantDT\".\n\nSolve failed and timestep already at or below dtmin, cannot continue!",
                  "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5402688",
                  "updatedAt": "2023-03-23T08:57:36Z",
                  "publishedAt": "2023-03-23T08:57:35Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is not a real divergence.\nTime Step 177, time = 199.999, dt = 1e-13\n0 Nonlinear |R| = 4.105825e-06\n0 Linear |R| = 4.105825e-06\n1 Linear |R| = 8.327757e-13\nyou're converged, but the solver tries to take a 1e-13 timestep and it throws everything off\nif you increase the timestep_tol to 1e-12 this will be fixed\nCould you please paste the log for the Newton solve_type?",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5407535",
                          "updatedAt": "2023-03-23T15:12:05Z",
                          "publishedAt": "2023-03-23T15:12:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Please find the log file for newton attached.\nnohup.txt\ninput file:\nalpha = 0.5\ncinit = 1000\ncmax = 3920\nDLi = 7.5e-11\nR_const = 8.314\nF_const = 96487\nka = 1e-10\nt0 = 0.36\nI_app = -10\nT = 300\n\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    xmin = 0\n    xmax = 200e-6\n    nx = 200\n[]\n\n[Variables]\n    [c]\n    []\n    [phi]\n    []\n[]\n\n# Initial conditions.\n[ICs]\n    [conc]\n        variable = c\n        type = FunctionIC\n        function = ic_func_c\n    []\n[]\n\n[BCs]\n    [left_c]\n        type = ADMatNeumannBC\n        variable = c\n        boundary = 'left'\n        value = 1\n        boundary_material = Nflux\n    []\n    # [right_c]\n    #     type = ADMatNeumannBC\n    #     variable = c\n    #     boundary = 'right'\n    #     value = -1\n    #     boundary_material = Nflux\n    # []\n    [right_c]\n        type = ADEgMatDirichlet\n        variable = c\n        boundary = 'right'\n        boundary_material=bndconst\n    []\n    # [right_c]\n    #         type = ADDirichletBC\n    #         variable = c\n    #         boundary = 'right'\n    #         value = 300\n    #     []\n    [left_phi]\n        boundary = 'left'\n        type = MatDirichletBC\n        variable = phi\n        alpha = '${alpha}'\n        Iapp = '${I_app}'\n        cmax = '${cmax}'\n        temp = '${T}'\n        ka = '${ka}'\n        some_var = c\n    []\n[]\n\n[AuxVariables]\n    [velocity]\n        family = LAGRANGE_VEC\n    []\n[]\n\n[AuxKernels]\n    [vec]\n        type = VectorFunctionAux\n        variable = velocity\n        function = velocity_func\n        execute_on = 'INITIAL TIMESTEP_END'\n    []\n[]\n\n[Functions]\n    [velocity_func]\n        type = ParsedVectorFunction\n        expression_x = '1'\n    []\n\n    [ic_func_c]\n        type = ParsedFunction\n        expression = '${cinit}'\n    []\n[]\n\n[Kernels]\n    [cdot]\n        type = TimeDerivative\n        variable = c\n    []\n    [c_diff]\n        type=ADMatDiffusion\n        diffusivity='${DLi}'\n        variable = c\n    []\n    [c_mig]\n        type=ExampleMigration\n        variable = phi\n        velocity = velocity\n        reaction_rate = coeff_mig\n        v=c\n    []\n    [advection]\n        type = LevelSetAdvection\n        velocity = velocity\n        variable = phi\n    []\n\n    [rhs]\n        type = ADMaterialPropertyValue\n        variable = phi\n        prop_name = IbyK\n    []\n[]\n\n[Materials]\n    [matconstant]\n        type = ADGenericConstantMaterial\n        prop_names = 'bndconst'\n        prop_values = '1000'\n    []\n    [Boundaryflux]\n        type = ADParsedMaterial\n        property_name = Nflux\n        expression = '${I_app}/${F_const}'\n    []\n    [migrationcoeff]\n        type = ADParsedMaterial\n        property_name = coeff_mig\n        expression = '(2*${R_const}*${T}*(1-${t0}))/(${F_const})'\n    []\n    [ionicconductivity]\n        type = ADParsedMaterial\n        coupled_variables = 'c'\n        property_name = kappa\n        expression = '0.1147*exp(520/${R_const}*(1/298-1/${T}))*(c/1000)^3\n                        -2.238*exp(1010/${R_const}*(1/298-1/${T}))*(c/1000)^1.5\n                        +2.915*exp(1270/${R_const}*(1/298-1/${T}))*(c/1000)'\n        outputs = exodus\n    []\n    [IbyK]\n        type = ADParsedMaterial\n        property_name = IbyK\n        material_property_names = 'kappa'\n        expression = '${I_app}/kappa'\n        outputs = exodus\n    []\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'Newton'\n    # solve_type = 'PJFNK'\n    dt = 0.2\n    end_time = 200\n[]\n\n[Postprocessors]\n    [left_phi]\n      type = PointValue\n      point = '0 0 0'\n      variable = phi\n    []\n    [right_phi]\n      type = PointValue\n      point = '200e-6 0 0'\n      variable = phi\n    []\n    [right_c]\n        type = PointValue\n        point = '200e-6 0 0'\n        variable = c\n    []\n    [I0]\n        type = ParsedPostprocessor\n        function = '${F_const}*${ka}*pow((${cmax}-right_c),${alpha})*pow(right_c,${alpha})'\n        pp_names = 'right_c'\n    []\n    [voltage]\n        type = ParsedPostprocessor\n        function = 'right_phi + (${R_const}*${T})/(${alpha}*${F_const})*(asinh(${I_app}/I0))'\n        pp_names = 'right_phi I0'\n    []\n[]\n\n\n[Outputs]\n    exodus = true\n    [./csv]\n        type = CSV\n    [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5413579",
                          "updatedAt": "2023-03-24T05:13:45Z",
                          "publishedAt": "2023-03-24T04:45:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Try the code and input file below.\n\nI think you need to scale your problem. I think there are some conditioning problems.\nI think that for an integrateBC to model a DirichletBC like you want it needs to be in the form written below\nIn my previous post, I said the penalty term is problem dependent. Using 1e2 as the penalty parameter, the solution converges and is accurate (post processor attached below).\nI think the reason your problem worked somewhat for _u[_qp] - _boundary_prop[_qp] as the BC is because of the parameters you had, but as I increased the diffusivity, the BC below would still be accurate but the _u[_qp] - _boundary_prop[_qp] method would get progressively worse results.\n\n#include \"EgMatDirichlet.h\"\n\nregisterMooseObject(\"goldfishApp\", EgMatDirichlet);\n\nInputParameters\nEgMatDirichlet::validParams()\n{\n  InputParameters params = ADIntegratedBC::validParams();\n\n  // Specify input parameters that we want users to be able to set:\n  params.addRequiredParam<MaterialPropertyName>(\"boundary_material\", \"Value on the boundary\");\n  params.addRequiredParam<Real>(\"penalty\", \"Penalty to enforce the boundary condition.\");\n  return params;\n}\n\nEgMatDirichlet::EgMatDirichlet(const InputParameters & parameters)\n  : ADIntegratedBC(parameters),\n    // store the user-specified parameters from the input file...\n    _boundary_prop(getADMaterialProperty<Real>(\"boundary_material\")),\n    _penalty(getParam<Real>(\"penalty\"))\n{\n}\n\nADReal\nEgMatDirichlet::computeQpResidual()\n{\n  return _penalty * _test[_i][_qp] * (_u[_qp] - _boundary_prop[_qp]);\n}\n\n\n#pragma once\n\n#include \"ADIntegratedBC.h\"\n\nclass EgMatDirichlet : public ADIntegratedBC\n{\npublic:\n  EgMatDirichlet(const InputParameters & parameters);\n\n  static InputParameters validParams();\n\nprotected:\n  virtual ADReal computeQpResidual() override;\n\nprivate:\n  const ADMaterialProperty<Real> & _boundary_prop;\n  Real _penalty;\n};\n\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    xmin = 0\n    xmax = 200e-6\n    nx = 200\n[]\n\n[Variables]\n    [c]\n    []\n[]\n\n# Initial conditions.\n[ICs]\n    [conc]\n        variable = c\n        type = FunctionIC\n        function = ic_func_c\n    []\n[]\n\n[BCs]\n    [left_c]\n        type = DirichletBC\n        variable = c\n        boundary = 'left'\n        value = 1000\n    []\n    [right_c]\n        type = EgMatDirichlet\n        variable = c\n        boundary = 'right'\n        boundary_material=bndconst\n        penalty = 1e2\n    []\n[]\n\n[Functions]\n    [ic_func_c]\n        type = ParsedFunction\n        expression = 1000\n    []\n[]\n\n[Kernels]\n    [cdot]\n        type = TimeDerivative\n        variable = c\n    []\n    [c_diff]\n        type=MatDiffusion\n        diffusivity= 7.5e-11\n        variable = c\n    []\n[]\n\n\n[Materials]\n    [matconstant]\n        type = ADGenericConstantMaterial\n        prop_names = 'bndconst'\n        prop_values = '300'\n    []\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    dt=2\n    end_time = 200\n    nl_abs_tol = 1e-10\n[]\n\n[Postprocessors]\n    [left_c]\n      type = PointValue\n      point = '0 0 0'\n      variable = c\n    []\n    [right_phi]\n      type = PointValue\n      point = '200e-6 0 0'\n      variable = c\n    []\n\n  []\n[Outputs]\n    exodus = true\n[]\n\nTime Step 100, time = 200, dt = 2\n 0 Nonlinear |R| = 2.257844e-06\n      0 Linear |R| = 2.257844e-06\n      1 Linear |R| = 5.617709e-20\n 1 Nonlinear |R| = 1.234283e-12\n Solve Converged!\n\nPostprocessor Values:\n+----------------+----------------+----------------+\n| time           | left_c         | right_phi      |\n+----------------+----------------+----------------+\n:                :                :                :\n|   1.720000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.740000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.760000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.780000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.800000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.820000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.840000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.860000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.880000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.900000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.920000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.940000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.960000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.980000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   2.000000e+02 |   1.000000e+03 |   3.000000e+02 |\n+----------------+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5416919",
                          "updatedAt": "2023-03-24T11:30:51Z",
                          "publishedAt": "2023-03-24T11:30:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Strange Stress Concentrations on Periodic RVE",
          "author": {
            "login": "Zoophish"
          },
          "bodyText": "Hi,\nI'm running a small strain model of an RVE using the homogenisation system in the new tensor mechanics system. I've noticed I get these unphyiscal looking stress concentrations on the boundaries. I'm following the test case given in this paper and it is clear that their model does not give these stress concentrations. I am using TET4 elements instead of HEX8 as I cannot mesh hex elements.\nThe artifact (this example is with the xx homogenisation stress constraint):\n\nRescaling the colour bar reveals the stresses (around the corners) which roughly match the paper I am following:\n\nFor clarity, it should look something like this:\n\nMy input file and mesh file is here:\ninput_file_mesh.zip\nIf this looks familiar, any help or pointers on what could be causing this would be greatly appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/23830",
          "updatedAt": "2023-03-24T11:26:16Z",
          "publishedAt": "2023-03-23T17:24:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The paper's mesh looks finer and more regular.\nCould you please refine your mesh to see if the issue disappears?\nThere's a uniform refinement option in MOOSE if you dont want to go back to your meshing software",
                  "url": "https://github.com/idaholab/moose/discussions/23830#discussioncomment-5409437",
                  "updatedAt": "2023-03-23T17:28:38Z",
                  "publishedAt": "2023-03-23T17:28:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Zoophish"
                          },
                          "bodyText": "I reduced the element size in gmsh and it seems have fixed the artefact on my validation case.\n\nThanks for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/23830#discussioncomment-5416880",
                          "updatedAt": "2023-03-24T11:26:14Z",
                          "publishedAt": "2023-03-24T11:26:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "TET4 is a bad choice for solid mechanics...",
                  "url": "https://github.com/idaholab/moose/discussions/23830#discussioncomment-5410588",
                  "updatedAt": "2023-03-23T19:45:56Z",
                  "publishedAt": "2023-03-23T19:45:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to apply a pressure load on the surface of a shell element \uff1f",
          "author": {
            "login": "tttsss-01"
          },
          "bodyText": "I want to use shell elements to simulate the pressure load inside a cylinder, how to do it?\nPressure in BCs doesn't seem to be able to handle this.",
          "url": "https://github.com/idaholab/moose/discussions/23711",
          "updatedAt": "2023-04-21T16:32:36Z",
          "publishedAt": "2023-03-14T06:31:23Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@neuphris @recuero on shell elements",
                  "url": "https://github.com/idaholab/moose/discussions/23711#discussioncomment-5307174",
                  "updatedAt": "2023-03-14T14:37:08Z",
                  "publishedAt": "2023-03-14T14:37:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You need to implement a custom body force kernel for this. PR welcome.",
                  "url": "https://github.com/idaholab/moose/discussions/23711#discussioncomment-5410739",
                  "updatedAt": "2023-03-23T20:03:16Z",
                  "publishedAt": "2023-03-23T20:03:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "'EffectiveStrain' in 'RankTwoScalarTools'",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hi MOOSEer,\nI try to calculate/use the equivalent plastic strain as shows https://mooseframework.inl.gov/source/utils/RankTwoScalarTools.html\nand discussed here #20979 and the input as\n\n[Auxvariables]\n[./equivalent_plastic_strain]\norder = CONSTANT\nfamily = MONOMIAL\n[../]\n[]\n[Auxkernels]\n[./equivalent_plastic_strain]\ntype =  RankTwoScalarTools #RankTwoScalarAux\nrank_two_tensor =  plastic_strain\nvariable = equivalent_plastic_strain\nscalar_type = effectiveStrain\n[../]\n[]\n\nBut the error throw out as\n\n*** ERROR ***\nA 'RankTwoScalarTools' is not a registered object.\n\nMaybe I misunderstood it, any suggestions are highly appreciated. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/23766",
          "updatedAt": "2023-04-29T03:07:28Z",
          "publishedAt": "2023-03-16T23:16:45Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUtils are meant to be called from the code, not from the input file.\nI think having an auxkernel was more appropriate there, to fill an auxvariable\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5339655",
                  "updatedAt": "2023-03-16T23:22:16Z",
                  "publishedAt": "2023-03-16T23:22:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thanks. I don't quite get it, could you explain more in detail? or are there related examples?",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5339669",
                          "updatedAt": "2023-03-16T23:25:39Z",
                          "publishedAt": "2023-03-16T23:25:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You\u2019re trying to use a utility.\nutilities are not objects you create in input files. It s code you can use when you are developing",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5339825",
                          "updatedAt": "2023-03-16T23:55:37Z",
                          "publishedAt": "2023-03-16T23:55:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Yes. I'm not sure where should I call for utility. Do you mean a new Auxkernel code containing RankTwoScalarTools and using utility needs to be developed?",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5339917",
                          "updatedAt": "2023-03-17T00:07:08Z",
                          "publishedAt": "2023-03-17T00:07:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yeah you could develop a new auxkernel that uses the utility you want to use.\nWhat are you trying to do?\nI think you just want to use the RankTwoScalarAux auxkernel here",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5339976",
                          "updatedAt": "2023-03-17T00:21:43Z",
                          "publishedAt": "2023-03-17T00:21:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "I want to call for the equivalent/effective plastic strain for other material modulus.\nso to put it this way, how can I obtain the \\epsilon_p^eq here? Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5343904",
                          "updatedAt": "2023-03-17T10:16:28Z",
                          "publishedAt": "2023-03-17T10:16:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you add\n[Debug]\n  show_material_props= true\n[]\n\nto the simulation do you see that property declared?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5347684",
                          "updatedAt": "2023-03-17T16:21:03Z",
                          "publishedAt": "2023-03-17T16:21:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Hi,\n\nI add it and it shows as\n\n\nConsumed Material Properties:\nObject: AuxKernel::isotropic_plasticityeffective_plastic_strain\nProperties: effective_plastic_strain\nObject: AuxKernel::isotropic_plasticityhardening_variable\nProperties: hardening_variable\n\nso it means it's calculated, right?\n\nPreviously, I used the [Compute Multiple Inelastic Stress] and [Isotropic Plasticity Stress Update] and input as follows to retrieve  \\epsilon_p^eq, but is this  \\epsilon_p^eq here the same as the one I showed in the figure? If yes, then what's the difference of [ effectiveStrain method] in https://mooseframework.inl.gov/source/utils/RankTwoScalarTools.html, as discussed as #20979. If no, then what's the definition of the \\epsilon_p^eq in the two modules.\n\n\n[./effective_plastic_strain]\ntype = MaterialRealAux\nproperty =  effective_plastic_strain\nvariable =  effective_plastic_strain\n[../]\n\n\nthe type of \\epsilon_p^eq should be  MaterialRealAux or RankTwoScalarAux or RankTwoScalarTools? All My questions come down to how can I calculate and call for \\epsilon_p^eq. Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5348088",
                          "updatedAt": "2023-03-17T16:57:16Z",
                          "publishedAt": "2023-03-17T16:57:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@hugary1995 @jiangwen84",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5350122",
                          "updatedAt": "2023-03-17T21:33:41Z",
                          "publishedAt": "2023-03-17T21:33:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Additionally, I'm trying to run the original input file from 'modules/combined/test/tests/j2_plasticity_vs_LSH/j2_hard1_mod_small_strain.i', which use the auxkernel to get eq_pl_strain as\n\n[./eq_pl_strain]\ntype = RankTwoScalarAux\nrank_two_tensor = plastic_strain\nscalar_type = EffectiveStrain\nvariable = eq_pl_strain\n[../]\n\nbut the error is still there.\n\n*** ERROR ***\nTo compute an effective inelastic strain use RankTwoScalarTools::effectiveStrain()",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5354397",
                          "updatedAt": "2023-03-18T17:03:47Z",
                          "publishedAt": "2023-03-18T17:03:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "[AuxVariables]\n  [ep]\n    order = CONSTANT\n    family = MONOMIAL\n    [AuxKernel]\n      type = MaterialRealAux\n      property = effective_plastic_strain\n      execute_on = 'TIMESTEP_END'\n    []\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5410700",
                          "updatedAt": "2023-03-23T19:58:07Z",
                          "publishedAt": "2023-03-23T19:58:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "coupled_variables problem disappeared and then reurned...",
          "author": {
            "login": "MScKarl"
          },
          "bodyText": "I started writing a Multiphase system using both \u201cargs\u201d and \u201ccouple_ variables\u201d for my system. On the first try I used \u201cargs\u201d and received the following error:\n*** ERROR ***\nf_eta: Coupled variable 'fa' was not found.\nBelieving I should use \u201ccouple_ variables\u201d instead I switched, resulting in the following error:\n*** ERROR ***\nInvalid function\n(eta1^2-1)^2\nin ParsedMaterialHelper.\nSyntax error: Unknown identifier\nYesterday I was in communication with this forum and got some great advice, and after rebooting the system it worked, but now the problem is back, and restarting again doesn\u2019t help. Could use some advice/tips on how to proceed.\nThe code for my materials section follows below:\n[Materials]\n\n  [./kappa]\n    type = GenericConstantMaterial\n    prop_names  = 'kappa11 kappa12 kappa21 kappa22'\n    prop_values = '0.01    0.01    0.01    0.01   '\n  [../]\n\n  [./L]\n    type = GenericConstantMaterial\n    prop_names = 'L'\n    prop_values = '1.0'\n  [../]\n\n  [./P0]\n    type = GenericConstantMaterial\n    prop_names = 'P0'\n    prop_values = '144000000'\n  [../]\n\n  [./s]\n    type = GenericConstantMaterial\n    prop_names = 's'\n    prop_values = '0.6' # variera\n  [../]\n\n\n  [./fa]\n    type = DerivativeParsedMaterial\n    property_name = fa\n    coupled_variables = 'eta1'\n    function = '(eta1^2-1)^2'\n    enable_jit = true\n  [../]\n\n  [./fb]\n    type = DerivativeParsedMaterial\n    f_name = fb\n    coupled_variables = 'eta2'\n    function = '(eta2^2-1)^2'\n  [../]\n\n  [./fc]\n    type = DerivativeParsedMaterial\n    f_name = fc\n    coupled_variables = 'eta1'\n    constant_names = 's'\n    constant_expressions = '0.6'\n    function = 's/4*(eta1*(eta1+2)*(eta1^2+2*eta1-6)-7)'\n  [../]\n\n   [./switching1]\n    type = SwitchingFunctionMaterial\n    function_name = h1\n    eta = eta1\n    h_order = HIGH\n  [../]\n\n  [./switching2]\n    type = SwitchingFunctionMaterial\n    function_name = h2\n    eta = eta2\n    h_order = HIGH\n  [../]\n\n\n  [./barrier]\n    type = MultiBarrierFunctionMaterial\n    etas = 'eta1 eta2'\n  [../]\n\n  [./f_eta]\n    type = DerivativeParsedMaterial\n    f_name = f_eta # Name of the function\n    coupled_variables = 'fa fb fc' \n    constant_names = 'P0'\n    constant_expressions = '144*10^6'\n    function = 'P0*(fa+fb*fc)'\n  [../]\n\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23817",
          "updatedAt": "2023-03-23T16:01:31Z",
          "publishedAt": "2023-03-22T17:01:50Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "You can ONLY use coupled_variables if your MOOSE is up to date.\nIf not, you MUST use args.\nBut here, fa fb and fc are not variables. They are material properties. So this is not the right parameter to use.\nWith an UP-TO-DATE MOOSE, you have to use material_property_names for fa fb fc\nhttps://mooseframework.inl.gov/source/materials/ParsedMaterial.html\nThe fact that this is unclear is exactly why we renamed these parameters (in an up to date MOOSE)",
                  "url": "https://github.com/idaholab/moose/discussions/23817#discussioncomment-5395823",
                  "updatedAt": "2023-03-22T17:07:12Z",
                  "publishedAt": "2023-03-22T17:07:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "I re-installed MOOSE 4 Jan 2023. But when was the up-to-date moose published and can I get access to it without re-installing MOOSE again?\ngit log:\ncommit 66833b334e04e1e41d99663ecf3331f2530be536 (HEAD -> master)\nAuthor: Your Name <you@example.com>\nDate:   Wed Jan 4 23:12:07 2023 +0100\n    initial commit",
                          "url": "https://github.com/idaholab/moose/discussions/23817#discussioncomment-5395939",
                          "updatedAt": "2023-03-22T17:16:05Z",
                          "publishedAt": "2023-03-22T17:16:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the renaming was merged end of January. But today's is always the best version",
                          "url": "https://github.com/idaholab/moose/discussions/23817#discussioncomment-5396021",
                          "updatedAt": "2023-03-22T17:26:45Z",
                          "publishedAt": "2023-03-22T17:26:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this page has how to udpate.\nYou ll likely need to update libmesh too\nhttps://mooseframework.inl.gov/getting_started/installation/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/23817#discussioncomment-5396027",
                          "updatedAt": "2023-03-22T17:27:22Z",
                          "publishedAt": "2023-03-22T17:27:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "I will update and see if I can get it to work. There is a chance I may have a follow up question later.",
                          "url": "https://github.com/idaholab/moose/discussions/23817#discussioncomment-5396627",
                          "updatedAt": "2023-03-22T18:24:44Z",
                          "publishedAt": "2023-03-22T18:24:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sounds good.\nbtw what you posted and deleted is the same problem\n  [./fa]\n    type = DerivativeParsedMaterial\n    property_name = fa\n    coupled_variables = 'eta1'\n    function = '(eta1^2-1)^2'\n    enable_jit = true\n  [../]\n\nis not valid with an old moose. You need to say f_name = fa with an OLD moose. Current one, property_name is good",
                          "url": "https://github.com/idaholab/moose/discussions/23817#discussioncomment-5396639",
                          "updatedAt": "2023-03-22T18:29:11Z",
                          "publishedAt": "2023-03-22T18:25:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MScKarl"
                  },
                  "bodyText": "Hi again!\nNow I've updated MOOSE and corrected the syntax, but I still get an error.\n*** ERROR ***\nThe following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\nMaterial property 'eta1', requested by 'fa' is not defined on block 0\nMaterial property 'eta1', requested by 'fa_face' is not defined on block 0\nMaterial property 'eta1', requested by 'fa_neighbor' is not defined on block 0\nMaterial property 'eta2', requested by 'fb' is not defined on block 0\nMaterial property 'eta2', requested by 'fb_face' is not defined on block 0\nMaterial property 'eta2', requested by 'fb_neighbor' is not defined on block 0\nMaterial property 'eta1', requested by 'fc' is not defined on block 0\nMaterial property 'eta1', requested by 'fc_face' is not defined on block 0\nMaterial property 'eta1', requested by 'fc_neighbor' is not defined on block 0\n[Materials]\n\n  [./kappa]\n    type = GenericConstantMaterial\n    prop_names  = 'kappa11 kappa12 kappa21 kappa22'\n    prop_values = '0.01    0.01    0.01    0.01   '\n  [../]\n\n  [./L]\n    type = GenericConstantMaterial\n    prop_names = 'L'\n    prop_values = '1.0'\n  [../]\n\n  [./P0]\n    type = GenericConstantMaterial\n    prop_names = 'P0'\n    prop_values = '144000000'\n  [../]\n\n  [./s]\n    type = GenericConstantMaterial\n    prop_names = 's'\n    prop_values = '0.6' # variera\n  [../]\n\n\n  [./fa]\n    type = DerivativeParsedMaterial\n    property_name = fa\n    material_property_names = 'eta1'\n    expression= '(eta1^2-1)^2'\n    enable_jit = true\n  [../]\n\n  [./fb]\n    type = DerivativeParsedMaterial\n    property_name = fb\n    material_property_names = 'eta2'\n    expression= '(eta2^2-1)^2'\n  [../]\n\n  [./fc]\n    type = DerivativeParsedMaterial\n    property_name = fc\n    material_property_names = 'eta1'\n    constant_names = 's'\n    constant_expressions = '0.6'\n    expression= 's/4*(eta1*(eta1+2)*(eta1^2+2*eta1-6)-7)'\n  [../]\n\n   [./switching1]\n    type = SwitchingFunctionMaterial\n    function_name = h1\n    eta = eta1\n    h_order = HIGH\n  [../]\n\n  [./switching2]\n    type = SwitchingFunctionMaterial\n    function_name = h2\n    eta = eta2\n    h_order = HIGH\n  [../]\n\n\n  [./barrier]\n    type = MultiBarrierFunctionMaterial\n    etas = 'eta1 eta2'\n  [../]\n\n  [./f_eta]\n    type = DerivativeParsedMaterial\n    property_name = f_eta # Name of the function\n    material_property_names = 'fa fb fc' \n    constant_names = 'P0'\n    constant_expressions = '144*10^6'\n    expression= 'P0*(fa+fb*fc)'\n  [../]\n\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/23817#discussioncomment-5407917",
                  "updatedAt": "2023-03-23T15:40:17Z",
                  "publishedAt": "2023-03-23T15:40:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So eta1 2 and 3 are variables right?\nso they should be coupled_variables not material_property_names in fa fb fc",
                          "url": "https://github.com/idaholab/moose/discussions/23817#discussioncomment-5407953",
                          "updatedAt": "2023-03-23T15:43:01Z",
                          "publishedAt": "2023-03-23T15:43:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Thank you very much!\n(Removed the other comment because it became moot.)",
                          "url": "https://github.com/idaholab/moose/discussions/23817#discussioncomment-5408181",
                          "updatedAt": "2023-03-23T16:00:40Z",
                          "publishedAt": "2023-03-23T16:00:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Why mesh is moving?",
          "author": {
            "login": "galibubc"
          },
          "bodyText": "I use the phase field and tensor mechanics module to solve a dendrite formation problem. I have a fundamental question regarding the mesh grids. As we know phase field is an implicit interface-capturing approach; hence we do not need to move the mesh while solving a phase field problem. But when I use the above two modules together with eigen strain, it appears that the mesh is moving during the dendrite formation. The evolution of the order parameter alone should be sufficient to track the growth of the dendrites and the interface. I am confused regarding the necessity of moving the mesh simultaneously. Using a fixed grid in the spatial configuration should be sufficient to capture the involved dynamics of the problem.\nI used  [./TensorMechanics] use_displaced_mesh = true [../] to calculate the strains and stresses in the deformed configuration.\nPlease comment on the appropriate usage of the above function for such applications. When I do not use eigen strain, The mesh is not moving.",
          "url": "https://github.com/idaholab/moose/discussions/23728",
          "updatedAt": "2023-04-29T03:07:50Z",
          "publishedAt": "2023-03-15T04:02:13Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you want to track the stresses and strains in the deformed configuration, but without displacing the mesh?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23728#discussioncomment-5317211",
                  "updatedAt": "2023-03-15T05:06:29Z",
                  "publishedAt": "2023-03-15T05:06:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "galibubc"
                  },
                  "bodyText": "Hello,\nPlease take a look at the attached image here. The difference with the previous image is that there is no eigen strain in this case.\nI want to measure cauchy stress in a deformed configuration (Eulerian mesh/ fixed grid mesh), not a lagrangian configuration (PK stress). If we calculate cauchy stress with phase-field, we evolve (another equation in space and time) strain tensor (for example: left cauchy green tensor B = FF^T. Using phase field, we avoid the computationally expensive task of moving mesh.\nI am adding my input file here. Please guide me to get the appropriate setting.\nundeformed_mesh.txt\ndeformed_mesh.txt",
                  "url": "https://github.com/idaholab/moose/discussions/23728#discussioncomment-5349177",
                  "updatedAt": "2023-03-17T19:11:55Z",
                  "publishedAt": "2023-03-17T19:11:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dschwen @laagesen on phase field",
                  "url": "https://github.com/idaholab/moose/discussions/23728#discussioncomment-5350118",
                  "updatedAt": "2023-03-17T21:32:53Z",
                  "publishedAt": "2023-03-17T21:32:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "When you solve the mechanical equilibrium equation, you solve for local displacement at each position (and local strains are derivatives of the displacement fields) When you visualize the mesh, depending on the tool you use, the software may display the elements as moved according to the local displacement field. This is usually a user-adjustable parameter, so you can switch it off or you can displace the mesh by some scalar multiple of the displacement field. When you don't include solving the mechanical equilibrium simultaneously, there are no displacement fields.",
                          "url": "https://github.com/idaholab/moose/discussions/23728#discussioncomment-5350239",
                          "updatedAt": "2023-03-17T21:53:41Z",
                          "publishedAt": "2023-03-17T21:53:40Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "galibubc"
                          },
                          "bodyText": "Does that mean [./TensorMechanics] use_displaced_mesh = false[../] will give the same results for the primitive variables (disp_x, disp_y, eta) without a deformed mesh in the visualization tool.\n\n\nMOOSE uses the tensor mechanics module to solve for the mechanical equilibrium. Is the module solving for displacement or velocity as the primitive variable?\n\n\nFor clarification, when we do not move the mesh, does the solver still compute the cauchy stresses in a deformed configuration? For this to happen, do you evolve any of the deformation tensors with space and time in the eulerian configuration?\n\n\nAlso, why it was not deforming the mesh when I used [./TensorMechanics] use_displaced_mesh = true[../], in the previous figure. The only difference between the two figures is that one has eigen strain (-0.32, deformed mesh) other does not (0.0, undeformed mesh).",
                          "url": "https://github.com/idaholab/moose/discussions/23728#discussioncomment-5373456",
                          "updatedAt": "2023-03-20T19:15:26Z",
                          "publishedAt": "2023-03-20T19:15:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For 2) displacement variables are used as nonlinear variables, not velocities\nFor 1 & 3 i would encourage you to check the documentation for the tensor mechanics module more closely.\n@maxnezdyur will know for sure otherwise",
                          "url": "https://github.com/idaholab/moose/discussions/23728#discussioncomment-5375633",
                          "updatedAt": "2023-03-20T23:26:05Z",
                          "publishedAt": "2023-03-20T23:26:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "galibubc"
                          },
                          "bodyText": "Thanks for the response. I checked the documents, but it is not clear to me. My apologies\nI am revising the questions again.\n\n\nWhy it was not deforming the mesh when I used [./TensorMechanics] use_displaced_mesh = true[../] in the previous figure. The only difference between the two figures is that one has eigen strain (-0.32, deformed mesh) other does not (0.0, undeformed mesh).\n\n\nDoes that mean [./TensorMechanics] use_displaced_mesh = false[../] will give the same results for the primitive variables (disp_x, disp_y, eta) without a deformed mesh in the visualization tool\n\n\nFor clarification, when we do not move the mesh, does the solver still compute the cauchy stresses in a deformed configuration?",
                          "url": "https://github.com/idaholab/moose/discussions/23728#discussioncomment-5396323",
                          "updatedAt": "2023-03-22T18:01:06Z",
                          "publishedAt": "2023-03-22T17:55:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@recuero",
                          "url": "https://github.com/idaholab/moose/discussions/23728#discussioncomment-5407611",
                          "updatedAt": "2023-03-23T15:18:24Z",
                          "publishedAt": "2023-03-23T15:18:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}