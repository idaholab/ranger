{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMC0xN1QwNDoxODowMi0wNjowMM4AbvBH"
    },
    "edges": [
      {
        "node": {
          "title": "Errors With Declarations",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI am using the following code:\n'''InputParameters\nIntegralDirectedSurfaceForceFEM::validParams()\n{\nInputParameters params = SideIntegralPostprocessor::validParams();\nparams.addClassDescription(\"Computes the directed force from friction and pressure differences on a surface.\");\nparams.addRequiredParam(\"vel_x\", \"The velocity in the x-direction.\");\n: SideIntegralPostprocessor(parameters),\n_vel_x(getFunctor(\"vel_x\")),'''\nI am getting the following error:\n'''/home/twise/projects/crab/src/postprocessors/IntegralDirectedSurfaceForceFEM.C:36:28: error: invalid initialization of reference of type 'const VariableValue&' {aka 'const MooseArray&'} from expression of type 'Moose::Functor' {aka 'const Moose::FunctorEnvelope'}\n36 |     _vel_x(getFunctor(\"vel_x\")), //  _vel_x(getFunctor(\"vel_x\")),\n|            ~~~~~~~~~~~~~~~~^~~~~~~~~'''",
          "url": "https://github.com/idaholab/moose/discussions/28888",
          "updatedAt": "2024-10-18T20:35:35Z",
          "publishedAt": "2024-10-18T19:48:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "TLWise"
                  },
                  "bodyText": "Adding Templ<is_ad> appears to have eliminated the problem.",
                  "url": "https://github.com/idaholab/moose/discussions/28888#discussioncomment-10987602",
                  "updatedAt": "2024-10-18T20:14:20Z",
                  "publishedAt": "2024-10-18T20:14:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the error here\n\ninvalid initialization of reference of type 'const VariableValue&' {aka 'const MooseArray&'} from expression of type 'Moose::Functor'\n\nsays that you have _vel_x as a variable value, which you can initialize with coupledValue from the Coupleable interface.\nBut you are trying to initialize it with getFunctor, which is meant for retrieving references to functors",
                          "url": "https://github.com/idaholab/moose/discussions/28888#discussioncomment-10987667",
                          "updatedAt": "2024-10-18T20:23:14Z",
                          "publishedAt": "2024-10-18T20:23:13Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiple nucleation conditions",
          "author": {
            "login": "ashishdhole"
          },
          "bodyText": "Hello,\nI am working on phase transformation and need nucleation event happening at different region with different conditions. Can I use the following:\n[UserObjects]\n  [inserter1]\n    type = DiscreteNucleationInserter\n    hold_time = 0.4\n    probability = P\n    seed = 12346\n    radius = 3.27\n  []\n  [inserter2]\n    type = DiscreteNucleationFromFile\n    hold_time = 10\n    file = nuclei2.csv\n    radius = 2\n  []\n  [map1]\n    type = DiscreteNucleationMap\n    int_width = 2\n    periodic = eta1\n    inserter = inserter1\n  []\n  [map2]\n    type = DiscreteNucleationMap\n    int_width = 2\n    periodic = eta2\n    inserter = inserter2\n  []\n[]\n\nor is there any other way?\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/28884",
          "updatedAt": "2024-10-18T19:20:22Z",
          "publishedAt": "2024-10-18T01:42:19Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe documentation for this technique can be found there\nhttps://mooseframework.inl.gov/modules/phase_field/Nucleation/DiscreteNucleation.html\nI dont know if we have other methods in moose\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28884#discussioncomment-10987247",
                  "updatedAt": "2024-10-18T19:20:23Z",
                  "publishedAt": "2024-10-18T19:20:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "New user : A 'ComputeIsotropicElasticityTensor' is not a registered object.",
          "author": {
            "login": "shredderbvek"
          },
          "bodyText": "I followed the solid mechanics tutorial, however, when I tried to initiate the simulation the following error occurred.\n(moose) bibek@ghostRobot96:~/projects/solid_mech$ ./solid_mech-opt -i solid_mech.i\n\n\n*** ERROR ***\nA 'ComputeIsotropicElasticityTensor' is not a registered object.\n\nIf you are trying to find this object in a dynamically loaded library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\n\nStack frames: 21\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&)\n3: Factory::reportUnregisteredError(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const\n4: Factory::getValidParams(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const\n5: MooseObjectAction::MooseObjectAction(InputParameters const&)\n6: AddMaterialAction::AddMaterialAction(InputParameters const&)\n7: RegistryEntry<AddMaterialAction>::buildAction(InputParameters const&)\n8: ActionFactory::create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, InputParameters&)\n9: Moose::Builder::walkRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, hit::Node*)\n10: Moose::Builder::walk(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, hit::Node*)\n11: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n12: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n13: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n14: Moose::Builder::build()\n15: MooseApp::setupOptions()\n16: MooseApp::run()\n17: ./solid_mech-opt(+0x20eb) [0x561d8ee780eb]\n18: main\n19: __libc_start_main\n20: ./solid_mech-opt(+0x2396) [0x561d8ee78396]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor",
          "url": "https://github.com/idaholab/moose/discussions/28887",
          "updatedAt": "2024-10-18T19:18:33Z",
          "publishedAt": "2024-10-18T19:16:26Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou need to use either:\n\nthe solid mechanics module executable\nor\nan application executable with SOLID_MECHANICS set to yes in the Makefile.\nto run solid mechanics simulations.\n\nIf you are doing the latter, you'll need to:\n\nadd it to the makefile\nmake clobberall\nthen rebuild with make",
                  "url": "https://github.com/idaholab/moose/discussions/28887#discussioncomment-10987226",
                  "updatedAt": "2024-10-18T19:18:34Z",
                  "publishedAt": "2024-10-18T19:18:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "outputting state variables using MaterialStdVectorAux",
          "author": {
            "login": "MaheshTummala17"
          },
          "bodyText": "I have been working on obtaining data for state variables such as Accumulated Plastic Strain Energy Density (APSED) and Plastic Strain Accumulation (PSA), both of which involve time-dependent integration. When comparing the results from MOOSE with those from Abaqus, I am getting close values for APSED at the centroids of all elements. However, the PSA values show a significant discrepancy, with the differences being large. In both simulations, I used the same UMAT file. I'm unsure where the mistake lies and would appreciate help in identifying the issue.\nAPSED is integral over time, with summation on all slip systems as the product of resolved shear stress and slip shear rate.\nPSA is the integral over time with terms containing the inner tensor product of plastic velocity gradient\nPreconditioning = SMP\nTimeIntegrator = ImplicitEuler\nsolver type = 'NEWTON'\n[AuxVariables]\n[APSED]\norder = FIRST\nfamily = MONOMIAL\n[]\n[PSA]\norder = FIRST\nfamily = MONOMIAL\n[]\n[]\n[AuxKernels]\n[SV_193]\ntype = MaterialStdVectorAux\nproperty = state_var\nvariable = APSED\nindex = 192\nexecute_on = timestep_end\n[]\n[SV_289]\ntype = MaterialStdVectorAux\nproperty = state_var\nvariable = PSA\nindex = 288\nexecute_on = timestep_end\n[]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/28824",
          "updatedAt": "2024-10-18T08:58:45Z",
          "publishedAt": "2024-10-10T07:35:54Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "LineValueSampler: VectorPostProcessor in PostProcessor",
          "author": {
            "login": "TFdvd"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello MOOSE community!\nI'm intrested in the behaviour of LineValueSampler. In particular, the latter is a VectorPostProcessor and I get a .csv for each iteration. Is it possible to pass LineValueSampler from a VectorPostProcessor to a PostProcessor so that I can manipulate its behaviour to obtain a single .csv? Specifically, LineValueSampler in VectorPostProcessor returns me a .csv with a number of results = num_points (requested parameter) . My idea is to save this dataset, but to manipulate it in the PostProcessor area to get a single value of my interest.\nDo you have any suggestions for following this path? Maybe this is a silly question, but I don't have much experience.\nThanks for your time and patience :)",
          "url": "https://github.com/idaholab/moose/discussions/28827",
          "updatedAt": "2024-10-17T22:58:15Z",
          "publishedAt": "2024-10-11T11:55:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAll the postprocessors get lumped into the same CSV file by default.\nHowever you can create a cutom CSV output and use the 'show' parameter to select which postprocessors to print there.\nYou can retrieve the vector values of of a VPP in a custom postprocessor using\ngetVectorPostprocessorValue(\"name of VPP\", \"which vector\")\n\nthis return a reference, you should save it in an attribute of your custom PP",
                  "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10916539",
                  "updatedAt": "2024-10-11T14:58:25Z",
                  "publishedAt": "2024-10-11T14:58:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TFdvd"
                          },
                          "bodyText": "Hello @GiudGiud , thanks for your answer! I got your suggestion and I implemented it into a .h and .c that I will attach below.\nFrom LineValueSampler I obtained a .csv with [variable][id][x][y][z] as output.\nIn the .h and .c below, my purpose is to save [variable] and possibly [y], in a Postprocessor in order to compare [variable] in this way:\n(std::abs(_c_var[i] - _threshold) < _tolerance)`\n\nI'm not sure about the result because in the terminal got these error and notes:\nerror: invalid new-expression of abstract class type 'NeckValue'\n  962 |     { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }\n      |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nnote:   because the following virtual functions are pure within 'NeckValue':\n   29 | class NeckValue : public GeneralPostprocessor\n      |       ^~~~~~~~~\n\nnote:     'virtual PostprocessorValue Postprocessor::getValue() const'\n   39 |   virtual PostprocessorValue getValue() const = 0;\n      |                              ^~~~~~~~\n\nSo I'm not able to proceed. Do you have some suggestion to correct and continue my custom Postprocessor?\n`NeckValue.h`\n\n`#ifndef NECKVALUE_H\n#define NECKVALUE_H\n\n#include \"GeneralPostprocessor.h\"\n\n\nclass NeckValue; \n\n\nclass NeckValue : public GeneralPostprocessor\n{\npublic:\n  \n  Real computeValue();\n\n  static InputParameters validParams();\n  NeckValue(const InputParameters & parameters);\n  \n  virtual void initialize() override;\n  virtual void execute() override;\n\n\n\n  \n\nprotected:\n\n  \n  std::vector<Real> _c_var;\n  const Real _threshold;\n  const Real _tolerance;\n \n\n\n};\n\n#endif //NECKVALUE_H`\n\n\n`NeckValue.C`\n\n\n`#include \"NeckValue.h\"\n#include \"NeckLineValueSampler.h\"  \n#include \"SystemBase.h\" \nusing namespace std;    \n\nregisterMooseObject(\"ParrotApp\", NeckValue);\n\nInputParameters\nNeckValue::validParams()\n{\n  InputParameters params = GeneralPostprocessor::validParams();\n\nparams.addRequiredParam<Real>(\"threshold\", \"Seconda variabile\");\nparams.addRequiredParam<Real>(\"tolerance\", \"Terza variabile\");\n\nparams.addRequiredParam<VectorPostprocessorName>(\"vpp\", \"The name of the VectorPostprocessor to pull the data from.\"); //new\nparams.addRequiredParam<std::string>(\"vector_name\",\"The name of the vector to use from the VectorPostprocessor\"); //new\nparams.addRequiredParam<std::vector<Real>>(\"c_var\", \"Lista di valori per c_var\");\n  return params;\n}\n\n\nNeckValue::NeckValue(\n  const InputParameters &parameters)  \n\n    : GeneralPostprocessor(parameters), \n    _threshold(getParam<Real>(\"threshold\")),\n    _tolerance(getParam<Real>(\"tolerance\")),\n    _c_var(getParam<std::vector<Real>>(\"c_var\"))\n{}\n\nvoid \nNeckValue::initialize()\n{\n\n}\nvoid \nNeckValue::execute()\n{\n  \n}\n\n\n  Real NeckValue::computeValue() { \n  Real value = 0.0; \n \n  \n  VectorPostprocessorValue c_var = getVectorPostprocessorValueByName(getParam<VectorPostprocessorName>(\"vpp\"),getParam<std::string>(\"vector_name\"));\n  for (unsigned int i = 0; i < 100; i++)\n  {\n    if (std::abs(_c_var[i] - _threshold) < _tolerance) \n    {\n      value = c_var[i];\n    }\n  }\n  return value;\n}\n\n`\n\nThanks @GiudGiud for your time and patience!",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10930014",
                          "updatedAt": "2024-10-15T13:27:32Z",
                          "publishedAt": "2024-10-13T18:22:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nthis is the message to look for\nnote: because the following virtual functions are pure within 'NeckValue':\n29 | class NeckValue : public GeneralPostprocessor\n| ^~~~~~~~~\nnote: 'virtual PostprocessorValue Postprocessor::getValue() const'\n39 | virtual PostprocessorValue getValue() const = 0;\n\nbascially you need to implement getValue\nso in the header add\nPostprocessorValue getValue() const override;\n\nand in the source add\nPostprocessorValue getValue() const\n{\nreturn _value;\n}\n\nin computeValue(), you should save value to a _value attribute",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10931254",
                          "updatedAt": "2024-10-14T00:04:08Z",
                          "publishedAt": "2024-10-14T00:04:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TFdvd"
                          },
                          "bodyText": "Hello @GiudGiud, thanks for your help! I need again support as regarding a doubt. I have a Postprocessor in which I manipulate a vector obtained from a VectoPostprocessor. I'm currently accessing the vector with the function\n const VectorPostprocessorValue & c_var = getVectorPostprocessorValueByName(getParam<VectorPostprocessorName>(\"vpp\"),getParam<std::string>(\"vector_name\")); \n\nbut unfortunately I don't get the desired vector. Below, I attach my .C and .i.\nThe current script runs without any error, however the results I get are not correct. Do you have any suggestion please?  Thanks a lot for your help\n#include \"NeckValue.h\"\n#include \"NeckLineValueSampler.h\"  \n#include \"SystemBase.h\" \nusing namespace std;   \n\nregisterMooseObject(\"ParrotApp\", NeckValue);\n\nInputParameters\nNeckValue::validParams()\n{\n  InputParameters params = GeneralPostprocessor::validParams();\nparams.addRequiredParam<Real>(\"threshold\", \"Seconda variabile\");\nparams.addRequiredParam<Real>(\"tolerance\", \"Terza variabile\");\nparams.addRequiredParam<VectorPostprocessorName>(\"vpp\", \"The name of the VectorPostprocessor to pull the data from.\"); \nparams.addRequiredParam<std::string>(\"vector_name\",\"The name of the vector to use from the VectorPostprocessor\"); \nparams.addParam<std::vector<Real>>(\"c_var\", std::vector<Real>{}, \"Vector of real values used in computation.\");\n  return params;\n}\n\n\nNeckValue::NeckValue(\n  const InputParameters &parameters)  \n    : GeneralPostprocessor(parameters), \n    _threshold(getParam<Real>(\"threshold\")),\n    _tolerance(getParam<Real>(\"tolerance\")),\n    _c_var(getParam<std::vector<Real>>(\"c_var\")) \n{}\n\nvoid \nNeckValue::initialize()\n{\n _c_var = getParam<std::vector<Real>>(\"c_var\"); \n}\nvoid \nNeckValue::execute()\n{\n  \n}\n\n\nReal NeckValue::computeValue() { \n\n  _value = 0.0; \n  _index = 0.0;\n \n  const VectorPostprocessorValue & c_var = getVectorPostprocessorValueByName(getParam<VectorPostprocessorName>(\"vpp\"),getParam<std::string>(\"vector_name\"));\n  \n  for (unsigned int i = 0; i < _c_var.size(); i++)\n  {\n    if (std::abs(_c_var[i] - _threshold) < _tolerance)  \n    {\n      _value = c_var[i]; \n      _index = i; \n      break;  \n    } \n  }\n                       \n    return _value;  \n}  \n\n  PostprocessorValue NeckValue::getValue() const       \n  {                                         \n    return _value;                              \n  }\n\n[VectorPostprocessors]\n  [./c_along_vertical]\n    type = NeckLineValueSampler\n    variable = c                    \n    start_point = '40 0 0'          \n    end_point = '40 30 0'           \n    num_points = 100                \n    sort_by = y \n  [../] \n[]\n\n\n[Postprocessors]\n  [./c_neck]\n    type = NeckValue\n    vpp = 'c_along_vertical' \n    threshold = 0.4 \n    tolerance = 0.05\n  [../]  \n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10941069",
                          "updatedAt": "2024-10-14T22:40:50Z",
                          "publishedAt": "2024-10-14T20:54:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is it lagged?\nDo you have a print out of a the vector in the VPP and in the PP?",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10941084",
                          "updatedAt": "2024-10-14T20:56:30Z",
                          "publishedAt": "2024-10-14T20:56:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TFdvd"
                          },
                          "bodyText": "In my VPP I get the output in a .csv like this:\n[variable] [id] [x] [y] [z].\nIn PP I would like to take the vector [variable] and manipulate it. My difficulty is to export [variable] from VPP to PP.",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10941376",
                          "updatedAt": "2024-10-14T21:55:54Z",
                          "publishedAt": "2024-10-14T21:55:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What error do you get?",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10941407",
                          "updatedAt": "2024-10-14T22:01:41Z",
                          "publishedAt": "2024-10-14T22:01:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TFdvd"
                          },
                          "bodyText": "I don't get an error. The results are not coherent and I think that my procedure is wrong when I pass [variable] from VPP to PP. Maybe, passing the vector \"[variable]\" in the right way, I will solve the problem.",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10941439",
                          "updatedAt": "2024-10-14T22:07:20Z",
                          "publishedAt": "2024-10-14T22:07:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you report here the print out of the vector in the VPP and in the PP?",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10941555",
                          "updatedAt": "2024-10-14T22:35:03Z",
                          "publishedAt": "2024-10-14T22:34:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TFdvd"
                          },
                          "bodyText": "Yes, sure!\nA generic .csv of my VPP is:\nC_along_vertical_0005_.xlsx\nThe file above treats the i-th iteration. On the previous file, that comes from VPP, I'm only interested on the entire vector c (1st column) that I want to export on the PP in order to catch one only value of my interest.\nThe result of my PP for all iteration in the single value of my interest is:\nc_neck.xlsx\nAs you can see, the repeted value 8.8931816251424e-323 in c_neck.xlsx file is not coherent and maybe VPP and PP are not comunicate well from the previous .C and .i that I attached. Thanks for your patience @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10946001",
                          "updatedAt": "2024-10-15T09:57:17Z",
                          "publishedAt": "2024-10-15T09:57:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "8.8931816251424e-323\n\nmeans an unitialized value in C++\nwhat is happening is that nothing ever calls computeValue().\nYou need to do this\nvoid \nNeckValue::execute()\n{\n  computeValue();\n}\n\nor move the code in computeValue into execute",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10948067",
                          "updatedAt": "2024-10-15T13:28:48Z",
                          "publishedAt": "2024-10-15T13:28:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "TFdvd"
                  },
                  "bodyText": "Hello @GiudGiud!\nI really want to thank you for your help, my custom PP works almost 100%. I have solved almost all the problems except for one detail that doesn't add up. From the results I attach below you can see that at the first iteration 0.2 I get 3.22 e-320 while at iteration 0.5 I get 4.42, which is the result I need to get in 0.2. In other words, I get the results of the current iteration at the next iteration.\nTime  |    c\n0      |    0\n0.2   |    3.56e-321\n0.5   |    4.84\n0.95  |   6.06\n.      |      .\n.      |      .\n.      |      ...... and so on\nI have tried indexing the for loop in various ways without getting a solution. I attach the .C below. Do you have any suggestions or notice anything that might explain this tendency? The explanation I have found is that perhaps the PP runs the loop before the VPP and so at the current iteration the PP finds no value from the VPP, while at the next iteration the PP finds data from the VPP which is still at the previous iteration. I don't know if this makes sense, but I would like to know your point of view and how I could solve this last detail. Thanks again for your help @GiudGiud !\n#include \"NeckValue.h\"\nregisterMooseObject(\"ParrotApp\", NeckValue);\nInputParameters\nNeckValue::validParams()\n{\nInputParameters params = GeneralPostprocessor::validParams();\nparams.addRequiredParam(\"threshold\", \"Seconda variabile\");\nparams.addRequiredParam(\"tolerance\", \"Terza variabile\");\nparams.addRequiredParam(\"vpp\", \"The name of the VectorPostprocessor to pull the data from.\"); //new\nparams.addRequiredParamstd::string(\"vector_name\",\"The name of the vector to use from the VectorPostprocessor\"); //new\nparams.addParam<std::vector>(\"c_var\", std::vector{}, \"Vector of real values used in computation.\");\nreturn params;\n}\nNeckValue::NeckValue(\nconst InputParameters &parameters)\n: GeneralPostprocessor(parameters),\n_threshold(getParam(\"threshold\")),\n_tolerance(getParam(\"tolerance\")),\n_c_var(getParam<std::vector>(\"c_var\")) //virgola in pi\u00f9\n{}\nvoid\nNeckValue::initialize()\n{\n_c_var = getParam<std::vector>(\"c_var\");\n}\nvoid\nNeckValue::execute()\n{\ncomputeValue();\n}\nReal NeckValue::computeValue() {\nconst VectorPostprocessorValue & _c_var = getVectorPostprocessorValueByName(getParam(\"vpp\"),getParamstd::string(\"vector_name\"));\nfor (unsigned int i = 0; i < _c_var.size(); i++)\n{\nif (std::abs(_c_var[i] - _threshold) < _tolerance)\n{\n  _value = _c_var[i]; \n\n[ ]\n  _index = i;\n\n  _true_neck = (_index * 0.303); \n\n  break; \n}  \n\n}\nreturn _true_neck; \n\n}\nPostprocessorValue NeckValue::getValue() const\n{\nreturn _true_neck;\n}",
                  "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10976668",
                  "updatedAt": "2024-10-17T22:17:09Z",
                  "publishedAt": "2024-10-17T22:17:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok so what must be happening is that the postprocessor is executed before the VPP\nso to fix that, use execution_order_groups (a parameter for both PPs, VPPs and UOs), and set the PP to be executed after the VPP",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10976679",
                          "updatedAt": "2024-10-17T22:19:39Z",
                          "publishedAt": "2024-10-17T22:19:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TFdvd"
                          },
                          "bodyText": "Perhaps I have not understood your point of view.\nThe VPP has to be executed first in order to provide the data to the PP afterwards.\nIf it is a matter of using execution_order_groups anyway, could you explain how to do that? Thanks in advance",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10976717",
                          "updatedAt": "2024-10-17T22:26:38Z",
                          "publishedAt": "2024-10-17T22:26:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in the VPP set\nexecution_order_group = 0\nin the PP set\nexecution_order_group = 1\nthat should work",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10976732",
                          "updatedAt": "2024-10-17T22:30:20Z",
                          "publishedAt": "2024-10-17T22:30:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TFdvd"
                          },
                          "bodyText": "You're right!! Thank a lot @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/28827#discussioncomment-10976857",
                          "updatedAt": "2024-10-17T22:58:16Z",
                          "publishedAt": "2024-10-17T22:58:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Initialize old Material Property",
          "author": {
            "login": "delpierrena"
          },
          "bodyText": "Hello everyone,\nI am currently trying to implement the particle finite element method using the Moose FEM solver.\nThe application could be landslide, earthen dam failures, footing etc.. The basic idea of the method is to remesh when necessary to allow for modelling large deformations problems. The remeshing algorithm is working fine but I am struggling harder with reinitializing the moose simulation from a past solution.\nSince our problem involves large deformations,  we need to remap a lot of quantities from one mesh to another. So we run a simulation, retrieve the plastic strain, internal parameter, stresses, velocities and accelerations and we want to remap these into the new displaced mesh.\nThe issue we face is that we are unable to initialize the old material properties before starting the simulation. We modified the initQpStatefulProperties function from the ComputeMultiPlasticityStress class in order to initialize the plastic_strain, the stress and the intnl parameter but this is obviously not the way to go.\nExample : We performed a slope failure simulation. We output some quantities at a given point in the slope after 0.1s of simulation. Here the elastic strain xx (es_xx) the plastic strain xx (ps_xx) the strain xx (s_xx) and the stress yy.\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | es_xx          | ps_xx          | s_xx           | stress_yy      |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-02 |  -1.467515e-05 |   1.252200e-05 |  -2.153149e-06 |  -3.078785e+04 |\n|   2.000000e-02 |  -1.678404e-05 |   1.252200e-05 |  -4.262041e-06 |  -3.115457e+04 |\n|   3.000000e-02 |  -4.448685e-06 |   1.252200e-05 |   8.073315e-06 |  -3.157687e+04 |\n|   4.000000e-02 |   2.029382e-05 |   1.252200e-05 |   3.281582e-05 |  -3.271324e+04 |\n|   5.000000e-02 |   4.244592e-05 |   1.252200e-05 |   5.496792e-05 |  -3.546752e+04 |\n|   6.000000e-02 |   7.036422e-05 |   1.252200e-05 |   8.288622e-05 |  -3.904428e+04 |\n|   7.000000e-02 |   1.045518e-04 |   1.252200e-05 |   1.170738e-04 |  -4.171049e+04 |\n|   8.000000e-02 |   1.193600e-04 |   1.252200e-05 |   1.318820e-04 |  -4.339706e+04 |\n|   9.000000e-02 |   1.225850e-04 |   2.543216e-05 |   1.480172e-04 |  -4.536374e+04 |\n|   1.000000e-01 |   1.144755e-04 |   8.649673e-05 |   2.009722e-04 |  -4.688521e+04 |\n+----------------+----------------+----------------+----------------+----------------+\n\nThen, we want to restart the simulation based on our modified version of InitQpStatefulProperties but the results are clearly wrong since the strain is not the sum of the elastic and of the plastic contribution and this, since the first step :\nPostprocessor Values: +----------------+----------------+----------------+----------------+----------------+ | time           | es_xx          | ps_xx          | s_xx           | stress_yy      | +----------------+----------------+----------------+----------------+----------------+ |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 | |   1.000000e-02 |   3.105196e-05 |   1.682521e-04 |   2.885585e-05 |  -3.673527e+04 | +----------------+----------------+----------------+----------------+----------------+\nWe believe that the issue is coming from the reinitialization of some fields (most probably the plastic strain ). In particular, when reinitializing the finite element problem, we cannot initialize the old properties needed for the return map algorithm. Do you have any idea of how we could initialize these old material properties ?",
          "url": "https://github.com/idaholab/moose/discussions/28654",
          "updatedAt": "2024-10-17T22:21:03Z",
          "publishedAt": "2024-09-18T14:49:45Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThings have improved recently on this front, with the new stateful material properties objects merged this year\nsee https://mooseframework.inl.gov/source/actions/ProjectedStatefulMaterialStorageAction.html\nDid you try to rely on those for your work?\nHow are you reinitializing the problem? Is this using restart/recover and checkpoints? Or exodus? Or some special problem?",
                  "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10682934",
                  "updatedAt": "2024-09-18T14:55:21Z",
                  "publishedAt": "2024-09-18T14:55:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "delpierrena"
                          },
                          "bodyText": "Hello,\nThank you for you quick answer. For now, I was outputing using the vtk format, then reading and providing the remapped field to Moose through a csv file. I modified the InitQpStatefulProperties (from ComputeMultiPlasticityStress) in order to reinitialize the properties, but unsuccessfully, as I showed before.\nI did not see this ProjectedStatefulMaterialStorageAction before. So, I should now be able to remap the plastic strain, the stresses and intnl parameter ?\nHere is how I did understand the documentation, but I did not find any example :\nLet's say I want to reinitialize the plastic_strain_xx :\nI create an AuxVariable\n[AuxVariables]\n    [./ps_xx]\n       [./InitialCondition]\n             type = FunctionIC\n             function = plastic_strain_xx_fcn # a function I create that reads the field in a csv file \n        [../]\n    [../]\n[]\n\nThen in the Materials, I should declare a InterpolatedStatefulMaterialReal :\n[Materials]\n  [interpolate_ps_xx]\n    type = InterpolatedStatefulMaterialReal\n    old_state = ps_xx\n    prop_name = plastic_strain_xx\n  []\n\nAm I correct ? Thank you again for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10683505",
                          "updatedAt": "2024-09-18T15:43:15Z",
                          "publishedAt": "2024-09-18T15:42:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The intent is to use ProjectedStatefulMaterialStorageAction to store the material properties then\nProjectedStatefulMaterial... to reload them from auxiliary variables\n\nI should now be able to remap the plastic strain, the stresses and intnl parameter ?\n\nthis has all been added in the context of solid mechanics calculations, so yes it should work for these",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10683597",
                          "updatedAt": "2024-09-18T15:52:32Z",
                          "publishedAt": "2024-09-18T15:52:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "delpierrena"
                          },
                          "bodyText": "I am not sure if I understood well.\nDoes it support the fact that we perform a simulation, then that we stop it, make some modifications to the mesh and finally restart the simulation ? Because I did not understand what you meant by 'store the material properties'.\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10683994",
                          "updatedAt": "2024-09-18T16:29:53Z",
                          "publishedAt": "2024-09-18T16:29:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think so. You might have to change this:\n\nThe action will set up aux variables for each scalar component of the projected properties listed in \"projected_props\". The variables will be marked as hidden and will not appear in any outputs.\n\nsince you modify the variable locations in the vtk outputs.\n@hugary1995 do you have some advice on using this?",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10684280",
                          "updatedAt": "2024-09-18T17:42:04Z",
                          "publishedAt": "2024-09-18T16:54:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "delpierrena"
                          },
                          "bodyText": "Just to clarify a bit : we have a csv file containing x,y,z and previous stateful properties. So for now, I read this file using the PropertyReadFile user object and I created functions, using the PiecewiseConstantFromCSV function, that would be used to define the initial state.\nFrom what I understood in this is the way I should do it :\nSet use_interpolated_state=true in the ComputeMultiPlasticityStress Material, which activate the ProjectedStatefulMaterialStorageAction\nThen, still in materials provide the :\n  [plastic_strain_interpolated_old]\n    type = GenericFunctionRankTwoTensor\n    tensor_functions = 'plastic_strain_xx_fcn plastic_strain_xy_fcn 0 plastic_strain_xy_fcn plastic_strain_yy_fcn 0  0 0 0'\n    tensor_name = plastic_strain_interpolated_old\n  []\n  [elastic_strain_interpolated_old]\n    type = GenericFunctionRankTwoTensor\n    tensor_functions = 'elastic_strain_xx_fcn elastic_strain_xy_fcn  0 elastic_strain_xy_fcn elastic_strain_yy_fcn 0  0 0 0'\n    tensor_name = elastic_strain_interpolated_old\n  []\n  [total_strain_interpolated_old]\n    type = GenericFunctionRankTwoTensor\n    tensor_functions = 'strain_xx_fcn strain_xy_fcn  0 strain_xy_fcn strain_yy_fcn 0  0 0 0'\n    tensor_name = total_strain_interpolated_old\n  []\n  [stress_interpolated_old]\n    type = GenericFunctionRankTwoTensor\n    tensor_functions = 'stress_xx_fcn stress_xy_fcn 0  stress_xy_fcn stress_yy_fcn 0  0 0 0'\n    tensor_name = stress_interpolated_old\n  []\n\n\nStill, I need to provide the plastic_transverse_direction_interpolated_old and the plastic_internal_parameter_interpolated_old. But until now I was not able to do so.  I just tried to initialize them with 0 values.\n  [plastic_transverse_direction_interpolated_old]\n    type = GenericConstantVectorMaterial\n    prop_names = plastic_transverse_direction_interpolated_old\n    prop_values = '0 0 0'\n  []\n  [plastic_internal_parameter_interpolated_old]\n    type = GenericConstantMaterial\n    prop_names = plastic_internal_parameter_interpolated_old\n    prop_values = 0\n  []\n\nWhich throws an error :\nThe requested non-AD material property 'plastic_internal_parameter_interpolated_old' of type 'std::vector'\nis already retrieved or declared as a non-AD property of type 'double'.\nIf you have any idea of how I could tackle this, or if you have any example of such a restart using the ProjectedStatefulMaterialStorageAction, It could be really helpful.\nThank you again ! Nathan",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10693386",
                          "updatedAt": "2024-09-19T12:59:41Z",
                          "publishedAt": "2024-09-19T12:59:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is being created as a Real instead of a vector. which one is it supposed to be?\n  [plastic_internal_parameter_interpolated_old]\n    type = GenericConstantMaterial\n    prop_names = plastic_internal_parameter_interpolated_old\n    prop_values = 0\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10693582",
                          "updatedAt": "2024-09-19T13:14:35Z",
                          "publishedAt": "2024-09-19T13:14:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@dschwen where can we find more examples on this?\nonly found this in the repo\nhttps://github.com/idaholab/moose/pull/26054/files#diff-34f082f72d6049a84c5c1a4aeb1f34ee91784626e461e788c598b8bd78f3c7b3",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10693599",
                          "updatedAt": "2024-09-19T13:16:56Z",
                          "publishedAt": "2024-09-19T13:16:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "delpierrena"
                          },
                          "bodyText": "Of course, I would like it to be a function as the internal parameter should be a vector, as for the other materials properties. But it is not working:\n  [plastic_internal_parameter_interpolated_old]\n    type = GenericFunctionMaterial\n    prop_names = plastic_internal_parameter_interpolated_old\n    prop_values = mc_int_fcn\n  []\n\nThis also throws this error :\nThe requested non-AD material property 'plastic_internal_parameter_interpolated_old' of type 'std::vector'\nis already retrieved or declared as a non-AD property of type 'double'. I believe that this is linked to the fact that the intnl_parameter is declared as a 'std::vector' in the ComputeMultiPlasticityStress class.",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10693661",
                          "updatedAt": "2024-09-19T13:52:46Z",
                          "publishedAt": "2024-09-19T13:22:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you cant declare the same property twice.\nIf it s a function material, then do you really need the projectedMaterialPropertyStorage? Functions dont need storage, they are evaluated on the fly.\nI suspect you should not be using a function if you want to leverage ProjectedStatefulMaterialPropertyStorage",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10694378",
                          "updatedAt": "2024-09-19T14:32:14Z",
                          "publishedAt": "2024-09-19T14:32:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "delpierrena"
                          },
                          "bodyText": "Ok but then I really do not understand how I should be using the action.\nFrom the moment I set the use_interpolated_state = true (which seems to be designed to activate the Action) in the ComputeMultiPlasticityStress , it requires a set of Material Properties :\n*** ERROR ***\nThe following error occurred in the Problem 'MOOSE Problem' of type FEProblem.\nMaterial property 'plastic_strain_interpolated_old', requested by 'mc' is not defined on block pfem_volume\nMaterial property 'plastic_internal_parameter_interpolated_old', requested by 'mc' is not defined on block pfem_volume\nMaterial property 'plastic_transverse_direction_interpolated_old', requested by 'mc' is not defined on block pfem_volume\nMaterial property 'total_strain_interpolated_old', requested by 'mc' is not defined on block pfem_volume\nMaterial property 'stress_interpolated_old', requested by 'mc' is not defined on block pfem_volume\nMaterial property 'elastic_strain_interpolated_old', requested by 'mc' is not defined on block pfem_volume\n\nThe previous material blocks I showed you made the majority of the error disappear. Example: if I put all the Material Properties blocks as shown before, excepted the one linked to the plastic_internal_parameter_interpolated_old, I got this :\n*** ERROR ***\nThe following error occurred in the Problem 'MOOSE Problem' of type FEProblem.\n\nMaterial property 'plastic_internal_parameter_interpolated_old', requested by 'mc' is not defined on block pfem_volume\n\nTherefore, if my previous solution indeed does not seem to suit, I do not know how to declare this specific Material Property (and if it is correct for the other ones).",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10694532",
                          "updatedAt": "2024-09-19T14:47:02Z",
                          "publishedAt": "2024-09-19T14:47:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "delpierrena"
                  },
                  "bodyText": "Just to clarify the full process, I show you different important blocks of my input file:\nI declared all the different projected properties in the following block :\n[ProjectedStatefulMaterialStorage]\n   [all]\n     projected_props = 'plastic_strain_interpolated_old stress_interpolated_old total_strain_interpolated_old elastic_strain_interpolated_old plastic_internal_parameter_interpolated_old plastic_transverse_direction_interpolated_old'\n     family = MONOMIAL\n     order = FIRST\n   []\n []\n\nI have a block of function where I retrieve the old state of a previous simulation, or let's say the initial state of the current one:\n[Functions]\n  [stress_xx_fcn]\n    type = PiecewiseConstantFromCSV\n    read_type = 'voronoi'\n    read_prop_user_object = 'reader_node'\n    column_number = '3'\n  []\n  [stress_xy_fcn]\n    type = PiecewiseConstantFromCSV\n    read_type = 'voronoi'\n    read_prop_user_object = 'reader_node'\n    column_number = '4'\n  []\n......\n\nThen the Materials block :\n[Materials]\n  [plastic_strain_interpolated_old]\n    type = GenericFunctionRankTwoTensor\n    tensor_functions = 'plastic_strain_xx_fcn plastic_strain_xy_fcn 0 plastic_strain_xy_fcn plastic_strain_yy_fcn 0  0 0 0'\n    tensor_name = plastic_strain_interpolated_old\n  []\n  [elastic_strain_interpolated_old]\n    type = GenericFunctionRankTwoTensor\n    tensor_functions = 'elastic_strain_xx_fcn elastic_strain_xy_fcn  0 elastic_strain_xy_fcn elastic_strain_yy_fcn 0  0 0 0'\n    tensor_name = elastic_strain_interpolated_old\n  []\n  .......\n   [./mc]\n    type = ComputeMultiPlasticityStress\n    ep_plastic_tolerance = 1E-9\n    plastic_models = mc\n    perform_finite_strain_rotations = false\n    min_stepsize = 0.01\n    ignore_failures = true\n    use_interpolated_state = true\n  [../]\n   ...",
                  "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10765450",
                  "updatedAt": "2024-09-26T15:50:55Z",
                  "publishedAt": "2024-09-26T15:50:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in the Materials block, is     use_interpolated_state = true in every relevant block?\nIf you use Debug/show_actions=true,\ndo you see auxkernels updating every variable that needs to be updated?\nthe Functions, are they used in AuxKernels? or in FunctionIC (preferrable)",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10777052",
                          "updatedAt": "2024-09-27T15:05:45Z",
                          "publishedAt": "2024-09-27T15:05:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Guys, if you know the number of elements to store in that vector then just change it into a statically sized std::array<Real, N>. Adding dynamically sized types to the projected material storage will be an ugly mess! There is no enforced guarantee that vector sizes stay the same during a simulation, so all the extra checks and the added parameters for users to specify vector sizes will make the code harder to read and maintain.",
                  "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10917656",
                  "updatedAt": "2024-10-11T16:50:10Z",
                  "publishedAt": "2024-10-11T16:50:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I've created #28836 to keep track of this",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10919281",
                          "updatedAt": "2024-10-11T21:00:39Z",
                          "publishedAt": "2024-10-11T21:00:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@delpierrena\nis there any reason you use ComputeMultiPlasticityStress ? Its use of std::vector properties is because of the potentially arbitrary number of plasticity models in use.\nCould you use another material?\nI m going to guess but this one maybe?\nhttps://mooseframework.inl.gov/source/materials/IsotropicPlasticityStressUpdate.html\n@dschwen",
                  "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10919059",
                  "updatedAt": "2024-10-11T20:19:20Z",
                  "publishedAt": "2024-10-11T20:19:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "delpierrena"
                          },
                          "bodyText": "The reason I use this material is that I find this approach of combining UserObjects describing the yield function with the ComputeMultiPlasticityStress to be quite convenient to use.  Also there exist many examples in the documentation and the possibility of combining multiple plasticity models is a fairly stong capability.\nIf you think that it will be more simple to rather use StressUpdate Materials, I can switch to this.  I understand that the presence of the std::vector intnl parameter makes it really difficult to work.",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10936216",
                          "updatedAt": "2024-10-14T12:45:00Z",
                          "publishedAt": "2024-10-14T12:44:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think it'd be good to do that for now.\nOnce you have a model with 2 plasticity sources, there might be another option still.\nFurther than that, we can start work on enabling the std::vector restart",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10939594",
                          "updatedAt": "2024-10-14T17:31:29Z",
                          "publishedAt": "2024-10-14T17:31:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "delpierrena"
                          },
                          "bodyText": "Hi @GiudGiud ,\nI modified my input file and now I am using the IsotropicPlasticityStressUpdate, as we mentioned earlier.\nThe code runs using the ProjectedStateful action, combined with the use_interpolated_state set to true in the ComputeMultipleInelasticStress material. In this case, I have just tried to set the initial vertical stress to (say) -10000, by unhiding the aux_variable created by the action and setting an initial condition on it.\nThe code runs, but the initial stress is not applied. So ... I must admit that I am a bit lost. I wonder what I am doing wrong.\nAgain, here is the input file (remap_stateful-new.i) on the github repository: https://github.com/delpierrena/example-ProjectedStateful",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10972942",
                          "updatedAt": "2024-10-17T15:03:07Z",
                          "publishedAt": "2024-10-17T15:03:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThanks for doing that. So in the new input we have\n  [isotropic_plasticity]\n    type = IsotropicPlasticityStressUpdate\n    yield_stress = 10e3\n    hardening_function = 0\n    # use_interpolated_state = true\n  []\n  [./radial_return_stress]\n    type = ComputeMultipleInelasticStress\n    tangent_operator = elastic\n    inelastic_models = 'isotropic_plasticity'\n    use_interpolated_state = true\n  [../]\n\nshould the first use_interpolated_stat be uncommented?\nAnd the second object seems to be using the previous method?\nI think I am looking at the wrong input file?",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10973109",
                          "updatedAt": "2024-10-17T15:15:10Z",
                          "publishedAt": "2024-10-17T15:15:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "delpierrena"
                          },
                          "bodyText": "In fact, if you use the IsotropicPlasticityStressUpdate, you must combine it with the ComputeMultipleInelasticStress (note that this material is different from ComputeMultiPlasticityStress).\nPreviously (with ComputeMultiPlasticityStress) we had to define the plasticity with UserObjects, which is not mandatory for ComputeMultipleInelasticStress.\nThe stresses as variables are part of the ComputeMultipleInelasticStress material. Therefore, I only enabled use_interpolated_state in this material as I just wanted to see if I could initialise stress_yy.",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10973232",
                          "updatedAt": "2024-10-17T15:25:17Z",
                          "publishedAt": "2024-10-17T15:25:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok and we are no longer hitting the same problem since all the properties there are tensors",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10973424",
                          "updatedAt": "2024-10-17T15:42:39Z",
                          "publishedAt": "2024-10-17T15:42:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@maxnezdyur do you have time to take a look ? This has worked around the previous difficulty",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10973764",
                          "updatedAt": "2024-10-17T16:09:32Z",
                          "publishedAt": "2024-10-17T16:09:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "So a few questions @delpierrena :\nHow do you know the initial stress is not applied.\n\nThe code runs, but the initial stress is not applied. So ... I\n\nI am not well versed on these classes but I don't see that  it would even use the _stess_old for your input file. It looks like for _is_elasticity_tensor_guaranteed_isotropic it won't even use the _stress_old.\nComputeMultipleInelasticStress.C\n      if (_is_elasticity_tensor_guaranteed_isotropic || !_perform_finite_strain_rotations)\n        _stress[_qp] =\n            _elasticity_tensor[_qp] * (_elastic_strain_old[_qp] + elastic_strain_increment);\n      else\n      {\n        if (_damage_model)\n          _stress[_qp] = _undamaged_stress_old + _elasticity_tensor[_qp] * elastic_strain_increment;\n        else\n          _stress[_qp] = _stress_old[_qp] + _elasticity_tensor[_qp] * elastic_strain_increment;\n      }\n\nI would try to maybe change elastic strain or so material that the old material is guaranteed to be used.\n@GiudGiud\nDo we have an auxkernel that can output the \"old\" material state. This would allow use to have a way to see if we are grabbing old correctly.",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10973832",
                          "updatedAt": "2024-10-17T16:16:54Z",
                          "publishedAt": "2024-10-17T16:15:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think such an auxkernelight be added by the ProjectedStatefulMaterial property action?",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10973905",
                          "updatedAt": "2024-10-17T16:22:18Z",
                          "publishedAt": "2024-10-17T16:22:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "delpierrena"
                          },
                          "bodyText": "Because applying or not the initial stress does not change the solution and the output variables at each time step.\nI tried to do the same for the elastic_strain_old and initialize them, but it does not apply either:\n [./_var_elastic_strain_4]\n    family = MONOMIAL\n    order = FIRST\n    [./InitialCondition]\n      type = FunctionIC\n      function = -0.001\n    [../]\n  [../]\n\nTomorrow I will add some cout in the code to be sure, but I believe that the solution should at least be different at time 1, influenced by the initial condition.",
                          "url": "https://github.com/idaholab/moose/discussions/28654#discussioncomment-10974123",
                          "updatedAt": "2024-10-17T16:44:01Z",
                          "publishedAt": "2024-10-17T16:44:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Failed tests for step10_multiapps tutorial: auxkernels/corrosion EXODIFF",
          "author": {
            "login": "smpeyres"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nI am working through the darcy_thermo_mech tutorials and I am currently on step10_multiapps. Compilation with make -j8 works just fine on Apple Silicon M1. However, when I perform ./run_tests -j8, it reports that two tests, both for tests/auxkernels/corrosion fail with EXODIFF while the other eight tests pass.\nI also tried the -j4 equivalents with the same results and diagnostics.sh passed all checks.\nAny thoughts?\n(Optional) code in question / simulation log / errors\nauxkernels/velocity_aux.test .............................................................................. OK\nkernels/simple_diffusion.test ............................................................................. OK\nkernels/darcy_pressure.test ............................................................................... OK\nbcs/outflow.test .......................................................................................... OK\nmaterials/packed_column.test .............................................................................. OK\nkernels/darcy_advection.test .............................................................................. OK\nauxkernels/corrosion.default: Working Directory: /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/tests/auxkernels/corrosion\nauxkernels/corrosion.default: Running command: /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/darcy_thermo_mech-opt -i corrosion.i --error --error-override --libtorch-device cpu\nauxkernels/corrosion.default: The following total 1 aux variables:\nauxkernels/corrosion.default:   porosity\nauxkernels/corrosion.default: are added for automatic output by MaterialOutputAction.\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: \nauxkernels/corrosion.default: *** Info ***\nauxkernels/corrosion.default: 'execute_on' parameter specified in [Outputs] block is ignored for object 'checkpoint'.\nauxkernels/corrosion.default: Define this object in its own sub-block of [Outputs] to modify its execution schedule.\nauxkernels/corrosion.default: Framework Information:\nauxkernels/corrosion.default: MOOSE Version:           git commit 2ec280afc3 on 2024-10-15\nauxkernels/corrosion.default: LibMesh Version:         \nauxkernels/corrosion.default: PETSc Version:           3.21.5\nauxkernels/corrosion.default: SLEPc Version:           3.21.1\nauxkernels/corrosion.default: Current Time:            Thu Oct 17 09:50:44 2024\nauxkernels/corrosion.default: Executable Timestamp:    Thu Oct 17 09:50:35 2024\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Checkpoint:\nauxkernels/corrosion.default:   Wall Time Interval:      Every 3600 s\nauxkernels/corrosion.default:   User Checkpoint:         Disabled\nauxkernels/corrosion.default:   # Checkpoints Kept:      2\nauxkernels/corrosion.default:   Execute On:              TIMESTEP_END \nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Parallelism:\nauxkernels/corrosion.default:   Num Processors:          1\nauxkernels/corrosion.default:   Num Threads:             1\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Mesh: \nauxkernels/corrosion.default:   Parallel Type:           replicated\nauxkernels/corrosion.default:   Mesh Dimension:          2\nauxkernels/corrosion.default:   Spatial Dimension:       2\nauxkernels/corrosion.default:   Nodes:                   121\nauxkernels/corrosion.default:   Elems:                   100\nauxkernels/corrosion.default:   Num Subdomains:          1\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Nonlinear System:\nauxkernels/corrosion.default:   Num DOFs:                121\nauxkernels/corrosion.default:   Num Local DOFs:          121\nauxkernels/corrosion.default:   Variables:               \"temperature\" \nauxkernels/corrosion.default:   Finite Element Types:    \"LAGRANGE\" \nauxkernels/corrosion.default:   Approximation Orders:    \"FIRST\" \nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Auxiliary System:\nauxkernels/corrosion.default:   Num DOFs:                421\nauxkernels/corrosion.default:   Num Local DOFs:          421\nauxkernels/corrosion.default:   Variables:               \"phi\" { \"phi_jump\" \"error_marker\" \"porosity\" } \nauxkernels/corrosion.default:   Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \nauxkernels/corrosion.default:   Approximation Orders:    \"FIRST\" \"CONSTANT\" \nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Execution Information:\nauxkernels/corrosion.default:   Executioner:             Transient\nauxkernels/corrosion.default:   TimeStepper:             ConstantDT\nauxkernels/corrosion.default:   TimeIntegrator:          ImplicitEuler\nauxkernels/corrosion.default:   Solver Mode:             Preconditioned JFNK\nauxkernels/corrosion.default:   PETSc Preconditioner:    hypre boomeramg \nauxkernels/corrosion.default: \nauxkernels/corrosion.default: LEGACY MODES ENABLED:\nauxkernels/corrosion.default:  This application uses the legacy initial residual evaluation behavior. The legacy behavior performs an often times redundant residual evaluation before the solution modifying objects are executed prior to the initial (0th nonlinear iteration) residual evaluation. The new behavior skips that redundant residual evaluation unless the parameter Executioner/use_pre_smo_residual is set to true. To remove this message and enable the new behavior, set the parameter 'use_legacy_initial_residual_evaluation_behavior' to false in *App.C. Some tests that rely on the side effects of the legacy behavior may fail/diff and should be re-golded.\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Mesh unchanged, skipping remaining steps...\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Time Step 0, time = 0\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Time Step 1, time = 0.5, dt = 0.5\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Postprocessor Values:\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: | time           | k_eff          |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: |   5.000000e-01 |   0.000000e+00 |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Pre-SMO residual: 8.34369\nauxkernels/corrosion.default:  0 Nonlinear |R| = 8.343691e+00\nauxkernels/corrosion.default:       0 Linear |R| = 8.343691e+00\nauxkernels/corrosion.default:       1 Linear |R| = 1.549240e+00\nauxkernels/corrosion.default:       2 Linear |R| = 8.001529e-02\nauxkernels/corrosion.default:       3 Linear |R| = 7.350995e-03\nauxkernels/corrosion.default:       4 Linear |R| = 4.792750e-04\nauxkernels/corrosion.default:       5 Linear |R| = 2.999320e-05\nauxkernels/corrosion.default:  1 Nonlinear |R| = 1.870387e-03\nauxkernels/corrosion.default:       0 Linear |R| = 1.870387e-03\nauxkernels/corrosion.default:       1 Linear |R| = 1.043748e-05\nauxkernels/corrosion.default:       2 Linear |R| = 8.783022e-07\nauxkernels/corrosion.default:       3 Linear |R| = 5.432982e-08\nauxkernels/corrosion.default:       4 Linear |R| = 3.631349e-09\nauxkernels/corrosion.default:  2 Nonlinear |R| = 6.193530e-09\nauxkernels/corrosion.default:  Solve Converged!\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Postprocessor Values:\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: | time           | k_eff          |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Mesh unchanged, skipping remaining steps...\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Time Step 2, time = 1, dt = 0.5\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Postprocessor Values:\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: | time           | k_eff          |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.default: |   1.000000e+00 |   1.254934e+01 |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Pre-SMO residual: 0.261142\nauxkernels/corrosion.default:  0 Nonlinear |R| = 2.611419e-01\nauxkernels/corrosion.default:       0 Linear |R| = 2.611419e-01\nauxkernels/corrosion.default:       1 Linear |R| = 6.505193e-03\nauxkernels/corrosion.default:       2 Linear |R| = 2.408524e-04\nauxkernels/corrosion.default:       3 Linear |R| = 1.879679e-05\nauxkernels/corrosion.default:       4 Linear |R| = 1.500252e-06\nauxkernels/corrosion.default:  1 Nonlinear |R| = 2.530532e-06\nauxkernels/corrosion.default:       0 Linear |R| = 2.530532e-06\nauxkernels/corrosion.default:       1 Linear |R| = 1.901748e-07\nauxkernels/corrosion.default:       2 Linear |R| = 1.081525e-08\nauxkernels/corrosion.default:       3 Linear |R| = 6.283127e-10\nauxkernels/corrosion.default:       4 Linear |R| = 3.100480e-11\nauxkernels/corrosion.default:       5 Linear |R| = 1.666475e-12\nauxkernels/corrosion.default:  2 Nonlinear |R| = 4.192184e-10\nauxkernels/corrosion.default:  Solve Converged!\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Postprocessor Values:\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: | time           | k_eff          |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.default: |   1.000000e+00 |   1.250955e+01 |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Mesh unchanged, skipping remaining steps...\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Time Step 3, time = 1.5, dt = 0.5\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Postprocessor Values:\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: | time           | k_eff          |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.default: |   1.000000e+00 |   1.250955e+01 |\nauxkernels/corrosion.default: |   1.500000e+00 |   1.250955e+01 |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Pre-SMO residual: 0.258737\nauxkernels/corrosion.default:  0 Nonlinear |R| = 2.587373e-01\nauxkernels/corrosion.default:       0 Linear |R| = 2.587373e-01\nauxkernels/corrosion.default:       1 Linear |R| = 6.307993e-03\nauxkernels/corrosion.default:       2 Linear |R| = 2.068094e-04\nauxkernels/corrosion.default:       3 Linear |R| = 2.099996e-05\nauxkernels/corrosion.default:       4 Linear |R| = 1.496631e-06\nauxkernels/corrosion.default:  1 Nonlinear |R| = 2.826520e-06\nauxkernels/corrosion.default:       0 Linear |R| = 2.826520e-06\nauxkernels/corrosion.default:       1 Linear |R| = 2.031846e-07\nauxkernels/corrosion.default:       2 Linear |R| = 1.365544e-08\nauxkernels/corrosion.default:       3 Linear |R| = 7.915748e-10\nauxkernels/corrosion.default:       4 Linear |R| = 3.783316e-11\nauxkernels/corrosion.default:       5 Linear |R| = 2.478907e-12\nauxkernels/corrosion.default:  2 Nonlinear |R| = 4.763928e-10\nauxkernels/corrosion.default:  Solve Converged!\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Postprocessor Values:\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: | time           | k_eff          |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.default: |   1.000000e+00 |   1.250955e+01 |\nauxkernels/corrosion.default: |   1.500000e+00 |   1.247105e+01 |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Mesh unchanged, skipping remaining steps...\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Time Step 4, time = 2, dt = 0.5\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Postprocessor Values:\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: | time           | k_eff          |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.default: |   1.000000e+00 |   1.250955e+01 |\nauxkernels/corrosion.default: |   1.500000e+00 |   1.247105e+01 |\nauxkernels/corrosion.default: |   2.000000e+00 |   1.247105e+01 |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Pre-SMO residual: 0.272895\nauxkernels/corrosion.default:  0 Nonlinear |R| = 2.728950e-01\nauxkernels/corrosion.default:       0 Linear |R| = 2.728950e-01\nauxkernels/corrosion.default:       1 Linear |R| = 6.991910e-03\nauxkernels/corrosion.default:       2 Linear |R| = 2.175259e-04\nauxkernels/corrosion.default:       3 Linear |R| = 1.805618e-05\nauxkernels/corrosion.default:       4 Linear |R| = 1.138326e-06\nauxkernels/corrosion.default:  1 Nonlinear |R| = 2.674962e-06\nauxkernels/corrosion.default:       0 Linear |R| = 2.674962e-06\nauxkernels/corrosion.default:       1 Linear |R| = 1.508168e-07\nauxkernels/corrosion.default:       2 Linear |R| = 8.990648e-09\nauxkernels/corrosion.default:       3 Linear |R| = 5.311757e-10\nauxkernels/corrosion.default:       4 Linear |R| = 3.985200e-11\nauxkernels/corrosion.default:       5 Linear |R| = 3.149307e-12\nauxkernels/corrosion.default:  2 Nonlinear |R| = 2.454356e-10\nauxkernels/corrosion.default:  Solve Converged!\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Postprocessor Values:\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: | time           | k_eff          |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.default: |   1.000000e+00 |   1.250955e+01 |\nauxkernels/corrosion.default: |   1.500000e+00 |   1.247105e+01 |\nauxkernels/corrosion.default: |   2.000000e+00 |   1.243065e+01 |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Mesh unchanged, skipping remaining steps...\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Time Step 5, time = 2.5, dt = 0.5\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Postprocessor Values:\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: | time           | k_eff          |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.default: |   1.000000e+00 |   1.250955e+01 |\nauxkernels/corrosion.default: |   1.500000e+00 |   1.247105e+01 |\nauxkernels/corrosion.default: |   2.000000e+00 |   1.243065e+01 |\nauxkernels/corrosion.default: |   2.500000e+00 |   1.243065e+01 |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Pre-SMO residual: 0.242195\nauxkernels/corrosion.default:  0 Nonlinear |R| = 2.421952e-01\nauxkernels/corrosion.default:       0 Linear |R| = 2.421952e-01\nauxkernels/corrosion.default:       1 Linear |R| = 5.958176e-03\nauxkernels/corrosion.default:       2 Linear |R| = 1.948871e-04\nauxkernels/corrosion.default:       3 Linear |R| = 1.259206e-05\nauxkernels/corrosion.default:       4 Linear |R| = 1.210143e-06\nauxkernels/corrosion.default:  1 Nonlinear |R| = 2.099531e-06\nauxkernels/corrosion.default:       0 Linear |R| = 2.099531e-06\nauxkernels/corrosion.default:       1 Linear |R| = 1.960142e-07\nauxkernels/corrosion.default:       2 Linear |R| = 8.996727e-09\nauxkernels/corrosion.default:       3 Linear |R| = 4.706163e-10\nauxkernels/corrosion.default:       4 Linear |R| = 2.283691e-11\nauxkernels/corrosion.default:       5 Linear |R| = 1.299604e-12\nauxkernels/corrosion.default:  2 Nonlinear |R| = 4.683512e-10\nauxkernels/corrosion.default:  Solve Converged!\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Postprocessor Values:\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: | time           | k_eff          |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.default: |   1.000000e+00 |   1.250955e+01 |\nauxkernels/corrosion.default: |   1.500000e+00 |   1.247105e+01 |\nauxkernels/corrosion.default: |   2.000000e+00 |   1.243065e+01 |\nauxkernels/corrosion.default: |   2.500000e+00 |   1.239742e+01 |\nauxkernels/corrosion.default: +----------------+----------------+\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Running exodiff: /Users/seanpeyres/moose-projects/moose/framework/contrib/exodiff/exodiff -m  -F 1e-10 -t 5.5e-06  /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/tests/auxkernels/corrosion/gold/corrosion_out.e-s005 /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/tests/auxkernels/corrosion/corrosion_out.e-s005\nauxkernels/corrosion.default: ERROR: \nauxkernels/corrosion.default:    *****************************************************************\nauxkernels/corrosion.default:               EXODIFF\t(Version: 2.90) Modified: 2018-02-15\nauxkernels/corrosion.default:               Authors:  Richard Drake, rrdrake@sandia.gov           \nauxkernels/corrosion.default:                         Greg Sjaardema, gdsjaar@sandia.gov          \nauxkernels/corrosion.default:               Run on    2024/10/17   09:50:48 CDT\nauxkernels/corrosion.default:    *****************************************************************\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Reading first file ... \nauxkernels/corrosion.default: Reading second file ... \nauxkernels/corrosion.default:   FILE 1: /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/tests/auxkernels/corrosion/gold/corrosion_out.e-s005\nauxkernels/corrosion.default:    Title: corrosion_out.e-s005\nauxkernels/corrosion.default:           Dim = 2, Blocks = 1, Nodes = 5538, Elements = 5161, Nodesets = 4, Sidesets = 4\nauxkernels/corrosion.default:           Vars: Global = 1, Nodal = 2, Element = 3, Nodeset = 0, Sideset = 0, Times = 1\nauxkernels/corrosion.default: \nauxkernels/corrosion.default:   FILE 2: /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/tests/auxkernels/corrosion/corrosion_out.e-s005\nauxkernels/corrosion.default:    Title: corrosion_out.e-s005\nauxkernels/corrosion.default:           Dim = 2, Blocks = 1, Nodes = 5538, Elements = 5161, Nodesets = 4, Sidesets = 4\nauxkernels/corrosion.default:           Vars: Global = 1, Nodal = 2, Element = 3, Nodeset = 0, Sideset = 0, Times = 1\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: exodiff: INFO .. Map option is not needed.\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Nodal coordinates will be compared .. tol:    1e-06 (absolute), floor:        0\nauxkernels/corrosion.default: Time step values will be compared .. tol:  5.5e-06 (relative), floor:    1e-10\nauxkernels/corrosion.default: Global variables to be compared:\nauxkernels/corrosion.default: \tk_eff                            tol:  5.5e-06 (relative), floor:    1e-10\nauxkernels/corrosion.default: Nodal variables to be compared:\nauxkernels/corrosion.default: \tphi                              tol:  5.5e-06 (relative), floor:    1e-10\nauxkernels/corrosion.default: \ttemperature                            5.5e-06 (relative),           1e-10\nauxkernels/corrosion.default: Element variables to be compared:\nauxkernels/corrosion.default: \tphi_jump                         tol:  5.5e-06 (relative), floor:    1e-10\nauxkernels/corrosion.default: \terror_marker                           5.5e-06 (relative),           1e-10\nauxkernels/corrosion.default: \tporosity                               5.5e-06 (relative),           1e-10\nauxkernels/corrosion.default: No Element Attribute variables on either file.\nauxkernels/corrosion.default: No Nodeset variables on either file.\nauxkernels/corrosion.default: No Sideset variables on either file.\nauxkernels/corrosion.default: Sideset Distribution Factors will be compared .. tol:    1e-06 (relative), floor:        0\nauxkernels/corrosion.default: \nauxkernels/corrosion.default:   ==============================================================\nauxkernels/corrosion.default:   NOTE: All node and element ids are reported as global ids.\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: Sideset Distribution Factors:\nauxkernels/corrosion.default:   --------- Time step 1, 2.5000000e+00 ~ 2.5000000e+00, rel diff:  0.00000e+00 ---------\nauxkernels/corrosion.default: Global variables:\nauxkernels/corrosion.default:    k_eff  rel diff:  1.2393210e+01 ~  1.2397415e+01 = 3.39164e-04 (FAILED)\nauxkernels/corrosion.default: Nodal variables:\nauxkernels/corrosion.default:    phi          rel diff:  0.0000000e+00 ~  1.0000000e+00 = 1.00000e+00 (node 2)\nauxkernels/corrosion.default:    temperature  rel diff:  3.0173049e+02 ~  3.0172747e+02 = 1.00295e-05 (node 2054)\nauxkernels/corrosion.default: Element variables:\nauxkernels/corrosion.default:    phi_jump      rel diff:  1.1892071e+00 ~  6.8658905e-01 = 4.22650e-01 (block 0, elmt 2124)\nauxkernels/corrosion.default:    porosity      rel diff:  5.0000000e-01 ~  2.5000000e-01 = 5.00000e-01 (block 0, elmt 2341)\nauxkernels/corrosion.default: \nauxkernels/corrosion.default: exodiff: Files are different\nauxkernels/corrosion.default: \nauxkernels/corrosion.default:  \nauxkernels/corrosion.default: ################################################################################\nauxkernels/corrosion.default: Tester failed, reason: EXODIFF\nauxkernels/corrosion.default: \nauxkernels/corrosion.default ................................................................ FAILED (EXODIFF)\nproblems.step_a .............................................................................. [min_cpus=3] OK\nauxkernels/corrosion.temp_dep: Working Directory: /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/tests/auxkernels/corrosion\nauxkernels/corrosion.temp_dep: Running command: /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/darcy_thermo_mech-opt -i corrosion.i AuxKernels/corrosion/temperature=350 Outputs/file_base=corrosion_temp_dep --error --error-override --libtorch-device cpu\nauxkernels/corrosion.temp_dep: The following total 1 aux variables:\nauxkernels/corrosion.temp_dep:   porosity\nauxkernels/corrosion.temp_dep: are added for automatic output by MaterialOutputAction.\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: *** Info ***\nauxkernels/corrosion.temp_dep: 'execute_on' parameter specified in [Outputs] block is ignored for object 'checkpoint'.\nauxkernels/corrosion.temp_dep: Define this object in its own sub-block of [Outputs] to modify its execution schedule.\nauxkernels/corrosion.temp_dep: Framework Information:\nauxkernels/corrosion.temp_dep: MOOSE Version:           git commit 2ec280afc3 on 2024-10-15\nauxkernels/corrosion.temp_dep: LibMesh Version:         \nauxkernels/corrosion.temp_dep: PETSc Version:           3.21.5\nauxkernels/corrosion.temp_dep: SLEPc Version:           3.21.1\nauxkernels/corrosion.temp_dep: Current Time:            Thu Oct 17 09:50:48 2024\nauxkernels/corrosion.temp_dep: Executable Timestamp:    Thu Oct 17 09:50:35 2024\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Checkpoint:\nauxkernels/corrosion.temp_dep:   Wall Time Interval:      Every 3600 s\nauxkernels/corrosion.temp_dep:   User Checkpoint:         Disabled\nauxkernels/corrosion.temp_dep:   # Checkpoints Kept:      2\nauxkernels/corrosion.temp_dep:   Execute On:              TIMESTEP_END \nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Parallelism:\nauxkernels/corrosion.temp_dep:   Num Processors:          1\nauxkernels/corrosion.temp_dep:   Num Threads:             1\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Mesh: \nauxkernels/corrosion.temp_dep:   Parallel Type:           replicated\nauxkernels/corrosion.temp_dep:   Mesh Dimension:          2\nauxkernels/corrosion.temp_dep:   Spatial Dimension:       2\nauxkernels/corrosion.temp_dep:   Nodes:                   121\nauxkernels/corrosion.temp_dep:   Elems:                   100\nauxkernels/corrosion.temp_dep:   Num Subdomains:          1\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Nonlinear System:\nauxkernels/corrosion.temp_dep:   Num DOFs:                121\nauxkernels/corrosion.temp_dep:   Num Local DOFs:          121\nauxkernels/corrosion.temp_dep:   Variables:               \"temperature\" \nauxkernels/corrosion.temp_dep:   Finite Element Types:    \"LAGRANGE\" \nauxkernels/corrosion.temp_dep:   Approximation Orders:    \"FIRST\" \nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Auxiliary System:\nauxkernels/corrosion.temp_dep:   Num DOFs:                421\nauxkernels/corrosion.temp_dep:   Num Local DOFs:          421\nauxkernels/corrosion.temp_dep:   Variables:               \"phi\" { \"phi_jump\" \"error_marker\" \"porosity\" } \nauxkernels/corrosion.temp_dep:   Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \nauxkernels/corrosion.temp_dep:   Approximation Orders:    \"FIRST\" \"CONSTANT\" \nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Execution Information:\nauxkernels/corrosion.temp_dep:   Executioner:             Transient\nauxkernels/corrosion.temp_dep:   TimeStepper:             ConstantDT\nauxkernels/corrosion.temp_dep:   TimeIntegrator:          ImplicitEuler\nauxkernels/corrosion.temp_dep:   Solver Mode:             Preconditioned JFNK\nauxkernels/corrosion.temp_dep:   PETSc Preconditioner:    hypre boomeramg \nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: LEGACY MODES ENABLED:\nauxkernels/corrosion.temp_dep:  This application uses the legacy initial residual evaluation behavior. The legacy behavior performs an often times redundant residual evaluation before the solution modifying objects are executed prior to the initial (0th nonlinear iteration) residual evaluation. The new behavior skips that redundant residual evaluation unless the parameter Executioner/use_pre_smo_residual is set to true. To remove this message and enable the new behavior, set the parameter 'use_legacy_initial_residual_evaluation_behavior' to false in *App.C. Some tests that rely on the side effects of the legacy behavior may fail/diff and should be re-golded.\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Mesh unchanged, skipping remaining steps...\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Time Step 0, time = 0\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Time Step 1, time = 0.5, dt = 0.5\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Postprocessor Values:\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: | time           | k_eff          |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: |   5.000000e-01 |   0.000000e+00 |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Pre-SMO residual: 8.34369\nauxkernels/corrosion.temp_dep:  0 Nonlinear |R| = 8.343691e+00\nauxkernels/corrosion.temp_dep:       0 Linear |R| = 8.343691e+00\nauxkernels/corrosion.temp_dep:       1 Linear |R| = 1.549240e+00\nauxkernels/corrosion.temp_dep:       2 Linear |R| = 8.001529e-02\nauxkernels/corrosion.temp_dep:       3 Linear |R| = 7.350995e-03\nauxkernels/corrosion.temp_dep:       4 Linear |R| = 4.792750e-04\nauxkernels/corrosion.temp_dep:       5 Linear |R| = 2.999320e-05\nauxkernels/corrosion.temp_dep:  1 Nonlinear |R| = 1.870387e-03\nauxkernels/corrosion.temp_dep:       0 Linear |R| = 1.870387e-03\nauxkernels/corrosion.temp_dep:       1 Linear |R| = 1.043748e-05\nauxkernels/corrosion.temp_dep:       2 Linear |R| = 8.783022e-07\nauxkernels/corrosion.temp_dep:       3 Linear |R| = 5.432982e-08\nauxkernels/corrosion.temp_dep:       4 Linear |R| = 3.631349e-09\nauxkernels/corrosion.temp_dep:  2 Nonlinear |R| = 6.193530e-09\nauxkernels/corrosion.temp_dep:  Solve Converged!\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Postprocessor Values:\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: | time           | k_eff          |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Mesh unchanged, skipping remaining steps...\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Time Step 2, time = 1, dt = 0.5\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Postprocessor Values:\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: | time           | k_eff          |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.temp_dep: |   1.000000e+00 |   1.254934e+01 |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Pre-SMO residual: 0.615038\nauxkernels/corrosion.temp_dep:  0 Nonlinear |R| = 6.150376e-01\nauxkernels/corrosion.temp_dep:       0 Linear |R| = 6.150376e-01\nauxkernels/corrosion.temp_dep:       1 Linear |R| = 1.454644e-02\nauxkernels/corrosion.temp_dep:       2 Linear |R| = 6.488325e-04\nauxkernels/corrosion.temp_dep:       3 Linear |R| = 5.991634e-05\nauxkernels/corrosion.temp_dep:       4 Linear |R| = 2.954481e-06\nauxkernels/corrosion.temp_dep:  1 Nonlinear |R| = 1.170857e-05\nauxkernels/corrosion.temp_dep:       0 Linear |R| = 1.170857e-05\nauxkernels/corrosion.temp_dep:       1 Linear |R| = 3.895838e-07\nauxkernels/corrosion.temp_dep:       2 Linear |R| = 2.231283e-08\nauxkernels/corrosion.temp_dep:       3 Linear |R| = 1.670949e-09\nauxkernels/corrosion.temp_dep:       4 Linear |R| = 1.110127e-10\nauxkernels/corrosion.temp_dep:  2 Nonlinear |R| = 3.747580e-10\nauxkernels/corrosion.temp_dep:  Solve Converged!\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Postprocessor Values:\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: | time           | k_eff          |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.temp_dep: |   1.000000e+00 |   1.234202e+01 |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Mesh unchanged, skipping remaining steps...\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Time Step 3, time = 1.5, dt = 0.5\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Postprocessor Values:\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: | time           | k_eff          |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.temp_dep: |   1.000000e+00 |   1.234202e+01 |\nauxkernels/corrosion.temp_dep: |   1.500000e+00 |   1.234202e+01 |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Pre-SMO residual: 0.569329\nauxkernels/corrosion.temp_dep:  0 Nonlinear |R| = 5.693288e-01\nauxkernels/corrosion.temp_dep:       0 Linear |R| = 5.693288e-01\nauxkernels/corrosion.temp_dep:       1 Linear |R| = 1.489655e-02\nauxkernels/corrosion.temp_dep:       2 Linear |R| = 6.584955e-04\nauxkernels/corrosion.temp_dep:       3 Linear |R| = 5.981734e-05\nauxkernels/corrosion.temp_dep:       4 Linear |R| = 2.678592e-06\nauxkernels/corrosion.temp_dep:  1 Nonlinear |R| = 1.222642e-05\nauxkernels/corrosion.temp_dep:       0 Linear |R| = 1.222642e-05\nauxkernels/corrosion.temp_dep:       1 Linear |R| = 3.096470e-07\nauxkernels/corrosion.temp_dep:       2 Linear |R| = 1.771201e-08\nauxkernels/corrosion.temp_dep:       3 Linear |R| = 1.427478e-09\nauxkernels/corrosion.temp_dep:       4 Linear |R| = 9.186501e-11\nauxkernels/corrosion.temp_dep:  2 Nonlinear |R| = 3.994145e-10\nauxkernels/corrosion.temp_dep:  Solve Converged!\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Postprocessor Values:\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: | time           | k_eff          |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.temp_dep: |   1.000000e+00 |   1.234202e+01 |\nauxkernels/corrosion.temp_dep: |   1.500000e+00 |   1.215335e+01 |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Mesh unchanged, skipping remaining steps...\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Time Step 4, time = 2, dt = 0.5\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Postprocessor Values:\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: | time           | k_eff          |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.temp_dep: |   1.000000e+00 |   1.234202e+01 |\nauxkernels/corrosion.temp_dep: |   1.500000e+00 |   1.215335e+01 |\nauxkernels/corrosion.temp_dep: |   2.000000e+00 |   1.215335e+01 |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Pre-SMO residual: 0.622794\nauxkernels/corrosion.temp_dep:  0 Nonlinear |R| = 6.227942e-01\nauxkernels/corrosion.temp_dep:       0 Linear |R| = 6.227942e-01\nauxkernels/corrosion.temp_dep:       1 Linear |R| = 1.445402e-02\nauxkernels/corrosion.temp_dep:       2 Linear |R| = 9.314179e-04\nauxkernels/corrosion.temp_dep:       3 Linear |R| = 7.202006e-05\nauxkernels/corrosion.temp_dep:       4 Linear |R| = 5.076344e-06\nauxkernels/corrosion.temp_dep:  1 Nonlinear |R| = 1.327533e-05\nauxkernels/corrosion.temp_dep:       0 Linear |R| = 1.327533e-05\nauxkernels/corrosion.temp_dep:       1 Linear |R| = 8.379616e-07\nauxkernels/corrosion.temp_dep:       2 Linear |R| = 4.705513e-08\nauxkernels/corrosion.temp_dep:       3 Linear |R| = 3.571541e-09\nauxkernels/corrosion.temp_dep:       4 Linear |R| = 2.077568e-10\nauxkernels/corrosion.temp_dep:       5 Linear |R| = 1.278367e-11\nauxkernels/corrosion.temp_dep:  2 Nonlinear |R| = 9.365078e-10\nauxkernels/corrosion.temp_dep:  Solve Converged!\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Postprocessor Values:\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: | time           | k_eff          |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.temp_dep: |   1.000000e+00 |   1.234202e+01 |\nauxkernels/corrosion.temp_dep: |   1.500000e+00 |   1.215335e+01 |\nauxkernels/corrosion.temp_dep: |   2.000000e+00 |   1.194816e+01 |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Mesh unchanged, skipping remaining steps...\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Time Step 5, time = 2.5, dt = 0.5\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Postprocessor Values:\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: | time           | k_eff          |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.temp_dep: |   1.000000e+00 |   1.234202e+01 |\nauxkernels/corrosion.temp_dep: |   1.500000e+00 |   1.215335e+01 |\nauxkernels/corrosion.temp_dep: |   2.000000e+00 |   1.194816e+01 |\nauxkernels/corrosion.temp_dep: |   2.500000e+00 |   1.194816e+01 |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Pre-SMO residual: 0.596107\nauxkernels/corrosion.temp_dep:  0 Nonlinear |R| = 5.961067e-01\nauxkernels/corrosion.temp_dep:       0 Linear |R| = 5.961067e-01\nauxkernels/corrosion.temp_dep:       1 Linear |R| = 1.299431e-02\nauxkernels/corrosion.temp_dep:       2 Linear |R| = 7.469740e-04\nauxkernels/corrosion.temp_dep:       3 Linear |R| = 6.612589e-05\nauxkernels/corrosion.temp_dep:       4 Linear |R| = 4.805180e-06\nauxkernels/corrosion.temp_dep:  1 Nonlinear |R| = 1.047249e-05\nauxkernels/corrosion.temp_dep:       0 Linear |R| = 1.047249e-05\nauxkernels/corrosion.temp_dep:       1 Linear |R| = 6.500098e-07\nauxkernels/corrosion.temp_dep:       2 Linear |R| = 3.799690e-08\nauxkernels/corrosion.temp_dep:       3 Linear |R| = 3.327898e-09\nauxkernels/corrosion.temp_dep:       4 Linear |R| = 1.875324e-10\nauxkernels/corrosion.temp_dep:       5 Linear |R| = 1.579450e-11\nauxkernels/corrosion.temp_dep:  2 Nonlinear |R| = 6.707149e-10\nauxkernels/corrosion.temp_dep:  Solve Converged!\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Postprocessor Values:\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: | time           | k_eff          |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: |   5.000000e-01 |   1.254934e+01 |\nauxkernels/corrosion.temp_dep: |   1.000000e+00 |   1.234202e+01 |\nauxkernels/corrosion.temp_dep: |   1.500000e+00 |   1.215335e+01 |\nauxkernels/corrosion.temp_dep: |   2.000000e+00 |   1.194816e+01 |\nauxkernels/corrosion.temp_dep: |   2.500000e+00 |   1.177877e+01 |\nauxkernels/corrosion.temp_dep: +----------------+----------------+\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Running exodiff: /Users/seanpeyres/moose-projects/moose/framework/contrib/exodiff/exodiff -m  -F 1e-10 -t 5.5e-06  /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/tests/auxkernels/corrosion/gold/corrosion_temp_dep.e-s005 /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/tests/auxkernels/corrosion/corrosion_temp_dep.e-s005\nauxkernels/corrosion.temp_dep: ERROR: \nauxkernels/corrosion.temp_dep:    *****************************************************************\nauxkernels/corrosion.temp_dep:               EXODIFF\t(Version: 2.90) Modified: 2018-02-15\nauxkernels/corrosion.temp_dep:               Authors:  Richard Drake, rrdrake@sandia.gov           \nauxkernels/corrosion.temp_dep:                         Greg Sjaardema, gdsjaar@sandia.gov          \nauxkernels/corrosion.temp_dep:               Run on    2024/10/17   09:50:52 CDT\nauxkernels/corrosion.temp_dep:    *****************************************************************\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Reading first file ... \nauxkernels/corrosion.temp_dep: Reading second file ... \nauxkernels/corrosion.temp_dep:   FILE 1: /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/tests/auxkernels/corrosion/gold/corrosion_temp_dep.e-s005\nauxkernels/corrosion.temp_dep:    Title: corrosion_temp_dep.e-s005\nauxkernels/corrosion.temp_dep:           Dim = 2, Blocks = 1, Nodes = 6029, Elements = 5695, Nodesets = 4, Sidesets = 4\nauxkernels/corrosion.temp_dep:           Vars: Global = 1, Nodal = 2, Element = 3, Nodeset = 0, Sideset = 0, Times = 1\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep:   FILE 2: /Users/seanpeyres/moose-projects/moose/tutorials/darcy_thermo_mech/step10_multiapps/tests/auxkernels/corrosion/corrosion_temp_dep.e-s005\nauxkernels/corrosion.temp_dep:    Title: corrosion_temp_dep.e-s005\nauxkernels/corrosion.temp_dep:           Dim = 2, Blocks = 1, Nodes = 6029, Elements = 5695, Nodesets = 4, Sidesets = 4\nauxkernels/corrosion.temp_dep:           Vars: Global = 1, Nodal = 2, Element = 3, Nodeset = 0, Sideset = 0, Times = 1\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: exodiff: INFO .. Map option is not needed.\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Nodal coordinates will be compared .. tol:    1e-06 (absolute), floor:        0\nauxkernels/corrosion.temp_dep: Time step values will be compared .. tol:  5.5e-06 (relative), floor:    1e-10\nauxkernels/corrosion.temp_dep: Global variables to be compared:\nauxkernels/corrosion.temp_dep: \tk_eff                            tol:  5.5e-06 (relative), floor:    1e-10\nauxkernels/corrosion.temp_dep: Nodal variables to be compared:\nauxkernels/corrosion.temp_dep: \tphi                              tol:  5.5e-06 (relative), floor:    1e-10\nauxkernels/corrosion.temp_dep: \ttemperature                            5.5e-06 (relative),           1e-10\nauxkernels/corrosion.temp_dep: Element variables to be compared:\nauxkernels/corrosion.temp_dep: \tphi_jump                         tol:  5.5e-06 (relative), floor:    1e-10\nauxkernels/corrosion.temp_dep: \terror_marker                           5.5e-06 (relative),           1e-10\nauxkernels/corrosion.temp_dep: \tporosity                               5.5e-06 (relative),           1e-10\nauxkernels/corrosion.temp_dep: No Element Attribute variables on either file.\nauxkernels/corrosion.temp_dep: No Nodeset variables on either file.\nauxkernels/corrosion.temp_dep: No Sideset variables on either file.\nauxkernels/corrosion.temp_dep: Sideset Distribution Factors will be compared .. tol:    1e-06 (relative), floor:        0\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep:   ==============================================================\nauxkernels/corrosion.temp_dep:   NOTE: All node and element ids are reported as global ids.\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: Sideset Distribution Factors:\nauxkernels/corrosion.temp_dep:   --------- Time step 1, 2.5000000e+00 ~ 2.5000000e+00, rel diff:  0.00000e+00 ---------\nauxkernels/corrosion.temp_dep: Global variables:\nauxkernels/corrosion.temp_dep:    k_eff  rel diff:  1.1774050e+01 ~  1.1778771e+01 = 4.00847e-04 (FAILED)\nauxkernels/corrosion.temp_dep: Nodal variables:\nauxkernels/corrosion.temp_dep:    phi          rel diff:  0.0000000e+00 ~  1.0000000e+00 = 1.00000e+00 (node 2)\nauxkernels/corrosion.temp_dep:    temperature  rel diff:  3.0161014e+02 ~  3.0160516e+02 = 1.65209e-05 (node 1972)\nauxkernels/corrosion.temp_dep: Element variables:\nauxkernels/corrosion.temp_dep:    phi_jump      rel diff:  1.1892071e+00 ~  6.8658905e-01 = 4.22650e-01 (block 0, elmt 2124)\nauxkernels/corrosion.temp_dep:    porosity      rel diff:  5.0000000e-01 ~  2.5000000e-01 = 5.00000e-01 (block 0, elmt 2341)\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep: exodiff: Files are different\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep:  \nauxkernels/corrosion.temp_dep: ################################################################################\nauxkernels/corrosion.temp_dep: Tester failed, reason: EXODIFF\nauxkernels/corrosion.temp_dep: \nauxkernels/corrosion.temp_dep ............................................................... FAILED (EXODIFF)\nproblems.step_b ........................................................................................... OK\n\n\nFinal Test Results:\n--------------------------------------------------------------------------------------------------------------\nauxkernels/velocity_aux.test .............................................................................. OK\nkernels/simple_diffusion.test ............................................................................. OK\nkernels/darcy_pressure.test ............................................................................... OK\nbcs/outflow.test .......................................................................................... OK\nmaterials/packed_column.test .............................................................................. OK\nkernels/darcy_advection.test .............................................................................. OK\nproblems.step_a .............................................................................. [min_cpus=3] OK\nproblems.step_b ........................................................................................... OK\nauxkernels/corrosion.default ................................................................ FAILED (EXODIFF)\nauxkernels/corrosion.temp_dep ............................................................... FAILED (EXODIFF)\n--------------------------------------------------------------------------------------------------------------\nRan 10 tests in 10.0 seconds. Average test time 2.5 seconds, maximum test time 6.4 seconds.\n8 passed, 0 skipped, 0 pending, 2 FAILED\nEncountering Errors? Please include diagnostic output\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/28874",
          "updatedAt": "2024-10-17T16:10:35Z",
          "publishedAt": "2024-10-17T15:01:36Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThat's interesting. Even though you passed -j8, you actually still ran this in serial.\nSo this is not a parallel consistency issue, it's a problem with the test suite running out of order when running 8 tests at the same time.\nI ll double check it then we'll address this, thanks for reporting.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28874#discussioncomment-10972982",
                  "updatedAt": "2024-10-17T15:07:17Z",
                  "publishedAt": "2024-10-17T15:07:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "nevermind this diffs with -j 1 for my machine. We'll address this",
                          "url": "https://github.com/idaholab/moose/discussions/28874#discussioncomment-10973498",
                          "updatedAt": "2024-10-17T15:48:16Z",
                          "publishedAt": "2024-10-17T15:48:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpeyres"
                          },
                          "bodyText": "A little update: I also tried to compile and run the tests for step11_action, which uses the same tests/auxkernels/corrosion.i test, and it also had EXODIFF.",
                          "url": "https://github.com/idaholab/moose/discussions/28874#discussioncomment-10973737",
                          "updatedAt": "2024-10-17T16:08:09Z",
                          "publishedAt": "2024-10-17T16:08:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes any step after step 10 will incur this.\nThis is likely a problem due to differences in random number generation in the RandomCorrosion model between macos and linux. There should be ways to make it consistent, they just are not in there yet",
                          "url": "https://github.com/idaholab/moose/discussions/28874#discussioncomment-10973779",
                          "updatedAt": "2024-10-17T16:10:36Z",
                          "publishedAt": "2024-10-17T16:10:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Crystal Plasticity with Periodic Boundary Conditions",
          "author": {
            "login": "lkuna24"
          },
          "bodyText": "I am attempting to run crystal plasticity simulations quasi-periodic boundary conditions.  I am applying a displacement to the top/bottom (z) of my RVE while setting the in-plane (x + y) boundaries to be periodic.  For some reason, the PBC simulation shows a very slight yield but otherwise almost linear curve.  To test this, I ran the same simulation utilizing symmetric boundary conditions (u_i = 0 on one of the boundaries normal to displacement), and now I see an expected result.  Here is a plot of the two simulations:\n\nI have included the input file, mesh, and txt to seed the orientations on the blocks.\nAdditionally, I know that the GlobalStrain system has been implemented for SolidMechanics PBC simulations and have also constructed an input for that.  This has an extremely hard time converging, and even looking at the result is quite strange.  It seems to have completed flattened the RVE.  Maybe using GS is the solution to this issue, and maybe I have just not utilized it properly?\n\nAny advice is greatly appreciated.\nThanks for your time and attention.\nDRAGen_RVE_16G.zip\nPeriodic_CP_Test.txt\nEulerAngles.txt\nPeriodic_CP_GS_Test.txt",
          "url": "https://github.com/idaholab/moose/discussions/28778",
          "updatedAt": "2024-10-17T14:58:21Z",
          "publishedAt": "2024-10-04T20:07:29Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "I'm not aware of the periodic boundary conditions having been successfully used with the crystal plasticity models in MOOSE: I am not certain that the assumptions in the CP models are consistent with the PBC assumptions. @SudiptaBiswas, @hugary1995, or @dschwen, do you know?\nNote: if you would like to ask for one of the moose developers to review your input files and/or code, a github branch is the best option. Many of us are unable to download zip files from the internet",
                  "url": "https://github.com/idaholab/moose/discussions/28778#discussioncomment-10885659",
                  "updatedAt": "2024-10-08T22:05:59Z",
                  "publishedAt": "2024-10-08T22:05:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lkuna24"
                          },
                          "bodyText": "Apologies, I should have known.\nI have pushed all the files to a lone branch located here:\nhttps://github.com/lkuna24/moose_CP_files.git",
                          "url": "https://github.com/idaholab/moose/discussions/28778#discussioncomment-10886040",
                          "updatedAt": "2024-10-08T23:29:12Z",
                          "publishedAt": "2024-10-08T23:29:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I suggest you set\nux=0 on left (-x)\nuy=0 on bottom (-y)\nuz=0 on back (-z)\nuz=g on front (+z)\nAlso apply an equal value boundary constraint on front (+z).",
                          "url": "https://github.com/idaholab/moose/discussions/28778#discussioncomment-10886093",
                          "updatedAt": "2024-10-08T23:44:27Z",
                          "publishedAt": "2024-10-08T23:44:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lkuna24"
                          },
                          "bodyText": "Thanks Gary, but I noted in my original post that this is how I first checked as to whether or not the PBC with CP is working:\n\nboundary conditions (u_i = 0 on one of the boundaries normal to displacement)\n\nI should have been a little bit clearer about this.",
                          "url": "https://github.com/idaholab/moose/discussions/28778#discussioncomment-10886233",
                          "updatedAt": "2024-10-09T00:23:05Z",
                          "publishedAt": "2024-10-09T00:23:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay, good.\nThen for the periodic case, do you want to apply displacement periodicity or strain periodicity?\nIf you do displacement periodicity, I believe the plastic spin is almost zero, hence little hardening.",
                          "url": "https://github.com/idaholab/moose/discussions/28778#discussioncomment-10886268",
                          "updatedAt": "2024-10-09T00:32:08Z",
                          "publishedAt": "2024-10-09T00:32:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lkuna24"
                          },
                          "bodyText": "I would hope to conserve the strain periodicity.  As it is an AuxVariable (I believe), I think the PBC has to be specified on displacements (the Variables in this simulation).",
                          "url": "https://github.com/idaholab/moose/discussions/28778#discussioncomment-10906916",
                          "updatedAt": "2024-10-10T17:16:39Z",
                          "publishedAt": "2024-10-10T17:16:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The two are not compatible in general.",
                          "url": "https://github.com/idaholab/moose/discussions/28778#discussioncomment-10907083",
                          "updatedAt": "2024-10-10T17:34:26Z",
                          "publishedAt": "2024-10-10T17:34:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lkuna24"
                          },
                          "bodyText": "Right, so is there a solution to resolve this?  I was under the impression that Global Strain was implemented to conserve strain periodicity.  Maybe the way I have utilized the GlobalStrain Action is just incorrect here?",
                          "url": "https://github.com/idaholab/moose/discussions/28778#discussioncomment-10915150",
                          "updatedAt": "2024-10-11T12:47:59Z",
                          "publishedAt": "2024-10-11T12:47:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lkuna24"
                  },
                  "bodyText": "Just checking in on this post again.  Is it currently not possible to do a CP RVE simulation with PBC in MOOSE?",
                  "url": "https://github.com/idaholab/moose/discussions/28778#discussioncomment-10972894",
                  "updatedAt": "2024-10-17T14:58:22Z",
                  "publishedAt": "2024-10-17T14:58:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Lumped Mass Time Derivative Kernel with AD",
          "author": {
            "login": "msbookwala"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI am trying to create a Lumped Mass Time Derivative Kernel with AD. For that I need $\\dot{u}$ values on nodes.\nIn MassLumpedTimeDerivative kernel, it has been defined using _u_dot_nodal(_var.dofValuesDot()) in the constructor.\nHowever,  with AD, only the methods adDofValues() and adUDot() are available, and not both. How can I define a Lumped mass Time derivative with AD? Is there any workaround?",
          "url": "https://github.com/idaholab/moose/discussions/28855",
          "updatedAt": "2024-10-17T16:14:42Z",
          "publishedAt": "2024-10-15T21:57:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou're right this is not implemented\nI just added this here if you want to try it out\n#28857\nI dont have a test for it yet though\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28855#discussioncomment-10953169",
                  "updatedAt": "2024-10-15T23:02:40Z",
                  "publishedAt": "2024-10-15T23:02:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "msbookwala"
                          },
                          "bodyText": "Thanks a lot Guillaume. I'll try it and let you know.\nMurtaza",
                          "url": "https://github.com/idaholab/moose/discussions/28855#discussioncomment-10953213",
                          "updatedAt": "2024-10-15T23:11:55Z",
                          "publishedAt": "2024-10-15T23:11:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It should be good now. There was an issue if you pulled my branch yesterday",
                          "url": "https://github.com/idaholab/moose/discussions/28855#discussioncomment-10961788",
                          "updatedAt": "2024-10-16T15:53:46Z",
                          "publishedAt": "2024-10-16T15:53:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "msbookwala"
                          },
                          "bodyText": "Hi, follow up on this issue. I implement a moose object ADMassLumpedTimeDerivative in the following way\nHeader file:\n#pragma once\n\n#include \"ADTimeKernel.h\"\n\nclass ADMassLumpedTimeDerivative : public ADTimeKernel\n{\npublic:\n  static InputParameters validParams();\n\n  ADMassLumpedTimeDerivative(const InputParameters & parameters);\n\nprotected:\n  virtual ADReal computeQpResidual() override;\n  const ADVariableValue & _ad_u_dot_nodal;\n  using ADKernel::_var;\n};\nSrc file:\n#include \"ADMassLumpedTimeDerivative.h\"\n\n// MOOSE includes\n#include \"Assembly.h\"\n#include \"MooseVariableFE.h\"\n\n#include \"libmesh/quadrature.h\"\n\nregisterMooseObject(\"discopanterApp\", ADMassLumpedTimeDerivative);\n\nInputParameters\nADMassLumpedTimeDerivative::validParams()\n{\n  InputParameters params = ADTimeKernel::validParams();\n  params.addClassDescription(\n      \"Lumped AD formulation of the time derivative $\\\\frac{\\\\partial u}{\\\\partial t}$. Its \"\n      \"corresponding weak form is $\\\\dot{u_i}(\\\\psi_i, 1)$ where $\\\\dot{u_i}$ denotes the time \"\n      \"derivative of the solution coefficient associated with node $i$.\");\n  return params;\n}\n\nADMassLumpedTimeDerivative::ADMassLumpedTimeDerivative(const InputParameters & parameters)\n  : ADTimeKernel(parameters), _ad_u_dot_nodal(_var.adDofValuesDot())\n{\n}\n\nADReal\nADMassLumpedTimeDerivative::computeQpResidual()\n{\n  return _test[_i][_qp] * _ad_u_dot_nodal[_i];\n}\n\nHowever, I am getting the wrong Jacobian. What am I doing wrong here?\nI also get the following error when I am in debugger:\n\nAssertion `compare_dofs_set == current_dofs_set' failed\nWe're going to see whether the dof sets are the same. IIRC the degree of freedom dependence (as indicated by the dof index set held by the ADReal) has to be the same for every residual passed to this method otherwise constrain_element_matrix will not work.\n\nI can send the whole trace if needed.",
                          "url": "https://github.com/idaholab/moose/discussions/28855#discussioncomment-10963947",
                          "updatedAt": "2024-10-16T20:03:24Z",
                          "publishedAt": "2024-10-16T20:03:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ll take a look tomorrow. I verified we had the right dof dot values, I assumed the derivatives would be correct since they are pretty simple",
                          "url": "https://github.com/idaholab/moose/discussions/28855#discussioncomment-10966419",
                          "updatedAt": "2024-10-17T03:19:38Z",
                          "publishedAt": "2024-10-17T03:19:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Actually looking at the object I just don't think you need AD for this.\nYou can easily implement the Jacobian and use the non AD attribute",
                          "url": "https://github.com/idaholab/moose/discussions/28855#discussioncomment-10970627",
                          "updatedAt": "2024-10-17T11:49:06Z",
                          "publishedAt": "2024-10-17T11:49:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "msbookwala"
                          },
                          "bodyText": "Hi.\nWe compared using TimeDerivative and ADTimeDerivative in our app and found a big difference in speed of codes, hence the motivation to use AD. However, we also need conservation of mass on the dofs. Hence the necessity of lumped mass formulation.",
                          "url": "https://github.com/idaholab/moose/discussions/28855#discussioncomment-10971769",
                          "updatedAt": "2024-10-17T13:28:14Z",
                          "publishedAt": "2024-10-17T13:26:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can implement lumpedMass without AD though.",
                          "url": "https://github.com/idaholab/moose/discussions/28855#discussioncomment-10971928",
                          "updatedAt": "2024-10-17T13:38:31Z",
                          "publishedAt": "2024-10-17T13:38:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "msbookwala"
                          },
                          "bodyText": "Hi,\nThere's already an implementation of a lumped mass time derivative. I just wanted to try lumped mass with AD to see if we get any speed gains for our app",
                          "url": "https://github.com/idaholab/moose/discussions/28855#discussioncomment-10971972",
                          "updatedAt": "2024-10-17T13:43:24Z",
                          "publishedAt": "2024-10-17T13:43:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No AD is not going to be faster for this. AD helps with getting the Jacobian right, but hardcoding the Jacobian is actually better for speed.",
                          "url": "https://github.com/idaholab/moose/discussions/28855#discussioncomment-10972097",
                          "updatedAt": "2024-10-17T13:54:09Z",
                          "publishedAt": "2024-10-17T13:54:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "3D temperature profile to 2D PF simulation",
          "author": {
            "login": "fervaldies"
          },
          "bodyText": "Hello, I was wondering if it is possible to run a thermal simulation in 3D and then extract the data of a 2D cut (or just a thin 3D slice of that model) and use those temperature values into a phase field simulation that has that exact shape and volume. I want to do a solidification model with grain growth and need the temperature evolution for that section of the model to simulate a 2D simulation (just 1 element in depth).",
          "url": "https://github.com/idaholab/moose/discussions/28761",
          "updatedAt": "2024-10-17T10:18:02Z",
          "publishedAt": "2024-10-03T04:53:14Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere are a number of ways you could do that.\nYou could load the 3D results file (checkpoint or exodus) in a SolutionUO and set fields using SolutionAUx. The location of the 2D plane in the 3D system will be used as the location to sample.\nYou could save the variable results in the 3D simulation using ElementValueSampler vectorpostprocessor, then read this data back into the 2D simulation using a PropertyFileReader and a PiecewiseConstrantFromCSV function",
                  "url": "https://github.com/idaholab/moose/discussions/28761#discussioncomment-10827888",
                  "updatedAt": "2024-10-03T05:46:06Z",
                  "publishedAt": "2024-10-03T05:46:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "fervaldies"
                          },
                          "bodyText": "Hello, first, thank you for your answer. So, I am usually using Paraview and I have seen the Slice feature and can have the region (or regions) where my blocks will be located. But how do I extract that temperature field and use it for my other simulation?",
                          "url": "https://github.com/idaholab/moose/discussions/28761#discussioncomment-10865154",
                          "updatedAt": "2024-10-07T09:06:36Z",
                          "publishedAt": "2024-10-07T09:06:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in Paraview I would not know.\nIf you wanted to slice in MOOSE you could modify this vectorprocessor\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/ElementsAlongPlane.html\nto also sample element values like this one\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/ElementValueSampler.html",
                          "url": "https://github.com/idaholab/moose/discussions/28761#discussioncomment-10866963",
                          "updatedAt": "2024-10-07T12:24:07Z",
                          "publishedAt": "2024-10-07T12:24:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fervaldies"
                          },
                          "bodyText": "I have tried using ElementValueSampler vectorpostprocessor, but it is creating a new CSV file for every time step, so I am not really sure how to then read each of these CSV files for each time step with the PiecewiseConstrantFromCSV function",
                          "url": "https://github.com/idaholab/moose/discussions/28761#discussioncomment-10966541",
                          "updatedAt": "2024-10-17T03:45:52Z",
                          "publishedAt": "2024-10-17T03:45:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you are trying to use a variable field through a function, this is not an intended use of functions.\nYou should use a material property instead. These can couple in variables. Or a Functor if you code is using that",
                          "url": "https://github.com/idaholab/moose/discussions/28761#discussioncomment-10969749",
                          "updatedAt": "2024-10-17T10:18:02Z",
                          "publishedAt": "2024-10-17T10:18:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}