{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNC0yM1QyMToyNzo1MS0wNjowMM4AMqHX"
    },
    "edges": [
      {
        "node": {
          "title": "Some artefacts in coupled phase-field-mechanics task",
          "author": {
            "login": "RossMech"
          },
          "bodyText": "Hello everyone,\nI have some numerical or model artefact in coupled phase-field and mechanical model. The value of order parameter is exceeding [0..1] range locally and seems to be some kind of the non-physical oscillation.\n\n\n\nThe model is multi-phase model with penalty stabilization.\nWhat have I done in troubleshooting\n\nThe automatic scaling of the residuals\nMesh size\nThe part of conserved and non-conserved variables in interfacial energy\nChange the form of local free energy functions (different polynomials and cosh)\nTime step reduction\nPenalty size\n\nTime step reduction seems to improve the situation, but the step size is then quite small.\nWould like to discuss the ideas about why it happens and what troubleshooting strategy can be used\nBest regards,\nRostyslav Nizinkovskyi.",
          "url": "https://github.com/idaholab/moose/discussions/17652",
          "updatedAt": "2022-06-21T08:38:58Z",
          "publishedAt": "2021-04-20T10:16:22Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Can you try adding bound constraints on the order parameter? https://mooseframework.inl.gov/source/auxkernels/ConstantBoundsAux.html\nAfter adding the bounds, i.e. a lower bound of 0 and an upper bound of 1, make sure you use one of the two VI solvers, vinewtonssls or vinewtonrsls.",
                  "url": "https://github.com/idaholab/moose/discussions/17652#discussioncomment-634692",
                  "updatedAt": "2022-06-21T08:39:06Z",
                  "publishedAt": "2021-04-20T11:08:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "RossMech"
                          },
                          "bodyText": "Hello, thank you for the response and suggestion. I would try to avoid it, because the task with lagrange multiplier would be very stiff and the time step would decrease drastically as well. But if nothing seems to work, I would try to use this AuxKernel then.",
                          "url": "https://github.com/idaholab/moose/discussions/17652#discussioncomment-634727",
                          "updatedAt": "2022-07-22T15:36:50Z",
                          "publishedAt": "2021-04-20T11:18:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I would try to avoid it, because the task with lagrange multiplier would be very stiff and the time step would decrease drastically as well.\n\nI'm not convinced that's what will happen here. But anyways feel free to try other methods.\nI don't think the oscillations can be completely \"fixed\" if you keep using the penalty approach.",
                          "url": "https://github.com/idaholab/moose/discussions/17652#discussioncomment-634821",
                          "updatedAt": "2022-07-22T15:36:50Z",
                          "publishedAt": "2021-04-20T11:45:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "You mentioned this is a coupled phase-field/mechanics simulation...I would try removing the mechanics part of the problem and see if the issue is still there. The shape of your particle is not circular, if you remove the mechanics part (and you are using isotropic interfacial energy) then you should eventually reach the energy-minimizing circular shape, and depending on the formulation I would not expect order parameter values greater than 1. I would make sure this happens first. Either way it will help diagnose where the problem lies.",
                  "url": "https://github.com/idaholab/moose/discussions/17652#discussioncomment-681366",
                  "updatedAt": "2022-07-22T15:36:50Z",
                  "publishedAt": "2021-04-30T21:47:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "RayTracing error",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi, when running some of the ray tracing tests I get the following error\nA 'LotsOfRaysRayStudy' is not a registered object.\n\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable\n\nJust rebuilt MOOSE yesterday on commit b2d6c22",
          "url": "https://github.com/idaholab/moose/discussions/17718",
          "updatedAt": "2024-08-30T14:18:36Z",
          "publishedAt": "2021-04-30T12:19:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "If you are running from the command-line, you probably just need to add --allow-test-objects\nThe objects is registered to the test app, which we disable by default to avoid test objects being used by accident.\n\n  \n    \n      moose/modules/ray_tracing/test/src/userobjects/LotsOfRaysRayStudy.C\n    \n    \n         Line 18\n      in\n      a2969bb\n    \n  \n  \n    \n\n        \n          \n           registerMooseObject(\"RayTracingTestApp\", LotsOfRaysRayStudy);",
                  "url": "https://github.com/idaholab/moose/discussions/17718#discussioncomment-680001",
                  "updatedAt": "2024-08-30T14:18:37Z",
                  "publishedAt": "2021-04-30T15:08:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "Thats it! Thanks\n\u2026\n________________________________\nFrom: Andrew E Slaughter ***@***.***>\nSent: 30 April 2021 16:08\nTo: idaholab/moose ***@***.***>\nCc: Davis, Andrew ***@***.***>; Author ***@***.***>\nSubject: Re: [idaholab/moose] RayTracing error (#17718)\n\n\nIf you are running from the command-line, you probably just need to add --allow-test-objects\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub<#17718 (comment)>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AASTUSV5F666KCZGZOO5E3TTLLBWXANCNFSM434DMZKQ>.",
                  "url": "https://github.com/idaholab/moose/discussions/17718#discussioncomment-680019",
                  "updatedAt": "2024-08-30T14:18:38Z",
                  "publishedAt": "2021-04-30T15:13:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Steady State Run Termination based on User-Defined Criterion Question",
          "author": {
            "login": "wrkendrick"
          },
          "bodyText": "Hi all,\nI've recently been working with a function that generates a temperature profile when given a temperature flux, and have used this in MOOSE to adjust boundary conditions every non-linear step until convergence is met. The tradition \"convergence\" however is the non-linear residual, which in this case takes too long to converge (I think because there's a natural oscillation of the direction in which the temperatures at the boundary change, making the residual explode in value even when the temperatures themselves are settling within +/- 0.1 degrees K).\nI decided to follow in the footsteps of the Terminator.C user object and focus on using the change in boundary temperatures as my criterion for convergence. My version of the Terminator needs to look at a vector postprocessor (as it's multiple temperatures across the surface) so I stripped a lot of the smart functionality like the parser. It essentially works the same though, where if the criterion is satisfied then it should run _fe_problem.terminateSolve().\nMy problem is that this isn't working right now. It's running the above function but it doesn't interrupt the run. I think this is because the above is meant to kick in at the end of a time step, not in the middle of a solve. I could be wrong, but if I am correct is there any other function/structure I can use to tell MOOSE to cleanly wrap up the run? I can force it by making convergence act as an error, but I don't think it will output results in this case, so there's no real point.\nBelow is my vector-adjusted Terminator:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"libmesh/libmesh_config.h\"\n\n#ifdef LIBMESH_HAVE_FPARSER\n\n#include \"Terminator.h\"\n#include \"MooseApp.h\"\n#include \"MooseEnum.h\"\n#include \"Executioner.h\"\n\nregisterMooseObject(\"MooseApp\", Terminator);\n\ndefineLegacyParams(Terminator);\n\nInputParameters\nTerminator::validParams()\n{\n  InputParameters params = GeneralUserObject::validParams();\n  params.addClassDescription(\"Adjusted Terminator for HTPIPE purposes.\");\n  params.addRequiredParam<std::vector<VectorPostprocessorName>>(\n      \"vpp_names\", \"The list of name of VectorPostProcessesors to watch for convergence\");\n  params.addRequiredParam<double>(\"criterion\", \"Convergence criterion\");\n  MooseEnum failModeOption(\"HARD SOFT\", \"HARD\");\n  params.addParam<MooseEnum>(\n      \"fail_mode\",\n      failModeOption,\n      \"Abort entire simulation (HARD) or just the current time step (SOFT).\");\n  params.addParam<std::string>(\n      \"message\", \"An optional message to be output when the termination condition is triggered\");\n\n  MooseEnum errorLevel(\"INFO WARNING ERROR\");\n  params.addParam<MooseEnum>(\n      \"error_level\",\n      errorLevel,\n      \"The error level for the message. A level of ERROR will always lead to a hard \"\n      \"termination of the entire simulation.\");\n  \n  return params;\n}\n\nTerminator::Terminator(const InputParameters & parameters)\n  : GeneralUserObject(parameters),\n    _fail_mode(getParam<MooseEnum>(\"fail_mode\").getEnum<FailMode>()),\n    _error_level(isParamValid(\"error_level\")\n                     ? getParam<MooseEnum>(\"error_level\").getEnum<ErrorLevel>()\n                     : ErrorLevel::NONE),\n    _vpp_names(getParam<std::vector<VectorPostprocessorName>>(\"vpp_names\")),\n    _criterion(getParam<double>(\"criterion\"))\n{\n  // sanity check the parameters\n  if (_error_level == ErrorLevel::ERROR && _fail_mode == FailMode::SOFT)\n    paramError(\"error_level\", \"Setting the error level to ERROR always causes a hard failure.\");\n  if (_error_level != ErrorLevel::NONE && !isParamValid(\"message\"))\n    paramError(\"error_level\",\n               \"If this parameter is specified a `message` must be supplied as well.\");\n  _vpp_num = _vpp_names.size();\n  _vpp_old.resize(_vpp_num);\n  _vpp_old_holder.resize(_vpp_num);\n  _vpp_old_old.resize(_vpp_num);\n}\n\nvoid\nTerminator::handleMessage()\n{\n  if (!isParamValid(\"message\"))\n    return;\n\n  auto message = getParam<std::string>(\"message\");\n  switch (_error_level)\n  {\n    case ErrorLevel::INFO:\n      mooseInfo(message);\n      break;\n\n    case ErrorLevel::WARNING:\n      mooseWarning(message);\n      break;\n\n    case ErrorLevel::ERROR:\n      mooseError(message);\n      break;\n\n    default:\n      break;\n  }\n}\n\nvoid\nTerminator::execute()\n{\n  converged = true;\n  for (unsigned int i = 0; i < _vpp_num; ++i) {\n    _fe_problem.terminateSolve();\n    std::cout << _vpp_names[i] << \"\\n\";\n    const VectorPostprocessorValue* value_column = &getVectorPostprocessorValueByName(_vpp_names[i], \"flux_aggregate\");\n    VectorPostprocessorValue old_old_value_column = _vpp_old_old[i];\n    if (old_old_value_column.size() == 0)\n      old_old_value_column.resize(value_column->size());\n    _vpp_old_holder[i] = *value_column;\n    for (int j=0; j < value_column->capacity(); j++) {\n      std::cout << j << \": NEW \" << value_column->at(j) << \"\\n\";\n      std::cout << j << \": OLD_OLD \" << old_old_value_column[j] << \"\\n\";\n      double check_val = std::abs(value_column->at(j) - old_old_value_column[j]);\n      if (check_val > _criterion) {\n        converged = false;\n        break;\n      }\n    }\n  }\n  _vpp_old_old = _vpp_old;\n  _vpp_old = _vpp_old_holder;\n\n  // request termination of the run or timestep in case the expression evaluates to true\n  if (converged)\n  {\n    if (_fail_mode == FailMode::HARD)\n    {\n      printf(\"REACHED HERE WHERE IT SHOULD HAVE\\n\");\n      handleMessage();\n      _fe_problem.terminateSolve();\n    }\n    else\n    {\n      _console << name() << \" is marking the current solve step as failed.\\n\";\n      handleMessage();\n      getMooseApp().getExecutioner()->picardSolve().failStep();\n    }\n  }\n}\n\n#endif\n\nNote:\n\nThere's a bunch of stuff left in the code from the old Terminator that doesn't really need to be there any more.\nConvergence is based on comparing the nth non-linear step temperatures and the (n-2)th non-linear step's termperatures.",
          "url": "https://github.com/idaholab/moose/discussions/17705",
          "updatedAt": "2022-07-18T19:15:25Z",
          "publishedAt": "2021-04-28T19:46:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "Are you setting the \"execute_on\" parameter? If not, set this to LINEAR and see if it works.\nFrom a software design perspective, you should not modify the existing object. You should just create a new object that inherits from GeneralUserObject or Terminator, depending if you need some of the same features. The object you create should go into your application.",
                  "url": "https://github.com/idaholab/moose/discussions/17705#discussioncomment-675124",
                  "updatedAt": "2022-07-18T19:15:33Z",
                  "publishedAt": "2021-04-29T14:23:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wrkendrick"
                          },
                          "bodyText": "Are you setting the \"execute_on\" parameter? If not, set this to LINEAR and see if it works.\n\nYep, currently running every non-linear, tried on linear and still getting the same deal. If I set the error_level to WARNING then the warning goes off when it should (each nonlinear step), but the run fails to terminate, suggesting _fe_problem.terminateSolve() may not be able to interrupt mid-run?\n\nFrom a software design perspective, you should not modify the existing object. You should just create a new object that inherits from GeneralUserObject or Terminator, depending if you need some of the same features. The object you create should go into your application.\n\nYou're absolutely correct, I'm being quick and sloppy right now, I intend to clean it all up and write it the proper way once I can confirm it works as intended.",
                          "url": "https://github.com/idaholab/moose/discussions/17705#discussioncomment-675352",
                          "updatedAt": "2022-07-18T19:15:31Z",
                          "publishedAt": "2021-04-29T15:07:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Looked at the code a bit and you are right, it will only terminate on timesteps. The check for the termination flag occurs in Transient::keepGoing, which is called by Transient::execute.\n@fdkong Is there a supported way to terminate the solve during the linear/non-linear iterations?",
                          "url": "https://github.com/idaholab/moose/discussions/17705#discussioncomment-675488",
                          "updatedAt": "2022-09-18T10:18:51Z",
                          "publishedAt": "2021-04-29T15:29:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "I decided to follow in the footsteps of the Terminator.C user object and focus on using the change in boundary temperatures as my criterion for convergence.\n\nIt is not right approach to me if you want to have the simulation converged based your rules.\nYou should  check the function  checkNonlinearConvergence. You could derive from FEProblem, and write your own version of checkNonlinearConvergence",
                  "url": "https://github.com/idaholab/moose/discussions/17705#discussioncomment-676304",
                  "updatedAt": "2022-09-18T10:18:51Z",
                  "publishedAt": "2021-04-29T18:40:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "I don't believe Steady (a single solve) is the right way to approach this problem. With complex problem, you are likely to get a more robust solve if you can break it into \"steps\". Even if there is no time dependency in your equation set you might choose to ramp up boundary or body forces over a series of solve steps. This is common in solid mechanics and is called \"load steps\". If you do that, you would use the \"Transient\" executioner with perhaps a fake or non-dimensional time (used to control your load steps) and your terminator condition would also just naturally work as-is.",
                  "url": "https://github.com/idaholab/moose/discussions/17705#discussioncomment-676488",
                  "updatedAt": "2022-09-18T10:18:14Z",
                  "publishedAt": "2021-04-29T19:25:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Proper use of InterfaceKernels",
          "author": {
            "login": "ke7kto"
          },
          "bodyText": "I'm modeling a diffusion process with a vapor-solid interface and a temperature gradient in one dimension. This seems like a very good fit for InterfaceKernels, but I cannot obtain a steady-state solve using InterfaceDiffusionBoundaryTerm, InterfaceDiffusionFluxMatch or a combination of the two in any event such that concentrations are greater than zero at the interface.\nTaking out the interface and setting making the variable representing molar quantity the same in each subdomain allows for a solve. The reaction_1D_steady test solves successfully on my installation.\nI hate asking \"what am I doing wrong?\" questions, but I'm really stuck here. How do I use the InterfaceKernels properly? I have attached the input file I'm using.\nsimple.txt",
          "url": "https://github.com/idaholab/moose/discussions/17628",
          "updatedAt": "2022-08-10T00:39:34Z",
          "publishedAt": "2021-04-16T20:59:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad Can you help with this question?",
                  "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-640541",
                  "updatedAt": "2022-08-10T00:39:45Z",
                  "publishedAt": "2021-04-21T15:03:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "It turns out that I have an issue which seems to be unrelated to InterfaceKernels. I'll update when I've isolated the root of the problem.",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-641063",
                          "updatedAt": "2022-08-10T00:39:45Z",
                          "publishedAt": "2021-04-21T16:56:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "There are four issues with the input file that prevent convergence\n\nThe initial condition for temperature was not close enough to the solution\nline 173 uses an expression that evaluates to log(0) at x=0\nThe boundary condition for line 122 is set to the wrong variable\nThere seems to be an issue with using 'exp' in parsedFunction to generate a material property. I can get convergence when I use a custom Material class using the same function",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-641176",
                          "updatedAt": "2022-08-10T00:39:45Z",
                          "publishedAt": "2021-04-21T17:18:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "So are the InterfaceKernels you're using working as desired with the resolution of your issues 1-4?",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-641283",
                          "updatedAt": "2022-08-10T00:39:46Z",
                          "publishedAt": "2021-04-21T17:41:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "Good question. They're not working as I would have expected them to, but I could be misinterpreting the way that they are supposed to work. Is the InterfaceDiffusionBoundaryTerm supposed to apply to diffusion within the interface, across the boundary, or both?\nWhat I find most puzzling is that the observed concentration difference across the interface changes direction when I switch between radial and cartesian coordinates. I've made a new input file without the previous problems (and removing the temperature dependence), which is attached.\nsimplenoT.txt",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-641676",
                          "updatedAt": "2023-04-28T20:20:11Z",
                          "publishedAt": "2021-04-21T19:18:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "I'm not sure I was very clear. I do not think that the InterfaceKernels are working properly. Here's why:\nThe file I've attached has Dirichlet boundary conditions as follows:\n\nConcentration 0.16 @ x=0\nConcentration 0 @ x=0.031782\n\nThere is an interface at x=0.0061625. Everything is in 1D. I'm using InterfaceDiffusionBoundaryTerm and InterfaceDiffusionFluxMatch.\n\n\nDiffusivity is set to 10\u207b\u2075 throughout both subdomains. If D or D_neighbor are set to any value other than the diffusivity of the bulk, a no-flux solution is obtained.\n\n\nFor cartesian coordinates and boundary diffusivities of 10\u207b\u2075, there is a jump to a concentration of ~0.65 on the right-hand side of the interface, which seems to be in error.\n\n\nWith coord_type = RZ and rz_coord_axis = Y (radially symmetric 1D diffusion) the results are more believable, with a concentration drop from ~0.055 to ~0.027 across the interface - though if I understand correctly, the concentrations on either side should be equal for this situation.",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-646942",
                          "updatedAt": "2023-04-28T20:20:11Z",
                          "publishedAt": "2021-04-22T20:34:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "The solution is also dependent on the number of elements",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-647003",
                          "updatedAt": "2022-10-03T02:53:32Z",
                          "publishedAt": "2021-04-22T20:55:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Sorry for being slow to respond @ke7kto. I have to say that I've looked at this pair of interface kernels before and it took me a fair while to understand what they are doing in a finite element sense. And it's been long enough since then that I've forgotten again. @dschwen is the author of those objects so maybe he can explain them.\nI will say that I am a fan of PenaltyInterfaceDiffusion which is actually a test object for the framework. I think we should probably move it into the framework so users have access to that object. But you are welcome to copy those sources for your own app. PenaltyInterfaceDiffusion simultaneously enforces equal flux across an interface and solution continuity as well. It also preserves the optimal convergence rate of your finite element method, e.g. second order if you are using first order Lagrange bases, given an appropriate choice of penalty parameter (for well scaled problems something like 1e6 is a good choice).",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-666785",
                          "updatedAt": "2022-10-03T02:53:32Z",
                          "publishedAt": "2021-04-27T22:16:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "@lindsayad Thanks for the reply! Using PenaltyInterfaceDiffusion, I get a good solve, the results are in line with expectations. For my specific problem 1e6 was too large a penalty, values from 1.0-1e5 worked well. Is there a straightforward way I could check the matrix properties to get an idea of the appropriate scale for the penalty parameter in general?\nAlso, looking at PenaltyInterfaceDiffusion, It seems I can specify a material property to calculate what the discontinuity should be. Is there a way to define a material on an interface, especially as dependent on the difference of some variable on either side of the interface? I would need some functionality like that for the non-toy version of this problem.",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-666898",
                          "updatedAt": "2022-10-03T02:53:32Z",
                          "publishedAt": "2021-04-27T22:58:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@lindsayad Thanks for the reply! Using PenaltyInterfaceDiffusion, I get a good solve, the results are in line with expectations. For my specific problem 1e6 was too large a penalty, values from 1.0-1e5 worked well. Is there a straightforward way I could check the matrix properties to get an idea of the appropriate scale for the penalty parameter in general?\n\nIt should at least be as large as your other diagonals, probably larger. It's a balance between how close to continuous you want the solution to be and how well conditioned you want your matrix to be. Matching the diagonals will give you the best conditioning but may not make your solution as close to continuous as you want (or maybe it does!). You can always inspect your matrix using the -ksp_view_pmat command line option (this is consumed by PETSc). You probably only want to use that option if your problem is reasonably small.\n\nAlso, looking at PenaltyInterfaceDiffusion, It seems I can specify a material property to calculate what the discontinuity should be. Is there a way to define a material on an interface, especially as dependent on the difference of some variable on either side of the interface? I would need some functionality like that for the non-toy version of this problem.\n\nYou are looking for an InterfaceMaterial. You can find an example of just your use case in moose/test/src/materials/JumpInterfaceMaterial.C",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-672212",
                          "updatedAt": "2022-10-03T02:53:33Z",
                          "publishedAt": "2021-04-28T21:29:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "This is exactly what I needed. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-672350",
                          "updatedAt": "2022-10-03T02:53:40Z",
                          "publishedAt": "2021-04-28T21:54:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Grain growth from existing mesh file",
          "author": {
            "login": "aashiquear"
          },
          "bodyText": "I like to initialize a grain growth model from an existing mesh file (exodus format), that is already run a grain growth simulation for a while. I found there is an option in the PolycrystalVariables action \"initial_from_file = true\". Using that option I have setup a FileMeshGenerator Mesh and input the mesh file that I have already run for a while. This runs quite well for the first few steps but failed with an exit code 6 and a comment \"Refinement flags were not consistent between processors!\". Upon looking into the output I found, it initializes the grains from the previous file but once it started running there is instability around the four borders. Is there any example out there where it uses the \"initial_from_file = true\" in PolycrystalVariable action? Here is the file I am trying to run:\ngrain_growth.txt",
          "url": "https://github.com/idaholab/moose/discussions/17695",
          "updatedAt": "2022-10-06T16:19:36Z",
          "publishedAt": "2021-04-27T23:40:27Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "There are known issues with reading in a solution from an exodus file where adaptivity has been used. Generally we prefer to restart from either a checkpoint file or one of the libMesh formats (XDA/XDR). You might try outputting those and see if you can get it going (start with a small test case to avoid wasting time). Is this a restart case or are you creating a whole new simulation and just hoping to import some data from your previous simulation?",
                  "url": "https://github.com/idaholab/moose/discussions/17695#discussioncomment-670214",
                  "updatedAt": "2022-10-06T16:19:36Z",
                  "publishedAt": "2021-04-28T14:18:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aashiquear"
                          },
                          "bodyText": "Right now I am trying a restart case, but eventually what I required is to run a whole new grain growth simulation using the grain structure generated from the previous file. I am running a simultaneous grain growth and another physics using a multiapp to see the effect of the other physics when grain migrated. If I start from voronoi IC the grain growth starts slow as it equilibrates to the GB width first and I failed to capture the initial effect as my other physics thinking the grain structure as static in the beginning. So, what I am trying to capture here is that both the script in multiapp calibrated in such that the initial GB width equilibration doesn't require and grain migration starts right away. After yesterday, I have run the same file I submit here using a single processor and can run the full simulation without failing. I get what I was looking for but there is instability (like the order parameter fluctuates) around the domain border still present. I am going to check with outputting in XDA format and re-reading the file in the new simulation. Please share your idea if there is a better (and easy) way of doing the same. Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/17695#discussioncomment-670357",
                          "updatedAt": "2022-10-06T16:19:57Z",
                          "publishedAt": "2021-04-28T14:44:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "There is some low hanging fruit in terms of optimizing and fixing some of the initial condition behavior of simulations with large numbers of variables. We already have this on our todo list, however being aware that others are needing this may help to bump priority.\n@fdkong",
                          "url": "https://github.com/idaholab/moose/discussions/17695#discussioncomment-670370",
                          "updatedAt": "2022-10-06T16:19:59Z",
                          "publishedAt": "2021-04-28T14:45:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Applying constraints",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "Hello,\nI am quite new to MOOSE and I have a lot of questions, but I will start with these here.\n\nIs there a way that I can access and manipulate the stiffness matrix before solving for the unknowns?\nHow are the constraints are enforced? Do you use penalty method?\nIs there an implementation for lagrange multiplier that relates the unknown variables to each other? If not, do you have recommendation where to start implementing it?\n\nWhat I am trying to do is to apply some constraint relations between the unknown variables (displacement), for instance, if I\u2019m solving for u, then I want u^1=u^2+u^3, where the numbers are node numbers. As you can see, this should decrease the problem DOF, but I am not sure exactly how to do so in MOOSE. Some of these constraints are in relation to the face nodes (up and down) and edges nodes and so on.\nThank you in advance\nKhaled",
          "url": "https://github.com/idaholab/moose/discussions/17455",
          "updatedAt": "2022-06-02T08:45:11Z",
          "publishedAt": "2021-03-29T21:35:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "How are the constraints are enforced? Do you use penalty method?\n\nThe most typical forms of constraints (periodic boundary conditions, hanging nodes on adaptively refined meshes, and Dirichlet boundary conditions) are almost always enforced directly; we have a constraint matrix C that turns a Jacobian K into C^T*K*C (and consistently modifies the residual, and may add terms corresponding to heterogeneous offsets for non-zero Dirichlet conditions).\nThat's not as easy to do with nonlinear constraints, though.  For those we typically use a penalty term or a Lagrange multiplier.  For a penalty method, there might be some classes in include/constraints/ that would be helpful - e.g. although the TiedValueConstraint only does a simple equality constraint (made less simple by the fact that it can enforce equality in contact problems that don't line up precisely node to node), the kernel is straightforward enough and you could try adding your own subclass with a nonlinear kernel.  For a Lagrange multiplier method, perhaps the mortar method code would be the best example?",
                  "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-640767",
                  "updatedAt": "2022-06-02T08:45:11Z",
                  "publishedAt": "2021-04-21T15:50:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "As you can see, this should decrease the problem DOF\n\nAlmost forgot - I'm afraid this isn't the case for us.  Not only does a penalty method leave DoF count the same and a Lagrange multiplier add additional DoFs, but even with direct enforcement of constraints we don't currently \"condense\" the linear system afterwards, we typically either leave constraint equations in the matrix rows corresponding to constrained DoFs, or we leave a 1 on the diagonal to keep those DoFs from causing solvers any difficulty and then we calculate the constrained DoF values directly after the solve is done.",
                          "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-640788",
                          "updatedAt": "2022-06-02T08:46:35Z",
                          "publishedAt": "2021-04-21T15:53:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "KhaledNabilSharafeldin"
                  },
                  "bodyText": "Hello @roystgnr Thank you for your reply! Since the time I have posted this I arrived at these questions:\n\nI started using LinearNodalConstraint for setting up these constraints using penalty method, but I have quite a few questions.\n\nThis constraint function inherits from NodalConstraint which has a formulation type parameter that is either penalty or kinematic. The kinematic one seems to be deleting the original residual for the secondary node, then adding in the new QpJacobian provided by the LinearNodalConstraint. So, I wanted to verify if this is the case; that it is possible to implement the direct method using this parameter while setting the _penalty to 1 and using the weight as a sign indicator. The total DoF number does not change since I am adding constraint functions in their place.\nThe way I am setting up these constraints is by passing 2 vectors; the secondary_nodes vector has only ONE node ID, while the primary has multiple node IDs corresponding to it. Is this the correct way to go through it? I just want to confirm this.\nFor the equation of the constraint itself, do all the variables should be on the RHS of the equation i.e., secondary-primary=0 (u^1-[ u^2+u^3]=0), or in the form of secondary=primary (u^1=u^2+u^3). This will affect the equation signs and I just would like to confirm it. From what I have seen in the NodalConstraint and LinearNodalConstraint, there\u2019s no sign switching going on, so I think it should be secondary-primary=0.\n\n\nDo node IDs numbering start from zero or 1? Because when visualizing the results, the global ID number starts from 1, but it seems like my Dirichlet BC are applied on a node ID 1 off from what I set it to. I am planning on using mesh pointers in the future, but it seems like it is going to take some time to get familiar with it and I have more questions about it, so I am not making it a priority right now. I am using mesh_renumbering flag to false to avoid any problems for now.\n\nThank you so much for taking the time to read this! Really appreciate your help!",
                  "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-660795",
                  "updatedAt": "2022-06-16T19:06:52Z",
                  "publishedAt": "2021-04-26T16:28:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "I'm afraid I'm going to have to punt on the NodalConstraint questions - I'm not personally familiar with those classes, and looking at https://mooseframework.inl.gov/source/constraints/LinearNodalConstraint.html is a bit dismaying; it looks like it was written by someone so deep in a solid mechanics rabbit hole that they weren't even thinking about the existence of a wider variety of variables.\nBut for the more libMesh-specific question:\n\nDo node IDs numbering start from zero or 1?\n\nYes!  Your node IDs can in general be zero-based, or one-based, or zero-based but with big gaps from adaptive mesh coarsening removing nodes, or sparse from communication-free parallel creation of new nodes ... libMesh supports all of that, which is nice if you want to use such capability but less nice if you wish you could assume nobody else is using that support.  Most commonly we use zero-based numbering, initially contiguous from most mesh generators (or from any mesh generator if you hadn't disabled node renumbering, which does a sweep at init/reinit times to eliminate any numbering gaps), but some output formats don't support zero as an ID (or don't support gaps in node numbers, or both) so we have to translate node numbers back and forth, and the node number you see in your debugger might not match the one you see in your viz program.",
                          "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-665368",
                          "updatedAt": "2022-06-16T19:07:07Z",
                          "publishedAt": "2021-04-27T16:33:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Just a quick comment here: the NodalConstraint works for general variables not just displacements in mechanics. I won't comment on whether the original developer is deep in the solid mechanics rabbit hole \ud83d\ude02",
                          "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-665500",
                          "updatedAt": "2022-06-16T19:07:07Z",
                          "publishedAt": "2021-04-27T17:05:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "But I agree -- some words in the documentation page might be misleading.",
                          "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-665504",
                          "updatedAt": "2022-06-16T19:07:07Z",
                          "publishedAt": "2021-04-27T17:06:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "well thank you both @roystgnr and @hugary1995 for the quick responses!\nWhat I am trying to actually do is to apply the minimal kinematic boundary condition... which seemed like a reasonable thing to do using those classes. I already did this but the \"results\" seems off, when using the penalty method the solution doesn't really converge, and for the kinematic, it doesn't even solve linearly giving off DIVERGED_NANORINF error.\nI can see that there is currently ongoing development for this by averaging either the microscopic P or F depending on the applied macroscopic quantities in this #17475\nI am still not sure exactly why the approach mentioned in this question wouldn't work, but I am looking forward for #17475 to be merged.",
                          "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-668670",
                          "updatedAt": "2022-07-30T17:00:53Z",
                          "publishedAt": "2021-04-28T10:48:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "2021 March and April News",
          "author": {
            "login": "aeslaughter"
          },
          "bodyText": "We finally were able to get the updates to our newsletter merged, hopefully we will be back on track for more regular updates.\nMarch 2021 News\nApril 2021 News",
          "url": "https://github.com/idaholab/moose/discussions/17690",
          "updatedAt": "2021-04-27T15:03:39Z",
          "publishedAt": "2021-04-27T15:03:18Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Postprocessing Kernel Variables",
          "author": {
            "login": "prajwalka"
          },
          "bodyText": "Hi,\nI'm fairly new to Moose and had this question.\nIs there an equivalent of \"Material Property\" for kernels? I wanted to use \"declareProperty\" for a kernel variable and postprocess it using something like MaterialRankTwoAux kernel. I also wanted the value of this variable at the previous time step.\nFor example, in enhanced strain methods, the value of stress and strain obtained from the linear elastic material need to be modified at the kernel level using tensors depending on the quadrature point. Is there any way of outputting these modified stress and strain values which are stored in my kernel? Or is it preferred that this modification is done using a User Object or any other method?\nThanks a lot!",
          "url": "https://github.com/idaholab/moose/discussions/17681",
          "updatedAt": "2023-04-21T17:17:30Z",
          "publishedAt": "2021-04-26T18:46:07Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I would recommend you to write a material property that calculates the modified stress/strain.",
                  "url": "https://github.com/idaholab/moose/discussions/17681#discussioncomment-663714",
                  "updatedAt": "2023-04-21T17:17:34Z",
                  "publishedAt": "2021-04-27T10:02:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "You can also create a custom AuxKernel to perform a calculation that uses coupled in the solution variable. We have an example of this in our workshop presentation:\n\nThe slides are here https://mooseframework.inl.gov/workshop/#/28\nOur discussion about it is here: https://www.youtube.com/watch?v=2tJwBsYaLaI",
                          "url": "https://github.com/idaholab/moose/discussions/17681#discussioncomment-664824",
                          "updatedAt": "2023-04-21T17:17:34Z",
                          "publishedAt": "2021-04-27T14:59:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "New version of MOOSE computationally slower than older version",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Dear all,\nI was facing performance issues with current version of MOOSE as it seems to be slower than the older versions dated about an year ago. My plasticity model with ~5000 Dof's took nearly an hour of computational time, while the legacy code ran in roughly around 35mins. The related discussion can be traced back to [https://github.com//discussions/16372]. Unfortunately the compilers here are upgraded and hence i am unable to build the legacy sources now, which might have given a chance for me to check and re-confirm their time. Probably somebody there in the team could test the attached files (with older versions ranging around May 2020) and check if these can be run under an hour. Any insights on the possible reasons for the slower performance will be appreciated, as this may lead to a huge savings in time while conduting the iterative simulation that i am currently working upon.\n23042021.zip",
          "url": "https://github.com/idaholab/moose/discussions/17671",
          "updatedAt": "2022-06-15T15:08:21Z",
          "publishedAt": "2021-04-23T15:09:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Couple of questions:\n\ncould you let us the commit hash of the old MOOSE you referred to?\nare you running exactly the same input file and using the same number of processors?\nSince you use AD, you should set 'solve_type = Newton' instead of 'PJFNK'. Could you change the solver type and rerun it?",
                  "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-650687",
                  "updatedAt": "2022-06-15T15:08:21Z",
                  "publishedAt": "2021-04-23T16:00:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "Dear Wen,\nHere are my answers.\n              1) Could you let us the commit hash of the old MOOSE you\nreferred to?\n git log -1\n                commit 1cc6b7e\n                Merge: 314e8b9 6fd9c7f\n               Author: moosetest ***@***.***>\n               Date:   Mon May 18 17:31:13 2020 -0600\n              Merge commit '6fd9c7f846a43385430795ac9e971716d2218d1c'\n\n             2) Are you running exactly the same input file and using the\nsame number of processors?\n                 Yes the same input file and the same number of processors\n(#10)\n\n              3) Since you use AD, you should set 'solve_type = Newton'\ninstead of 'PJFNK'. Could you change the solver type and rerun it?\n                  I did try with Newton, but for some reasons it wouldn't\nrun at that time. Will give a try again and let you know.\n\nThe functional filename is different in the inputfile and so request you to\nset the actuals while running the computation.\n\n\nKind regards,\nArun\n\u2026\nOn Fri, Apr 23, 2021 at 5:00 PM Wen Jiang ***@***.***> wrote:\n Couple of questions:\n\n    1. could you let us the commit hash of the old MOOSE you referred to?\n    2. are you running exactly the same input file and using the same\n    number of processors?\n    3. Since you use AD, you should set 'solve_type = Newton' instead of\n    'PJFNK'. Could you change the solver type and rerun it?\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#17671 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AJSA254IZSIE55IBI25IRC3TKGKTLANCNFSM43O2KVQQ>\n .",
                  "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-651031",
                  "updatedAt": "2022-06-15T15:08:27Z",
                  "publishedAt": "2021-04-23T17:26:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I can reproduce @abarun22 's results.\nI slightly modified his input file to simplify things:\n[Mesh]\n  type = FileMesh\n  file = Specimen_QtrModel.e\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  volumetric_locking_correction = true\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    strain = FINITE\n    incremental = true\n    add_variables = true\n    use_automatic_differentiation = true\n  []\n[]\n\n[BCs]\n  [Load_RE]\n    type = FunctionDirichletBC\n    variable = disp_x\n    function = '0.0226*t'\n    boundary = \"Right_end\"\n    preset = false\n  []\n  [Symm_LE]\n    type = DirichletBC\n    variable = disp_x\n    value = 0\n    boundary = \"Left_end\"\n  []\n  [Symm_BY]\n    type = DirichletBC\n    variable = disp_y\n    value = 0.0\n    boundary = \"Bottom\"\n  []\n  [Symm_LZ]\n    type = DirichletBC\n    variable = disp_z\n    value = 0.0\n    boundary = \"Lateral_face\"\n  []\n  [Const_RY]\n    type = DirichletBC\n    variable = disp_y\n    value = 0.0\n    boundary = \"Right_end\"\n  []\n  [Const_RZ]\n    type = DirichletBC\n    variable = disp_z\n    value = 0.0\n    boundary = \"Right_end\"\n  []\n[]\n\n[Functions]\n  [hf]\n    type = PiecewiseLinear\n    data_file = PW_last_iter.csv\n    scale_factor = 1\n    format = columns\n  []\n[]\n\n[Materials]\n  [elasticity_tensor]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 2.02E+11\n    poissons_ratio = 0.315\n  []\n  [isotropic_plasticity]\n    type = ADIsotropicPlasticityStressUpdate\n    yield_stress = 554146341.5\n    hardening_function = hf\n  []\n  [radial_return_stress]\n    type = ADComputeMultipleInelasticStress\n    inelastic_models = 'isotropic_plasticity'\n  []\n[]\n\n[Postprocessors]\n  [nl_its]\n    type = NumNonlinearIterations\n  []\n  [time]\n    type = PerfGraphData\n    section_name = Root\n    data_type = TOTAL\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu       superlu_dist'\n\n  dt = 0.1\n  end_time = 25\n\n  nl_rel_tol = 1e-6\n  nl_max_its = 20\n\n  automatic_scaling = true\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  print_linear_residuals = false\n[]\n\nI use the same conda env to make a more fair comparison. Most important versions are:\nmoose-mpich               3.3.2                   build_5    idaholab\nmoose-petsc               3.14.2                  build_4    idaholab\nmoose-tools               2021.01.06                 py_0    idaholab\n\nNew moose (c7126c8) total run time: 449.5038 seconds\nOld moose (1cc6b7e) total run time: 296.3510 seconds\nThis may well be due to a simple config change or default option change. But I think there is value in tracking it down.",
                  "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652421",
                  "updatedAt": "2022-06-15T15:08:32Z",
                  "publishedAt": "2021-04-24T00:53:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "BTW, this is using 8 processors on my Ubuntu.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652424",
                          "updatedAt": "2022-06-15T15:08:27Z",
                          "publishedAt": "2021-04-24T00:55:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Which commit is causing this?",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652447",
                          "updatedAt": "2022-06-15T15:08:31Z",
                          "publishedAt": "2021-04-24T01:13:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I don't know. I haven't run any bisect nor any profiling yet.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652448",
                          "updatedAt": "2022-06-15T15:08:27Z",
                          "publishedAt": "2021-04-24T01:15:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Gary can you see whether changing to nonsparse changes things? (I\u2019m guessing you were running with default sparse crowd config?)",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652574",
                          "updatedAt": "2022-09-22T08:48:45Z",
                          "publishedAt": "2021-04-24T03:12:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I don't know. I haven't run any bisect nor any profiling yet.\n\n@hugary1995 There are definitely some changes inADComputeMultipleInelasticStress, which also might cause this issue.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652582",
                          "updatedAt": "2022-09-22T08:48:45Z",
                          "publishedAt": "2021-04-24T03:19:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "@lindsayad Yeah I was running with default config. When I try to switch to nonsparse local indexing I get the following error:\n$> ./configure --with-ad-indexing-type=local                                                                                             \u2500\u256f\n---------------------------------------------\n----------- Configuring MOOSE ---------------\n---------------------------------------------\nconfiguring with derivative backing array size of 50\nconfiguring with AD indexing type local\nconfiguring with derivative type sparse\nchecking for x86_64-conda-linux-gnu-pkg-config... no\nchecking for pkg-config... /usr/bin/pkg-config\nconfigure: checking system for libpng\nconfiguring with libpng support\nconfigure: creating ./config.status\nconfig.status: creating conf_vars.mk\nconfig.status: creating framework/include/base/MooseConfig.h.tmp\nconfig.status: executing framework/include/base/MooseConfig.h commands\nconfig.status: creating framework/include/base/MooseConfig.h - prefix MOOSE for framework/include/base/MooseConfig.h.tmp defines\n---------------------------------------------\n--------- Done Configuring MOOSE ------------\n---------------------------------------------\n\n$> ./configure --with-derivative-type=nonsparse                                                                                          \u2500\u256f\n---------------------------------------------\n----------- Configuring MOOSE ---------------\n---------------------------------------------\nconfiguring with derivative backing array size of 50\nconfigure: error: cannot use global AD indexing with a nonsparse derivative container\n\nDo you have any clue?",
                  "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652586",
                  "updatedAt": "2022-06-15T15:08:33Z",
                  "publishedAt": "2021-04-24T03:21:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Nvmd, I need to do ./configure --with-derivative-type=nonsparse --with-ad-indexing-type=local . I thought the configure script knows about the current config status.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652593",
                          "updatedAt": "2022-06-15T15:08:27Z",
                          "publishedAt": "2021-04-24T03:22:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@lindsayad  Good news for me: I don't need to run any bisects :)\nBad news for you: with AD local indexing nonsparse the run time is 287.7488, with AD global indexing sparse the run time is 440.2642 (Yes, the number is different from the one in my original post because I re-ran it to make sure.)",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652614",
                          "updatedAt": "2022-06-15T15:08:27Z",
                          "publishedAt": "2021-04-24T03:45:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@abarun22 Could you try to run ./configure --with-derivative-type=nonsparse --with-ad-indexing-type=local in your moose root directory, then recompile and see if it speeds up your calculations?",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652617",
                          "updatedAt": "2022-06-15T15:08:33Z",
                          "publishedAt": "2021-04-24T03:51:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Ok I\u2019m glad we figured out the issue straightaway. I will have to profile this to figure out the differences and whether there are any potential remedies. In the meantime the user should definitely work with local nonsparse. Gary could you create a ticket and tag me please?",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652658",
                          "updatedAt": "2022-07-12T04:12:16Z",
                          "publishedAt": "2021-04-24T04:25:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Thanks! No problem, I just tagged you.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-653392",
                          "updatedAt": "2022-07-12T04:12:16Z",
                          "publishedAt": "2021-04-24T12:39:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Dear Gary,\nThe configure options for non-sparse indexing does not seem to impact the computational time. I ran your version of the input file which took 462s and 466s before and after configuring the options. It is still taking the same one hour for my version of input file.\nFYI, i did the configuration as suggested by you, which it did successfully - then moved to test directory (moose/test), recompiled the sources with new options and recompiled my application eventully.\nKind regards,\nArun",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-660963",
                          "updatedAt": "2022-07-12T04:12:16Z",
                          "publishedAt": "2021-04-26T17:10:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You made me unconfident... I triple checked just now, and global sparse gave me 434 seconds and local nonsparse gave me 290 seconds. It is really making a difference on my machine. Either one of us did something wrong, or something is machine-dependent. We probably need a third person to confirm.\nJust to make sure, you first ran the ./configure --with-derivative-type=nonsparse --with-ad-indexing-type=local command, then recompiled your application, and finally ran my input file, right? Is it possible you have multiple moose on your machine and your application didn't pick up the right one?",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-661940",
                          "updatedAt": "2022-07-12T04:12:18Z",
                          "publishedAt": "2021-04-26T21:52:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Dear Gary,\nYes exactly the same. Here is the configure log for your reference\n(base) abalasub@freia013> ./configure --with-derivative-type=nonsparse --with-ad-indexing-type=local\n----------- Configuring MOOSE ---------------\nconfiguring with derivative backing array size of 50\nconfiguring with AD indexing type local\nconfiguring with derivative type nonsparse\nchecking for pkg-config... /usr/bin/pkg-config\nconfigure: checking system for libpng\nconfiguring with libpng support\nconfigure: creating ./config.status\nconfig.status: creating conf_vars.mk\nconfig.status: creating framework/include/base/MooseConfig.h.tmp\nconfig.status: executing framework/include/base/MooseConfig.h commands\nconfig.status: creating framework/include/base/MooseConfig.h - prefix MOOSE for framework/include/base/MooseConfig.h.tmp defines\n--------- Done Configuring MOOSE ------------\nAfter that i re-compiled my application and ran your inputfile. I am sure the application is linking with the correct version of moose uniquely. No problems here i guess. I will try and run this nonsparse configured moose in other clusters and see if it speeds up the computation.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-663955",
                          "updatedAt": "2022-07-12T04:12:19Z",
                          "publishedAt": "2021-04-27T11:33:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Distortion of mesh on adding plasticity with hardening",
          "author": {
            "login": "Bala-1005"
          },
          "bodyText": "Hello everyone,\nI am working on coupling phase field and plasticity modeling. I am using Isotropic plasticity with power hardening rule. But for some reason, the mesh gets distorted as shown in the figure. I have tried different boundary conditions but all the simulation runs show distortion and then stops converging. What could be the reason for this? The simulation runs perfectly when no plasticity is involved.\nI use a SMALL strain definition with incremental strain for tensor mechanics.\n\nThanks,\nBala",
          "url": "https://github.com/idaholab/moose/discussions/17590",
          "updatedAt": "2022-06-16T18:59:14Z",
          "publishedAt": "2021-04-13T01:02:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "That is a cool looking result, @Bala-1005 .   Could it be the usual mesh-dependence of strain-softening/hardening ?  Eg, with a coarse mesh, no quadpoints yield, but with a fine mesh a quadpoint yields, which then causes another quadpoint to yield, etc, leading to a substantially different result.",
                  "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602755",
                  "updatedAt": "2022-06-16T18:59:21Z",
                  "publishedAt": "2021-04-13T01:14:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "Thank you @WilkAndy . I am not familiar with the concept of mesh-dependence of strain hardening. I might have to read up on it. In the mean time, would removing adaptivity of the mesh help in reducing the distortion?",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602839",
                          "updatedAt": "2022-06-16T18:59:25Z",
                          "publishedAt": "2021-04-13T01:54:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Give it a try!",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602845",
                          "updatedAt": "2022-06-16T18:59:22Z",
                          "publishedAt": "2021-04-13T01:56:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "That does not seem to work as the solve stops converging really fast.",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602869",
                          "updatedAt": "2022-06-16T18:59:22Z",
                          "publishedAt": "2021-04-13T02:09:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Oh well - it was just an idea - i don't know about phase-field, so will leave this problem to an expert.",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602882",
                          "updatedAt": "2022-09-14T12:42:59Z",
                          "publishedAt": "2021-04-13T02:18:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Can you let us know why you don't want the distortion (or why you think it's nonphysical)? Also can you post contour plots of displacements and effective inelastic strain?",
                  "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602962",
                  "updatedAt": "2022-06-16T18:59:24Z",
                  "publishedAt": "2021-04-13T03:04:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "The problem is a solidification problem. The red part is solid and the blue part is the liquid. Therefore a distorted mesh does not seem to make a lot of sense in the liquid part. If that were the case, then I believe my elastic simulations also would have shown such a distortion which was not the case. I hope I make sense.\nHere are the displacements, and effective strain plots.",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-603244",
                          "updatedAt": "2022-06-16T18:59:24Z",
                          "publishedAt": "2021-04-13T06:04:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I think it'd be useful to defined \"distorted\".  Eg, do you mean:\n\nasymmetric (there isn't exact 8-fold symmetry in your results), or\nshould-be-circular-but-isn't, or\nshould-be-square-but-isn't, or\nshould not have the inwards-pointing fingers, or\nsomething else?",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-603369",
                          "updatedAt": "2022-06-16T18:59:33Z",
                          "publishedAt": "2021-04-13T06:55:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "I mean I expected the mesh to stay square-shaped but close to the interface, the mesh does not seem to be that way. In contrast, the results with only elasticity as shown below, shows very little to no change in shape.",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-604860",
                          "updatedAt": "2022-06-16T18:59:30Z",
                          "publishedAt": "2021-04-13T13:33:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thanks @Bala-1005 .  Before quitting this discussion (due to my ignorance), i want to ask: are you sure the result isn't correct?  More specifically: are you sure your physics with hardening has a unique solution?\nAn example of a system with a non-unique solution is the stretching of a 1D material that is governed by a strain-softening law.  As you stretch the material, you'll get closer to the yield strength.  When you hit the yield strength, the whole material won't suddenly fail: just some \"random\" part of it will fail.  In real life, the \"random\" part is the part that, for whatever reason, was slightly weaker than the rest.  In a numerical model, the \"random\" part will be a quadpoint that was under slightly more stress, due to roundoff error (or other precision-related artifacts).  Then, because of the strain softening, that \"random\" part will keep deforming plastically while you continue to stretch the material, while the remainder of the 1D bar will behave elastically.\nTo me, your situation looks analogous to this.  There are a few \"random\" quadpoints that behave a little differently from the others, causing the \"distortion\".  You'll be able to determine whether your situation falls has this type of non-unique solution by doing a similar thought experiment to the previous paragraph.  Then, follow through the consequences of the \"random\" quadpoints failing: does that mean their neighbours then preferentially fail?  If so, then your \"distortion\" is mostly likely caused by non-uniqueness, in my opinion.\nJust throwing this to you for consideration, not because i know anything about your physics or numerics!!",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-606818",
                          "updatedAt": "2022-09-14T12:43:38Z",
                          "publishedAt": "2021-04-13T21:18:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "Thank you for the analysis @WilkAndy .  It has helped me understand my problem better. I have been thinking in the same lines for my problem. The only point where I am not able to physically explain is the fact that the red phase is the solid part and the blue phase is the liquid part. Mesh \"distortion\" occurs only in the liquid phase. This can be seen better with some user defined anisotropy in the problem as shown below in the figure. Here there is a mesh \"distortion\" in the liquid phase between two solid phases. There are no stresses in the liquid phase as their young's modulus is several orders lower than the solids. Say, for example one of the quad points in the solid phase yields, it does not make physical sense for me to say that a neighboring quad point in the liquid has yielded as well. In other words, my question would be, Is it proper to use plasticity modeling for the entire domain or does it make more sense to use plasticity modeling only for the solid part?\n\nThank you so much for the explanation.\nBala",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-648121",
                          "updatedAt": "2022-09-14T12:43:45Z",
                          "publishedAt": "2021-04-23T06:23:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "So, just checking - the \"distortion\" you're referring to is in the blue elements between the tips of the red regions.  If so, then i would look at numerical problems such as shear (or volumetric) locking, since those strangely shaped elements should be more square according to my eyes.\nSecondly, when you have a large contrast in young's modulus, you'll get a large contrast in residuals.  So the contribution to the overall residual from the \"blue\" region could be much smaller than from the \"red\" region, meaning the blue region might not have converged as well as the red region.  Put another way: it doesn't \"cost\" much (energy or force) to move a blue node compared with a \"red\" node.\nI don't know anything about your model, but generally liquids are not governed by solid-mechanics plasticity (J2).  Plasticity means that, for example, pulling a material past its yield point and then releasing it again results in a permanently extended material - it does not return to its original shape.  I'm not aware of any fluids that act like that, or when you say \"plastic fluid\" are you meaning a non-Newtonian fluid?  I've obviously exceeded the limit of my knowledge in this question!",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-649098",
                          "updatedAt": "2022-09-14T12:43:59Z",
                          "publishedAt": "2021-04-23T11:03:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Bala-1005\nWhat is the difference between the mechanical properties of the solid and liquid?\nI get this kind of problems when one region has a stiffness which is much smaller than the other.\nCould you share the input file?\nBest Regards,\nNicol\u00f2 Grilli",
                  "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-603529",
                  "updatedAt": "2022-09-14T12:44:20Z",
                  "publishedAt": "2021-04-13T07:48:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "Hi @ngrilli ,\nThe young's moduli of the solid and liquid phases have a difference in the order of around ~10e9. Did you get these kinds of problems with plasticity or with elasticity?\nHere is the input file.\nThanks,\nBala\nkks_anisotropic_plastic.txt",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-604919",
                          "updatedAt": "2022-09-14T12:44:25Z",
                          "publishedAt": "2021-04-13T13:45:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Let me tell you a tangential issue here. When you use a plastic model (with stateful properties), you'd better not use adaptivity. It does not guarantee the stress state is always admissible before and after refinement/coarsening, i.e. remain at yield surface.\nI agree with @ngrilli , the issue seems to be related to the large material contrast.",
                  "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-652601",
                  "updatedAt": "2022-09-14T12:44:22Z",
                  "publishedAt": "2021-04-24T03:27:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}