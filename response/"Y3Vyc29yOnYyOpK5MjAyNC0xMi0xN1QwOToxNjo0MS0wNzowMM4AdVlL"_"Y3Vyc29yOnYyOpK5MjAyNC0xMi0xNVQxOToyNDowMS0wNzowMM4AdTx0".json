{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMi0xNVQxOToyNDowMS0wNzowMM4AdTx0"
    },
    "edges": [
      {
        "node": {
          "title": "How to set up a non-uniform boundary condition?",
          "author": {
            "login": "waaizhaq"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI have a rectangular mesh where I set the bottom boundary to a NeumannBC of value 0, representing the ground, the right and top walls to a DirichletBC of value 296.15 Kelvin, representing the ambient air, and currently I have the left wall set to a DirichletBC of value 505.15 Kelvin. However, I want to change that to where only the lower half of the wall is set to the 505.15 Kelvin, and the upper half is another insulated boundary, or NeumannBC of value 0.",
          "url": "https://github.com/idaholab/moose/discussions/29552",
          "updatedAt": "2024-12-17T13:09:28Z",
          "publishedAt": "2024-12-16T04:35:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "snowbugxs"
                  },
                  "bodyText": "I think you may need a section on the domain, then you get two left walls, lower one and upper one. Set different BCs to them.",
                  "url": "https://github.com/idaholab/moose/discussions/29552#discussioncomment-11582039",
                  "updatedAt": "2024-12-16T14:40:27Z",
                  "publishedAt": "2024-12-16T14:40:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "Do you know an example that I can look at? I was trying to find something on the MOOSE framework but couldn't find what I was looking for.",
                          "url": "https://github.com/idaholab/moose/discussions/29552#discussioncomment-11583178",
                          "updatedAt": "2024-12-16T16:24:08Z",
                          "publishedAt": "2024-12-16T16:24:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nUse this generator to split the sideset in two. Then use one boundary condition on one part and another on the other part\nhttps://mooseframework.inl.gov/source/meshgenerators/ParsedGenerateSideset.html",
                          "url": "https://github.com/idaholab/moose/discussions/29552#discussioncomment-11583522",
                          "updatedAt": "2024-12-16T16:53:29Z",
                          "publishedAt": "2024-12-16T16:53:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "snowbugxs"
                          },
                          "bodyText": "Can we do it outside moose, e.g, using Gmsh to split the domains?",
                          "url": "https://github.com/idaholab/moose/discussions/29552#discussioncomment-11592928",
                          "updatedAt": "2024-12-17T12:49:07Z",
                          "publishedAt": "2024-12-17T12:49:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes. You can take any mesh generation step in meshing software outside of moose",
                          "url": "https://github.com/idaholab/moose/discussions/29552#discussioncomment-11593198",
                          "updatedAt": "2024-12-17T13:09:28Z",
                          "publishedAt": "2024-12-17T13:09:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "I cant find the implementation of SplitCHWRes in the source code",
          "author": {
            "login": "snowbugxs"
          },
          "bodyText": "For the split C-H equation, SplitCHWRes is designed to calculate the term of (M\u2207u,\u2207\u03c8).\nI find the implementation of this class is missing in the souce file, located at   /moose/modules/phase_field/src/kernels/SplitCHWRes.C.\nAlso, it's unusual the implementation of the base class SplitCHWResBase is not in the .C file but in the .h file.",
          "url": "https://github.com/idaholab/moose/discussions/29546",
          "updatedAt": "2024-12-17T00:58:17Z",
          "publishedAt": "2024-12-15T11:02:55Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe implementation of the template is in the header because that's what is commonly done in C++ when you want to define a template that others may instantiate with types you did not foresee could be used in the template.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/29546#discussioncomment-11572398",
                  "updatedAt": "2024-12-15T14:53:39Z",
                  "publishedAt": "2024-12-15T14:53:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "snowbugxs"
                          },
                          "bodyText": "Thanks. Sorry for I may cause a misunderstanding here.\nBoth files SplitCHWRes.C and SplitCHWRes.h don't include the implementation of how to calculate residuals.\nPlease check the two files.",
                          "url": "https://github.com/idaholab/moose/discussions/29546#discussioncomment-11581955",
                          "updatedAt": "2024-12-16T14:33:32Z",
                          "publishedAt": "2024-12-16T14:33:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it is implemented in SplitCHWResBase.h",
                          "url": "https://github.com/idaholab/moose/discussions/29546#discussioncomment-11585020",
                          "updatedAt": "2024-12-16T19:06:54Z",
                          "publishedAt": "2024-12-16T19:06:54Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "snowbugxs"
                          },
                          "bodyText": "Get it. Derived class inherits the methods defined in Base class.",
                          "url": "https://github.com/idaholab/moose/discussions/29546#discussioncomment-11587347",
                          "updatedAt": "2024-12-17T00:58:04Z",
                          "publishedAt": "2024-12-17T00:58:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "symbol lookup error after Update",
          "author": {
            "login": "Flolaffel"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI just updated MOOSE and when I try to run my simulations I now get:\n./simp-opt: symbol lookup error: /home/.local/ruef/miniforge/envs/moose/lib/libmpifort.so.12: undefined symbol: PMPIX_Start_progress_thread\nas the only output. I tried reinstalling moose which didn't work. What to do?",
          "url": "https://github.com/idaholab/moose/discussions/29554",
          "updatedAt": "2024-12-16T19:28:47Z",
          "publishedAt": "2024-12-16T09:16:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Flolaffel"
                  },
                  "bodyText": "It just started working. Unfortunately I don't know what the issue was.",
                  "url": "https://github.com/idaholab/moose/discussions/29554#discussioncomment-11579543",
                  "updatedAt": "2024-12-16T10:36:07Z",
                  "publishedAt": "2024-12-16T10:36:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "probably a left-over compiled object, that eventually got cleaned with a make clobberall or a git clean",
                          "url": "https://github.com/idaholab/moose/discussions/29554#discussioncomment-11585186",
                          "updatedAt": "2024-12-16T19:28:47Z",
                          "publishedAt": "2024-12-16T19:28:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Sintering neck calculation",
          "author": {
            "login": "HPL001"
          },
          "bodyText": "Dear moose community,\nhello. I am doing the sintering calculation between two particles, I want to output the change curve of the sintering neck in the post-processing, how should I operate?",
          "url": "https://github.com/idaholab/moose/discussions/29542",
          "updatedAt": "2024-12-16T19:28:10Z",
          "publishedAt": "2024-12-14T13:51:28Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Closing as a duplicate",
                  "url": "https://github.com/idaholab/moose/discussions/29542#discussioncomment-11585180",
                  "updatedAt": "2024-12-16T19:28:11Z",
                  "publishedAt": "2024-12-16T19:28:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Simplification or mistake",
          "author": {
            "login": "YXY101676"
          },
          "bodyText": "Hello,\nThe following code defines a function that generates a vector containing the values of order parameters. According to the original formula, this function should sum the squares all order parameters except for the one corresponding to the current kernel. However, based on my understanding, the function is summing the squares of all order parameters:\nstd::vector<Real>\nACGrGrPoly::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\n other_ops = assignOtherOps();\n\n  // Sum all other order parameters\n  Real SumOPj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n    SumOPj += other_ops[i] * other_ops[i];\n\nI want to know if this usage is a simplification or an error.\nyxy",
          "url": "https://github.com/idaholab/moose/discussions/29551",
          "updatedAt": "2024-12-16T19:24:26Z",
          "publishedAt": "2024-12-16T03:15:25Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe one for the kernel is not parts of _vals. So it does not get stored in other_ops\nsee the base class\nACGrGrBase::validParams()\n{\n  InputParameters params = ACBulk<Real>::validParams();\n  params.addRequiredCoupledVar(\"v\",\n                               \"Array of coupled order parameter names for other order parameters\");\n\n\nACGrGrBase::ACGrGrBase(const InputParameters & parameters)\n  : ACBulk<Real>(parameters),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n\nThen in the SumOPj (really sumOPj_squared), it also does not feature",
                  "url": "https://github.com/idaholab/moose/discussions/29551#discussioncomment-11585144",
                  "updatedAt": "2024-12-16T19:24:27Z",
                  "publishedAt": "2024-12-16T19:24:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Sintering neck calculation",
          "author": {
            "login": "HPL001"
          },
          "bodyText": "Dear moose community,\nhello. I am doing the sintering calculation between two particles, I want to output the change curve of the sintering neck in the post-processing, how should I operate?do I need to use NodalVariableValue or something?",
          "url": "https://github.com/idaholab/moose/discussions/29555",
          "updatedAt": "2024-12-16T19:08:10Z",
          "publishedAt": "2024-12-16T10:12:15Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nIn the postprocessing? So you want to modify the mesh then or just compute a new value for an existing quantity?\nNodalVariableValue lets you output a value. If you want to use this value into a new postprocessor, you can use the ParsedPostprocessor",
                  "url": "https://github.com/idaholab/moose/discussions/29555#discussioncomment-11585032",
                  "updatedAt": "2024-12-16T19:08:10Z",
                  "publishedAt": "2024-12-16T19:08:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Different physics solved in different \"growing/merging\" domains",
          "author": {
            "login": "keassyguang"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi everyone,\nI am dealing with a photopolymerization based printing process simulation to predict the distortions of the printed part. As shown below, a capital letter \"H\" is selected as the print part, three physics are considered, namely the chemical, thermal, and structural. Is it possible to solve different physics in different domains? For example, chemical is solved in regions 2 and 3; thermal is solved in regions 1, 2, and 3; structural is solved in regions 2 and 3. There could be potential couplings between different physics. The main concerns are as follow:\n\nThe moving/merging domains\nThe moving/growing node sets\n\nFor the first, the number of domains could change over time. Domains could be merged into one or more. Is it possible to use MOOSE's built-in mesh generator to achieve this, or to use a third party software to pre-define all the blocks? For these three physics, the blocks that variables to be solved is changing during the simulation due to the geometry. In addition, the variables may only be solved within the last 50 or 100 layers, while the variables for the previous layers are treated as constant.\nFor the second one, I need use a lot of node sets to define the boundary conditions or initializations for the chemical and structural physics, and these node sets could change over time.\nAny possible solutions, problems, challenges related to the implementation are welcome. Many thanks.",
          "url": "https://github.com/idaholab/moose/discussions/29066",
          "updatedAt": "2024-12-16T13:30:30Z",
          "publishedAt": "2024-11-13T16:40:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\ns it possible to solve different physics in different domains\n\nCertainly. You just use block restriction on each variable.\n\nFor the first, the number of domains could change over time. Domains could be merged into one or more. Is it possible to use MOOSE's built-in mesh generator to achieve this, or to use a third party software to pre-define all the blocks?\n\nThe easiest way so far to do this has been to have  every element you need, already in the mesh, just assigned to an inactive block. Then when the equations are supposed to be solved on these elements, you change their subdomain to one of the active blocks.\nNote that you can pre-declare blocks that do not exist on the mesh currnetly but will later in the simulation in the Mesh block",
                  "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11245616",
                  "updatedAt": "2024-11-13T19:55:51Z",
                  "publishedAt": "2024-11-13T19:55:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "The easiest way so far to do this has been to have every element you need, already in the mesh, just assigned to an inactive block. Then when the equations are supposed to be solved on these elements, you change their subdomain to one of the active blocks.\n\nThank you very much. I can understand this concept and I hope it can work, but I am really confused about how to implement it.\nDo we have any relevant examples? Currently I only know how to use GeneratedMeshGenerator to create blocks and activate elements using the CoupledVarThresholdElementSubdomainModifier method. It would be great if you could kindly show me more details.",
                          "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11252458",
                          "updatedAt": "2024-11-14T10:16:24Z",
                          "publishedAt": "2024-11-14T10:16:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can find examples of modifying the subdomains of elements in\ntest/tests/meshmodifiers/element_subdomain_modifier",
                          "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11255652",
                          "updatedAt": "2024-11-14T15:02:02Z",
                          "publishedAt": "2024-11-14T15:02:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Thanks a lot so far. I have gone through all the examples in the element_subdomain_modifier folder and read the documentation for the meshmodifiers section. Based on my understanding, it seems that the TimedSubdomainModifier is suitable for the desired functionality.\nAssuming we pre-declare three blocks for these three physics, in order to \"move\" specified elements (blocks) to the desired blocks for given points in time, it seems that I need to create a block for each element. When facing with a large scale model, it could be thousands and millions of elements, which means there should be thousands and millions of blocks defined by the Mesh section in the input file? (if we set each element as an individual block)\nAnother concern is the moving boundary. I need the top surface of the latest layer to define the boundary condition for the thermal physics, while how to create such a moving boundary? This boundary line (2D case) or face (3D case) could be made up of thousands and hundreds element pairs.",
                          "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11272262",
                          "updatedAt": "2024-11-15T18:44:46Z",
                          "publishedAt": "2024-11-15T18:44:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are elements moving from one domain to the other one by one?\nCan you not group them in subdomains for them to change together?\nIf not, then you need to code a new MeshModifier that has these capabilities.",
                          "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11272367",
                          "updatedAt": "2024-11-15T18:57:52Z",
                          "publishedAt": "2024-11-15T18:57:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Are elements moving from one domain to the other one by one?\nCan you not group them in subdomains for them to change together?\n\nNo, I don't need to move elements from one domain to the other one by one. I wish elements could be activated one layer at a time for specific times. I think there are two strategies:\n\nUsing the [TimedSubdomainModifier]: For each layer, group elements into three subdomains according to their color and define the times, blocks from and blocks move to in an input .csv file\nUsing the [CoupledVarThresholdElementSubdomainModifier]: Group all elements into three subdomains according to their color and activate them together with coupled variable\n\nFor both these methods I need to group elements into subdomains in advance, do we have any object to achieve this?",
                          "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11275898",
                          "updatedAt": "2024-11-16T05:46:47Z",
                          "publishedAt": "2024-11-16T05:46:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThe grouping of elements into subdomains is done at the mesh generation stage.\nYou can use the ParsedGenerateSubdomain for this purpose, that's one of the most flexible ways to assign subdomains.\nhttps://mooseframework.inl.gov/source/meshgenerators/ParsedSubdomainMeshGenerator.html\nUnless you are trying to convert all elements from one subdomain to another in a single operation, I dont think the TimedSubdomainModifier is for you.\nIf you want to use that one, you will need to pre-define a different subdomain for each layer.",
                          "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11277283",
                          "updatedAt": "2024-11-16T12:45:10Z",
                          "publishedAt": "2024-11-16T12:35:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Thank you very much. I tried to use the SubdomainPerElementGenerator for a simple 2D case (just as the picture above [Layer 5]). I created 6 blocks (two in a pair), three moving boundaries and three mesh modifiers with CoupledVarThresholdElementSubdomainModifier and it works fine. However, SubdomainPerElementGenerator may not be suitable for a large model and I don't know how to deal with the 3D case with SubdomainPerElementGenerator.\n\nUnless you are trying to convert all elements from one subdomain to another in a single operation, I dont think the TimedSubdomainModifier is for you.\nIf you want to use that one, you will need to pre-define a different subdomain for each layer.\n\nI agree with you. In fact, I need to pre-define blocks regardless of which mesh modifier method I choose. The problem now is that the geometry of the part could be quite complicated, which means I need to use a lot of expressions to describe the three regions (outside region, boundary region, and inside region) of the part. I want to find a simple way to pre-define these blocks.",
                          "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11277485",
                          "updatedAt": "2024-11-16T13:17:21Z",
                          "publishedAt": "2024-11-16T13:17:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "https://mooseframework.inl.gov/moose/source/meshgenerators/SubdomainPerElementGenerator.html is indeed not the right way for a large model. This is mostly for small cases\nDo you need to predefine layers to make sure the elements from layer n+1 change subdomains before elements from layer n?\nBecause if you don't, and if you already have subdomains defined for the actual regions of the mesh, you can use the coupledVarThresholdLM subdomain modifier and then rely on the variable value and change the subdomain on the per element basis, instead of relying on predefined layers",
                          "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11278023",
                          "updatedAt": "2024-11-16T14:55:30Z",
                          "publishedAt": "2024-11-16T14:55:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Do you need to predefine layers to make sure the elements from layer n+1 change subdomains before elements from layer n?\n\nI didn't quite get that but I don't think I need it.\nAs shown in the below figure, I would create 6 blocks.\nblock 1: all gray regions below the red line\nblock 2: all green regions below the red line\nblock 3: all yellow regions below the red line\nblock 4: all gray regions above the red line\nblock 5: all green regions above the red line\nblock 6: all yellow regions above the red line\nmoving boundary 1: SideSetsBetweenSubdomainsGenerator, primary: block 1, paired:block 4\nmoving boundary 2: SideSetsBetweenSubdomainsGenerator, primary: block 2, paired:block 5\nmoving boundary 3: SideSetsBetweenSubdomainsGenerator, primary: block 3, paired:block 6\nThen the CoupledVarThresholdElementSubdomainModifier is applied to these three pairs of blocks to change the elements' domain.\n\n\nand if you already have subdomains defined for the actual regions of the mesh\n\nFor the mesh preparation stage, to assign elements to blocks 1-6, for this simple geometry case, I can use the ParsedSubdomainMeshGenerator with several expressions to do it. I would say this could be a big challenge to do if the geometry is complicated and the model is large. Are there any simple methods to assign elements to the correct blocks? Like how to assign the gray regions above the red line to block 4 in a complicated geometry (especially in the 3D case) with a smart way?",
                          "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11278690",
                          "updatedAt": "2024-11-16T16:47:26Z",
                          "publishedAt": "2024-11-16T16:42:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Having equations for the regions is already an efficient way. If you have plenty of equations for each region, then you can make a new mesh generator which can take all your specifications.\nAssigning subdomains in moose is not the common way to do this though. Ideally when you are meshing the system in your meshing tool, you are assigning the subdomains which often map to different parts / materials of the system",
                          "url": "https://github.com/idaholab/moose/discussions/29066#discussioncomment-11279566",
                          "updatedAt": "2024-11-16T19:36:31Z",
                          "publishedAt": "2024-11-16T19:36:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "how to translate FV var to FE var?",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello, There is a error about Material, when I try to compute a material which form is $k=P*T$, where k is material property, P is compute form FVM, T is compute form FEM.\nYour material mamox couples in both FE and FV vars. To support ghost calculations which some FV consumers may need, multiphysics simulations should define separate materials for coupling in finite element and finite volume variables because we do not have a user friendly way of running DerivedMaterial::computeQpProperties and saying 'compute this property because it doesn't depend on finite element variables' or 'don't compute this property because it *does* depend on finite element variables'\nAre there auxiliary variables AuxVariable that convert FV variables into FE variables? I can't find it from the name.\nThanks for you help in advance.\nZhaohao Wang",
          "url": "https://github.com/idaholab/moose/discussions/29525",
          "updatedAt": "2024-12-16T08:48:18Z",
          "publishedAt": "2024-12-12T08:17:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou can use a ProjectionAux to convert kne to the other.\nAlternatively you can use the functor APIs to couple FE or FV variables in any object. See the Functor documentation",
                  "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11543618",
                  "updatedAt": "2024-12-12T12:01:59Z",
                  "publishedAt": "2024-12-12T12:01:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Thanks, this is pretty effective. Just as you say, I use ProjectionAux to convert both.\n  [porosity_back]\n  []\n  [temp_fv]\n    type = MooseVariableFVReal\n  []\n [porosity_back]\n    type = ProjectionAux\n    v = porosity\n    variable = porosity_back\n  []\n  [temp_back]\n    type = ProjectionAux\n    v = temp\n    variable = temp_fv\n  []\n   [porosityadvection]\n    type = FVPoreAdvection\n    variable = porosity\n    temperature = temp_fv\n    plutonium_concentration = 0\n  []\n  [mamox]\n    type = MAMOXThermal\n    temperature = temp\n    porosity = porosity_back\n  []\nBut there is new error. and I have used gdb to find error place.\nAssertion `!face_mat->hasStatefulProperties()' failed\nFinite volume materials do not currently support stateful properties.\nat /home/wang/projects/moose/framework/src/problems/FEProblemBase.C, line 8774\n#0  0x00007fffe134a4f0 in PMPI_Abort () from /home/wang/miniforge/envs/moose/lib/libmpi.so.12\n#1  0x00007ffff4b49b12 in moose::internal::mooseErrorRaw (msg=..., prefix=...)\n    at /home/wang/projects/moose/framework/src/base/MooseError.C:88\n#2  0x00007ffff4ca958b in mooseError<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&> () at /home/wang/projects/moose/framework/build/header_symlinks/MooseError.h:303\n#3  0x00007ffff537e4e6 in ThreadedFaceLoop<libMesh::StoredRange<MooseMesh::const_face_info_iterator, FaceInfo const*> >::~ThreadedFaceLoop (this=0x7fffffff7e60, __in_chrg=<optimized out>)\n    at /home/wang/projects/moose/framework/build/header_symlinks/ComputeFVFluxThread.h:219\n#4  0x00007ffff5349d61 in ComputeFVFluxThread<libMesh::StoredRange<MooseMesh::const_face_info_iterator, FaceInfo const*>, AttribVectorTags>::~ComputeFVFluxThread (this=0x7fffffff7e60, __in_chrg=<optimized out>)\n    at /home/wang/projects/moose/framework/build/header_symlinks/ComputeFVFluxThread.h:465\n#5  0x00007ffff537f441 in ComputeFVFluxResidualThread<libMesh::StoredRange<MooseMesh::const_face_info_iterator, FaceInfo const*> >::~ComputeFVFluxResidualThread (this=0x7fffffff7e60, __in_chrg=<optimized out>)\n    at /home/wang/projects/moose/framework/build/header_symlinks/ComputeFVFluxThread.h:890\n#6  0x00007ffff52cdc9a in NonlinearSystemBase::computeResidualInternal (this=0x555555cf7bd0, tags=...)\n    at /home/wang/projects/moose/framework/src/systems/NonlinearSystemBase.C:1748\n#7  0x00007ffff52c4eb0 in NonlinearSystemBase::computeResidualTags (this=0x555555cf7bd0, tags=...)\n    at /home/wang/projects/moose/framework/src/systems/NonlinearSystemBase.C:826\n#8  0x00007ffff682bd1a in FEProblemBase::computeResidualTags (this=0x555555cd4bc0, tags=...)\n    at /home/wang/projects/moose/framework/src/problems/FEProblemBase.C:7058\n#9  0x00007ffff6828f8f in FEProblemBase::computeResidualInternal (this=0x555555cd4bc0, soln=..., residual=..., \n    tags=...) at /home/wang/projects/moose/framework/src/problems/FEProblemBase.C:6898\n#10 0x00007ffff6827102 in FEProblemBase::computeResidual (this=0x555555cd4bc0, soln=..., residual=..., \n    nl_sys_num=0) at /home/wang/projects/moose/framework/src/problems/FEProblemBase.C:6720\n#11 0x00007ffff6826983 in FEProblemBase::computeResidualSys (this=0x555555cd4bc0, sys=..., soln=..., residual=...)\n    at /home/wang/projects/moose/framework/src/problems/FEProblemBase.C:6690\n#12 0x00007ffff52ae3f5 in ComputeResidualFunctor::residual (this=0x555555cf94c8, soln=..., residual=..., sys=...)\n    at /home/wang/projects/moose/framework/src/systems/ComputeResidualFunctor.C:27\n#13 0x00007fffef89d35d in libmesh_petsc_snes_residual ()\n   from /home/wang/miniforge/envs/moose/libmesh/lib/libmesh_dbg.so.0\n#14 0x00007fffe8094668 in SNESComputeFunction () from /home/wang/miniforge/envs/moose/petsc/lib/libpetsc.so.3.022\n#15 0x00007fffe806e931 in SNESSolve_NEWTONLS () from /home/wang/miniforge/envs/moose/petsc/lib/libpetsc.so.3.022\n#16 0x00007fffe809c505 in SNESSolve () from /home/wang/miniforge/envs/moose/petsc/lib/libpetsc.so.3.022\n#17 0x00007fffef8a4dc4 in libMesh::PetscNonlinearSolver<double>::solve(libMesh::SparseMatrix<double>&, libMesh::NumericVector<double>&, libMesh::NumericVector<double>&, double, unsigned int) ()\n   from /home/wang/miniforge/envs/moose/libmesh/lib/libmesh_dbg.so.0\n#18 0x00007fffef9426ce in libMesh::NonlinearImplicitSystem::solve() ()\n   from /home/wang/miniforge/envs/moose/libmesh/lib/libmesh_dbg.so.0\n#19 0x00007ffff52bacce in NonlinearSystem::solve (this=0x555555cf7bd0)\n    at /home/wang/projects/moose/framework/src/systems/NonlinearSystem.C:197\n#20 0x00007ffff681c85d in FEProblemBase::solve (this=0x555555cd4bc0, nl_sys_num=0)\n    at /home/wang/projects/moose/framework/src/problems/FEProblemBase.C:6247\n#21 0x00007ffff44fe0eb in FEProblemSolve::solve (this=0x555555d596f8)\n    at /home/wang/projects/moose/framework/src/executioners/FEProblemSolve.C:406\n#22 0x00007ffff4503a44 in FixedPointSolve::solveStep (this=0x555555d59d00, begin_norm=@0x555556398150: 0, \n    end_norm=@0x5555563c7630: 0, transformed_dofs=...)\n    at /home/wang/projects/moose/framework/src/executioners/FixedPointSolve.C:439\n#23 0x00007ffff45028d0 in FixedPointSolve::solve (this=0x555555d59d00)\n    at /home/wang/projects/moose/framework/src/executioners/FixedPointSolve.C:291\n#24 0x00007ffff6587b12 in TimeStepper::step (this=0x555555789dd0)\n    at /home/wang/projects/moose/framework/src/timesteppers/TimeStepper.C:168\n#25 0x00007ffff4513d62 in Transient::takeStep (this=0x555555d59340, input_dt=-1)\n    at /home/wang/projects/moose/framework/src/executioners/Transient.C:418\n#26 0x00007ffff45127e2 in Transient::execute (this=0x555555d59340)\n    at /home/wang/projects/moose/framework/src/executioners/Transient.C:293\n#27 0x00007ffff4b3406a in MooseApp::executeExecutioner (this=0x55555582d540)\n    at /home/wang/projects/moose/framework/src/base/MooseApp.C:1180\n#28 0x00007ffff4b3b552 in MooseApp::run (this=0x55555582d540)\n    at /home/wang/projects/moose/framework/src/base/MooseApp.C:1562\n#29 0x0000555555557e94 in Moose::main<MiracleTestApp> (argc=3, argv=0x7fffffffb5f8)\n    at /home/wang/projects/moose/framework/build/header_symlinks/MooseMain.h:47\n#30 0x00005555555576fd in main (argc=3, argv=0x7fffffffb5f8) at /home/wang/projects/miracle/src/main.C:17\nLooks like in \\moose\\framework? please give me some advices, thanks!\nZhaohao Wang",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11551053",
                          "updatedAt": "2024-12-13T01:27:21Z",
                          "publishedAt": "2024-12-13T01:27:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Stateful material properties are properties which depend on their value in a previous time step.\nUnfortunately this is not supported in finite volume right now, as the error message is telling you.\nI don't think it's even on the roadmap at this point. With finite volume we have fully transitioned to using functor material properties. These can handle statefulness. You would need to develop the materials again as functor materials to use this",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11551145",
                          "updatedAt": "2024-12-13T01:46:06Z",
                          "publishedAt": "2024-12-13T01:46:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Ok, thanks. I will try to use functor, Thanks again for your quick response.",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11551201",
                          "updatedAt": "2024-12-13T01:57:02Z",
                          "publishedAt": "2024-12-13T01:57:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "emm, I can't find which material. I have change the FV variable porosity into FE variable. and in the FVKernels only has one variable - porosity.\n[FVKernels]\n  [porositydiffusion]\n    type = FVPoreDiffusion\n    variable = porosity\n    diffusivity = 1e-12\n  []\n  [porosityadvection]\n    type = FVPoreAdvection\n    variable = porosity\n    temperature = temp_fv\n    plutonium_concentration = 0\n  []\n  [porositytimederivative]\n    type = FVTimeKernel\n    variable = porosity\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11553836",
                          "updatedAt": "2024-12-13T08:34:55Z",
                          "publishedAt": "2024-12-13T08:34:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "More information I have find which FVkernel. Mainly copied FVAdvection, and add a RealVectorValue FVPoreAdvection::velocity() const. may be the VariableValue add in wrong way.\nregisterMooseObject(\"MiracleApp\", FVPoreAdvection);\n\nInputParameters\nFVPoreAdvection::validParams()\n{\n  InputParameters params = FVFluxKernel::validParams();\n  params.addRequiredCoupledVar(\"temperature\", \"the MOX temperature in K\");\n  params.addCoupledVar(\"plutonium_concentration\", \"the plutonium concentration in range 0 - 1\");\n  params += Moose::FV::advectedInterpolationParameter();\n  return params;\n}\n\nFVPoreAdvection::FVPoreAdvection(const InputParameters & params)\n  : FVFluxKernel(params),\n    _temperature(coupledValue(\"temperature\")),\n    _temperature_grad(coupledGradient(\"temperature\")),\n    _plutonium_concentration(coupledValue(\"plutonium_concentration\"))\n{\n  const bool need_more_ghosting =\n      Moose::FV::setInterpolationMethod(*this, _advected_interp_method, \"advected_interp_method\");\n  if (need_more_ghosting && _tid == 0)\n  {\n    adjustRMGhostLayers(std::max((unsigned short)(2), _pars.get<unsigned short>(\"ghost_layers\")));\n\n    // If we need more ghosting, then we are a second-order nonlinear limiting scheme whose stencil\n    // is liable to change upon wind-direction change. Consequently we need to tell our problem that\n    // it's ok to have new nonzeros which may crop-up after PETSc has shrunk the matrix memory\n    getCheckedPointerParam<FEProblemBase *>(\"_fe_problem_base\")\n        ->setErrorOnJacobianNonzeroReallocation(false);\n  }\n}\nRealVectorValue\nFVPoreAdvection::velocity() const\n{\nRealVectorValue velocity_sens =\n      5.006e-12 *\n      (0.988 + 6.395e-6 * _temperature[_qp] + 3.543e-9 * std::pow(_temperature[_qp], 2) +\n       3e-12 * std::pow(_temperature[_qp], 3)) *\n      std::pow(_temperature[_qp], -2.5) * vaporization * vapour_pressure * _temperature_grad[_qp];\n  return velocity_sens;\n}\n\nADReal\nFVPoreAdvection::computeQpResidual()\n{\n  const bool elem_is_upwind = velocity() * _normal >= 0;\n  const auto face =\n      makeFace(*_face_info, Moose::FV::limiterType(_advected_interp_method), elem_is_upwind);\n  ADReal u_interface = _var(face, determineState());\n\n  return _normal * velocity() * u_interface * (1 - u_interface);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11554571",
                          "updatedAt": "2024-12-13T09:44:35Z",
                          "publishedAt": "2024-12-13T09:44:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is your porosity actually changing in time? And at a rythm high enough that it matters for time integration purposes?\nIf porosity is the material that is requested at an older state, and porosity does not change, then you can delete that code that requires the old state and simply always use the current porosity",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11558905",
                          "updatedAt": "2024-12-13T15:59:45Z",
                          "publishedAt": "2024-12-13T15:59:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "I think the gdb pointing us in the wrong direction.\n\nIf porosity is the material that is requested at an older state, and porosity does not change, then you can delete that code that requires the old state and simply always use the current porosityz\nI don't use old value of porosity variable. In the material only\n\n  _porosity(coupledValue(\"porosity\")),\nif not use gdb the output is\n1068089 segmentation fault (core dumped)\nWhen I turn off FVPoreAdvection, the error disappears. This leads me to believe that there might be an issue with the coupled variable temperature. I am using ProjectionAux to transfer the FE-based temperature to an FV-based temperature. I have also included the code above for reference. Could you please take a look and provide some advice?\"",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11570131",
                          "updatedAt": "2024-12-15T06:10:35Z",
                          "publishedAt": "2024-12-15T06:10:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Taking another look at your code this is not going to work:\n    _temperature(coupledValue(\"temperature\")),\n    _temperature_grad(coupledGradient(\"temperature\")),\n\nthe graident of an FV variable through the coupleable interface is always 0 (const monomial shape function).\nCan you paste the header? I think you might have forgotten to store _temperature as a reference",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11572460",
                          "updatedAt": "2024-12-15T15:01:33Z",
                          "publishedAt": "2024-12-15T15:01:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "I realized that the _temperature_grad is 0 when the shape function is const. If I need the gradient, at least the shape function order is first. Badly, in MooseVariableFVReal only support MONOMIAL and CONSTANT.\nthere is a header part\nprotected:\n  virtual ADReal computeQpResidual() override;\n  const VariableValue & _temperature;\n  const VariableGradient & _temperature_grad;\n  const VariableValue & _plutonium_concentration;\n\n  RealVectorValue velocity();\n  Moose::FV::InterpMethod _advected_interp_method;\nI don't forget to use a reference.",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11575615",
                          "updatedAt": "2024-12-16T01:54:56Z",
                          "publishedAt": "2024-12-16T01:19:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Oh, thank you. The error is caused by the temperature grad. when I use a simple RealVectorValue(1, 0, 0) replace it, the error disappear. Now the problem is how to get the gradient. Maybe I need to sort as the AuxVariable, I am trying.",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11575916",
                          "updatedAt": "2024-12-16T02:10:30Z",
                          "publishedAt": "2024-12-16T02:10:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "\"No Functor ever provided with name 'dh_dt' under 'T_time' FVKernel\" even though I listed the parameter",
          "author": {
            "login": "waaizhaq"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A Navier Stokes is the most appropriate category for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (avoid screenshots if possible, triple back quotes before/after pasted text, etc)\n\nQuestion\nHello,\nI am trying to conduct a simple natural convection problem in MOOSE, as shown below.\n\nMy mesh only consists of the natural circulation flow, so the width of the wall is neglected. I just set a left boundary condition of Ts, and made my mesh thickness 1 meter.\nI am very new to MOOSE so I am still learning how to use it. I've been following a lot of examples posted online in the framework to create my input file, so do let me know if something seems out of place.\nBut an error I've been running into is the 'dh_dt' not being provided even though I listed it under the INSFVEnergyTImeDerivative kernel. Is there something else that I'm missing?\nI also tried running this problem as a steady state by commenting out the time-dependent kernels and changing the executioner type to steady, but then I got an error about the solve not converging.\nBy the way, to run this input I copied the navier stokes module into my own separate directory and compiled it, following the instructions that were in the framework under 'Pre-Built MOOSE.'\nAdditional information\nMesh size and type: rectangular mesh, 5 by 5\nDiscretization (finite element CG/DG, finite volume, etc): finite volume\nModels (turbulence, porous media, etc): natural convection\nBase input you started from: nat_conv_wall.txt",
          "url": "https://github.com/idaholab/moose/discussions/29550",
          "updatedAt": "2024-12-16T03:07:01Z",
          "publishedAt": "2024-12-15T22:30:57Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis functor has to be defined by a FunctorMaterial. Here it should be this one:\nhttps://mooseframework.inl.gov/source/functormaterials/INSFVEnthalpyFunctorMaterial.html",
                  "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11574990",
                  "updatedAt": "2024-12-15T22:42:11Z",
                  "publishedAt": "2024-12-15T22:42:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "Thank you! I'll add this to my input and see if I run into any other issues.",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575013",
                          "updatedAt": "2024-12-15T22:48:28Z",
                          "publishedAt": "2024-12-15T22:48:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "So I've gotten past the FunctorMaterial issue, but I'm still running into convergence issues. I'm getting:\nLinear solve did not converge due to DIVERGED_PC_FAILED iterations 0\nPC failed due to FACTOR_NUMERIC_ZEROPIVOT\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0\nAnd I was looking at a similar discussion post that you answered a while back, mentioning to get around the FACTOR_NUMERIC_ZEROPIVOT, we can add a nonzero quantity to the diagonal, using the -pc_factor_shift NONZERO petsc options/values. I have that in my input but I'm still getting the same issue.",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575260",
                          "updatedAt": "2024-12-16T00:08:51Z",
                          "publishedAt": "2024-12-16T00:08:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "should be -pc_factor_shift_type iirc",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575287",
                          "updatedAt": "2024-12-16T00:15:43Z",
                          "publishedAt": "2024-12-16T00:15:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "That fixed it, thank you! I'm unfamiliar with the way MOOSE solves its simulations. Do you have any resources I can read into to understand the numerical methods of the different solvers?",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575360",
                          "updatedAt": "2024-12-16T00:29:31Z",
                          "publishedAt": "2024-12-16T00:29:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You ll have to look to the PETSc documentation for how the nonlinear system is solved. MOOSE does the assembly then calls petsc",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575469",
                          "updatedAt": "2024-12-16T00:46:52Z",
                          "publishedAt": "2024-12-16T00:46:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "If I wanted to run the simulation as steady-state, which parameters would I change? I've commented out the time-dependent kernels and also the TimeStepper block under the Executioner block, then changed Transient to Steady, but then I run into another DIVERGED_DTOL convergence issue, I also added automatic_scaling in my executioner block.\nFramework Information:\nMOOSE Version:           git commit 2bd11a0 on 2024-10-06\nLibMesh Version:\nPETSc Version:           3.21.5\nSLEPc Version:           3.21.1\nCurrent Time:            Sun Dec 15 19:53:48 2024\nExecutable Timestamp:    Sun Oct  6 04:10:42 2024\nCheckpoint:\nWall Time Interval:      Every 3600 s\nUser Checkpoint:         Disabled\nCheckpoints Kept:      2\nExecute On:              TIMESTEP_END\nParallelism:\nNum Processors:          1\nNum Threads:             1\nMesh:\nParallel Type:           replicated\nMesh Dimension:          2\nSpatial Dimension:       2\nNodes:                   36\nElems:                   25\nNum Subdomains:          1\nNonlinear System:\nNum DOFs:                100\nNum Local DOFs:          100\nVariables:               { \"vel_x\" \"vel_y\" \"pressure\" \"T\" }\nFinite Element Types:    \"MONOMIAL\"\nApproximation Orders:    \"CONSTANT\"\nExecution Information:\nExecutioner:             Steady\nSolver Mode:             NEWTON\nPETSc Preconditioner:    lu\nMOOSE Preconditioner:    SMP (auto)\nPostprocessor Values:\n+----------------+----------------+\n| time           | ave_T          |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+\nPerforming automatic scaling calculation\n0 Nonlinear |R| = 8.303678e+03\n0 Linear |R| = 8.303678e+03\n1 Linear |R| = 1.000718e-10\n1 Nonlinear |R| = 3.338182e+08\n0 Linear |R| = 3.338182e+08\n1 Linear |R| = 8.988101e-04\n2 Nonlinear |R| = 9.164821e+07\n0 Linear |R| = 9.164821e+07\n1 Linear |R| = 6.644202e-08\n3 Nonlinear |R| = 2.058075e+07\n0 Linear |R| = 2.058075e+07\n1 Linear |R| = 1.044626e-08\n4 Nonlinear |R| = 5.263572e+06\n0 Linear |R| = 5.263572e+06\n1 Linear |R| = 4.649094e-09\n5 Nonlinear |R| = 1.930216e+06\n0 Linear |R| = 1.930216e+06\n1 Linear |R| = 2.490749e-09\n6 Nonlinear |R| = 2.454784e+06\n0 Linear |R| = 2.454784e+06\n1 Linear |R| = 4.081857e-08\n7 Nonlinear |R| = 1.965131e+09\n0 Linear |R| = 1.965131e+09\n1 Linear |R| = 1.977286e-06\n8 Nonlinear |R| = 5.999012e+05\n0 Linear |R| = 5.999012e+05\n1 Linear |R| = 1.087908e-06\n9 Nonlinear |R| = 6.960520e+05\n0 Linear |R| = 6.960520e+05\n1 Linear |R| = 1.075856e-08\n10 Nonlinear |R| = 1.063886e+06\n0 Linear |R| = 1.063886e+06\n1 Linear |R| = 3.278389e-09\n11 Nonlinear |R| = 5.422805e+08\n0 Linear |R| = 5.422805e+08\n1 Linear |R| = 4.369014e-07\n12 Nonlinear |R| = 7.352211e+06\n0 Linear |R| = 7.352211e+06\n1 Linear |R| = 3.356987e-06\n13 Nonlinear |R| = 4.169012e+09\n0 Linear |R| = 4.169012e+09\n1 Linear |R| = 1.430620e-06\n14 Nonlinear |R| = 9.723472e+09\n0 Linear |R| = 9.723472e+09\n1 Linear |R| = 1.466204e-03\n15 Nonlinear |R| = 7.599592e+11\n0 Linear |R| = 7.599592e+11\n1 Linear |R| = 6.276364e-03\n16 Nonlinear |R| = 1.370462e+13\n0 Linear |R| = 1.370462e+13\n1 Linear |R| = 5.705603e+00\n17 Nonlinear |R| = 1.451590e+16\nNonlinear solve did not converge due to DIVERGED_DTOL iterations 17\nSolve Did NOT Converge!\nAborting as solve did not converge",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575911",
                          "updatedAt": "2024-12-16T02:09:35Z",
                          "publishedAt": "2024-12-16T02:09:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For steady state (without using a relaxation transient) you need to work on the initialization. The initial condition needs to fall in the region of attraction of the solution, which can be hard to do\nIt's generally easier to use a relaxation-to-steady state transient",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11576090",
                          "updatedAt": "2024-12-16T02:40:33Z",
                          "publishedAt": "2024-12-16T02:40:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "I understand, I think that's what I have for my transient case, where it runs the simulation until it reaches steady state.",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11576212",
                          "updatedAt": "2024-12-16T03:07:01Z",
                          "publishedAt": "2024-12-16T03:07:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error: Section '[Sphinx]' does not have an associated \"Action\" after Updating MOOSE",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello everyone,\nYesterday I updated MOOSE to the latest version (it had been several months since my last update). After recompiling my custom application successfully, I encountered the following error when running my input file:\ntest.i:79.1: section '[Sphinx]' does not have an associated \"Action\".\n Common causes:\n- you misspelled the Action/section name\n- the app you are running does not support this Action/syntax\n\nThe issue is that I do have this custom action implemented in my application, and it was working fine before the MOOSE update.\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_variable\");\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_kernel\");\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_bc\");\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_aux_variable\");\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_aux_kernel\");\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_user_object\");\n\nIs there any recent change in MOOSE\u2019s handling of custom actions or input file parsing that I should be aware of? Or could there be additional steps needed after updating MOOSE to ensure custom actions are recognized?\nAny guidance would be greatly appreciated.\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/29545",
          "updatedAt": "2024-12-16T02:24:04Z",
          "publishedAt": "2024-12-15T08:57:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo we have not changed neither of these.\nDo you have in SphixApp.C a call to register SphinxAction to the [Sphinx] block?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/29545#discussioncomment-11572402",
                  "updatedAt": "2024-12-15T14:54:29Z",
                  "publishedAt": "2024-12-15T14:54:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you for your response. After the update, I forgot to modify the autogenerated SphixApp.C. As you pointed out, I indeed didn\u2019t register SphinxAction in SphixApp.C. After making the necessary changes, the issue has been resolved.\nThanks again for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/29545#discussioncomment-11575981",
                          "updatedAt": "2024-12-16T02:24:02Z",
                          "publishedAt": "2024-12-16T02:24:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}