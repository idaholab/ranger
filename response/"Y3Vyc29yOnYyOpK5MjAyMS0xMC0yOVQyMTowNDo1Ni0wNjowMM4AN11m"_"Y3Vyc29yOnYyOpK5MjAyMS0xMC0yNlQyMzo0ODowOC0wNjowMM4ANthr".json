{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMC0yNlQyMzo0ODowOC0wNjowMM4ANthr"
    },
    "edges": [
      {
        "node": {
          "title": "Dummy kernel for simulation",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Hello!\nA mesh for my simulation has several phases (A, B, C, and D).\nI want to run a simulation (physics) for only one phase (C).\nHowever, as far as I know, MOOSE requires every phase have a kernel.\nI tried to NullKernel for A,B, and D, but it did not converge.\nAre there any ways to run a simulation without affecting simulation convergence?\nThanks!\nBest regards,\nHokon Kim",
          "url": "https://github.com/idaholab/moose/discussions/19247",
          "updatedAt": "2022-06-28T11:43:53Z",
          "publishedAt": "2021-10-28T20:01:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nhow ironic I was documenting this kernel last week but did not make the PR yet. I ll make it now.\nBest option is to move the variables to aux variables since you are not solving for them. That will decrease the size of the matrix.\nThe NullKernel has a jacobian fill parameter that should have done the trick. Can you try increasing it?\nOtherwise I d try with a time derivative kernel, since these variables are effectively solving that equation (dA/dt = 0)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19247#discussioncomment-1555378",
                  "updatedAt": "2022-06-28T11:43:53Z",
                  "publishedAt": "2021-10-28T20:42:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Here s the future version of the docs for this\nhttps://mooseframework.inl.gov/docs/PRs/19248/site/source/kernels/NullKernel.html\nlet s improve it as we figure this one out",
                          "url": "https://github.com/idaholab/moose/discussions/19247#discussioncomment-1559833",
                          "updatedAt": "2022-06-28T11:43:55Z",
                          "publishedAt": "2021-10-29T15:47:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "As far as I know,\nVariables work with Kernels and AuxVariables work with AuxKernels.\nIf I move some variables to aux variables, then I might use AuxKernels.\nDoes Kernels (NullKernel) work with aux variables?\nI don't run an application with the input below, yet.\n[Variables]\n  [./phi_YSZ]\n    block = 'PT_YSZ_TET4 PT_TPB_TET4'\n    initial_condition = 0.00000 # (V)\n    scaling = 1e4\n  [../]\n[]\n\n[Kernels]\n  [./vacancyIonicDrift]\n    type  = DiffMatKernel\n    block = 'PT_YSZ_TET4 PT_TPB_TET4'\n    variable  = phi_YSZ\n    diff_coef = 'sigma_YSZ'\n  [../]\n\n  [./gasDiffusion]\n    type  = NullKernel\n    block = 'PT_PORE_TET4 PT_TPB_TET4'\n    variable  = p_O2\n  [../]\n\n  [./holeDrift]\n    type  = NullKernel\n    block = 'PT_LSM_TET4 PT_TPB_TET4' # when you use previously generated mesh, you need to use LSM block.\n    variable  = phi_LSM\n  [../]\n[]\n\n[AuxVariables]\n  [./p_O2]\n    block = 'PT_PORE_TET4 PT_TPB_TET4'\n    initial_condition = 0.21 # (atm)\n    # scaling = 1e4\n  [../]\n\n  [./phi_LSM]\n    block = 'PT_LSM_TET4 PT_TPB_TET4' # when you use previously generated mesh, you need to use LSM block.\n    initial_condition = 1.03665 # (V) Just for condition: Each subdomain must contain at least one Kernel.\n    # scaling = 1e7 # 1e2 for cylinder\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/19247#discussioncomment-1560522",
                          "updatedAt": "2022-06-28T11:43:55Z",
                          "publishedAt": "2021-10-29T18:06:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you move the variable to be an aux-Variable then you dont need a NullKernel. The NullKernel is to avoid a singularity in the non-linear system. If you dont want to do anything to an auxvariable then dont have an auxkernel for it",
                          "url": "https://github.com/idaholab/moose/discussions/19247#discussioncomment-1560916",
                          "updatedAt": "2022-06-28T11:43:57Z",
                          "publishedAt": "2021-10-29T19:44:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "My question is \"even I move some variables to Aux-variable\", still some phases (A, B, and D) does not have Kernels.\nThis will give me an error like \"each subdomain has one Kernel..\"",
                          "url": "https://github.com/idaholab/moose/discussions/19247#discussioncomment-1560963",
                          "updatedAt": "2022-06-28T11:44:01Z",
                          "publishedAt": "2021-10-29T19:51:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh those are less of a concern.\nJust add \"kernel_coverage_check = false\" to your [Problem] block.",
                          "url": "https://github.com/idaholab/moose/discussions/19247#discussioncomment-1561023",
                          "updatedAt": "2022-06-28T11:44:00Z",
                          "publishedAt": "2021-10-29T20:10:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "I modified part of input file like below.\nAs far as I know, there are not any issues.\nI didn't run it with this input file yet. But, let's see if it works.\n[Variables]\n  [./phi_YSZ]\n    block = 'PT_YSZ_TET4 PT_TPB_TET4'\n    initial_condition = 0.00000 # (V)\n    scaling = 1e4\n  [../]\n[]\n\n[Kernels]\n  [./vacancyIonicDrift]\n    type  = DiffMatKernel\n    block = 'PT_YSZ_TET4 PT_TPB_TET4'\n    variable  = phi_YSZ\n    diff_coef = 'sigma_YSZ'\n  [../]\n[]\n\n[Problem] # To make it possible to run a simulation without assigning kernel or material property to each phase.\n  kernel_coverage_check = false\n  material_coverage_check = false\n[]\n\n[BCs]\n  [./potentialYSZ_bottom]\n    type = DirichletBC\n    variable = phi_YSZ\n    boundary = 'SF_YSZ_WITH_XMAX'\n    value = 0.00000 # (V)\n  [../]\n\n  [./potentialYSZ_top]\n    type = FunctionDirichletBC\n    variable = phi_YSZ\n    boundary = 'SF_YSZ_WITH_XMIN'\n    function = 'funcPotentialYSZ' # (V)\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/19247#discussioncomment-1561156",
                          "updatedAt": "2022-06-28T11:44:00Z",
                          "publishedAt": "2021-10-29T20:42:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "units system",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hello,\nIf I generate mesh in the unit of mm rather than m, then how should the units system in the input file be changed?\nFor example, when I use m in the mesh and input density = 1kg/m^3, thermal conductivity = 1W/mK and specific heat = 1 J/kgK , then what's the unit of them in the input file when the mesh with unit of mm ?\nI checked the page https://mooseframework.inl.gov/source/utils/Units.html  but find no solutions. Thank you:)",
          "url": "https://github.com/idaholab/moose/discussions/19256",
          "updatedAt": "2022-06-14T05:44:55Z",
          "publishedAt": "2021-10-29T09:17:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf the mesh is in mm then all units need to be adapted to mm. I recommend you document them throughout your input file. If you use any pre-made model (like the fluid properties from the fluid_properties module), make sure to check those for units too.\nSo in the input file:\n1kg / m3 -> 1e-9 kg/mm3 now\n1W/mk -> 1e-3 W/mmK\netc\nThat page is one of the best resource wrt unit conversions. The other discussion about how to do units in input files is here\nhttps://mooseframework.inl.gov/application_usage/input_syntax.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19256#discussioncomment-1559791",
                  "updatedAt": "2022-06-14T05:45:09Z",
                  "publishedAt": "2021-10-29T15:40:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@GiudGiud Thank you:)",
                          "url": "https://github.com/idaholab/moose/discussions/19256#discussioncomment-1560725",
                          "updatedAt": "2022-06-14T05:45:09Z",
                          "publishedAt": "2021-10-29T18:56:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Combining Grain Tracker with Discrete Nucleation",
          "author": {
            "login": "jbair34"
          },
          "bodyText": "Hi All,\nI was wondering if it is possible to use MOOSE's grain tracker algorithms in a solidification simulation with discrete nucleation? My understanding of the grain tracker is that the grain IDs are assigned at the start of the simulation so I am guessing it is not possible to have a grain ID assigned upon nucleation? We were trying to set up a simulation with random orientations of nuclei which would be tied to a grain ID.\nThanks,\nJake",
          "url": "https://github.com/idaholab/moose/discussions/19244",
          "updatedAt": "2022-06-29T05:45:41Z",
          "publishedAt": "2021-10-28T18:29:28Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hi Jake- there is a capability to use a \"reserved\" order parameter to introduce nuclei using the discrete nucleation algorithm. Basically new nuclei are brought into existence with the reserved order parameter, then the GrainTracker remaps them to different order parameters. There is some description on the documentation page:\nhttps://mooseframework.inl.gov/modules/phase_field/Nucleation/DiscreteNucleation.html\nSee the section under Direct Order Parameter Modification. However I am not sure if this is going to work if there is any anisotropy in the properties of the individual nuclei, like if you are simulating dendritic solidification. If there is anisotropy in the properties, I don't think you can re-use order parameters to allow arbitrary orientations. So each nucleus with the same order parameter is going to have the same orientation relationship relative to the liquid. But, if you are simulating isotropic particles this shouldn't be an issue.",
                  "url": "https://github.com/idaholab/moose/discussions/19244#discussioncomment-1560625",
                  "updatedAt": "2022-06-29T05:45:41Z",
                  "publishedAt": "2021-10-29T18:27:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jbair34"
                          },
                          "bodyText": "Thanks Larry! I was hoping the grain ID itself could provide the anisotropy information rather than the order parameter but I guess we might have to try to figure out a way to do that differently. We'll play with it a little just to test it though and see if we can get it to work as is.",
                          "url": "https://github.com/idaholab/moose/discussions/19244#discussioncomment-1560656",
                          "updatedAt": "2022-06-29T05:45:41Z",
                          "publishedAt": "2021-10-29T18:33:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Boussinesq convergence problem",
          "author": {
            "login": "erikgus94"
          },
          "bodyText": "Hi,\nI was hoping to get some tips or answers to how I could get a converging solution to my Boussinesq problem. My input file is pretty much identical to the example file on the INSFVMomentumBoussinesq page except that I have redefined the boundary conditions and material properties as well as included a mesh file with a 2d loop. I have tried using different scaling parameters with no luck, my input and mesh files are available here.",
          "url": "https://github.com/idaholab/moose/discussions/19208",
          "updatedAt": "2023-02-25T00:07:44Z",
          "publishedAt": "2021-10-26T12:37:49Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nI've been able to make a reduced version of this simulation converge on a quad simplified mesh using a transient and a viscosity rampdown through time.\nThe problem is that the initialization is too difficult for the numerical solver with the real value of viscosity. So we start with a highly viscous problem, basically diffusion with a little bit of flow, and go down from there.\nI also added an initial condition to temperature (a little rough going from 0K to 660 over 5s otherwise)\nAnd switched the advected quantity (momentum, energy) interpolation method from average to upwind. Average can be oscillatory as it s a second order method. We will have 2nd order limited (not oscillating) interpolation methods in the near future.\nFinally, I switched from no slip to free slip BCs. The mesh you are using is much too coarse to resolve a no-slip wall.\nI pushed my solution to this repo: https://github.com/GiudGiud/Boussinesq-question.\nIt's likely not converged mesh-wise. The relaxation transient is also not completely finished, but at least it's running with the right fluid properties, we just need to wait.\nNote that you will want to optimize the time stepping, the mesh and the numerical solver to get better performance.\nTriangle meshes are supported but we recommend using quad meshes for fluid simulations for now.\nI think the bigger issue is your mesh. Switching the mesh from mine to yours breaks down at 10x the viscosity\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19208#discussioncomment-1540734",
                  "updatedAt": "2023-02-25T00:07:44Z",
                  "publishedAt": "2021-10-26T19:08:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "erikgus94"
                          },
                          "bodyText": "Thanks a lot for the help, it is much appreciated!\nSmart solution to use transient rampdown of the viscosity. I'm managing to get an converging solution with the mesh you made @GiudGiud.\nI made another mesh file with quad mesh as you suggested but I'm still not able to get it to converge even for the first time step. The mesh file can be found here, the new mesh is still coarse but I'm applying free slip BSs. See input file here.\nCould it be that it is actually converging but very slowly?\nAnd also, have I assumed right that the units Navier Stokes module uses  is [Pa* s] for viscosity, [kg/m^3] for density, [W/m* K] for thermal conductivity and [J/kg* K] for specific heat capacity?",
                          "url": "https://github.com/idaholab/moose/discussions/19208#discussioncomment-1559667",
                          "updatedAt": "2023-02-25T00:07:49Z",
                          "publishedAt": "2021-10-29T15:19:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yup we use SI units in the Navier Stokes module. Some other MOOSE modules allow for imperial units but it hasnt been done for that one\nMy guess is that we have to keep helping the solver by initializing better, or using an even slower viscosity rampdown.\nCould you please try to get convergence on a non-slanted version of your mesh (so starting from my mesh and adjusting the pipe size until it's the same as your mesh. This will require adjusting all the mesh generators btw) ?",
                          "url": "https://github.com/idaholab/moose/discussions/19208#discussioncomment-1559747",
                          "updatedAt": "2023-02-25T00:08:44Z",
                          "publishedAt": "2021-10-29T15:33:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Why no 'QR' factorization option?",
          "author": {
            "login": "aladshaw3"
          },
          "bodyText": "I know when performing a 'NEWTON' solve, the MOOSE framework will use 'LU' factorization, and you can also use 'LU' or 'ILU' as a sub-preconditioner on blocks of the Jacobian, but I have run into some situations where 'LU' fails (presumably from some pivoting issue).\nI also know that PETSc supports 'QR' factorization as a direct solve method (https://petsc.org/release/docs/manualpages/PC/PCQR.html#PCQR), which is generally a more numerically stable method than 'LU' factorization. However, when I try to invoke 'QR' from the input file to use as a sub-preconditioner, PETSc spits errors out at me.\nIn my input file, I put 'qr' as the option for either '-pc_type', '-sub_pc_type', or even '-ksp_pc_type' and I always get the following error (or some variation of this).\n[0]PETSC ERROR: --------------------- Error Message --------------------------------------------------------------\n[0]PETSC ERROR: Unknown type. Check for miss-spelling or missing package: https://www.mcs.anl.gov/petsc/documentation/installation.html#external\n[0]PETSC ERROR: Unable to find requested PC type qr\n[0]PETSC ERROR: See https://www.mcs.anl.gov/petsc/documentation/faq.html for trouble shooting.\n[0]PETSC ERROR: Petsc Release Version 3.15.1, unknown\n[0]PETSC ERROR: ./cats-opt on a  named opal by 1pi Tue Oct 26 15:21:42 2021\n[0]PETSC ERROR: Configure options --COPTFLAGS=-O3 --CXXOPTFLAGS=-O3 --FOPTFLAGS=-O3 --with-x=0 --with-mpi=1 --with-ssl=0 --with-openmp=1 --with-debugging=0 --with-cxx-dialect=C++11 --with-shared-libraries=1 --download-mumps=1 --download-strumpack=1 --download-hypre=1 --download-metis=1 --download-slepc=1 --download-ptscotch=1 --download-parmetis=1 --download-scalapack=1 --download-superlu_dist=1 --with-fortran-bindings=0 --with-sowing=0 --with-64-bit-indices EOF --download-fblaslapack=1 AR=${PREFIX}/bin/x86_64-conda-linux-gnu-ar CC=mpicc CXX=mpicxx FC=mpifort FC=mpifort FC=mpifort CFLAGS=\"-march=nocona -mtune=haswell\" CXXFLAGS=\"-march=nocona -mtune=haswell\" LDFLAGS=\"-Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,--disable-new-dtags -Wl,--gc-sections -Wl,-rpath,/home/1pi/miniconda3/envs/moose/lib -Wl,-rpath-link,/home/1pi/miniconda3/envs/moose/lib -L/home/1pi/miniconda3/envs/moose/lib\" --prefix=/home/1pi/miniconda3/envs/moose\n[0]PETSC ERROR: #1 PCSetType() at /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-petsc_1626838109546/work/src/ksp/pc/interface/pcset.c:67\n[0]PETSC ERROR: #2 PCSetFromOptions() at /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-petsc_1626838109546/work/src/ksp/pc/interface/pcset.c:154\n[0]PETSC ERROR: #3 KSPSetFromOptions() at /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-petsc_1626838109546/work/src/ksp/ksp/interface/itcl.c:355\n[0]PETSC ERROR: #4 PCSetUp_KSP() at /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-petsc_1626838109546/work/src/ksp/pc/impls/ksp/pcksp.c:98\n[0]PETSC ERROR: #5 PCSetUp() at /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-petsc_1626838109546/work/src/ksp/pc/interface/precon.c:1015\n[0]PETSC ERROR: #6 KSPSetUp() at /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-petsc_1626838109546/work/src/ksp/ksp/interface/itfunc.c:406\n[0]PETSC ERROR: #7 KSPSolve_Private() at /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-petsc_1626838109546/work/src/ksp/ksp/interface/itfunc.c:850\n[0]PETSC ERROR: #8 KSPSolve() at /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-petsc_1626838109546/work/src/ksp/ksp/interface/itfunc.c:1085\n[0]PETSC ERROR: #9 SNESSolve_NEWTONLS() at /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-petsc_1626838109546/work/src/snes/impls/ls/ls.c:225\n[0]PETSC ERROR: #10 SNESSolve() at /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-petsc_1626838109546/work/src/snes/interface/snes.c:4653\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\nSo my question is, does the MOOSE framework not support the usage of 'QR' factorization methods in PETSc? I think this would be a nice option to have for when any 'LU' factorization fails for one reason or another.",
          "url": "https://github.com/idaholab/moose/discussions/19212",
          "updatedAt": "2022-08-02T16:21:25Z",
          "publishedAt": "2021-10-26T19:26:40Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@fdkong for using QR over LU for direct solves\nwhen LU fails because of pivoting issue, an easy almost-always-fix is to add a shift with this:\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'",
                  "url": "https://github.com/idaholab/moose/discussions/19212#discussioncomment-1555203",
                  "updatedAt": "2022-08-02T16:21:31Z",
                  "publishedAt": "2021-10-28T19:59:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aladshaw3"
                          },
                          "bodyText": "@GiudGiud  I have used that option before (and generally leave it active), but there are still some cases where the LU will fail, but other solvers are fine.\nDoes the '-pc_factor_shift_type' argument apply to ONLY '-pc_type'? Or will it still apply when I use LU as '-sub_pc_type' and/or '-ksp_pc_type'?\nAre there other LU options I can toggle when LU fails?",
                          "url": "https://github.com/idaholab/moose/discussions/19212#discussioncomment-1555309",
                          "updatedAt": "2022-08-02T16:21:40Z",
                          "publishedAt": "2021-10-28T20:25:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@fdkong will know more about LU options and I m curious as well.\nI suspect the main PC shift does not apply for the sub_pc since there is a sub_pc_factor_shift parameter as well",
                          "url": "https://github.com/idaholab/moose/discussions/19212#discussioncomment-1555380",
                          "updatedAt": "2022-08-02T16:21:45Z",
                          "publishedAt": "2021-10-28T20:43:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "there are sub* versions of the shift. See\n  petsc_options_iname = '-pc_type -sub_pc_type   -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm       ilu            nonzero'",
                          "url": "https://github.com/idaholab/moose/discussions/19212#discussioncomment-1555417",
                          "updatedAt": "2022-08-02T16:21:49Z",
                          "publishedAt": "2021-10-28T20:53:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "I know when performing a 'NEWTON' solve, the MOOSE framework will use 'LU' factorization, and you can also use 'LU' or 'ILU' as a sub-preconditioner on blocks of the Jacobian,\n\nHmmm, this is not really related to Newton or PJFNK.  We use the default setting from PETSc if you do not specify anything in your input file. By default, we use block Jacobi with ILU (not LU) as a subblock solver.  Yes, if the code is run on one MPI rank (serial run), you will get an essential ILU solver since the subblock is the whole block.\n\nSo my question is, does the MOOSE framework not support the usage of 'QR' factorization methods in PETSc?\n\nQR was introduced to PETSc.3.16.x  that was released about two months ago, and right now MOOSE is still using PETSc.3.15.x.  We will update PETSc soon to 3.16.x.\nWe offer all options from PETSc. We do not really truncate anything.\nDid you have any tests that show QR is better than LU/ILU?\n\nDoes the '-pc_factor_shift_type' argument apply to ONLY '-pc_type'? Or will it still apply when I use LU as '-sub_pc_type' and/or '-ksp_pc_type'?\n\nYes, you need prefix for sub solvers.\nWhat your petsc options look like?",
                  "url": "https://github.com/idaholab/moose/discussions/19212#discussioncomment-1555542",
                  "updatedAt": "2022-08-02T16:21:54Z",
                  "publishedAt": "2021-10-28T21:19:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aladshaw3"
                          },
                          "bodyText": "@fdkong\nThanks for the input! All I needed to do was to set all the sub-solvers to use 'nonzero' shift factors.\nI don't have any specific cases to point to where QR was better than LU, but I generally just use QR when available because it is a more stable factorization technique.",
                          "url": "https://github.com/idaholab/moose/discussions/19212#discussioncomment-1558868",
                          "updatedAt": "2022-08-02T16:21:54Z",
                          "publishedAt": "2021-10-29T13:00:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Documentation/Code Inconsistency",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "The documentation for [Output] in the Exodus section - https://mooseframework.inl.gov/source/outputs/Exodus.html says that options for execute_on are 'NONE, INITIAL, LINEAR, NONLINEAR, TIMESTEP_END, TIMESTEP_BEGIN, FINAL, FAILED, CUSTOM, ALWAYS', however when running the code, ALL isn't allowed, the options are \"NONE INITIAL LINEAR NONLINEAR TIMESTEP_END TIMESTEP_BEGIN FINAL FAILED CUSTOM\".",
          "url": "https://github.com/idaholab/moose/discussions/19147",
          "updatedAt": "2023-10-18T03:10:23Z",
          "publishedAt": "2021-10-19T12:46:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nALL isnt in the list, but ALWAYS is. it's accepted as a parameter. However I ve just tested it and it doesn't trigger on a simple example.\nI'll see if others pitch in on this. This is probably something to fix though\nfyi best documentation on execute_on I could find is here:\nhttps://mooseframework.inl.gov/bison/source/interfaces/SetupInterface.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19147#discussioncomment-1502858",
                  "updatedAt": "2023-10-18T03:10:23Z",
                  "publishedAt": "2021-10-19T14:30:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Added an issue\n#19255\nso I dont forget about it",
                          "url": "https://github.com/idaholab/moose/discussions/19147#discussioncomment-1556830",
                          "updatedAt": "2023-10-18T03:22:30Z",
                          "publishedAt": "2021-10-29T05:20:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question on a Lagrange multiplier constraint kernel",
          "author": {
            "login": "xueyang94"
          },
          "bodyText": "Hello,\nIn the SwitchingFunctionConstraintEta kernel, the residual is _lambda[_qp] * _dh[_qp] * _test[_i][_qp]. Is this kernel assuming that one switching function h is a function of only one phase parameter eta? For example, only the simple and high order switching functions are considered, but not the SwitchingFunctionMultiPhaseMaterial where each h is a function of multiple etas?\nIf one h can depend on multiple etas, then shouldn't the kernel residual be _lambda[_qp] * (*_dh[i][j])[_qp] * _test[_i][_qp]? (This refers back to the multiphase models page, the first weak form equation under the lagrange multiplier constraint section.)\nThanks,\nXY",
          "url": "https://github.com/idaholab/moose/discussions/19181",
          "updatedAt": "2022-11-02T15:01:36Z",
          "publishedAt": "2021-10-22T15:54:07Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nIt's a good question imo.\nh is a material property (and dh its derivative) which can be arbitrarily complex and depend on any number of phase parameters. _dh is the derivative with regards to only the variable of the kernel.\nBecause it's a lagrange multiplier constraint, I would want to add only the term for that particular variable to the residual for that variable. If you look at https://github.com/idaholab/moose/blob/next/modules/phase_field/test/tests/MultiPhase/acmultiinterface.i this is what is being done.\n@dschwen will know more than me.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19181#discussioncomment-1556784",
                  "updatedAt": "2022-11-02T15:01:36Z",
                  "publishedAt": "2021-10-29T05:05:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem building libmesh with intel compilers",
          "author": {
            "login": "ke7kto"
          },
          "bodyText": "I recently installed the intel compilers on my Ubuntu 20.04 LTS machine. When recompiling MOOSE, I got errors.\nHere is my process:\ncd ~/my/new/moosedir/scripts\n./update_and_rebuild_petsc.sh\n./update_and_rebuild_libmesh.sh\n\nThis results in\n/bin/ld: ./.libs/libmesh_opt.so: undefined reference to \nvtkMPICommunicatorOpaqueComm::vtkMPICommunicatorOpaqueComm(int*)'\n\nI've found /usr/lib/x86_64-linux-gnu/libvtkParallelMPI-7.1.so and the libvtkParallelMPI-pv5.7.so (ostensibly paraview vtk library) to have the definition of _ZN28vtkMPICommunicatorOpaqueComm9GetHandleEv, but am unsure how to proceed.",
          "url": "https://github.com/idaholab/moose/discussions/19237",
          "updatedAt": "2022-06-16T21:12:15Z",
          "publishedAt": "2021-10-28T17:25:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "IIRC the Moose folks got sick of seeing issues from Intel compilers and have stopped supporting them, so you might want to give up on the project altogether.  If you don't, though, maybe open this as a libMesh issue?  I think we still have enough non-MOOSE icpc users to want to look into this.\nYou've got an undefined reference (is that the only one?) to a particular constructor there, but you're showing a definition for the GetHandle method on the same object, not the same thing.\nI'm running 20.04 too, so I could probably reproduce this easily enough, though I don't currently have VTK installed.  Any particular reason you have VTK 7 installed rather than 6 or 9?",
                  "url": "https://github.com/idaholab/moose/discussions/19237#discussioncomment-1554639",
                  "updatedAt": "2022-06-16T21:15:43Z",
                  "publishedAt": "2021-10-28T17:59:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Oh, shoot, I don't actually have icpc installed on any of my current Ubuntu systems.  Sorry, I'm so used to having a system with intel modules handy that I'd forgotten that's no longer the case.  I might still be able to help you find a fix, but it'd be a lot slower if I can't replicate the problem.",
                          "url": "https://github.com/idaholab/moose/discussions/19237#discussioncomment-1554657",
                          "updatedAt": "2022-06-16T21:15:49Z",
                          "publishedAt": "2021-10-28T18:02:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "Intel has released their compiler toolkits for free for general use under a \"no support\" tier. Here's the instructions for adding the apt repo, but I made a mistake in adding the setvars.sh script to my ~/.bashrc. I don't really need to use the intel tools to build moose.\nThere is no particular reason I have VTK 7 installed. I think it may have been autoselected for some reason.",
                          "url": "https://github.com/idaholab/moose/discussions/19237#discussioncomment-1554718",
                          "updatedAt": "2022-06-16T21:15:50Z",
                          "publishedAt": "2021-10-28T18:14:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Glued Contact Convergence with multiple Contacts",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi All, y'all must feel like I'm bombarding you! I've got a problem with a contact convergence problem, I've tried making an MVP type problem, but it converges fine, so I must be missing something in my simplification. I have the following assembly;\n\nI've made the problem smaller, e.g. modelling the contact between the ball and the pin with glued contact, and that converges ok. I've also modelled the contact between the ball and the 'hat' and that converges fine (my initial guess was that it was a separation issue between the ball and the hat, that turned out to be wrong). I've also constrained the 'hat' to move in z only but that made no appreciable difference. So independently pin-ball OK, ball-hat OK, pin-ball-hat - NOPE.\nAny suggestions?",
          "url": "https://github.com/idaholab/moose/discussions/19130",
          "updatedAt": "2022-07-12T18:43:28Z",
          "publishedAt": "2021-10-18T10:25:10Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc @lindsayad @recuero",
                  "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1499092",
                  "updatedAt": "2022-07-12T18:43:24Z",
                  "publishedAt": "2021-10-18T23:17:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "I cannot distinguish the geometry very well from the image. But, from the description, it seems that the determining factor there is the application of the glued contact constraints altogether. I'd make sure there is no part of the mesh that gets overconstrained (maybe reducing the size of some sidesets?).",
                  "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1499168",
                  "updatedAt": "2022-07-12T18:43:24Z",
                  "publishedAt": "2021-10-18T23:59:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Weirdly, there are some points where the penetration is -1e6, i.e. -ve 1 million metres which doesn't make much sense to me frankly.\n\nAlso, when attempting to converge there is a bail out, looks like somehow one of the elements is either displacing or the nodes are shooting off to infinite +z\n\nSetting Up\n  Initializing\n    Finished Initializing Equation Systems                                               [  4.84 s] [  807 MB]\n    Finished Initializing Displaced Equation System                                      [  0.60 s] [  386 MB]\n  Finished Initializing                                                                  [  6.03 s] [ 1196 MB]\nFinished Setting Up                                                                      [  7.51 s] [ 1375 MB]\nFramework Information:\nMOOSE Version:           git commit b5a350860f on 2021-09-28\nLibMesh Version:         aebb5a5c0e1f6d8cf523a720e19f70a6d17c0236\nPETSc Version:           3.15.1\nCurrent Time:            Tue Oct 19 19:23:06 2021\nExecutable Timestamp:    Tue Sep 28 20:19:26 2021\n\nParallelism:\n  Num Processors:          1\n  Num Threads:             8\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          3\n  Spatial Dimension:       3\n  Nodes:                   35424\n  Elems:                   183877\n  Num Subdomains:          3\n\nNonlinear System:\n  Num DOFs:                106272\n  Num Local DOFs:          106272\n  Variables:               { \"disp_x\" \"disp_y\" \"disp_z\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                6025760\n  Num Local DOFs:          6025760\n  Variables:               { \"stress_xx_nodal\" \"strain_xx_nodal\" \"stress_yy_nodal\" \"strain_yy_nodal\" \n                             \"stress_zz_nodal\" \"strain_zz_nodal\" \"vonmises_nodal\" } { \"strain_xx\" \"strain_yy\" \n                             \"strain_zz\" \"vonmises_stress\" } { \"penetration\" \"contact_pressure\" \"nodal_area_contact_ball_socket\" \n                             \"nodal_area_contact_pin_ball\" } \n  Finite Element Types:    \"MONOMIAL\" \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  Solver Mode:             NEWTON\n  MOOSE Preconditioner:    SMP\n\n\n    Setting Up Materials\n      Finished Computing Initial Material Values                                         [  3.40 s] [  997 MB]\n    Finished Setting Up Materials                                                        [  3.41 s] [  998 MB]\n    Reinitializing Because of Geometric Search Objects..                                 [ 25.42 s] [  141 MB]\n  Finished Performing Initial Setup                                                      [ 32.53 s] [ 1157 MB]\n\nTime Step 0, time = 0\n\nTime Step 1, time = 5, dt = 5\n\n    Rebuilding Geometric Search Patches\n      Reinitializing Because of Geometric Search Objects...                              [ 26.22 s] [  -25 MB]\n    Finished Rebuilding Geometric Search Patches                                         [ 26.34 s] [  -24 MB]\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 3.216429e-07\n    Computing Jacobian                                                                   [  7.49 s] [  198 MB]\n      0 Linear |R| = 3.216429e-07\n      1 Linear |R| = 3.190770e-07\n      2 Linear |R| = 3.173445e-07\n      3 Linear |R| = 1.025635e-13\nWARNING: At least one element took more than 10 iterations to converge in inverse_map()...\nRerun in devel/dbg mode for more details.\nERROR: Newton scheme FAILED to converge in 21 iterations in element 122391 for physical point = (x,y,z)=(-0.0166628,  1.63084, 4.32143e+08)\n  Elem Information\n   id()=122391, unique_id()=198603, processor_id()=0\n   type()=TET4\n   dim()=3\n   n_nodes()=4\n    0  Node id()=24809, processor_id()=0, Point=(x,y,z)=(-0.0165868,   1.6312, 4.32143e+08)\n    DoFs=(0/0/74427) (0/1/74428) (0/2/74429) (1/11/5983300) (1/12/5983301) (1/13/5983302) (1/14/5983303) \n    1  Node id()=24811, processor_id()=0, Point=(x,y,z)=(-0.0167855,  1.62849, 4.32143e+08)\n    DoFs=(0/0/74433) (0/1/74434) (0/2/74435) (1/11/5983308) (1/12/5983309) (1/13/5983310) (1/14/5983311) \n    2  Node id()=23894, processor_id()=0, Point=(x,y,z)=(-0.0192472,  1.63069, 4.32143e+08)\n    DoFs=(0/0/71682) (0/1/71683) (0/2/71684) (1/11/5979640) (1/12/5979641) (1/13/5979642) (1/14/5979643) \n    3  Node id()=23893, processor_id()=0, Point=(x,y,z)=(-0.0197317,  1.62942, 4.32143e+08)\n    DoFs=(0/0/71679) (0/1/71680) (0/2/71681) (1/11/5979636) (1/12/5979637) (1/13/5979638) (1/14/5979639) \n   n_sides()=4\n    neighbor(0)=nullptr\n    neighbor(1)=126093\n    neighbor(2)=137441\n    neighbor(3)=128532\n   hmin()=0.00303343, hmax()=0.00427406\n   volume()=4.45414e-09\n   active()=1, ancestor()=0, subactive()=0, has_children()=0\n   parent()=nullptr\n   level()=0, p_level()=0\n   refinement_flag()=DO_NOTHING\n   p_refinement_flag()=DO_NOTHING\n   DoFs=(1/0/3426948) (1/0/3426949) (1/0/3426950) (1/0/3426951) (1/1/3426952) (1/1/3426953) (1/1/3426954) (1/1/3426955) (1/2/3426956) (1/2/3426957) (1/2/3426958) (1/2/3426959) (1/3/3426960) (1/3/3426961) (1/3/3426962) (1/3/3426963) (1/4/3426964) (1/4/3426965) (1/4/3426966) (1/4/3426967) (1/5/3426968) (1/5/3426969) (1/5/3426970) (1/5/3426971) (1/6/3426972) (1/6/3426973) (1/6/3426974) (1/6/3426975) (1/7/5638120) (1/8/5638121) (1/9/5638122) (1/10/5638123)",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504148",
                          "updatedAt": "2022-07-12T18:43:28Z",
                          "publishedAt": "2021-10-19T18:27:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Oh I should also note, i turned on automatic scaling, which was off previously. Could the symmetry plane we can see make a difference?",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504409",
                          "updatedAt": "2022-07-12T18:43:58Z",
                          "publishedAt": "2021-10-19T19:34:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Could be. I'd try doing glued contact with the penalty formulation if you haven't.",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504431",
                          "updatedAt": "2022-07-12T18:43:55Z",
                          "publishedAt": "2021-10-19T19:39:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Oh I should also note, i turned on automatic scaling, which was off previously. Could the symmetry plane we can see make a difference?\n\nSo did the large penetration only show up after turning on automatic scaling?",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504500",
                          "updatedAt": "2022-08-12T12:46:46Z",
                          "publishedAt": "2021-10-19T20:03:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "With penalty, same deal as above. Without symmetry, I get -ve Jacobian error\n[adavis@j0818 run]$ ~/opt/moose/modules/combined/combined-opt -i p5coil_ball_mount-sym.i --n-threads=8\n\nSetting Up\n  Finished Setting Mesh                                                                  [  0.78 s] [  136 MB]\n  Initializing\n    Initializing Equation Systems                                                        [  7.43 s] [ 1238 MB]\n    Finished Initializing Displaced Equation System                                      [  0.92 s] [  570 MB]\n  Finished Initializing                                                                  [  9.38 s] [ 1816 MB]\nFinished Setting Up                                                                      [ 11.75 s] [ 2050 MB]\nFramework Information:\nMOOSE Version:           git commit b5a350860f on 2021-09-28\nLibMesh Version:         aebb5a5c0e1f6d8cf523a720e19f70a6d17c0236\nPETSc Version:           3.15.1\nCurrent Time:            Tue Oct 19 20:51:23 2021\nExecutable Timestamp:    Tue Sep 28 20:19:26 2021\n\nParallelism:\n  Num Processors:          1\n  Num Threads:             8\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          3\n  Spatial Dimension:       3\n  Nodes:                   50807\n  Elems:                   272155\n  Num Subdomains:          3\n\nNonlinear System:\n  Num DOFs:                152421\n  Num Local DOFs:          152421\n  Variables:               { \"disp_x\" \"disp_y\" \"disp_z\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                8912188\n  Num Local DOFs:          8912188\n  Variables:               { \"stress_xx_nodal\" \"strain_xx_nodal\" \"stress_yy_nodal\" \"strain_yy_nodal\" \n                             \"stress_zz_nodal\" \"strain_zz_nodal\" \"vonmises_nodal\" } { \"strain_xx\" \"strain_yy\" \n                             \"strain_zz\" \"vonmises_stress\" } { \"penetration\" \"contact_pressure\" \"nodal_area_contact_ball_socket\" \n                             \"nodal_area_contact_pin_ball\" } \n  Finite Element Types:    \"MONOMIAL\" \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  Solver Mode:             NEWTON\n  MOOSE Preconditioner:    SMP\n\n\n    Setting Up Materials\n      Finished Computing Initial Material Values                                         [  4.86 s] [ 1464 MB]\n    Finished Setting Up Materials                                                        [  4.86 s] [ 1464 MB]\n    Reinitializing Because of Geometric Search Objects.....                              [ 42.59 s] [  172 MB]\n  Finished Performing Initial Setup                                                      [ 51.93 s] [ 1661 MB]\n\nTime Step 0, time = 0\n\nTime Step 1, time = 5, dt = 5\n\n    Rebuilding Geometric Search Patches\n      Reinitializing Because of Geometric Search Objects......                           [ 44.09 s] [    4 MB]\n    Finished Rebuilding Geometric Search Patches                                         [ 44.30 s] [    4 MB]\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 9.152297e-07\n    Computing Jacobian.                                                                  [ 12.57 s] [  584 MB]\n      0 Linear |R| = 9.152297e-07\n      1 Linear |R| = 8.865040e-07\n      2 Linear |R| = 8.865040e-07\n      3 Linear |R| = 1.385801e-09\n  Elem Information\n   id()=244540, unique_id()=313416, processor_id()=0\n   type()=TET4\n   dim()=3\n   n_nodes()=4\n    0  Node id()=44934, processor_id()=0, Point=(x,y,z)=(-0.0438262,  1.75396, -3.93721e+09)\n    DoFs=(0/0/134802) (0/1/134803) (0/2/134804) (1/11/8888696) (1/12/8888697) (1/13/8888698) (1/14/8888699) \n    1  Node id()=44935, processor_id()=0, Point=(x,y,z)=(-0.105596,  1.72867, -3.93721e+09)\n    DoFs=(0/0/134805) (0/1/134806) (0/2/134807) (1/11/8888700) (1/12/8888701) (1/13/8888702) (1/14/8888703) \n    2  Node id()=44925, processor_id()=0, Point=(x,y,z)=(-0.0108594,  1.67695, -3.93721e+09)\n    DoFs=(0/0/134775) (0/1/134776) (0/2/134777) (1/11/8888660) (1/12/8888661) (1/13/8888662) (1/14/8888663) \n    3  Node id()=44929, processor_id()=0, Point=(x,y,z)=(-0.00339524,  1.68348, -3.93721e+09)\n    DoFs=(0/0/134787) (0/1/134788) (0/2/134789) (1/11/8888676) (1/12/8888677) (1/13/8888678) (1/14/8888679) \n   n_sides()=4\n    neighbor(0)=246722\n    neighbor(1)=246886\n    neighbor(2)=245556\n    neighbor(3)=247795\n   hmin()=0.0226688, hmax()=0.135425\n   volume()=-2.01603e-05\n   active()=1, ancestor()=0, subactive()=0, has_children()=0\n   parent()=nullptr\n   level()=0, p_level()=0\n   refinement_flag()=DO_NOTHING\n   p_refinement_flag()=DO_NOTHING\n   DoFs=(1/0/6847120) (1/0/6847121) (1/0/6847122) (1/0/6847123) (1/1/6847124) (1/1/6847125) (1/1/6847126) (1/1/6847127) (1/2/6847128) (1/2/6847129) (1/2/6847130) (1/2/6847131) (1/3/6847132) (1/3/6847133) (1/3/6847134) (1/3/6847135) (1/4/6847136) (1/4/6847137) (1/4/6847138) (1/4/6847139) (1/5/6847140) (1/5/6847141) (1/5/6847142) (1/5/6847143) (1/6/6847144) (1/6/6847145) (1/6/6847146) (1/6/6847147) (1/7/8598500) (1/8/8598501) (1/9/8598502) (1/10/8598503) \nERROR: negative Jacobian -0.000120962 at point (x,y,z)=(-0.0409192,  1.71076, -3.93721e+09) in element 244540\n\nSomehow the nodes are shooting off to -ve infinity in this case??",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504501",
                          "updatedAt": "2022-08-12T12:46:46Z",
                          "publishedAt": "2021-10-19T20:03:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Here are the regions (circled) of large -ve penetration, upper threshold is -0.01",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504539",
                          "updatedAt": "2022-08-12T12:47:12Z",
                          "publishedAt": "2021-10-19T20:13:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "@lindsayad the -ve penetration is consistent between them, however in the case of automatic scaling=true I get a -ve jacobian error, in the case of automatic_scaling=false its the newton scheme failed to converge",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504549",
                          "updatedAt": "2022-08-12T12:47:13Z",
                          "publishedAt": "2021-10-19T20:17:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "What I absolutely do not understand is why I would see large -ve penetration in that particular volume when it does not show up in the case when I model the ball and pin, in isolation without the 'hat'",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504587",
                          "updatedAt": "2022-08-12T12:47:13Z",
                          "publishedAt": "2021-10-19T20:26:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "happy to share files here, if that would be useful",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504601",
                          "updatedAt": "2022-08-12T12:47:14Z",
                          "publishedAt": "2021-10-19T20:29:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "A common issue for secondary nodes that are right on the edge of primary faces (which appears to be where you are having trouble) is that if they are slightly off the face, contact isn't picked up. You can remedy that by setting the tangential_tolerance parameter, which controls a distance (in model coordinates) by which the faces are virtually extended off beyond the edge. I'd try setting that to something like 1/10 the length of your elements in that region.\nI'm puzzled about why this makes the solver fall apart, because the worst case should really just be that contact isn't enforced on those nodes, but it's worth giving it a try.",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504659",
                          "updatedAt": "2022-08-12T12:47:14Z",
                          "publishedAt": "2021-10-19T20:43:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "I can send you this problem, along with my test problem. My original hypothesis, was the curvature of these surfaces came into play in some way so the test problem has a sphere, with conical sections of spherical shells above it. In that case three layers with contact between them was fine. They were exact contact where there was no gaps between the shells, tomorrow I can try a version with gaps.\n\nGet Outlook for Android<https://aka.ms/AAb9ysg>\n\u2026\n________________________________\nFrom: Ben Spencer ***@***.***>\nSent: Tuesday, October 19, 2021 10:42:52 PM\nTo: idaholab/moose ***@***.***>\nCc: Davis, Andrew ***@***.***>; Author ***@***.***>\nSubject: Re: [idaholab/moose] Glued Contact Convergence with multiple Contacts (Discussion #19130)\n\n\nJust a bit!\n\nNow I'm wondering whether we have some sort of fundamental issue related to handling of chains of blocks that are constrained to each other. You mentioned at the beginning that you tried to set up some sort of minimal problem, which actually worked. Was it just something like 3 blocks next to each other with contact constraints between them?\n\nI can't promise that I'll find the time to do much with this, but it would be helpful if you could share your model.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub<#19130 (reply in thread)>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AASTUSVEAJI7P6VNMQLDJFDUHXQ5ZANCNFSM5GGIWGIQ>.\nTriage notifications on the go with GitHub Mobile for iOS<https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android<https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.",
                  "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1504941",
                  "updatedAt": "2022-07-12T18:43:58Z",
                  "publishedAt": "2021-10-19T21:51:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "problem-contact.tar.gz - here is the explicit problem above",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1516058",
                          "updatedAt": "2022-07-12T18:43:56Z",
                          "publishedAt": "2021-10-21T18:11:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "contact-mvp.tar.gz and the contct mvp - I have created and confirmed that there is a double contact problem which works fine, and this triple contact fails.",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1516099",
                          "updatedAt": "2022-07-12T18:43:55Z",
                          "publishedAt": "2021-10-21T18:20:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Oh, I think I may've done something quite dim. I use a pressure boundary, which seems to work absolutely fine when there are two contacts, but not when there are three. However, if I use FunctionDirichletBC for displacement, it seems to be fine. The particular comparison we're doing with ANSYS uses force/pressure based BCs. So I've now figured out from your advice in #17780, what the right thing to do is, and now its working.\n\nThanks for your help, for posterity I'll upload a complete input & mesh which runs as I expect.",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1516881",
                          "updatedAt": "2022-07-12T18:44:16Z",
                          "publishedAt": "2021-10-21T21:11:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Glad it's working!",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1516996",
                          "updatedAt": "2022-08-12T12:47:59Z",
                          "publishedAt": "2021-10-21T21:43:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "I'm horrible at monitoring my notifications -- sorry for not responding earlier.  I'm glad you got this working!  Yes, you have to be really careful about making sure you don't have unrestrained rigid body modes for problems like this.",
                          "url": "https://github.com/idaholab/moose/discussions/19130#discussioncomment-1553963",
                          "updatedAt": "2022-08-12T12:47:59Z",
                          "publishedAt": "2021-10-28T16:09:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Too many constraints (100,000+), and simulation won't start",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi all,\nI'm running a massive scale groundwater simulation (6 millions elements) with faults.\nWe use multipoint constraints (MPCs) to work around faults/discontinuity (LinearNodalConstraint).\nThe simulation could run with no problem with less than 1000 constraints blocks\n\n\nBUT the problem occurs when we have more than 100,000 constraints blocks, and the simulation takes forever to start (it haven't started yet after a few hrs)\n\n\nNot sure if I can work around this? or should I write MPCs algos myself so it takes the master and the slave nodes from a CSV file? (in this case, I don't need a million lines input file)\nPlease suggest if you have any idea.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/18930",
          "updatedAt": "2022-06-15T03:02:10Z",
          "publishedAt": "2021-09-27T09:40:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think this (writing a custom CSV-based MPC) is a good idea. Not all systems in MOOSE are scalable, and MOOSE generally should not scale well with the input file length because every object is created by every process. Then based on the mesh distribution only some of the objects remain active locally.\n@rwcarlsen is there an optimization on the block-restriction with regards to setting up kernels etc ?\nAnother option (more difficult I think) would be to wrap the creation of these MPCs in an action and only create the ones that matter for every rank. That will require a few things imo:\n\nknow which constraint belong on which rank ahead of time, so have that information in the CSV, and use a known partitioning of the simulation (cartesian ones are simple if your case is simple)\nbe extra aware of constraints lying across multiple ranks\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1391069",
                  "updatedAt": "2022-06-15T03:02:11Z",
                  "publishedAt": "2021-09-27T15:14:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud, thank you for you suggestion!\nFirst of all, I'm not sure what do you mean by 'rank' here, but all my constraints are the same (equal value constraints), just with different node pairs.\nI'm thinking of importing MCPs list (master node/slave node) [attached], using either VectorPostprocessors/CSVReader OR Function/PiecewiseConstant\n\nThen feed the data from CSV into LinearNodalConstraint at once\nFrom .C file, I need to let 'primary' read all the node_ID from the first column and then secondary_node_ID read the second column from the CSV file.\n\ndo you have any suggestions on how to work around this?\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1393372",
                          "updatedAt": "2022-06-15T03:02:11Z",
                          "publishedAt": "2021-09-28T01:10:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "I see I can import multiple nodes at once, for example here below\n   [./pp_con_0]\n   type = LinearNodalConstraint\n   variable = porepressure\n   weights = 1\n   penalty = 1e10\n   primary = '166 166 167 167'\n   secondary_node_ids = '241 244 240 242'\n   [../]\n\nbut somehow MOOSE doesn't pair them 1-to-1, I think this is an easier issue to work with @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1393397",
                          "updatedAt": "2022-06-15T03:02:12Z",
                          "publishedAt": "2021-09-28T01:20:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "See the documentation for LinearNodeConstraint, the primary is actually tied with multiple secondary_node_ids, there is no 1 to 1 pairing\nAre all groups of nodes completely separated? If so then it may not matter\nA rank is the same as a process\nYour constraints are all the same but they are distributed in the mesh. So some are active on a process' subdomain, the rest are not",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1393457",
                          "updatedAt": "2022-06-15T03:02:12Z",
                          "publishedAt": "2021-09-28T01:45:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud\n\nAre all groups of nodes completely separated? If so then it may not matter\n\nthey are not, for example here, this 1 primary (master) node has 5 secondary (slave) nodes\n [pwp_constr_119174]\n    type = LinearNodalConstraint\n    variable = porepressure\n    weights = 1\n    penalty = 1e10\n    primary = '786429'\n    secondary_node_ids = '1079754 965795 1265430 1079759'\n  []\n\nI thought I'd be able to do something like this:\nprimary = '786429 786429 786429 786429 786429'\nsecondary_node_ids = '1079754 965795 1265430 1079759'\n\nso that I can have only 1 constraint block in my input file instead of 100,000.\nIs it possible to make it read 1 to 1 by modifying .C file?",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1393485",
                          "updatedAt": "2022-08-13T17:00:15Z",
                          "publishedAt": "2021-09-28T01:57:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You could definitely add that by modifying the .C file.\nYou could have 3 vectors as parameters:\n\nprimary node ids\nsecondary node ids (so maybe 5x the size of primary node ids)\nnumber of secondary nodes for each primary node",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1393494",
                          "updatedAt": "2022-08-13T17:00:15Z",
                          "publishedAt": "2021-09-28T02:00:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If it's 1 to 1 for your application, then you could do it in two vectors. You will be modifying the constraint code directly though",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1393496",
                          "updatedAt": "2022-08-13T17:00:30Z",
                          "publishedAt": "2021-09-28T02:01:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "If it's 1 to 1 for your application, then you could do it in two vectors. You will be modifying the constraint code directly though\n\nThis approach seems easier, but tbh not sure where to start yet, I will get back to you when I have some clue",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1393514",
                          "updatedAt": "2022-08-13T17:00:31Z",
                          "publishedAt": "2021-09-28T02:06:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "my guess is adding a for-loop for each node pair before calculating the constraints, could work.\nThe NodalConstraint.C mainly putting everything into a sparse matrix.\n@GiudGiud do you know any expert in this area that might be able to help? the Constraints .C file is much more difficult to understand compared to the Material .C file",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1395251",
                          "updatedAt": "2022-08-13T17:00:33Z",
                          "publishedAt": "2021-09-28T10:09:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "git blame says @sveerara and @lindsayad for that system\nI think looking at src/loops/ComputeMortarFunctor will also help understanding how things are happening in the back end.",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1397091",
                          "updatedAt": "2022-08-13T17:00:34Z",
                          "publishedAt": "2021-09-28T15:44:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "ComputeMortarFunctor only interacts with MortarConstraints. This is a NodalConstraint",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1397320",
                          "updatedAt": "2022-08-13T17:00:36Z",
                          "publishedAt": "2021-09-28T16:17:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "Can you use regular node-face constraints?  Do you have sidesets defined on the  fault faces.  There is an option for glued contact.",
                  "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1398950",
                  "updatedAt": "2022-06-15T03:02:13Z",
                  "publishedAt": "2021-09-28T21:31:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @lynnmunday, we don't have the fault faces in our mesh, we use wedge elements to deal with discontinuity in the mesh, hence we use nodal constraints.\n\nI also check flow in fracture example, it seems like the fracture is a continuum from the matrix ( they don't split the [volume] mesh across the fault), please let me know if I'm wrong @WilkAndy (I see you are an author of that example).",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1399216",
                          "updatedAt": "2022-06-15T03:02:13Z",
                          "publishedAt": "2021-09-28T23:01:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "I can't figure out what you are showing in the mesh, I don't see wedge elements.  I see a block of hex's being tied to a block of tets.\nAre you trying to model something like what Andy has in one of these examples for fracture flow:\nhttps://mooseframework.inl.gov/modules/porous_flow/flow_through_fractured_media.html\nIn the first example:\nhttps://mooseframework.inl.gov/modules/porous_flow/nomultiapp_flow_through_fractured_media.html\nThe higher dimensional mesh has a lower dimensional mesh has a lower dimensional mesh along the fracture.  The lower dimensional mesh shares nodes with the higher dimensional mesh.  It is all conformally meshed.\nThe other example:\nhttps://mooseframework.inl.gov/modules/porous_flow/multiapp_fracture_flow_introduction.html\nA multiapp is used and energy is transferred between the matrix and fracture\nCould you tell me how your example is different than these.",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1399266",
                          "updatedAt": "2022-06-15T03:02:13Z",
                          "publishedAt": "2021-09-28T23:20:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "There is an EqualValueEmbeddedConstraint in blackbear that is used to model rebar in concrete by tying a 1D bar element to the element nodes that surround it.  That might be similar to what you want.\nhttps://mooseframework.inl.gov/blackbear/source/constraints/EqualValueEmbeddedConstraint.html",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1399286",
                          "updatedAt": "2022-06-15T03:02:19Z",
                          "publishedAt": "2021-09-28T23:29:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Could you tell me how your example is different than these.\n\nHi @lynnmunday, so our discontinuity works such that, we split (duplicated) the node at the fault and use the wedge elements + constraints to link the flow between them.\n\n\nBUT from https://mooseframework.inl.gov/modules/porous_flow/flow_through_fractured_media.html\nthey share the nodes at the fault face\n\nTherefore, the nodes between the fault are continuum?\nit would be nice if we have an example in case (1) for 3D:\n\nA simulation may use a 3D mesh that contains thin 3D elements to represent the fractures. Usually the thin \"fracture\" elements are part of a separate block in the mesh to which appropriate porosity and permeability are prescribed. No special input-file magic needs to be performed.\n\nso if I understand correctly, the discontinuity is handled purely by meshing and not MOOSE?\nIt method we were using work fine on a smaller scale, but for some reason, MOOSE just couldn't handle 100,000 MPCs on the mesh shown below.\n\nI'd be very happy to adopt the method that @WilkAndy introduced if it works the way we wanted.",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1399352",
                          "updatedAt": "2022-08-13T17:02:35Z",
                          "publishedAt": "2021-09-28T23:52:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "@bwspenc is this exactly what EqualValueEmbeddedConstraint does?",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1432433",
                          "updatedAt": "2022-08-13T17:02:42Z",
                          "publishedAt": "2021-10-05T21:23:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "EqualValueEmbeddedConstraint definitely works for 3D elements embedded in 3D elements. A single EqualValueEmbeddedConstraint might be equivalent to your 100,000 LinearNodalConstraints, except that EqualValueEmbeddedConstraint does interpolation at the slave node using shape functions in the master element. BTW, EqualValueEmbeddedConstraint is in moose not blackbear.",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1432480",
                          "updatedAt": "2022-08-13T17:02:42Z",
                          "publishedAt": "2021-10-05T21:41:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "In Andy's dfn modeling example for method 1, the fracture is created in cubit or coreforms trelis meshing using this journal file:\nhttps://github.com/idaholab/moose/blob/master/modules/porous_flow/examples/flow_through_fractured_media/coarse_3D.jou\nIn the journal file the two ellipse surfaces are put into the cube volume and assigned as blocks 2&3 and the cube volume is assigned block 1.  Block 1 is then meshed with tets and blocks 2&3 are meshed with tri's. The fracture has to be explicitly meshed but it also has different physics so different material models are applied to the 3D and 2D blocks.  They share nodes but they have different element types.  The hard part is getting a conformal mesh between all these surfaces and the volume which requires a bunch of webcutting in cubit.  Creating a conformal mesh is really hard for a realistic dfn, maybe there is some specailty software but I could not get anything to mesh. This is why we had to use method 2 for more complicated dfns.   Can you mesh your dfn's with a 2D mesh?  If so, you can try method 2 from that webpage using multiapps if the fractures physics is much faster than the matrix (higher porosity, higher thermal conductivity, etc.)",
                  "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1399828",
                  "updatedAt": "2022-06-15T03:02:18Z",
                  "publishedAt": "2021-09-29T03:19:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thank you @lynnmunday, I will go through the paper and get back to you when I understand more n how MOOSE handle fault/fracture",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1400901",
                          "updatedAt": "2022-06-15T03:02:18Z",
                          "publishedAt": "2021-09-29T08:10:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Hi @GiudGiud and @lindsayad\nI almost get the action to work I have a couple of questions here\nFirst question:\nthis is my MPCbe.C file\nthis is the version before adding the for-loop, this is the test version, so I fix the node-pair here.\nregisterMooseAction(\"traiApp\", MPCbe, \"add_constraint\");\n\nInputParameters\nMPCbe::validParams()\n{\n\nInputParameters params = Action::validParams();\n\n  return params;\n}\n\nMPCbe::MPCbe(const InputParameters & params) : Action(params) {}\n\nvoid\nMPCbe::act()\n{\n\n  std::string var_name = \"porepressure\";\n\n  Real weights = 1;\n  int primary = 166;\n  int secondary_node_ids  = 241;\n\n  InputParameters params = _factory.getValidParams(\"LinearNodalConstraint\");\n  params.set<NonlinearVariableName>(\"variable\") = var_name;\n  params.set<Real>(\"weights\") = weights;\n  params.set<Real>(\"primary\") = primary;\n  params.set<Real>(\"secondary_node_ids\") = secondary_node_ids;\n  params.set<Real>(\"penalty\") = 1e10;\n  _problem->addConstraint(\"LinearNodalConstraint\", var_name, params);\n}\n\nI'm not sure why when I call it in my input file, moose doesn't recognise my new action, did I miss anything?\n[MPCbe]\n[]\n\n*** ERROR ***\n/home/moose/projects/trai/hydro_fault.i:307: section 'MPCbe' does not have an associated \"Action\".\nDid you misspell it?\n\nThe second question, says if I feed two vectors into this action (list of primary and secondary nodes)\nhow do I call it one by one in the for-loop? this is more like C++ syntax question\nvoid\nMPCbe::act()\n{\nfor (unsigned int cur_num = 0; cur_num = primary.size ; cur_num++)\n{\n\n  std::string var_name = \"porepressure\";\n\n  Real weights = 1;\n  int primary = primary[cur_num][0];             ****i'd do something like this in python, but not sure how to call it in c++\n  int secondary_node_ids  = secondary_node_ids[cur_num][0];\n\n  InputParameters params = _factory.getValidParams(\"LinearNodalConstraint\");\n  params.set<NonlinearVariableName>(\"variable\") = var_name;\n  params.set<Real>(\"weights\") = weights;\n  params.set<Real>(\"primary\") = primary;\n  params.set<Real>(\"secondary_node_ids\") = secondary_node_ids;\n  params.set<Real>(\"penalty\") = 1e10;\n  _problem->addConstraint(\"LinearNodalConstraint\", var_name, params);\n\n }\n}\n\nThank you guys\nKind regards,\nTraiwit",
                  "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1445960",
                  "updatedAt": "2022-06-15T03:02:20Z",
                  "publishedAt": "2021-10-08T04:35:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nFor the first question\nyou need to register the action in your app\nFor example for AddLotsofDiffusion we have\nbase/MooseTestApp.C:    registerSyntax(\"AddLotsOfDiffusion\", \"Testing/LotsOfDiffusion/*\");\nFor the second question\nprimary and secondary are declared as vectors in MPCbe.h right? And they are one to one (at first, for optimization you may change that later?)\nThen something like that should work\nvoid\nMPCbe::act()\n{\nfor (unsigned int cur_num = 0; cur_num = primary.size ; cur_num++)\n{\n\n  std::string var_name = \"porepressure\";\n\n  std::vector<Real> weights{1};\n  std::vector<unsigned int> primary_node_ids{primary[cur_num]};\n  std::vector<unsigned int> secondary_node_ids = secondary_node_ids[cur_num];\n\n  InputParameters params = _factory.getValidParams(\"LinearNodalConstraint\");\n  params.set<NonlinearVariableName>(\"variable\") = var_name;\n  params.set<std::vector<Real>>(\"weights\") = weights;\n  params.set<std::vector<unsigned int>>(\"primary\") = primary_node_ids;\n  params.set<std::vector<unsigned int>>(\"secondary_node_ids\") = secondary_node_ids;\n  params.set<Real>(\"penalty\") = 1e10;\n  _problem->addConstraint(\"LinearNodalConstraint\", var_name, params);\n\n }\n}\n\nEDIT: A little better vector creation",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1446295",
                          "updatedAt": "2022-06-15T03:02:19Z",
                          "publishedAt": "2021-10-08T06:23:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud\nQ1 is solved.\nfor Q2:\nIt still struggles to run with element accessing from vector,\nso when I remove the element accessing lines below, it works fine, but that will be just a normal LinearNodalConstriants.\n std::vector<Real> weights{0};\n std::vector<unsigned int> primary_node_ids{primary_node_ids[cur_num]};\n std::vector<unsigned int> secondary_node_ids{secondary_node_ids[cur_num]};\n\nNot so sure what went wrong with accessing data from vector and the for-loop\nhere is what the input looks like in .i file\n[MPCbe]\nprimary = '166 166 167'\nsecondary_node_ids = '241 244 242'\nweights = '1 1 1'\n[]\n\nbelow is the full version of .C file just in case you'd like to see\n#include \"MPCbe.h\"\n// #include \"AddConstraintAction.h\"\n#include \"LinearNodalConstraint.h\"\n#include \"MooseMesh.h\"\n#include \"FEProblem.h\"\n\n#include <sstream>\n#include <stdexcept>\n#include \"libmesh/libmesh.h\"\n#include \"libmesh/exodusII_io.h\"\n#include \"libmesh/equation_systems.h\"\n#include \"libmesh/nonlinear_implicit_system.h\"\n#include \"libmesh/explicit_system.h\"\n#include \"libmesh/string_to_enum.h\"\n#include \"libmesh/fe.h\"\n\nregisterMooseAction(\"traiApp\", MPCbe, \"add_constraint\");\n\nInputParameters\nMPCbe::validParams()\n{\n  InputParameters params = Action::validParams();\n  params.addParam<std::vector<unsigned int>>(\"primary\", \"The primary node IDs.\");\n  params.addParam<std::vector<unsigned int>>(\"secondary_node_ids\",\n                                           \"The list of secondary node ids\");\n  params.addParam<std::vector<Real>>(\"weights\",\n                                           \"weights\");\n  return params;\n}\nMPCbe::MPCbe(const InputParameters & params)\n  : Action(params),\nprimary_node_ids(getParam<std::vector<unsigned int>>(\"primary\")),\nsecondary_node_ids(getParam<std::vector<unsigned int>>(\"secondary_node_ids\")),\nweights(getParam<std::vector<Real>>(\"weights\"))\n{\n}\nvoid\nMPCbe::act()\n\n{\nfor (unsigned int cur_num = 0; cur_num = primary_node_ids.size()-1 ; cur_num++)\n{\n\n  std::vector<Real> weights{0};\n  std::vector<unsigned int> primary_node_ids{primary_node_ids[cur_num]};\n  std::vector<unsigned int> secondary_node_ids{secondary_node_ids[cur_num]};\n\n  InputParameters params = _factory.getValidParams(\"LinearNodalConstraint\");\n  params.set<NonlinearVariableName>(\"variable\") = \"porepressure\";\n  params.set<std::vector<Real>>(\"weights\")= weights;\n  params.set<std::vector<unsigned int>>(\"primary\") = primary_node_ids;\n  params.set<std::vector<unsigned int>>(\"secondary_node_ids\") = secondary_node_ids;\n  params.set<Real>(\"penalty\") = 1e10;\n  _problem->addConstraint(\"LinearNodalConstraint\", \"MPCbe\", params);\n\n}\n}\n\nThank you\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1454945",
                          "updatedAt": "2022-06-15T03:02:19Z",
                          "publishedAt": "2021-10-10T12:52:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Do you want the weight to be zero every time? Because that should be what's happening ... you are going to have value initialization of the single element in your local weights variable and value initialization of a Real (aka double) will lead to a 0. Looking at your original input it looks like you want the weight to be 1.\nAlso looking at your example input, it seems like you actually want the secondary_node_ids parameter to be a vector of vectors, e.g. a std::vector<std::vector<unsigned int>>",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1456006",
                          "updatedAt": "2022-06-15T14:41:39Z",
                          "publishedAt": "2021-10-10T19:56:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks @lindsayad\nI want the weight to be 1 for every pair, when I used weight = 0 in the LinearNodalConstraint, I didn't get the result I wanted.\nAnother thing is that I'm still not sure how to deal with the parameter types (please assume my c++ knowledge is 0)\nI see from LinearNodalConstraint.C (below), these are the parameter types that they want, so I copied that\nLinearNodalConstraint::LinearNodalConstraint(const InputParameters & parameters)\n  : NodalConstraint(parameters),\n    _primary_node_ids(getParam<std::vector<unsigned int>>(\"primary\")),\n    _secondary_node_ids(getParam<std::vector<unsigned int>>(\"secondary_node_ids\")),\n    _secondary_node_set_id(getParam<BoundaryName>(\"secondary_node_set\")),\n    _penalty(getParam<Real>(\"penalty\"))\n{\n  _weights = getParam<std::vector<Real>>(\"weights\");\n\nI tried std::vector<std::vector<unsigned int>> but still didn't work, it literally doesn't run, seems like it couldn't access the value inside the vector or something. I believe the problem comes from these 3 lines below\n  std::vector<Real> weights{weights[cur_num]};\n  std::vector<unsigned int> primary_node_ids{primary_node_ids[cur_num]};\n  std::vector<unsigned int> secondary_node_ids{secondary_node_ids[cur_num]};\n\nand this is the error i got\n\nMy ultimate goal is, I input data into my action in vector form, but then let it takes each pair into LinearNodalConstraint at each loop.\nFor example,\n[MPCbe]\nprimary = '166 166 167'\nsecondary_node_ids = '241 244 242'\nweights = '1 1 1'\n[]\n\nloop 1     primary = 166, secondary_node_ids = 241, weights = 1\nloop 2     primary = 166, secondary_node_ids = 244, weights = 1\nloop 3     primary = 167, secondary_node_ids = 242, weights = 1\n\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1456483",
                          "updatedAt": "2022-09-29T19:08:53Z",
                          "publishedAt": "2021-10-11T00:21:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "cant believe this is happening guys @GiudGiud @lindsayad\nall good now, thank you guys!\n\nNow time to test it with 100000 constraints and see if it works",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1456618",
                          "updatedAt": "2022-09-29T19:08:53Z",
                          "publishedAt": "2021-10-11T01:48:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Hi @GiudGiud\nOkay, so I continue to improve this MPC action, now I want it to read list of master and slave nodes from .CSV file.\nI followed an example from VectorPostprocessorComponent.C, now I have the problem where my MPC action doesn't see getVectorPostprocessorValue even I have\n#include \"VectorPostprocessorComponent.h\"\n#include \"VectorPostprocessorInterface.h\"\n\nin both .C and .h files\nI googled and see that we had a similar issue before #9285\nCould you please check if this's the same issue?\nKind regards,\nTraiwit\nInputParameters\nMPCbe::validParams()\n{\n  InputParameters params = Action::validParams();\n\n  params.addParam<std::vector<Real>>(\"weights\",\n                                           \"weights\");\n  params.addRequiredParam<VectorPostprocessorName>(\n        \"vectorpostprocessor\", \"The vectorpostprocessor from which a value is extracted\");\n  return params;\n}\nMPCbe::MPCbe(const InputParameters & params)\n  : Action(params),\n_vpp_name(getParam<VectorPostprocessorName>(\"vectorpostprocessor\")),\nprimary_node_ids(getVectorPostprocessorValue(\"vectorpostprocessor\", \"master\")),\nsecondary_node_ids(getVectorPostprocessorValue(\"vectorpostprocessor\", \"slave\")),\nweights(getParam<std::vector<Real>>(\"weights\"))\n{\n}\nvoid\n\nclass MPCbe : public Action\n{\npublic:\n  static InputParameters validParams();\n\n  MPCbe(const InputParameters & params);\n\n  virtual void act() override;\n\n    // Holds the primary node ids\n  const VectorPostprocessorValue &  primary_node_ids;\n  // Holds the list of secondary node ids\n  const VectorPostprocessorValue &  secondary_node_ids;\n\n  std::vector<Real> weights;\n\n  // const VectorPostprocessorValue & _vpp_values\n  const VectorPostprocessorName _vpp_name;",
                  "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1536021",
                  "updatedAt": "2022-06-15T14:41:39Z",
                  "publishedAt": "2021-10-26T03:45:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It's related. The problem was for boundary conditions, whereas you are creating a new Action. That issue is closed, so in that case the problem was solved.\nFor your problem you want to add the VectorPostprocessorInterface as a base class of your action.",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1536200",
                          "updatedAt": "2022-06-15T14:42:03Z",
                          "publishedAt": "2021-10-26T05:04:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "For your problem you want to add the VectorPostprocessorInterface as a base class of your action.\n\nsorry for a noob question, but is there an example on how to do this? can I add more than 1 class to the .h file?\n#pragma once\n\n#include \"Action.h\"\n#include \"GeneralPostprocessor.h\"\n#include \"GeneralVectorPostprocessor.h\"\n#include \"VectorPostprocessorComponent.h\"\n#include \"VectorPostprocessorInterface.h\"\n\nclass MPCbe : public Action\n{\npublic:\n  static InputParameters validParams();\n\n  MPCbe(const InputParameters & params);\n\n  virtual void act() override;\n\n    // Holds the primary node ids\n  const VectorPostprocessorValue &  primary_node_ids;\n  // Holds the list of secondary node ids\n  const VectorPostprocessorValue &  secondary_node_ids;\n\n  std::vector<Real> weights;\n  const VectorPostprocessorName _vpp_name;\n\n};",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1536213",
                          "updatedAt": "2022-06-15T14:41:58Z",
                          "publishedAt": "2021-10-26T05:08:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "class MPCbe : public Action\n->\nclass MPCbe : public Action, public VectorPostprocessorInterface\nYou can look at userobject/UserObject.h for an example of inheriting interfaces.\nAs Alex pointed out, this isnt done much on Actions. And you ll have to be mindful of when this action is being executed.\nI guess we are drifting more and more to the role of a UserObject rather than an Action now that it has complex inputs",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1536270",
                          "updatedAt": "2022-06-15T14:42:14Z",
                          "publishedAt": "2021-10-26T05:31:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I deleted my post because I wanted to actually get on my computer and check my hunch ... VectorPostprocessorInterface::VectorPostprocessorInterface fills a reference to _vpi_fe_problem but because actions are constructed way before the FEProblemBase is created, this will actually end up being a reference to a nullptr most likely. So you will not be able to inherit from VectorPostprocessorInterface. However, as @GiudGiud is suggesting, if you are careful with your action tasks, you can actually retrieve the vector postprocessor directly from an Actions _problem member during act(). You can see in the code below that the VectorPostprocessorInterface ultimately makes a call to the problem:\nconst VectorPostprocessorValue &\nVectorPostprocessorInterface::getVectorPostprocessorByNameHelper(\n    const VectorPostprocessorName & name,\n    const std::string & vector_name,\n    bool broadcast,\n    std::size_t t_index) const\n{\n  possiblyCheckHasVectorPostprocessorByName(name, vector_name);\n  addVectorPostprocessorDependencyHelper(name);\n\n  const ReporterMode mode = broadcast ? REPORTER_MODE_REPLICATED : REPORTER_MODE_ROOT;\n  return _vpi_feproblem.getReporterData().getReporterValue<VectorPostprocessorValue>(\n      VectorPostprocessorReporterName(name, vector_name), _vpi_moose_object, mode, t_index);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1539101",
                          "updatedAt": "2022-09-29T19:08:43Z",
                          "publishedAt": "2021-10-26T14:32:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thank you @GiudGiud and @lindsayad,\nThis is quite beyond me, I might need some time to digest it, I will get back to you guys when I understand all this stuff better.",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1541775",
                          "updatedAt": "2022-10-14T18:08:34Z",
                          "publishedAt": "2021-10-26T23:08:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not trying to add to the confusion but you dont really need to go through a vector postprocessor to access the CSV reader btw. You can instantiate one in your action. Look at ElementPropertyReadFile which you have used already.",
                          "url": "https://github.com/idaholab/moose/discussions/18930#discussioncomment-1542912",
                          "updatedAt": "2022-10-14T18:08:34Z",
                          "publishedAt": "2021-10-27T05:48:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}