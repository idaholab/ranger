{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMC0yMFQyMToxMjowNS0wNjowMM4AN3-C"
    },
    "edges": [
      {
        "node": {
          "title": "Adjusting Executioner parameters during runtime or setting a Stopping criterion",
          "author": {
            "login": "ttruster"
          },
          "bodyText": "I am just starting into using MOOSE, so I apologize if this is covered in a test input somewhere, but I haven't located one yet. The analysis I am considering is of a multi element/material model, but I'll describe a simple problem by analogy.\nI am desiring to simulation a Maxwell material (spring and dashpot in series) under an applied force that is initially ramped quickly and then helped fixed for an indefinite time (solid mechanics folks: think of a creep experiment). Since the material is nonlinear, I'd like to use the IterationAdaptiveDT TimeStepper for Transient Execution. Thus, the simulation can have a small dt initially, and then adaptively increase once the load is at its hold period. Then, I'd like the simulation to finish/stop once the total elongation/displacement of the material has reached a \"criteria\"; for instance a certain target value. While I could set the end_time to some value that I think the device/material will pass/exceed the criterion, that time will change with different material coefficients and is thus \"hard\" to estimate.\nI am looking for a good example that talks about the Controls systems like TimePeriods or perhaps one that discusses the control_tags input parameter, which could shed light on how to build such a criteria.\nThank you,\nTim",
          "url": "https://github.com/idaholab/moose/discussions/19112",
          "updatedAt": "2022-06-14T16:32:25Z",
          "publishedAt": "2021-10-14T21:27:16Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Tim\nYou can use the steady state detection option, explained here\nhttps://mooseframework.inl.gov/source/executioners/Transient.html. It will terminate the transient in time based on the residual\nFor a custom termination criteria, you can also use a Terminator https://mooseframework.inl.gov/source/userobject/Terminator.html\nYou ll have to use postprocessors to retrieve terms in the criteria you want, then a formula can be parsed by the Terminator in the expression field. I think this will crash the simulation on request though! Might not be the end you want\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19112#discussioncomment-1479587",
                  "updatedAt": "2022-06-14T16:32:36Z",
                  "publishedAt": "2021-10-14T22:02:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "Terminator is the right way to do this.  The default for the Terminator is to stop the solve at the end of the Timestep (faile_mode = HARD) and if you set error_level = INFO it will simply print the message and then the solve will end at the end of the timestep.\nThat error_level really should be the default... but it's not clear to me that it is.\n@andrsd - do you want to weigh in here?",
                          "url": "https://github.com/idaholab/moose/discussions/19112#discussioncomment-1479779",
                          "updatedAt": "2022-07-07T10:18:59Z",
                          "publishedAt": "2021-10-14T23:13:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "Hi Guillaume and Derek:\nI was able to add Terminator to my input file and have the simulation stop using that command with the HARD option. Thanks for the suggestions!\nTim",
                          "url": "https://github.com/idaholab/moose/discussions/19112#discussioncomment-1515525",
                          "updatedAt": "2022-07-07T10:19:00Z",
                          "publishedAt": "2021-10-21T16:32:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrsd"
                          },
                          "bodyText": "@friedmud If you are pinging me about the error_level, you have the wrong guy - that was done by @dschwen in 84d87ee346f.\nOtherwise, Terminator is the way to do this...",
                          "url": "https://github.com/idaholab/moose/discussions/19112#discussioncomment-1523752",
                          "updatedAt": "2022-07-07T10:33:31Z",
                          "publishedAt": "2021-10-22T23:20:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "EBSDMeshGenerator/Reader + Distributed Mesh Workflow",
          "author": {
            "login": "gka80"
          },
          "bodyText": "Hello-\nI'm working on a modification to the EBSDMeshGenerator/Reader workflow to take in data of a different format (e.g. particle geometry developed in a different program). For this application, I have the workflow operating quite nicely. The issue that I'm running into currently is that using a replicated mesh, the memory requirements are intensive. Some notes:\n\n\nThe goal is to run this on a cluster. Each node has access to 28 cores and 100 GB (useable) memory. Simple tests indicate that (100/28) ~3.5 GB/core is \"too low.\" The run shown in the file attachment was terminated at ~10 GB/core which means that I would be using less than 50% of the node core capacity which is too inefficient (as I don't have access to many nodes to begin with and am restricted to 10 hour increments). Tested on a PC with 64 GB memory.\n\n\nThe \"coarse\" (test) mesh is ~500,000 elements (HEX8). Small. I won't be running mesh adaptivity, but I would like to refine this mesh further for the final run.\n\n\nThe number of non-linear variables is ~20. Small but not inconsequential.\n\n\nThe number of variables in the auxiliary system isn't what I would consider \"excessive\" (although the number of DOF seems rather high [possibly due to the tensor mobility]).\n\n\nI've read and understand the mesh splitting documentation (Mesh Splitting) and have successfully used it on a few test problems. However, while I have an idea as to why the current workflow doesn't work as distributed, I'm unable to pinpoint \"what\" in the MOOSE framework needs to be implemented to make it work (I know it has to do with libMesh).\n\n\nbash output attached as an example.\n\n\nEDIT: Also, SMP preconditioning using ASM with \"sub\" preconditioning type ilu with 3 factor levels and an overlap of 1. I've tried other preconditioning options but found this combination to work the best on smaller test problems. Admittedly, this area is a bit new to me (I've read the PETSc documentation but didn't understand everything; have yet to make a second pass). AMG-based methods performed poorly but I've read that that could be because I'm using a split CH formulation (could also be because I'm a beginner).\n\n\nDoes anyone:\n\nHave any recommendations on a \"work around\" to be able to split the problem and run the model as distributed?\nHave any examples (or is willing to point me in the right direction) so that I can modify the EBSDMeshGenerator/Reader workflow so that it can be implemented as distributed?\n\nI know my problem is small, however I'm in personally uncharted territory. Not opposed to learning, just hoping someone can throw me a bone.\nThank you!\n-Garrett",
          "url": "https://github.com/idaholab/moose/discussions/17442",
          "updatedAt": "2022-07-20T06:19:47Z",
          "publishedAt": "2021-03-28T19:48:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "git blame says @dschwen is the expert here",
                  "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-554772",
                  "updatedAt": "2022-07-20T06:20:30Z",
                  "publishedAt": "2021-03-31T21:02:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Ugh, totally missed this thread. I'll take a look tomorrow!",
                          "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-1499747",
                          "updatedAt": "2022-07-20T06:20:30Z",
                          "publishedAt": "2021-10-19T04:00:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Ok, it would be relatively straight forward to create a DistributedEBSDMeshGenerator (which inherits from DistributedRectilinearMeshGenerator rather than GeneratedMeshGenerator). I can do that in the next couple of days.",
                          "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-1503031",
                          "updatedAt": "2022-07-20T06:20:30Z",
                          "publishedAt": "2021-10-19T14:59:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gka80"
                          },
                          "bodyText": "@dschwen Great! Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-1503476",
                          "updatedAt": "2022-07-20T06:20:42Z",
                          "publishedAt": "2021-10-19T16:08:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Check out #19155 I'd welcome any feedback on it.",
                          "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-1504569",
                          "updatedAt": "2022-10-11T19:26:08Z",
                          "publishedAt": "2021-10-19T20:23:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gka80"
                          },
                          "bodyText": "@dschwen Thank you for turning this around so quickly. I'll give this a try by COB Friday (or wait until the potential implementation with sub-mesh generation?) and offer comments (if any).",
                          "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-1509764",
                          "updatedAt": "2022-10-11T19:26:08Z",
                          "publishedAt": "2021-10-20T16:40:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "SubGenerator version is now merged into MOOSE. To take advantage of it just add parallel_type = DISTRIBUTED in the [Mesh] block.",
                          "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-1511782",
                          "updatedAt": "2022-10-11T19:26:08Z",
                          "publishedAt": "2021-10-21T02:31:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gka80"
                          },
                          "bodyText": "@dschwen @GiudGiud\nThank you. It looks like this solution will work great. I'll chime in if I have any other questions.",
                          "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-1522917",
                          "updatedAt": "2022-10-11T19:26:08Z",
                          "publishedAt": "2021-10-22T18:56:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "gka80"
                  },
                  "bodyText": "@dschwen (or anyone), any hints, sample codes, or links/advice on \"where to dig\"? I can provide more information, if necessary.",
                  "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-615031",
                  "updatedAt": "2022-07-20T06:20:43Z",
                  "publishedAt": "2021-04-15T11:53:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hey @gka80 are you still working on this?\nWe can hit up more people if so",
                          "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-1498916",
                          "updatedAt": "2022-07-20T06:20:43Z",
                          "publishedAt": "2021-10-18T22:12:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gka80"
                          },
                          "bodyText": "Hey @GiudGiud,\nI was sidetracked with another project. However, this problem is still near the top of my priority list. I anticipate on getting back to it in the next few weeks.\nIf someone has capacity to look into the issue, that'd be great. I'm still not opposed to coding up a solution myself if someone was able to provide some guidance. Whatever is easiest.",
                          "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-1499631",
                          "updatedAt": "2022-07-20T06:20:47Z",
                          "publishedAt": "2021-10-19T03:11:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@SudiptaBiswas  @jain651 @laagesen  any of you can offer guidance on that one?",
                          "url": "https://github.com/idaholab/moose/discussions/17442#discussioncomment-1499668",
                          "updatedAt": "2022-07-20T06:20:47Z",
                          "publishedAt": "2021-10-19T03:26:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error after updating MOOSE on Windows",
          "author": {
            "login": "tstepan333"
          },
          "bodyText": "Hello,\nI updated MOOSE and then tried to recompile makefile, but I got the error:\nIn file included from /home/tstepan/projects/moose/framework/build/unity_src/auxkernels_Unity.C:50: /home/tstepan/projects/moose/framework/src/auxkernels/SolutionAux.C: In member function 'virtual libMesh::Real SolutionAux::computeValue()': /home/tstepan/projects/moose/framework/src/auxkernels/SolutionAux.C:97:63: error: 'const class libMesh::Elem' has no member named 'vertex_average' 97 |       output = _solution_object.pointValue(_t, _current_elem->vertex_average(), _var_name); |                                                               ^~~~~~~~~~~~~~ In file included from /home/tstepan/projects/moose/framework/build/unity_src/auxkernels_Unity.C:52: /home/tstepan/projects/moose/framework/src/auxkernels/SpatialUserObjectAux.C: In member function 'virtual libMesh::Real SpatialUserObjectAux::computeValue()': /home/tstepan/projects/moose/framework/src/auxkernels/SpatialUserObjectAux.C:41:53: error: 'const class libMesh::Elem' has no member named 'vertex_average' 41 |     return _user_object.spatialValue(_current_elem->vertex_average()); |                                                     ^~~~~~~~~~~~~~ Compiling C++ (in opt mode) /home/tstepan/projects/moose/framework/build/unity_src/fviks_Unity.C... Compiling C++ (in opt mode) /home/tstepan/projects/moose/framework/build/unity_src/fvkernels_Unity.C... Compiling C++ (in opt mode) /home/tstepan/projects/moose/framework/build/unity_src/geomsearch_Unity.C... make: *** [/home/tstepan/projects/moose/framework/build.mk:144: /home/tstepan/projects/moose/framework/build/unity_src/auxkernels_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1 make: *** Waiting for unfinished jobs.... In file included from /home/tstepan/projects/moose/framework/build/unity_src/geomsearch_Unity.C:3: /home/tstepan/projects/moose/framework/src/geomsearch/FindContactPoint.C: In function 'void Moose::findContactPoint(PenetrationInfo&, libMesh::FEBase*, libMesh::FEBase*, libMesh::FEType&, const libMesh::Point&, bool, libMesh::Real, bool&)': /home/tstepan/projects/moose/framework/src/geomsearch/FindContactPoint.C:104:44: error: 'const class libMesh::Elem' has no member named 'vertex_average' 104 |         dim - 1, fe_side_type, side, side->vertex_average(), TOLERANCE, false); |                                            ^~~~~~~~~~~~~~ In file included from /home/tstepan/projects/moose/framework/build/unity_src/fvkernels_Unity.C:3: /home/tstepan/projects/moose/framework/src/fvkernels/FVBodyForce.C: In member function 'virtual ADReal FVBodyForce::computeQpResidual()': /home/tstepan/projects/moose/framework/src/fvkernels/FVBodyForce.C:45:78: error: 'const class libMesh::Elem' has no member named 'vertex_average' 45 |   Real factor = _scale * _postprocessor * _function.value(_t, _current_elem->vertex_average()); |                                                                              ^~~~~~~~~~~~~~ make: *** [/home/tstepan/projects/moose/framework/build.mk:144: /home/tstepan/projects/moose/framework/build/unity_src/geomsearch_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1 make: *** [/home/tstepan/projects/moose/framework/build.mk:144: /home/tstepan/projects/moose/framework/build/unity_src/fvkernels_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1\nTo update your MOOSE repository I used the following commands:\ncd ~/projects/moose\ngit fetch origin\ngit rebase origin/master\nCould you help me?",
          "url": "https://github.com/idaholab/moose/discussions/19162",
          "updatedAt": "2022-11-30T20:49:39Z",
          "publishedAt": "2021-10-20T20:09:42Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou forgot to update libmesh.\nIs this a conda install? If so just run conda update --all\nProbably will be good to make clobberall before running make again too\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19162#discussioncomment-1510786",
                  "updatedAt": "2022-12-10T20:37:58Z",
                  "publishedAt": "2021-10-20T20:35:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tstepan333"
                          },
                          "bodyText": "Thanks, it helped",
                          "url": "https://github.com/idaholab/moose/discussions/19162#discussioncomment-1522783",
                          "updatedAt": "2022-12-10T20:37:58Z",
                          "publishedAt": "2021-10-22T18:26:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to know the current time step in material kernel",
          "author": {
            "login": "alexchen4ai"
          },
          "bodyText": "Hi Moose experts, I am currently doing a time dependent problem and I wish to implement the  backward Euler integration by AD differentiation.Is it possible that we can get the value of the current time step in material subroutine?",
          "url": "https://github.com/idaholab/moose/discussions/19179",
          "updatedAt": "2024-11-18T03:14:59Z",
          "publishedAt": "2021-10-22T08:19:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Yes, you can use _t for time and _t_step for time step.",
                  "url": "https://github.com/idaholab/moose/discussions/19179#discussioncomment-1520728",
                  "updatedAt": "2024-11-18T03:14:59Z",
                  "publishedAt": "2021-10-22T12:35:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you! Could you help explain more? time and time step are from executioner. How can I get the value of _t and _t_step in the material kernel?",
                          "url": "https://github.com/idaholab/moose/discussions/19179#discussioncomment-1522708",
                          "updatedAt": "2024-11-18T03:14:59Z",
                          "publishedAt": "2021-10-22T18:09:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Either in Material or Kernel,  you can directly use _t and _t_step.  They are member variables declared in the base class.",
                          "url": "https://github.com/idaholab/moose/discussions/19179#discussioncomment-1522760",
                          "updatedAt": "2024-11-18T03:14:59Z",
                          "publishedAt": "2021-10-22T18:20:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you! That makes sense!",
                          "url": "https://github.com/idaholab/moose/discussions/19179#discussioncomment-1522766",
                          "updatedAt": "2024-11-18T03:15:04Z",
                          "publishedAt": "2021-10-22T18:21:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "possibility of running Tensor mechanics problem (with plasticity) using Explicit solvers?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi all, I've been trying to make my mine simulation to be able to run on explicit solver (to match with Abaqus).\nI wonder if MOOSE can do what I want.\nSo far what I've found is that the only Explicit solver from 'TimeIntegrator System' that works with my problem is CentralDifference with lumped.\nHowever, it does not go beyond the 'Static Initialization' step > tho I tried to modify the example problem (elastic) and it works fine, not sure if the problem comes from plasticity.\nCould you please have a look at my input file (attached) and please guide me on this problem, I really could not find many examples on Explicit solvers.\nThank you very much.\nTraiwit\nExplicitMOOSE.zip",
          "url": "https://github.com/idaholab/moose/discussions/17678",
          "updatedAt": "2022-06-15T22:24:45Z",
          "publishedAt": "2021-04-26T06:33:10Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "apparently, the current problem is an instability in the smaller elements (in this case the mine's tunnel), where the larger elements (mine stope) look fine.",
                  "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-662214",
                  "updatedAt": "2022-06-15T22:24:45Z",
                  "publishedAt": "2021-04-26T23:59:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Does it run if you remove plasticity? Are you sure your time step size satisfies CFL conditions?",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-663722",
                          "updatedAt": "2022-06-15T22:24:45Z",
                          "publishedAt": "2021-04-27T10:05:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @hugary1995,\nI could run using both elastic and plastic, esp with very small-time step size, however, at some point, the small elements start to explode (like the figure attached above). Also, it takes so much time when the time step size is small, is there anything that works like mass-scaling in MOOSE?\nIt could run fine if I set implicit=false in the InertialForce kernel OR when I set use_constant_mass = true under TimeIntegrator/type = CentralDifference/lumped >> HOWEVER, disp_ for these cases remain 0, which is incorrect.\nis CFL documented in MOOSE? I tried to follow  https://mooseframework.inl.gov/modules/tensor_mechanics/CriticalTimeStepMath.html for time step size.\ntbh I actually don't know what to do, I tried all the explicit solvers, seem like this is my only option.\nThank you,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-663812",
                          "updatedAt": "2022-06-15T22:24:45Z",
                          "publishedAt": "2021-04-27T10:36:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "@bwspenc - could you answer the question about how to do solid mechanics using explicit timestepping, or nominate someone else?  It's been about 5 years since i ran any explicit stuff, and i know MOOSE has moved on since then.",
                  "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-666545",
                  "updatedAt": "2022-06-15T22:24:47Z",
                  "publishedAt": "2021-04-27T21:09:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Prompting @bwspenc",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-690679",
                          "updatedAt": "2022-06-15T22:24:47Z",
                          "publishedAt": "2021-05-03T22:56:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thank you for reminding @WilkAndy, I kinda give up on this idea of explicit, now I want to relax plasticity so the simulation doesn't crash when the initial stress is too high or the softening is too rapid (5e6 to 5e5 from plastic strain 0 to 1%). I probs should make a new forum regarding this.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-690872",
                          "updatedAt": "2022-06-15T22:24:47Z",
                          "publishedAt": "2021-05-04T00:31:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Unfortunately, I'm probably not very helpful here. As you've already seen, there is a basic capability, but it is pretty limited -- doesn't work with contact, and the last I heard, it was really slow. If it's not a really short duration impact event, you will likely have better luck with the implicit solver for the time being. We just haven't had much of a driver for developing this by our current programs.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-696365",
                          "updatedAt": "2022-06-15T22:24:47Z",
                          "publishedAt": "2021-05-05T00:18:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LabrosV"
                          },
                          "bodyText": "I am currently using the implicit solver to run some problems, but I'm interested in using the explicit solver to investigate short duration impact events. How basic/limited is the capability? (i.e. I'm looking for an updated manual, if exists.) Currently, there is no need for contact and it's OK if it's not so fast.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-1515309",
                          "updatedAt": "2022-08-30T17:25:52Z",
                          "publishedAt": "2021-10-21T15:55:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@LabrosV, as @bwspenc said above, we haven't looked at this much by ourselves. I see no obvious issue in using the explicit solver with plasticiticty. We are happy to hear about your experience with it.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-1517627",
                          "updatedAt": "2022-08-30T17:25:51Z",
                          "publishedAt": "2021-10-22T01:47:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LabrosV"
                          },
                          "bodyText": "Thank you @hugary1995. I'll take a look and share with you my experience.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-1517667",
                          "updatedAt": "2022-08-30T17:25:57Z",
                          "publishedAt": "2021-10-22T02:00:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Traiwit\nI attach an example simulation where you can see the settings I use for dynamics simulations:\nCase2ResidualStress4umDynamic.zip\nMy experience is that dynamics simulations in moose work fine without explicit method, just use the PJFNK solver.\nExplicit dynamic simulations are useful for impact or other specialized simulations.\nIf you just want to see the wave dynamics, implicit is fine.\nMy experience is that convergence problem may arise from:\n\n\nNewmark parameters not set to the stable values, see here:\nhttps://mooseframework.inl.gov/modules/tensor_mechanics/Dynamics.html\n\n\nTime step must be set such that it takes about 20 time steps for a wave to cross the smallest element (calculate wave speed analytically). You need to check the same for the load you are applying, if the load is very fast.\n\n\nuse_displaced_mesh = false\nin the kernel leads to more stable simulations, but then it's an approximation\n\n\nCheck that density is set properly\n\n\nThe material model itself is less likely to give problems\nunless you have softening behaviour.\nTrust this helps\nBest Regards,\nNicol\u00f2 Grilli",
                  "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-693419",
                  "updatedAt": "2022-06-15T22:24:48Z",
                  "publishedAt": "2021-05-04T13:53:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks @ngrilli I will give it a go tmr morning\nJust wondering is it possible to use use_displaced_mesh = false with a large strain problem? and where should I activate this option? I see it can be placed at most of the [Materials] block.\nThank you\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-693521",
                          "updatedAt": "2022-06-15T22:24:52Z",
                          "publishedAt": "2021-05-04T14:11:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Currently, you have to use the displaced mesh for finite strain. However, you may be interested in this PR that will allow running without it: #17475\nJust curious -- is the displaced mesh causing you trouble?",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-696369",
                          "updatedAt": "2022-06-15T22:24:52Z",
                          "publishedAt": "2021-05-05T00:20:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@bwspenc I don't think so, I'm just trying all the possible ways to make my simulation works. I am now back to implicit dynamic and trying to work around the plasticity.\nThanks anyway!",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-696374",
                          "updatedAt": "2022-06-15T22:24:52Z",
                          "publishedAt": "2021-05-05T00:24:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "If you're having trouble with plasticity, I would recommend looking at using the automatic differentiation (AD) versions of those models. We know that our Jacobians aren't great with the non-AD versions of the plasticity models, which is surely going to hurt convergence.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-699109",
                          "updatedAt": "2022-08-30T17:26:47Z",
                          "publishedAt": "2021-05-05T14:43:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Eigensolver executioner w/ cantilever proble (tensor_mechanics)?",
          "author": {
            "login": "mangerij"
          },
          "bodyText": "I have been poking around and was wondering if there is an example in the repo for the standard cantilever problem (bending) but solved with the eigenvalue solver.\nTherefore, one would obtain the modes (frequencies and eigenvectors of displacements for disp_x disp_y disp_z).\nthanks",
          "url": "https://github.com/idaholab/moose/discussions/19077",
          "updatedAt": "2022-06-30T13:39:34Z",
          "publishedAt": "2021-10-12T13:13:18Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc @jiangwen84",
                  "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1478178",
                  "updatedAt": "2022-06-30T13:39:34Z",
                  "publishedAt": "2021-10-14T16:28:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "There isn't an example of this.  The eigensolver doesn't work for mechanics.  I think @cbolisetti has looked into this and might have a branch that solves a problem like this.",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1484407",
                          "updatedAt": "2022-06-30T13:39:38Z",
                          "publishedAt": "2021-10-15T18:42:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "Yes, I don't think we cam solve this with the current moose or TM. @sveerara has created the necessary objects for this but it was never merged.  You can find tests in this branch\nhttps://github.com/sveerara/moose/tree/eigen\nYou'll have to compile with slepC to use this though.",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1499785",
                          "updatedAt": "2022-06-30T13:39:38Z",
                          "publishedAt": "2021-10-19T04:13:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "Very cool. I will poke around. Is there any reason why it wasn't merged?",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1501860",
                          "updatedAt": "2022-06-30T13:39:39Z",
                          "publishedAt": "2021-10-19T11:39:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "I am don't know unfortunately. May be @fdkong knows.",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1515595",
                          "updatedAt": "2022-08-31T06:57:33Z",
                          "publishedAt": "2021-10-21T16:44:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "The eigen solver is general, and it will work for general problems.\nBut the issue we have is that physics kernels such as TM can not really form an exact matrix that is required by SLEPc.  Most of eigen sovlers are based on matrix. We have a matrix-free version, but that generate only one eigenvalue",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1516838",
                          "updatedAt": "2022-08-31T06:57:33Z",
                          "publishedAt": "2021-10-21T20:59:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Now that we have AD, shouldn't the matrix be accurate?",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1517600",
                          "updatedAt": "2022-11-17T22:29:02Z",
                          "publishedAt": "2021-10-22T01:40:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Recent MOOSE News",
          "author": {
            "login": "aeslaughter"
          },
          "bodyText": "Sep. 2021\nAug. 2021\nJuly 2021",
          "url": "https://github.com/idaholab/moose/discussions/18859",
          "updatedAt": "2021-10-21T21:54:42Z",
          "publishedAt": "2021-09-20T15:13:46Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Building my own element? (cohesive element)",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nMy team at work wants to investigate how to create our own element (cohesive element) by modifying pre-existing elements in moose.\nThis is for us to work around discontinuity in both tensor-mechanics and hydro problems, as we want our workflow to be as close as possible to what we do with Abaqus. ( I know MOOSE has the cohesive zone and the way to work with flow in fracture)\nI suspect that we have to do that via Libmesh and then import it to MOOSE following this method: https://mooseframework.inl.gov/help/faq/faq_build_libmesh.html\nPlease give us some suggestions on where should we start to look into this.\nThank you very much.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/18978",
          "updatedAt": "2022-07-29T15:50:23Z",
          "publishedAt": "2021-10-01T07:33:10Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Traiwit\nDepends, if you want to do this before the calculation you can use the Moose MeshGenerators to do this.\nhttps://mooseframework.inl.gov/syntax/Mesh/\nIf you want to do this during the calculation you can use the adaptivity system to do this.\nhttps://mooseframework.inl.gov/moose/syntax/Adaptivity/\nI dont think we have this feature currently. Note that libmesh does not support arbitraty polyhedra so you will be restricted to the elements supported by libmesh.\nhttps://libmesh.github.io/doxygen/index.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1427374",
                  "updatedAt": "2022-07-29T15:50:45Z",
                  "publishedAt": "2021-10-04T23:55:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think @Traiwit was asking about building his own element type, and I agree with him that seems to be libMesh-level development.",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1427556",
                          "updatedAt": "2022-07-29T15:50:50Z",
                          "publishedAt": "2021-10-05T01:05:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks guys,\n@hugary1995 so i should work on libmesh and just import it into MOOSE?\nas I can see they don't have a cohesive element, but they have an element creation there\n\nhttps://libmesh.github.io/examples/introduction_ex1.html",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1429751",
                          "updatedAt": "2022-07-29T15:50:50Z",
                          "publishedAt": "2021-10-05T12:00:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'm not a libMesh guy, @roystgnr is the expert. At the libMesh level, don't think of it as a cohesive element in the context of mechanics, it's just a lower dimensional face element connecting two neighboring volume eelements. @roystgnr can point you in the right direction of building such element.",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1430107",
                          "updatedAt": "2022-07-29T15:51:26Z",
                          "publishedAt": "2021-10-05T13:23:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh is a cohesive element a lower dimensional element between two elements or a merged element made of 2 elements? I thought the latter",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1430309",
                          "updatedAt": "2023-04-18T21:26:03Z",
                          "publishedAt": "2021-10-05T14:05:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Yeah, I'm a little confused there too.\nFor the former case: libMesh does support \"multi-manifold\" meshes, so e.g. you can have a sheet of 2D elements cutting through (or on the boundary of) a 3D mesh.  With Lagrange FE, you can connect the 2D elements to the neighboring elements' 3D nodes if you want their values to always match; with any FE you can have separate elements with their own (unique even if physically overlapping) nodes.\nFor the latter case: the only \"macroelement\" in libMesh is the Clough-Tocher triangle, and that had to be hand-coded (C1 continuity between subelements really constrains the function space there).  We don't have anything to let you create a larger element from a selection of smaller elements at runtime ... though I'd really like to add that someday; multiscale FEM is fantastic for complicated domains.",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1432490",
                          "updatedAt": "2023-04-18T21:26:25Z",
                          "publishedAt": "2021-10-05T21:44:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "oh is a cohesive element a lower-dimensional element between two elements or a merged element made of 2 elements? I thought the latter\n\nI thought it's the first case, but not necessary has to be  'lower dimension, but it has ~0 thickness\n\nhttps://abaqus-docs.mit.edu/2017/English/SIMACAEELMRefMap/simaelm-c-cohesiveusage.htm\nI see @arovinelli asked about this back in 2018, but I reckon Andrea has moved on and created his own version of the cohesive surface instead. https://groups.google.com/g/moose-users/c/hQkaOVbrm88\nbut yeah I would like to use the cohesive element in both hydro and mechanic (and maybe HM coupled) problems.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1433287",
                          "updatedAt": "2023-04-18T21:26:27Z",
                          "publishedAt": "2021-10-06T03:40:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "In my opinion, it is not trivial to add a cohesive element in libMesh and make it work seamlessly with MOOSE. That is the reason we originally implemented the DG-like CZM.  To large extend, the DG-like CZM is equivalent to the traditional CZM implementation in Abaqus.\nMaybe you could let us know why you want to implement traditional CZM? Are there any features that might be missing from the DG-like CZM? If so, we can probably add new features. That would be much easier to do than to reinvent the wheel.",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1433333",
                          "updatedAt": "2023-04-18T21:27:08Z",
                          "publishedAt": "2021-10-06T03:58:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "In my opinion, it is not trivial to add a cohesive element in libMesh and make it work seamlessly with MOOSE. That is the reason we originally implemented the DG-like CZM. To large extend, the DG-like CZM is equivalent to the traditional CZM implementation in Abaqus.\nMaybe you could let us know why you want to implement traditional CZM? Are there any features that might be missing from the DG-like CZM? If so, we can probably add new features. That would be much easier to do than to reinvent the wheel.\n\nHi @jiangwen84 sorry for a late reply, I've been discussing with my team about this.\nFirst of all, we are from Abaqus world where they have a cohesive element and this would be easier to implement to our existing complex meshes.\nSo we want to achieve a continuous solution field across several domains (domains are differently meshed, using tets and wedges). So there is no DG- or XFEM-approach needed. That would already be possible, however, due to the complexity of the discretization problem, we can only achieve those wedges to be flat [zero thickness] (the upper and lower triangle of the wedge share the same positions, but still have individual DOFs).\nThe zero thickness element will also make moose run into problems due to the invalid jacobean. See two pics attached to illustrate this.\n\n\nalthough we want to create an element that has zero thickness, we are not interested in modelling a discontinuity. We need to describe the behaviour of some material between adjacent tet-faces. This zone is in reality very thin compared to the surrounding material and the fact that we model it with zero-thickness in more or less a tweak to make it easier possible to introduce this zone at all.\nthe material we need to model needs its own state variable (damage, porosity etc) which means it must be able to be independently responding from the state of the adjacent surface due to its history.\n#################################################################\nwe previously used wedges elements + NodalConstraints to achieve what we want for the hydro problems using MOOSE, but it would be nicer to have a cohesive element especially for mechanical (and HM) simulations\n\n\n\nThe question now would be, we should we look into in order to create a new element (cohesive element), is there any example? Our team previously have implemented FE element in Abaqus, so as long as we know where to start, we should be able to do it (ofc with your support \ud83d\ude03 )\nKind regards,\nTraiwit\n@GiudGiud @roystgnr @hugary1995 @arovinelli",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1474815",
                          "updatedAt": "2023-04-18T21:27:08Z",
                          "publishedAt": "2021-10-14T06:03:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "So the idea here is that you have an infinitely thin element, e.g. a QUAD4 that's got two pairs of overlapping nodes, but you can't simply use an EDGE2 instead because you need 2 independent degrees of freedom for each variable on each node pair, but you also probably can't use a QUAD4 because the most basic FEM calculations are likely to break in a world where deta/dx or deta/dy is infinite?\nI'd start by just positioning nodes to give you an infinitely thin QUAD4 and then see exactly what breaks.  libMesh does allow nodes to overlap, even from the same element, but I'm sure it'll end up screaming at you at some point when we try to do an inverse_map() and discover the map isn't invertible.  On the other hand, if you don't see any screaming (we don't use inverse_map() willy-nilly, since it's expensive, and we do have elements like pyramids that are usable despite not having an invertible map everywhere) then you might be able to do what you want just by creating your own quadrature rule?",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1484857",
                          "updatedAt": "2023-04-18T21:30:04Z",
                          "publishedAt": "2021-10-15T20:27:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@roystgnr there are specific quadrature rules for cohesive elements that allow nodes to be coincident. So what you describe is correct.",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1485628",
                          "updatedAt": "2023-04-18T21:30:11Z",
                          "publishedAt": "2021-10-16T01:10:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@Traiwit  I am not fully convinced that we have to use cohesive element for your problems. DG-interface is discontinuous, but with appropriate constraint, the field is continuous before damage.   You can define any stateful material properties, such as damage, porosity, on the interface which are independent of adjacent  surface. In addition, you can probably solve a lower-dimension problem, e.g. fluid, on the interface.\nIn the meantime, I do not want to discourage you from exploring the cohesive element implementation in MOOSE. As @hugary1995 mentioned, creating element should be done in LibMesh and @roystgnr can provide you more insights. If my understanding is correct, the cohesive element can be standard quad in 2D with zero thickness, but the integration will be only performed in the middle line. Therefore, at minimum, the LibMesh needs to support zero thickness element type and new integration scheme for such element. @roystgnr is this hard to do? Thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1480307",
                  "updatedAt": "2022-07-29T15:51:25Z",
                  "publishedAt": "2021-10-15T03:12:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "BISON \"Vectors are not the same length\" error",
          "author": {
            "login": "kloibz"
          },
          "bodyText": "New BISONer, first time poster:\nI am trying to run a metallic fuel simulation, but I am getting the above error message saying that \"Vectors are not the same length\" and I am unsure how to debug the error. I am recreating a file based off of a template file that has run and I know that my build of BISON is good because I am able to run the assessment files with no issue. So far I have gone line by line through my input file comparing and trying to find differences, but I am still stuck. Any debugging suggestions or useful interpretations from the error code that could point me to problem area?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/19165",
          "updatedAt": "2023-07-27T16:14:34Z",
          "publishedAt": "2021-10-21T00:50:30Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@kloibz Since this is a Bison related question, I suggest you send an email directly to bison-users@inl.gov We will answer your question there. Thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/19165#discussioncomment-1511814",
                  "updatedAt": "2023-07-27T16:14:34Z",
                  "publishedAt": "2021-10-21T02:46:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "kloibz"
                          },
                          "bodyText": "Okay, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/19165#discussioncomment-1515496",
                          "updatedAt": "2023-07-27T16:14:34Z",
                          "publishedAt": "2021-10-21T16:27:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question on computing a material vector",
          "author": {
            "login": "xueyang94"
          },
          "bodyText": "Hello,\nI am writing a material class, which can compute a vector of material properties, but I couldn't get the initialization right. I have tried _mat_name(declareProperty<std::vector<MaterialPropertyName>>(\"mat_names\")), _mat_prop(_some_num),  and then use a for loop to declare for example _mat_prop[i] = &declareProperty<Real>(_mat_name[i]).   The complier error is no matching constructor for initialization of 'std::vector<MaterialPropertyName>'. (The parent class is DerivativeMaterialInterface<Material>.)\nIs it possible at all for a material class to compute a material vector? If so, what would be the proper initialization and declaration syntax? I did not find an example material that does this. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/19152",
          "updatedAt": "2022-08-22T09:04:04Z",
          "publishedAt": "2021-10-19T17:40:33Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "It's possible. Please have a look at the GenericConstantMaterial, which defines a vector of Real material properties.\nhttps://github.com/idaholab/moose/blob/next/framework/src/materials/GenericConstantMaterial.C\nI think for mat_name you want to initialize the vector of names with a getParam<std::vector < MaterialPropertyName > >\nThen in the constructor body you want to make the calls to declare each property.\nI dont think declareProperty can be called with a vector of names like that, but I could be wrong",
                  "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1505116",
                  "updatedAt": "2022-08-22T09:04:05Z",
                  "publishedAt": "2021-10-19T22:40:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you need a material property vector instead of a vector of material properties, see the answer below",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1508482",
                          "updatedAt": "2022-08-22T09:04:09Z",
                          "publishedAt": "2021-10-20T13:37:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "Update:\nSince the vector of materials is computed in the material class, the _prop_values in GenericConstantMaterial cannot be pre-defined in the input file. However, based on the idea of declaring both the prop_name and prop_value, it is fairly easy to output a vector of material properties like this, in case someone needs it:\nparams.addRequiredParam<std::vector<MaterialPropertyName>>(\"some_names\", \"a description\");\nInitializer:\n_some_names(getParam<std::vector<MaterialPropertyName>>(\"some_names\")),\n_some_prop(_num),\nDeclare prop:\nfor (unsigned int i=0; i<_num; ++i)\n_some_prop[i] = &declareProperty<Real>(_some_names[i]);",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1511688",
                          "updatedAt": "2022-08-22T09:04:22Z",
                          "publishedAt": "2021-10-21T02:12:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Agreed, the treatment of values will have to be different. I m pointing to this material for the handling of the vectors.",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1511903",
                          "updatedAt": "2022-08-22T09:04:24Z",
                          "publishedAt": "2021-10-21T03:12:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @xueyang94\nThis is an example from my repository:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainCrystalPlasticityBackstress.C\nFor instance in the constructor, I declare:\n_rho_for(declareProperty<std::vector>(\"rho_for\")),\nThen I provide the dimension of the vector:\n_rho_for[_qp].resize(_nss);\nbefore starting using it.\nThen I initialise:\nfor (unsigned int i = 0; i < _nss; ++i) // initialise forest dislocation densities\n_rho_for[_qp][i] = _init_rho_for;\nTrust this helps,\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1507922",
                  "updatedAt": "2022-08-22T09:04:25Z",
                  "publishedAt": "2021-10-20T11:56:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "Thanks for your reply. In your repo, _rho_for is declared as a vector of 'Real'. However, I want to declare a vector of material properties, which can be output by name and taken by other materials or kernels in the input file. For example, in the input file, I want to have some_mat = \"mat1, mat2, mat3,..\" as one of my material class's parameters. This is similar but not exactly the same as what your code does. I appreciate your advice.\nXueyang",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1509514",
                          "updatedAt": "2022-08-22T09:04:33Z",
                          "publishedAt": "2021-10-20T16:01:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so you want to build a vector material property from a vector of material properties?\nLike mat1, mat2, mat3 are already defined, and you want to access them by just passing some_mat = \"mat1 mat2 mat3\" to a kernel",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1509759",
                          "updatedAt": "2022-08-22T09:04:33Z",
                          "publishedAt": "2021-10-20T16:39:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "@GiudGiud Not really. mat1, mat2, and mat3 are not already known. They should be computed by myMatClass, where they are the elements of a material vector. In the input file that uses myMatClass, it looks like:\n[something]\ntype = myMatClass\nsome_mat = \"mat1, mat2, mat3\"\n....\n[../]\nThis way, mat1, mat2, and mat3 can be used in the kernels. The diffusion kernel can take mat1 as the diffusivity:\n[Diffusion]\ntype = MatDiffusion\nvariable = u\ndiffusivity = mat1\n[../]\nmat2 and mat3 can also be used somewhere else in the kernels.",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1509970",
                          "updatedAt": "2022-08-22T09:04:34Z",
                          "publishedAt": "2021-10-20T17:19:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This feels like my first post is appropriate then.\nGenericConstantMaterial, GenericFunctionMaterial etc all do something like that.\nThe syntax for GenericConstantMaterial would be:\n[material_name]\n  type = GenericConstantMaterial\n  prop_names = \"mat1 mat2 mat3\"\n  prop_values = \"1 2 43\"\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1510006",
                          "updatedAt": "2022-08-22T09:04:39Z",
                          "publishedAt": "2021-10-20T17:28:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "@GiudGiud Yup, I was about the try the method in your post, but then I found another bug in my code. I am working on fixing that first. I will come back to this if I need more help. Thanks Guillaume!",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1510195",
                          "updatedAt": "2022-08-22T09:04:39Z",
                          "publishedAt": "2021-10-20T18:15:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}