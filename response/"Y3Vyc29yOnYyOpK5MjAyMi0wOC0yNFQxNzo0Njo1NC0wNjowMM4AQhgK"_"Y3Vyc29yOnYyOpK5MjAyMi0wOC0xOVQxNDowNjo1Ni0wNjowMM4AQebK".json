{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOC0xOVQxNDowNjo1Ni0wNjowMM4AQebK"
    },
    "edges": [
      {
        "node": {
          "title": "Finite discrete element method in MOOSE",
          "author": {
            "login": "caowen1510957"
          },
          "bodyText": "Hello,\n\n\nIs there a Module for the Finite discrete element method in MOOSE?\nhttps://en.wikipedia.org/wiki/Discrete_element_method\n\n\nFor fracturing modeling, phase-field, and discrete element method, can anyone provide a good Pro and Con for these two methods?\n\n\nOr is there a \"better (advanced)\" method adapted in MOOSE for fracturing induced by dynamic loading?",
          "url": "https://github.com/idaholab/moose/discussions/21898",
          "updatedAt": "2022-09-02T19:55:55Z",
          "publishedAt": "2022-08-19T14:20:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@recuero",
                  "url": "https://github.com/idaholab/moose/discussions/21898#discussioncomment-3432134",
                  "updatedAt": "2022-08-19T14:47:00Z",
                  "publishedAt": "2022-08-19T14:47:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "We do not have DEM implemented in MOOSE.  For fracture modeling,  we have XFEM, PF and Peridynamics.  You should be able to find literatures to discuss their pro and cons in details.",
                  "url": "https://github.com/idaholab/moose/discussions/21898#discussioncomment-3432238",
                  "updatedAt": "2022-08-19T14:58:40Z",
                  "publishedAt": "2022-08-19T14:58:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "caowen1510957"
                          },
                          "bodyText": "We do not have DEM implemented in MOOSE. For fracture modeling, we have XFEM, PF and Peridynamics. You should be able to find literatures to discuss their pro and cons in details.\n\nThanks, the following question, for the boundary, is there an option to add an absorbing boundary?",
                          "url": "https://github.com/idaholab/moose/discussions/21898#discussioncomment-3432454",
                          "updatedAt": "2022-08-19T15:24:53Z",
                          "publishedAt": "2022-08-19T15:24:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "We do not have DEM implemented in MOOSE. For fracture modeling, we have XFEM, PF and Peridynamics. You should be able to find literatures to discuss their pro and cons in details.\n\nThanks, the following question, for the boundary, is there an option to add an absorbing boundary?\n\nThere is a way to apply simple absorbing boundary conditions, check this  #20850. Also, a Robin-kind boundary conditions is available for electromagnetics, but I think - I have not tried it though- it may be easily extended to elastodynamics, check this https://mooseframework.inl.gov/moose/source/bcs/EMRobinBC.html and https://mooseframework.inl.gov/moose/source/bcs/VectorTransientAbsorbingBC.html.",
                          "url": "https://github.com/idaholab/moose/discussions/21898#discussioncomment-3465273",
                          "updatedAt": "2022-08-24T12:22:46Z",
                          "publishedAt": "2022-08-24T12:22:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "gap boundary sequence influenced GapHeatTransfer result",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "Hi,\nI am doing a 2d steady thermal diffusion simulation with gap radiation on a two separated quarter annuluses. I found that the sequence I specify the primary and secondary boundary has an influence on the resulting temperature field. gap_surface_0 as primary the simulation did not converge. Specifying two GapHeatTransfer for 0-1 and 1-0  respectively resulted in low temperature at the corners as shown in the figure. However, if I only specify 1 as primary and 0 as secondary (which matches the direction of heat flux across the gap), no corner temperature issue.\nFrom my shallow understanding of the code, this object is written to consider heat transfer from both sides. So something was not right about my implementation. Please help me on it.",
          "url": "https://github.com/idaholab/moose/discussions/21759",
          "updatedAt": "2022-09-02T19:56:24Z",
          "publishedAt": "2022-08-02T21:25:52Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "BoZeng1997"
                  },
                  "bodyText": "[GlobalParams]\n  temperature = T\n[]\n\n[Mesh]\n  [ori]\n    type = FileMeshGenerator\n    file = 'radiation_2d.msh'\n  []\n  [drl]\n    type = BlockDeletionGenerator\n    input = ori\n    block = 'void_center void_pellet'\n  []\n[]\n\n[Variables]\n  [T]\n    [InitialCondition]\n      type = ConstantIC\n      value = 23.0\n    []\n  []\n[]\n\n[Kernels]\n  [diff]\n    type = ADHeatConduction #ADHeatConduction\n    variable = 'T'\n    thermal_conductivity = thermal_conductivity\n    block = 'pellet_inner pellet_outer'\n  []\n[]\n\n[BCs]\n  [outer_temperature]\n    type = ADDirichletBC\n    variable = T\n    boundary = void_nb_0\n    value = 1304.2 # (C)\n  []\n  [inner_temperature]\n    type = ADDirichletBC\n    variable = T\n    boundary = void_center\n    value = 1001.2 # (C)\n  []\n[]\n\n[ThermalContact]\n  # [gap_pellet_01]\n  #   type = GapHeatTransfer\n  #   variable = T\n  #   primary = void_pellet_0\n  #   secondary = void_pellet_1\n  #   emissivity_primary = 0.37\n  #   emissivity_secondary = 0.37\n  #   gap_conductivity = 0.151e-3\n  #   gap_geometry_type = CYLINDER\n  #   cylinder_axis_point_1 = '0 0 0'\n  #   cylinder_axis_point_2 = '0 0 1'\n  # []\n  [gap_pellet_10]\n    type = GapHeatTransfer\n    variable = T\n    primary = void_pellet_1\n    secondary = void_pellet_0\n    emissivity_primary = 0.37\n    emissivity_secondary = 0.37\n    gap_conductivity = 0.151e-3\n    gap_geometry_type = CYLINDER\n    cylinder_axis_point_1 = '0 0 0'\n    cylinder_axis_point_2 = '0 0 1'\n  []\n[]\n\n\n[Materials]\n  [pellet_thermal_conductivity]\n    type = ADParsedMaterial\n    args = 'T'\n    f_name = 'thermal_conductivity'\n    function = '250.6e-2' #HELP CONVERGE\n    block = 'pellet_inner pellet_outer'\n  []\n[]\n\n[Postprocessors]\n  [void_1_temp]\n    type = SideAverageValue\n    variable = T\n    boundary = void_pellet_1\n  []\n  [void_0_temp]\n    type = SideAverageValue\n    variable = T\n    boundary = void_pellet_0\n  []\n  [void_1_flux]\n    type = ADSideDiffusiveFluxIntegral\n    variable = T\n    boundary = void_pellet_1\n    diffusivity = thermal_conductivity\n  []\n  [void_0_flux]\n    type = ADSideDiffusiveFluxIntegral\n    variable = T\n    boundary = void_pellet_0\n    diffusivity = thermal_conductivity\n  []\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n  automatic_scaling = true\n\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-8\n[]\n\n[Outputs]\n  [exodus]\n    type = Exodus\n    file_base = 2pellet_gap_10_noTdt_cylinder\n  []\n  print_linear_residuals = false\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3311425",
                  "updatedAt": "2022-08-02T21:30:35Z",
                  "publishedAt": "2022-08-02T21:30:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@jasondhales do you have any suggestions for this question?",
                          "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3380496",
                          "updatedAt": "2022-08-12T02:28:07Z",
                          "publishedAt": "2022-08-12T02:28:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jasondhales"
                          },
                          "bodyText": "Without quadrature = true, this will be a one way (secondary to primary, if I recall correctly) contact constraint.  With quadrature = true, the primary and secondary surfaces are used twice, swapped the second time.  This is what we recommend.\nThat being said, the mortar approach is better.",
                          "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3423571",
                          "updatedAt": "2022-08-18T14:36:03Z",
                          "publishedAt": "2022-08-18T14:36:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "By mortar approach, do you mean ModularGapConductanceConstraint together with GapFluxModelRadiation as mentioned in page\nhttps://mooseframework.inl.gov/source/constraints/ModularGapConductanceConstraint.html\nand example input deck\nhttps://github.com/idaholab/moose/blob/b3df9cac31d90926bc845ad48628b9b8e0bbb115/modules/heat_conduction/test/tests/gap_heat_transfer_mortar/large_gap_heat_transfer_test_cylinder_mortar.i\n?",
                          "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3462939",
                          "updatedAt": "2022-08-24T07:21:15Z",
                          "publishedAt": "2022-08-24T07:21:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "yes ModularGapConductanceConstraint used with various options for gap flux models (including the radiation one you mentioned) are MOOSE's thermal mortar contact objects",
                          "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3465179",
                          "updatedAt": "2022-08-24T12:09:21Z",
                          "publishedAt": "2022-08-24T12:09:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "BoZeng1997"
                  },
                  "bodyText": "Hi @jasondhales ,\nI have another question about simulation gap radiation heat transfer in MOOSE. Does GapHeatTransfer or the mortar approach work well for gaps with changing distance? Like the gaps on both sides of the green region in the image. Is this shape fine with the code or the theory of gap radiation?",
                  "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3463027",
                  "updatedAt": "2022-08-24T07:31:27Z",
                  "publishedAt": "2022-08-24T07:31:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "thermal contact is generally used in conjunction with mechanics modeling and mesh deformation, so the answer is that MOOSE's thermal models should work fine with changing gaps",
                          "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3465167",
                          "updatedAt": "2022-08-24T12:08:05Z",
                          "publishedAt": "2022-08-24T12:08:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Negative Jacobian From inverted Elements",
          "author": {
            "login": "kevin-wandke"
          },
          "bodyText": "I am running a simulation of a pneumatically driven soft actuator using Moose's Tensor Mechanics and contact Modules. Despite my best efforts my simulation continually fails to converge and I routinely get \"negative Jacobian\" error from libmesh.\nA quick search of previous forum posts would indicate that this type of error occurs when an element becomes inverted.\nI have attempted using a shorter timestep, as well as using hex8 elements instead of tet4 ones. Additionally, if I view the element in question, it does not appear to deform much at all over the course of the simulation. However, the element does undergo large translations and rotations. Could this be causing the difficulties, or is it possible that the solver is making a bad iteration that is inverting an element temporarily?\nPlease let me know if there is any other information I can provide that could be helpful in solving this issue!\nI have included the error message I have received below\n\nLocation of failed element 554 within mesh\n\nElement 554 on timestep 0 (right) and timestep 40 (left). It appears that while the element was rotated and translated, there was very little actual deformation.\n\nSome parts of my input file that may be helpful in diagnosing the issue:\n[Functions]\n  [rampLinear]\n    type = ParsedFunction\n    value=1e5*t\n []\n[]\n[BCs]\n     [Pressure]\n        [stress]\n        boundary = 'Inner_cavity'\n        function=rampLinear\n        use_automatic_differentiation = true\n        use_displaced_mesh = true\n        hht_alpha=-.25\n        []\n    []\n[]\n[Contact]\n  [b1]\n    primary = 'Body1 Body2 Body3 Body4 Body5 Body6 Body7 Body8'\n    secondary = 'Body1C Body2C Body3C Body4C Body5C Body6C Body7C Body8C'\n    model = frictionless\n    penalty = 0.1e5\n    formulation=penalty\n    normalize_penalty=True\n    normal_smoothing_distance = 0.1\n    newmark_beta = 0.4\n    newmark_gamma = 0.75\n    []\n   [superglue1]\n    primary = 'SG1 SG2 SG3 SG4'\n    secondary = 'SG1C SG2C SG3C  SG4C'\n    model = glued\n    penalty = 8e5\n    formulation=penalty\n    normalize_penalty=True\n    normal_smoothing_distance = 0.1\n    newmark_beta = 0.4\n    newmark_gamma = 0.75\n    []\n[]\n[Materials]\n  [strain]\n    type=ADComputeFiniteStrain\n    decomposition_method=EigenSolution  \n   []\n  [elasticity_tensor]\n    type = ADComputeElasticityTensor\n    C_ijkl = '1.684e5 0.176e5 0.176e5 1.684e5 0.176e5 1.684e5 0.754e5 0.754e5 0.754e5'\n    fill_method = symmetric9\n  []\n  [elasitc_stress]\n    type = ADComputeFiniteStrainElasticStress\n    mu=1e1\n    kappa=1e7\n  []\n    [density1]\n    type = GenericConstantMaterial\n    prop_names = density\n    prop_values = 1000e-9\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type=PJFNK\n  nl_rel_tol = 1e-4\n  nl_abs_tol =5e-4\n  l_max_its = 5\n  l_tol = 1e-7\n  nl_max_its = 20\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart'\n  petsc_options_value = 'asm lu 20 151\n  line_search='none'\n  nl_forced_its=2\n  automatic_scaling=true\n  compute_scaling_once=false\n  start_time=0.0\n  end_time=1\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    growth_factor=1.41\n    optimal_iterations = 8\n    dt = .001\n  []\n  [TimeIntegrator]\n  \ttype=ImplicitEuler\n  []\n  dtmin=.001\n[]",
          "url": "https://github.com/idaholab/moose/discussions/21890",
          "updatedAt": "2022-09-02T19:56:31Z",
          "publishedAt": "2022-08-18T21:47:48Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "For starters, I have two suggestions:\n\nMake sure that there aren't any rigid body modes.\nTry adding a damper, e.g. https://mooseframework.inl.gov/source/dampers/ElementJacobianDamper.html\n\nRegarding the visualization you showed for the inverted element: an inverted element typically happens between nonlinear iterations, after the solution is updated by Newton/PJFNK, and that is not the final converged solution that is being output at TIMESTEP_END. If you really want to visualize the inverted element, you could try to output the exodus file at NONLINEAR.",
                  "url": "https://github.com/idaholab/moose/discussions/21890#discussioncomment-3427924",
                  "updatedAt": "2022-08-19T02:31:02Z",
                  "publishedAt": "2022-08-19T02:31:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "For the visualization, I think in the Outputs block additional_execute_on = FAILED will output the final Exodus file with the inverted element without having to write every NONLINEAR iteration.",
                          "url": "https://github.com/idaholab/moose/discussions/21890#discussioncomment-3430835",
                          "updatedAt": "2022-08-19T11:50:03Z",
                          "publishedAt": "2022-08-19T11:50:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you check the coordinates of that element? It definitely doesnt look deformed in the picture. Is it involved in contact?",
                          "url": "https://github.com/idaholab/moose/discussions/21890#discussioncomment-3432241",
                          "updatedAt": "2022-08-19T14:58:47Z",
                          "publishedAt": "2022-08-19T14:58:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "kevin-wandke"
                          },
                          "bodyText": "My apologies for the late response.\nI am confident that there are not any rigid body modes as if that is the case I usually see solves fail in the first timestep or two, as opposed to later in the simulation. Furthermore, I did check and there are DirichletBC's constraining the motion in the X, Y and Z directions.\nRegarding the coordinates of the deformed element, I used the thresholding operation in paraview in order to identify the proper element ID , so I am confident that the proper element is displayed.\nIn addition to implementing a damper, are there any other solver parameters that might prevent this type of error?",
                          "url": "https://github.com/idaholab/moose/discussions/21890#discussioncomment-3458867",
                          "updatedAt": "2022-08-23T17:27:16Z",
                          "publishedAt": "2022-08-23T17:27:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Small time steps are usually how we deal with this.\nThe element IDs are offset by one in Paraview (starts at 1 we start at 0) so maybe the element was not the right one?",
                          "url": "https://github.com/idaholab/moose/discussions/21890#discussioncomment-3458924",
                          "updatedAt": "2022-08-23T17:35:53Z",
                          "publishedAt": "2022-08-23T17:35:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Domain decomposition method",
          "author": {
            "login": "liangLL888"
          },
          "bodyText": "How to use non overlapping domain decomposition method to solve problems in MOOSE? Are there any examples?",
          "url": "https://github.com/idaholab/moose/discussions/21896",
          "updatedAt": "2022-09-02T19:56:51Z",
          "publishedAt": "2022-08-19T05:10:29Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nMost domain decomposition in MOOSE is non-overlapping. Overlapping is done as necessary (ghosting) when information is needed from neighbor domains.\nAny example or simulation in MOOSE may be run in parallel by running:\nmpirun -n <number of parallel processes> <application_executable> -i <input_file.i>\nI could not locate the mpi tutorial. You may find one online though\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21896#discussioncomment-3432288",
                  "updatedAt": "2022-08-19T15:05:48Z",
                  "publishedAt": "2022-08-19T15:05:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "The default preconditioning type used by PETSc and MOOSE when you run in parallel is bjacobi which is not overlapping. If you wanted a domain decomposition preconditioning type with overlap then you would use -pc_type asm and then you can specify different amounts of overlap with \u2018-pc_asm_overlap\u2018. The default value for that option is 1. A value of 0 would be equivalent to bjacobi (block Jacobi).",
                  "url": "https://github.com/idaholab/moose/discussions/21896#discussioncomment-3455818",
                  "updatedAt": "2022-08-23T11:43:27Z",
                  "publishedAt": "2022-08-23T11:42:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "kernel help",
          "author": {
            "login": "Gallasd"
          },
          "bodyText": "Hello, I want to carry out thermal topology optimization research based on moose. The optimized design variable is the thermal conductivity of each element.\nSince my c++ level is very poor, I would like to ask if it is possible to give the thermal conductivity in the form of a vector in the .i file without modifying the source code. For example, a model with N elements is given a thermal conductivity vector of N \u00d7 1.",
          "url": "https://github.com/idaholab/moose/discussions/21913",
          "updatedAt": "2022-09-02T19:49:42Z",
          "publishedAt": "2022-08-22T14:02:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Yeah, you can use https://mooseframework.inl.gov/source/functions/PiecewiseConstantFromCSV.html together with https://mooseframework.inl.gov/source/userobject/PropertyReadFile.html",
                  "url": "https://github.com/idaholab/moose/discussions/21913#discussioncomment-3451558",
                  "updatedAt": "2022-08-22T22:54:08Z",
                  "publishedAt": "2022-08-22T22:54:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Crystal Plasticity with Grain Tracker",
          "author": {
            "login": "FHilty"
          },
          "bodyText": "Me and @jbair34 would like to combine crystal plasticity with the grain trackers capabilities for discrete nucleation. However, we are stuck as the ComputeElasticityTensorCP material is needed to create the necessary material properties for the crystal plasticity kernels, but there isn't a \"grain_tracker\" parameter for this material as there is with other ComputeElasticityTensor options.  As a result the crystal plasticity kernels isn't interacting with the grain structure from grain tracker. Is there currently a way to make this work?",
          "url": "https://github.com/idaholab/moose/discussions/21484",
          "updatedAt": "2022-08-22T21:56:30Z",
          "publishedAt": "2022-07-01T18:56:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@permcody @dschwen who else may I tag on grain tracking",
                  "url": "https://github.com/idaholab/moose/discussions/21484#discussioncomment-3104746",
                  "updatedAt": "2022-07-08T04:07:02Z",
                  "publishedAt": "2022-07-08T04:07:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "FHilty"
                          },
                          "bodyText": "Just poking this thread to see if there are any updates.",
                          "url": "https://github.com/idaholab/moose/discussions/21484#discussioncomment-3150108",
                          "updatedAt": "2022-07-14T20:19:42Z",
                          "publishedAt": "2022-07-14T20:19:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "The GrainTracker can certainly be added to that material. I don\u2019t have any resources that can work on this but we can advise somebody who would be willing to do the work.",
                          "url": "https://github.com/idaholab/moose/discussions/21484#discussioncomment-3151259",
                          "updatedAt": "2022-07-15T01:08:26Z",
                          "publishedAt": "2022-07-15T01:08:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FHilty"
                          },
                          "bodyText": "Hi Cody, thank you for the information. In a few week I will have the time to work on the changes, I will touch base again when I can get started. Thanks again.",
                          "url": "https://github.com/idaholab/moose/discussions/21484#discussioncomment-3158831",
                          "updatedAt": "2022-07-15T18:25:22Z",
                          "publishedAt": "2022-07-15T18:25:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FHilty"
                          },
                          "bodyText": "My schedule cleared up to where i can work on this and have been reading through the crystal plasticity and grain tracker files.\nThere are three material objects used ComputeElasticityTensorCP, ComputeMultipleCrystalPlasticityStress, and (in our case) CrystalPlasticityKalidindiUpdate. I don't believe the latter two will need modification, however they do utilize the material property crysrot that is provided from ComputeElasticityTensorCP so that is the first object that I will need to modify. From looking at the material ComputePolycrystalElasticityTensor I have a fair idea of how to give a material access to the grain tracker and retrieve the correct grain ID at an element.\nMy first question is what does the command _grain_tracker.getData(grain_id) actually return? That exact command seems to be used to retrieve both the Euler angles and elasticity tensor in different places. I think modifying ComputeElasticityTensorCP to (optionally) utilize the grain tracker will be straight forward once I understand how to get those specific pieces of information. This update would mean that the correct crysrot material property is provided to the other material objects.\nMy second question is much more open ended, what other objects would need modification to couple crystal plasticity with the grain tracker? I have not seen any other places in the kernel/material objects I need which require access grain trackers information.\n\nReduced version of the input script (extension changed from .i to .txt):\nGT_DN_XP_Simple.txt\nEBSD data for structure (extension changed from .ebsd to .txt):\nMCPC_20Grain_ebsd.txt\nEuler angle file that has correct inital 20 grain orientations and random angles for nucleated grains:\nMCPC_Random_Euler_1000.txt\nSlip system text file:\ninput_slip_sys.txt",
                          "url": "https://github.com/idaholab/moose/discussions/21484#discussioncomment-3319198",
                          "updatedAt": "2022-08-03T19:01:11Z",
                          "publishedAt": "2022-08-03T19:01:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "First Answer: .getData(grain_id) is a templated interface function. It can return just about anything we define. It's setup to return various attributes for a given grain (things like Euler Angles, volumes, proximity to the boundary, etc). To see what methods are available you'll need to dig through the functor interface classes in the PhaseField module. I'm most familiar with EBSDAccessorFunctors, but as you've seen there are others. Just look at what interfaces the class you are interested in inherits from and look at the associated methods in those classes.\nSecond Answer: The whole point of the GrainTracker is to maintain a stable ID with a reduced number of order parameters so you'll likely need several attributes of each Grain to perform your calculations and this is where the GrainTracker can help you. I'm fairly certain that we are pulling unique grain information in the material system already, which feeds into the residual calculations for some of these models.",
                  "url": "https://github.com/idaholab/moose/discussions/21484#discussioncomment-3353179",
                  "updatedAt": "2022-08-08T21:56:31Z",
                  "publishedAt": "2022-08-08T21:56:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "FHilty"
                          },
                          "bodyText": "Thank you for the assistance and sorry for the long silence, I had not heard of functors before so it was a learning experience. Once I started to understand what exactly was happening in other MOOSE objects I found that the solution was much simpler than I thought.\nFor anyone finding this thread the solution I settled on was to start with the ComputeElasticityTensorCP material and replaced the body of assignEulerAngles() with 2 steps. First retrieve the grain ID from grain tracker, then look up the Euler angles directly from the file using the Euler angle provider. As it turns out, this is exactly what OutputEulerAngles does in the precalculateValue() function. I performed a few tests and, so far as I can tell, the rest of the crystal plasticity framework is working correctly, it just hinged on getting the correct Euler angles. Now when the grain tracker inserts a new grain nucleus with discrete nucleation it is reflected in the stress/strain fields from the crystal plasticity modules.",
                          "url": "https://github.com/idaholab/moose/discussions/21484#discussioncomment-3449449",
                          "updatedAt": "2022-08-22T16:42:52Z",
                          "publishedAt": "2022-08-22T16:42:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Grea, glad you are working! The Euler Angle provider caches values so it doesn't have to do a file lookup each time you call it. There is a lot of nifty, but complex machinery making all this work. Let us know if you need any further assistance.",
                          "url": "https://github.com/idaholab/moose/discussions/21484#discussioncomment-3451332",
                          "updatedAt": "2022-08-22T21:56:19Z",
                          "publishedAt": "2022-08-22T21:56:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "dynamic tensor mechanics axisymmetric RZ",
          "author": {
            "login": "Alirezarei"
          },
          "bodyText": "Hello,\nI have been trying to use the Dynamic Tensor Mechanics action to solve an axisymmetric RZ problem, but I always get an error saying the coordinate system is not supported. I have tried the following approaches to solve the issue, but nothing has worked so far.\n\nI made two ADDynamicStressDivergenceTensors in different directions, but I get an error saying: \"The coordinate system in the problem block must be set to XYZ for cartesian geometries\"\nI used Tensor mechanics master action and added two ADInertialForce kernels in different directions but the solve does not converge in this case!\nI used the Dynamic Master action without specifying the coord_type and set the cylindrical_axis_point1 and cylindrical_axis_point2 to proper vectors but it still solves in cartesian coordinate system!\n\nCould you help me with this please?\nI appreciate your time.\nRegards,\nAlireza",
          "url": "https://github.com/idaholab/moose/discussions/21893",
          "updatedAt": "2022-08-20T04:21:42Z",
          "publishedAt": "2022-08-19T00:13:06Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You are probably missing the following block in the input file\n[Mesh]\n  coord_type = RZ\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/21893#discussioncomment-3427886",
                  "updatedAt": "2022-08-19T02:20:53Z",
                  "publishedAt": "2022-08-19T02:20:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Alirezarei"
                          },
                          "bodyText": "Thanks for your reply. When I add coord_type = RZ and I'm using dynamic master action, it throws an error saying: \"unsupported coordinate system\". The problem is that Dynamic Master action seems not to support axisymmetric RZ problems or I'm missing something!",
                          "url": "https://github.com/idaholab/moose/discussions/21893#discussioncomment-3428217",
                          "updatedAt": "2022-08-19T04:04:32Z",
                          "publishedAt": "2022-08-19T04:04:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Yeah, we don't have RZ in dynamics. I recommend you use the following input: https://github.com/idaholab/moose/blob/436a787585e17c3901eb7de29dbd43a80d9a881a/modules/tensor_mechanics/test/tests/dynamics/rayleigh_damping/rayleigh_hht.i where inertia is already included in the latest action.\nYou mention the parameters cylindrical_axis_point1 and cylindrical_axis_point2: Aren't those gap heat transfer parameters? In any case, if you want to use dynamics, unfortunately for now, you'll have to stick to Cartesian systems.",
                          "url": "https://github.com/idaholab/moose/discussions/21893#discussioncomment-3434989",
                          "updatedAt": "2022-08-19T22:20:33Z",
                          "publishedAt": "2022-08-19T22:20:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Alirezarei"
                          },
                          "bodyText": "I see. Thanks for your help.\nI really need to perform a dynamic analysis in RZ coordinate system. Are you planning to add this feature to Tensor Mechanics Dynamic Master action any time soon? If not, how can I do it myself?\nAlso, I'm using Tensor Mechanics Master action that supports RZ coordinate system but the linear solver does not converge due to DIVERGED_PC_FAILED; PC failed due to FACTOR_NUMERIC_ZEROPIVOT. The same input works for XYZ coordinate system. Is there any way that I can solve this issue?",
                          "url": "https://github.com/idaholab/moose/discussions/21893#discussioncomment-3435068",
                          "updatedAt": "2022-08-19T22:45:17Z",
                          "publishedAt": "2022-08-19T22:45:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "Are you planning to add this feature to Tensor Mechanics Dynamic Master action any time soon? If not, how can I do it myself?\n\nI don't believe we can work on that soon. If you are interested in looking at it, I'd review DynamicStressDivergenceTensors which does the Cartesian definition of stresses within a dynamic integrator and then also at StressDivergenceRZTensors which does the axisymmetric work for quasi-statics. To successfully implement the RZ problem in dynamics you'd need to derive the expressions including _alpha, _dt, and _zeta.\n\nI'm using Tensor Mechanics Master action that supports RZ coordinate system but the linear solver does not converge due to DIVERGED_PC_FAILED; PC failed due to FACTOR_NUMERIC_ZEROPIVOT\n\nIt's hard to know what's going on there. I recommend you look at quasistatic RZ problems in the repository and see if you are missing something. Wonder if your BCs are correct since you mentioned you used the same input for XYZ.",
                  "url": "https://github.com/idaholab/moose/discussions/21893#discussioncomment-3435143",
                  "updatedAt": "2022-08-19T23:12:10Z",
                  "publishedAt": "2022-08-19T23:12:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Alirezarei"
                          },
                          "bodyText": "Thank you very much for your prompt responses. I really appreciate it. I will check them out and see if I can do it myself.",
                          "url": "https://github.com/idaholab/moose/discussions/21893#discussioncomment-3435767",
                          "updatedAt": "2022-08-20T04:20:17Z",
                          "publishedAt": "2022-08-20T04:20:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The results of parallel and serial calculations in MOOSE are different in the thermo-mechanical coupling calculation",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, everyone.\nI want to do some thermomechanical coupling problems with MOOSE. and I want to set the model to have no displacement in the Z direction, so I set the boundary condition of displacements like this\uff1a\n  [./top_and_bottom]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'outer_bottom outer_top inner_bottom inner_top'\n    value = 0\n  [../]\n\nThere are two problems. The first one is that when I calculate with different numbers of cores, I get different results. For example, when I use one core, 4 cores and 8 cores for calculation, the results obtained are very different. It seems that the serial computation results is reasonable. The second one is that the distributions of disp_x and disp_y are not symmetrical to the x and y axes. But they are supposed to be symmetrical. If I want to make disp_x and disp_y symmetrical, should I set some boundary conditions for them?\nThe calculation results of using 1 core, 4 cores, and 8 cores are as follows:\n\n\n\nThere are output files and mesh file.\nattached files.zip\nThere is complete input file:\nini_temp = 593 # K\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh]\n  file = '2layers_3d_4parts.msh'\n[]\n\n[Variables]\n  [./T]\n    initial_condition = ${ini_temp}\n  [../]\n[]\n\n[AuxVariables]\n  [./heat]\n    family = MONOMIAL\n    order = FIRST\n    block = 'inner'\n  [../]\n[]\n\n[Kernels]\n  [./outer_inner_temperature_time]\n    type = ADHeatConductionTimeDerivative\n    variable = T\n    block = 'outer inner'\n    density_name = 'rho'\n    specific_heat = 'cp'\n  [../]\n  [./outer_inner_temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    block = 'outer inner'\n    thermal_conductivity = 'k'\n  [../]\n  [./heat_source]\n    type = HeatSource\n    variable = T\n    block = 'inner'\n    value = 1e5\n  [../]\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = FINITE\n    automatic_eigenstrain_names = true\n    generate_output = 'vonmises_stress'\n    block = 'outer inner'\n  []\n[]\n\n[Materials]\n  [elasticity]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 2e11\n    poissons_ratio = 0.32\n    block = 'outer inner'\n  []\n  [thermal_expansion]\n    type = ComputeThermalExpansionEigenstrain\n    temperature = T\n    thermal_expansion_coeff = 1.0358e-5\n    stress_free_temperature = 273\n    eigenstrain_name = thermal_expansion\n    block = 'outer inner'\n  []\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n    block = 'outer inner'\n  []\n\n  [./rho_inner]\n    type = ADParsedMaterial\n    f_name = rho\n    function = '0.0110876 * pow(9.9672e-1 + 1.179e-5 * T - 2.429e-9 * pow(T,2) + 1.219e-12 * pow(T,3),-3)'\n    args = 'T'\n    block = 'inner'\n  [../]\n  [./cp_inner]\n    type = ADParsedMaterial\n    f_name = cp\n    function = '0.76 * ((302.27 * pow((548.68/T),2) * exp(548.68 / T)) / pow((exp(548.68 / T) - 1),2) + 2 * 8.463e-3 * T + 8.741e7 * 18531.7 * exp(-18531.7 / T) / pow(T,2)) + 0.24 * ((322.49 * pow((587.41/T),2) * exp(587.41 / T)) / pow((exp(587.41 / T) - 1),2) + 2 * 1.4679e-2 * T)'\n    args = 'T'\n    block = 'inner'\n  [../]\n  [./k_inner]\n    type = ADParsedMaterial\n    f_name = k\n    function = '1.158/(7.5408 + 17.692 * (T / 1000) + 3.6142 * pow((T/1000),2)) + 74.105 * pow((T / 1000),-2.5) * exp(-16.35 / (T / 1000))'\n    args = 'T'\n    block = 'inner'\n  [../]\n\n  [./rho_outer]\n    type = ADParsedMaterial\n    f_name = rho\n    function = '1e-6 * (7830.853 - 0.212046 * T - 1.011373e-4 * pow(T,2))'\n    args = 'T'\n    block = 'outer'\n  [../]\n  [./cp_outer]\n    type = ADParsedMaterial\n    f_name = cp\n    function = '5863.9 - 32.563 * T + 0.072564 * pow(T,2) - 7.045375e-5 * pow(T,3) + 2.585336e-8 * pow(T,4)'\n    args = 'T'\n    block = 'outer'\n  [../]\n  [./k_outer]\n    type = ADParsedMaterial\n    f_name = k\n    function = '0.3'\n    args = 'T'\n    block = 'outer'\n  [../]\n[]\n\n[BCs]\n  [./top_and_bottom]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'outer_bottom outer_top inner_bottom inner_top'\n    value = 0\n  [../]\n  [./outer_wall_T]\n    type = DirichletBC\n    variable = T\n    value = ${ini_temp}\n    boundary = 'outer_wall'\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 25\n  dt = 0.001\n  #end_time = 100\n\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-10\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n   # petsc_options_iname = '-snes_type'\n  # petsc_options_value = 'test'\n\n  nl_max_its = 30\n  l_max_its = 100\n  automatic_scaling = true\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nThanks a lot.",
          "url": "https://github.com/idaholab/moose/discussions/21878",
          "updatedAt": "2022-08-20T01:33:56Z",
          "publishedAt": "2022-08-18T14:43:27Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "For the difference you see with different processors, that's very likely due to rigid body modes in the xy plane. You can still solve the system because you are using mumps with multiple processors plus a nonzero diagonal shift, but you lose the uniqueness of the solution.",
                  "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3431044",
                  "updatedAt": "2022-08-19T12:20:47Z",
                  "publishedAt": "2022-08-19T12:20:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Same reason for the asymmetry. There are two ways to resolve both issues:\n\nRemove the rigid body modes by fixing a point in the domain. Any point should do.\nAdd an inertia term in the momentum balance.",
                          "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3431067",
                          "updatedAt": "2022-08-19T12:24:50Z",
                          "publishedAt": "2022-08-19T12:24:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Do you mean that I should set boundary conditions on a point in the domain? I set new bundary conditions like this;\n  [./bottom_point_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom_point'\n    value = 0\n  [../]\n  [./bottom_point_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom_point'\n    value = 0\n  [../]\n  [./bottom_point_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom_point'\n    value = 0\n  [../]\n\nThe bottom_point is the point in the middle of the bottom of the cylinder with coordinates (0, 0, 0). I think if the input file is correct, the result will be the same whether it is a quad-core or an octa-core calculation. So I computed the input file with the new boundary conditions with four and eight cores respectively. . But the results calculated by different numbers of cores are still different and  asymmetry. Here are outputs screenshots and files:\n\n\nfiles.zip\nIf I want to set the model to have constraints at the top and bottom. In antoher word, the model cannot expand in the axial direction, only in the radial direction, how should I set the boundary conditions?",
                          "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3431945",
                          "updatedAt": "2022-08-19T14:28:36Z",
                          "publishedAt": "2022-08-19T14:28:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Remove the rigid body modes by fixing a point in the domain. Any point should do.\n\nUhh I guess I didn't make it clear, my bad. The way you are fixing the point removes the in-plane translational motion, but the body could still rotate. You'd want to pick two points, fix x and y at the first point, and fix x or y at the second point. You'd want to keep the original BC in the z direction.",
                          "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3433812",
                          "updatedAt": "2022-08-19T18:19:41Z",
                          "publishedAt": "2022-08-19T18:19:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "I've set boundary conditions on top_point and bottom_point, which are the midpoints of the top and bottom of the model, the new BCs block is here:\n[BCs]\n  [./bottom_point_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom_point'\n    value = 0\n  [../]\n  [./bottom_point_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom_point'\n    value = 0\n  [../]\n  [./top_point_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'top_point'\n    value = 0\n  [../]\n  [./top_and_bottom_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'outer_bottom outer_top inner_bottom inner_top'\n    value = 0\n  [../]\n  [./outer_wall_T]\n    type = DirichletBC\n    variable = T\n    value = ${ini_temp}\n    boundary = 'outer_wall'\n  [../]\n[]\n\nBut different numbers of cores still compute different results. The following are the results of the calculations for quad-core and octa-core:\n\n\nnew_files.zip\nThe new_files folder has a mesh file which has a coarser mesh in the axial direction.",
                          "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3435213",
                          "updatedAt": "2022-08-19T23:42:43Z",
                          "publishedAt": "2022-08-19T23:42:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Think about it: the \"top_point\" and the \"bottom_point\" you picked happen to align with the center axis. So the cylinder could still rotate (about the center axis).\nTry this: say the radius of the cylinder is R, and the bottom of the cylinder has origin (0, 0, 0), then pick point 1 at (0, 0, 0) and point 2 at (R, 0, 0). Fix the x and y displacements at point 1, and fix the y displacement at point 2.",
                          "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3435414",
                          "updatedAt": "2022-08-20T01:11:39Z",
                          "publishedAt": "2022-08-20T01:11:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Amazing idea! You are totally correct, Gary! I've got reasonable results after taking your advice. Sincere thanks to your patience and wisdom.",
                          "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3435446",
                          "updatedAt": "2022-08-20T01:27:19Z",
                          "publishedAt": "2022-08-20T01:27:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "So I just tested with your coarse mesh, and the results are consistent using different number of processors. My mesh block and BCs are\n[Mesh]\n  [fmg]\n    type = FileMeshGenerator\n    file = '2layers_3d_4parts_coarse.msh'\n  []\n  [pin]\n    type = ExtraNodesetGenerator\n    input = fmg\n    new_boundary = 'pin'\n    nodes = 4566\n  []\n[]\n\n[BCs]\n  [bottom_point_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom_point'\n    value = 0\n  []\n  [bottom_point_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom_point'\n    value = 0\n  []\n  [pin_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'pin'\n    value = 0\n  []\n  [bottom_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'outer_bottom inner_bottom'\n    value = 0\n  []\n  [outer_wall_T]\n    type = DirichletBC\n    variable = T\n    value = ${ini_temp}\n    boundary = 'outer_wall'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3435449",
                          "updatedAt": "2022-08-20T01:27:39Z",
                          "publishedAt": "2022-08-20T01:27:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Yeah, the results is absolutely correct! Thanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3435454",
                          "updatedAt": "2022-08-20T01:30:11Z",
                          "publishedAt": "2022-08-20T01:30:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "If you want the body to expand/shrink in the z-direction (due to thermal expansion for example), you probably don't want to constrain both top and bottom. Just constrain the z displacements on the bottom surface should suffice. You may want to constrain the top surface to have the same z-displacement, in which case you could use an EqualValueBoundaryConstraint on the top surface.",
                          "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3435460",
                          "updatedAt": "2022-08-20T01:31:13Z",
                          "publishedAt": "2022-08-20T01:31:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Okay, I'll learn to use this object carefully. Your advice really helps a lot to me!",
                          "url": "https://github.com/idaholab/moose/discussions/21878#discussioncomment-3435464",
                          "updatedAt": "2022-08-20T01:33:56Z",
                          "publishedAt": "2022-08-20T01:33:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "UMATHT in MOOSE",
          "author": {
            "login": "sidharthsarmah"
          },
          "bodyText": "Hi,\nI wanted to use this UMATHT.f subroutine in MOOSE.\nThis is the code I use in the moose file in section materials, but there is error popping out, please help, I am new to moose, thanks!\n# Testing the UMAT Interface - creep linear strain hardening model using the finite strain formulation - visco-plastic material.\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Mesh]\n  file = BLP.inp\n[]\n\n[Functions]\n  [top_pull]\n    type = ParsedFunction\n    value = '0.1*t'\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = small\n    incremental = true\n    generate_output = 'stress_xx stress_xy stress_yy strain_xx strain_xy strain_yy'\n  []\n[]\n\n[BCs]\n  [x_pull_function]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = Outer\n    function = 'top_pull'\n  []\n\n   [y_pull_function]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = Outer\n    function = 'top_pull'\n  []\n[]\n\n[Materials]\n [umatht]\n    type = AbaqusUMATStress\n    constant_properties = '0.0127 2'\n    plugin = '../../../../tensor_mechanics/test/plugins/UMATHT'\n    num_state_vars = 3\n    concentration = concentration\n    use_one_based_indexing = true\n  []\n  [constant]\n    type = AbaqusUMATStress\n    #                      Young's modulus,  Poisson's Ratio, Yield, Hardening\n    constant_properties = '201880 0.3 595 0.059'\n    plugin = ../../../plugins/UMATHT\n[UMATHT.txt](https://github.com/idaholab/moose/files/9332177/UMATHT.txt)\n\n    num_state_vars = 3\n    use_one_based_indexing = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-ksp_gmres_restart'\n  petsc_options_value = '101'\n\n  line_search = 'none'\n\n  l_max_its = 100\n  nl_max_its = 100\n  nl_rel_tol = 1e-12\n  nl_abs_tol = 1e-10\n  l_tol = 1e-9\n  start_time = 0.0\n  num_steps = 10\n  dt = 0.1\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Outputs]\n  [out]\n    type = Exodus\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/21844",
          "updatedAt": "2022-09-02T19:57:10Z",
          "publishedAt": "2022-08-13T21:10:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nThe two paths are different\n    plugin = '../../../../tensor_mechanics/test/plugins/UMATHT'\n    plugin = ../../../plugins/UMATHT\n\nare the paths correct?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21844#discussioncomment-3398860",
                  "updatedAt": "2022-08-15T14:32:07Z",
                  "publishedAt": "2022-08-15T14:32:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Yeah but the UMATHT subroutine is mentioned to not b registered, can you help me with this?",
                          "url": "https://github.com/idaholab/moose/discussions/21844#discussioncomment-3402571",
                          "updatedAt": "2022-08-16T01:16:59Z",
                          "publishedAt": "2022-08-16T01:16:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "The paths are the same, let me explain the problem, it's basically a coupled problem.\nThe UMATHT subroutine is for the calculation of the temperature, which takes various inputs such as diffusion etc.\nThe UMAT subroutine is for stress calculation\nThe DISP subroutine is for insert loading conditions which are K1 type loading.\nCan you help on how do I implement this, thanks!\n\n! User material and thermal subroutine for hydrogen transport\n! The code is distributed under a BSD license\n! If using this code for research or industrial purposes, please cite:\n! R. Fernandez-Sousa, C. Betegon, E. Martinez-Paneda. Analysis of the\n! influence of microstructural traps on hydrogen assisted fatigue.\n! Acta Materialia 199, pp. 253-263 (2020).\n! doi: 10.1016/j.actamat.2020.08.030\n! Emilio Martinez-Paneda (e.martinez-paneda@imperial.ac.uk)\n! Imperial College London\n  module ktransfer\n  implicit none\n  real*8 coorT(50000,4,2),grad(50000,8),ShT(50000,4)\n  save\n  end module   \n\n!***********************************************************************\nsubroutine uexternaldb(lop,lrestart,time,dtime,kstep,kinc)\nuse ktransfer\ninclude 'aba_param.inc' !implicit real(a-h o-z)\ndimension time(2)\n  if (lop.eq.0) then ! start of the analysis\n   coorT=0.d0\n   grad=0.d0\n   ShT=0.d0\n  end if\n  \n  return\n  end\n\n!***********************************************************************\nsubroutine umatht(u,dudt,dudg,flux,dfdt,dfdg,statev,temp,dtemp,\n1 dtemdx,time,dtime,predef,dpred,cmname,ntgrd,nstatv,props,nprops,\n2 coords,pnewdt,noel,npt,layer,kspt,kstep,kinc)\n  use ktransfer\n  include 'aba_param.inc'\n\n  character*80 cmname\n  dimension dudg(ntgrd),flux(ntgrd),dfdt(ntgrd),dfdg(ntgrd,ntgrd),\n 1 statev(nstatv),dtemdx(ntgrd),time(2),predef(1),dpred(1),\n 2 props(nprops),coords(3)\n\n  dimension Wb(nprops/2-1),xK(nprops/2-1),xNt(nprops/2-1),sig(ntgrd)\n\n  ! Step-1: Read input data & Initialize\n  dfdg=0.d0\n  ntens=ntgrd*2\n  cL=temp+dtemp\n\n  D=props(1)\n  kflag=props(2)\n  xNl=5.1d20 ! [sites/mm^3]\n  Vh=2000.d0 ! [mm^3/mol]\n  R=8314.5d0 ! [N*mm/(mol*K)]\n  T=300.d0   ! [K]\n  b=0.2725d-6 ! bcc [mm]\n  sig(1)=grad(noel,2*npt-1)\n  sig(2)=grad(noel,2*npt)\n  ntraps=nprops/2-1\n  \n  do k1=1,ntraps\n   Wb(k1)=props(2+2*k1-1)\n   xNt(k1)=props(2+2*k1)\n   xK(k1)=exp(Wb(k1)/(R*T))\n  end do\n  \n  du2=0.d0\n  if (kflag.eq.0) then ! Lattice H only\n   xNt(1)=0.d0\n  elseif (kflag.eq.1) then ! No dislocations: Wb(1) and xNt(1) irrelevant\n   xNt(1)=0.d0\n  elseif (kflag.eq.2) then ! Kumnick & Johnson / Sofronis & McMeeking (in sites/mm^3)\n   xNt(1)=10.d0**(23.26d0-2.33d0*exp(-5.5d0*statev(1+2*ntens)))/1e9\n  elseif (kflag.eq.3) then ! Kumnick & Johnson / Krom et al. \n   xNt(1)=10.d0**(23.26d0-2.33d0*exp(-5.5d0*statev(1+2*ntens)))/1e9\n   du2=(xK(1)*cL/(xK(1)*cL+xNl))*29.5d0\n & *dexp(-5.5d0*statev(1+2*ntens))*xNt(1)*statev(2+2*ntens)\n  elseif (kflag.eq.4) then ! Gilman / Dadfarnia et al.\n    if (statev(1+2*ntens).lt.0.5) then\n     xNt(1)=(1.d10+statev(1+2*ntens)*2.d16)/(b*1e6)\n     du2=(xK(1)*cL/(xK(1)*cL+xNl))*(statev(2+2*ntens)*2e16)/(b*1e6)\n    elseif (statev(1+2*ntens).ge.0.5) then\n     xNt(1)=(1e16)/(b*1e6)\n    endif\n  elseif (kflag.eq.5) then ! Taylor / Fernandez-Sousa et al.\n   xNt(1)=statev(3+2*ntens)/b\n  endif\n  \n  dudt2=0.d0\n  do k1=1,ntraps\n   dudt2=dudt2+xNt(k1)*xK(k1)*xNl/((xK(k1)*cL+xNl)**2.d0)\n  end do \n  dudt=1.d0+dudt2\t   \n  u=u+dudt*dtemp+du2\n  do i=1,ntgrd\n   dudg(i)=0.d0\n   flux(i)=-D*dtemdx(i)+D*cL*Vh*sig(i)/(R*T)\n   dfdt(i)=D*Vh*sig(i)/(R*T)\n   dfdg(i,i)=-D\n  end do\n\n!     store the concentration in each trap, in all traps and in traps and lattice\nid=3+2*ntens\nstatev(ntraps+1+id)=0\ndo k1=1,ntraps\nstatev(k1+id)=xNt(k1)*xK(k1)*cL/(xK(k1)*cL+xNl)\nstatev(ntraps+1+id)=statev(ntraps+1+id)+statev(k1+id)\nend do\nstatev(ntraps+2+id)=cL+statev(ntraps+1+id)\n  return\n  end\n\n! User material subroutine for power law conventional plasticity\n! The code is distributed under a BSD license\n! If using this code for research or industrial purposes, please cite:\n! E. Martinez-Paneda, S. Fuentes-Alonso, C. Betegon.\n! Gradient-enhanced statistical analysis of cleavage fracture\n! European Journal of Mechanics - A/Solids 77, 103785 (2019)\n! doi: 10.1016/j.euromechsol.2019.05.002\n! Emilio Martinez-Paneda (mail@empaneda.com)\n! Imperial College London\n  subroutine umat(stress,statev,ddsdde,sse,spd,scd,rpl,ddsddt,\n 1 drplde,drpldt,stran,dstran,time,dtime,temp2,dtemp,predef,dpred,\n 2 cmname,ndi,nshr,ntens,nstatv,props,nprops,coords,drot,pnewdt,\n 3 celent,dfgrd0,dfgrd1,noel,npt,layer,kspt,jstep,kinc)\n\n  use ktransfer\n  include 'aba_param.inc'\n\n  character*8 cmname\n  dimension stress(ntens),statev(nstatv),ddsdde(ntens,ntens),\n 1 ddsddt(ntens),drplde(ntens),stran(ntens),dstran(ntens),\n 2 time(2),predef(1),dpred(1),props(nprops),coords(3),drot(3,3),\n 3 dfgrd0(3,3),dfgrd1(3,3),jstep(4)\n  \n  dimension eelas(ntens),eplas(ntens),flow(ntens),olds(ntens),\n + oldpl(ntens),deriv(2,4),xjacm(2,2),xjaci(2,2)\n       \n  parameter(toler=1.d-6,newton=20)\n\n!     Initialization\nddsdde=0.d0\nE=props(1) ! Young's modulus\nxnu=props(2) ! Poisson's ratio\nSy=props(3) ! Yield stress\nxn=props(4) ! Strain hardening exponent\n  call rotsig(statev(1),drot,eelas,2,ndi,nshr)\n  call rotsig(statev(ntens+1),drot,eplas,2,ndi,nshr)\n  eqplas=statev(1+2*ntens)\n  olds=stress\n  oldpl=eplas\n\n!     Compute the gradient of the hydrostatic stress\nif (npt==1 .and. time(1).gt.0) then\ndo k1=1,4 ! Hard coded for 4 integration points\nif (k1==1) then\ns=-1.d0\nt=-1.d0\nelseif (k1==2) then\ns=1.d0\nt=-1.d0\nelseif (k1==3) then\ns=-1.d0\nt=1.d0\nelseif (k1==4) then\ns=1.d0\nt=1.d0\nend if\n    deriv(1,1)=-(1.d0/4.0)*(1-t)\n    deriv(1,2)=(1.d0/4.0)*(1-t)\n    deriv(1,3)=-(1.d0/4.0)*(1+t)\n    deriv(1,4)=(1.d0/4.0)*(1+t)\n    deriv(2,1)=-(1.d0/4.0)*(1-s)\n    deriv(2,2)=-(1.d0/4.0)*(1+s)\n    deriv(2,3)=(1.d0/4.0)*(1-s)\n    deriv(2,4)=(1.d0/4.0)*(1+s)\n\n    xjacm(1,1)=deriv(1,1)*coorT(noel,1,1)+deriv(1,2)*coorT(noel,2,1)\n 1 +deriv(1,3)*coorT(noel,3,1)+deriv(1,4)*coorT(noel,4,1)\n\n    xjacm(1,2)=deriv(1,1)*coorT(noel,1,2)+deriv(1,2)*coorT(noel,2,2)\n 1 +deriv(1,3)*coorT(noel,3,2)+deriv(1,4)*coorT(noel,4,2)\n \n    xjacm(2,1)=deriv(2,1)*coorT(noel,1,1)+deriv(2,2)*coorT(noel,2,1)\n 1 +deriv(2,3)*coorT(noel,3,1)+deriv(2,4)*coorT(noel,4,1)\n  \n    xjacm(2,2)=deriv(2,1)*coorT(noel,1,2)+deriv(2,2)*coorT(noel,2,2)\n 1 +deriv(2,3)*coorT(noel,3,2)+deriv(2,4)*coorT(noel,4,2)\n\n    djacb=xjacm(1,1)*xjacm(2,2)-xjacm(1,2)*xjacm(2,1) \n  \n    xjaci(1,1)=xjacm(2,2)/djacb \n    xjaci(1,2)=-xjacm(1,2)/djacb  \n    xjaci(2,1)=-xjacm(2,1)/djacb   \n    xjaci(2,2)=xjacm(1,1)/djacb\n\n    a1=xjaci(1,1)*deriv(1,1)+xjaci(1,2)*deriv(2,1) \n    a2=xjaci(1,1)*deriv(1,2)+xjaci(1,2)*deriv(2,2) \n    a3=xjaci(1,1)*deriv(1,3)+xjaci(1,2)*deriv(2,3) \n    a4=xjaci(1,1)*deriv(1,4)+xjaci(1,2)*deriv(2,4) \n    b1=xjaci(2,1)*deriv(1,1)+xjaci(2,2)*deriv(2,1) \n    b2=xjaci(2,1)*deriv(1,2)+xjaci(2,2)*deriv(2,2) \n    b3=xjaci(2,1)*deriv(1,3)+xjaci(2,2)*deriv(2,3) \n    b4=xjaci(2,1)*deriv(1,4)+xjaci(2,2)*deriv(2,4)  \n  \n    grad(noel,2*k1-1)=a1*ShT(noel,1)+a2*ShT(noel,2)+a3*ShT(noel,3)\n 1 +a4*ShT(noel,4)\n    grad(noel,2*k1)=b1*ShT(noel,1)+b2*ShT(noel,2)+b3*ShT(noel,3)\n 1 +b4*ShT(noel,4)\n   end do \n  end if     \n\n!     Build elastic stiffness matrix\neg=E/(1.d0+xnu)/2.d0\nelam=(E/(1.d0-2.d0xnu)-2.d0eg)/3.d0\n  do i=1,3\n   do j=1,3\n    ddsdde(j,i)=elam\n   end do\n   ddsdde(i,i)=2.d0*eg+elam\n  end do\n  do i=4,ntens\n   ddsdde(i,i)=eg\n  end do\n\n!     Calculate predictor stress and elastic strain\nstress=stress+matmul(ddsdde,dstran)\neelas=eelas+dstran\n!     Calculate equivalent von Mises stress\nSmises=(stress(1)-stress(2))**2+(stress(2)-stress(3))**2\n1 +(stress(3)-stress(1))**2\ndo i=4,ntens\nSmises=Smises+6.d0*stress(i)**2\nend do\nSmises=sqrt(Smises/2.d0)\n!     Get yield stress from the specified hardening curve\nSf=Sy*(1.d0+E*eqplas/Sy)**xn\n!     Determine if active yielding\nif (Smises.gt.(1.d0+toler)*Sf) then\n!     Calculate the flow direction\nSh=(stress(1)+stress(2)+stress(3))/3.d0\nflow(1:3)=(stress(1:3)-Sh)/Smises\nflow(4:ntens)=stress(4:ntens)/Smises\n!     Solve for Smises and deqpl using Newton's method\ndeqpl=0.d0\nEt=Exn(1.d0+Eeqplas/Sy)**(xn-1)\ndo kewton=1,newton\nrhs=Smises-(3.d0eg)deqpl-Sf\ndeqpl=deqpl+rhs/((3.d0eg)+Et)\nSf=Sy*(1.d0+E*(eqplas+deqpl)/Sy)xn\nEt=Exn(1.d0+E*(eqplas+deqpl)/Sy)(xn-1)\nif(abs(rhs).lt.tolerSy) exit\nend do\nif (kewton.eq.newton) write(7,)'WARNING: plasticity loop failed'\n!     Update stresses and strains\nstress(1:3)=flow(1:3)Sf+Sh\neplas(1:3)=eplas(1:3)+3.d0/2.d0flow(1:3)deqpl\neelas(1:3)=eelas(1:3)-3.d0/2.d0flow(1:3)*deqpl\nstress(4:ntens)=flow(4:ntens)Sf\neplas(4:ntens)=eplas(4:ntens)+3.d0flow(4:ntens)deqpl\neelas(4:ntens)=eelas(4:ntens)-3.d0flow(4:ntens)*deqpl\neqplas=eqplas+deqpl\n!     Calculate the plastic strain energy density\ndo i=1,ntens\nspd=spd+(stress(i)+olds(i))*(eplas(i)-oldpl(i))/2.d0\nend do\n!     Formulate the jacobian (material tangent)\neffg=egSf/Smises\nefflam=(E/(1.d0-2.d0xnu)-2.d0effg)/3.d0\neffhrd=3.d0egEt/(3.d0eg+Et)-3.d0effg\ndo i=1,3\ndo j=1,3\nddsdde(j,i)=efflam\nenddo\nddsdde(i,i)=2.d0effg+efflam\nend do\ndo i=4,ntens\nddsdde(i,i)=effg\nend do\n   do i=1,ntens\n    do j=1,ntens\n     ddsdde(j,i)=ddsdde(j,i)+effhrd*flow(j)*flow(i)\n    end do\n   end do\n  endif\n\n!     Store strains in state variable array\nstatev(1:ntens)=eelas\nstatev((ntens+1):2ntens)=eplas\nstatev(1+2ntens)=eqplas\nstatev(2+2*ntens)=deqpl\n!     Statistically stored dislocations (bcc)\nxm=2.9d0\nb=0.2725d-6\nssd=((Sy*(E/Sy)*xn(eqplas+Sy/E)**xn)/(xm0.5d0egb))**2\nstatev(3+2ntens)=ssd\n!     Store information for computing the Sh gradient\nShT(noel,npt)=(stress(1)+stress(2)+stress(3))/3.d0\ncoorT(noel,npt,1)=coords(1)\ncoorT(noel,npt,2)=coords(2)\n  return\n  end\n\n! User subroutine for prescribing a remote amplitude load\n! The code is distributed under a BSD license\n! If using this code for research or industrial purposes, please cite:\n! S. del Busto, C. Beteg\u00f3n, E. Mart\u00ednez-Pa\u00f1eda. A cohesive zone\n! framework for environmentally assisted fatigue. Engineering Fracture\n! Mechanics 185: 210-226 (2017). doi:10.1016/j.engfracmech.2017.05.021\n! Emilio Mart\u00ednez-Pa\u00f1eda (mail@empaneda.com)\n! Technical University of Denmark\n  subroutine  disp(u,kstep,kinc,time,node,noel,jdof,coords)\n\n  include 'aba_param.inc'\n\n  dimension u(3),time(2),coords(3)\n\n! Introduce manually\nxk=30dsqrt(1000.d0)time(2) ! MPam^1/2 to MPamm^1/2\ne=201880.d0\nxnu=0.3d0\npi=3.14159265359d0\n!user coding to define U\nr=dsqrt(coords(1)**2+coords(2)**2)\ntheta=atan2(coords(2),coords(1))\nif (jdof.eq.1) then\nu(1)=(1+xnu)(xk/e)sqrt(r/(2pi))(3-4xnu-cos(theta))\n& cos(theta/2)\nelseif (jdof.eq.2) then\nu(1)=(1+xnu)(xk/e)sqrt(r/(2pi))(3-4xnu-cos(theta))\n& sin(theta/2)\nendif\n  RETURN\n  END",
                          "url": "https://github.com/idaholab/moose/discussions/21844#discussioncomment-3402591",
                          "updatedAt": "2022-08-16T01:22:17Z",
                          "publishedAt": "2022-08-16T01:22:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "We currently only support stress calculation user subroutines and external database utility subroutines. User heat transfer subroutines aren't supported yet. You can, however, use the temperature variable in your stress routine if you define MOOSE heat transfer kernels.",
                          "url": "https://github.com/idaholab/moose/discussions/21844#discussioncomment-3402797",
                          "updatedAt": "2022-08-16T02:16:53Z",
                          "publishedAt": "2022-08-16T02:16:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Does it mean we cannot perform diffusion process where the driving force is the stress gradient using the UMATHT subroutine?\nOr can we make any changes to the UMAT subroutine available in Moose to obtain the desired heat transfer distribution? By incorporating say the space and time derivative of Temperature?\nPlease assist!",
                          "url": "https://github.com/idaholab/moose/discussions/21844#discussioncomment-3403677",
                          "updatedAt": "2022-08-16T06:19:42Z",
                          "publishedAt": "2022-08-16T06:19:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Does it mean we cannot perform diffusion process where the driving force is the stress gradient using the UMATHT subroutine?\n\nCorrect. You could use MOOSE native capabilities to do that if you so choose.",
                          "url": "https://github.com/idaholab/moose/discussions/21844#discussioncomment-3434994",
                          "updatedAt": "2022-08-19T22:22:01Z",
                          "publishedAt": "2022-08-19T22:22:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "By native capability, it means, I need to modify the Kernels?",
                          "url": "https://github.com/idaholab/moose/discussions/21844#discussioncomment-3435227",
                          "updatedAt": "2022-08-19T23:48:10Z",
                          "publishedAt": "2022-08-19T23:48:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "You may or may not need to modify kernels depending on your use case. There are options for users that want to define materials in the input files, such as parsed materials (https://mooseframework.inl.gov/source/materials/ParsedMaterial.html), which avoid the need to code. This is the doc for the heat transfer module: https://mooseframework.inl.gov/modules/heat_conduction/index.html.",
                          "url": "https://github.com/idaholab/moose/discussions/21844#discussioncomment-3435283",
                          "updatedAt": "2022-08-20T00:11:52Z",
                          "publishedAt": "2022-08-20T00:11:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Thanks a lot",
                          "url": "https://github.com/idaholab/moose/discussions/21844#discussioncomment-3435425",
                          "updatedAt": "2022-08-20T01:16:28Z",
                          "publishedAt": "2022-08-20T01:16:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Conda Apple Silicon (libgfortran issue)",
          "author": {
            "login": "milljm"
          },
          "bodyText": "There is an issue with our ARM Conda packages (not being strict enough... again).\nThe change (mamba list):\n-    libgfortran:                 5.0.0.dev0-11_0_1_hf114ba7_23 conda-forge     < good version\n+    libgfortran:                 5.0.0-11_3_0_hd922786_24      conda-forge\n-    libgfortran5:                11.0.1.dev0-hf114ba7_23       conda-forge     < good version\n+    libgfortran5:                11.3.0-hdaf2cc0_24            conda-forge\nIf you perform an update, or install from scratch, you will receive these problematic packages. The fix is to supply the correct version of libgfortran when installing. Like so:\nmamba create -n moose moose-libmesh moose-tools libgfortran=5.0.0.dev0",
          "url": "https://github.com/idaholab/moose/discussions/21902",
          "updatedAt": "2022-08-19T20:09:56Z",
          "publishedAt": "2022-08-19T20:06:56Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      }
    ]
  }
}