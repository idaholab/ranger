{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNi0wOFQxOTozMTowOS0wNjowMM4APA-Y"
    },
    "edges": [
      {
        "node": {
          "title": "Mesh setting up message at the beginning of output",
          "author": {
            "login": "xueyang94"
          },
          "bodyText": "I sometimes randomly (but rarely) receive this message at the beginning of the output when running a moose input file. With this message, the simulation takes a long time to run. But when I ran the same input file for a second time, I don't receive the mesh setting message and everything is normal. Where does this message comes from and how to make sure the future run does not have this message? Thanks. -Xueyang",
          "url": "https://github.com/idaholab/moose/discussions/20940",
          "updatedAt": "2022-06-10T20:02:07Z",
          "publishedAt": "2022-05-03T15:17:43Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThese are messages from the live perf graph. It's outputting to let you know it's not stuck.\nhttps://mooseframework.inl.gov/source/utils/PerfGraph.html\nI imagine the Reading mesh ... is always there and the Updating mesh ... message is only sometimes there?\nAre you running with a distributed mesh?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2681229",
                  "updatedAt": "2022-06-10T20:02:07Z",
                  "publishedAt": "2022-05-03T15:39:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "The Reading mesh and Updating mesh either appear together or don't appear at all. In the latter case the output just starts with Framework Information. I am not using distributed mesh. The mesh is read from an exodus file and the variables are imported. This is strange because I am running a bunch of input files with everything else exactly the same except for one diffusion material property parameter. Within those input files, only one gave me the Setting Mesh info I showed above, and that one took much longer wall time. But I ran that one input again, it didn't show the mesh setting message and finished normally just like other files.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2681357",
                          "updatedAt": "2022-06-10T20:02:12Z",
                          "publishedAt": "2022-05-03T15:59:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is this on an HPC platform? Or a work computer?\nThese logs appearing/disappearing is tied to how fast you are loading the mesh basically. So if something is slowing down file IO outside of MOOSE that can trigger that.\nReading mesh in MOOSE is deterministic otherwise.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2681809",
                          "updatedAt": "2022-06-10T20:02:13Z",
                          "publishedAt": "2022-05-03T17:23:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "This particular batch of files was on HPC, but I have seen the same thing happened before on local machine. I don't think these logs appearing is an issue, the issue is that in all of the following iterations, each step takes far more wall time somehow. If something was slowing down the IO when I started the simulation, I would expect the simulation speed to catch up after a while. By ending the simulation and restarting immediately, the normal speed was recovered.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2682061",
                          "updatedAt": "2022-06-10T20:02:13Z",
                          "publishedAt": "2022-05-03T17:54:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so the whole simulation is slower when they appear?",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2682648",
                          "updatedAt": "2022-06-10T20:02:17Z",
                          "publishedAt": "2022-05-03T19:42:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "Correct.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2683769",
                          "updatedAt": "2022-06-10T20:02:18Z",
                          "publishedAt": "2022-05-04T00:22:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you can share your inputs I can see if I can reproduce this. But the fact that this affects the whole simulation and not parts of it points to an issue with either your machine or how moose is being ran rather than a buggy feature which would only be present in parts of the simulation.\nAre you running threads or MPI?",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2684321",
                          "updatedAt": "2022-06-10T20:02:17Z",
                          "publishedAt": "2022-05-04T04:24:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "I'm running MPI. On both cluster and my local machine, with that message, the simulation is slowed down. My input file imports mesh from an exodus file which is 25GB. How would you prefer me to share both the exodus and input file? Thanks for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2694874",
                          "updatedAt": "2022-06-10T20:02:17Z",
                          "publishedAt": "2022-05-05T15:43:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "That message appears because the simulation is slow I think, not the other way around.\nWith MPI a classic 2x slowdown is if two processes get bound to the same core. Or if you are using all the cores but one of the cores is busy doing something else for the system (often an issue on HPC).\nHow many processes are you using and how many cores are there on the machines?\nIf you can share those I can see if it's reproducible on INL HPC.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2694941",
                          "updatedAt": "2022-06-10T20:02:22Z",
                          "publishedAt": "2022-05-05T15:53:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "On my university HPC, for one simulation I request 8 nodes and 32 MPI processes. Each node has 2 CPU and 32 cores. So I use 16 CPU and 256 cores in total.\nMy local machine has 1 CPU and 8 cores in total. I use all cores to execute a simulation: mpirun -np 8 -opt -i.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2722953",
                          "updatedAt": "2022-06-10T20:02:22Z",
                          "publishedAt": "2022-05-10T14:13:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So you could send me the inputs by email. My email is on my github profile.\nWhat application do I need to run it? just moose?\nI ll see if I can reproduce the slowdown.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2755461",
                          "updatedAt": "2022-06-10T20:02:27Z",
                          "publishedAt": "2022-05-15T21:24:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@xueyang94 any luck finding the culprit?",
                  "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2909765",
                  "updatedAt": "2022-06-09T01:27:22Z",
                  "publishedAt": "2022-06-09T01:27:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "@GiudGiud I have emailed you back days ago. The printing of mesh setting messages and the subsequent slow down is most likely due to the machine being busy. Thanks for the help.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2917177",
                          "updatedAt": "2022-06-09T20:46:06Z",
                          "publishedAt": "2022-06-09T20:46:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh sorry. Glad this is settled and thanks for letting me know",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2917235",
                          "updatedAt": "2022-06-09T20:59:33Z",
                          "publishedAt": "2022-06-09T20:59:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Thermal contact problems",
          "author": {
            "login": "Edward-Eth"
          },
          "bodyText": "Hi, I am wondering what the best approach to model conduction between two meshes that are in direct contact but are not meshed together is? I have tried using the thermal contact action, but setting the gap conductivity to the material conductivity (which seems like the correct thing to do in my case) results in a model that never converges/has to use incredibly small time steps. Am I using the wrong method? In the below input file gap_conductivity values greater than about 10e-6 will not converge, which is odd when my material conductivity is 8e-3.\n[Mesh]\n    [Top_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 2\n        ymax = 2\n        zmax = 2\n        xmin = 0\n        ymin = 0\n        zmin = 1\n        boundary_name_prefix = 'Upper'\n        boundary_id_offset = 10\n    []\n    [Bottom_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 2\n        ymax = 2\n        zmax = 1\n        boundary_name_prefix = 'Lower'\n    []\n    [Combine]\n        type = CombinerGenerator\n        inputs = 'Bottom_Block Top_Block'\n        positions = '0 0 0 0.12 0.12 0'\n    []\n    [Rename]\n        type = RenameBoundaryGenerator\n        input = Combine\n        old_boundary = '10 11 12 13 14 15'\n        new_boundary = 'Upper_back Upper_bottom Upper_right Upper_top Upper_left Upper_front'\n    []\n    [LowerSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = Rename\n        combinatorial_geometry = 'z<1'\n        block_id = 1\n        block_name = 'Lower_Block'\n    []\n    [UpperSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = LowerSubDomain\n        combinatorial_geometry = 'z>1'\n        block_id = 2\n        block_name = 'Upper_Block'\n    []\n[]\n\n[Variables]\n    [T]\n        block = '1 2'\n    []\n[]\n\n[ICs]\n    [T_Lower]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 1\n    []\n\n    [T_Upper]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 2\n    []\n[]\n\n[Kernels]\n    [HeatConduction]\n        type = HeatConduction\n        variable = T\n    []\n    [HeatConductionTimeDerivative]\n        type = HeatConductionTimeDerivative\n        variable = T\n    []\n[]\n\n[BCs]\n    [Heat_Out_Base]\n        type = ADDirichletBC\n        value = 293.0\n        variable = T\n        boundary = 'Lower_back'\n    []\n    [Heat_In_Top]\n        type = ADDirichletBC\n        value = 350.0\n        variable = T\n        boundary = 'Upper_front'\n    []\n[]\n\n[ThermalContact]\n  [thermal_contact]\n    type = GapHeatTransfer\n    variable = T\n    primary = 'Upper_back'\n    secondary = 'Lower_front'\n    emissivity_primary = 0\n    emissivity_secondary = 0\n    gap_conductivity = 1e-6\n    #quadrature = True\n    #gap_geometry_type = PLATE\n  []\n[]\n\n[Materials]\n    [./ti_material]\n        type = GenericConstantMaterial\n        prop_names = 'density thermal_conductivity poissons_ratio specific_heat'\n        prop_values = '4e-6 8e-3 0.3 560'\n        block = '1 2'\n    [../]\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    automatic_scaling = True\n    nl_abs_tol = 1e-3\n    nl_max_its = 50\n    l_max_its = 50\n    num_steps = 20\n    dt = 0.05\n[]\n\n[Outputs]\n    [outfile]\n        type = Exodus\n        file_base = \"ThermalGlueTest\"\n    []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/20830",
          "updatedAt": "2022-06-25T05:39:24Z",
          "publishedAt": "2022-04-21T10:35:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\ngap_geometry_type = PLATE should be correct in this case right? Does it help?\nWhat does the solution look like for the first few steps it converged? Is it going towards the right temperature gradient?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2610250",
                  "updatedAt": "2022-06-05T05:25:55Z",
                  "publishedAt": "2022-04-21T16:45:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Edward-Eth"
                  },
                  "bodyText": "Sorry for the very delayed response, I moved onto a different problem but have now come back to this issue. It seems that gap heat transfer, when used to conduct between contacting but not merged meshes, conducts a lot faster than it ought too. For example, in input file 1, the material has a conductivity of 0.0057, and the \"gap\" has a conductivity of 0.0000000057, which is 10^6 times smaller than than the material. Despite this, viewing the exodus file shows that the conductivity across the \"gap\" occurs barely slower than conduction through the material, so despite what should be a very insulating layer between the two blocks of mesh, conductivity between them is almost as quick as conduction within. This explains why using the same value for conductivity for the gap and the part causes issues, as this would result in extremely quick conduction making the sim unstable and stop it from converging.\nThis seems to be specifically an issue with gaps that are zero seperation, ie in contact, as when I increase the gap to equivalent to the element size in the mesh, using the same conductance in the gap as in the material works correctly, as seen in this image:\n\nThis model was stable with gap conductivity = material conductivity, however this doesn't resolve the problem of what conductivity value to use to conduct between disjoint meshes that are in perfect contact. This model is Input File 2.\nOne thought therefore would be to artificially add a small gap into the model between the two blocks of mesh, this was attempted in Input File 3. I found that at a gap of 1/10 mesh size the simulation was again unstable.\nBasically, it seems that the issue is the tool is designed for a gap heat transfer, so as the gap diminishes to zero the rate of heat transfer grows and in the contact case diverges to an unsolvable fast transfer. This makes sense for a gap, the smaller the gap the faster the transfer, but then means that zero gap is unsolvable. Am I just using the wrong tool for this?\n\n  Input File 1\n\n[Mesh]\n    [Top_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 20\n        xmin = 0\n        ymin = 0\n        zmin = 10\n        boundary_name_prefix = 'Upper'\n        boundary_id_offset = 10\n    []\n    [Bottom_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 10\n        boundary_name_prefix = 'Lower'\n    []\n    [Combine]\n        type = CombinerGenerator\n        inputs = 'Bottom_Block Top_Block'\n        positions = '0 0 0 0 0 0'\n    []\n    [LowerSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = Combine\n        combinatorial_geometry = 'z<=10'\n        block_id = 1\n        block_name = 'Lower_Block'\n    []\n    [UpperSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = LowerSubDomain\n        combinatorial_geometry = 'z>10'\n        block_id = 2\n        block_name = 'Upper_Block'\n    []\n[]\n\n[Variables]\n    [T]\n        block = '1 2'\n    []\n[]\n\n[ICs]\n    [T_Lower]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 1\n    []\n    [T_Upper]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 2\n    []\n[]\n\n[Kernels]\n    [HeatConduction]\n        type = HeatConduction\n        variable = T\n    []\n    [HeatConductionTimeDerivative]\n        type = HeatConductionTimeDerivative\n        variable = T\n    []\n[]\n\n[BCs]\n    [Heat_Out_Base]\n        type = ADDirichletBC\n        value = 293.0\n        variable = T\n        boundary = 'Lower_back'\n    []\n    [Heat_In_Top]\n        type = ADDirichletBC\n        value = 350.0\n        variable = T\n        boundary = 'Upper_front'\n    []\n[]\n\n[ThermalContact]\n  [thermal_contact]\n    type = GapHeatTransfer\n    variable = T\n    primary = 'Upper_back'\n    secondary = 'Lower_front'\n    emissivity_primary = 0\n    emissivity_secondary = 0\n    gap_conductivity = 0.0000000057\n    gap_geometry_type = PLATE\n  []\n[]\n\n[Materials]\n    [./ti_material]\n        type = GenericConstantMaterial\n        prop_names = 'density thermal_conductivity specific_heat'\n        prop_values = '0.0000045 0.0057 544'\n        block = '1 2'\n    [../]\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    automatic_scaling = True\n    nl_max_its = 50\n    l_max_its = 50\n    num_steps = 40\n    dt = 0.1\n[]\n\n[Outputs]\n    [outfile]\n        type = Exodus\n        file_base = \"SimpleThermalGlueTest\"\n        append_date = true\n    []\n[]\n\n\n\n  Input File 2\n# Thermal contact between two blocks, has issues with conductivity values anywhere near the conductivity of the material itself so not sure what's going on here.\n\n[Mesh]\n    [Top_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 9\n        xmax = 20\n        ymax = 20\n        zmax = 20\n        xmin = 0\n        ymin = 0\n        zmin = 11\n        boundary_name_prefix = 'Upper'\n        boundary_id_offset = 10\n    []\n    [Bottom_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 10\n        boundary_name_prefix = 'Lower'\n    []\n    [Combine]\n        type = CombinerGenerator\n        inputs = 'Bottom_Block Top_Block'\n        positions = '0 0 0 0 0 0'\n    []\n    [LowerSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = Combine\n        combinatorial_geometry = 'z<=10'\n        block_id = 1\n        block_name = 'Lower_Block'\n    []\n    [UpperSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = LowerSubDomain\n        combinatorial_geometry = 'z>10'\n        block_id = 2\n        block_name = 'Upper_Block'\n    []\n[]\n\n[Variables]\n    [T]\n        block = '1 2'\n    []\n[]\n\n[ICs]\n    [T_Lower]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 1\n    []\n\n    [T_Upper]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 2\n    []\n[]\n\n[Kernels]\n    [HeatConduction]\n        type = HeatConduction\n        variable = T\n    []\n    [HeatConductionTimeDerivative]\n        type = HeatConductionTimeDerivative\n        variable = T\n    []\n[]\n\n[BCs]\n    [Heat_Out_Base]\n        type = ADDirichletBC\n        value = 293.0\n        variable = T\n        boundary = 'Lower_back'\n    []\n    [Heat_In_Top]\n        type = ADDirichletBC\n        value = 350.0\n        variable = T\n        boundary = 'Upper_front'\n    []\n[]\n\n[ThermalContact]\n  [thermal_contact]\n    type = GapHeatTransfer\n    variable = T\n    primary = 'Upper_back'\n    secondary = 'Lower_front'\n    emissivity_primary = 0\n    emissivity_secondary = 0\n    gap_conductivity = 0.0057\n    gap_geometry_type = PLATE\n  []\n[]\n\n[Materials]\n    [./ti_material]\n        type = GenericConstantMaterial\n        prop_names = 'density thermal_conductivity specific_heat'\n        prop_values = '0.0000045 0.0057 544'\n        block = '1 2'\n    [../]\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    automatic_scaling = True\n    nl_max_its = 50\n    l_max_its = 50\n    num_steps = 40\n    dt = 0.1\n[]\n\n[Outputs]\n    [outfile]\n        type = Exodus\n        file_base = \"SimpleThermalGlueTest\"\n        append_date = true\n    []\n[]\n\n\n\n  Input File 3\n# Thermal contact between two blocks, has issues with conductivity values anywhere near the conductivity of the material itself so not sure what's going on here.\n\n[Mesh]\n    [Top_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 20\n        xmin = 0\n        ymin = 0\n        zmin = 10\n        boundary_name_prefix = 'Upper'\n        boundary_id_offset = 10\n    []\n    [Bottom_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 10\n        boundary_name_prefix = 'Lower'\n    []\n    [Combine]\n        type = CombinerGenerator\n        inputs = 'Bottom_Block Top_Block'\n        positions = '0 0 0 0 0 0.1'\n    []\n    [LowerSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = Combine\n        combinatorial_geometry = 'z<=10'\n        block_id = 1\n        block_name = 'Lower_Block'\n    []\n    [UpperSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = LowerSubDomain\n        combinatorial_geometry = 'z>10'\n        block_id = 2\n        block_name = 'Upper_Block'\n    []\n[]\n\n[Variables]\n    [T]\n        block = '1 2'\n    []\n[]\n\n[ICs]\n    [T_Lower]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 1\n    []\n\n    [T_Upper]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 2\n    []\n[]\n\n[Kernels]\n    [HeatConduction]\n        type = HeatConduction\n        variable = T\n    []\n    [HeatConductionTimeDerivative]\n        type = HeatConductionTimeDerivative\n        variable = T\n    []\n[]\n\n[BCs]\n    [Heat_Out_Base]\n        type = ADDirichletBC\n        value = 293.0\n        variable = T\n        boundary = 'Lower_back'\n    []\n    [Heat_In_Top]\n        type = ADDirichletBC\n        value = 350.0\n        variable = T\n        boundary = 'Upper_front'\n    []\n[]\n\n[ThermalContact]\n  [thermal_contact]\n    type = GapHeatTransfer\n    variable = T\n    primary = 'Upper_back'\n    secondary = 'Lower_front'\n    emissivity_primary = 0\n    emissivity_secondary = 0\n    gap_conductivity = 0.0057\n    gap_geometry_type = PLATE\n  []\n[]\n\n[Materials]\n    [./ti_material]\n        type = GenericConstantMaterial\n        prop_names = 'density thermal_conductivity specific_heat'\n        prop_values = '0.0000045 0.0057 544'\n        block = '1 2'\n    [../]\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    automatic_scaling = True\n    nl_max_its = 50\n    l_max_its = 50\n    num_steps = 40\n    dt = 0.1\n[]\n\n[Outputs]\n    [outfile]\n        type = Exodus\n        file_base = \"SimpleThermalGlueTest\"\n        append_date = true\n    []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2768819",
                  "updatedAt": "2022-06-05T05:26:01Z",
                  "publishedAt": "2022-05-17T15:46:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@Edward-Eth can you specify the gap_distance parameter manually?\nthe behavior you are describing is consistent with determining the gap distance automatically. If the gap is pretty much closed, then it's not really slowing down heat transfer",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2770785",
                          "updatedAt": "2022-06-05T05:26:06Z",
                          "publishedAt": "2022-05-17T20:42:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "If I specify zero I'm guessing it will still break though?",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2773824",
                          "updatedAt": "2022-06-05T05:26:06Z",
                          "publishedAt": "2022-05-18T08:09:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "I'm looking for something like the mesh to mesh hard contact feature in nastran:(https://help.mscsoftware.com/bundle/MSC_Nastran_2020/page/Nastran_Combined_Book/non_linear/ch09/TOC.Thermal.Contact1.xhtml)\nThe temperature at each node on one surface is a combination of weighted temperatures from nodes on the opposite surface. Would this be more easily achieved with a matched value boundary condition or interface diffusion?",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2773892",
                          "updatedAt": "2022-06-05T05:26:06Z",
                          "publishedAt": "2022-05-18T08:19:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "Not sure if this is relevant but what I'm modelling is actually one solid object, it's just that the mesh for two parts of it are disjoint, but what I'm trying to achieve is conduction as though they were one solid continuously meshed object. I've tried equal value boundary constraint but that seems to end up enforcing that the bottom of the top block should be the same temperature as the top of the bottom one, but never heats up the bottom one, so it effectively sets a dirichlet of the lower block's temperature on the underside of the top block.",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2775873",
                          "updatedAt": "2022-06-11T10:28:22Z",
                          "publishedAt": "2022-05-18T13:15:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "have you looked at the thermal contact action ?\nhttps://mooseframework.inl.gov/source/actions/ThermalContactAction.html",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2777181",
                          "updatedAt": "2022-05-18T15:58:08Z",
                          "publishedAt": "2022-05-18T15:58:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "interfaces are usually for internal sidesets so I m not sure interface diffusion is the right object. Which one are you think of?",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2777195",
                          "updatedAt": "2022-05-18T16:00:13Z",
                          "publishedAt": "2022-05-18T16:00:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "have you looked at the thermal contact action ? https://mooseframework.inl.gov/source/actions/ThermalContactAction.html\n\nI used that for setting up the gap heat transfer in the first instance. Is there some other type within thermal contact action that would be more suitable? The ThermalContactSystem page (which thermal contact action recommends you look at for examples and parameters) is empty so there's not much to go on there...",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2781823",
                          "updatedAt": "2022-05-19T08:21:55Z",
                          "publishedAt": "2022-05-19T08:21:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "If you look at the parameters of this material: https://mooseframework.inl.gov/source/materials/GapConductance.html, you'll see options to define radiation and conductivity.\nInformation for similar radiation formulation: https://mooseframework.inl.gov/source/userobjects/GapFluxModelRadiation.html.\nFor conduction, you can provide a constant gap conductivity or a function. There are some additional factors that appear in the parameter section.",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2784244",
                          "updatedAt": "2022-05-19T14:48:05Z",
                          "publishedAt": "2022-05-19T14:48:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "If you look at the parameters of this material: https://mooseframework.inl.gov/source/materials/GapConductance.html, you'll see options to define radiation and conductivity.\nInformation for similar radiation formulation: https://mooseframework.inl.gov/source/userobjects/GapFluxModelRadiation.html. For conduction, you can provide a constant gap conductivity or a function. There are some additional factors that appear in the parameter section.\n\nCircling back onto this issues and still not understanding how to get this to work. Here's my input file for trying to use the GapConductance material, but nothing happens that indicates there's any heat transfer from one mesh to the other. Not sure how I'm supposed to implement the GapConductance as there's no example input file. It's labelled as a material so I've put it in the materials block, but that seems odd to me.\nInput file:\n\n  Input File 1\n[Mesh]\n    [Top_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 20\n        xmin = 0\n        ymin = 0\n        zmin = 10\n        boundary_name_prefix = 'Upper'\n        boundary_id_offset = 10\n    []\n    [Bottom_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 10\n        boundary_name_prefix = 'Lower'\n    []\n    [Combine]\n        type = CombinerGenerator\n        inputs = 'Bottom_Block Top_Block'\n        positions = '0 0 0 0 0 0'\n    []\n    [LowerSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = Combine\n        combinatorial_geometry = 'z<=10'\n        block_id = 1\n        block_name = 'Lower_Block'\n    []\n    [UpperSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = LowerSubDomain\n        combinatorial_geometry = 'z>10'\n        block_id = 2\n        block_name = 'Upper_Block'\n    []\n[]\n\n[Variables]\n    [T_Upper]\n        block = 2\n    []\n    [T_Lower]\n        block = 1\n    []\n[]\n\n[ICs]\n    [T_Upper_Initial]\n        type = ConstantIC\n        value = 293.0\n        variable = T_Upper\n        block = 2\n    []\n    [T_Lower_Initial]\n        type = ConstantIC\n        value = 293.0\n        variable = T_Lower\n        block = 1\n    []\n[]\n\n[Kernels]\n    [HeatConduction_Upper]\n        type = ADHeatConduction\n        variable = T_Upper\n        block = 2\n    []\n    [HeatConductionTimeDerivative_Upper]\n        type = ADHeatConductionTimeDerivative\n        variable = T_Upper\n        block = 2\n    []\n    [HeatConduction_Lower]\n        type = ADHeatConduction\n        variable = T_Lower\n        block = 1\n    []\n    [HeatConductionTimeDerivative_Lower]\n        type = ADHeatConductionTimeDerivative\n        variable = T_Lower\n        block = 1\n    []\n[]\n\n[BCs]\n    [Heat_Out_Base]\n        type = ADDirichletBC\n        value = 293.0\n        variable = T_Lower\n        boundary = 'Lower_back'\n    []\n    [Heat_In_Top]\n        type = ADDirichletBC\n        value = 350.0\n        variable = T_Upper\n        boundary = 'Upper_front'\n    []\n[]\n\n[Materials]\n    [./ti_material]\n        type = ADGenericConstantMaterial\n        prop_names = 'density thermal_conductivity specific_heat youngs_modulus poissons_ratio'\n        prop_values = '0.0000045 0.0057 544 1.16E+05 0.3'\n        block = '1 2'\n    [../]\n    [GapTransferMaybe]\n        type = GapConductance\n        variable = T_Upper\n        boundary = 'Upper_back'\n        paired_boundary = 'Lower_front'\n        gap_conductivity = 0.0057\n        emissivity_primary = 0.0\n        emissivity_secondary = 0.0\n        gap_geometry_type = PLATE\n        gap_temp = T_Lower\n        quadrature = True\n        warnings = True\n    []\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    automatic_scaling = True\n    nl_max_its = 50\n    l_max_its = 200\n    num_steps = 40\n    dt = 0.5\n[]\n\n[Outputs]\n    [outfile]\n        type = Exodus\n        file_base = \"ThermalContactTesting/SimpleThermalGlueTest\"\n        append_date = true\n    []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2906386",
                          "updatedAt": "2022-06-08T14:22:34Z",
                          "publishedAt": "2022-06-08T14:22:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I am not sure if you want to use or to implement a gap conductance model. If you want to use it, I'd just look into the tests in the MOOSE repository. For example, large_gap_heat_transfer_test_cylinder.i in the heat conduction module uses the thermal action to establish gap heat transfer physics in a problem:\n  [RPV_gap]\n    type = GapHeatTransfer\n    gap_geometry_type = 'CYLINDER'\n    emissivity_primary = 0.8\n    emissivity_secondary = 0.8\n    variable = Tsolid\n    primary = 'core_outer'\n    secondary = 'rpv_inner'\n    gap_conductivity = 0.1\n    quadrature = true\n    cylinder_axis_point_1 = '0 0 0'\n    cylinder_axis_point_2 = '0 0 5'\n  []\n[]\n\nThe action creates the gap conductance material, or a constant gap conductance, if a constant value is provided through the action -- this is typically done for many MOOSE physics.",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2907093",
                          "updatedAt": "2022-06-08T15:49:19Z",
                          "publishedAt": "2022-06-08T15:49:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cylindrical shell example",
          "author": {
            "login": "hrishiv"
          },
          "bodyText": "I was performing a simulation with a cylindrical shell model and got some errors so I decided to look into one of the test examples https://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/test/tests/shell/static/pinched_cylinder_symm.i\nPinching of the cylinder is modeled by applying load at the side (1,0,1) in the X direction and the result is correct. Instead, I tried to simulate the same pinching in the Y direction by applying a load at the top (0,1,1) in the Y direction. I expected the displacement at the point of application of the load (0,1,1) in the Y direction in my simulation to be equal to the displacement in the X direction at the point of application of a load (1,0,1) of the example as I just changed the application of pinching force from the side to the top. However, I saw different results. Can someone please help me with this? Thank you in advance.",
          "url": "https://github.com/idaholab/moose/discussions/19580",
          "updatedAt": "2022-06-25T05:39:56Z",
          "publishedAt": "2021-12-08T15:21:41Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you please paste your updated DiracKernel for the source?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-1777046",
                  "updatedAt": "2022-06-09T12:57:51Z",
                  "publishedAt": "2021-12-09T06:42:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "or the whole input file if you have changed anything else",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-1777166",
                          "updatedAt": "2022-06-09T12:58:00Z",
                          "publishedAt": "2021-12-09T07:20:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "Hi, I just changed DiracKernel and the postprocessor.\n[DiracKernels]\n[./top]\ntype = ConstantPointSource\nvariable = disp_y\npoint = '0 1 1'\nvalue = -2.5 # P = 10\n[../]\n[]\n[Postprocessors]\n[./disp_y]\ntype = PointValue\npoint = '0 1 1'\nvariable = disp_y\n[../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-1780709",
                          "updatedAt": "2022-06-09T12:57:57Z",
                          "publishedAt": "2021-12-09T17:17:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This seems right. Not sure why the solution is not symmetric.\nGit blame says @sveerara and @bwspenc should know",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-1782722",
                          "updatedAt": "2022-06-09T12:58:03Z",
                          "publishedAt": "2021-12-10T00:00:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "Also from what have I observed using shell elements in MOOSE in different orientations has been causing some issues. When I have a model like a box that would have shell elements in two perpendicular planes YZ and XZ, the solution is wrong (compared to ABAQUS) when I specify the same two rotation variables 'rotx' and 'roty' for both the planes. When I divided the model into two blocks and used 'rotz and roty' as the variables for a block in plane YZ and 'rotx and rotz' variables for the block in XZ plane I got displacements similar to ABAQUS for static case (I still have not got similar result for dynamic case using different block too).",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-1782793",
                          "updatedAt": "2022-06-09T12:58:13Z",
                          "publishedAt": "2021-12-10T00:33:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@jain651 any thoughts on this?",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-2909857",
                          "updatedAt": "2022-06-09T01:48:51Z",
                          "publishedAt": "2022-06-09T01:48:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jain651"
                          },
                          "bodyText": "Hrishiv is here at INL as an intern with us. We, including Ben, are looking at this problem together. We will post our findings with this problem as soon as possible.",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-2914240",
                          "updatedAt": "2022-06-09T14:39:26Z",
                          "publishedAt": "2022-06-09T14:39:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "mooseInfo question",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "Is there a way for a message sent to mooseInfo() to output each time it's called? Looks like it's wrapped in a \"mooseDoOnce\" call which I assume does what it says?\nFor instance, I'm using a Terminator to cut the time step when a material model needs it (using MaterialTimeStepPostprocessor) and I'd like it to print the Terminator message each time rather than just the first time.",
          "url": "https://github.com/idaholab/moose/discussions/20932",
          "updatedAt": "2022-06-11T01:27:57Z",
          "publishedAt": "2022-05-02T18:02:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNot currently. We have a PR up to improve that system and be able to output things on a customizable schedule.\n#17897\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2675757",
                  "updatedAt": "2022-06-11T01:27:57Z",
                  "publishedAt": "2022-05-02T18:42:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Thanks. Looks like that PR is a bit old but I hope it gets through because the functionality would be useful.",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2676269",
                          "updatedAt": "2022-06-11T18:24:49Z",
                          "publishedAt": "2022-05-02T20:12:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If this PR doesnt make it in I ll make another one next week. We have a few users for this functionality at this point.",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2676352",
                          "updatedAt": "2022-07-10T05:24:34Z",
                          "publishedAt": "2022-05-02T20:30:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We're still working on it. I ll try to get you an update on this next week",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2755401",
                          "updatedAt": "2022-07-10T05:24:35Z",
                          "publishedAt": "2022-05-15T21:01:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this PR is stalled as its makers arent happy with it. I have another idea for this but will take some free time.",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2909753",
                          "updatedAt": "2022-06-09T01:23:41Z",
                          "publishedAt": "2022-06-09T01:23:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "btw we're not going to change mooseInfo's behavior. Use a _console output for your needs",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2909759",
                          "updatedAt": "2022-06-09T01:24:36Z",
                          "publishedAt": "2022-06-09T01:24:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Got it, thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2913041",
                          "updatedAt": "2022-06-09T11:57:18Z",
                          "publishedAt": "2022-06-09T11:57:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Questions about the dependence of elastic tensor on phase field variable",
          "author": {
            "login": "ZhigangPu"
          },
          "bodyText": "Dear,\nI am new to the moose and right now I am trying to couple the phase field and tensor mechanics to simlulate dendrite growth in elastic field. I am reading examples in the  modules/phase_field-mechanics/combined directory. I am confused about the way Moose specify the elastic tensor's dependence and strain's dependence on phase field varible.\nFor example, in the input file Conserved.i,\nFor elastic tensor, no field is reserved for the choice of phase variable in following section, but indeed elastic tensor is different across different phase field.\n\nFor strain and elastic energy, args are specified as c in the correponding section, but I cannot understand the way c interacts with strain and energy. I've read some official document on ComputeVariableEigenstrain and ElasticEnergyMaterial, but there seems to be no direct explanation.\n\nAny reponse will be highly appreciated!\nBest,\nZhigang",
          "url": "https://github.com/idaholab/moose/discussions/19053",
          "updatedAt": "2022-06-09T08:17:59Z",
          "publishedAt": "2021-10-11T12:48:22Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Just by reading that input file it seems to me that\n\nthe eigenstrain is defined as 0.1 * c * I, where I is the second order identity tensor;\nthe strain purely depends on the eigenstrain, hence the strain is defined as -0.1 * c * I; Nope, there's also elastic deformation.\nthe elasticity tensor is homogeneous (doesn't depend on c).",
                  "url": "https://github.com/idaholab/moose/discussions/19053#discussioncomment-1461670",
                  "updatedAt": "2022-06-09T07:52:52Z",
                  "publishedAt": "2021-10-12T00:10:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "BTW, I'm not a fan of coupling \"Eulerian\" dendritic growth with \"Lagrangian\" mechanics. It's not as simple as it seems to be.",
                          "url": "https://github.com/idaholab/moose/discussions/19053#discussioncomment-1461681",
                          "updatedAt": "2022-06-09T07:52:53Z",
                          "publishedAt": "2021-10-12T00:14:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ZhigangPu"
                          },
                          "bodyText": "Dear hugary:\nThanks for the comments. Yeah, but it's wired the elasticity tensor is homogeneous since there are two saperate phases. As for the difficulty of coupling between Eulerian method and Lagrangian method, thanks for pointing out and I will think more about it.\nBest\nzhigang",
                          "url": "https://github.com/idaholab/moose/discussions/19053#discussioncomment-1461820",
                          "updatedAt": "2022-06-09T07:52:54Z",
                          "publishedAt": "2021-10-12T01:26:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think that's a perfectly valid example for demonstration purposes. If you want to have variable dependent elasticity tensor you can use ComputeVariableElasticityTensor or something like that, I don't remember the exact name.",
                          "url": "https://github.com/idaholab/moose/discussions/19053#discussioncomment-1461885",
                          "updatedAt": "2022-06-09T07:52:53Z",
                          "publishedAt": "2021-10-12T01:46:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ZhigangPu"
                          },
                          "bodyText": "Dear hugary:\nGreat! Then I'll try the ComputeVariableElasticityTensor object.\nMany thanks for your kindly remind! I really need this.\nBest,\nzhigang",
                          "url": "https://github.com/idaholab/moose/discussions/19053#discussioncomment-1462378",
                          "updatedAt": "2022-10-14T00:20:07Z",
                          "publishedAt": "2021-10-12T05:21:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "biaogxb"
                  },
                  "bodyText": "Hello, can I have your wechat or Facebook? I'm also using moose to do dendrite problems. Can I have an in-depth exchange with you\uff1flooking forward to your reply.\nmy emial \uff1a709806584@qq.com",
                  "url": "https://github.com/idaholab/moose/discussions/19053#discussioncomment-2911649",
                  "updatedAt": "2022-06-09T08:18:02Z",
                  "publishedAt": "2022-06-09T08:17:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Different eigenstrain at different block",
          "author": {
            "login": "zx1987"
          },
          "bodyText": "Dear colleagues,\nI am trying to setup a multi-app simulation, where the current focus is on the sub-app which is a mechanical problem but used temperature and cure info passed from the master app. For this sub-app, I have block 0 and 1, where block 1 has temperature and degree of cure, and correspondingly thermal and chemical strains; block 0 only has temperature so only thermal expansion. As a first try, I only turn the thermal strain and chemical strain in block 1 on, but turn the thermal strain in block 0 off.\nIn the tensor mechanics module, I have something like:\n  [TensorMechanics]`\n    `[Master]\n      [DCPD]\n      incremental = `true`\n        new_system = true\n        formulation = UPDATED\n        volumetric_locking_correction = false\n        generate_output = 'cauchy_stress_xx cauchy_stress_yy cauchy_stress_xy '\n                          'strain_xx strain_yy strain_xy'\n        block = 1\n        eigenstrain_names = 'thermalstrain chemicalstrain'  %---- Consider thermal and chemical strains on for block 1\n      []\n      [Substrate]\n        incremental = true\n        new_system = true\n        formulation = UPDATED\n        volumetric_locking_correction = false\n        generate_output = 'cauchy_stress_xx cauchy_stress_yy cauchy_stress_xy '\n                          'strain_xx strain_yy strain_xy'\n        block = '0'   %--- no thermal strain at this point\n      []\n    []\n  []\n[]\n\nI them define my material properties:\n[Materials]\n  [./Elasticity_tensor_DCPD]\n    type = ComputeIsotropicElasticityTensorTempCureDependent %-- we coded a simple temp- and cure-dependent elasticity tensor\n    youngs_modulus = 2.1e9\n    poissons_ratio = 0.416\n    temperature = Temperature\n    cure = Cure\n     block = 1\n  [../]\n\n  [elasticity_tensor_Substrate]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 200e9\n    poissons_ratio = 0.3\n    temperature = Temperature\n     block = 0\n  []\n  [compute_stress]\n    type = ComputeLagrangianLinearElasticStress\n  []\n\n  [thermal_expansion_strain]\n     type = ComputeInstantaneousCureTempDependentThermalExpansionFunctionEigenstrain %-- we coded a simple temp- and cure-dependent thermal expansion coefficient\n     block = 1\n     stress_free_temperature = 23.0\n     tg0= -137.0  # parameter tg0\n     tginf= 140.0  # parameter tg_inf\n     lambda=0.7   # parameter lambada\n     reference_cure = 0.28\n     thermal_expansion_coeff_gel_belowtg  = 35.0e-5 # thermal expansion coefficient of gel\n     thermal_expansion_coeff_gel_abovetg  = 56.72e-5 # thermal expansion coefficient of gel\n     thermal_expansion_coeff_pdcpd_belowtg = 12.91e-5  # thermal expansion coefficient of cured dcpd (poly-dcpd) below tg\n     thermal_expansion_coeff_pdcpd_abovetg = 25.58e-5 # thermal expansion coefficient of cured dcpd (poly-dcpd) above tg\n     temperature = Temperature\n     cure=Cure\n     eigenstrain_name = thermalstrain\n   []\n \n  [chemical_shrinkage_strain]\n    type = ComputeInstantaneousCureTempDependentChemicalShrinkageFunctionEigenstrain %-- we coded a simple temp- and cure-dependent chemical shrinkate coefficient\n    block = 1\n    stress_free_cure = 0.28\n    low_curerate=2.0\n    high_curerate=6\n    ccs_low_curerate=-0.0512\n    ccs_high_curerate=-0.3\n    ccs_ref=-0.3\n    para_f=0.1\n    para_f_ccs=55.5\n    cure = Cure\n    eigenstrain_name = chemicalstrain\n  []\n\n[]\n\nThere is an error message says something : Material property 'thermalstrain', requested by 'DCPD_strain' is not defined on block Substrate_QUAD4\nThis is suggesting to me that block = 1 in the DCPD block of the TensorMechanics is not taking effect, but rather, the code thinks the eigenstasins are defined in all the blocks.\nI may misunderstood something, but does any one has any experience with this, or could suggest what is the right way to assign different eigenstrains in each block? Thank you!\nBest,\nXiang",
          "url": "https://github.com/idaholab/moose/discussions/20952",
          "updatedAt": "2022-06-09T07:05:26Z",
          "publishedAt": "2022-05-04T22:17:30Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dschwen could you please help Xiang with the block restriction of the action",
                  "url": "https://github.com/idaholab/moose/discussions/20952#discussioncomment-2698086",
                  "updatedAt": "2022-06-09T07:05:36Z",
                  "publishedAt": "2022-05-06T03:42:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@jiangwen84 would you know what's wrong with the block restriction here?",
                          "url": "https://github.com/idaholab/moose/discussions/20952#discussioncomment-2755414",
                          "updatedAt": "2022-06-09T07:05:36Z",
                          "publishedAt": "2022-05-15T21:07:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@zx1987 Just define a 0 thermal strain property using a constant material for now\nhttps://mooseframework.inl.gov/docs/site/source/materials/GenericConstantMaterial.html",
                  "url": "https://github.com/idaholab/moose/discussions/20952#discussioncomment-2909764",
                  "updatedAt": "2022-06-09T01:26:48Z",
                  "publishedAt": "2022-06-09T01:26:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Thank you Guillaume for your help. We will try this out and let you know!",
                          "url": "https://github.com/idaholab/moose/discussions/20952#discussioncomment-2910460",
                          "updatedAt": "2022-06-09T04:27:22Z",
                          "publishedAt": "2022-06-09T04:27:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Getting warning while using mesh adaptivity",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE Experts\nI am trying to implement the mesh adaptivity as follows:\n[Adaptivity]\n  marker = errorfrac \n  steps = 3\n  [./Indicators]\n    [./error]\n      type = GradientJumpIndicator\n      variable = damage\n      outputs = none\n    [../]\n  [../]\n\n  [./Markers]\n  [./errorfrac]\n      type = ValueThresholdMarker\n      coarsen = 0\n      variable = damage\n      refine = 0.9\n      outputs = none\n    [../]\n  [../]\n[]\n\nHowever, I am getting the following error:\nUsing EXPERIMENTAL Stateful Material Property projection with Adaptivity!\n\nWarning! Mesh re-partitioning is disabled while using stateful material properties!  This can lead to large load imbalances and degraded performance!!\n\nCan you please let me know what does it mean and how to avoid it?\nThanks in advance.\nBest\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/21213",
          "updatedAt": "2022-06-09T01:50:33Z",
          "publishedAt": "2022-06-05T14:45:43Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe issue is that support for stateful properties (properties that depend on prior states) is growing but is not complete with regards to more advanced features like re-partitioning.\nSee this issue for more details:\n#4532\nI think there's a more recent issue too but cant seem to find it right now\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21213#discussioncomment-2887027",
                  "updatedAt": "2022-06-05T18:41:01Z",
                  "publishedAt": "2022-06-05T18:41:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Hello @GiudGiud\nThank you very much.\nI think the only parameter is History field in phase field fracture.\nRest are all constants in my chemo-mechanical-fracture model.\nCan you suggest any other alternative to use adaptive mesh?\nBest\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/21213#discussioncomment-2887333",
                          "updatedAt": "2022-06-05T20:38:45Z",
                          "publishedAt": "2022-06-05T20:37:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It's not barring you from using adaptivity here, it's just disabling re-partitioning which may lower performance if the load on each process becomes unequal.\nI think the way forward is to take the performance hit until we fix this. It's on the schedule for next FY",
                          "url": "https://github.com/idaholab/moose/discussions/21213#discussioncomment-2887666",
                          "updatedAt": "2022-06-05T23:07:24Z",
                          "publishedAt": "2022-06-05T23:07:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "by performance hit I mean dont re-partition. Adaptivity should be fine though keep an eye out since it s experimental as mentioned in the message",
                          "url": "https://github.com/idaholab/moose/discussions/21213#discussioncomment-2909863",
                          "updatedAt": "2022-06-09T01:50:31Z",
                          "publishedAt": "2022-06-09T01:50:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "TimeStepper not updating dt after --recover",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "I am currently running a long run with checkpoints enabled. When the run is stopped, and then recovered using the flag --recover in the command line it starts back up again at the last checkpoint and starts solving seemingly fine.\nHowever, the problem is that the TimeStepper that updates dt based on postprocessor information does not update the dt anymore, and is constant at the initial guess of dt.\nis there a specific reason why this is the case? and how can I enable it?\nThanks in advance",
          "url": "https://github.com/idaholab/moose/discussions/21131",
          "updatedAt": "2022-06-25T05:40:09Z",
          "publishedAt": "2022-05-25T12:36:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI just checked on the test we have for it and it works.\nThe time stepper should not have changed, it should keep using the postprocessor value.\nWhat does your executioner block look like ?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21131#discussioncomment-2823073",
                  "updatedAt": "2022-05-25T20:45:30Z",
                  "publishedAt": "2022-05-25T20:45:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "I have multiple subapps\nthis is the main\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'    # PJFNK JFNK NEWTON FD LINEAR\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold'\n  petsc_options_value = 'hypre    boomeramg      31                 0.7'\n  nl_rel_tol = 1e-10  # first iteration tolerance/current\n  nl_abs_tol = 1e-5 # current iteration tolerance\n  l_max_its = 1000\n  num_steps = 100000\n  start_time = 5000\n  # dtmin = .1\n  [./TimeStepper]\n    type = TransientTransport\n    postprocessor = rss_max\n    cfl = 0.45\n    dt = 1e-6\n    dt_max = 50\n    n = 20\n    n_slip = 12\n  [../]  \n[]\n\n1st subapp\n[Executioner]\n  type = Transient\n  solve_type = 'LINEAR'                  # PJFNK JFNK NEWTON FD LINEAR\n  l_tol = 1.0e-10                         # Linear Tolerance         : 1.0e-5\n  l_abs_tol = 1.0e-8\n  l_max_its = 10000                       # Max Linear Iterations    : 10000\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold'\n  petsc_options_value = 'hypre    boomeramg      31                 0.7'\n  [./TimeStepper]\n    type = TransientTransport\n    postprocessor = rss_max\n    cfl = 0.45\n    dt = 1e-6\n    dt_max = 50\n    n_slip = 12\n  [../] \n  num_steps = 1000\n\n  automatic_scaling = true\n  compute_scaling_once = true \n[]\n\n2nd subapp\n[Executioner]\n  type = Transient\n  solve_type = 'LINEAR'                  # PJFNK JFNK NEWTON FD LINEAR\n  l_tol = 1.0e-11                         # Linear Tolerance         : 1.0e-5\n  l_max_its = 10000                       # Max Linear Iterations    : 10000\n  petsc_options_iname = '-pc_type   -pc_hypre_type  -pc_hypre_boomeramg_strong_threshold'\n  petsc_options_value = 'hypre      boomeramg       0.7'\n\n  [./TimeIntegrator]\n    # type = ImplicitEuler\n    # type = BDF2\n    #type = CrankNicolson\n    # type = ImplicitMidpoint\n    # type = LStableDirk2\n    # type = LStableDirk3\n    # type = LStableDirk4\n    # type = AStableDirk4\n    #\n    # Explicit methods\n    type = ActuallyExplicitEuler\n    # type = ExplicitEuler\n    #type = ExplicitMidpoint\n    # type = Heun\n    # type = Ralston\n  [../]\n  [./TimeStepper]\n    type = TransientTransport\n    postprocessor = rss_maxs\n    cfl = 0.45\n    dt = 1e-6\n    dt_max = 50\n    n_slip = 12\n  [../] \n  # scheme = implicit-euler\n[]\n\npardon the long reply.\nThe time stepping seems to be working fine when it is launched properly, and stops functioning when I recover it. by stops working I mean it uses the initial dt=1e-6 all the time.\nThis timestepper is custom, and I have it print out the calculated dt in the terminal, so it does calculate a new dt, but is not used.\nlet me know if I need to provide more details.",
                          "url": "https://github.com/idaholab/moose/discussions/21131#discussioncomment-2827456",
                          "updatedAt": "2022-05-26T12:51:18Z",
                          "publishedAt": "2022-05-26T12:51:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So when you print the time step, do all 3 timesteppers return something bigger than 1e-6 ?\nThe main app is usually the one that imposes the shortest timestep, though the subapps may be subcycling.\nI think at this point I would want to see the log of the execution.",
                          "url": "https://github.com/idaholab/moose/discussions/21131#discussioncomment-2828628",
                          "updatedAt": "2022-05-26T15:51:32Z",
                          "publishedAt": "2022-05-26T15:51:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@KhaledNabilSharafeldin any update on this?",
                          "url": "https://github.com/idaholab/moose/discussions/21131#discussioncomment-2909825",
                          "updatedAt": "2022-06-09T01:41:13Z",
                          "publishedAt": "2022-06-09T01:41:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Plastic parameters that depend on space and time",
          "author": {
            "login": "Hadrien89"
          },
          "bodyText": "Hello,\nI\u2019m trying to run slope stability simulations in tensor mechanics. In particular, I\u2019m using the shear strength reduction method on a heterogenous material. For this method, I would need to have the friction angle and the cohesion in the Mohr-Coulomb model that both depend on space (given by a csv file) and time (all the Mohr-Coulomb parameters are reduced by the same factor at every time step).\nI have tried to follow the solution used in Porous Flow to produce a heterogeneous reservoir:\nhttps://mooseframework.inl.gov/modules/porous_flow/heterogeneous_models.html\nThis solution does not to be directly applicable in my case as the materials properties in this example that change with space (permeability and porosity) are declared as Auxvariables and are used in a Material. However, it seems that I cannot used Auxvariables in a UserObject, which is the current way to define the Mohr-Coulomb properties. I get the following error when compiling if I try to create a Userobject that could use the Auxvariable of the friction angle:\nerror: use of undeclared identifier 'coupledValue'; did you mean 'coupledScalar'?\nIt seems that only Scalar variables can be used in a UserObject.\nDo you have some ideas how I could have those parameters depending on space and time (without changing the whole return map algorithm)?\nThanks for your help!",
          "url": "https://github.com/idaholab/moose/discussions/21063",
          "updatedAt": "2022-06-25T05:40:21Z",
          "publishedAt": "2022-05-20T21:24:40Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou need your class to be using the Coupleable interface to be able to use the coupledValue routine. This interface is inherited by Element/Side/Interface/etcUserObject, not by UserObject the parent class of all of these.\nIf your UO fits in one of these categories, please inherit those instead.\nFor parameters depending on space and time, you can use a Function if they are known at the time you are writing your input file. If they are to be computed during the simulation you can use:\n\na material property\nan auxiliary variable if you dont need to take derivatives into account / the terms are not part of forming a Jacobian with automatic differentiation. OR if you need tight control on when to update the quantity (linear / nonlinear iterations / once a timestep etc)\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21063#discussioncomment-2796291",
                  "updatedAt": "2022-05-21T15:43:27Z",
                  "publishedAt": "2022-05-21T15:34:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Hadrien89"
                          },
                          "bodyText": "Hi Guillaume,\nThanks a lot for your quick reply!\nRegarding the solution you propose for the parameters that depend on space and time, it is what I\u2019m trying to do. I\u2019m using a function that is changing an AuxVariable for each parameter, but I\u2019m stuck at using this AuxVar in a UO\u2026\nTo be more precise, the UO I have created to have the plastic properties coming from an AuxVariable is a modified copy of the UO \u201cTensorMechanicsHardeningConstant\u201d (which takes constant parameters as input). The parent class of all UO that defines plastic parameters is \u201cTensorMechanicsHardeningModel\u201d, which inherits from GeneralUserObject and, as you suggested, it seems to be the issue here.\nI have tried to have \u201cTensorMechanicsHardeningModel\u201d inherit from Element/Side/Interface/etcUserObject instead of GeneralUserObject, but it is creating 20 errors when compiling.\nI also tried to #include different files (like \"MooseVariable.h\" and others) directly in the UO I have created, but it didn\u2019t change anything.\nI apologise my knowledge of C++ is quite limited...\nHadrien",
                          "url": "https://github.com/idaholab/moose/discussions/21063#discussioncomment-2800779",
                          "updatedAt": "2022-05-22T23:09:37Z",
                          "publishedAt": "2022-05-22T23:09:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThe easiest way might just be to add the Coupleable interface as a parent class for your class then.\nCan you try that?\nSideUserObject.h/C or any of the others I mentioned will show the two lines you need to add to do this.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21063#discussioncomment-2800808",
                          "updatedAt": "2022-05-22T23:27:34Z",
                          "publishedAt": "2022-05-22T23:27:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@Hadrien89 any luck with this?",
                          "url": "https://github.com/idaholab/moose/discussions/21063#discussioncomment-2909813",
                          "updatedAt": "2022-06-09T01:39:05Z",
                          "publishedAt": "2022-06-09T01:39:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "About ComputeSmearedCrackingStress",
          "author": {
            "login": "Xelver"
          },
          "bodyText": "Hi,\nI'd like to use ComputeSmearedCrackingStress with AbruptSoftening to compute the failure of ceramic materials. I tried to familiarize myself with this function through the test example  \"cracking.i\".  The mesh file used in this example was a 1x1x1 cube with single element and the failure stress was 1.68e6 Pa.\nWhen I tried to replace the mesh file with another one, which was also a 1x1x1 cube but with more elements, the failure stress decreased. The more elements, the more the stress dropped (The failure stress was 4.17e5 Pa for 1000 elements).  I'm confused, because normally the failure stress should not change.",
          "url": "https://github.com/idaholab/moose/discussions/20546",
          "updatedAt": "2022-06-25T05:40:37Z",
          "publishedAt": "2022-03-14T09:14:40Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@jiangwen84",
                  "url": "https://github.com/idaholab/moose/discussions/20546#discussioncomment-2504970",
                  "updatedAt": "2022-06-25T05:40:25Z",
                  "publishedAt": "2022-04-05T03:19:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@Xelver is this solved?\nIs the failure stress converging as you refine the mesh?\nAre you using the uniform refinement feature?\nWhat value do you expect for the failure stress?",
                          "url": "https://github.com/idaholab/moose/discussions/20546#discussioncomment-2754453",
                          "updatedAt": "2022-06-25T05:40:25Z",
                          "publishedAt": "2022-05-15T15:17:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Xelver"
                          },
                          "bodyText": "Thanks for your reply.\nActually, I then have tried another way instead of ComputeSmearedCrackingStress.\nThe failure stress is converging as the mesh refinement, and I'm using the uniform refinement.\nFrom my point of view, the failure stress should remain the same as the mesh is refined (1.68e6 Pa).",
                          "url": "https://github.com/idaholab/moose/discussions/20546#discussioncomment-2756086",
                          "updatedAt": "2022-06-25T05:40:25Z",
                          "publishedAt": "2022-05-16T01:28:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@dschwen thoughts on this?",
                          "url": "https://github.com/idaholab/moose/discussions/20546#discussioncomment-2760245",
                          "updatedAt": "2022-06-25T05:40:26Z",
                          "publishedAt": "2022-05-16T14:28:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@Xelver Could you send us your input file with ComputeSmearedCrackingStress? @bwspenc and I would like to take a look.",
                          "url": "https://github.com/idaholab/moose/discussions/20546#discussioncomment-2760725",
                          "updatedAt": "2022-06-25T05:40:28Z",
                          "publishedAt": "2022-05-16T15:28:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Xelver"
                          },
                          "bodyText": "OK, here's the input file. The output corresponding to the input file is as follow:\n\n# Simple pull test for cracking.\n# The stress increases for two steps and then drops to zero.\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 10\n  ny = 10\n  nz = 10\n  #file = cracking_test.e\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Functions]\n  [./displ]\n    type = PiecewiseLinear\n    x = '0 1 2 3  4'\n    y = '0 1 0 -1 0'\n  [../]\n[]\n\n[Modules/TensorMechanics/Master]\n  [./all]\n    strain = FINITE\n    add_variables = true\n    generate_output = 'stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx strain_xx'\n  [../]\n[]\n\n[BCs]\n  [./pull]\n    type = FunctionPresetBC\n    variable = disp_x\n    boundary = right #4\n    function = displ\n  [../]\n  [./left]\n    type = PresetBC\n    variable = disp_x\n    boundary = left#1\n    value = 0.0\n  [../]\n  [./bottom]\n    type = PresetBC\n    variable = disp_y\n    boundary = bottom#2\n    value = 0.0\n  [../]\n  [./back]\n    type = PresetBC\n    variable = disp_z\n    boundary = back#3\n    value = 0.0\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 2.8e7\n    poissons_ratio = 0\n  [../]\n  [./elastic_stress]\n    type = ComputeSmearedCrackingStress\n    cracking_stress = 1.68e6\n    softening_models = abrupt_softening\n  [../]\n  [./abrupt_softening]\n    type = AbruptSoftening\n  [../]\n[]\n\n[Postprocessors]\n  [./strain_xx]\n    type = ElementAverageValue\n    variable = strain_xx\n    execute_on = 'initial TIMESTEP_END'\n  [../]\n  [./stress_xx]\n    type = ElementAverageValue\n    variable = stress_xx  #In this case, the maximum stress_xx is 4.168e5 at 0.015s.\n    execute_on = 'initial TIMESTEP_END'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -sub_pc_type'\n  petsc_options_value = '101                asm      lu'\n\n  line_search = 'none'\n\n  l_max_its = 100\n  nl_max_its = 100\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-8\n  l_tol = 1e-5\n  start_time = 0.0\n  end_time = 0.1\n  dt = 0.005\n[]\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/20546#discussioncomment-2763851",
                          "updatedAt": "2022-06-25T05:40:28Z",
                          "publishedAt": "2022-05-17T01:29:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "any updates on this?",
                          "url": "https://github.com/idaholab/moose/discussions/20546#discussioncomment-2909778",
                          "updatedAt": "2022-06-09T01:31:09Z",
                          "publishedAt": "2022-06-09T01:31:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}