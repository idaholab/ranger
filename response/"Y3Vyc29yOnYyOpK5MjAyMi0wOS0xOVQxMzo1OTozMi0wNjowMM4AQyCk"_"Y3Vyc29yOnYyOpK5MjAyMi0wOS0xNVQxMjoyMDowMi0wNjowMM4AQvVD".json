{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOS0xNVQxMjoyMDowMi0wNjowMM4AQvVD"
    },
    "edges": [
      {
        "node": {
          "title": "Issues With Running Sintering Model",
          "author": {
            "login": "ibuhari86"
          },
          "bodyText": "Hello,\nI am trying to run one of the input files from @SudiptaBiswas 2018 paper but I am running into issues.\nSince I am new to the MOOSE/GitHub environment, I started off with the first tutorial on app development, but since I am not trying to create a new application for a starter, I intended to run the input file \"sintering_test1_isomob.i\" from tests in Crow. I downloaded the crow as a zipped file, started with the creation of a new app named \"crow\" by following the first few steps of tutorial one (image 1 attached), and then pasting the content of the downloaded crow into the new crow I created. However, when I tried to execute the command cd ~/projects/babbler make -j4 it does not create the crow-opt file needed to run the app. I start to get fatal errors as seen in the second and third images.\nAny ideas what I might be missing? Or is there a better way to achieve this? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/21523",
          "updatedAt": "2022-09-19T18:36:20Z",
          "publishedAt": "2022-07-06T22:33:04Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "Hi @ibuhari86, You will need to switch to devel branch to compile the application. Cloning the application instead of using the zip might work better.",
                  "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3095779",
                  "updatedAt": "2022-07-06T22:36:22Z",
                  "publishedAt": "2022-07-06T22:36:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ibuhari86"
                          },
                          "bodyText": "Hello @SudiptaBiswas,\nThank you very much for your response. I tried cloning and when I executed the same command it seemed to be compiling alright at the start but exited with one of the fatal errors I encountered above.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3095902",
                          "updatedAt": "2022-07-06T23:07:51Z",
                          "publishedAt": "2022-07-06T23:07:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "You need to switch to devel branch. Do git checkout devel before compiling.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3096053",
                          "updatedAt": "2022-07-06T23:29:49Z",
                          "publishedAt": "2022-07-06T23:27:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ibuhari86"
                          },
                          "bodyText": "I switched to devel branch, tried to compile and run into this (images 1 & 2). I had a similar issue when I was installing MOOSE for the first time, and I needed to delete idaholab from mamba list and reinstall the mamba moose environment and that solved the issue. idaholab is no linger an output of cat ~/.condarc, so I tried reinstalling the mamba package again but the error is persistent (image 3).",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3096286",
                          "updatedAt": "2022-07-07T00:30:28Z",
                          "publishedAt": "2022-07-07T00:30:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "This indicates that the libmesh is not built. Try running the libmesh update script.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3097117",
                          "updatedAt": "2022-07-07T04:38:13Z",
                          "publishedAt": "2022-07-07T04:38:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ibuhari86"
                          },
                          "bodyText": "Hi @SudiptaBiswas,\nAre you talking about this script\ncd ~/projects/moose\n./scripts/update_and_rebuild_libmesh.sh?\n\n\nIf it is, then I run it and still could not compile.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3097208",
                          "updatedAt": "2022-07-07T05:02:57Z",
                          "publishedAt": "2022-07-07T05:02:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ibuhari86"
                          },
                          "bodyText": "Now, when I run make -j4 in the moose environment (rather than base), Error 127 disappears and another (Error 1) appears as shown. ./run_tests -j8 then resulted in FAILED tests.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3097528",
                          "updatedAt": "2022-07-07T06:09:38Z",
                          "publishedAt": "2022-07-07T06:09:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "This seems like a linking error. You will have to clean your directory before rebuilding the application. Try make clobberall first within the application and you might also need to perform git clean -xfd ( caution: this will delete any unchecked files, make sure to commit any changes you might have before doing this). Then try make again. It also might be a good idea to rebuild a moose module before trying the application.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3101692",
                          "updatedAt": "2022-07-07T16:26:54Z",
                          "publishedAt": "2022-07-07T16:26:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nSo for this last error, you are missing a function definition.\nYou need to have a validParam function in all your materials, just like this (this is a kernel)\nheader:\nclass FVAdvection : public FVFluxKernel\n{\npublic:\n  static InputParameters validParams();\n...\n\nsource:\nInputParameters\nFVAdvection::validParams()\n{\n  InputParameters params = FVFluxKernel::validParams();\n  params.addClassDescription(\n      \"Residual contribution from advection operator for finite volume method.\");\n  params.addRequiredParam<RealVectorValue>(\"velocity\", \"Constant advection velocity\");\n  MooseEnum advected_interp_method(\"average upwind skewness-corrected\", \"upwind\");\n\n  params.addParam<MooseEnum>(\n      \"advected_interp_method\",\n      advected_interp_method,\n      \"The interpolation to use for the advected quantity. Options are \"\n      \"'upwind', 'average' and 'skewness-corrected', with the default being 'upwind'.\");\n  return params;\n}\n\nThe previous validParam syntax is deprecated, you need to update all of CrowApp to use the new one.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3101696",
                          "updatedAt": "2022-07-07T16:27:26Z",
                          "publishedAt": "2022-07-07T16:27:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "also you need to be more careful with the build instructions. You previously tried to build libmesh independently, but you are also trying to use the mamba install. Both methods are incompatible (except for expert users, they can be made to work together) and may lead to compiling errors.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3101711",
                          "updatedAt": "2022-07-07T16:29:00Z",
                          "publishedAt": "2022-07-07T16:28:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ibuhari86"
                          },
                          "bodyText": "This seems like a linking error. You will have to clean your directory before rebuilding the application. Try make clobberall first within the application and you might also need to perform git clean -xfd ( caution: this will delete any unchecked files, make sure to commit any changes you might have before doing this). Then try make again. It also might be a good idea to rebuild a moose module before trying the application.\n\nHi @SudiptaBiswas, by your last statement, did you mean reinstalling the MOOSE environment again from scratch? I did make clobberall and git clean -xfd but I am still getting Error 1.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3102022",
                          "updatedAt": "2022-07-07T17:21:15Z",
                          "publishedAt": "2022-07-07T17:20:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A 'SplitCHParsed' is not a registered object.",
          "author": {
            "login": "FatimahDzr"
          },
          "bodyText": "Hello everyone,\nI tried to run the code 2015_10_19_FAST_2p_periodic_neckgrowth.i from SudiptaBiswas. Even though Im connected with her directory and linked my moose to GitHub, every time I tried to run the code via UBUNTU and using  ../projects/crow/crow-opt -i 2017_04_06_2p_matrxmob.i command I get this error:\n*** ERROR ***\nA 'SplitCHParsed' is not a registered object.\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\nStack frames: 22\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits, std::allocator > >(std::__cxx11::basic_string<char, std::char_traits, std::allocator >&&)\n3: Factory::reportUnregisteredError(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&) const\n4: Factory::getValidParams(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&)\n5: MooseObjectAction::MooseObjectAction(InputParameters)\n6: AddKernelAction::AddKernelAction(InputParameters)\n7: /mnt/c/For_MOOSE/projects/moose/framework/libmoose-opt.so.0(+0x795588) [0x7fbfd3a39588]\n8: /mnt/c/For_MOOSE/projects/moose/framework/libmoose-opt.so.0(+0x795617) [0x7fbfd3a39617]\n9: ActionFactory::create(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, InputParameters&)\n10: Parser::walkRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >, hit::Node*)\n11: Parser::walk(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, hit::Node*)\n12: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n13: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n14: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n15: Parser::parse(std::vector<std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::allocator<std::__cxx11::basic_string<char, std::char_traits, std::allocator > > > const&)\n16: MooseApp::setupOptions()\n17: MooseApp::run()\n18: main\n19: /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7fbfcc647d90]\n20: __libc_start_main\n21: ../projects/crow/crow-opt(+0x23ef) [0x5645364fd3ef]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\nAs I understand the kernel A 'SplitCHParsed' is not a registered in my Moose library. I would be grateful if you could help me with this error and how to solve that. Is there any approach to adding a kernel to the moose library?",
          "url": "https://github.com/idaholab/moose/discussions/21946",
          "updatedAt": "2022-09-19T18:28:29Z",
          "publishedAt": "2022-08-26T17:51:30Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nso you are using Crow directly?\nyou\u2019re not hitting any error? There were issues like 2 months ago did they get addressed?\ncan you please paste the output \u00b4 ldd crow-opt\u2019\nTo see if the phase field module for linked properly\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3491235",
                  "updatedAt": "2022-08-27T23:50:07Z",
                  "publishedAt": "2022-08-27T23:50:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Also can you more simple input files with crow?",
                          "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3491240",
                          "updatedAt": "2022-08-27T23:53:04Z",
                          "publishedAt": "2022-08-27T23:53:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FatimahDzr"
                          },
                          "bodyText": "I can run the simple examples in the moose example file but for this case, it cannot be run. I downloaded SplitCHParsed kernel and pasted it into files \"include\" and \"src\" to address this issue. It worked and apparently the code can be run but when it reached the kernel \"PolycrystalSinteringKernel\", it stopped and printed\n*** ERROR ***\n/mnt/c/moose/exp/ex10.i:81: missing required parameter 'Kernels/PolycrystalSinteringKernel/type'\nDoc String: \"A string representing the Moose Object that will be built by this Action\"\nI couldn't find that kernel yet. I'm not sure if it is a practical solution to download and put each kernel for running the problem.",
                          "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3597417",
                          "updatedAt": "2022-09-08T16:45:41Z",
                          "publishedAt": "2022-09-08T16:45:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you forgot to specify the type of the object, it s a required parameter\notherwise we dont know what the object is",
                          "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3597897",
                          "updatedAt": "2022-09-08T17:32:38Z",
                          "publishedAt": "2022-09-08T17:32:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FatimahDzr"
                          },
                          "bodyText": "Thank you for your response, at first I tried to create my own application but every time an error appeared. So I used cloning to the Crow git. I cloned to the \"devel\" branch successfully but when I'm going to create crow-opt, this error appears :\n/home/fatimahdzr/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /mnt/c/moose/projects/gav/lib/libCrow-opt.so: **undefined reference to `InputParameters validParams<Material>()'\ncollect2: error: ld returned 1 exit status**\n\nI would be grateful if you could help me with this error.\nRegards",
                          "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3681897",
                          "updatedAt": "2022-09-19T17:29:29Z",
                          "publishedAt": "2022-09-19T15:10:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThis is because Crow has deprecated syntax for valid parameters. see this post\nhttps://mooseframework.inl.gov/newsletter/2020_04.html#!\nWe really want someone to fix this, it keeps coming up\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3683701",
                          "updatedAt": "2022-09-19T18:28:29Z",
                          "publishedAt": "2022-09-19T18:28:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Type for matrix multiplication",
          "author": {
            "login": "philipJFpfahl"
          },
          "bodyText": "Hello,\nI am new to using moose, but I hope this question is not too trivial.\nI would like to weigh a variable with a pre-calculated matrix and calculate a new variable with that.\n$a=Wb$\nwhere $a$ and $b$ would be $N$ dimensional (for each mesh point) and $W$ would be $N \\times N$.\nthis is part of a coupled equation where\n$\\dot{p} = p + a$\nSo far so easy.\nNow I wanted to implement this by defining a material \"W\" and then calling this material later to be consumed by a Kernel doing the matrix multiplication.\nFirst:\nIt seems to me, that such an operation should be rather common. Is there already a module doing that?\nif not:\nHow should I implement the matrix W?\nA Material object seems like the right choice, but I only want to initialize the matrix once. So maybe it's better to write a User object doing that?\nThanks in advance\n``",
          "url": "https://github.com/idaholab/moose/discussions/21752",
          "updatedAt": "2022-09-19T08:10:20Z",
          "publishedAt": "2022-08-02T14:14:23Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou may use a RankTwoTensor to store a matrix.\nWe do have material properties of type rank two tensor.\nSee this example\nhttps://mooseframework.inl.gov/source/materials/ADGenericConstantRankTwoTensor.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3309662",
                  "updatedAt": "2022-08-02T16:40:46Z",
                  "publishedAt": "2022-08-02T16:40:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hello,\nthank you for the fast reply. That is, what I was looking for.\nSo I should make a material, that produces the $W$ matrix and then a kernel that consumes it?\nAnd is it possible to execute the material only at the beginning of my calculations? I tried \"execute_on = INITIAL\" but that does not seem to work for materials.\nI am asking because I am sure what the \"best\" way to do that is.\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3314354",
                          "updatedAt": "2022-08-03T08:36:05Z",
                          "publishedAt": "2022-08-03T08:36:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYes for the material creating / computing it and the kernel consuming / using the value.\nI'm afraid not, we dont really support execution schedules on regular materials (only on functor materials, but we havent added the tensor overloads for these). What you could do is make it depend on copies of the variables, then if those copies are never updated the material properties would be constant.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3316147",
                          "updatedAt": "2022-08-03T12:48:47Z",
                          "publishedAt": "2022-08-03T12:48:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hello,\nso the material object is called, whenever the kernel consumes it? That seems like a substantial computational burden if the material stays constant all the time, especially with a larger mesh. I am also not interested in the shape function of the $W$ matrix (since I already know it).\nIs it better to store the matrix as a  vector?\nIf yes, how would I generate such a vector?\nI could then use it to make the matrix multiplication in the Kernel as a loop.\nFor $N$ mesh points it would be something like this\nfor(int i =0; i < $N \\times N$; i++)\n{\na[_qp] = W[_qp * $N \\times N$ + i] b[i]\n}\nI am wondering why no one uses this kind of operation in MOOSE. Is there a better way to approach this problem?\nAnyway thanks for your help this far.\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3316321",
                          "updatedAt": "2022-08-03T13:09:34Z",
                          "publishedAt": "2022-08-03T13:09:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "If it s constant spatially then you may use the constant_on option to say that it s constant by block and that will make it only be computed once for every element / qp in the block\n\nYou may store it as a vector if you prefer, please have a look at Vector materials instead of tensors then\n\u2026\n Le 3 ao\u00fbt 2022 \u00e0 08:09, philipJFpfahl ***@***.***> a \u00e9crit :\n\n \ufeff\n Hello,\n\n so the material object is called, whenever the kernel consumes it? That seems like a substantial computational burden if the material stays constant all the time, especially with a larger mesh. I am also not interested in the shape function of the $W$ matrix (since I already know it).\n Is it better to store the matrix as a vector?\n If yes, how would I generate such a vector?\n I could then use it to make the matrix multiplication in the Kernel as a loop.\n For $N$ mesh points it would be something like this\n\n for(int i =0; i < $N \\times N$; i++)\n {\n a[_qp] = W[_qp * $N \\times N$ + i] b[i]\n }\n\n I am wondering why no one uses this kind of operation in MOOSE. Is there a better way to approach this problem?\n Anyway thanks for your help this far.\n\n Philip\n\n \u2014\n Reply to this email directly, view it on GitHub, or unsubscribe.\n You are receiving this because you commented.",
                  "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3316565",
                  "updatedAt": "2022-08-03T13:36:12Z",
                  "publishedAt": "2022-08-03T13:36:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nSo I reviewed the problem. I think there was a misunderstanding from my side of how MOOSE handles indexing.\nWhen doing the finite element method you have nodes and elements. The number of nodes is equal to the number of points in your mesh. In MOOSE you integrate over these elements. The _qp index indicates the point in the element on which the integral is supported.\nWhat I need to do has nothing to do with the integral. On each time step, I want to adjust the value of each node point. The adjustment depends on the matrix $W$ and all the other nodal points. In the sense, that the jth node is calculated like this\n$$a_j = \\sum_{k = 1}^N W_{j,k} b_k$$\nwith N nodal points.\nIn a more physical sense, that means, that every point of $a$ depends on all the other points in $b$ multiplied by a weight.\nI am sorry for my misleading question, I didn't know better. Is there a way in MOOSE to solve these kinds of problems?\nThanks again,\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3335298",
                          "updatedAt": "2022-08-05T16:28:07Z",
                          "publishedAt": "2022-08-05T16:28:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you can do that in MOOSE, though I think you'll have to code it\nHave a be an AuxVariable, and the kernel that does this operation an AuxKernel.\nThen you ll want to access\n\na at _qp\nb at k, which will be the index in a loop from 0 to Nqp\nW at the combined index\n\nW can still be a vector or a rank two tensor, as you prefer. If it s constant, GenericConstantRankTwoTensor is still a good choice",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3339483",
                          "updatedAt": "2022-08-07T04:09:54Z",
                          "publishedAt": "2022-08-06T13:04:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey\nI had to try that. The problem remains. I can not access the full value of my Variable b in my Kernel. I checked that it is nodal. I suppose I just struggle with the indexing of $b$ in the Kernel.\nI initialize it with\nconst VariableValue & _b;\nand add it to the parameters\nparams.addRequiredCoupledVar(\"b\", \"This is text\");\n_b(coupledValue(\"b\"))\nin the for loop, I try to index it as _b[k], but it seems to contain only at _b[0] the correct value of the current qp.\nCan you give me a hint on how to access all the variable values in the Kernel?\nThank you very much,\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3349813",
                          "updatedAt": "2022-08-08T13:58:24Z",
                          "publishedAt": "2022-08-08T13:58:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is this a Kernel or an AuxKernel?\nis this 2D or 3D?\nWhich quadrature are you specifying in the Executioner block? Or is it the default?",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3351462",
                          "updatedAt": "2022-08-08T17:26:57Z",
                          "publishedAt": "2022-08-08T17:26:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nit is in an AuxKernel, in 2D.\n[Executioner]\n  type = Transient\n  start_time = 0\n  dt = 0.01\n  num_steps = 2\n  solve_type = 'PJFNK'\n[]\n\nIs there a place where I can read up on this?\nThank you,\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3352430",
                          "updatedAt": "2022-08-08T23:45:17Z",
                          "publishedAt": "2022-08-08T19:53:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hi Philip\nSo you actually wont have access to any other qp for a nodal variable. For an elemental variable you would, all the qp values are computed for the element. But for a nodal variable, the node is a the quadrature point, so there is only one value there.\nYou could try performing this operation with an elemental variable, then projecting it to a nodal variable\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3353995",
                          "updatedAt": "2022-08-09T01:29:50Z",
                          "publishedAt": "2022-08-09T01:29:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nIs it possible, that a kernel gets only handed the nodal position in the mesh and is then able to operate (however) on that node? Therefore it would not possible to access all the nodal values in each kernel. From a parallelization perspective that makes sense, but would make my life much more difficult.\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3355971",
                          "updatedAt": "2022-08-09T08:40:48Z",
                          "publishedAt": "2022-08-09T08:40:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes. For nodes you only get to operate on that node, it's a single quadrature point loop basically\nFor elements you may work with all the quadrature points at once.",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3358525",
                          "updatedAt": "2022-08-09T14:16:36Z",
                          "publishedAt": "2022-08-09T14:16:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "I see. Is there a way to access the same Matrix and the same Variable, AuxVariable or vector at all individual nodes?\nThen I could do the Matrix multiplication that way.",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3358607",
                          "updatedAt": "2022-08-09T14:27:22Z",
                          "publishedAt": "2022-08-09T14:27:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "on nodes the classic way not that I know of.\n@lindsayad how could we access multiple node values at the same time? We could re-init multiple times but that s not desirable",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3359517",
                          "updatedAt": "2022-08-09T16:19:22Z",
                          "publishedAt": "2022-08-09T16:19:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "philipJFpfahl"
                  },
                  "bodyText": "Hey,\nI am still struggling with the implementation of the weight matrix. It seems like the order in which MOOSE addresses each node is not row by row.\nWhat I mean, is that if I have a $2 \\times 2$ grid I expect the indexing to be something like this:\n0 1  \n2 3\n\nresulting in a solution vector indexed like this (0, 1, 2, 3). For this, I would know, how to load the weight matrix.\nBut the indexing is more like this:\n0 1\n3 2\n\nresulting in (0, 1, 3, 2) as the indices for the returned solution vector.\nIs there a way, to load in (maybe a material) and have it be in the same order as the MOOSE solution vector?\nwhat I mean is that for a matrix with indexes like that:\n00 01 02 03\n10 11 12 13 \n20 21 22 23 \n30 31 32 33 \n...\n\nI would  need it to be transformed into a matrix like this:\n00 01 03 02\n10 11 13 12 \n30 31 33 32 \n20 21 23 22 \n\nNote that for $W_{j,i}$ both the $j$ and the $i$ index are \"out of order\".\nI don't have a better description. Maybe there is also a way to get the \"real\" position of the node somehow. All ideas are welcome.\nThank you,\nPhilip",
                  "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3413666",
                  "updatedAt": "2022-08-17T10:54:10Z",
                  "publishedAt": "2022-08-17T10:54:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you dump the material into an auxvariable it will be ordered similarly as other variables.\nYou may use Array aux variables for this",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3417621",
                          "updatedAt": "2022-08-17T20:08:57Z",
                          "publishedAt": "2022-08-17T20:08:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nI think that is the right path. The AuxVariabes are stored in the same \"nodal\" order as the Variables. I also found out, that  allow_renumbering = false orders the nodes in a better way. (As I would do it by hand)\nNow the problem is the following:\nI still need access to each entry in the AuxVariabes vector. So how do I do the same you showed me for Variables with AuxVariables?\nAll the best,\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3429116",
                          "updatedAt": "2022-08-19T07:24:07Z",
                          "publishedAt": "2022-08-19T07:24:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "How do you compute W? I feel like that\u2019s a very important question because maybe it would inform my question of how you would get W correctly sorted/stored into an array aux variable representation",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3429433",
                          "updatedAt": "2022-08-19T08:19:45Z",
                          "publishedAt": "2022-08-19T08:19:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "By the way somewhere in this discussion I think you asked about accessing positions. If you are in a nodal aux kernel, you have a _current_node data member which is a pointer to the current Node, which derives from Point. So dereferencing the pointer, you will have something that behaves exactly like a Point. So for instance you can access the x-coordinate like this:\n(*_current_node)(0)",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3429512",
                          "updatedAt": "2022-08-19T08:33:04Z",
                          "publishedAt": "2022-08-19T08:33:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "$W$ is the tensor product of two vectors $c \\otimes d$ with the same length as $a$.\nIn physical terms, the two vectors are scaled versions of the power shape of the reactor. This matrix is not really sparse. My idea was only to store the two vectors and then calculate the entries of $W$ in each $for$ loop. This will work fast since the problem seems memory bound. (Please correct me if I am wrong)\nI load the AuxVariables with the PropertyReadFile Object.\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3429515",
                          "updatedAt": "2022-08-19T08:33:36Z",
                          "publishedAt": "2022-08-19T08:33:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "(*_current_node)(0)\nThats a good tip. Thank you, I was just confused in which way MOOSE indexes the different points. That is also how I intend to find the current node id  _current_node -> id().\nAs I said I am just getting into MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3429589",
                          "updatedAt": "2022-08-19T08:44:55Z",
                          "publishedAt": "2022-08-19T08:44:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Sorry for the delay @philipJFpfahl. I am currently on leave but will be back to work next Monday at which time I should be able to help more",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3475275",
                          "updatedAt": "2022-08-25T14:28:14Z",
                          "publishedAt": "2022-08-25T14:28:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Oh, thank you for checking up.\nI figured out that I can find the aux solution vector with _aux_sys.serializedSolution() but the coupled() method does not return the correct index for auxVariables. The rest should be working fine.\nAll the best and have a nice time off.",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3475543",
                          "updatedAt": "2022-08-25T14:56:43Z",
                          "publishedAt": "2022-08-25T14:56:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nhave you found a solution to find out the right integer for the position in the aux solution vector?\nall the best\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3634671",
                          "updatedAt": "2022-09-13T11:50:08Z",
                          "publishedAt": "2022-09-13T11:50:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I forget where we were at in the conversation. You can get the correct dof index if you use the DofObject::dof_number API. So assuming _aux_var_number = coupled(\"blah_blah\"):\nconst auto soln_vector_index = _current_node->dof_number(_aux_sys.number(), _aux_var_number, 0);\nHere I am assuming you are in a nodal aux kernel (I think that's where we arrived, but correct me if I'm wrong)",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3648346",
                          "updatedAt": "2022-09-14T21:02:58Z",
                          "publishedAt": "2022-09-14T21:02:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mixing mesh elements",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "This may be a simple questions that is already answered somewhere. Is it possible to use a mesh with different elements (eg tets and hexes) but arranged so that each block only contains one kind of mesh elements, but different blocks can have different kinds of elements? I know that within a block, MOOSE seems not to like mixed elements.",
          "url": "https://github.com/idaholab/moose/discussions/22122",
          "updatedAt": "2022-09-29T16:52:07Z",
          "publishedAt": "2022-09-16T18:26:43Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "yes it s very much supported\njust a detail but libmesh as well does not like mixed elements",
                  "url": "https://github.com/idaholab/moose/discussions/22122#discussioncomment-3665042",
                  "updatedAt": "2022-09-16T18:40:32Z",
                  "publishedAt": "2022-09-16T18:40:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Thanks! I thought it might be, but I wanted to make sure.",
                  "url": "https://github.com/idaholab/moose/discussions/22122#discussioncomment-3665143",
                  "updatedAt": "2022-09-16T18:55:59Z",
                  "publishedAt": "2022-09-16T18:55:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can NOT open output file in Paraview",
          "author": {
            "login": "seongwonHam"
          },
          "bodyText": "Hello, MOOSE users.\nI have some trouble with the ParaView program.\nI can NOT open my MOOSE calculation result file in ParaView.\nGenerally, I used to drag the output file from MobaXterm's UI to paraview to check my results.\nHowever, this work doesn't work today, and I couldn't visualize my files.\nI don't know why this situation has occurred.\nAttached is a picture of the error code from Paraview.\nPlease let me know how can I solve this problem and make it normally.\n\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/22116",
          "updatedAt": "2022-09-29T16:52:22Z",
          "publishedAt": "2022-09-16T08:56:32Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou need to use the legacy exodus reader.\nPlease search on the forum, there's others who did this\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22116#discussioncomment-3664100",
                  "updatedAt": "2022-09-29T16:52:44Z",
                  "publishedAt": "2022-09-16T16:09:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Coupling INSFV and FVDiffusion for heat transfer through a subdomain boundary",
          "author": {
            "login": "JuliaHLee"
          },
          "bodyText": "Dear MOOSE experts,\nI am working on a micro-scale heat transport model with INSFV. As a preliminary model, I have made a 2D geometry including a domain as fluid space and a subdomain in the center as a solid block, and managed to simulate the heat transport with water flow in the fluid space. However, heat conduction in the solid did not occur. It seems, there was a problem with heat transfer between fluid and solid, even though I tried it with the \u2018PINSFVEnergyAmbientConvection\u2019 FVKernel assigned on the boundary element between the fluid and solid (please click 'input file' below). I also tried \u2018FVConvectionCorrelationInterface\u2019, but it also did work. Here is the simulation result below:\n\nIs there a way to couple INSFV and FVDiffusion through the subdomain boundary (lower dimensional element) in the center of the domain? For the heat transfer coupling variables in fluid and solid phase, which Kernel can be used? Or should I use finite element method, instead of finite volume method?\nIn addition, can I make a constant pressure difference between top and bottom boundary? I would like to assign inlet and outlet pressure for the uniform water flow from top to bottom, instead of pinning the pressure at the corner of the top boundary.\nAny suggestion and comment will be welcome.\nBest regards,\nJulia\nInput file\n\n# Water properties\nmu = 1.0E-3\nrho = 1000.0\nk = 0.598\ncp = 4186\nh_fs = 100\n\n\n# Solid properties\ncp_s = 830\nrho_s = 1680\nk_s = 3.5\np_outlet = 0\n\n[Mesh]\n  [generated_mesh]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 40\n  ny = 40\n  xmin = 0\n  ymin = 0\n  ymax = 0.1 \n  xmax = 0.1 \n  []\n  [subdomain1]\n    input = generated_mesh\n    type = SubdomainBoundingBoxGenerator\n    block_name = subdomain1\n    bottom_left = '0.04 0.04 0'\n    block_id = 1\n    top_right = '0.06 0.06 0'\n  []\n  [sideset]\n    input = subdomain1\n    type = SideSetsAroundSubdomainGenerator\n    block = 1\n    new_boundary = sideset\n  []\n  [solid_boundary]\n    input = sideset\n    type = LowerDBlockFromSidesetGenerator\n    sidesets = sideset\n    new_block_id = 2\n  []\n[]\n\n[GlobalParams]\n  # retain behavior at time of test creation\n  two_term_boundary_expansion = false\n  rhie_chow_user_object = 'rc'\n  advected_interp_method = 'average'\n  velocity_interp_method = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = vel_x\n    v = vel_y\n    block = 0\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [vel_x]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [vel_y]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [pressure]\n    type = INSFVPressureVariable\n    block = 0\n  []\n  [T]\n    type = INSFVEnergyVariable\n    block = '0 2'\n    initial_condition = 283.15\n  []\n  [Ts]\n    type = INSFVEnergyVariable\n    initial_condition = 283.15\n    block = '1 2'\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    rho = ${rho}\n    block = 0\n  []\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_x\n    mu = ${mu}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_x\n    momentum_component = 'x'\n    pressure = pressure\n    block = 0\n  []\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_y\n    momentum_component = 'y'\n    pressure = pressure\n    block = 0\n  []\n  [energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = T\n    cp = ${cp}\n    rho = ${rho}\n    block = 0\n  []\n  [temp_conduction]\n    type = FVDiffusion\n    coeff = 'k'\n    variable = T\n    block = 0\n  []\n  [temp_advection]\n    type = INSFVEnergyAdvection\n    variable = T\n    block = 0\n  []\n  [solid_energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = Ts\n    cp = ${cp_s}\n    rho = ${rho_s}\n    block = 1\n  []\n  [solid_temp_conduction]\n    type = FVDiffusion\n    coeff = 'k_s'\n    variable = Ts\n    block = 1\n  []\n  [Ts_energy_convection]\n    type = PINSFVEnergyAmbientConvection\n    variable = Ts\n    is_solid = true\n    T_fluid = T\n    T_solid = Ts\n    h_solid_fluid = 'h_cv'\n    block = 2\n  []\n  [T_energy_convection]\n    type = PINSFVEnergyAmbientConvection\n    variable = T\n    is_solid = false\n    T_fluid = T\n    T_solid = Ts\n    h_solid_fluid = 'h_cv'\n    block = 2\n  []\n[]\n\n\n[FVBCs]\n  [inlet-u]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_x\n    function = 0\n  []\n  [inlet-v]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_y\n    function = -1e-4\n  []\n  [inlet_T]\n   type = FVDirichletBC\n    variable = T\n    boundary = 'top'\n    value = 303.15\n  []\n  [no-slip-u]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_x\n    function = 0\n  []\n  [no-slip-v]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_y\n    function = 0\n  []\n\n  [symmetry-u]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'x'\n  []\n  [symmetry-v]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [symmetry-p]\n    type = INSFVSymmetryPressureBC\n    boundary = 'right'\n    variable = pressure\n  []\n\n  [outlet_u]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'x'\n    rho = ${rho}\n  []\n  [outlet_v]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'y'\n    rho = ${rho}\n  []\n  [outlet_p]\n    type = INSFVOutletPressureBC\n    boundary = 'bottom'\n    variable = pressure\n    function = '${p_outlet}'\n  []\n[]\n\n[Materials]\n  [functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k'\n    prop_values = '${cp} ${k}'\n  []\n  [ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'T'\n    rho = ${rho}\n    block = 0\n  []\n  [solid_functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp_s k_s'\n    prop_values = '${cp_s} ${k_s}'\n  []\n  [solid_ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'Ts'\n    rho = ${rho_s}\n    block = 1\n  []\n  [constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'h_cv'\n    prop_values = '${h_fs}'\n    block = 2\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_pc_type -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      100                lu           NONZERO'\n  line_search = 'none'\n  nl_rel_tol = 1e-5  #7e-13\n  dt = 10\n  end_time = 1000\n[]\n\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/22070",
          "updatedAt": "2022-09-16T08:19:44Z",
          "publishedAt": "2022-09-12T12:24:00Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPINSFVEnergyAmbientConvection is for volumetric heat transfer so it wont work for heat exchange between surfaces.\nFVConvectionCorrelationInterface should have worked. How did you set it up?\nYou do not need lower dimensional elements to make this work. The interface kernel should be set on the sideset.\nI would remove this block\n  [solid_boundary]\n    input = sideset\n    type = LowerDBlockFromSidesetGenerator\n    sidesets = sideset\n    new_block_id = 2\n  []\n\nbecause these elements with no physics solved on them will impact the solver performance\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3627513",
                  "updatedAt": "2022-09-12T16:01:45Z",
                  "publishedAt": "2022-09-12T16:01:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "JuliaHLee"
                          },
                          "bodyText": "Hello Guillaume,\nThank you for your answer and suggestions! As you suggested, I removed the lower dimensional elements.\nWhen I tried the IFVConvectionCorrelationInterface, temperature change in the solid block occurred. However, the kernel created an additional heat flux from the sideset boundary to the fluid space, instead of reaching the temperature equilibrium between fluid and solid phase. The additional heat flux or heat sink should not happen in my model, because I have a temperature input only from the top boundary with warm water. The simulation result is below:\n\nSo, what I want is to make heat transport through the solid, and reach the temperature equilibrium between fluid and solid phase. Would this Kernel still work for it?\nMany thanks!\nHere is the input file:\n\n# Water properties\nmu = 1.0E-3\nrho = 1000.0\nk = 0.598\ncp = 4186\n\n\n\n# Solid properties\ncp_s = 830\nrho_s = 1680\nk_s = 3.5\np_outlet = 0\n\n[Mesh]\n  [generated_mesh]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 40\n  ny = 40\n  xmin = 0\n  ymin = 0\n  ymax = 0.1 \n  xmax = 0.1 \n  []\n  [subdomain1]\n    input = generated_mesh\n    type = SubdomainBoundingBoxGenerator\n    block_name = subdomain1\n    bottom_left = '0.04 0.04 0'\n    block_id = 1\n    top_right = '0.06 0.06 0'\n  []\n  [sideset]\n    input = subdomain1\n    type = SideSetsAroundSubdomainGenerator\n    block = 1\n    new_boundary = sideset\n  []\n[]\n\n[GlobalParams]\n  # retain behavior at time of test creation\n  two_term_boundary_expansion = false\n  rhie_chow_user_object = 'rc'\n  advected_interp_method = 'average'\n  velocity_interp_method = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = vel_x\n    v = vel_y\n    block = 0\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [vel_x]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [vel_y]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [pressure]\n    type = INSFVPressureVariable\n    block = 0\n  []\n  [T]\n    type = INSFVEnergyVariable\n    block = 0\n    initial_condition = 283.15\n  []\n  [Ts]\n    type = INSFVEnergyVariable\n    initial_condition = 283.15\n    block = 1\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    rho = ${rho}\n    block = 0\n  []\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_x\n    mu = ${mu}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_x\n    momentum_component = 'x'\n    pressure = pressure\n    block = 0\n  []\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_y\n    momentum_component = 'y'\n    pressure = pressure\n    block = 0\n  []\n  [energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = T\n    cp = ${cp}\n    rho = ${rho}\n    block = 0\n  []\n  [temp_conduction]\n    type = FVDiffusion\n    coeff = 'k'\n    variable = T\n    block = 0\n  []\n  [temp_advection]\n    type = INSFVEnergyAdvection\n    variable = T\n    block = 0\n  []\n  [solid_energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = Ts\n    cp = ${cp_s}\n    rho = ${rho_s}\n    block = 1\n  []\n  [solid_temp_conduction]\n    type = FVDiffusion\n    coeff = 'k_s'\n    variable = Ts\n    block = 1\n  []\n[]\n\n[FVInterfaceKernels]\n  [convection]\n    type = FVConvectionCorrelationInterface\n    variable1 = T\n    variable2 = Ts\n    boundary = sideset\n    h = 50\n    T_solid = Ts\n    T_fluid = T\n    subdomain1 = 0\n    subdomain2 = 1\n    wall_cell_is_bulk = true\n  []\n[]\n\n[FVBCs]\n  [inlet-u]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_x\n    function = 0\n  []\n  [inlet-v]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_y\n    function = -1e-4\n  []\n  [inlet_T]\n   type = FVDirichletBC\n    variable = T\n    boundary = 'top'\n    value = 303.15\n  []\n  [no-slip-u]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_x\n    function = 0\n  []\n  [no-slip-v]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_y\n    function = 0\n  []\n\n  [symmetry-u]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'x'\n  []\n  [symmetry-v]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [symmetry-p]\n    type = INSFVSymmetryPressureBC\n    boundary = 'right'\n    variable = pressure\n  []\n\n  [outlet_u]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'x'\n    rho = ${rho}\n  []\n  [outlet_v]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'y'\n    rho = ${rho}\n  []\n  [outlet_p]\n    type = INSFVOutletPressureBC\n    boundary = 'bottom'\n    variable = pressure\n    function = '${p_outlet}'\n  []\n[]\n\n[Materials]\n  [functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k'\n    prop_values = '${cp} ${k}'\n  []\n  [ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'T'\n    rho = ${rho}\n    block = 0\n  []\n  [solid_functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp_s k_s'\n    prop_values = '${cp_s} ${k_s}'\n  []\n  [solid_ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'Ts'\n    rho = ${rho_s}\n    block = 1\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_pc_type -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      100                lu           NONZERO'\n  line_search = 'none'\n  nl_rel_tol = 1e-5  #7e-13\n  dt = 10\n  end_time = 1000\n[]\n\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3636930",
                          "updatedAt": "2022-09-13T16:09:46Z",
                          "publishedAt": "2022-09-13T16:09:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It should work, we shouldnt see this heating up on one side.\nMy guess is that sideset is not consistently oriented in this mesh setup.\nCould you please use the sidesetsBetweenSubdomainGenerator to create that sideset?\nIt should be fairly straight forward",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3637605",
                          "updatedAt": "2022-09-13T17:38:53Z",
                          "publishedAt": "2022-09-13T17:38:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JuliaHLee"
                          },
                          "bodyText": "I have replaced the sideset block with SideSetsBetweenSubdomainsGenerator. But my simulation result is the same. I guess the heat flux on one side could be due to the non-uniform water flow around the solid block.\nSo I was still thinking that I might need to deal with the interface Kernel. It seems that the flux goes only to the fluid with the Kernel. As you could see on my result above, my solid loses heat and the heat goes to the fluid. But I need the other way around, heat transfer from fluid to solid. How can I change it?",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3642524",
                          "updatedAt": "2022-09-14T08:47:28Z",
                          "publishedAt": "2022-09-14T08:47:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont understand how the fluid is hotter on the right.\nMaybe make the problem fully symmetric and look at what you get?\nThe interface kernel adds contributions to the residual of both equations so it should do what you want.\nIt does seem to influence the temperature distribution in both phases, but the contributions dont seem right",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3646940",
                          "updatedAt": "2022-09-14T17:08:51Z",
                          "publishedAt": "2022-09-14T17:08:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JuliaHLee"
                          },
                          "bodyText": "Asymmetry is another issue, which I could not solve. I would like to make symmetric water flow, but I could not make it work. I think it is because of the pressure boundary condition, as I mentioned on my posting. The result of pressure in the fluid space is like this:\n\nShouldn't the pressure same over the top boundary, instead of the high pressure point on the corner? So I tried to make the constant pressure difference between top and bottom boundary, by using FVDirichletBC. But it did not converge, like this:\n\nInput file with changed BC\n\n# Water properties\nmu = 1.0E-3\nrho = 1000.0\nk = 0.598\ncp = 4186\n\n\n\n# Solid properties\ncp_s = 830\nrho_s = 1680\nk_s = 3.5\n\n[Mesh]\n  [generated_mesh]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 40\n  ny = 40\n  xmin = 0\n  ymin = 0\n  ymax = 0.1 \n  xmax = 0.1 \n  []\n  [subdomain1]\n    input = generated_mesh\n    type = SubdomainBoundingBoxGenerator\n    block_name = subdomain1\n    bottom_left = '0.04 0.04 0'\n    block_id = 1\n    top_right = '0.06 0.06 0'\n  []\n  [sideset]\n    input = subdomain1\n    type = SideSetsBetweenSubdomainsGenerator\n    primary_block = 0\n    paired_block = 1\n    new_boundary = sideset\n  []\n[]\n\n[GlobalParams]\n  # retain behavior at time of test creation\n  two_term_boundary_expansion = false\n  rhie_chow_user_object = 'rc'\n  advected_interp_method = 'average'\n  velocity_interp_method = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = vel_x\n    v = vel_y\n    block = 0\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [vel_x]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [vel_y]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [pressure]\n    type = INSFVPressureVariable\n    block = 0\n  []\n  [T]\n    type = INSFVEnergyVariable\n    block = 0\n    initial_condition = 283.15\n  []\n  [Ts]\n    type = INSFVEnergyVariable\n    initial_condition = 283.15\n    block = 1\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    rho = ${rho}\n    block = 0\n  []\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_x\n    mu = ${mu}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_x\n    momentum_component = 'x'\n    pressure = pressure\n    block = 0\n  []\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_y\n    momentum_component = 'y'\n    pressure = pressure\n    block = 0\n  []\n  [energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = T\n    cp = ${cp}\n    rho = ${rho}\n    block = 0\n  []\n  [temp_conduction]\n    type = FVDiffusion\n    coeff = 'k'\n    variable = T\n    block = 0\n  []\n  [temp_advection]\n    type = INSFVEnergyAdvection\n    variable = T\n    block = 0\n  []\n  [solid_energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = Ts\n    cp = ${cp_s}\n    rho = ${rho_s}\n    block = 1\n  []\n  [solid_temp_conduction]\n    type = FVDiffusion\n    coeff = 'k_s'\n    variable = Ts\n    block = 1\n  []\n[]\n\n[FVInterfaceKernels]\n  [convection]\n    type = FVConvectionCorrelationInterface\n    variable1 = Ts\n    variable2 = T\n    boundary = sideset\n    h = 50\n    T_solid = T\n    T_fluid = Ts\n    subdomain1 = 1\n    subdomain2 = 0\n    wall_cell_is_bulk = true\n  []\n[]\n\n[FVBCs]\n  [inlet-u]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_x\n    function = 0\n  []\n  [inlet-v]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_y\n    function = -1e-4\n  []\n  [inlet_T]\n   type = FVDirichletBC\n    variable = T\n    boundary = 'top'\n    value = 303.15\n  []\n  [no-slip-u]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_x\n    function = 0\n  []\n  [no-slip-v]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_y\n    function = 0\n  []\n\n  [symmetry-u]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'x'\n  []\n  [symmetry-v]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [outlet_u]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'x'\n    rho = ${rho}\n  []\n  [outlet_v]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'y'\n    rho = ${rho}\n  []\n  [inlet_p]\n    type = FVDirichletBC\n    variable = pressure\n    boundary = top\n    value = 50\n  []\n  [outlet_p]\n    type = FVDirichletBC\n    variable = pressure\n    boundary = bottom\n    value = 1\n  []\n[]\n\n[Materials]\n  [functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k'\n    prop_values = '${cp} ${k}'\n  []\n  [ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'T'\n    rho = ${rho}\n    block = 0\n  []\n  [solid_functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp_s k_s'\n    prop_values = '${cp_s} ${k_s}'\n  []\n  [solid_ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'Ts'\n    rho = ${rho_s}\n    block = 1\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_pc_type -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      100                lu           NONZERO'\n  line_search = 'none'\n  nl_rel_tol = 1e-3  #7e-13\n  dt = 10\n  end_time = 1000\n[]\n\n\n[Outputs]\n  exodus = true\n[]\n\n\nCould you please give me advice regarding the pressure boundary condition for making symmetric flow?",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3647319",
                          "updatedAt": "2022-09-14T18:09:58Z",
                          "publishedAt": "2022-09-14T18:09:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Tfluid and Tsolid are flipped with T, Ts in the parameters of the interface kernel. That could be your problem\nthe system is not symmetric because you have no-slip boundary conditions on one side and symmetric on the other side.\nSince the symmetry is handled in the boundary condition, you dont see it in the domain. You could simplify your model by having no-slip everywhere",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3650476",
                          "updatedAt": "2022-09-15T05:25:02Z",
                          "publishedAt": "2022-09-15T05:25:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JuliaHLee"
                          },
                          "bodyText": "Thank you for the advice about BC! I have managed to make symmetric flow.\nT and Ts were flipped, while I was testing all possibilities. And now I have put them back on the right positions. However, the strange contribution of the interface Kernel remains the same.. The result is below:\n\nFor the moment, I do not really have a clue, how I can fix it. Would it be a problem with BC or the Kernel itself?\nInput file\n\n# Water properties\nmu = 1.0E-3\nrho = 1000.0\nk = 0.598\ncp = 4186\n\n\n\n# Solid properties\ncp_s = 830\nrho_s = 1680\nk_s = 3.5\np_outlet = 0\n\n[Mesh]\n  [generated_mesh]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 40\n  ny = 40\n  xmin = 0\n  ymin = 0\n  ymax = 0.1 \n  xmax = 0.1 \n  []\n  [subdomain1]\n    input = generated_mesh\n    type = SubdomainBoundingBoxGenerator\n    block_name = subdomain1\n    bottom_left = '0.04 0.04 0'\n    block_id = 1\n    top_right = '0.06 0.06 0'\n  []\n  [sideset]\n    input = subdomain1\n    type = SideSetsBetweenSubdomainsGenerator\n    primary_block = 0\n    paired_block = 1\n    new_boundary = sideset\n  []\n[]\n\n[GlobalParams]\n  # retain behavior at time of test creation\n  two_term_boundary_expansion = false\n  rhie_chow_user_object = 'rc'\n  advected_interp_method = 'average'\n  velocity_interp_method = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = vel_x\n    v = vel_y\n    block = 0\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [vel_x]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [vel_y]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [pressure]\n    type = INSFVPressureVariable\n    block = 0\n  []\n  [T]\n    type = INSFVEnergyVariable\n    block = 0\n    initial_condition = 283.15\n  []\n  [Ts]\n    type = INSFVEnergyVariable\n    initial_condition = 283.15\n    block = 1\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    rho = ${rho}\n    block = 0\n  []\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_x\n    mu = ${mu}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_x\n    momentum_component = 'x'\n    pressure = pressure\n    block = 0\n  []\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_y\n    momentum_component = 'y'\n    pressure = pressure\n    block = 0\n  []\n  [energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = T\n    cp = ${cp}\n    rho = ${rho}\n    block = 0\n  []\n  [temp_conduction]\n    type = FVDiffusion\n    coeff = 'k'\n    variable = T\n    block = 0\n  []\n  [temp_advection]\n    type = INSFVEnergyAdvection\n    variable = T\n    block = 0\n  []\n  [solid_energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = Ts\n    cp = ${cp_s}\n    rho = ${rho_s}\n    block = 1\n  []\n  [solid_temp_conduction]\n    type = FVDiffusion\n    coeff = 'k_s'\n    variable = Ts\n    block = 1\n  []\n[]\n\n[FVInterfaceKernels]\n  [convection]\n    type = FVConvectionCorrelationInterface\n    variable1 = T\n    variable2 = Ts\n    boundary = sideset\n    h = 50\n    T_solid = Ts\n    T_fluid = T\n    subdomain1 = 0\n    subdomain2 = 1\n    wall_cell_is_bulk = true\n    #bulk_distance = 0.02\n  []\n[]\n\n[FVBCs]\n  [inlet-u]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_x\n    function = 0\n  []\n  [inlet-v]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_y\n    function = -1e-4\n  []\n  [inlet_T]\n   type = FVDirichletBC\n    variable = T\n    boundary = 'top'\n    value = 303.15\n  []\n  [no-slip-u]\n    type = INSFVNoSlipWallBC\n    boundary = 'left right sideset'\n    variable = vel_x\n    function = 0\n  []\n  [no-slip-v]\n    type = INSFVNoSlipWallBC\n    boundary = 'left right sideset'\n    variable = vel_y\n    function = 0\n  []\n\n  [outlet_u]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'x'\n    rho = ${rho}\n  []\n  [outlet_v]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'y'\n    rho = ${rho}\n  []\n  [outlet_p]\n    type = INSFVOutletPressureBC\n    boundary = 'bottom'\n    variable = pressure\n    function = '${p_outlet}'\n  []\n[]\n\n[Materials]\n  [functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k'\n    prop_values = '${cp} ${k}'\n  []\n  [ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'T'\n    rho = ${rho}\n    block = 0\n  []\n  [solid_functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp_s k_s'\n    prop_values = '${cp_s} ${k_s}'\n  []\n  [solid_ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'Ts'\n    rho = ${rho_s}\n    block = 1\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_pc_type -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      100                lu           NONZERO'\n  line_search = 'none'\n  nl_rel_tol = 1e-3  #7e-13\n  dt = 10\n  end_time = 800\n[]\n\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3655053",
                          "updatedAt": "2022-09-15T15:24:29Z",
                          "publishedAt": "2022-09-15T15:24:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@grmnptr if you have time to have a look. Looks like a bug with our convection correlation interface. It s not used much so it would not be that shocking\nIf not I ll have time next week",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3655460",
                          "updatedAt": "2022-09-15T16:05:35Z",
                          "publishedAt": "2022-09-15T16:05:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grmnptr"
                          },
                          "bodyText": "Okay, I'll check it today.",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3655843",
                          "updatedAt": "2022-09-15T16:48:03Z",
                          "publishedAt": "2022-09-15T16:48:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grmnptr"
                          },
                          "bodyText": "Okay, the current implementation didn't take into account the face normals. Adding that fixed the problem, will add tests and push a PR today.",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3656322",
                          "updatedAt": "2022-09-15T17:56:52Z",
                          "publishedAt": "2022-09-15T17:51:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to transfer strain in spherical coordinates to Cartesian coordinate?",
          "author": {
            "login": "RECHOA"
          },
          "bodyText": "Hi all,\nIf i know the raidal and hoop strain of a material in spherical coordinates as folliws:\n\u03b5r= -0.007T ;  \u03b5t= -0.004T ; T is the tempearature.\nNow i want to analyze its mechanical behaviour by using MOOSE in the Cartesian coordinate (coord-type=XYZ), how should I build the strain tensor \u03b5 in EigenStrain.C?",
          "url": "https://github.com/idaholab/moose/discussions/22105",
          "updatedAt": "2022-09-29T16:59:55Z",
          "publishedAt": "2022-09-15T14:31:41Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@recuero\nI think you ll want to do the math, build a generic constant tensor, and use that in the calculation.\nI doubt we have a utility for you here but Antonio will know",
                  "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3654896",
                  "updatedAt": "2022-09-15T15:07:20Z",
                  "publishedAt": "2022-09-15T15:07:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I doubt we have a utility for that too. It seems that once you perform the transformation from your spherical coordinates to the Cartesian systems, you'll end up with a nontrivial dependency on the temperature. I wonder if a simple way forward can be just to inherit from ComputeEigenstrain and perform the transformation there pulling the temperature variable.\nMaybe @jiangwen84 knows if there is a simpler way to do that.",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3655364",
                          "updatedAt": "2022-09-15T15:54:53Z",
                          "publishedAt": "2022-09-15T15:54:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The general steps are:\n\nCalculate the eigen deformation gradient from the eigen strain, IIRC tensor mechanics uses the log strain measure.\nCalculate the scalar-valued thermal expansion, i.e. the determinant of the eigen deformation gradient, which is convenient as it is an invariant.\nCalculate the eigen deformation gradient in Cartesian from the calculated thermal expansion.\nCalculate the eigen strain from the eigen deformation gradient in Cartesian.\n\nYour eigen strain might be trickier as it seems to be anisotropic. But the general steps should apply, you just do it for the two directions and add the eigen strains.",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3655466",
                          "updatedAt": "2022-09-15T16:06:10Z",
                          "publishedAt": "2022-09-15T16:06:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "And of course you can do it as @recuero suggested -- directly transform the eigen strain tensor using a rotation tensor. It will require users to define the axisymmetric RZ coordinate system, e.g. the symmetry axis.",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3655494",
                          "updatedAt": "2022-09-15T16:09:50Z",
                          "publishedAt": "2022-09-15T16:09:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RECHOA"
                          },
                          "bodyText": "Thanks for your reply. I am sorry i didn't understand the general steps. Are there articles or formula derivation i can refer to?\nAs for the other method (directly transforming the eigen strain tensor using a rotation tensor), If I have multiple spheres like this to simulate, does that mean I have to set up multiple spherical coordinates and convert the strain to cartesian coordinates in each spherical coordinate\uff1f",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3655832",
                          "updatedAt": "2022-09-15T16:46:42Z",
                          "publishedAt": "2022-09-15T16:46:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Are there articles or formula derivation i can refer to?\n\nI'm not aware of any unfortunately.\n\nAs for the other method (directly transforming the eigen strain tensor using a rotation tensor), If I have multiple spheres like this to simulate, does that mean I have to set up multiple spherical coordinates and convert the strain to cartesian coordinates in each spherical coordinate\uff1f\n\nYes. Intuitively that's how it works if I understand your problem description correctly: you know how the spheres are going to expand radially and axially in their respective spherical coordinates, so they can't share a common spherical coordinate system as they are transformed into Cartesian.",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3658267",
                          "updatedAt": "2022-09-16T00:22:36Z",
                          "publishedAt": "2022-09-16T00:22:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RECHOA"
                          },
                          "bodyText": "you know how the spheres are going to expand radially and axially in their respective spherical coordinates, so they can't share a common spherical coordinate system as they are transformed into Cartesian.\n\nyes, the expansion of the spheres are  konwn in in their respective spherical coordinates. In each sphere it follws \u03b5r= -0.007T ; \u03b5t= -0.004T, i.e. the strain tensor in spherical coordinate is known as\nSsphere =\n\nSo now i need to find a way (maybe a transform matrix M) to convert  Ssphere in  respective spherical coordinates to Sxyz in Cartesian coordinate system",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3660465",
                          "updatedAt": "2022-09-16T08:11:36Z",
                          "publishedAt": "2022-09-16T08:11:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Coupling Variables Error",
          "author": {
            "login": "FanZhangchen"
          },
          "bodyText": "Hello,\nI am trying to implement a MOOSE framework with two governing equations and two nodal degrees of freedom. I try to use adCoupledVectorValue to represent the coupled variable. MOOSE could compile well, but when I tried to solve it, some errors came up.\n*** ERROR *** The named variable is a standard variable, try a 'coupled[Value/Gradient/Dot/etc]...' function instead\nSo I think it might be wrong with my coupling variables. I am new to MOOSE that I am not sure how to realize the problems with two coupling variables in two equations. Could you give me some suggestions about it? Thanks",
          "url": "https://github.com/idaholab/moose/discussions/22103",
          "updatedAt": "2022-09-16T07:17:13Z",
          "publishedAt": "2022-09-15T11:12:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "FanZhangchen"
                  },
                  "bodyText": "The governing equations are attached here if you need them.\n\n\n$\\rho$ and $\\rho_G$ are the nodal degrees of freedom.",
                  "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3653600",
                  "updatedAt": "2022-09-15T12:47:52Z",
                  "publishedAt": "2022-09-15T12:47:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCoupledVectorValue is a routine for vector variables, not for regular single-component field variables.'\nI think you want to use coupledValue or ADcoupledValue here\nThis retrieves the local quadrature point value of the variable passed\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3654932",
                  "updatedAt": "2022-09-15T15:10:47Z",
                  "publishedAt": "2022-09-15T15:10:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "FanZhangchen"
                          },
                          "bodyText": "Hello\nThank you for your reply. I have tried to use ADcoupledValue and I got some errors. The error is attached here.\nerror: no match for 'operator-' (operand types are 'libMesh::CompareTypes<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>'} and 'libMesh::boostcopy::enable_if_c<true, libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> > >::type' {aka 'libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >'})\n   27 |     - _grad_test[_i][_qp] * _rhot[_qp];\n\nI think I might have some C++ syntax errors here. I will also attach my C++ file here. Do you have any ideas about my problem?\n#include \"ADGNDTrans.h\"\n\nregisterMooseObject(\"framework2App\", ADGNDTrans);\n\nInputParameters\nADGNDTrans::validParams()\n{\n  auto params = ADKernel::validParams();\n  params.addParam<Real>(\"backstress\", 1.0, \"Back stress' parameter\");\n  params.addClassDescription(\"The time derivative operator with the weak form of $(\\\\psi_i, \"\n                             \"\\\\frac{\\\\partial rhog}{\\\\partial t})$.\");\n  params.addCoupledVar(\"rhot\", \"The variable representing the total dislocation density.\");\n  return params;\n}\n\nADGNDTrans::ADGNDTrans(const InputParameters & parameters)\n  : ADKernel(parameters),\n    _backstress(getParam<Real>(\"backstress\")),\n    _rhot(adCoupledValue(\"rhot\"))\n{\n}\n\nADReal\nADGNDTrans::computeQpResidual()\n{\n  return _backstress * _grad_u[_qp]*_grad_test[_i][_qp]\n    - _grad_test[_i][_qp] * _rhot[_qp];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3658607",
                          "updatedAt": "2022-09-16T02:48:18Z",
                          "publishedAt": "2022-09-16T01:55:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes the syntax is wrong. Basically the two terms being substracted are of a different type.\nFrom the message, one is a single ADReal and the other is a vector of ADReals",
                          "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3658848",
                          "updatedAt": "2022-09-16T02:49:33Z",
                          "publishedAt": "2022-09-16T02:49:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FanZhangchen"
                          },
                          "bodyText": "Does it mean I need to add another kernel for these different types? Or the easy way to solve this error is to divide two terms into different kernels?",
                          "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3658879",
                          "updatedAt": "2022-09-16T02:56:27Z",
                          "publishedAt": "2022-09-16T02:56:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no you dont, you need to check that the math makes sense here. You have a grad_u * grad_test and a grad_test * some_variable that is not a vector\nI dont think that s right",
                          "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3658952",
                          "updatedAt": "2022-09-16T03:14:07Z",
                          "publishedAt": "2022-09-16T03:13:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FanZhangchen"
                          },
                          "bodyText": "Yes, I get your point. I will check if there is any math error. Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3659000",
                          "updatedAt": "2022-09-16T03:31:07Z",
                          "publishedAt": "2022-09-16T03:31:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Verifying Energy Conservation in Heat Transfer Calculations",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, moose developers.\nI would like to verify the conservation of energy in MOOSE heat transfer calculations. The specific model is like this\uff1a\n\nThere is a heating rod with a sinusoidal distribution of power, the surrounding is a fluid, and the whole system is adiabatic. I gave this system an initial temperature T0, the average temperatures of the solid and liquid after t seconds are Ts and Tf respectively. Then the heat absorbed by the system, which also can be called enthalpy,  should be equal to\n\nOn the other hand, the heat released by the solid heating rod should be equal to the integral of the power over the volume multiplied by t, which is equal to:\n\nIt can be seen from the boundary conditions that the system is adiabatic, and it stands to reason that the enthalpy of the system should be equal to the heat released by the heating rod. But they are not equal. I have some PostProcessors in an input file. The power_integral means the integral of power over the entire heating rod volume. The energy_difference means power_integral * t - enthalpy .\nThe enthalpy rise versus time and the heat released by the heating rod versus time are plotted as follows:\n\nThere are input file and mesh files:\n# Units: cm K s kg\n\noutlet_pressure = 0\ninlet_velocity = 150 # cm/s\nini_temp = 300 # K\nheat_transfer_coefficient = 9 # W cm-2\ng = -981 \nrho_solid = 0.011 # kg cm-3\ncp_solid = 300 # cm s-2\nk_solid = 0.06 # W cm-1 K-1\n# (0.5 * 0.5 * pi * 10) = 7.8539816\nV_solid = 7.8539816\n\nrho_fluid = 0.0077\ncp_fluid = 145\nk_fluid = 0.12\nmu_fluid = 1.762e-5\n# ((1.6 * 1.6 - 0.5 * 0.5 * pi) * 10) = 17.7460184\nV_fluid = 17.7460184\n\n[Mesh]\n  file = 'solid_fluid.msh'\n[]\n\n[Variables]\n  [./T]\n    initial_condition = ${ini_temp}\n  [../]\n  [./velocity]\n    family = LAGRANGE_VEC\n    block = 'fluid'\n  [../]\n  [./p]\n    order = FIRST\n    family = LAGRANGE\n    block = 'fluid'\n  [../]\n[]\n\n[AuxVariables]\n  [./power]\n    family = MONOMIAL\n    order = FIRST\n    block = 'solid'\n  [../]\n[]\n\n[ICs]\n  [./initial_velocity]\n    type = VectorConstantIC\n    x_value = 0\n    y_value = 0\n    z_value = ${inlet_velocity}\n    variable = velocity\n  [../]\n  [./initial_p]\n    type = FunctionIC\n    variable = p\n    function = ini_p\n  [../]\n[]\n\n[Kernels]\n  [./fluid_mass]\n    type = INSADMass\n    variable = p\n  [../]\n  [./fluid_mass_pspg]\n    type = INSADMassPSPG\n    variable = p\n  [../]\n\n  [./fluid_momentum_time]\n    type = INSADMomentumTimeDerivative\n    variable = velocity\n  [../]\n  [./fluid_momentum_convection]\n    type = INSADMomentumAdvection\n    variable = velocity\n  [../]\n  [./fluid_momentum_pressure]\n    type = INSADMomentumPressure\n    variable = velocity\n    pressure = p\n    integrate_p_by_parts = true\n  [../]\n  [./fluid_momentum_gravity]\n    type = INSADGravityForce\n    variable = velocity\n    gravity = '0 0 ${g}'\n  [../]\n  [./fluid_momentum_supg]\n    type = INSADMomentumSUPG\n    variable = velocity\n    velocity = velocity\n  [../]\n\n  [./fluid_temperature_time]\n    type = INSADHeatConductionTimeDerivative\n    variable = T\n    block = 'fluid'\n  [../]\n  [./fluid_temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    block = 'fluid'\n    thermal_conductivity = 'k'\n  [../]\n  [./fluid_temperature_advection]\n    type = INSADEnergyAdvection\n    variable = T\n    block = 'fluid'\n  [../]\n  [./fluid_temperature_supg]\n    type = INSADEnergySUPG\n    variable = T\n    velocity = velocity\n    block = 'fluid'\n  [../]\n\n  [./solid_temperature_time]\n    type = ADHeatConductionTimeDerivative\n    variable = T\n    block = 'solid'\n    density_name = 'rho'\n    specific_heat = 'cp'\n  [../]\n  [./solid_temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    block = 'solid'\n    thermal_conductivity = 'k'\n  [../]\n  [./heat_source]\n    type = ADCoupledForce\n    variable = T\n    block = 'solid'\n    v = power\n  [../]\n[]\n\n[AuxKernels]\n  [./power_aux]\n    type = FunctionAux\n    variable = power\n    function = power_function\n    block = 'solid'\n  [../]\n[]\n\n[InterfaceKernels]\n  [./convection_heat_transfer]\n    type = ConjugateHeatTransfer\n    variable = T\n    T_fluid = T\n    neighbor_var = 'T'\n    boundary = 'solid_wall'\n    htc = 'htc'\n  [../]\n[]\n\n[BCs]\n  [./inlet_velocity_fluid]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'fluid_bottom'\n    function_z = ${inlet_velocity}\n  [../]\n  [./outlet_p_fluid]\n    type = DirichletBC\n    variable = p\n    boundary = 'fluid_top'\n    value = ${outlet_pressure}\n  [../]\n\n  [./no_slip]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'solid_wall'\n  [../]\n\n  [./Periodic]\n    [./x]\n      variable = velocity\n      primary = 'fluid_wall1'\n      secondary = 'fluid_wall2'\n      translation = '1.6 0 0'\n    [../]\n    [./y]\n      variable = velocity\n      primary = 'fluid_wall3'\n      secondary = 'fluid_wall4'\n      translation = '0 1.6 0'\n    [../]\n  [../]\n[]\n\n[Materials]\n  [./solid_mat]\n    type = ADGenericConstantMaterial\n\tprop_names = 'rho cp k'\n\tprop_values = '${rho_solid} ${cp_solid} ${k_solid}'\n\tblock = 'solid'\n  [../]\n  [./fluid_mat]\n    type = ADGenericConstantMaterial\n\tprop_names = 'rho cp k mu'\n\tprop_values = '${rho_fluid} ${cp_fluid} ${k_fluid} ${mu_fluid}'\n\tblock = 'fluid'\n  [../]\n\n  [./ins_mat_fluid]\n    type = INSADStabilized3Eqn\n    velocity = velocity\n    pressure = p\n    temperature = T\n    block = 'fluid'\n  [../]\n\n  [./htc]\n    type = ADGenericFunctionMaterial\n    prop_names = htc\n    prop_values = htc_function\n  [../]\n[]\n\n[Functions]\n  [./htc_function]\n    type = ParsedFunction\n    value = ${heat_transfer_coefficient}\n  [../]\n  [./ini_p]\n    type = ParsedFunction\n    value = '0.011 * 981 * (10-z)'\n  [../]\n  [./power_function]\n    type = ParsedFunction\n    value = '100 + 200 * sin(z / 10 * pi)'\n  [../]\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n    solve_type = 'NEWTON'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  #num_steps = 100\n  dt = 1\n  end_time = 200\n\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-10\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n   # petsc_options_iname = '-snes_type'\n  # petsc_options_value = 'test'\n\n  nl_max_its = 30\n  l_max_its = 100\n  automatic_scaling = true\n[]\n\n[Postprocessors]\n  [./average_T_solid]\n    type = ElementAverageValue\n    variable = T\n    block = 'solid'\n  [../]\n  [./average_T_fluid]\n    type = ElementAverageValue\n    variable = T\n    block = 'fluid'\n  [../]\n  [./enthalpy]\n    type = ParsedPostprocessor\n\tfunction = '(average_T_solid - 300) * ${rho_solid} * ${cp_solid} * ${V_solid}  + (average_T_fluid - 300) * ${rho_fluid} * ${cp_fluid} * ${V_fluid}'\n\tpp_names = 'average_T_solid average_T_fluid'\n  [../]\n  [./power_integral]\n    type = ElementIntegralVariablePostprocessor\n\tvariable = power\n\tblock = 'solid'\n  [../]\n  [energy_difference]\n    type = ParsedPostprocessor\n\tfunction = 'power_integral * t - enthalpy'\n\tpp_names = 'power_integral enthalpy'\n\tuse_t = true\n  [../]\n[]\n\n[Outputs]\n  perf_graph = true\n  print_linear_residuals = true\n  [./exodus]\n    type = Exodus\n    file_base = 'energy_balance'\n    execute_on = 'TIMESTEP_END'\n  [../]\n  [./csv]\n    type = CSV\n    file_base = 'energy_balance'\n    execute_on = 'TIMESTEP_END'\n  [../]\n[]\n\ngithub.zip\nWhat do you think of this problem? Am I overlooking a cooling source in the system or some other setting that causes heat to move out of the system\uff1f",
          "url": "https://github.com/idaholab/moose/discussions/21966",
          "updatedAt": "2022-09-16T01:39:57Z",
          "publishedAt": "2022-08-30T06:12:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "The way you define enthalpy and total work doesn't look right to me.\nwork = power * dt only holds when power doesn't change with time (I'm not sure if this the case with your model without reading it in detail.).\nThe enthalpy density should be integrated in volume. The expression you used only hold when you have a homogeneous temperature field.",
                  "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3522140",
                  "updatedAt": "2022-08-31T22:44:55Z",
                  "publishedAt": "2022-08-31T22:44:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Hi, Gary.\nPower is a function of z, so I use the following formulas to calculate the work produced in time t:\n\nSolid and fluid don't have homogeneous temperature fields, so I find the average temperature of the solid and liquid first and then calculate their enthalpy.\n\nSo the enthalpy should be equal to the work, but the simulation results are not. These are PostProcessors of enthalpy , power and energy_difference:\n  [./enthalpy]\n    type = ParsedPostprocessor\n    function = '(average_T_solid - 300) * ${rho_solid} * ${cp_solid} * ${V_solid}  + (average_T_fluid - 300) * ${rho_fluid} * ${cp_fluid} * ${V_fluid}'\n    pp_names = 'average_T_solid average_T_fluid'\n  [../]\n  [./power_integral]\n    type = ElementIntegralVariablePostprocessor\n    variable = power\n    block = 'solid'\n  [../]\n  [energy_difference]\n    type = ParsedPostprocessor\n    function = 'power_integral * t - enthalpy'\n    pp_names = 'power_integral enthalpy'\n    use_t = true\n  [../]",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3522911",
                          "updatedAt": "2022-09-01T02:44:22Z",
                          "publishedAt": "2022-09-01T02:41:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Solid and fluid don't have homogeneous temperature fields, so I find the average temperature of the solid and liquid first and then calculate their enthalpy.\n\nThis may be fine, but very inaccurate, and is most likely the source of the difference you are seeing. You need to properly integrate the enthalpy density both in space and in time for it to match the heat source. The equation should be\n\\int_0^t \\int_\\Omega \\rho c_p \\dot{T} \\d{V} \\d{t}\n\nCompute the enthalpy rate density \\rho c_p \\dot{T} as a material property,\nIntegrate the enthalpy rate density in space to get the enthalpy rate, e.g. using a ElementIntegralMaterialProperty postprocessor.\nIntegrate the enthalpy rate in time. Use your favorite integration scheme, as I think the time integration error will be negligible in this case.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3528187",
                          "updatedAt": "2022-09-01T15:23:54Z",
                          "publishedAt": "2022-09-01T15:23:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thank you, Gary. These methods maybe useful, After solving the problem of the fluid pressure field I will add the energy equation as well and use your method to verify the conservation of energy. I'll let you know the result of my attempt.\ud83d\ude00",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3534843",
                          "updatedAt": "2022-09-02T09:43:40Z",
                          "publishedAt": "2022-09-02T09:43:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Hi, Gary.\nI think the following formulas can be used to calculate the enthalpy:\n\nWhen \u03c1 and cp are constants, I define a material property called fluid_enthalpy_density in the Materials block to calculate the increasement of enthalpy at a certain point:\n  [./fluid_enthalpy_density_mat]\n    type = ADParsedMaterial\n    f_name = fluid_enthalpy_density\n    function = '(Tf - ${ini_temp}) * rho * cp'\n    args = 'Tf'\n    material_property_names = 'rho cp'\n    block = 'fluid'\n  [../]\n  [./solid_enthalpy_density_mat]\n    type = ADParsedMaterial\n    f_name = solid_enthalpy_density\n    function = '(Ts - ${ini_temp}) * rho * cp'\n    args = 'Ts'\n    material_property_names = 'rho cp'\n    block = 'solid'\n  [../]\n\nThen I integrate the fluid_enthalpy_density in space to get the fluid_enthalpy:\n  [./solid_enthalpy]\n    type = ADElementIntegralMaterialProperty\n    mat_prop = 'solid_enthalpy_density'\n    block = 'solid'\n  [../]\n  [./fluid_enthalpy]\n    type = ADElementIntegralMaterialProperty\n    mat_prop = 'fluid_enthalpy_density'\n    block = 'fluid'\n  [../]\n\nThe heat absorbed by the system is calculated by these formulas:\n\nThe power_density I defined is:\n[AuxVariables]\n  [./power_density]\n    family = MONOMIAL\n    order = FIRST\n    block = 'solid'\n  [../]\n[]\n[AuxKernels]\n  [./power_density_auxk]\n    type = FunctionAux\n    variable = power_density\n    function = power_density_function\n    block = 'solid'\n  [../]\n[]\n[Functions]\n  [./power_density_function]\n    type = ParsedFunction\n    value = '50'\n  [../]\n[]\n\nThen I integrate the power_density in space to get the power:\n  [./power]\n    type = ElementIntegralVariablePostprocessor\n    variable = power_density\n    block = 'solid'\n  [../]\n\nFinally, I multiply power by time t to get heat:\n  [./heat]\n    type = ParsedPostprocessor\n    function = 'power * t'\n    pp_names = 'power'\n    use_t = true\n  [../]\n\nThe sum of solid_enthalpy and fluid_enthalpy should be equal to heat, but they are not:\n  [./enthalpy]\n    type = ParsedPostprocessor\n    function = 'solid_enthalpy + fluid_enthalpy'\n    pp_names = 'solid_enthalpy fluid_enthalpy'\n  [../]\n  [./energy_relative_error]\n    type = ParsedPostprocessor\n    function = 'abs(enthalpy - heat) / heat'\n    pp_names = 'enthalpy heat'\n  [../]\n\nHere are enthalpy and heat plots of time:\n\nDo you think there is something wrong with the way I integrate? Why is there such a big error? Here are complete files.\nfiles.zip\nBest regards.\nXu.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3560578",
                          "updatedAt": "2022-09-05T14:32:33Z",
                          "publishedAt": "2022-09-05T14:32:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is cp constant? If not then your enthalpy integral is approximate\nsame question for power",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3561862",
                          "updatedAt": "2022-09-05T16:26:40Z",
                          "publishedAt": "2022-09-05T16:26:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Yeah, rho and cp are all constants.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3561919",
                          "updatedAt": "2022-09-05T16:31:35Z",
                          "publishedAt": "2022-09-05T16:31:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "ohhh I didn't see you are using SUPG. The usual form of the SUPG operator introduces dissipation hence enthalpy is not conserved. IIRC there is a straightforward modification you can make to guarantee conservation though.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3561933",
                          "updatedAt": "2022-09-05T16:32:39Z",
                          "publishedAt": "2022-09-05T16:32:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "In other words, I think if you use the unstabilized heat equation in the fluid, you should be able to demonstrate enthalpy conservation, although the advection messes up your solution.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3561970",
                          "updatedAt": "2022-09-05T16:35:08Z",
                          "publishedAt": "2022-09-05T16:35:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Do you mean that if I remove SUPG operator, I can get enthalpy \uff1d heat?",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3562017",
                          "updatedAt": "2022-09-05T16:39:20Z",
                          "publishedAt": "2022-09-05T16:39:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Actually, I've demonstrated the conservation of energy only for solid heat conduction. The results were very good, with an error of one in 10,000. But when I add fluid convective heat transfer, the error is very large.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3562055",
                          "updatedAt": "2022-09-05T16:42:51Z",
                          "publishedAt": "2022-09-05T16:42:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "js-jixu"
                  },
                  "bodyText": "I have a 2D model. In the middle of the model is a solid area with an internal heat source, with fluid areas on both sides. There is conjugate heat transfer between the solid region and the fluid region. I want to verify the conservation of energy when calculating heat transfer. I set the temperature boundary conditions as natural boundary conditions (no boundary conditions) to achieve the purpose of insulating the entire system.\n\nInitially I wanted to verify the conservation of energy by transient calculations, using rho*cp*\u0394T to calculate the energy absorbed by the fluid. There are problems with this formula, the most obvious one being that it doesn't take velocity into account. And it is not proper to use transient calculations to verify energy conservation.\n@lindsayad wrote an input file for verifying energy conservation using steady-state calculations. He integrates rho*cp*u*\u25bdT to get the energy absorbed by the fluid. Together with the energy of the reaction term, it is exactly equal to the energy released by the solid region.\nIt should be noted that the thermal conductivity equation in the solid region is -k\u25bd\u00b2T=0, while all boundary conditions are \u25bdT=0. Under the above conditions, a definite solution cannot be obtained. So @lindsayad adds a reaction term to the steady state heat conduction equation in the solid region, which is used to remove the null-space in the temperature equation.\nHere is the input file written by @lindsayad:\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    nx = 10\n    ny = 10\n    dim = 2\n  []\n  [subdomain]\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0.5 0 0'\n    top_right = '1 1 0'\n    block_id = 1\n    input = gen\n  []\n  [break_boundary]\n    input = subdomain\n    type = BreakBoundaryOnSubdomainGenerator\n    boundaries = 'bottom top'\n  []\n  [sideset]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = break_boundary\n    primary_block = '1'\n    paired_block = '0'\n    new_boundary = 'fluid_left'\n  []\n  coord_type = RZ\n  second_order = true\n[]\n\n[Variables]\n  [T]\n    order = SECOND\n  []\n  [velocity]\n    family = LAGRANGE_VEC\n    order = SECOND\n    block = 1\n  []\n  [pressure]\n    block = 1\n  []\n[]\n\n[ICs]\n  [vel]\n    type = VectorConstantIC\n    variable = velocity\n    x_value = 1e-15\n    y_value = 1e-15\n    block = 1\n  []\n[]\n\n[Kernels]\n  [mass]\n    type = INSADMass\n    variable = pressure\n    block = 1\n  []\n\n  [momentum_convection]\n    type = INSADMomentumAdvection\n    variable = velocity\n    block = 1\n  []\n  [momentum_viscous]\n    type = INSADMomentumViscous\n    variable = velocity\n    block = 1\n  []\n  [momentum_pressure]\n    type = INSADMomentumPressure\n    variable = velocity\n    pressure = pressure\n    integrate_p_by_parts = true\n    block = 1\n  []\n\n  [temperature_advection]\n    type = INSADEnergyAdvection\n    variable = T\n     block = 1\n  []\n  [temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    thermal_conductivity = 'k'\n  []\n  [heat_source]\n    type = BodyForce\n    variable = T\n    block = 0\n    function = 'x + y'\n  []\n  [remove_null_space]\n    variable = T\n    block = 0\n    type = Reaction\n  []\n[]\n\n[BCs]\n  [velocity_inlet]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    function_y = 1\n    boundary = 'bottom_to_1'\n  []\n  [wall]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'fluid_left right'\n  []\n[]\n\n[Materials]\n  [constant]\n    type = ADGenericConstantMaterial\n    prop_names = 'cp rho k mu'\n    prop_values = '1 1   1 1'\n  []\n  [ins]\n    type = INSAD3Eqn\n    pressure = pressure\n    velocity = velocity\n    temperature = T\n    block = 1\n  []\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n[Postprocessors]\n  [reaction]\n    type = ElementIntegralVariablePostprocessor\n    variable = T\n    block = 0\n  []\n  [advection]\n    type = INSADElementIntegralEnergyAdvection\n    temperature = T\n    velocity = velocity\n    cp = cp\n    rho = rho\n    block = 1\n  []\n  [source]\n    type = FunctionElementIntegral\n    function = 'x + y'\n    block = 0\n  []\n  [sum]\n    type = ParsedPostprocessor\n    function = 'reaction + advection - source'\n    pp_names = 'reaction advection source'\n  []\n[]\n\nSincere thanks to @lindsayad @hugary1995 @GiudGiud for their patient replies.",
                  "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3653072",
                  "updatedAt": "2022-09-15T11:39:12Z",
                  "publishedAt": "2022-09-15T11:37:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Thanks for the summary @js-jixu. Can you mark this discussion as answered?",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3657017",
                          "updatedAt": "2022-09-15T19:50:39Z",
                          "publishedAt": "2022-09-15T19:50:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Gasket type elements",
          "author": {
            "login": "srinath-chakravarthy"
          },
          "bodyText": "Hi all,\nI would like to develop a gasket type element. One example of this is a QUAD4 element with 4 nodes, however with integration points lying on the mid-plane between bottom and top of the element. How would i go about doing this ?.I have looked at libmesh/elem and libmesh/gaussian_quad. So would i just define a new element QUAD4G and attach a default new quadrature rule to this element ? If so how would i integrate this into moose.\nIn essence this will be like a finite-thickness traditional cohesive element. The nice thing is the finite thckness version is non-singular and can presumably use all existing moose methods.\nI understand that there is a DG version of cohesive element in moose, but i am not able to decipher if this can be used for a finite thickness context.\nCheers\nSrinath",
          "url": "https://github.com/idaholab/moose/discussions/22082",
          "updatedAt": "2022-09-29T16:52:16Z",
          "publishedAt": "2022-09-13T15:19:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "Any suggestions anyone ?",
                  "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3647776",
                  "updatedAt": "2022-09-14T19:20:41Z",
                  "publishedAt": "2022-09-14T19:20:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@roystgnr",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3648145",
                          "updatedAt": "2022-09-14T20:23:40Z",
                          "publishedAt": "2022-09-14T20:23:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "There seems to be a bit of language difference here - the midplane between the top and bottom of a Quad4 with planar nodes is the Quad4 - it's a Face, a 2-D manifold (albeit not planar in the general case; you can have a \"twist\" between opposing edges) element. You can use it to solve an approximation to a 3-D problem, but that happens in the problem formulation (in the kernel), not the Elem.\nMaybe that's a bigger language difference?  The combination of geometric Elem and FE space and physics kernel all together is what other idioms sometimes lump together as an \"element\" ... but IMHO trying to explicitly add every combination ahead of time is like insisting on finding the \"element name\" key on a keyboard that already has e,l,m,n,t, and a.\nWhen I solve shallow water flow on a quad mesh, I don't need to define QUAD4S as a new ElemType; the depth-integrated equations went from 3D to 2D, so I just derive a weak form, add FE variables (which is what defines the \"Finite Element\" in the mathematical sense; it's not just the geometric element), and then I'd probably use Gaussian quadrature to solve those, but that all works with standard quads and/or triangles on a 2D domain, because while there's a 3D physics, in that formulation it's entirely defined by the 2D depth-averaged equations.  Or suppose I had a beam equation - I might add displacement variables with FEType of HERMITE to solve the $C^1$ weak form, or twice as many variables (e.g. displacements plus rotations) with some $C^0$ type like LAGRANGE to solve a mixed form, but either way I'd be solving on an ordinary EDGE2 or EDGE3 mesh.\nIn your case, then?  What you need to write depends on the shape function and quadrature details.  If you can describe a solution solely on an hex element's midplane and there's a canonical way to extrapolate from that quad midplane to the full hex, then you can almost certainly run on a standard Quad4 or Quad9.  Can you write the space of shape functions on that plane with (a tensor product of!) existing spaces in libMesh?  If so then you're good to go there too; if not then that's what you'll end up having to write a new FE subclass and FEType for.  Are your quadrature points described by one of the standard rules?  Even if not then you definitely don't want to try to edit the Gaussian quadrature, which already has a standard definition on quads, but in that case you'll have to add your own QBase subclass and corresponding QuadratureType.",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3648418",
                          "updatedAt": "2022-09-14T21:13:12Z",
                          "publishedAt": "2022-09-14T21:13:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I believe there's a misunderstanding. @srinath-chakravarthy was asking for a genuine new type of quadrature rule. He was talking about Quad4 in 2-D as a volume element instead of Quad4 in 3-D as a face element. Instead of the standard Gaussian quadrature, he wants to place quadrature points along the midline (not midplane) of the Quad4 element. So I think @roystgnr 's suggestion towards the end should apply.\nWhat I have trouble understanding is that a Quad4 element has two orthogonal midlines, how do you want to tell the new quadrature rule to use one over the other @srinath-chakravarthy ?",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655611",
                          "updatedAt": "2022-09-15T16:22:20Z",
                          "publishedAt": "2022-09-15T16:22:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "ok, I can see that Abaqus has its own convention :-)\nhttps://classes.engineering.wustl.edu/2009/spring/mase5513/abaqus/docs/v6.6/books/usb/default.htm?startat=pt06ch26s06alm47.html",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655652",
                          "updatedAt": "2022-09-15T16:25:35Z",
                          "publishedAt": "2022-09-15T16:25:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Oh, the midline!  I was imaging a new type of shell element.  Thanks for clarifying!\nYeah, \"your own QBase subclass and corresponding QuadratureType\" would be the way to go here.\n\na Quad4 element has two orthogonal midlines, how do you want to tell the new quadrature rule to use one over the other\n\nThat's actually doable in the mesh generator - since we always map elem->point(0) in physical space back to (-1,-1) in master space (and then go counter-clockwise from there), a quadrature rule that always returns points on the xi axis will always return points on the midline bisecting edges 03 and 12; a rule that always returns points on the eta axis will always return points on the line bisecting 01 and 32",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655667",
                          "updatedAt": "2022-09-15T16:27:06Z",
                          "publishedAt": "2022-09-15T16:27:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "srinath-chakravarthy"
                          },
                          "bodyText": "@hugary1995  thanks for clarifying and @roystgnr for the suggestions. The quadrature point definition is rather easy on the libmesh side. How would i go about the moose part of it, namely attaching this quadrature rule to the Quad4 element ?\n\nThat's actually doable in the mesh generator - since we always map elem->point(0) in physical space back to (-1,-1) in master space (and then go counter-clockwise from there), a quadrature rule that always returns points on the xi axis will always return points on the midline bisecting edges 03 and 12; a rule that always returns points on the eta axis will always return points on the line bisecting 01 and 32\",\nThis would mean i have to make sure that the physical point(0) and side (0,3) and side (1,2) is oriented in the direction of interest ?",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655804",
                          "updatedAt": "2022-09-15T16:42:04Z",
                          "publishedAt": "2022-09-15T16:42:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think once you set up your quadrature rule, you just need to add it to enum_quadrature_type.h. Then the SetupQuadratureAction in MOOSE should be able to pick that up automatically.",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655888",
                          "updatedAt": "2022-09-15T16:53:46Z",
                          "publishedAt": "2022-09-15T16:53:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Oh and also update the conversion table in Conversion.C::initQuadratureType().",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655939",
                          "updatedAt": "2022-09-15T16:59:11Z",
                          "publishedAt": "2022-09-15T16:59:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "On the libMesh side there's a few places to edit besides the new subclass's files and enum_quadrature_type.h - we'd need a case in quadrature_build.C, a map entry in string_to_enum.C, and we'd really want an instantiation in quadrature_test.C except that I'm not sure the tests there are appropriate for something that's underintegrating in that way.\nOff topic from the conversation here, but I don't like that manual code in Conversion.C.  It has to be edited to add new enums now, but ideally we wouldn't be having to change anything at all in MOOSE.  C++ doesn't even support enough reflection to iterate over a sparse enum's valid values, but maybe libMesh should provide some kind of container (a constexpr initializer_list??) of enum values and then Conversion.C could iterate over that and do enum_to_string (and prepend that extra Q) with each.  We have to write string conversions in libMesh for new enum entries, but we ought to be able to get away with not writing a redundant isomorphic conversion elsewhere.",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3656305",
                          "updatedAt": "2022-09-15T17:48:35Z",
                          "publishedAt": "2022-09-15T17:48:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Off topic from the conversation here, but I don't like that manual code in Conversion.C. It has to be edited to add new enums now, but ideally we wouldn't be having to change anything at all in MOOSE. C++ doesn't even support enough reflection to iterate over a sparse enum's valid values, but maybe libMesh should provide some kind of container (a constexpr initializer_list??) of enum values and then Conversion.C could iterate over that and do enum_to_string (and prepend that extra Q) with each. We have to write string conversions in libMesh for new enum entries, but we ought to be able to get away with not writing a redundant isomorphic conversion elsewhere.\n\nYep, you are apparently on top of this #17810",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3656436",
                          "updatedAt": "2022-09-15T18:09:48Z",
                          "publishedAt": "2022-09-15T18:09:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}