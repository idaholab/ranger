{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wOS0xMFQwODowNzoxOC0wNjowMM4AbUaB"
    },
    "edges": [
      {
        "node": {
          "title": "How to set boundary conditions for a newly created subdomain?",
          "author": {
            "login": "PEI0214"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello\nI want to compute only in the newly created subdomain. So I only set the variables in the newly created subfield. But when I set the boundary condition, I got the following error:\n*** ERROR ***\n'archor_x' of type 'FunctionDirichletBC' depends on variable(s) 'disp_y,disp_z'. However, that variable does not appear to be defined on (all of) boundary ''.\n\nIs there any way to set boundary conditions for newly created subdomains?",
          "url": "https://github.com/idaholab/moose/discussions/28549",
          "updatedAt": "2024-09-11T23:36:33Z",
          "publishedAt": "2024-09-05T13:50:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "for newly created subdomains?\n\ndo you mean newly created boundaries?\nWhat did you specify for the boundary of FunctionDirichletBC ?",
                  "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10559140",
                  "updatedAt": "2024-09-05T15:17:05Z",
                  "publishedAt": "2024-09-05T15:17:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "PEI0214"
                  },
                  "bodyText": "For newly created subdomains refer to blocks.\nadd_subdomain_ids = '${new_block_ids}'\n\nFunctionDirichletBC limits the displacement of the boundary.\nThe variables and boundary conditions are set as follows:\n[Variables]\n  [disp_x]\n    block = '${new_block_ids}'\n  []\n  [disp_y]\n    block = '${new_block_ids}'\n  []\n  [disp_z]\n    block = '${new_block_ids}'\n  []\n[]\n\n[BCs]\n\n  [archor_x]\n    type = FunctionDirichletBC\n    boundary = 'bottom'\n    variable = disp_x\n    value = 0\n  []\n\n  [archor_y]\n    type = FunctionDirichletBC\n    boundary = 'bottom'\n    variable = disp_y\n    value = 0\n  []\n\n  [archor_z]\n    type = FunctionDirichletBC\n    boundary = 'bottom'\n    variable = disp_z\n    value = 0\n  []\n[]\n\nThe 'bottom' is the boundary of the initial grid.  Is there a way to add a boundary to a newly created block?",
                  "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10564971",
                  "updatedAt": "2024-09-06T06:06:58Z",
                  "publishedAt": "2024-09-06T05:57:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can create new boundary using this object\nhttps://mooseframework.inl.gov/source/meshmodifiers/SidesetAroundSubdomainUpdater.html\nand predeclare it using the add_sideset_ids / names parameter",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10568674",
                          "updatedAt": "2024-09-06T12:15:43Z",
                          "publishedAt": "2024-09-06T12:15:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "That's not what I wanted. My grid and input files are as follows:\nMoves the initial grid blocks to the newly created blocks. And set the boundary conditions. Set the displacement of the bottom boundary (including 'bottom, left1, left2, left3, right1, right2, right3') to 0.\nCan you run it? And give some advice? Is there a way to set variables for boundaries?",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10570382",
                          "updatedAt": "2024-09-19T08:46:43Z",
                          "publishedAt": "2024-09-06T14:56:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "@GiudGiud Hello\uff0cdo you have any good suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10582361",
                          "updatedAt": "2024-09-08T14:18:53Z",
                          "publishedAt": "2024-09-08T14:18:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ll take a look. I still dont understand what you really want but it might come\n\nIs there a way to set variables for boundaries?\n\nUsing dirichlet boundary conditions",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10582376",
                          "updatedAt": "2024-09-08T14:22:11Z",
                          "publishedAt": "2024-09-08T14:22:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "ok I think I know what you are trying to do.\nThere's an integrity check on the variable restrictions vs the dirichlet BCs boudnary restrictions\nSet this parameter to bypass it\n[Problem]\n  boundary_restricted_node_integrity_check = false\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10583602",
                  "updatedAt": "2024-09-08T17:43:00Z",
                  "publishedAt": "2024-09-08T17:42:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "That solves the problem. Thank you very much for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10585634",
                          "updatedAt": "2024-09-09T02:36:31Z",
                          "publishedAt": "2024-09-09T02:36:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "Hello\nThe following error occurred when I set the pressure. Do you have any good suggestions?\n*** ERROR ***\nError constructing object 'wateface_pressure' while retrieving value for 'variable' parameter! Did you forget to set 'variable' or set it to '' (empty string) by accident?\n\nThe pressure boundary conditions are set as follows:\n[Functions]\n  [w_p1]\n    type = ParsedFunction\n    expression = 'max(1e3 * (t -10), 0)'\n  []\n[]\n\n[BCs]\n  [wateface_pressure]\n    type = Pressure\n    boundary = 'top'\n    function = w_p1\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10588869",
                          "updatedAt": "2024-09-09T09:35:16Z",
                          "publishedAt": "2024-09-09T09:35:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The error message is correct here I think.\nYou are missing the variable parameter in this water_pressure BC",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10589653",
                          "updatedAt": "2024-09-09T10:59:33Z",
                          "publishedAt": "2024-09-09T10:59:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "When I add a variable, I still get this error.",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10590081",
                          "updatedAt": "2024-09-19T08:47:27Z",
                          "publishedAt": "2024-09-09T11:45:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the syntax for the Pressure action is wrong, it should not be nested under BCs, but under Pressure\nsee this page\nhttps://mooseframework.inl.gov/syntax/BCs/Pressure/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10590123",
                          "updatedAt": "2024-09-09T11:50:15Z",
                          "publishedAt": "2024-09-09T11:50:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "https://mooseframework.inl.gov/syntax/BCs/Pressure/index.html\nThe Pressure in this file should be under BCs. I still get an error when I add Pressure according to the syntax in the file.",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10590206",
                          "updatedAt": "2024-09-09T11:58:33Z",
                          "publishedAt": "2024-09-09T11:58:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "right but it should be\n[BCs]\n  [Pressure]\n    [wateface_pressure]\n      boundary = 'bottom'\n      function = w_p1\n      displacements = 'disp_x disp_y disp_z'\n     []\n  []\n[]\n\nbased on the example",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10590458",
                          "updatedAt": "2024-09-09T12:33:40Z",
                          "publishedAt": "2024-09-09T12:23:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "I did so. But that didn't work. Can you run it?",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10590508",
                          "updatedAt": "2024-09-09T12:29:32Z",
                          "publishedAt": "2024-09-09T12:29:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does your BC block look like now?",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10590603",
                          "updatedAt": "2024-09-09T12:38:26Z",
                          "publishedAt": "2024-09-09T12:38:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "[BCs]\n  [archor_x]\n    type = DirichletBC\n    boundary = 'bottom left1 left2 left3 right1 right2 right3'\n    variable = disp_x\n    value = 0\n  []\n\n  [archor_y]\n    type = DirichletBC\n    boundary = 'bottom left1 left2 left3 right1 right2 right3'\n    variable = disp_y\n    value = 0\n  []\n\n  [archor_z]\n    type = DirichletBC\n    boundary = 'bottom left1 left2 left3 right1 right2 right3'\n    variable = disp_z\n    value = 0\n  []\n\n  [Pressure]\n    [pressure1]\n      boundary = 'top'\n      function = 'max(1000 * (t - 10) ,0)'\n    []\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28549#discussioncomment-10590713",
                          "updatedAt": "2024-09-09T12:46:44Z",
                          "publishedAt": "2024-09-09T12:46:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiapp setting in transient and SIMPLE executioner",
          "author": {
            "login": "lucuo"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI am now trying to use multiapps to solve the thermal fluid-structure coupling calculation. The mainapp for solid domain calculations, his executioner settings as follows.\n[Executioner]\n  type = Transient \n  solve_type = 'PJFNK'\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '201    hypre   boomeramg    4'\n  line_search = 'none'\n  automatic_scaling = true\n  l_max_its = 50\n  nl_max_its = 15\n  nl_forced_its = 2  # I set it, but it was not run in step of multiapp\n  nl_rel_tol = 1e-4\n  nl_abs_tol = 1e-10\n  start_time = 0.0\n  end_time = 10\n  dt = 1\n[]\n\nMy subapp uses the SIMPLENonlinearAssembly algorithm to solve, and his executioner Settings are as follows.\n[Executioner]\n  type = SIMPLENonlinearAssembly\n  # petsc_options_iname = '-pc_type -pc_hypre_type -pc_factor_shift_type'\n  # petsc_options_value = 'hypre boomeramg NONZERO'\n  rhie_chow_user_object = 'rc'\n  momentum_systems = 'u_system v_system w_system'\n  pressure_system = 'pressure_system'\n  energy_system = 'energy_system'\n  pressure_gradient_tag = ${pressure_tag}\n  momentum_equation_relaxation = 0.05\n  pressure_variable_relaxation = 0.05\n   energy_equation_relaxation = 0.05\n  num_iterations = 100\n  pressure_absolute_tolerance = 1e-2\n  momentum_absolute_tolerance = 1e-2\n  ### energy_absolute_tolerance = 1e-2\n  print_fields = false\n  #output_linear_residuals = true  # \u8f93\u51fa\u6bcf\u6b65\u7ebf\u6027\u6b8b\u5dee\n  #output_nonlinear_residuals = true  # \u8f93\u51fa\u6bcf\u6b65\u975e\u7ebf\u6027\u6b8b\u5dee\n  momentum_l_abs_tol = 1e-2\n  pressure_l_abs_tol = 1e-2\n  ### energy_l_abs_tol = 1e-2\n  momentum_l_tol = 0\n  pressure_l_tol = 0\n  ### energy_l_tol = 0\n  momentum_petsc_options_iname = '-pc_type -pc_hypre_type -ksp_type -ksp_rtol -ksp_gmres_restart -pc_factor_shift_type'\n  momentum_petsc_options_value = 'hypre boomeramg gmres     1e-2      300  NONZERO'\n  pressure_petsc_options_iname = '-pc_type -pc_hypre_type -pc_factor_shift_type'\n  pressure_petsc_options_value = 'hypre boomeramg NONZERO'\n  energy_petsc_options_iname = '-pc_type -pc_hypre_type -pc_factor_shift_type'\n  energy_petsc_options_value = 'hypre boomeramg NONZERO'\n[]\n\nThe multiapps type I use is , which is set as follows.\n[MultiApps]\n    [./sub_up]\n      type = FullSolveMultiApp\n      input_files = '3d-segregated-energy.i'\n      output_in_position = true\n      execute_on = timestep_end\n      ignore_solve_not_converge = true\n    [../]\n[]\n\nNow the problem I have is this. In the process of iterative solution, the main program calculation needs to carry out nonlinear iterative solution for many times, but in this calculation, the mainapp only carries out linear iteration from the iteration of the second step.(I want him to run nonlinear iterations and I set nonlinear iterations nl_forced_its = 2) . What is the cause of this problem\nThe output recording process of the program is as follows (the output of fluid domain iteration is hidden by me). There will be nonlinear iteration in the first step, but only linear iteration will be carried out from the second step. May I ask whether the problem is set by Executioner or the problem of FullSolveMultiApp? How can I improve? Thank you very much for your help.\nMOOSE Version:           git commit dc00ea5 on 2024-07-03\nLibMesh Version:         \nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1\nCurrent Time:            Mon Sep  9 20:43:34 2024\nExecutable Timestamp:    Thu Aug 15 22:55:21 2024\n\nCheckpoint:\n  Wall Time Interval:      Every 3600.000000 s\n  User Checkpoint:         Disabled\n  # Checkpoints Kept:      2\n  Execute On:              TIMESTEP_END \n\nParallelism:\n  Num Processors:          24\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          3\n  Spatial Dimension:       3\n  Nodes:                   \n    Total:                 17556\n    Local:                 962\n    Min/Max/Avg:           682/962/731\n  Elems:                   \n    Total:                 15600\n    Local:                 650\n    Min/Max/Avg:           650/650/650\n  Num Subdomains:          1\n  Num Partitions:          24\n  Partitioner:             centroid\n\nNonlinear System:\n  Num DOFs:                70224\n  Num Local DOFs:          3848\n  Variables:               { \"temp\" \"disp_x\" \"disp_y\" \"disp_z\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                189156\n  Num Local DOFs:          8112\n  Variables:               { \"ht_flux\" \"f_temp_element\" \"f_temp_element2\" } \"f_temp_node\" { \"channel_Hw\" \n                             \"vonmises_stress\" \"stress_xx\" \"stress_yy\" \"stress_zz\" \"strain_xx\" \"strain_yy\" \n                             \"strain_zz\" } \n  Finite Element Types:    \"MONOMIAL\" \"LAGRANGE\" \"MONOMIAL\" \n  Approximation Orders:    \"CONSTANT\" \"FIRST\" \"CONSTANT\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  TimeIntegrator:          ImplicitEuler\n  Solver Mode:             Preconditioned JFNK\n  PETSc Preconditioner:    lu mat_superlu_dist_fact: SamePattern  mat_superlu_dist_replacetinypivot: true \n  MOOSE Preconditioner:    SMP\n\n\ufffd[36msub_up0: \ufffd[39mParallelism:\n\ufffd[36msub_up0: \ufffd[39m  Num Processors:          24\n\ufffd[36msub_up0: \ufffd[39m  Num Threads:             1\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mMesh: \n\ufffd[36msub_up0: \ufffd[39m  Parallel Type:           replicated\n\ufffd[36msub_up0: \ufffd[39m  Mesh Dimension:          3\n\ufffd[36msub_up0: \ufffd[39m  Spatial Dimension:       3\n\ufffd[36msub_up0: \ufffd[39m  Nodes:                   \n\ufffd[36msub_up0: \ufffd[39m    Total:                 33440\n\ufffd[36msub_up0: \ufffd[39m    Local:                 1659\n\ufffd[36msub_up0: \ufffd[39m    Min/Max/Avg:           1071/1692/1393\n\ufffd[36msub_up0: \ufffd[39m  Elems:                   \n\ufffd[36msub_up0: \ufffd[39m    Total:                 30000\n\ufffd[36msub_up0: \ufffd[39m    Local:                 1219\n\ufffd[36msub_up0: \ufffd[39m    Min/Max/Avg:           1214/1283/1250\n\ufffd[36msub_up0: \ufffd[39m  Num Subdomains:          1\n\ufffd[36msub_up0: \ufffd[39m  Num Partitions:          24\n\ufffd[36msub_up0: \ufffd[39m  Partitioner:             metis\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mNonlinear System 0:\n\ufffd[36msub_up0: \ufffd[39m  Num DOFs:                30000\n\ufffd[36msub_up0: \ufffd[39m  Num Local DOFs:          1219\n\ufffd[36msub_up0: \ufffd[39m  Variables:               \"vel_x\" \n\ufffd[36msub_up0: \ufffd[39m  Finite Element Types:    \"MONOMIAL\" \n\ufffd[36msub_up0: \ufffd[39m  Approximation Orders:    \"CONSTANT\" \n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mNonlinear System 1:\n\ufffd[36msub_up0: \ufffd[39m  Num DOFs:                30000\n\ufffd[36msub_up0: \ufffd[39m  Num Local DOFs:          1219\n\ufffd[36msub_up0: \ufffd[39m  Variables:               \"vel_y\" \n\ufffd[36msub_up0: \ufffd[39m  Finite Element Types:    \"MONOMIAL\" \n\ufffd[36msub_up0: \ufffd[39m  Approximation Orders:    \"CONSTANT\" \n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mNonlinear System 2:\n\ufffd[36msub_up0: \ufffd[39m  Num DOFs:                30000\n\ufffd[36msub_up0: \ufffd[39m  Num Local DOFs:          1219\n\ufffd[36msub_up0: \ufffd[39m  Variables:               \"vel_z\" \n\ufffd[36msub_up0: \ufffd[39m  Finite Element Types:    \"MONOMIAL\" \n\ufffd[36msub_up0: \ufffd[39m  Approximation Orders:    \"CONSTANT\" \n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mNonlinear System 3:\n\ufffd[36msub_up0: \ufffd[39m  Num DOFs:                30000\n\ufffd[36msub_up0: \ufffd[39m  Num Local DOFs:          1219\n\ufffd[36msub_up0: \ufffd[39m  Variables:               \"pressure\" \n\ufffd[36msub_up0: \ufffd[39m  Finite Element Types:    \"MONOMIAL\" \n\ufffd[36msub_up0: \ufffd[39m  Approximation Orders:    \"CONSTANT\" \n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mNonlinear System 4:\n\ufffd[36msub_up0: \ufffd[39m  Num DOFs:                30000\n\ufffd[36msub_up0: \ufffd[39m  Num Local DOFs:          1219\n\ufffd[36msub_up0: \ufffd[39m  Variables:               \"T_fluid\" \n\ufffd[36msub_up0: \ufffd[39m  Finite Element Types:    \"MONOMIAL\" \n\ufffd[36msub_up0: \ufffd[39m  Approximation Orders:    \"CONSTANT\" \n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mAuxiliary System:\n\ufffd[36msub_up0: \ufffd[39m  Num DOFs:                63440\n\ufffd[36msub_up0: \ufffd[39m  Num Local DOFs:          2878\n\ufffd[36msub_up0: \ufffd[39m  Variables:               \"f_soild_flux\" \"h_flux\" \n\ufffd[36msub_up0: \ufffd[39m  Finite Element Types:    \"MONOMIAL\" \"LAGRANGE\" \n\ufffd[36msub_up0: \ufffd[39m  Approximation Orders:    \"CONSTANT\" \"FIRST\" \n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mExecution Information:\n\ufffd[36msub_up0: \ufffd[39m  Executioner:             SIMPLENonlinearAssembly\n\ufffd[36msub_up0: \ufffd[39m  Solver Mode:             Preconditioned JFNK\n\ufffd[36msub_up0: \ufffd[39m  MOOSE Preconditioner 0:  FDP\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m\n\nTime Step 0, time = 0\n\nTime Step 1, time = 1, dt = 1\n 0 Nonlinear |R| = \ufffd[32m4.809470e+07\ufffd[39m\n      0 Linear |R| = \ufffd[32m4.809470e+07\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.471996e+04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m3.096357e+02\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m 15.60 s\ufffd[39m] [\ufffd[33m  392 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\n\ufffd[36m\n*** Info ***\nAutomated diagnosis did not detect any floating point indetermination in the transfer. You may consider turning it off using `search_value_conflicts=false` to improve performance/scalability.\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mIteration 1 Initial residual norms:\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 1 \ufffd[32m0.999999\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 2 \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 3 \ufffd[32m0.999999\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Pressure equation: \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Energy equation: \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mTurbulence Iteration \n.....\n\ufffd[36msub_up0: \ufffd[39m Passive Scalar Iteration 40\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mOutlier Variable Residual Norms:\n\ufffd[36msub_up0: \ufffd[39m  vel_x: \ufffd[31m1.246887e-01\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_y: \ufffd[31m2.247223e+05\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_z: \ufffd[31m9.960882e-02\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  pressure: \ufffd[31m5.306563e+03\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  T_fluid: \ufffd[31m2.017551e+10\ufffd[39m\n    Finished Executing MultiApps                                                         [\ufffd[33m358.89 s\ufffd[39m] [\ufffd[33m  400 MB\ufffd[39m]\n  Finished Executing MultiApps                                                           [\ufffd[33m358.92 s\ufffd[39m] [\ufffd[33m  400 MB\ufffd[39m]\n\nOutlier Variable Residual Norms:\n  temp: \ufffd[31m3.096357e+02\ufffd[39m\n\nTime Step 2, time = 2, dt = 1\n      0 Linear |R| = \ufffd[32m4.669242e+07\ufffd[39m\n      1 Linear |R| = \ufffd[32m3.541467e+07\ufffd[39m\n      2 Linear |R| = \ufffd[32m2.112772e+07\ufffd[39m\n      3 Linear |R| = \ufffd[32m1.291262e+07\ufffd[39m\n      4 Linear |R| = \ufffd[32m6.802449e+06\ufffd[39m\n      5 Linear |R| = \ufffd[32m3.421253e+06\ufffd[39m\n      6 Linear |R| = \ufffd[32m1.878802e+06\ufffd[39m\n      7 Linear |R| = \ufffd[32m1.198107e+06\ufffd[39m\n      8 Linear |R| = \ufffd[32m6.219310e+05\ufffd[39m\n      9 Linear |R| = \ufffd[32m3.416913e+05\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mIteration 1 Initial residual norms:\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 1 \ufffd[32m0.459476\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 2 \ufffd[32m0.429843\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 3 \ufffd[32m0.622183\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Pressure equation: \ufffd[32m0.10511\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Energy equation: \ufffd[32m0.0352354\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mTurbulence Iteration \n.....\n\ufffd[36msub_up0: \ufffd[39m Passive Scalar Iteration 40\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mOutlier Variable Residual Norms:\n\ufffd[36msub_up0: \ufffd[39m  vel_x: \ufffd[31m2.624380e-03\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_y: \ufffd[31m2.247218e+05\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_z: \ufffd[31m2.370897e-03\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  pressure: \ufffd[31m5.306599e+03\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  T_fluid: \ufffd[31m2.017562e+10\ufffd[39m\n    Finished Executing MultiApps                                                         [\ufffd[33m173.93 s\ufffd[39m] [\ufffd[33m  401 MB\ufffd[39m]\n  Finished Executing MultiApps                                                           [\ufffd[33m173.94 s\ufffd[39m] [\ufffd[33m  401 MB\ufffd[39m]\n\nOutlier Variable Residual Norms:\n  temp: \ufffd[31m4.669242e+07\ufffd[39m\n\nTime Step 3, time = 3, dt = 1\n      0 Linear |R| = \ufffd[32m4.669656e+07\ufffd[39m\n      1 Linear |R| = \ufffd[32m3.541385e+07\ufffd[39m\n      2 Linear |R| = \ufffd[32m2.113508e+07\ufffd[39m\n      3 Linear |R| = \ufffd[32m1.292112e+07\ufffd[39m\n      4 Linear |R| = \ufffd[32m6.823898e+06\ufffd[39m\n      5 Linear |R| = \ufffd[32m3.418508e+06\ufffd[39m\n      6 Linear |R| = \ufffd[32m1.874484e+06\ufffd[39m\n      7 Linear |R| = \ufffd[32m1.194857e+06\ufffd[39m\n      8 Linear |R| = \ufffd[32m6.179547e+05\ufffd[39m\n      9 Linear |R| = \ufffd[32m3.387257e+05\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mIteration 1 Initial residual norms:\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 1 \ufffd[32m0.173687\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 2 \ufffd[32m0.303465\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 3 \ufffd[32m0.141008\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Pressure equation: \ufffd[32m0.0833745\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Energy equation: \ufffd[32m0.0105228\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mTurbulence Iteration \n.....\n\ufffd[36msub_up0: \ufffd[39m Passive Scalar Iteration 40\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mOutlier Variable Residual Norms:\n\ufffd[36msub_up0: \ufffd[39m  vel_x: \ufffd[31m1.508197e-04\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_y: \ufffd[31m2.247218e+05\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_z: \ufffd[31m1.533745e-04\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  pressure: \ufffd[31m5.306601e+03\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  T_fluid: \ufffd[31m2.017569e+10\ufffd[39m\n    Finished Executing MultiApps                                                         [\ufffd[33m174.32 s\ufffd[39m] [\ufffd[33m  402 MB\ufffd[39m]\n  Finished Executing MultiApps                                                           [\ufffd[33m174.32 s\ufffd[39m] [\ufffd[33m  402 MB\ufffd[39m]\n\nOutlier Variable Residual Norms:\n  temp: \ufffd[31m4.669656e+07\ufffd[39m\n\nTime Step 4, time = 4, dt = 1\n      0 Linear |R| = \ufffd[32m4.669402e+07\ufffd[39m\n      1 Linear |R| = \ufffd[32m3.541127e+07\ufffd[39m\n      2 Linear |R| = \ufffd[32m2.113192e+07\ufffd[39m\n      3 Linear |R| = \ufffd[32m1.291635e+07\ufffd[39m\n      4 Linear |R| = \ufffd[32m6.819506e+06\ufffd[39m\n      5 Linear |R| = \ufffd[32m3.417130e+06\ufffd[39m\n      6 Linear |R| = \ufffd[32m1.874242e+06\ufffd[39m\n      7 Linear |R| = \ufffd[32m1.195229e+06\ufffd[39m\n      8 Linear |R| = \ufffd[32m6.187997e+05\ufffd[39m\n      9 Linear |R| = \ufffd[32m3.395698e+05\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mIteration 1 Initial residual norms:\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 1 \ufffd[32m0.0418871\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 2 \ufffd[32m0.00252954\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 3 \ufffd[32m0.0492365\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Pressure equation: \ufffd[32m0.00338572\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Energy equation: \ufffd[32m0.00664526\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mTurbulence Iteration \n.....\n\ufffd[36msub_up0: \ufffd[39m Passive Scalar Iteration 40\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mOutlier Variable Residual Norms:\n\ufffd[36msub_up0: \ufffd[39m  vel_x: \ufffd[31m1.475322e-04\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_y: \ufffd[31m2.247218e+05\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_z: \ufffd[31m1.479738e-04\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  pressure: \ufffd[31m5.306601e+03\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  T_fluid: \ufffd[31m2.017576e+10\ufffd[39m\n    Finished Executing MultiApps                                                         [\ufffd[33m182.01 s\ufffd[39m] [\ufffd[33m  403 MB\ufffd[39m]\n  Finished Executing MultiApps                                                           [\ufffd[33m182.06 s\ufffd[39m] [\ufffd[33m  403 MB\ufffd[39m]\n\nOutlier Variable Residual Norms:\n  temp: \ufffd[31m4.669402e+07\ufffd[39m\n\nTime Step 5, time = 5, dt = 1\n      0 Linear |R| = \ufffd[32m4.669405e+07\ufffd[39m\n      1 Linear |R| = \ufffd[32m3.541139e+07\ufffd[39m\n      2 Linear |R| = \ufffd[32m2.113199e+07\ufffd[39m\n      3 Linear |R| = \ufffd[32m1.291664e+07\ufffd[39m\n      4 Linear |R| = \ufffd[32m6.820135e+06\ufffd[39m\n      5 Linear |R| = \ufffd[32m3.417141e+06\ufffd[39m\n      6 Linear |R| = \ufffd[32m1.874041e+06\ufffd[39m\n      7 Linear |R| = \ufffd[32m1.194833e+06\ufffd[39m\n      8 Linear |R| = \ufffd[32m6.182486e+05\ufffd[39m\n      9 Linear |R| = \ufffd[32m3.390971e+05\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mIteration 1 Initial residual norms:\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 1 \ufffd[32m0.0347057\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 2 \ufffd[32m0.000820605\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 3 \ufffd[32m0.0346063\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Pressure equation: \ufffd[32m0.00255769\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Energy equation: \ufffd[32m0.00485941\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mTurbulence Iteration \n......\n\ufffd[36msub_up0: \ufffd[39m Passive Scalar Iteration 40\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mOutlier Variable Residual Norms:\n\ufffd[36msub_up0: \ufffd[39m  vel_x: \ufffd[31m1.478493e-04\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_y: \ufffd[31m2.247218e+05\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_z: \ufffd[31m1.478046e-04\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  pressure: \ufffd[31m5.306601e+03\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  T_fluid: \ufffd[31m2.017583e+10\ufffd[39m\n    Finished Executing MultiApps                                                         [\ufffd[33m172.11 s\ufffd[39m] [\ufffd[33m  403 MB\ufffd[39m]\n  Finished Executing MultiApps                                                           [\ufffd[33m172.14 s\ufffd[39m] [\ufffd[33m  403 MB\ufffd[39m]\n\nOutlier Variable Residual Norms:\n  temp: \ufffd[31m4.669405e+07\ufffd[39m",
          "url": "https://github.com/idaholab/moose/discussions/28578",
          "updatedAt": "2024-09-11T21:45:20Z",
          "publishedAt": "2024-09-09T13:53:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think you need to take a step back and make sure both simulations converge before attempting to couple them.\nTHe convergence history shows both solves are not converging, with very high residuals left\nYou should set both linear and nonlinear residuals to output in the Outputs block\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28578#discussioncomment-10592560",
                  "updatedAt": "2024-09-09T15:06:17Z",
                  "publishedAt": "2024-09-09T15:06:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lucuo"
                          },
                          "bodyText": "Yes, subapp computing NS computation has not converged. But the first step of the transient calculation of the mainapp is convergent. So, the mainapp transient calculation does not do nonlinear iteration in the second step because the subapp does not converge?\nTime Step 0, time = 0\n\nTime Step 1, time = 1, dt = 1\n 0 Nonlinear |R| = \ufffd[32m4.809470e+07\ufffd[39m\n      0 Linear |R| = \ufffd[32m4.809470e+07\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.471996e+04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m3.096357e+02\ufffd[39m\n      0 Linear |R| = \ufffd[32m3.096357e+02\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.142657e-01\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m9.742861e-04\ufffd[39m\n      0 Linear |R| = \ufffd[32m9.742861e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m3.132244e-07\ufffd[39m\n 3 Nonlinear |R| = \ufffd[32m5.947938e-08\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\nCurrently Executing\n  Finished Solving \n\nAutomated diagnosis did not detect any floating point indetermination in the transfer. You may consider turning it off using `search_value_conflicts=false` to improve performance/scalability.\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mIteration 1 Initial residual norms:\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 1 \ufffd[32m0.999999\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 2 \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 3 \ufffd[32m0.999999\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Pressure equation: \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Energy equation: \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mTurbulence Iteration \n.....\n.....\n\ufffd[36msub_up0: \ufffd[39m Passive Scalar Iteration 50\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mOutlier Variable Residual Norms:\n\ufffd[36msub_up0: \ufffd[39m  vel_x: \ufffd[31m2.369030e+00\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_y: \ufffd[31m2.247225e+05\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_z: \ufffd[31m2.368925e+00\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  pressure: \ufffd[31m5.306184e+03\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  T_fluid: \ufffd[31m2.017603e+10\ufffd[39m\n    Finished Executing MultiApps                                                         [\ufffd[33m 49.71 s\ufffd[39m] [\ufffd[33m  389 MB\ufffd[39m]\n  Finished Executing MultiApps                                                           [\ufffd[33m 49.71 s\ufffd[39m] [\ufffd[33m  389 MB\ufffd[39m]\n\nOutlier Variable Residual Norms:\n  temp: \ufffd[31m5.947938e-08\ufffd[39m\n\nTime Step 2, time = 2, dt = 1\n      0 Linear |R| = \ufffd[32m4.669277e+07\ufffd[39m\n      1 Linear |R| = \ufffd[32m3.541490e+07\ufffd[39m\n      2 Linear |R| = \ufffd[32m2.112786e+07\ufffd[39m\n      3 Linear |R| = \ufffd[32m1.291270e+07\ufffd[39m\n      4 Linear |R| = \ufffd[32m6.802496e+06\ufffd[39m\n      5 Linear |R| = \ufffd[32m3.421276e+06\ufffd[39m\n      6 Linear |R| = \ufffd[32m1.878814e+06\ufffd[39m\n      7 Linear |R| = \ufffd[32m1.198115e+06\ufffd[39m\n      8 Linear |R| = \ufffd[32m6.219352e+05\ufffd[39m\n      9 Linear |R| = \ufffd[32m3.416936e+05\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mIteration 1 Initial residual norms:\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 1 \ufffd[32m0.704326\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 2 \ufffd[32m0.829437\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 3 \ufffd[32m0.691473\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Pressure equation: \ufffd[32m0.0988212\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Energy equation: \ufffd[32m0.0926524\ufffd[39m",
                          "url": "https://github.com/idaholab/moose/discussions/28578#discussioncomment-10593476",
                          "updatedAt": "2024-09-09T16:28:46Z",
                          "publishedAt": "2024-09-09T16:27:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You should remove this for now\n      ignore_solve_not_converge = true\n\nit does not do nonlinear iterations if it is already converged. With nl_rel_tol of 1e-4 it might be converged in 1 NL iteration",
                          "url": "https://github.com/idaholab/moose/discussions/28578#discussioncomment-10593544",
                          "updatedAt": "2024-09-09T16:35:23Z",
                          "publishedAt": "2024-09-09T16:35:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lucuo"
                          },
                          "bodyText": "Hello, I have removed ignore_solve_not_converge = true, but the iteration of the mainapp in step 2 still has no nonlinearity. I think the possible reason is that between the two \u2460 the iteration of the fluid app does not converge. \u2461 The fullsolvedmultiapp setting changes the mainapp convergence criteria.\nIn addition, when my subapp runs 3d-segregated-energy.i or 2d-segregated-energy.i, the program stops iterating(Normally it meets the convergence criteria for pressure, momentum and energy) but the T_fluid residual value of the output is too large. I think this is the reason why the subroutine does not converge.\nRunning 3d-segregated-energy.i or 2d-segregated-energy.i alone satisfies pressure_absolute_tolerance = 1e-13 momentum_absolute_tolerance = 1e-13 energy_absolute_tolerance = 1e-13\nWhen iteration is stopped, the output Tfluid residuals are still too large, and the convergence criterion of subroutine iteration is not applicable to SIMPLENonlinearAssembly computation. If it can be modified\nTime Step 0, time = 0\n\nTime Step 1, time = 1, dt = 1\n 0 Nonlinear |R| = \ufffd[32m4.809470e+07\ufffd[39m\n      0 Linear |R| = \ufffd[32m4.809470e+07\ufffd[39m\n      1 Linear |R| = \ufffd[32m8.366229e+04\ufffd[39m\n      2 Linear |R| = \ufffd[32m7.186666e+01\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m1.497849e+04\ufffd[39m\n      0 Linear |R| = \ufffd[32m1.497849e+04\ufffd[39m\n      1 Linear |R| = \ufffd[32m3.477019e+00\ufffd[39m\n      2 Linear |R| = \ufffd[32m6.778806e-03\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m4.267373e-01\ufffd[39m\n      0 Linear |R| = \ufffd[32m4.267373e-01\ufffd[39m\n      1 Linear |R| = \ufffd[32m6.053385e-05\ufffd[39m\n      2 Linear |R| = \ufffd[32m1.338816e-07\ufffd[39m\n 3 Nonlinear |R| = \ufffd[32m6.181346e-06\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mIteration 1 Initial residual norms:\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 1 \ufffd[32m9.75781e-07\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 2 \ufffd[32m9.75781e-07\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 3 \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Pressure equation: \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Energy equation: \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mTurbulence Iteration \n.......\n\n\ufffd[36msub_up0: \ufffd[39mIteration 84 Initial residual norms:\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 1 \ufffd[32m1.14255e-06\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 2 \ufffd[32m9.90535e-07\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 3 \ufffd[32m8.8479e-07\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Pressure equation: \ufffd[32m9.71587e-07\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Energy equation: \ufffd[32m9.86807e-06\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mTurbulence Iteration \n\ufffd[36msub_up0: \ufffd[39m Passive Scalar Iteration 84\n\ufffd[36msub_up0: \ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mOutlier Variable Residual Norms:\n\ufffd[36msub_up0: \ufffd[39m  vel_x: \ufffd[31m6.686837e-04\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_y: \ufffd[31m6.686842e-04\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  vel_z: \ufffd[31m6.976906e-02\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  pressure: \ufffd[31m4.142814e-02\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m  T_fluid: \ufffd[31m9.575829e+03\ufffd[39m\nAborting as solve did not converge\n\nTime Step 1, time = 0.5, dt = 0.5\n      0 Linear |R| = \ufffd[32m2.474844e+07\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.877096e+07\ufffd[39m\n      2 Linear |R| = \ufffd[32m1.119839e+07\ufffd[39m\n      3 Linear |R| = \ufffd[32m6.844111e+06\ufffd[39m\n      4 Linear |R| = \ufffd[32m3.605523e+06\ufffd[39m\n      5 Linear |R| = \ufffd[32m1.813377e+06\ufffd[39m\n      6 Linear |R| = \ufffd[32m9.958272e+05\ufffd[39m\n      7 Linear |R| = \ufffd[32m6.350362e+05\ufffd[39m\n      8 Linear |R| = \ufffd[32m3.296440e+05\ufffd[39m\n      9 Linear |R| = \ufffd[32m1.811076e+05\ufffd[39m\n     10 Linear |R| = \ufffd[32m1.007719e+05\ufffd[39m\n     11 Linear |R| = \ufffd[32m5.285892e+04\ufffd[39m\n     12 Linear |R| = \ufffd[32m3.044607e+04\ufffd[39m\n     13 Linear |R| = \ufffd[32m1.676661e+04\ufffd[39m\n     14 Linear |R| = \ufffd[32m9.358838e+03\ufffd[39m\n     15 Linear |R| = \ufffd[32m5.427682e+03\ufffd[39m\n     16 Linear |R| = \ufffd[32m3.064747e+03\ufffd[39m\n     17 Linear |R| = \ufffd[32m1.687410e+03\ufffd[39m\n     18 Linear |R| = \ufffd[32m9.475786e+02\ufffd[39m\n     19 Linear |R| = \ufffd[32m5.391898e+02\ufffd[39m\n     20 Linear |R| = \ufffd[32m3.102800e+02\ufffd[39m\n     21 Linear |R| = \ufffd[32m1.780052e+02\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mIteration 1 Initial residual norms:\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 1 \ufffd[32m9.75781e-07\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 2 \ufffd[32m9.75781e-07\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Momentum equation: Component 3 \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Pressure equation: \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39m Energy equation: \ufffd[32m1\ufffd[39m\n\ufffd[36msub_up0: \ufffd[39mTurbulence Iteration \n\nThe final result output when running 3d-segregated-energy.i or 2d-segregated-energy.i alone\n2d-segregated-energy.i\nIteration 88 Initial residual norms:\n Momentum equation: Component 1 5.75932e-16\n Momentum equation: Component 2 1.30731e-16\n Pressure equation: 7.58978e-15\n Energy equation: 9.08817e-14\nTurbulence Iteration\n Passive Scalar Iteration 88\n\nOutlier Variable Residual Norms:\n  vel_x: 5.406363e+01\n  vel_y: 4.210712e+00\n  pressure: 3.883315e-02\n  T_fluid: 1.160953e+05\n\n3d-segregated-energy.i\nIteration 125 Initial residual norms:\n Momentum equation: Component 1 7.44957e-11\n Momentum equation: Component 2 7.44929e-11\n Momentum equation: Component 3 9.87257e-11\n Pressure equation: 2.86239e-11\n Energy equation: 1.3411e-12\nTurbulence Iteration\n Passive Scalar Iteration 125\n\nOutlier Variable Residual Norms:\n  vel_x: 6.686864e-04\n  vel_y: 6.686864e-04\n  vel_z: 6.976859e-02\n  pressure: 4.142827e-02\n  T_fluid: 9.575821e+03",
                          "url": "https://github.com/idaholab/moose/discussions/28578#discussioncomment-10604650",
                          "updatedAt": "2024-09-10T15:50:36Z",
                          "publishedAt": "2024-09-10T15:50:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lucuo"
                          },
                          "bodyText": "This is my input file and mesh file\nsoild_fluid.zip",
                          "url": "https://github.com/idaholab/moose/discussions/28578#discussioncomment-10604763",
                          "updatedAt": "2024-09-10T16:00:29Z",
                          "publishedAt": "2024-09-10T16:00:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lucuo"
                          },
                          "bodyText": "If I want to couple SIMPLENonlinearAssembly and transient Executioner, which multiapp should I use. thanks for some advice",
                          "url": "https://github.com/idaholab/moose/discussions/28578#discussioncomment-10616678",
                          "updatedAt": "2024-09-11T16:30:17Z",
                          "publishedAt": "2024-09-11T16:30:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou can put either the CFD or the other solve inside a FullSolveMultiApp\nUnfortunately, SIMPLENonlinearAssembly  does not support transient execution (yet, we have a PR for transient support of multi-system).\nSo you cannot yet use two transient solves and a transientMultiApp to exchange information on every time step",
                          "url": "https://github.com/idaholab/moose/discussions/28578#discussioncomment-10619548",
                          "updatedAt": "2024-09-11T21:45:46Z",
                          "publishedAt": "2024-09-11T21:45:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Growing single precipitates/Refining Mesh",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "I have a KKS script that simulates the growth of precipitates in particular directions due to influence of aging under stress, mistfit strains which leads to variant selection.\nThis test is for the 3-phase KKS model\nAnd here is a snapshot of the simulation\n\nMy question is is there a way I can get it more refined to focus on about 1-2 precipitates like the snapshot below rather than the many in the matrix",
          "url": "https://github.com/idaholab/moose/discussions/28552",
          "updatedAt": "2024-09-11T19:42:51Z",
          "publishedAt": "2024-09-05T21:44:31Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Implementing ADKernel for chemical potential equations",
          "author": {
            "login": "ahzeeshan"
          },
          "bodyText": "I am trying to implement an ADKernel for satisfying equilibrium conditions (pointwise) for chemical potentials of two species: $\\mu_a$ and $\\mu_b$. The conditions are $\\mu_a + \\mu_b = 0$ and $\\mu_a = \\mu_{target}$ (constant). The concentrations of species are $c_a$ and $c_b$. The code has three variables: $\\phi, c_a, c_b$.\nNote that $\\mu_a$ and $\\mu_b$ are themselves defined in terms of $c_a, c_b$ and $\\phi$. Let $\\mu_a = f(c_a, c_b, \\phi)$, $\\mu_b = g(c_a, c_b, \\phi)$.\nImplementation\nMaterial properties\nI implemented the chemical potential functions $\\mu_a = f(c_a, c_b, \\phi)$ and $\\mu_b = g(c_a, c_b, \\phi)$ as material properties using the ADDerivativeParsedMaterial, see below\n  [./chempot_pos]\n     type = ADDerivativeParsedMaterial\n     property_name = 'mu_pos'\n     coupled_variables = 'phi cpos cneg'\n     material_property_names = 'mu0_pos kT zpos e'\n     expression = 'mu0_pos + kT * log(cpos / (1-cpos)) + zpos * e * phi'\n     derivative_order = 2\n     outputs = exodus\n  [../]\n\nKernels\nThe kernels are: a PDE for $\\phi$; $\\mu_a + \\mu_b = 0$ for $c_b$ and $\\mu_a = \\mu_0$ for $c_a$. I implemented ADKernels for the two conditions by taking as input the material properties $\\mu_a$, $\\mu_b$, $\\mu_0$\nparams.addRequiredParam<MaterialPropertyName>(\"mua\", \"The name of the first chemical potential\");\n...\n_mua(getADMaterialProperty<Real>(\"mua\")),\n\nand setting the residuals as:\nreturn  (_mu[_qp] - _mutarget[_qp]) * _test[_i][_qp];\nreturn  (_mua[_qp] + _mub[_qp]) * _test[_i][_qp];\nThe kernels in the input file look like this\n  [./chem_pot_eqbm]\n    type = ChemPotEqual\n    variable = cneg\n    mua = mu_pos\n    mub = mu_neg\n    args = 'phi cneg'\n  [../]\n\nProblem\nI am unable to achieve convergence. By running with -snes_test_jacobian, I found that my Jacobians are wrong. I am not entirely sure but maybe the problem stems from passing the $\\mu$'s directly to the ADKernel as material properties instead of hard coding the functions $f$ and $g$ inside the kernel that make the dependence on $c_a, c_b$ and $\\phi$ explicit?\nI'd appreciate any help.",
          "url": "https://github.com/idaholab/moose/discussions/28591",
          "updatedAt": "2024-09-11T17:17:06Z",
          "publishedAt": "2024-09-09T23:20:14Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe Jacobians should be correct when using AD without mistakes dropping the derivatives, so we should look for those.\nThis way of retrieving  material properties should be correct. Did you use this consistently?\n_mua(getADMaterialProperty<Real>(\"mua\")),\n\nThis expression will diverge near 0 and 1 log(cpos / (1-cpos)). Do you have a Bounds object maybe to make sure cpos does not approach the bounds?\n\nmaybe the problem stems from passing the \u03bc 's directly to the ADKernel as material properties instead of hard coding the functions f and g inside the kernel that make the dependence on ca,cb and \u03d5 explicit?\n\nno using AD properties should be fine for propagating the derivatives correctly from the residual to the Jacobian",
                  "url": "https://github.com/idaholab/moose/discussions/28591#discussioncomment-10603476",
                  "updatedAt": "2024-09-10T14:30:28Z",
                  "publishedAt": "2024-09-10T14:30:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ahzeeshan"
                  },
                  "bodyText": "Hi @GiudGiud\nYes, I used this consistently in the kernels. I also added a bounds object but I got the same problem. Could you please look into my app here: https://github.com/ahzeeshan/edl_solid/blob/main/test/tests/simple.i",
                  "url": "https://github.com/idaholab/moose/discussions/28591#discussioncomment-10607945",
                  "updatedAt": "2024-09-10T23:45:04Z",
                  "publishedAt": "2024-09-10T23:45:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "could you try something like log( max(1e-12, cpos / (1-cpos) ) ) to prevent getting arbitrarily close to 0 in the log? The bounds don't prevent that",
                          "url": "https://github.com/idaholab/moose/discussions/28591#discussioncomment-10609151",
                          "updatedAt": "2024-09-11T03:28:46Z",
                          "publishedAt": "2024-09-11T03:28:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ahzeeshan"
                  },
                  "bodyText": "I tried this but the Jacobian is still off.\n||J - Jfd||_F/||J||_F = 0.000486969, ||J - Jfd||_F = 55.5544",
                  "url": "https://github.com/idaholab/moose/discussions/28591#discussioncomment-10616235",
                  "updatedAt": "2024-09-11T15:53:41Z",
                  "publishedAt": "2024-09-11T15:53:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "bounding it will not help the Jacobian but it will prevent floating point errors.\nDoes it give you which coefficient is off? Using the Outputs/dofmap=true, we should look at which variable the Jacobian is not correct for",
                          "url": "https://github.com/idaholab/moose/discussions/28591#discussioncomment-10617208",
                          "updatedAt": "2024-09-11T17:17:08Z",
                          "publishedAt": "2024-09-11T17:17:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "New user having issues rebuilding libmesh",
          "author": {
            "login": "ParadoxPrism117"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nHi, first time poster and new user to MOOSE. I am trying to install MOOSE and attempted to perform the update/rebuild of libmesh when I encountered an error finding/linking to a \"z library\". The error provided a suggestion of disabling two applications, but it still didn't build correctly even after trying that. Is there something missing I need to install or disable?\n(Optional) code in question / simulation log / errors\nconfigure: error: Can't find or link to the z library. Turn off netCDF-4 and      DAP clients with --disable-netcdf-4 --disable-dap, or see config.log for errors.\nconfigure: error: ../../../../contrib/netcdf/netcdf-c-4.6.2/configure failed for contrib/netcdf/netcdf-c-4.6.2\nRunning make -j 1...\nmake: *** No targets specified and no makefile found.  Stop.\nEncountering Errors? Please include diagnostic output\n####################################################################################################\nInfluential Environment Variables\n\nCONDA_CHANNEL=https://conda.software.inl.gov/public\nCONDA_DEFAULT_ENV=base\nCONDA_EXE=/home/kzimins/miniforge/bin/conda\nCONDA_PREFIX=/home/kzimins/miniforge\nCONDA_PROMPT_MODIFIER=(base) \nCONDA_PYTHON_EXE=/home/kzimins/miniforge/bin/python\nCONDA_SHLVL=1\nCURL_CA_BUNDLE=\nMOOSE_JOBS=6\nPATH=/home/kzimins/miniforge/bin:/home/kzimins/miniforge/condabin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin\nREQUESTS_CA_BUNDLE=\nSSL_CERT_FILE=\n####################################################################################################\nCompiler(s) (CC CXX FC F77 F90):\n\nCC\tnot set\nCXX\tnot set\nFC\tnot set\nF77\tnot set\nF90\tnot set\n\nFAIL: One or more compiler environment variables not set, or set incorrectly\n####################################################################################################\nPython Sanity Checks\n\n/usr/bin/env python3 --version; (reporting as: Python 3.12.5) matches\nwhich python3 python;\n\n/home/kzimins/miniforge/bin/python3 --version; == Python 3.12.5\n/home/kzimins/miniforge/bin/python --version; == Python 3.12.5\n\nOK\n####################################################################################################\nPython Modules (TestHarness, run-ability)\n\n\nWARNING: missing module(s): pyaml jinja2 \n\nEither install the above packages, or perhaps you have yet\nto activate the moose environment: conda activate moose\n\nMissing 'warning' Python modules may cause miscellaneous runtime issues.\n\nWARNING: One or more Python issues present.\n####################################################################################################\nMOOSE Repository/Conda Version Checks\n\nWARNING: Unable to run Conda tests due to missing Python modules\n\n\nchecks FAILED",
          "url": "https://github.com/idaholab/moose/discussions/28589",
          "updatedAt": "2024-09-11T14:30:47Z",
          "publishedAt": "2024-09-09T21:24:56Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou need to install zlib.\nYou can get it from conda fairly easily conda install zlib",
                  "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10595842",
                  "updatedAt": "2024-09-09T21:41:47Z",
                  "publishedAt": "2024-09-09T21:41:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ParadoxPrism117"
                          },
                          "bodyText": "Does zlib need to be installed in the same folder?",
                          "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10596464",
                          "updatedAt": "2024-09-10T00:09:34Z",
                          "publishedAt": "2024-09-10T00:09:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ParadoxPrism117"
                          },
                          "bodyText": "I installed zlib but I am still having the same issue. Do I need to attempt a clean install of MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10596482",
                          "updatedAt": "2024-09-10T00:13:34Z",
                          "publishedAt": "2024-09-10T00:13:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Does zlib need to be installed in the same folder?\n\nno should be fine anywhere  as long as it s found in the LIBRARY_PATH\n\nDo I need to attempt a clean install of MOOSE?\n\nprobably not. let s see the config.log for libmesh",
                          "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10596513",
                          "updatedAt": "2024-09-10T00:20:54Z",
                          "publishedAt": "2024-09-10T00:20:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ParadoxPrism117"
                          },
                          "bodyText": "config.log",
                          "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10596555",
                          "updatedAt": "2024-09-10T00:28:42Z",
                          "publishedAt": "2024-09-10T00:28:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ParadoxPrism117"
                          },
                          "bodyText": "I attached the config.log as a file because it was too much text to paste into a reply",
                          "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10596643",
                          "updatedAt": "2024-09-10T00:51:51Z",
                          "publishedAt": "2024-09-10T00:51:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Looks like netcdf failed to configure/build. Can you navigate where it says its building it in the log:\n/home/kzimins/projects/moose/libmesh/build/contrib/netcdf/netcdf-c-4.6.2\n\nand report what the configure.log says there? It may be named config.log as well. Or some other \".log\" file.",
                          "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10602221",
                          "updatedAt": "2024-09-10T12:49:53Z",
                          "publishedAt": "2024-09-10T12:49:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ParadoxPrism117"
                          },
                          "bodyText": "sure, here is the netcdf config.log:\nconfig.log",
                          "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10602328",
                          "updatedAt": "2024-09-10T12:59:26Z",
                          "publishedAt": "2024-09-10T12:59:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ParadoxPrism117"
                          },
                          "bodyText": "It mentions on line 530 that it encounters a fatal error with a \"curl.h\" file/directory?",
                          "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10602389",
                          "updatedAt": "2024-09-10T13:04:36Z",
                          "publishedAt": "2024-09-10T13:04:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think the error is still the same, towards the end\nThis curl.h error you can solve by installing libcurl-devel",
                          "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10602648",
                          "updatedAt": "2024-09-10T13:23:57Z",
                          "publishedAt": "2024-09-10T13:23:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "This still seems to be a zlib error:\nconfigure:18515: error: Can't find or link to the z library. Turn off netCDF-4 and      DAP clients with --disable-netcdf-4 --disable-dap, or see config.log for errors.\n\nI think installing zlib using Conda only works if you also use Conda's compilers. What I mean by that, is that the following link line:\nconfigure:18486: mpicc -o conftest  -I/home/kzimins/projects/moose/scripts/../petsc/include \\\n-I/home/kzimins/projects/moose/scripts/../petsc/arch-moose/include \\\n-I/home/kzimins/projects/moose/petsc/arch-moose/include \\\n-I/home/kzimins/projects/moose/petsc/include \\\n-I/home/kzimins/projects/moose/petsc/arch-moose/include    conftest.c -lz  \\\n-Wl,-rpath,/home/kzimins/projects/moose/petsc/arch-moose/lib \\\n-L/home/kzimins/projects/moose/petsc/arch-moose/lib \\\n-Wl,-rpath,/usr/lib/gcc/x86_64-linux-gnu/11 \\\n-L/usr/lib/gcc/x86_64-linux-gnu/11 -lpetsc -lHYPRE -ldmumps -lmumps_common \\\n-lpord -lpthread -lstrumpack -lscalapack -lsuperlu_dist -lflapack -lfblas \\\n-lptesmumps -lptscotchparmetisv3 -lptscotch -lptscotcherr -lesmumps -lscotch \\\n-lscotcherr -lparmetis -lmetis -lhdf5_hl -lhdf5 -lm -lX11 -lmpichfort -lmpich \\\n-lgfortran -lm -lgfortran -lm -lgcc_s -lquadmath -lstdc++ -lrt -L/lib -lhdf5 \\\n-Wl,-rpath,/lib   >&5\n\nContains no paths to your Conda installation. The following:\n-L/usr/lib/gcc/x86_64-linux-gnu/11\n\nThis is the bit I see in the above link line that includes a path to your compiler. If this were Conda supplied compilers, it would report: -L/home/kzimins/miniforge/envs/moose/lib, and by extension, would include the path necessary to Conda installed z library.\nI am sure there is a reason you are not wanting to install the MOOSE Conda packages, so I won't press. So instead, try this:\nexport LDFLAGS=\"-L/home/kzimins/miniforge/lib $LDFLAGS\"\nexport METHODS=opt MOOSE_JOBS=6  # this will help speed up the process\n./update_and_rebuild_libmesh.sh\nHowever, because there will be plenty of other libraries in this location, I can't guarantee success. There may be additional issues. If so, it may be better if you apt install zlib-dev or build the z library manually, and add the above -L flag pointing to the sole one item you manually create.",
                          "url": "https://github.com/idaholab/moose/discussions/28589#discussioncomment-10602657",
                          "updatedAt": "2024-09-10T13:24:43Z",
                          "publishedAt": "2024-09-10T13:24:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to set the contact thermal resistance and radiation heat transfer on the surface of a continuous block?",
          "author": {
            "login": "LeonDong1998"
          },
          "bodyText": "Hello everyone!\nI want to know how continuous surface heat transfer can achieve a similar effect to GapHeatTransfer, the  emissivity of two contact surfaces can be set. And although there is no thermal conductivity of the gap material, the contact thermal resistance can be set.\nThank you in advance!",
          "url": "https://github.com/idaholab/moose/discussions/28592",
          "updatedAt": "2024-09-11T13:50:50Z",
          "publishedAt": "2024-09-10T12:56:07Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you dont have a gap in the mesh but instead have a continuous surface, then you can use an interface kernel.\nThis one should do it\nhttps://mooseframework.inl.gov/source/interfacekernels/SideSetHeatTransferKernel.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28592#discussioncomment-10602491",
                  "updatedAt": "2024-09-10T13:11:07Z",
                  "publishedAt": "2024-09-10T13:11:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "LeonDong1998"
                          },
                          "bodyText": "Thanks a lot!\nAnd I tried to build a simulation using SideSetHeatTransfer Kernel, but encountered the following error:\n\"Variable and neighbor variable are the same, but they are not elemental variables.\"\nAfterwards, I changed the family from LAGRANGE to MONOMIN, and the following error occurred, which may be related to my calculation coupling openmc:\n\"max_T: cannot couple elemental variables into nodal objects\"\nThank you in advance!",
                          "url": "https://github.com/idaholab/moose/discussions/28592#discussioncomment-10613440",
                          "updatedAt": "2024-09-11T11:34:23Z",
                          "publishedAt": "2024-09-11T11:34:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The first object is refusing to do an interface treatment for a continuous nodal variable. This makes sense you might have to actually create the gap using a BreakMesh...Generator then use a proper gap heat transfer treatment\nmax_T is a postprocessor. This is a different object giving you the error.\nYou probably have a NodalExtremeValue postprocessor which wont accept an elemental variable",
                          "url": "https://github.com/idaholab/moose/discussions/28592#discussioncomment-10614929",
                          "updatedAt": "2024-09-11T13:50:51Z",
                          "publishedAt": "2024-09-11T13:50:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "No active order parameters",
          "author": {
            "login": "ritamcj"
          },
          "bodyText": "Dear all,\nI am seeing the error \"No active order parameters\" in DeformedGrainMaterial in the phase field module. The relevant code snippet is below:\n  const auto & op_to_grains = _grain_tracker.getVarToFeatureVector(_current_elem->id());\n\n  // loop over active OPs\n  bool one_active = false;\n  for (MooseIndex(op_to_grains) op_index = 0; op_index < op_to_grains.size(); ++op_index)\n  {\n    if (op_to_grains[op_index] == FeatureFloodCount::invalid_id)\n      continue;\n\n    one_active = true;\n    auto grain_id = op_to_grains[op_index];\n\n    if (grain_id >= _deformed_grain_num)\n    {\n      rho_i = 0.0;\n    }\n    else\n    {\n       rho_i = _Disloc_Den_i[_qp];\n    }\n    rho0 += rho_i * (*_vals[op_index])[_qp] * (*_vals[op_index])[_qp];\n  }\n\n  if (!one_active && _t_step > 0)\n    mooseError(\"No active order parameters\");\n\nMy guess is that at a particular element, all grain order parameters become zero. I am unable to understand this. My simulation involves direct order parameter modification (through DiscreteNucleationForce) to simulate nucleation and growth. For new grains in reserved order parameters in GrainTracker, I have assigned a large nucleation force (nucleus_value = 50000). I wonder whether this causes the problem when too many nuclei are formed. I look forward to your suggestions.\nWarm Regards,\nRitam Chatterjee",
          "url": "https://github.com/idaholab/moose/discussions/21200",
          "updatedAt": "2024-09-11T09:44:38Z",
          "publishedAt": "2022-06-02T09:50:35Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen @SudiptaBiswas @jiangwen84 on phase field stuff please",
                  "url": "https://github.com/idaholab/moose/discussions/21200#discussioncomment-2909841",
                  "updatedAt": "2022-06-09T01:45:41Z",
                  "publishedAt": "2022-06-09T01:45:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "Do you have grain remapping on? Do your nuclei get remapped to a new order parameter after they are created? What kernel are you using for the reserved order parameter?\nIt's hard to say what is happening in you simulations with the limited information provided here. If you think the number of nuclei is the problem, then try reducing the nucleation rate such that only one or two nuclei occur in a timestep. It would be easy to debug the issue that way.",
                          "url": "https://github.com/idaholab/moose/discussions/21200#discussioncomment-2917628",
                          "updatedAt": "2022-06-09T22:10:28Z",
                          "publishedAt": "2022-06-09T22:10:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Sudipta,\nThank you for the reply. I have attached a pseudo input file, which should make it easier to understand my approach\nMoose_github_21200_input_file.txt.\nI had turned grain remapping off as I wanted my initial Ti-6Al-4V dual phase structure intact to evaluate the preferred location of nucleation at various interfaces such as alpha-alpha and alpha-beta. Can this cause new grains to not find any reserved order parameters? If that is the case, I will allow grain remapping and check again. A slower nucleation rate can work but I think it would eventually lead to the same issue due to unavailability of reserved order parameters for new grains.\nWarm regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/21200#discussioncomment-2919839",
                          "updatedAt": "2022-06-10T06:24:43Z",
                          "publishedAt": "2022-06-10T06:24:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "If the remapping is turned off then how does the nuclei evolve over time? Without remapping, probably only option you have is increasing the number of order parameters.",
                          "url": "https://github.com/idaholab/moose/discussions/21200#discussioncomment-2951449",
                          "updatedAt": "2022-06-14T23:50:09Z",
                          "publishedAt": "2022-06-14T23:50:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@ritamcj any update on this?",
                          "url": "https://github.com/idaholab/moose/discussions/21200#discussioncomment-3021463",
                          "updatedAt": "2022-06-25T05:46:32Z",
                          "publishedAt": "2022-06-25T05:46:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Sudipta and Guillaume,\nI apologize for the delay in responding as I was traveling. With grain remapping off, you correctly stated that the only option is to increase the number of order parameters. However, this significantly slows down the simulation. Hence, I switched on grain remapping, lowered the nucleation rate as well as the hold time of nuclei in the system. The simulation ran longer, but I am still trying to optimize to run up to large strain (~50%). I do accept your insights, and it can be marked as the solution. Many thanks for your explanations.\nWarm regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/21200#discussioncomment-3165535",
                          "updatedAt": "2022-07-17T13:42:52Z",
                          "publishedAt": "2022-07-17T13:42:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YXY101676"
                          },
                          "bodyText": "Hello, I want to know if the activation grains and the order parameters here are one-to-one correspondence, I may have misunderstood the code\u3002",
                          "url": "https://github.com/idaholab/moose/discussions/21200#discussioncomment-10612306",
                          "updatedAt": "2024-09-11T09:44:39Z",
                          "publishedAt": "2024-09-11T09:44:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Area/Volume fraction",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "Is there a kernel/auxkernel or postprocessor that can help me calculate the volume/area fraction of my precipitates during or after evolution of the precipitates?",
          "url": "https://github.com/idaholab/moose/discussions/28582",
          "updatedAt": "2024-09-17T20:22:17Z",
          "publishedAt": "2024-09-09T16:37:35Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "https://mooseframework.inl.gov/source/postprocessors/AverageGrainVolume.html",
                  "url": "https://github.com/idaholab/moose/discussions/28582#discussioncomment-10593635",
                  "updatedAt": "2024-09-09T16:44:28Z",
                  "publishedAt": "2024-09-09T16:44:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "and https://mooseframework.inl.gov/source/postprocessors/GrainBoundaryArea.html",
                          "url": "https://github.com/idaholab/moose/discussions/28582#discussioncomment-10593636",
                          "updatedAt": "2024-09-09T16:44:31Z",
                          "publishedAt": "2024-09-09T16:44:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "Is this in my postprocessor going to calculate the area of my eta(order parameter) as they evolve in the matrix?\n [./gr1area]\n    type = ElementIntegralVariablePostprocessor\n    variable = eta1\n    execute_on = 'initial timestep_end'\n  [../]\n  [./gr2area]\n    type = ElementIntegralVariablePostprocessor\n    variable = eta2\n    execute_on = 'initial timestep_end'\n  [../]\n  [./gr3area]\n    type = ElementIntegralVariablePostprocessor\n    variable = eta3\n    execute_on = 'initial timestep_end'\n  [../] \n\nAnd I assume this also gives the average volume of the precipitates as they grow?\n[./avg_grain_vol]\n    type = AverageGrainVolume\n    grain_num = 3\n    execute_on = 'initial timestep_end'\n  [../]",
                          "url": "https://github.com/idaholab/moose/discussions/28582#discussioncomment-10607742",
                          "updatedAt": "2024-09-10T22:53:36Z",
                          "publishedAt": "2024-09-10T22:53:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes I think both of these should be good",
                          "url": "https://github.com/idaholab/moose/discussions/28582#discussioncomment-10607754",
                          "updatedAt": "2024-09-10T22:55:35Z",
                          "publishedAt": "2024-09-10T22:55:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error using ADCZM",
          "author": {
            "login": "chunhuizhao478"
          },
          "bodyText": "In the computeInterfaceTraction() function, I try to approximate rate using current and old interface_displacement_jump as follows:\n//Approximate slip rate\n  RealVectorValue interface_displacement_jump_rate = (1.0/_dt) * (_interface_displacement_jump[_qp] - _interface_displacement_jump_old[_qp]) + Vini_vec;\n\nHowever, I got the following error:\n/Users/andyz/mambaforge3/envs/moose/libmesh/include/libmesh/type_vector.h:548:18: error: assigning to 'double' from incompatible type 'const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, unsigned long long, MetaPhysicL::NWrapper<53>>, true>'\n    _coords[i] = p._coords[i];\n                 ^~~~~~~~~~~~\n/Users/andyz/mambaforge3/envs/moose/libmesh/include/libmesh/vector_value.h:209:3: note: in instantiation of function template specialization 'libMesh::TypeVector<double>::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, unsigned long long, MetaPhysicL::NWrapper<53>>, true>>' requested here\n  TypeVector<T> (p)\n  ^\n/Users/andyz/projects/farms_rsf/src/materials/2d/implicit/AD/ADImplicitRateStateFrictionLaw2D.C:59:55: note: in instantiation of function template specialization 'libMesh::VectorValue<double>::VectorValue<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, unsigned long long, MetaPhysicL::NWrapper<53>>, true>>' requested here\n  RealVectorValue interface_displacement_jump_rate =  (_interface_displacement_jump[_qp] - _interface_displacement_jump_old[_qp]) + Vini_vec;\n                                                      ^\n1 error generated.\nmake: *** [/Users/andyz/projects/moose/framework/build.mk:149: /Users/andyz/projects/farms_rsf/build/unity_src/materials_2d_implicit_AD_Unity.arm64-apple-darwin20.0.0.opt.lo] Error 1\n\nAny idea on how to get rid of this? Thanks a lot",
          "url": "https://github.com/idaholab/moose/discussions/24901",
          "updatedAt": "2024-09-10T21:44:22Z",
          "publishedAt": "2023-07-05T04:03:03Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "_coords[i] = MetaPhysicL::raw_value(p._coords[i]);\n\nor\n_coords[i] = p._coords[i].value();\n\nthis is happening because you are copying an AD number into a regular floating point number, hence removing the derivatives.\nWe do want to warn devs about removing derivatives like this",
                  "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6358418",
                  "updatedAt": "2023-07-05T04:05:11Z",
                  "publishedAt": "2023-07-05T04:05:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks Giud! Sounds like this approximation is not allowed? How should I get the rate of this material property?",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6358438",
                          "updatedAt": "2023-07-05T04:12:37Z",
                          "publishedAt": "2023-07-05T04:09:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh my bad I looked at the first error",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6358454",
                          "updatedAt": "2023-07-05T04:15:28Z",
                          "publishedAt": "2023-07-05T04:15:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no this is allowed. You just need to create the non-AD vector before computing the operations on the vectors and setting the non-AD vector",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6358458",
                          "updatedAt": "2023-07-05T04:15:57Z",
                          "publishedAt": "2023-07-05T04:15:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you may be able to use raw_value on _interface_displacement_jump[_qp] directly actually",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6358459",
                          "updatedAt": "2023-07-05T04:16:24Z",
                          "publishedAt": "2023-07-05T04:16:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "sorry, could you write the format down? I'm not familiar with this AD, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6358473",
                          "updatedAt": "2023-07-05T04:19:36Z",
                          "publishedAt": "2023-07-05T04:19:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "does this work?\neither:\n  RealVectorValue interface_displacement_jump_rate = (1.0/_dt) * (MetaPhysicL::raw_value(_interface_displacement_jump[_qp]) - _interface_displacement_jump_old[_qp]) + Vini_vec;\n\nor using AD (probably preferrable actually)\n  ADRealVectorValue interface_displacement_jump_rate = (1.0/_dt) * (_interface_displacement_jump[_qp] - _interface_displacement_jump_old[_qp]) + Vini_vec;",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6358488",
                          "updatedAt": "2023-07-05T04:20:56Z",
                          "publishedAt": "2023-07-05T04:20:55Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks! The first one works.",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6358501",
                          "updatedAt": "2023-07-05T04:23:36Z",
                          "publishedAt": "2023-07-05T04:23:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok first one loses the derivatives so just make sure you dont use it to compute an ADReal residual!",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6358517",
                          "updatedAt": "2023-07-05T04:26:04Z",
                          "publishedAt": "2023-07-05T04:26:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Eventually the value will be put into _interface_traction(declareADPropertyByName<RealVectorValue>(_base_name + \"interface_traction\")), which is a RealVectorValue, I think it's ok?",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6358562",
                          "updatedAt": "2023-07-05T04:36:32Z",
                          "publishedAt": "2023-07-05T04:36:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Nope not ok.\nIt\u2019s an AD material property, the type is actually ADRealVectorValue",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6362874",
                          "updatedAt": "2023-07-05T13:21:49Z",
                          "publishedAt": "2023-07-05T13:21:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "chunhuizhao478"
                  },
                  "bodyText": "The error message is as follows (I have updated moose to latest version):\n(moose) andyz@Chunhuis-MBP-2 farms_rsf % make -j8\nCompiling C++ (in opt mode) /Users/andyz/projects/farms_rsf/build/unity_src/materials_2d_implicit_Unity.C...\nIn file included from /Users/andyz/projects/farms_rsf/build/unity_src/materials_2d_implicit_Unity.C:2:\n/Users/andyz/projects/farms_rsf/src/materials/2d/implicit/ADImplicitRateStateFrictionLaw2D.C:71:23: error: no matching function for call to 'asinh'\n  ADReal mu = rsf_a * asinh( sliprate_strike/(2*delta_o) * exp((f_o + rsf_b * log(delta_o * statevar/rsf_L))/rsf_a) );\n                      ^~~~~\n/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h:341:15: note: candidate function not viable: no known conversion from 'typename MultipliesType<DualNumber<double, SemiDynamicSparseNumberArray<double, unsigned long long, NWrapper<53>>, true>, double, false>::supertype' (aka 'DualNumber<double, SemiDynamicSparseNumberArray<double, unsigned long long, MetaPhysicL::NWrapper<53>>, true>') to 'double' for 1st argument\nextern double asinh(double);\n              ^\n/Users/andyz/mambaforge3/envs/moose/bin/../include/c++/v1/math.h:1093:46: note: candidate function not viable: no known conversion from 'typename MultipliesType<DualNumber<double, SemiDynamicSparseNumberArray<double, unsigned long long, NWrapper<53>>, true>, double, false>::supertype' (aka 'DualNumber<double, SemiDynamicSparseNumberArray<double, unsigned long long, MetaPhysicL::NWrapper<53>>, true>') to 'float' for 1st argument\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return ::asinhf(__lcpp_x);}\n                                             ^\n/Users/andyz/mambaforge3/envs/moose/bin/../include/c++/v1/math.h:1094:46: note: candidate function not viable: no known conversion from 'typename MultipliesType<DualNumber<double, SemiDynamicSparseNumberArray<double, unsigned long long, NWrapper<53>>, true>, double, false>::supertype' (aka 'DualNumber<double, SemiDynamicSparseNumberArray<double, unsigned long long, MetaPhysicL::NWrapper<53>>, true>') to 'long double' for 1st argument\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return ::asinhl(__lcpp_x);}\n                                             ^\n/Users/andyz/mambaforge3/envs/moose/bin/../include/c++/v1/math.h:1099:1: note: candidate template ignored: requirement 'std::is_integral<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, unsigned long long, MetaPhysicL::NWrapper<53>>, true>>::value' was not satisfied [with _A1 = MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, unsigned long long, MetaPhysicL::NWrapper<53>>, true>]\nasinh(_A1 __lcpp_x) _NOEXCEPT {return ::asinh((double)__lcpp_x);}\n^\n1 error generated.\nmake: *** [/Users/andyz/projects/moose/framework/build.mk:145: /Users/andyz/projects/farms_rsf/build/unity_src/materials_2d_implicit_Unity.arm64-apple-darwin20.0.0.opt.lo] Error 1\n(moose) andyz@Chunhuis-MBP-2 farms_rsf % \n\nthe header file:\n#pragma once\n\n#include \"ADCZMComputeLocalTractionTotalBase.h\"\n\nclass ADImplicitRateStateFrictionLaw2D : public ADCZMComputeLocalTractionTotalBase\n{\npublic:\n  static InputParameters validParams();\n  ADImplicitRateStateFrictionLaw2D(const InputParameters & parameters);\n\nprotected:\n  virtual void computeInterfaceTraction();\n\n  //rate-and-state friction coefficients\n  Real _f_o;\n  Real _rsf_a;\n  Real _rsf_b;\n  Real _rsf_L;\n  Real _delta_o;\n  Real _Vini;\n\n  //initial shear and normal traction\n  Real _Tn_o;\n  Real _Ts_o;\n\n  //old/older interface jump\n  const MaterialProperty<RealVectorValue> & _interface_displacement_jump_old;\n  const MaterialProperty<RealVectorValue> & _interface_displacement_jump_older;\n};\n\nthe source file:\n#include \"ADImplicitRateStateFrictionLaw2D.h\"\n\nregisterMooseObject(\"farms_rsfApp\", ADImplicitRateStateFrictionLaw2D);\n\nInputParameters\nADImplicitRateStateFrictionLaw2D::validParams()\n{\n  InputParameters params = ADImplicitRateStateFrictionLaw2D::validParams();\n  return params;\n}\n\nADImplicitRateStateFrictionLaw2D::ADImplicitRateStateFrictionLaw2D(const InputParameters & parameters)\n  : ADCZMComputeLocalTractionTotalBase(parameters),\n  _f_o(getParam<Real>(\"f_o\")),\n  _rsf_a(getParam<Real>(\"rsf_a\")),\n  _rsf_b(getParam<Real>(\"rsf_b\")),\n  _rsf_L(getParam<Real>(\"rsf_L\")),\n  _delta_o(getParam<Real>(\"delta_o\")),\n  _Vini(getParam<Real>(\"Vini\")),\n  _Tn_o(getParam<Real>(\"Tn_o\")),\n  _Ts_o(getParam<Real>(\"Ts_o\")),\n  _interface_displacement_jump_old(getMaterialPropertyOldByName<RealVectorValue>(_base_name + \"interface_displacement_jump\")),\n  _interface_displacement_jump_older(getMaterialPropertyOlderByName<RealVectorValue>(_base_name + \"interface_displacement_jump\"))\n{\n}\n\n//Define Frictional Law (function of sliprate and statevar)\ndouble mu_friction_law_implicit2DAD(Real sliprate, Real statevar, Real rsf_a, Real rsf_b, Real rsf_L, Real delta_o, Real f_o)\n{\n  double mu = 0;\n  mu = rsf_a * asinh( sliprate/(2*delta_o) * exp((f_o + rsf_b * log(delta_o * statevar/rsf_L))/rsf_a) );\n  return mu;\n}\n\nvoid\nADImplicitRateStateFrictionLaw2D::computeInterfaceTraction()\n{\n  //Define Parameters\n  Real f_o = _f_o;\n  Real rsf_a = _rsf_a;\n  Real rsf_b = _rsf_b;\n  Real rsf_L = _rsf_L;\n  Real delta_o = _delta_o;\n  Real Vini = _Vini;\n  Real Tn_o = _Tn_o;\n  Real Ts_o = _Ts_o;\n\n  //Get initial slip rate value\n  RealVectorValue Vini_vec(0.0,Vini,0.0);\n\n  //Get normal traction\n  //if (_interface_displacement_jump[_qp](0) < 0){}else{}\n  Real Tn = abs(Tn_o);\n\n  //Get old state variable\n  Real statevar_old = 0;\n\n  //Approximate slip rate\n  ADRealVectorValue interface_displacement_jump_rate = (1.0/_dt) * (_interface_displacement_jump[_qp] - _interface_displacement_jump_old[_qp]) + Vini_vec;\n  RealVectorValue interface_displacement_jump_rate_old = (1.0/_dt) * (_interface_displacement_jump_old[_qp] - _interface_displacement_jump_older[_qp]) + Vini_vec;\n\n  //Get strike direction at t\n  ADReal sliprate_strike = interface_displacement_jump_rate(1);\n  Real sliprate_strike_old = interface_displacement_jump_rate_old(1);\n\n  //Define state variable at t+dt\n  Real statevar = (rsf_L / sliprate_strike_old) + (statevar_old - rsf_L / sliprate_strike_old) * exp( -1 * sliprate_strike_old * _dt / rsf_L );\n  \n  //Define friction mu at t+dt\n  //!arcsinh(z)= ln(z+sqrt(z^2+1))\n  ADReal mu = rsf_a * asinh( sliprate_strike/(2*delta_o) * exp((f_o + rsf_b * log(delta_o * statevar/rsf_L))/rsf_a) );\n  \n  //Compute shear traction at t+dt\n  ADReal Ts = Tn * mu;\n\n  //Save results\n  _statevar[_qp] = statevar;\n  _sliprate[_qp] = sliprate_strike;\n\n  //Feed traction into the system\n  //Assign back traction in CZM\n  ADRealVectorValue traction;\n\n  traction(0) = 0.0; \n  traction(1) = -Ts+Ts_o; //\"-\"\n  traction(2) = 0.0;\n\n  _interface_traction[_qp] = traction;\n}",
                  "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6366858",
                  "updatedAt": "2023-07-05T19:59:05Z",
                  "publishedAt": "2023-07-05T19:59:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "I have hardcode in the source file to declare additional material property (although I don't think this is the issue):\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#pragma once\n\n#include \"InterfaceMaterial.h\"\n\n/**\n * AD equivalent of CZMComputeLocalTractionBase\n */\nclass ADCZMComputeLocalTractionBase : public InterfaceMaterial\n{\npublic:\n  static InputParameters validParams();\n  ADCZMComputeLocalTractionBase(const InputParameters & parameters);\n\nprotected:\n  void initQpStatefulProperties() override;\n  void computeQpProperties() override;\n\n  /// Compute the local traction\n  virtual void computeInterfaceTraction() = 0;\n\n  /// Base name of the material system\n  const std::string _base_name;\n\n  /// the value of the traction in local coordinates\n  ADMaterialProperty<RealVectorValue> & _interface_traction;\n\n  /// The displacment jump in local coordaintes\n  const ADMaterialProperty<RealVectorValue> & _interface_displacement_jump;\n\n  //Additional Material Properties\n  MaterialProperty<Real> & _statevar; //state variable\n  ADMaterialProperty<Real> & _sliprate; //slip rate\n\n  Real _statevarini; //initial state variable\n  Real _Vini;        //initial sliprate\n};\n\nthe source file\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"ADCZMComputeLocalTractionBase.h\"\n#include \"CZMComputeLocalTractionBase.h\"\n\nInputParameters\nADCZMComputeLocalTractionBase::validParams()\n{\n  InputParameters params = CZMComputeLocalTractionBase::validParams();\n  params.addParam<Real>(\"statevarini\",1e9,\"initial state variable\");\n  params.addParam<Real>(\"Vini\",1e-12,\"initial slip rate\");\n  return params;\n}\n\nADCZMComputeLocalTractionBase::ADCZMComputeLocalTractionBase(const InputParameters & parameters)\n  : InterfaceMaterial(parameters),\n    _base_name(isParamValid(\"base_name\") && !getParam<std::string>(\"base_name\").empty()\n                   ? getParam<std::string>(\"base_name\") + \"_\"\n                   : \"\"),\n    _interface_traction(\n        declareADPropertyByName<RealVectorValue>(_base_name + \"interface_traction\")),\n    _interface_displacement_jump(\n        getADMaterialPropertyByName<RealVectorValue>(_base_name + \"interface_displacement_jump\")),\n    _statevar(declarePropertyByName<Real>(\"statevar\")),\n    _sliprate(declareADPropertyByName<Real>(\"sliprate\")),\n    _statevarini(getParam<Real>(\"statevarini\")),\n    _Vini(getParam<Real>(\"Vini\"))\n{\n}\n\nvoid\nADCZMComputeLocalTractionBase::initQpStatefulProperties()\n{\n  _interface_traction[_qp] = 0;\n\n  _statevar[_qp] = _statevarini;\n  _sliprate[_qp] = _Vini;\n}\n\nvoid\nADCZMComputeLocalTractionBase::computeQpProperties()\n{\n  computeInterfaceTraction();\n}",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6366882",
                          "updatedAt": "2023-07-05T20:02:19Z",
                          "publishedAt": "2023-07-05T20:02:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Can you try using std::asinh and similarly for all your special math functions?",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6367536",
                          "updatedAt": "2023-07-05T21:10:26Z",
                          "publishedAt": "2023-07-05T21:10:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "I'm a little perturbed that the error message suggests it's not even considering the definition from dualnumber.h.  Is there any possibility that the headers here ended up including dualnumber_forward.h but not dualnumber.h (or at least dualnumber_decl.h)?",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-6367741",
                          "updatedAt": "2023-07-05T21:43:18Z",
                          "publishedAt": "2023-07-05T21:43:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ahzeeshan"
                          },
                          "bodyText": "I got the same error when using the log function from <cmath> but std::log works without errors in an ADKernel.",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-10598341",
                          "updatedAt": "2024-09-10T05:57:56Z",
                          "publishedAt": "2024-09-10T05:57:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@roystgnr do you think if we put our dual number math function overloads in the MetaPhysicL namespace instead of std that argument dependent lookup would work for us here? Unfortunately doing that migration would break a lot of existing code which uses std::",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-10605618",
                          "updatedAt": "2024-09-10T17:31:21Z",
                          "publishedAt": "2024-09-10T17:31:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "It wouldn't be crazy to put them in both places.  Backwards compatibility and (I hope; I'm not sure) ADL too.",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-10607433",
                          "updatedAt": "2024-09-10T21:42:20Z",
                          "publishedAt": "2024-09-10T21:42:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Though I think using namespace std or explicit std::asinh etc. has to be the right thing to do here.  Overloads for use with custom classes is supposed to be the use case where it's expected to put user code in namespace std.",
                          "url": "https://github.com/idaholab/moose/discussions/24901#discussioncomment-10607440",
                          "updatedAt": "2024-09-10T21:44:23Z",
                          "publishedAt": "2024-09-10T21:44:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Erroneous result while applying cohesive zone at inclined interface",
          "author": {
            "login": "AmanKumar0301"
          },
          "bodyText": "Hi @arovinelli @jiangwen84 I was trying to regenerate a patch test for cohesive zone model (see the attached figure, patch test-b). My geometry is a square of 1mm x 1mm dimension. I used BreakMeshByBlockGenerator to break the geometry along its diagonal (diagonal connecting the points (0,1) and (1,0)). Two triangular blocks are created as a result. I inserted PureElasticTractionSeparation CZM at this interface. Then applied displacement boundary condition at the top edge and right edge in order to create a pure mode-II loading.\nHowever the generated results are erroneous. Neither the expected traction nor expected displacement are generated.\nCorrect results are being generated for CZM interface aligned along the Cartesian axes for patch test-a. However, for test-b, I suspect that erroneous result being generated has something to do with inclined interface. I applied the same loading/BCs without insertion of cohesive zone and yet the results are exactly same and erroneous. I cannot understand why is it happening. Please help.",
          "url": "https://github.com/idaholab/moose/discussions/28581",
          "updatedAt": "2024-09-12T03:57:34Z",
          "publishedAt": "2024-09-09T16:35:04Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "arovinelli"
                  },
                  "bodyText": "@AmanKumar0301\nThat would be a major mistake that neither me or wen caught when developing or validating the model.\nSo I would say it's unlikely, but possible.\nThere are two set of traction vector, local traction (defined in the interface coordinate system) and global traction (defined in the sample coordinate system). Are you sure you are looking at the right set?\nAlso without you showing us the results of the simulation it's impossible to say if something is wrong",
                  "url": "https://github.com/idaholab/moose/discussions/28581#discussioncomment-10594024",
                  "updatedAt": "2024-09-09T17:23:10Z",
                  "publishedAt": "2024-09-09T17:23:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AmanKumar0301"
                          },
                          "bodyText": "Here is the MOOSE script that I am running:\n\n\n\nI have applied traction BC at the right edge and top edge in +ve x-axis and +ve y-axis direction. So effectively it should simulate mode-1 opening normal to the interface. Also, with the given values of traction and penalty stiffness a normal jump of 1mm is expected. However see the following results:\n\n\n\n\nNon of the above results is correct.\nIt is noteworthy that for other cases where I simulated the interface along Cartesian axes direction, the results are correct. For example, for patch test-a (see the image in 1st question), I am getting the correct result.",
                          "url": "https://github.com/idaholab/moose/discussions/28581#discussioncomment-10597457",
                          "updatedAt": "2024-09-10T03:20:49Z",
                          "publishedAt": "2024-09-10T03:20:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "Important on the bottom, consideration on the top\nsomething is weird. The result of the simulation you are running are not converged. You can't have different stresses on the two elements (you are using a stress prescribed BC), equilibrium is not satisfied.\nCheck your residual, I would be really surprised if that is 0~ish. The solution seems to be garbage.\nAlso did you check results without CZM (you said you did but I'm just curios at this point).\nCan you add the tangential traction, which according to your configuration should be identically 0.\nCan you ran it using Neumann BC, i.e. traction if your element size is 1. Pressure is kind of a complicated one.\nThe CZM results are only reported on the element belonging to the master surface, so I'm not surprised to see zeros on the right side.\nIt would interesing to see the residuals on both surfaces (tensor mechanics, see master action add\nextra_vector_tags = 'F_x F_y'\n\nIMPORTANT CONSIDERATIONS\n\nI'm wondering, and now maybe remembering, that the preset nodal fields might not include the proper nodes.\nyou might want to add something like in here  czm_multiple_action_and_materials.i see [add_side_sets] in mesh generation block to make sure you are indeed applying the right BC to the proper nodes or to generate your mesh in cubit and appropriately define side-sets.\nI really suspect this is the problem.\nWhen you break the mesh using BreakMeshByBlockGenerator, new nodes are added, and old side-set (left,right,top and bottom) might become incomplete, and not include the nodes that you are thinking. you can visualize them in paraview.",
                          "url": "https://github.com/idaholab/moose/discussions/28581#discussioncomment-10597762",
                          "updatedAt": "2024-09-10T04:18:46Z",
                          "publishedAt": "2024-09-10T04:07:32Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AmanKumar0301"
                          },
                          "bodyText": "Thanks a lot for your reply and thanks for your interest.\nIn the previous case, the results were converged. But they were garbage (incorrect) as you mentioned, and that is why I posted. I did check the side_sets in paraview for visualization before applying Bcs. And the side_sets top, bottom, left and right were all correctly visible.\nNow, I followed your advice and generated side_sets based on type SideSetsFromNormalsGenerator. And the script is indeed working now and correct results are generating. I am so so thankful to you for bringing this aspect into my notice. I was struggling for more than a week now. But you saved me.\nI have been meshing in GMSH. I want to ask you whether this traigular type element (with controlled dimension) can be generated in MOOSE itself in order to avoid future difficulties.\nAlso, I went through MOOSE database of CZM. There are three cohesive laws which have been implemented:\n\nPureElasticTractionSeparation\nBiLinearMixedModeTraction\nSalehaniIrani3DCTraction\n\nAre you considering implementing other traction separation laws e.g. exponential law?\nSuppose I want to implement my own traction separation laws, how can I do so? I am working on exploring cohesive zone simulation through MOOSE. Till now I have been relying on already developed modules and solely using the MOOSE scripting to generate results. I don\u2019t have background in C++. So please suggest.\nI also request you to develop Cohesive Zone module in MOOSE to bring it at par with other commercially available softwares. If there are any shortcomings or something additional needs to be done, please do consider.",
                          "url": "https://github.com/idaholab/moose/discussions/28581#discussioncomment-10599054",
                          "updatedAt": "2024-09-10T07:33:23Z",
                          "publishedAt": "2024-09-10T07:30:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "I'm glad it worked. We should probably add a warning in the cohesive model description about regenerating side sets.\nTo answer your questions:\n\nMoose is pretty flexible in terms of mesh generation, most case are handled.\nIf you need something you cannot achieve with a mesh generator use cubit from SNL.\nI can't develop other cohesive zone models simply because my job now does not entail that, and I don't have funding for doing it. The last time I worked on CZM was 3 years ago,  since then I moved to LANL and now I'm working with other solvers.\nif you need to develop your own model i suggest you looking at the CZM documentation which should explain fairly well how it's done. Find your eqautions and try. you don't need to be an expert in C++ .\nThe exponential model should be the SalehaniIrani3d except that is not stateful, i.e. it does not have a linear unload after an exponential load, so it does not keep track of damage directly\n\nHope this helps\nCheers",
                          "url": "https://github.com/idaholab/moose/discussions/28581#discussioncomment-10603188",
                          "updatedAt": "2024-09-10T14:07:19Z",
                          "publishedAt": "2024-09-10T14:07:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}