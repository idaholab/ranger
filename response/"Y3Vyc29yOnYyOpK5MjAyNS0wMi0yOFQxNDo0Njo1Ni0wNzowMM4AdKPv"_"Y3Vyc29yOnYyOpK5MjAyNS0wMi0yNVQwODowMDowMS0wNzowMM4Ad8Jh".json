{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNS0wMi0yNVQwODowMDowMS0wNzowMM4Ad8Jh"
    },
    "edges": [
      {
        "node": {
          "title": "Mesh refinement and MeshModifiers",
          "author": {
            "login": "PEI0214"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello\uff0c\nI ran into problems when I used mesh refinement and mesh modification, and when I used parallel computing.\n(1) When parallel is used, the computation will not proceed, as follows.\n(2) When parallelism is not used, the calculation can be carried out normally, and the results obtained are very different from those without refinement.\nI will illustrate with a simple example, the input file is as follows:\ninput.zip\n\noutput\nThe grid has six and eight node cells, and parallelism is also normal when only eight node cells are refined. However, parallel computation cannot be carried out when only six nodes are refined.",
          "url": "https://github.com/idaholab/moose/discussions/29937",
          "updatedAt": "2025-02-28T14:55:40Z",
          "publishedAt": "2025-02-22T13:49:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "PEI0214"
                  },
                  "bodyText": "@GiudGiud\nhello, Can you help me figure out what is causing this\uff1f",
                  "url": "https://github.com/idaholab/moose/discussions/29937#discussioncomment-12314395",
                  "updatedAt": "2025-02-25T15:03:02Z",
                  "publishedAt": "2025-02-25T15:03:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I made a note of it but I dont have time until after the MOOSE conference to debug this.\nCan you refine your mesh outside of MOOSE for now?\nor maybe refining in the mesh block should work\notherwise you can try debugging this yourself\nhttps://mooseframework.inl.gov/application_development/debugging.html",
                          "url": "https://github.com/idaholab/moose/discussions/29937#discussioncomment-12319481",
                          "updatedAt": "2025-02-26T00:55:40Z",
                          "publishedAt": "2025-02-26T00:55:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "Even in serial, if I run with a METHOD=dbg build I get an assertion failure at the start of time step 3:\nAssertion `my_dof_g == their_dof_g' failed.\nmy_dof_g = 2807193521\ntheir_dof_g = 2807189585\n\nFrom the lagrange_compute_constraints code in libMesh.  Getting in there in the debugger, it looks like we're getting corrupted data because we've indexed into empty dof_indices vectors ... and gah, that's got to be because of a bug in one of the Prism::side_ptr overloads.  One overload properly sets the side element's subdomain_id() to match its volume element, and the other just plain does not, and you hit a Prism6 code path that uses the one that does not, and so when we look for dof_indices on that side element we see that it doesn't have the right subdomain for the variable we're calculating with and we conclude that it must not have any indices, right before we return to the code written with the assumption that of course it should have indices.\nEven refining outside of MOOSE won't help here, because it's not the refinement failing, it's the calculation of hanging node constraints on the refined mesh.  While you wait for the fix, I'm afraid the only possible workaround I can see is that you could convert your mesh to simplices in the initial generation - Tet::side_ptr has the same bug, but e.g. Tet4 has its own side_ptr implementation that doesn't fall back on the buggy version the way Prism6 falls back on Prism.\nI can't believe we never caught this sooner; thank you for reporting it!  I'll put up a PR with the fix ASAP, and before I do so I'll check through our other element types to see if I can find everything else with the same bug, but long-term I really need to either add some subdomain-restricted variables to our current adaptive refinement unit tests or add an additional swath of unit tests using them.",
                  "url": "https://github.com/idaholab/moose/discussions/29937#discussioncomment-12341941",
                  "updatedAt": "2025-02-27T17:07:09Z",
                  "publishedAt": "2025-02-27T17:07:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "libMesh/libmesh#4092 fixes your input case for me.  Thanks very much for making it so easy to reproduce!",
                          "url": "https://github.com/idaholab/moose/discussions/29937#discussioncomment-12352671",
                          "updatedAt": "2025-02-28T14:55:41Z",
                          "publishedAt": "2025-02-28T14:55:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Creating a Loop Using Meshing Tools",
          "author": {
            "login": "CadenWil"
          },
          "bodyText": "Hi,\nI am attempting to create a loop using the meshing tools in Moose.\nHere is the file as well as an image of what I've done so far. I was unable to find a way to attach the two ends together to form a loop.\nMy questions are:\nIs there a way to attach these two ends together?\nIs there a better way to build the mesh that I'm trying to build?\nIs there a 3rd party mesh builder that I should use instead?\nCreateLoop.txt\n\nThanks for your help in this.",
          "url": "https://github.com/idaholab/moose/discussions/29983",
          "updatedAt": "2025-02-27T16:45:13Z",
          "publishedAt": "2025-02-27T16:06:08Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nIs there a way to attach these two ends together?\n\nyou mesh it all the way with overlapping edges/nodes then use this mesh generator to stitch\nhttps://mooseframework.inl.gov/source/meshgenerators/StitchedMeshGenerator.html\n\nIs there a better way to build the mesh that I'm trying to build?\n\nan alternative is to use this mesh generator\nhttps://mooseframework.inl.gov/source/meshgenerators/GeneratedMeshGenerator.html\ndraw the loop with the subdomains,\nthen use this mesh generator to delete the center:\nhttps://mooseframework.inl.gov/source/meshgenerators/BlockDeletionGenerator.html\n\nIs there a 3rd party mesh builder that I should use instead?\n\nany 3rd party tool will be able to do this. as you want",
                  "url": "https://github.com/idaholab/moose/discussions/29983#discussioncomment-12341179",
                  "updatedAt": "2025-02-27T16:09:52Z",
                  "publishedAt": "2025-02-27T16:09:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "CadenWil"
                          },
                          "bodyText": "Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/29983#discussioncomment-12341676",
                          "updatedAt": "2025-02-27T16:45:13Z",
                          "publishedAt": "2025-02-27T16:45:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Miscible CO\u2082 Injection Convergence Problem and Capillary Pressure Issues",
          "author": {
            "login": "QUIUQ"
          },
          "bodyText": "Problem Description:\nI encountered convergence issues while simulating CO\u2082 injection using the MOOSE framework. The problem setup is as follows:\nSimulation Conditions:\nAxisymmetric cylindrical space injection with isothermal conditions and two-phase miscible gas (CO\u2082) injection.\n\nWhen using a constant capillary pressure (pc = 0), the injection simulation runs successfully for 1 year.\nHowever, when I use the capillary pressure model [pc], with the PorousFlowCapillaryPressureVG type, and the following parameters:\n[pc]  \n    type = PorousFlowCapillaryPressureVG  \n    alpha = 0.5  \n    m = 0.45  \n    sat_lr = 0.2  \n[]  \n\nI found that during the simulation, the pressure falls below the range of the tabulated data. The formation pressure is around 3e7, but the simulated pressure goes out of range.\n\nAdditionally, when using the following parameters:\n[pc]  \n    type = PorousFlowCapillaryPressureVG  \n    alpha = 1e-5  \n    m = 0.5  \n    sat_lr = 0.2  \n[]  \n\nThe program quickly fails during the advection process from the first row of the grid on the left to the right side. I'm not sure why this happens. Even with alpha = 1e-5, which should be a reasonable value in practice, the simulation still fails.\nI suspect the issue is with the capillary pressure settings or that the settings for the miscible CO\u2082 model are incorrect.\nMoreover, I noticed that during injection, the overpressure of water does not increase significantly, while in TOUGH, the overpressure increases much more compared to the MOOSE simulation.\nAnd here is the link to my code. https://github.com/QUIUQ/CO2-injection-MOOSE\n[Mesh]\n    type = GeneratedMesh\n    dim = 2\n    ny = 25\n    nx = 50\n    ymax = 100\n    xmin = 0.1\n    xmax = 1200\n    bias_x = 1.05\n    coord_type = RZ\n    rz_coord_axis = Y\n[]\n\n[GlobalParams]\n    PorousFlowDictator = dictator\n    gravity = '0 -9.81 0'\n    temperature_unit = Celsius\n[]\n\n[Variables]\n    [pgas]\n        #scaling = 1e-7\n    []\n    [zi]\n        initial_condition = 0\n    []\n[]\n\n[ICs]\n    [pp_initial]\n        type = FunctionIC\n        variable = pgas\n        function = pp_ic\n    []\n[]\n\n[Functions]\n    [pp_ic]\n        type = SolutionFunction\n        solution = soln\n    []\n    [injection_rate]\n        type = ParsedFunction\n        symbol_values = injection_area\n        symbol_names = area\n        expression = '-5/area'\n    []\n[]\n\n\n[UserObjects]\n    [soln]\n        type = SolutionUserObject\n        mesh = initial_condition.e\n        system_variables = porepressure\n    []\n    [dictator]\n        type = PorousFlowDictator\n        porous_flow_vars = 'pgas zi'\n        number_fluid_phases = 2\n        number_fluid_components = 2\n    []\n    [pc]\n        type = PorousFlowCapillaryPressureVG\n        alpha = 1e-5\n        m = 0.5\n        sat_lr = 0.3\n    []\n    [pc0]\n        type = PorousFlowCapillaryPressureConst\n        pc = 0\n    []\n    [fs]\n        type = PorousFlowBrineCO2\n        brine_fp = brine\n        co2_fp = co2\n        capillary_pressure = pc\n    []\n[]\n\n[AuxVariables]\n    [temperature]\n        initial_condition = 50\n    []\n    [xnacl]\n        initial_condition = 0.1\n    []\n    [pressure_gas]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [pressure_water]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [saturation_gas]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [saturation_water]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [density_water]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [density_gas]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [x0_water]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [x0_gas]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [x1_water]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [x1_gas]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [cap_pre]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n[]\n\n[Kernels]\n    [mass0]\n        type = PorousFlowMassTimeDerivative\n        variable = pgas\n        fluid_component = 0\n    []\n    [flux0]\n        type = PorousFlowAdvectiveFlux\n        variable = pgas\n        fluid_component = 0\n    []\n    [mass1]\n        type = PorousFlowMassTimeDerivative\n        variable = zi\n        fluid_component = 1\n    []\n    [flux1]\n        type = PorousFlowAdvectiveFlux\n        variable = zi\n        fluid_component = 1\n    []\n[]\n\n[AuxKernels]\n    [pressure_water]\n        type = PorousFlowPropertyAux\n        variable = pressure_water\n        property = pressure\n        phase = 0\n        execute_on = timestep_end\n    []\n    [pressure_gas]\n        type = PorousFlowPropertyAux\n        variable = pressure_gas\n        property = pressure\n        phase = 1\n        execute_on = timestep_end\n    []\n    [saturation_water]\n        type = PorousFlowPropertyAux\n        variable = saturation_water\n        property = saturation\n        phase = 0\n        execute_on = timestep_end\n    []\n    [saturation_gas]\n        type = PorousFlowPropertyAux\n        variable = saturation_gas\n        property = saturation\n        phase = 1\n        execute_on = timestep_end\n    []\n    [density_water]\n        type = PorousFlowPropertyAux\n        variable = density_water\n        property = density\n        phase = 0\n        execute_on = timestep_end\n    []\n    [density_gas]\n        type = PorousFlowPropertyAux\n        variable = density_gas\n        property = density\n        phase = 1\n        execute_on = timestep_end\n    []\n    [x1_water]\n        type = PorousFlowPropertyAux\n        variable = x1_water\n        property = mass_fraction\n        phase = 0\n        fluid_component = 1\n        execute_on = timestep_end\n    []\n    [x1_gas]\n        type = PorousFlowPropertyAux\n        variable = x1_gas\n        property = mass_fraction\n        phase = 1\n        fluid_component = 1\n        execute_on = timestep_end\n    []\n    [x0_water]\n        type = PorousFlowPropertyAux\n        variable = x0_water\n        property = mass_fraction\n        phase = 0\n        fluid_component = 0\n        execute_on = timestep_end\n    []\n    [x0_gas]\n        type = PorousFlowPropertyAux\n        variable = x0_gas\n        property = mass_fraction\n        phase = 1\n        fluid_component = 0\n        execute_on = timestep_end\n    []\n    [capillary_pressure]\n        type = PorousFlowPropertyAux\n        variable = cap_pre\n        property = capillary_pressure\n        execute_on = timestep_end\n    []\n[]\n\n[BCs]\n    [methane_injection]\n        type = PorousFlowSink\n        boundary = left\n        variable = zi\n        flux_function = injection_rate\n        fluid_phase = 1\n    []\n    [outer_pressure_fixed]\n        type = FunctionDirichletBC\n        variable = pgas\n        boundary = right\n        function = pp_ic\n    []\n[]\n\n[FluidProperties]\n    [water]\n        type = Water97FluidProperties\n    []\n    [watertab]\n        type = TabulatedBicubicFluidProperties\n        fp = water\n    []\n    [brine]\n        type = BrineFluidProperties\n        water_fp = watertab\n    []\n    [co2sw]\n        type = CO2FluidProperties\n    []\n    [co2]\n        type = TabulatedBicubicFluidProperties\n        fp = co2sw\n    []\n\n[]\n\n[Materials]\n    [temperature]\n        type = PorousFlowTemperature\n        temperature = temperature\n    []\n    [brineco2]\n        type = PorousFlowFluidState\n        gas_porepressure = pgas\n        z = zi\n        temperature = temperature\n        xnacl = xnacl\n        capillary_pressure = pc\n        fluid_state = fs\n    []\n    [porosity]\n        type = PorousFlowPorosityConst\n        porosity = 0.1\n    []\n    [permeability]\n        type = PorousFlowPermeabilityConst\n        permeability = '1.5833e-13 0 0  0 1.5833e-13 0  0 0 1.5833e-13' #160.43 mD\n    []\n    [relperm_water]\n        type = PorousFlowRelativePermeabilityVG\n        m = 0.45946\n        phase = 0\n        s_res = 0.300\n        sum_s_res = 0.3\n      []\n      [relperm_gas]\n        type = PorousFlowRelativePermeabilityBC\n        phase = 1\n        s_res = 0.0\n        sum_s_res = 0.3\n        lambda = 2\n        nw_phase = true\n      []\n[]\n\n[Preconditioning]\n    [andy]\n      type = SMP\n      full = true\n      petsc_options_iname = '-pc_type -pc_factor_mat_solver_package '\n      petsc_options_value = 'lu mumps '\n    []\n  []\n\n  [Executioner]\n    type = Transient\n    solve_type = NEWTON\n    end_time = 31536000\n    nl_abs_tol = 1e-7\n    nl_rel_tol = 1e-5\n    dtmax = 1e5\n    nl_max_its = 15\n    automatic_scaling = true\n    #compute_scaling_once = true\n    [TimeStepper]\n      type = IterationAdaptiveDT\n      dt = 1e1\n      growth_factor = 1.25\n    []\n  []\n\n  [Postprocessors]\n    [mass_ph0]\n      type = PorousFlowFluidMass\n      fluid_component = 0\n      execute_on = 'initial timestep_end'\n    []\n    [mass_ph1]\n      type = PorousFlowFluidMass\n      fluid_component = 1\n      execute_on = 'initial timestep_end'\n    []\n    [injection_area]\n      type = AreaPostprocessor\n      boundary = left\n      execute_on = initial\n    []\n  []\n\n  [Outputs]\n    execute_on = 'initial timestep_end'\n    exodus = true\n    perf_graph = true\n    [csv]\n        type = CSV\n        sync_times = '2.592e6 8.64e6 31536000'\n        sync_only = true\n    []\n  []",
          "url": "https://github.com/idaholab/moose/discussions/29947",
          "updatedAt": "2025-02-27T06:32:12Z",
          "publishedAt": "2025-02-25T05:26:15Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nthe tabulatedFluidProperties have other options than throwing for the out of bounds cases\nhttps://mooseframework.inl.gov/source/fluidproperties/TabulatedBicubicFluidProperties.html\ncan you try those for your case?",
                  "url": "https://github.com/idaholab/moose/discussions/29947#discussioncomment-12319511",
                  "updatedAt": "2025-02-26T00:59:42Z",
                  "publishedAt": "2025-02-26T00:59:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "QUIUQ"
                          },
                          "bodyText": "Thank you, @GiudGiud\nHowever, I believe the main issue lies elsewhere. I have used the capillary pressure parameters from the restart examples, so I believe the parameters are correct. https://mooseframework.inl.gov/modules/porous_flow/restart.html\nThe change I made was to the fluid properties, replacing immiscible methane with miscible CO\u2082 gas. However, the simulation fails quickly \uff08the dt become extremely small\uff09. Upon examining the results, I found that the simulation stalls when the CO\u2082 gas fills the left mesh (the injection zone) and stops when attempting to advect to the right mesh.\n\nIs there something wrong with my input file? This issue is really frustrating, and I hope I can get some help. and my input file https://github.com/QUIUQ/CO2-injection-MOOSE/blob/main/co2_injection_vg.i",
                          "url": "https://github.com/idaholab/moose/discussions/29947#discussioncomment-12320124",
                          "updatedAt": "2025-02-26T02:36:42Z",
                          "publishedAt": "2025-02-26T02:36:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Have you tried some of the solutions from this page? what were the results?\nhttps://mooseframework.inl.gov/moose/application_usage/failed_solves.html",
                          "url": "https://github.com/idaholab/moose/discussions/29947#discussioncomment-12326617",
                          "updatedAt": "2025-02-26T14:26:07Z",
                          "publishedAt": "2025-02-26T14:26:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont see anything obviously wrong in the input.\ndoes this simulation solve with other fluid properties? Maybe more simple ones? ( replacing immiscible methane/ did those work?)",
                          "url": "https://github.com/idaholab/moose/discussions/29947#discussioncomment-12326650",
                          "updatedAt": "2025-02-26T14:29:27Z",
                          "publishedAt": "2025-02-26T14:27:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "QUIUQ"
                  },
                  "bodyText": "Thank you, @GiudGiud\nI have successfully run simulations using immiscible methane with the capillarypressureVG model and an alpha value of 1e-5.\nAdditionally, I tried using an alpha value of 1 for miscible CO\u2082, which also worked.\nHowever, when I set alpha to 1e-5 for miscible CO\u2082, the simulation fails to advect to the next mesh.\nI suspect that the alpha value might be the issue.\nAn alpha of 1e-5 is considered a reasonable engineering value, isn't it?\nCould it be that a smaller alpha increases the capillary pressure, preventing the gas from entering adjacent meshes?",
                  "url": "https://github.com/idaholab/moose/discussions/29947#discussioncomment-12327884",
                  "updatedAt": "2025-02-26T15:59:33Z",
                  "publishedAt": "2025-02-26T15:59:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "An alpha of 1e-5 is considered a reasonable engineering value, isn't it?\n\nI would not know\nfrom alpha = 1 to alpha = 1e-5, what changes in the numerical solve?\nIf we can see an impact on the scaling of the equations, or the conditioning of the matrix, or the distance between the solution and the initial condition, then this could be a clue to how to fix this",
                          "url": "https://github.com/idaholab/moose/discussions/29947#discussioncomment-12328716",
                          "updatedAt": "2025-02-26T17:07:30Z",
                          "publishedAt": "2025-02-26T17:07:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "I think it is still the issue that is noted in #23197 (reply in thread)\nThe workaround in that case was to make a second (constant) capillary pressure user object and use that in the material. It doesn't affect the results, only the derivatives and hence has helped convergence.",
                          "url": "https://github.com/idaholab/moose/discussions/29947#discussioncomment-12333323",
                          "updatedAt": "2025-02-27T02:35:58Z",
                          "publishedAt": "2025-02-27T02:35:57Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "QUIUQ"
                  },
                  "bodyText": "Thank you, @GiudGiud and @cpgr , for your responses and suggestions.\nI appreciate your help! The workaround with the constant capillary pressure user object has helped with convergence. I also realized that I should set the pc_max, because \ud835\udc5d_water = \ud835\udc5d_gas \u2212 \ud835\udc5d\ud835\udc50, and if \ud835\udc5d\ud835\udc50 is too high, \ud835\udc5d_water might fall below the range of the tabulated flow. I'm not sure if my understanding is correct.\nI'll continue learning the MOOSE Framework. Thank you again for your guidance and support!",
                  "url": "https://github.com/idaholab/moose/discussions/29947#discussioncomment-12334556",
                  "updatedAt": "2025-02-27T06:13:44Z",
                  "publishedAt": "2025-02-27T06:13:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to change \u201cnl_abs_tol\u201d during running by Controls function?",
          "author": {
            "login": "lipxisi"
          },
          "bodyText": "Hello\nSome reasons caused my calculation example to be difficult to converge at the beginning, requiring a larger convergence criterion. However, after running for some time, the convergence becomes good, and at this point, a smaller convergence criterion is needed to ensure continuous calculations. I hope to use the control function to change \u201cnl_abs_tol\u201d during runtime, but it seems that\u201cnl_abs_tol\u201d has not been declared as a controllable variable. It seems that how to declare nl_abs_tol in transient as a controllable variable? I added params.declareControllable(\"nl_abs_tol\"); in both FEProblemSolve.C and transient.c respectively, and after recompiling and running, the following error still occurs:\n*** ERROR ***\nThe following error occurred in the object \"func_control\", of type \"RealFunctionControl\".\n\nThe desired parameter 'nl_abs_tol' was not located for the 'func_control' object, it either does not exist or has not been declared as controllable.\n\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/29979",
          "updatedAt": "2025-02-27T04:10:08Z",
          "publishedAt": "2025-02-27T02:29:53Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou cannot use the Controls system to control convergence criteria.\nHowever you can use the new Convergence system to have custom convergence criteria.\nYou might have to create a new object, I dont think we have a Function option for nl_abs_tol at this point",
                  "url": "https://github.com/idaholab/moose/discussions/29979#discussioncomment-12333897",
                  "updatedAt": "2025-02-27T04:10:09Z",
                  "publishedAt": "2025-02-27T04:10:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using a postprocessor or vectorpostprocessor to calculate the heat source",
          "author": {
            "login": "CadenWil"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi,\nI'm attempting to learn some of the post processing capabilities of MOOSE. One of the things I'd like to know how to do is how to use a post processor to graph the heat source.  I've looked through several tutorials and haven't found an answer.\nI did learn how to graph variables such as temperature.\nHere is the example I'm currently working with:\nSiliconChip_addPost.txt\nIn this example the heat source is a single value, however I intend to change that in the future.\nWhat post processor can I use to graph the heat being generated?",
          "url": "https://github.com/idaholab/moose/discussions/29954",
          "updatedAt": "2025-02-26T20:31:47Z",
          "publishedAt": "2025-02-25T20:06:03Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nI did learn how to graph variables such as temperature.\n\nDo you want the temperature at a point? Or the average?\n\nWhat post processor can I use to graph the heat being generated?\n\nthe heat is a constant here. We cannot grab a constant from the parameters to plot it at the time. You could code something to do that if you wanted.\nUse a different kernel that takes in a postprocessor for example for the heat source.\nThen you can plot that postprocessor as it will be output to CSV\n  [heat_source]\n    type = HeatSource\n    variable = T\n    value = 5000000\n    block = 2\n  []",
                  "url": "https://github.com/idaholab/moose/discussions/29954#discussioncomment-12317768",
                  "updatedAt": "2025-02-25T20:46:44Z",
                  "publishedAt": "2025-02-25T20:46:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "CadenWil"
                          },
                          "bodyText": "What is my heat is not a constant?  For example if I add this block:\n[Functions]\n [volumetric_heat]\n    type = ParsedFunction\n    expression = 5000000*x/0.01\n []\n[]\n\nand I change the heat_source block to:\n[heat_source]\n    type = HeatSource\n    variable = T\n    function = volumetric_heat\n    block = 2\n[]\n\nNow the heat source is a function of the x direction.  Is there a way for me to graph it with a post processor?\nHere is the full file for reference.\nSiliconChip_addPostwFunction.txt",
                          "url": "https://github.com/idaholab/moose/discussions/29954#discussioncomment-12328362",
                          "updatedAt": "2025-02-26T16:38:25Z",
                          "publishedAt": "2025-02-26T16:38:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can use this to output the value of the function to a postprocessor\nhttps://mooseframework.inl.gov/source/postprocessors/FunctionValuePostprocessor.html\nif you want to see the integrated value, for the total energy, you can then feed it into this PP\nhttps://mooseframework.inl.gov/source/postprocessors/TimeIntegratedPostprocessor.html",
                          "url": "https://github.com/idaholab/moose/discussions/29954#discussioncomment-12328937",
                          "updatedAt": "2025-02-26T17:21:37Z",
                          "publishedAt": "2025-02-26T17:21:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "CadenWil"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/29954#discussioncomment-12330878",
                          "updatedAt": "2025-02-26T20:31:48Z",
                          "publishedAt": "2025-02-26T20:31:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issue with use_displaced_mesh in Viscoelastic Adhesive Contact Setup",
          "author": {
            "login": "asurovi"
          },
          "bodyText": "I am currently working on implementing viscoelastic adhesive contact in MOOSE. To achieve this, I have considered using the BilinearMixedModeCohesiveZoneModel user object along with NormalMortarMechanicalContact constraints for defining the adhesive contact behavior. Additionally, I have chosen the GeneralizedMaxwellModel as the material model to capture the viscoelastic response.\nHowever, after running my input file, I encountered the following error message:\n*** ERROR ***\ntwoBlockViscoelasticAdhesiveContact.i:247.5:\nThe following parameter error occurred in the UserObject 'czm_uo' of type BilinearMixedModeCohesiveZoneModel.\nuse_displaced_mesh: 'use_displaced_mesh' must be true for the WeightedGapUserObject object\nTo resolve this, I attempted to set the global parameter use_displaced_mesh = true, but the issue persists.\nI would appreciate any insights on how to correctly enable use_displaced_mesh in this setup or any necessary modifications to properly model viscoelastic adhesive contact.\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/29918",
          "updatedAt": "2025-02-27T18:16:59Z",
          "publishedAt": "2025-02-19T14:50:48Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "Hello! I'm not familiar with contact problems or methods, but I think you need specify displacement variables for the Problem. The easiest way to do this is using GlobalParams:\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\nWhere the number of disp_* entries should equal the dimensionality of your mesh. If you don't have variables representing displacements, you can create fake ones for now like this:\n[AuxVariables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/29918#discussioncomment-12252820",
                  "updatedAt": "2025-02-19T17:17:30Z",
                  "publishedAt": "2025-02-19T17:17:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Thanks @zachmprince, that turned out to be the issue. Although use_displaced_mesh was set as a Global Parameter, this didn't fix the error because the disp_* variables weren't identified as the displacement in the Global Parameters, which meant it didn't get pasted to the Problem.\nI wanted to respond to this and let @GiudGiud know, since perhaps the error message could be improved. My guess is, there is a logical test inside Problem which silently changes use_displaced_mesh to false on all objects if the displacement parameter isn't set. Might be better to check the error of the missing displacements for the Problem if use_displaced_mesh is set to true.",
                  "url": "https://github.com/idaholab/moose/discussions/29918#discussioncomment-12319646",
                  "updatedAt": "2025-02-26T01:19:53Z",
                  "publishedAt": "2025-02-26T01:19:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ll create an issue.\nI agree the current behavior is sneaky, probably for some obscure reason dating from early moose days",
                          "url": "https://github.com/idaholab/moose/discussions/29918#discussioncomment-12326808",
                          "updatedAt": "2025-02-26T14:38:30Z",
                          "publishedAt": "2025-02-26T14:38:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "New grain formation using Grain tracker",
          "author": {
            "login": "ritamcj"
          },
          "bodyText": "Dear Moose users,\nI am trying to simulate nucleation in a polycrystal using Grain tracker. I came across the option \"reserved order parameters\" in Grain tracker but I am unable to figure out how to invoke new grain formation using this. I tried various strategies as follows:\n\nI used discretenucleation to increase new grain order parameters (say gr3,gr4,gr5) to values greater than the threshold required to recognise a new feature. I kept op_num = 6, initial grains = 3 and used polycrystalvariables and polycrystalkernel to evolve grain op's with prefix \"gr\".\n\n[./nucleation_energy]\n  type = DiscreteNucleation\n  f_name = Fn\n  op_names  = 'gr0 gr1 gr2 gr3 gr4 gr5'\n  op_values = '0.1 0.1 0.1 1 1 1'\n  penalty = 20\n  penalty_mode = MATCH\n  map = map\n  block = 'face1_QUAD4  face2_QUAD4  face3_QUAD4'\n  outputs = exodus\n[../]\n\n\nIncrease the number of order parameters \"op_num\" in my input file by writing a simple function. Something like:\n\n[GlobalParams]\n  op_num = op_evolution_function\n  deformed_grain_num = 3\n  var_name_base = gr\n  grain_tracker = grain_tracker\n[../]\n\n[Functions]\n  [./op_evolution_function]\n    type = ParsedFunction\n    value = deformed_grain_num + 1\n  [../]\n[]\n\nThis did not work as the syntax to read a function value is likely incorrect. I have come across functions in Grain tracker such as newGrainCreated, getNewGrainIDs but am unable to figure out how to invoke nucleation through new grain order parameters. I would really appreciate guidance on possible strategies to tackle this problem.\nWarm Regards,\nRitam",
          "url": "https://github.com/idaholab/moose/discussions/19191",
          "updatedAt": "2025-02-26T13:37:08Z",
          "publishedAt": "2021-10-25T05:36:37Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hi Ritam,\nIf you haven't already, please have a look at the documentation page\nhttps://mooseframework.inl.gov/modules/phase_field/Nucleation/DiscreteNucleation.html\nand especially the section Direct Order Parameter Modification. You will need to add a DiscreteNucleationForce and Reaction kernel that act on the reserved order parameter. You shouldn't need to do either of the other things you tried, but you will need a map and inserter to inform the DiscreteNucleationForce kernel.",
                  "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-1539139",
                  "updatedAt": "2022-07-05T08:34:21Z",
                  "publishedAt": "2021-10-26T14:38:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Also make sure you run nucleation only on the reserved order parameters. Those are not assigned any grains by the grain tracker and can be use to stage new nuclei.",
                          "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-1542384",
                          "updatedAt": "2022-07-05T08:34:22Z",
                          "publishedAt": "2021-10-27T02:06:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ritamcj"
                  },
                  "bodyText": "Hi Larry and Daniel,\nThank you so much for your suggestions. I am able to see nucleating grains individually through their order parameters (say gr9). I am now trying to observe the evolving grain structure, but the new nuclei aren't observed in \"unique_grains\" in GrainTracker even though the new grain order parameters exceed the threshold. However, the halos do update. Any pointers regarding this? I have applied a grain growth model through \"polycrystalstoredenergy\" and am able to observe grain growth in pre-existing grains.\nRitam\n\n  \n    \n    \n\n    new_grains.mp4\n    \n  \n\n  \n\n  \n\n\n\n  \n    \n    \n\n    unique_grains.1.mp4\n    \n  \n\n  \n\n  \n\n\n\n  \n    \n    \n\n    halos.mp4",
                  "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-1552583",
                  "updatedAt": "2022-07-05T08:34:23Z",
                  "publishedAt": "2021-10-28T12:51:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Ritam, you will need to use a significantly higher mesh resolution than shown here. The GrainTracker is probably having a hard time distinguishing new grains from existing grains. The nucleation rate also seems to be very high so it may be having a hard time distinguishing between individual nucleation events. Please make sure you have at least 3 mesh elements through the interfaces between order parameters prior to trying anything with nucleation. Once you observe grain growth under these conditions, you can then add in nucleation.",
                  "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-1553129",
                  "updatedAt": "2022-07-05T08:34:22Z",
                  "publishedAt": "2021-10-28T14:25:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Larry,\nI am happy to inform you that I am able to visualize the evolving microstructure with nucleating grains, which grow further with stored deformation energy based on dislocation density evolution. I used a very fine mesh and a slower nucleation rate and it worked. Many thanks for your suggestions.\nWarm regards,\nRitam\n\n  \n    \n    \n\n    new_grains.mp4\n    \n  \n\n  \n\n  \n\n\n\n  \n    \n    \n\n    unique_grains.mp4",
                          "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-1562672",
                          "updatedAt": "2022-07-05T08:34:24Z",
                          "publishedAt": "2021-10-30T11:24:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Great! Glad that worked.",
                          "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-1564011",
                          "updatedAt": "2022-07-05T08:34:24Z",
                          "publishedAt": "2021-10-30T20:05:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Sabalei"
                  },
                  "bodyText": "Hi Ritam,\nI'm trying to simulate static recrystallization. I also applied a grain growth model through \"polycrystalstoredenergy\".\nI have inserted the nucleus through Direct order parameter modification. However, new nuclei shrink after formation rather than grow further.  I tried to increase the hold time and Dislocation density, but it didn't solve the problem. Any pointers regarding this?",
                  "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-12141596",
                  "updatedAt": "2025-02-11T13:09:51Z",
                  "publishedAt": "2025-02-11T13:09:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Sabalei,\nYou can increase the order modification parameter (v1) to increase the driving force for growth of nuclei. Please see https://mooseframework.inl.gov/source/kernels/DiscreteNucleationForce.html\nNow, you should be able to see growth followed by shrinkage and annihilation of nuclei.\nWarm regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-12143879",
                          "updatedAt": "2025-02-11T14:26:06Z",
                          "publishedAt": "2025-02-11T14:26:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Thanks @ritamcj!",
                          "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-12143899",
                          "updatedAt": "2025-02-11T14:27:41Z",
                          "publishedAt": "2025-02-11T14:27:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "@ritamcj @Sabalei @GiudGiud Dear all,\nHave you got any grain coalescence problem in your new grain formation simulation? I am finding two grains with the same grain order parameter are coalescing with each other (Please see the attached image). However, I would like to prevent the coalescence of grains and keep them sepearate with a grain boundary. Would you be kind to let me know what sort of parameters I should use in the GrainTracker userobject to make that happen? Your advice will be highly appreciated. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-12286391",
                          "updatedAt": "2025-02-22T15:01:43Z",
                          "publishedAt": "2025-02-22T15:01:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Sabalei"
                          },
                          "bodyText": "Are these new grains formed by nucleation? Whether remap is enabled? Coalescence can be prevented  by remap two grains that are very close together into different order parameters.",
                          "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-12290344",
                          "updatedAt": "2025-02-23T08:18:53Z",
                          "publishedAt": "2025-02-23T08:18:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "@Sabalei @GiudGiud\nYes, new grains are forming by discrete nucleation. As you suggested, I have enabled the remapping. However, I am getting a\nnew problem. Duplicate grains are forming at the same location when remap_grains = true. Please see the attached image. Any solution for that? Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-12312984",
                          "updatedAt": "2025-02-25T13:06:26Z",
                          "publishedAt": "2025-02-25T13:06:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Sabalei"
                          },
                          "bodyText": "I think you need to modify the Useobject DiscreteNucleationInserter code makes the distance between new grains is greater than a set value.",
                          "url": "https://github.com/idaholab/moose/discussions/19191#discussioncomment-12326013",
                          "updatedAt": "2025-02-26T13:37:09Z",
                          "publishedAt": "2025-02-26T13:37:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Voronoi tessellation",
          "author": {
            "login": "sidharthsarmah"
          },
          "bodyText": "Hi @GiudGiud ,\nI want to create a voronoi tessellation of a steel sample and perform diffusion modelling. It has different types of grains and grain boundaries, I dont find lot of text related to VT in MOOSE, can you please suggest.",
          "url": "https://github.com/idaholab/moose/discussions/29558",
          "updatedAt": "2025-02-26T02:08:43Z",
          "publishedAt": "2024-12-17T02:33:15Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere are plenty of options. See the PropertyReadFile to be able to load data using a voronoi distribution. Then once this data is in a FUnction you can use it to assign subdomains, (through FunctionAux + CoupledVarSubdomainModifier), to assign material properties (using the same PropertyReadFile) etc",
                  "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11587926",
                  "updatedAt": "2024-12-17T02:37:25Z",
                  "publishedAt": "2024-12-17T02:37:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Does that mean I have to generate the coordinates using another code and use the coordinates as input in MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11588245",
                          "updatedAt": "2024-12-17T03:35:01Z",
                          "publishedAt": "2024-12-17T03:35:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There might be a random voronoi generator in moose. Look through the ICs in phase field maybe",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11588400",
                          "updatedAt": "2024-12-17T04:08:14Z",
                          "publishedAt": "2024-12-17T04:08:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud, I will need some help on it, as this is the first I am working on VT:\n\n\nUsing Python, I created a VT which looks something like this, and gives me x and y coordinates of the vertices:\n\n\nNow, this goes into the MOOSE right?\n\n\nIf so, how do I obtain the finite element of each grains in MOOSE?\n\n\nOr do I need to create a meshed of each tessellation in ABAQUS (by inserting the python generated VT as inputs) and then input the generated mesh from ABAQUS in MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11612827",
                          "updatedAt": "2024-12-22T05:26:32Z",
                          "publishedAt": "2024-12-19T04:04:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Now, this goes into the MOOSE right?\n\nYou can load the coordinate in a PropertyReadFile in Voronoi mode yes\n\nIf so, how do I obtain the finite element of each grains in MOOSE?\n\nin phase field, I have seen overlaying the VT on top of a Cartesian mesh instead. Then assign elements based on the VT\n\nOr do I need to create a meshed of each tessellation in ABAQUS (by inserting the python generated VT as inputs) and then input the generated mesh from ABAQUS in MOOSE?\n\nThis works! Just do whatever works imo",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11613036",
                          "updatedAt": "2024-12-19T04:59:24Z",
                          "publishedAt": "2024-12-19T04:59:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "@GiudGiud , can you suggest if there are other ways (library/ software) to mesh the generate VT cells from Python which can be inserted into MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11613088",
                          "updatedAt": "2024-12-19T05:08:48Z",
                          "publishedAt": "2024-12-19T05:08:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud . Also, this is one example I found in MOOSE, its does not align with the grain but rather is just x, y coord in MOOSE.\nmodules/phase_field/test/tests/initial_conditions/PolycrystalVoronoiIC_periodic.i\nDoes that mean I have to mesh it somewhere else and insert it in MOOSE:",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11613507",
                          "updatedAt": "2024-12-22T05:26:42Z",
                          "publishedAt": "2024-12-19T06:29:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Does that mean I have to mesh it somewhere else and insert it in MOOSE:\n\nIf you dont like how they do it in phase field, then yes.\nAlternatively, we do have the capability to generate 2D tetrahedral meshes\nhttps://mooseframework.inl.gov/source/meshgenerators/XYDelaunayGenerator.html\nIf you could input the boundaries of the VT, you could use that to generate the mesh.\nYou could also make an integrated capability (loads the VT then meshes it) by creating a new mesh generator",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11617677",
                          "updatedAt": "2024-12-19T13:47:27Z",
                          "publishedAt": "2024-12-19T13:47:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you suggest if there are other ways (library/ software) to mesh the generate VT cells from Python which can be inserted into MOOSE?\n\nI am sure there are hundreds of python packages to generate VTs. This is a very common model",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11617697",
                          "updatedAt": "2024-12-19T13:47:56Z",
                          "publishedAt": "2024-12-19T13:47:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "hi @GiudGiud thanks, lets say I am doing a diffusion problem along the grain (cL, DL) and grain boundary (cBG, DGB).\nif I use these kernels, how will MOOSE determine whether I am solving eqn 1 or 2, ie the two PDE together or separately?",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11619365",
                          "updatedAt": "2024-12-22T05:26:58Z",
                          "publishedAt": "2024-12-19T16:11:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are these equations supposed to be block restricted?",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11619393",
                          "updatedAt": "2024-12-19T16:13:40Z",
                          "publishedAt": "2024-12-19T16:13:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ADParsedFunction Deprecation Warning",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI have a script where I get this warning:\n*** Warning, This code is deprecated and will be removed in future versions:\n***** Invalid Object: ADParsedFunction *****\nExpired on Sat Feb  3 01:00:00 2024\nUpdate your application using the 'MooseParsedFunction' object\n\nHowever I can't find MooseParsedFunction in the source or online documentation, and when I tried to update it I got:\n*** ERROR ***\nA 'MooseParsedFunction' is not a registered object.\n\nIf you are trying to find this object in a dynamically loaded library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\n\nWhat exactly is this deprecation warning referring to, then?",
          "url": "https://github.com/idaholab/moose/discussions/29950",
          "updatedAt": "2025-02-25T16:42:37Z",
          "publishedAt": "2025-02-25T15:42:21Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nuse ParsedFunction instead of MooseParsedFunction\nADParsedFunctions were removed",
                  "url": "https://github.com/idaholab/moose/discussions/29950#discussioncomment-12314964",
                  "updatedAt": "2025-02-25T15:52:08Z",
                  "publishedAt": "2025-02-25T15:52:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "I see. I guess since I'm using the parsed function as a ADNeumannBC, the AD functionality gets applied at the BC level?",
                          "url": "https://github.com/idaholab/moose/discussions/29950#discussioncomment-12315029",
                          "updatedAt": "2025-02-25T15:57:55Z",
                          "publishedAt": "2025-02-25T15:57:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes and no.\nyes, the BC will use AD so it does not have a manual Jacobian implementation\nno, the function does not carry derivatives. So it should not depend on a nonlinear variable, otherwise AD will miss those derivatives and your Jacobian will be imperfect",
                          "url": "https://github.com/idaholab/moose/discussions/29950#discussioncomment-12315186",
                          "updatedAt": "2025-02-25T16:13:35Z",
                          "publishedAt": "2025-02-25T16:13:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Ah I see that makes sense. And if I need a function that depends on a nonlinear variable I can just create a custom BC object.",
                          "url": "https://github.com/idaholab/moose/discussions/29950#discussioncomment-12315526",
                          "updatedAt": "2025-02-25T16:41:08Z",
                          "publishedAt": "2025-02-25T16:41:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I can just create a custom BC object.\n\neither that or use AD material properties or AD functor material properties. Both can carry AD derivatives",
                          "url": "https://github.com/idaholab/moose/discussions/29950#discussioncomment-12315540",
                          "updatedAt": "2025-02-25T16:42:39Z",
                          "publishedAt": "2025-02-25T16:42:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Total volume",
          "author": {
            "login": "amassaf"
          },
          "bodyText": "Hi I am using CZM on a cylindrical mesh and I want to find the total volume of the deformed cylinder (CZ deformation included) and I was wondering if there is a way to get this volume? I thought of using InternalVolume by setting a boundary surrounding the original cylinder but setting this boundary only seems to work with BoundingBoxNodeSetGenerator which doesn't work with cylinders ? Would you have any advice on how to get the full volume in this case ? Thank you",
          "url": "https://github.com/idaholab/moose/discussions/29711",
          "updatedAt": "2025-03-03T16:14:45Z",
          "publishedAt": "2025-01-20T09:41:38Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@arovinelli do you know?",
                  "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-11893697",
                  "updatedAt": "2025-01-20T17:46:30Z",
                  "publishedAt": "2025-01-20T17:46:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "arovinelli"
                  },
                  "bodyText": "A first order approximation would be _qp_weight[_qp] times _disp_jump[_qp], Then of course you need to sum them all together. I'm not sure if there is a user object or something else already doing it for you ... Maybe @hugary1995 ?",
                  "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-11903341",
                  "updatedAt": "2025-01-21T14:40:45Z",
                  "publishedAt": "2025-01-21T14:40:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "We do not currently have such object, but the approach @arovinelli described would work.\nI'm however having trouble understanding the motivation for including separation volume in the total volume calculation. I think the cohesive elements are supposed to be zero-thickness dummy elements for tracking traction-separation laws. The \"volume\" of these cohesive elements are essentially void in my understanding. Maybe @amassaf could explain the motivation.",
                          "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-11903454",
                          "updatedAt": "2025-01-21T14:51:43Z",
                          "publishedAt": "2025-01-21T14:51:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amassaf"
                          },
                          "bodyText": "I have a polycrystal under compression, I want to quantify the change in volume due to voids, the decrease in volume at first followed by increase in volume due to the jump",
                          "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-11903496",
                          "updatedAt": "2025-01-21T14:55:36Z",
                          "publishedAt": "2025-01-21T14:55:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Usually I wouldn't directly associate the separation across cohesive elements with voids because they are at different scales. Does the traction-separation law you are using contain some internal variables that describe void formation/evolution? I might be better to directly integrate such internal variables on the interface.",
                          "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-11903533",
                          "updatedAt": "2025-01-21T15:00:04Z",
                          "publishedAt": "2025-01-21T15:00:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amassaf"
                          },
                          "bodyText": "no sorry by void I meant the separation at the interface the normal_jump or tangent_jump leading to normal_jump when there is total loss of traction (total decohesion)",
                          "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-11903617",
                          "updatedAt": "2025-01-21T15:06:14Z",
                          "publishedAt": "2025-01-21T15:06:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay, I think I understand now. You can create a postprocessor deriving from SideIntegralPostprocessor, in computeQpIntegral() the expression you'd want to use is\nreturn _disp_jump[_qp] * _normals[_qp];",
                          "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-11903770",
                          "updatedAt": "2025-01-21T15:14:48Z",
                          "publishedAt": "2025-01-21T15:14:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amassaf"
                          },
                          "bodyText": "Ok, thank you so much for your help ! :)",
                          "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-11904601",
                          "updatedAt": "2025-01-21T16:05:53Z",
                          "publishedAt": "2025-01-21T16:05:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amassaf"
                          },
                          "bodyText": "Hi, so I have another question regarding this sideintegralpostprocessor. I want to get this :\n but I want it in two forms:\nI want to get the components of the tensor from the outerproduct between the displacement jump  with jump_x jump_y jump_z  and the normal to the interface (n_x n_y n_z) .\nBut I also want the normal to the interface as normal (n_n and n_t) with the displacement jump from normal_jump and tangent_jump. So my question is how can I get these normals and what is the _normals[_qp] referring to. Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-12084682",
                          "updatedAt": "2025-02-06T17:17:12Z",
                          "publishedAt": "2025-02-06T17:17:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "_normals is the local normal to the face in a side-integration, at that quadrature point. For a second or higher order element, the normal is not constant along the face, but depends on the side quadrature point.\nwhat is n_n here? normal?\nand n_t ? tangeant?",
                          "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-12084760",
                          "updatedAt": "2025-02-06T17:26:46Z",
                          "publishedAt": "2025-02-06T17:26:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amassaf"
                          },
                          "bodyText": "Oh ok. n_n and n_t would be the components in the normal and tangential direction function of unit vectors in the normal and tangential direction.",
                          "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-12084895",
                          "updatedAt": "2025-02-06T17:39:20Z",
                          "publishedAt": "2025-02-06T17:39:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m not sure how to define the tangeant here but maybe you ll know what to pick",
                          "url": "https://github.com/idaholab/moose/discussions/29711#discussioncomment-12084922",
                          "updatedAt": "2025-02-06T17:41:43Z",
                          "publishedAt": "2025-02-06T17:41:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}