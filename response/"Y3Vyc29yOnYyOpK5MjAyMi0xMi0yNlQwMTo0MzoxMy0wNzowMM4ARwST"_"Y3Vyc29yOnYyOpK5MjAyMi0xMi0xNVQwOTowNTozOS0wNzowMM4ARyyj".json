{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMi0xNVQwOTowNTozOS0wNzowMM4ARyyj"
    },
    "edges": [
      {
        "node": {
          "title": "error: no matching function for call to 'FEProblemBase::assembly(THREAD_ID&, int)",
          "author": {
            "login": "batodon"
          },
          "bodyText": "Hello,\nI\u2019m assigning a THREAD_ID typedef to some variables (_curr_node and _curr_element), but I keep getting the following no matching function call when I try to compile. Could you please help?\n/home/batodon/MOOSE/projects/ergs/src/materials/PFEMBase.C:94:38: error: no matching function for call to 'FEProblemBase::assembly(THREAD_ID&, int)'\n   94 |     _curr_node(problem.assembly(tid,0).node()),\n      |                                      ^\nIn file included from /home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/UserObjectInterface.h:14,\n                 from /home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/MaterialBase.h:21,\n                 from /home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/Material.h:13,\n                 from /home/batodon/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowMaterial.h:12,\n                 from /home/batodon/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowMaterialVectorBase.h:12,\n                 from /home/batodon/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowPermeabilityBase.h:12,\n                 from /home/batodon/MOOSE/projects/ergs/build/header_symlinks/PFEMBase.h:3,\n                 from /home/batodon/MOOSE/projects/ergs/src/materials/PFEMBase.C:1,\n                 from /home/batodon/MOOSE/projects/ergs/build/unity_src/materials_Unity.C:2:\n/home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/FEProblemBase.h:330:14: note: candidate: 'virtual Assembly& FEProblemBase::assembly(THREAD_ID)'\n  330 |   Assembly & assembly(THREAD_ID tid) override\n      |              ^~~~~~~~\n/home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/FEProblemBase.h:330:14: note:   candidate expects 1 argument, 2 provided\n/home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/FEProblemBase.h:335:20: note: candidate: 'virtual const Assembly& FEProblemBase::assembly(THREAD_ID) const'\n  335 |   const Assembly & assembly(THREAD_ID tid) const override\n      |                    ^~~~~~~~\n/home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/FEProblemBase.h:335:20: note:   candidate expects 1 argument, 2 provided\nIn file included from /home/batodon/MOOSE/projects/ergs/build/unity_src/materials_Unity.C:2:\n/home/batodon/MOOSE/projects/ergs/src/materials/PFEMBase.C:95:41: error: no matching function for call to 'FEProblemBase::assembly(THREAD_ID&, int)'\n   95 |     _curr_element(problem.assembly(tid,0).elem()),\n\nHere is my declaration:\n\t  FEProblemBase & problem;\n\t  THREAD_ID tid;\n\nAnd part of my destructor:\n    problem(*getCheckedPointerParam<FEProblemBase *>(\"_fe_problem_base\")),\n    tid(getParam<THREAD_ID>(\"_tid\")),\n    _curr_node(problem.assembly(tid,0).node()),\n    _curr_element(problem.assembly(tid,0).elem()),\n\nThe problem seems to come from the arguments to _curr_node and _curr_element. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/22996",
          "updatedAt": "2022-12-23T22:00:14Z",
          "publishedAt": "2022-12-20T16:22:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think you just need problem.assembly(tid), no 0\nWhat does that return ?",
                  "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4460607",
                  "updatedAt": "2022-12-20T16:45:57Z",
                  "publishedAt": "2022-12-20T16:45:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Thanks, @GiudGiud. I already tried it. It compiled but I had a segmentation fault when I run my input file.",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4460631",
                          "updatedAt": "2022-12-20T16:48:40Z",
                          "publishedAt": "2022-12-20T16:48:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it might not come from that though\ncan you run this in a debugger\nhttps://mooseframework.inl.gov/application_development/debugging.html",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4460715",
                          "updatedAt": "2022-12-20T17:00:56Z",
                          "publishedAt": "2022-12-20T17:00:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hi @GiudGiud. Any help? I hit a 'virtual memory exhausted' when building in a dbg mode:\n{standard input}: virtual memory exhausted: Cannot allocate memory\nvirtual memory exhausted: Cannot allocate memory\nvirtual memory exhausted: Cannot allocate memory\nAssembler messages:\n{standard input}:709029: Fatal error: bfd_make_empty_symbol: memory exhausted\n{standard input}:709029: Fatal error: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/.libs/userobjects_Unity.x86_64-conda-linux-gnu.dbg.o: memory exhausted\nvirtual memory exhausted: Cannot allocate memory\nvirtual memory exhausted: Cannot allocate memory\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/materials_lagrangian_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1\nmake: *** Waiting for unfinished jobs....\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/userobjects_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/materials_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/materials_cohesive_zone_model_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/materials_crystal_plasticity_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/bcs_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4461253",
                          "updatedAt": "2022-12-20T18:21:18Z",
                          "publishedAt": "2022-12-20T18:16:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you build with a single process?\nMETHOD=dbg make -j 1",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4461270",
                          "updatedAt": "2022-12-20T18:19:52Z",
                          "publishedAt": "2022-12-20T18:19:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Not quite sure if I'm getting the correct backtrace, but here is the error from debugging. I can't find the location (to either the header/src file) for my problem.\n*** ERROR ***\n\nStack frames: 7\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\n2: void mooseError<char const*>(char const*&&)\n3: MooseApp::run()\n4: main\n5: __libc_start_main\n6: /home/batodon/MOOSE/projects/ergs/ergs-dbg(+0x3079) [0x555555557079]\n\nThread 1 \"ergs-dbg\" hit Breakpoint 1, 0x00007fffea061cc0 in PMPI_Abort () from /home/batodon/mambaforge3/envs/moose/lib/libmpi.so.12\n(gdb) bt\n#0  0x00007fffea061cc0 in PMPI_Abort () from /home/batodon/mambaforge3/envs/moose/lib/libmpi.so.12\n#1  0x00007ffff4a75bab in moose::internal::mooseErrorRaw (msg=..., prefix=...)\n    at /home/batodon/MOOSE/projects/moose/framework/src/base/MooseError.C:83\n#2  0x00007ffff5f21ff5 in mooseError<char const*> () at /home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/MooseError.h:258\n#3  0x00007ffff4a165a9 in MooseApp::run (this=0x5555557474a0) at /home/batodon/MOOSE/projects/moose/framework/src/base/MooseApp.C:1406\n#4  0x0000555555557739 in main (argc=3, argv=0x7fffffffbed8) at /home/batodon/MOOSE/projects/ergs/src/main.C:33",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4461480",
                          "updatedAt": "2022-12-20T18:50:19Z",
                          "publishedAt": "2022-12-20T18:50:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This error with no message is often a libmesh error.\nThe backtrace shows line 1406 in the mooseApp file\nWhat is it for your current moose version?\nFor me it s the errorCheck, but for you it might be something else",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4462029",
                          "updatedAt": "2022-12-20T20:26:10Z",
                          "publishedAt": "2022-12-20T20:26:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Thanks @GiudGiud. This is what I have on line 1406 of mooseApp.C file:\nmooseError(err.what());",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4462108",
                          "updatedAt": "2022-12-20T20:42:45Z",
                          "publishedAt": "2022-12-20T20:42:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok so an initialSetup() is failing with a libmesh_error and it s being caught there/\nYou ll need to set a breakpoint on libmesh_error, then generate a backtrace there",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4462116",
                          "updatedAt": "2022-12-20T20:46:20Z",
                          "publishedAt": "2022-12-20T20:46:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Sorry, I got  No stack.  as  backtrace after setting a breakpoint on libmesh_error.",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4462148",
                          "updatedAt": "2022-12-20T21:09:38Z",
                          "publishedAt": "2022-12-20T20:54:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you ll need to catch the breakpoint to have a stack.\nno stock means it ran to completion",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4462205",
                          "updatedAt": "2022-12-20T21:04:59Z",
                          "publishedAt": "2022-12-20T21:04:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fracture propagation in natural fractured reservoir",
          "author": {
            "login": "miraboreasumr"
          },
          "bodyText": "Hello,\nI have a naturally fractured reservoir, and I have the location of the natural fractures (EDFM?)\nWhat are the modules I should learn if I want to study the natural fracture propagation while injecting fluid into the fractures?",
          "url": "https://github.com/idaholab/moose/discussions/23017",
          "updatedAt": "2023-01-03T23:46:48Z",
          "publishedAt": "2022-12-22T16:45:27Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "For reservoir modeling, you want to look at porous_flow ( https://mooseframework.inl.gov/modules/porous_flow/index.html ). They have a few examples of flow through fractures, see https://mooseframework.inl.gov/modules/porous_flow/flow_through_fractured_media.html.\nhttps://mooseframework.inl.gov/modules/porous_flow/multiapp_fracture_flow_PorousFlow_3D.html might be closest approach to the EDFM approach you mentioned. However, I do not think that is capable of modeling fracture propagation yet.",
                  "url": "https://github.com/idaholab/moose/discussions/23017#discussioncomment-4477475",
                  "updatedAt": "2022-12-22T17:05:44Z",
                  "publishedAt": "2022-12-22T17:05:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "miraboreasumr"
                          },
                          "bodyText": "So no way to do fracture propagation?",
                          "url": "https://github.com/idaholab/moose/discussions/23017#discussioncomment-4477510",
                          "updatedAt": "2022-12-22T17:08:34Z",
                          "publishedAt": "2022-12-22T17:08:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Which methods do you want to use for fracture propagation? Does EDFM support crack propagation? I am working on the implementation of a phase-field fracture models for hydraulic fracturing within porous flow module. Is that something you are interested in? I might be able to have it ready in January.",
                          "url": "https://github.com/idaholab/moose/discussions/23017#discussioncomment-4478377",
                          "updatedAt": "2022-12-22T18:30:16Z",
                          "publishedAt": "2022-12-22T18:30:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "miraboreasumr"
                          },
                          "bodyText": "Thanks for the reply. EDFM+XFEM (Extended finite element method) can do fracture propagation. If your phase-field models can handle when there are natural fractures (EDFM or inner boundary?), and propagation, I will be interested in it.",
                          "url": "https://github.com/idaholab/moose/discussions/23017#discussioncomment-4480347",
                          "updatedAt": "2022-12-23T00:21:15Z",
                          "publishedAt": "2022-12-23T00:21:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stress based damage model",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE Experts,\nI want to implement a simple stress based damage model for my simulation.\nFor example,\nif von-Mises stress for any element >= threshold value\ndamage =1\nelse\ndamage=0\nend\nCan you please locate me a suitable example to do so?\nI shall be very thankful.\nBest,\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/23013",
          "updatedAt": "2023-06-24T19:55:00Z",
          "publishedAt": "2022-12-22T07:10:35Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you looking at cracking?\nStress thresholds are used for some of the models there, you could take a look\nhttps://mooseframework.inl.gov/moose/source/materials/ComputeSmearedCrackingStress.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23013#discussioncomment-4476467",
                  "updatedAt": "2022-12-22T15:05:43Z",
                  "publishedAt": "2022-12-22T15:05:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "And also look at DamageBase class.",
                          "url": "https://github.com/idaholab/moose/discussions/23013#discussioncomment-4477495",
                          "updatedAt": "2022-12-22T17:07:08Z",
                          "publishedAt": "2022-12-22T17:07:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Compiling libmesh with vtk",
          "author": {
            "login": "drebbel1z"
          },
          "bodyText": "I am trying to install libmesh with vtk.\nI have been able to install vtk from source,  but when I input \"./scripts/update_and_rebuild_libmesh.sh --with-vtk-lib=/projects/vtk_install/lib64 --with-vtk-include=/projects/vtk_install/include/vtk-9.2\"  into the terminal, the installation still proceeds without vtk (See below)\nchecking ~/projects/vtk_install/include/vtk-9.2/vtkConfigure.h usability... no\nchecking ~/projects/vtk_install/include/vtk-9.2/vtkConfigure.h presence... no\nchecking for ~/projects/vtk_install/include/vtk-9.2/vtkConfigure.h... no\nVTK header files not found!\n<<< Configuring library without VTK support >>>\n\nI checked the named folder and there is no vtkConfigure.h present. I however found vtkPythonConfigure.h. Are these related?\nHow do I fix this and be able to compile libmesh with vtk?\nI already found this site: https://groups.google.com/g/moose-users/c/Kb6s_LWcEnU\nIt helped me with installing vtk, but I am currently stuck.\nI configured vtk using\ncmake  -DCMAKE_INSTALL_PREFIX=~/projects/vtk_install -DCMAKE_BUILD_TYPE=Release -DVTK_Group_Rendering=OFF -DVTK_WRAP_PYTHON=ON -Wno-dev $HOME/projects/vtk\nas suggested by the site.",
          "url": "https://github.com/idaholab/moose/discussions/22975",
          "updatedAt": "2023-02-04T07:19:55Z",
          "publishedAt": "2022-12-15T21:20:05Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "drebbel1z"
                  },
                  "bodyText": "@GiudGiud, any help?",
                  "url": "https://github.com/idaholab/moose/discussions/22975#discussioncomment-4435416",
                  "updatedAt": "2022-12-17T05:30:28Z",
                  "publishedAt": "2022-12-17T05:30:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\n@milljm knows these things better than I do\nWhy did you pass -Wno-dev to the vtk install?\nSo this is on a cluster right, you are not using conda anywhere? I d probably just download VTK in a conda environment with just that\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22975#discussioncomment-4437208",
                          "updatedAt": "2022-12-17T11:26:58Z",
                          "publishedAt": "2022-12-17T11:26:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "doquang"
                          },
                          "bodyText": "libmesh requires a VTK which MPI supported. Have you compile your VTK with option -DVTK_USE_MPI:BOOL=ON ?",
                          "url": "https://github.com/idaholab/moose/discussions/22975#discussioncomment-4437238",
                          "updatedAt": "2022-12-17T11:36:34Z",
                          "publishedAt": "2022-12-17T11:36:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "drebbel1z"
                          },
                          "bodyText": "@doquang  I just did. I still can't find the vtkConfigure.h file in the include directory\n@GiudGiud I tried the conda installation but I have not had much luck with that. That is why I installed vtk separately. wrt to the conda installation, it compiles and builds fine, except for this warning: unsupported GNU_PROPERTY_TYPE. And none of the tests pass.",
                          "url": "https://github.com/idaholab/moose/discussions/22975#discussioncomment-4437780",
                          "updatedAt": "2022-12-17T14:12:31Z",
                          "publishedAt": "2022-12-17T14:12:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I would not use ~/... use absolute paths to your vtk/lib and vtk/include/vtk-<version> directories. Some times ~ are treated as literal characters...",
                          "url": "https://github.com/idaholab/moose/discussions/22975#discussioncomment-4450439",
                          "updatedAt": "2022-12-19T16:19:55Z",
                          "publishedAt": "2022-12-19T16:19:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Maybe there are some bugs in navier stokes modules",
          "author": {
            "login": "suqingji"
          },
          "bodyText": "Dear developers,\nI am developing the RANS k-omega turbulence model based on MOOSE FEM. Now my k-omega codes can be used to simulate some simple cases. But in other complex cases, the convergence of the code is difficult. So I find some bugs(maybe which is a normal phenomenon but I think it is abnormal) in laminar simulation when I debug my turbulence codes.\nHere is the list about the bugs(Please allow me to call it a bug).\n\nIn a 3D-lid-driven test case, I found that the convergence progress is different on different scale grid unless the variables are scaled.\n\nfor example,\nIf I change the L  params by multiplying factor 1000 with type = TransformGenerator, at the same time  I change the \\mu(Dynamic viscosity)  params by multiplying factor 1000, so the Reynolds number and Euler number are the same. And I also make time step dt becoming 1000 times. So the Strauhal number is the same, too. In other words, the above two problems are the same. So that the convergence progress should be the same in theory. But It is amazing to me that the convergence progress is different.\nMaybe you will tell me that it does not matter. But in fact in complex problems especially in Thermal Hydraulics, the problem may become  Solve Did NOT Converge!\n\n\ntips: In the above problem, I use AD rather than by hand to compute Jacobian.\n\nAlso in a 3D-lid-driven test case\n\nNow I use by hand rather than AD to compute Jacobian. And the conditions are exactly the same as list 1. So that the solution should be the same in theory. And the converge or not converge should be the same in theory. But It is amazing to me that the convergence is different. In AD the problem is converged but in by hand the problem is not converged. If I change the SUPG/PSPG params alpha in the input file the problem becomes converged. Those are unbelievable.\nIt sounds crazy, and it doesn't make sense in theory, but I've actually found these problems, so it feels like some bugs to me.\nBest regards.\nQINGJI SU",
          "url": "https://github.com/idaholab/moose/discussions/21996",
          "updatedAt": "2022-12-18T20:58:20Z",
          "publishedAt": "2022-09-02T09:34:28Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I would have to see the hand-coded and AD inputs in order to understand why you are getting different behavior between the two cases.\nRegarding the scaling ... I believe what you are seeing there is a consequence of the fact that degrees of freedom controlled by Dirichlet boundary conditions are included in the nonlinear system. So as you scale your physics rows, your Dirichlet rows remain unscaled and so you have different operators",
                  "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3539420",
                  "updatedAt": "2022-09-02T18:52:15Z",
                  "publishedAt": "2022-09-02T18:52:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "A way to circumvent this is to apply scaling to the physics rows. You can either supply it manually to Variables sub-blocks via the scaling parameter, or you can use automatic_scaling in the Executioner block:\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  # Run for 100+ timesteps to reach steady state.                                                                     \n  num_steps = 1\n  dt = 0.5\n  dtmin = 0.5\n  petsc_options_iname = '-pc_type -sub_pc_factor_levels -ksp_gmres_restart'\n  petsc_options_value = 'asm      6                     200'\n  line_search = 'none'\n  nl_rel_tol = 1e-12\n  nl_abs_tol = 1e-13\n  nl_max_its = 6\n  automatic_scaling = true\n  verbose = true\n  off_diagonals_in_auto_scaling = true\n[]\n\nThe last parameter off_diagonals_in_auto_scaling is important since the pressure equation has zero (or potentially small if doing PSPG) on-diagonals. So for instance I ran an INS cavity simulation with no scaling of dt/h/mu and then a simulation in which I scaled dt/h/mu by 10, and these are the convergence histories using automatic scaling of the physics rows:\nh/mu/dt scaled by 10\nTime Step 0, time = 0\n\nTime Step 1, time = 5\n          old time = 0\n                dt = 5\n            old dt = 5\n\n\nPerforming automatic scaling calculation\n\nAutomatic scaling factors:\n  velocity: 0.00830258\n  p: 0.03\n\n\n 0 Nonlinear |R| = 1.457738e+00\n      0 Linear |R| = 1.457738e+00\n      1 Linear |R| = 5.039948e-17\n 1 Nonlinear |R| = 5.679814e-03\n      0 Linear |R| = 5.679814e-03\n      1 Linear |R| = 1.589405e-18\n 2 Nonlinear |R| = 7.112778e-08\n      0 Linear |R| = 7.112778e-08\n      1 Linear |R| = 1.398928e-23\n 3 Nonlinear |R| = 8.071238e-17\n Solve Converged!\n\nh/mu/dt scaled by 1\nTime Step 0, time = 0\n\nTime Step 1, time = 0.5\n          old time = 0\n                dt = 0.5\n            old dt = 0.5\n\n\nPerforming automatic scaling calculation\n\nAutomatic scaling factors:\n  velocity: 0.0830258\n  p: 0.3\n\n\n 0 Nonlinear |R| = 1.457738e+00\n      0 Linear |R| = 1.457738e+00\n      1 Linear |R| = 8.947181e-17\n 1 Nonlinear |R| = 5.679814e-03\n      0 Linear |R| = 5.679814e-03\n      1 Linear |R| = 1.280724e-18\n 2 Nonlinear |R| = 7.112778e-08\n      0 Linear |R| = 7.112778e-08\n      1 Linear |R| = 1.370400e-23\n 3 Nonlinear |R| = 4.196560e-17\n Solve Converged!\n\nYou can see that with the scaling, the resulting solves are identical",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3540334",
                          "updatedAt": "2022-09-02T22:09:48Z",
                          "publishedAt": "2022-09-02T22:08:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Hi @lindsayad,\nThank you for your reply.\nYour opinion is right about the first problem. However, there is another question about the first problem.\nIn a complex problem,  there is a linear solver error after using automatic_scaling = true.\n\nIf I remove the code of automatic_scaling = true, the problem could be solved. That is a strange phenomenon. Therefore I hardly use automatic_scaling = true. But I must admit that in some problems the problem convergence progress becomes better if I use automatic_scaling = true.  So I am very tangled if I should use automatic_scaling = true.\nBest regrads.\nQINGJI SU",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3541933",
                          "updatedAt": "2022-09-03T09:57:49Z",
                          "publishedAt": "2022-09-03T09:51:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "About the second problem, Here are my test case input files.\nAD:\nconst_num = 1.e0\nconst_dt = 1.e-1\nconst_mu = ${const_num}\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    xmin = 0\n    xmax = ${const_num}\n    ymin = 0\n    ymax = ${const_num}\n    zmin = 0\n    zmax = ${const_num}\n    nx = 10\n    ny = 10\n    nz = 10\n  []\n  [./corner_node]\n    type = ExtraNodesetGenerator\n    new_boundary = 'pinned_node'\n    nodes = '0'\n    input = gen\n  [../]\n[]\n[Variables]\n  [./velocity]\n    family = LAGRANGE_VEC\n  [../]\n  [./p]\n  [../]\n[]\n[ICs]\n  [velocity]\n    type = VectorConstantIC\n    x_value = 1e-15\n    y_value = 1e-15\n    variable = velocity\n  []\n[]\n[Kernels]\n  [./mass]\n    type = INSADMass\n    variable = p\n  [../]\n  [./mass_pspg]\n    type = INSADMassPSPG\n    variable = p\n  [../]\n  [./momentum_time]\n    type = INSADMomentumTimeDerivative\n    variable = velocity\n  [../]\n  [./momentum_convection]\n    type = INSADMomentumAdvection\n    variable = velocity\n  [../]\n  [./momentum_viscous]\n    type = INSADMomentumViscous\n    variable = velocity\n  [../]\n  [./momentum_pressure]\n    type = INSADMomentumPressure\n    variable = velocity\n    pressure = p\n    integrate_p_by_parts = true\n  [../]\n  [./momentum_supg]\n    type = INSADMomentumSUPG\n    variable = velocity\n    velocity = velocity\n  [../]\n[]\n[BCs]\n  [./no_slip]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'bottom right left front back'\n  [../]\n  [./lid]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'top'\n    function_x = '1'\n  [../]\n  [./pressure_pin]\n    type = DirichletBC\n    variable = p\n    boundary = 'pinned_node'\n    value = 0\n  [../]\n[]\n[Materials]\n  [./const]\n    type = ADGenericConstantMaterial\n    prop_names = 'rho      mu                 cp k'\n    prop_values = '1e4     ${const_mu}       1  1e4'\n  [../]\n  [ins_mat]\n    type = INSADTauMaterial\n    velocity = velocity\n    pressure = p\n    alpha = 1\n  []\n[]\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  num_steps = 1\n  dt = ${const_dt}\n  petsc_options_iname = '-pc_type -sub_pc_factor_levels -ksp_gmres_restart'\n  petsc_options_value = 'lu      2                     200'\n  line_search = 'none'\n  nl_rel_tol = 1e-4\n  nl_abs_tol =  1e-7\n  nl_max_its = 60\n  automatic_scaling = true\n  verbose = true\n  off_diagonals_in_auto_scaling = true\n[]\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\nno AD rather than by hand:\nconst_num = 1.\nconst_dt = 1.e-1\n# const_scaling = 1e0\n\nvel_x = vel_x\nvel_y = vel_y\nvel_z = vel_z\npressure = p\n[GlobalParams]\n  pspg = true\n  supg = true\n  u = vel_x\n  v = vel_y\n  w = vel_z\n  pressure = p\n  integrate_p_by_parts = true\n  alpha = 1\n[]\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    xmin = 0\n    xmax = ${const_num}\n    ymin = 0\n    ymax = ${const_num}\n    zmin = 0\n    zmax = ${const_num}\n    nx = 10\n    ny = 10\n    nz = 10\n  []\n  [./corner_node]\n    type = ExtraNodesetGenerator\n    new_boundary = 'pinned_node'\n    nodes = '0'\n    input = gen\n  [../]\n[]\n\n[Variables]\n  [./vel_x]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./vel_y]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./vel_z]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./p]\n    # scaling = ${const_scaling}\n  [../]\n[]\n\n[Kernels]\n  [mass]\n    type = INSMass\n    variable = p\n  []\n  # x-momentum, time\n  [x_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_x}\n  []\n  # x-momentum, space\n  [x_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_x}\n    component = 0\n  []\n  # y-momentum, time\n  [y_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_y}\n  []\n  # y-momentum, space\n  [y_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_y}\n    component = 1\n  []\n  # z-momentum, time\n  [z_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_z}\n  []\n  # z-momentum, space\n  [z_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_z}\n    component = 2\n  []\n[]\n\n[BCs]\n  [no_slip_x]\n    type = DirichletBC\n    variable = ${vel_x}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [no_slip_y]\n    type = DirichletBC\n    variable = ${vel_y}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [no_slip_z]\n    type = DirichletBC\n    variable = ${vel_z}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [./lid_x]\n    type = DirichletBC\n    variable = ${vel_x}\n    boundary = 'top'\n    value = 1.\n  [../]\n  [./lid_y]\n    type = DirichletBC\n    variable = ${vel_y}\n    boundary = 'top'\n    value = 0.\n  [../]\n  [./lid_z]\n    type = DirichletBC\n    variable = ${vel_z}\n    boundary = 'top'\n    value = 0.\n  [../]\n\n  [./pressure_pin]\n    type = DirichletBC\n    variable = ${pressure}\n    boundary = 'pinned_node'\n    value = 0\n  [../]\n[]\n\n[Materials]\n  [./const]\n    type = GenericConstantMaterial\n    prop_names = 'rho      mu               '\n    prop_values = '1e4     ${const_num}     '\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  num_steps = 1\n  dt = ${const_dt}\n  petsc_options_iname = '-pc_type -sub_pc_factor_levels -ksp_gmres_restart'\n  petsc_options_value = 'lu       2                     200'\n  line_search = 'none'\n  nl_rel_tol = 1e-4\n  nl_abs_tol =  1e-7\n  nl_max_its = 60\n\n  automatic_scaling = true\n  verbose = true\n  off_diagonals_in_auto_scaling = true\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\n# [Debug]\n#   show_var_residual_norms = true\n# []\n\n\nThe AD and by hand codes in the Navier-stokes module have been checked by me. But I have not found the bugs' reason.\nThanks,\nQINGJI SU",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3541966",
                          "updatedAt": "2022-09-03T10:08:06Z",
                          "publishedAt": "2022-09-03T10:08:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "This hand-coded input version converges about as well as the AD version. The changes were\n\nscaling grouping for velocity variables (this happens naturally for the vector velocity variable used in AD)\nsetting preset = false which applies to the Dirichlet boundary conditions. Vector Dirichlet boundary conditions do not have the preset option, e.g. they are never preset, whereas preset = true is the default for non-vector Dirichlet boundary conditions\nsetting transient_term = true in the GlobalParams block. This adds the transient term into the strong residual used for SUPG and PSPG. This happens automatically for AD\n\nconst_num = 1.\nconst_dt = 1.e-1\n# const_scaling = 1e0\n\nvel_x = vel_x\nvel_y = vel_y\nvel_z = vel_z\npressure = p\n[GlobalParams]\n  pspg = true\n  supg = true\n  u = vel_x\n  v = vel_y\n  w = vel_z\n  pressure = p\n  integrate_p_by_parts = true\n  alpha = 1\n  transient_term = true\n  preset = false\n[]\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    xmin = 0\n    xmax = ${const_num}\n    ymin = 0\n    ymax = ${const_num}\n    zmin = 0\n    zmax = ${const_num}\n    nx = 10\n    ny = 10\n    nz = 10\n  []\n  [./corner_node]\n    type = ExtraNodesetGenerator\n    new_boundary = 'pinned_node'\n    nodes = '0'\n    input = gen\n  [../]\n[]\n\n[Variables]\n  [./vel_x]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./vel_y]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./vel_z]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./p]\n    # scaling = ${const_scaling}\n  [../]\n[]\n\n[Kernels]\n  [mass]\n    type = INSMass\n    variable = p\n  []\n  # x-momentum, time\n  [x_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_x}\n  []\n  # x-momentum, space\n  [x_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_x}\n    component = 0\n  []\n  # y-momentum, time\n  [y_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_y}\n  []\n  # y-momentum, space\n  [y_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_y}\n    component = 1\n  []\n  # z-momentum, time\n  [z_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_z}\n  []\n  # z-momentum, space\n  [z_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_z}\n    component = 2\n  []\n[]\n\n[BCs]\n  [no_slip_x]\n    type = DirichletBC\n    variable = ${vel_x}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [no_slip_y]\n    type = DirichletBC\n    variable = ${vel_y}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [no_slip_z]\n    type = DirichletBC\n    variable = ${vel_z}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [./lid_x]\n    type = DirichletBC\n    variable = ${vel_x}\n    boundary = 'top'\n    value = 1.\n  [../]\n  [./lid_y]\n    type = DirichletBC\n    variable = ${vel_y}\n    boundary = 'top'\n    value = 0.\n  [../]\n  [./lid_z]\n    type = DirichletBC\n    variable = ${vel_z}\n    boundary = 'top'\n    value = 0.\n  [../]\n\n  [./pressure_pin]\n    type = DirichletBC\n    variable = ${pressure}\n    boundary = 'pinned_node'\n    value = 0\n  [../]\n[]\n\n[Materials]\n  [./const]\n    type = GenericConstantMaterial\n    prop_names = 'rho      mu               '\n    prop_values = '1e4     ${const_num}     '\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  num_steps = 1\n  dt = ${const_dt}\n  petsc_options_iname = '-pc_type -sub_pc_factor_levels -ksp_gmres_restart'\n  petsc_options_value = 'lu       2                     200'\n  line_search = 'none'\n  nl_rel_tol = 1e-4\n  nl_abs_tol =  1e-7\n  nl_max_its = 60\n\n  automatic_scaling = true\n  verbose = true\n  off_diagonals_in_auto_scaling = true\n  scaling_group_variables = 'vel_x vel_y vel_z; p'\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\n# [Debug]\n#   show_var_residual_norms = true\n# []",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3577091",
                          "updatedAt": "2022-09-06T17:44:13Z",
                          "publishedAt": "2022-09-06T17:44:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If I remove the code of automatic_scaling = true, the problem could be solved. That is a strange phenomenon. Therefore I hardly use automatic_scaling = true. But I must admit that in some problems the problem convergence progress becomes better if I use automatic_scaling = true. So I am very tangled if I should use automatic_scaling = true.\n\nYea automatic scaling is not a silver bullet. Sometimes it is helpful and sometimes it's not. I would suggest always grouping like variables into the scaling computation, like I did in the input above with the scaling_group_variables parameter. If a problem does not solve well with automatic scaling and solve_type = NEWTON, then I would suggest running with -pc_type svd -pc_svd_monitor on a problem with 1000 dofs or less and see whether the problem is well-posed.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3577406",
                          "updatedAt": "2022-09-06T17:47:25Z",
                          "publishedAt": "2022-09-06T17:47:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "I got it, your answer is helpful to me. Thank you very much.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3583901",
                          "updatedAt": "2022-09-07T11:03:42Z",
                          "publishedAt": "2022-09-07T11:03:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "you're welcome! Thanks for your good questions!",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3585490",
                          "updatedAt": "2022-09-07T14:00:53Z",
                          "publishedAt": "2022-09-07T14:00:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "suqingji"
                  },
                  "bodyText": "Hi @lindsayad,\nPlease forgive me for bothering you again.\nI encountered a convergence problem when I simulated a flow problem.\nIf I use the INSAD to simulate:\n19 Nonlinear |R| = 8.042014e-16\n\n    |residual|_2 of individual variables:\n                   velocity: 6.55322e-16\n                   p:        4.66147e-16\n  Linear solve did not converge due to DIVERGED_NANORINF iterations 0\nNonlinear solve did not converge due to DIVERGED_LINEAR_SOLVE iterations 19\n\n Solve Did NOT Converge!\n\n  Finished Solving                                                                       [225.63 s] [   81 MB]\n\n\nAborting as solve did not converge\n\nFinished Executing\n\nIf I use INS to simulate:\n60 Nonlinear |R| = 8.810293e-16\n\n    |residual|_2 of individual variables:\n                      vel_x: 4.27504e-16\n                      vel_y: 4.32017e-16\n                      vel_z: 4.25759e-16\n                      p:     4.74914e-16\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 60\n\n Solve Did NOT Converge!\n\n  Finished Solving                                                                       [614.75 s] [   84 MB]\n\n\nAborting as solve did not converge\n\nFinished Executing\n\nIn fact, the output on the screen if I use INS is normal because of my nl_ral_tol , nl_abs_tol and nl_max_its setup. However, the output on the screen, if I use INSAD, is abnormal for Linear solve did not converge due to DIVERGED_NANORINF iterations 0.\nAs I know, the reason for DIVERGED_NANORINF is that divide by zero when the program solves the Linear equations. That means there are zeros on the diagonal of the matrix. But the same problem if I use the INS rather than INSAD the situations did not happen.\nSo I suspect that there are some bugs when the AD build the jacobian matrix.\nHere are my input files:\nINSAD:\n[Mesh]\n  [./gen]\n    type = FileMeshGenerator\n    file = dvi-exodus.exo\n  [../]\n  [inlet_left]\n    type = ParsedGenerateSideset\n    input = gen\n    combinatorial_geometry = 'abs(x + 1500) < 1e-4'\n    new_sideset_name = 'inlet_left'\n  []\n  [inlet_right]\n    type = ParsedGenerateSideset\n    input = inlet_left\n    combinatorial_geometry = 'abs(x - 1500) < 1e-4'\n    new_sideset_name = 'inlet_right'\n  []\n  [./scale]\n    type = TransformGenerator\n    input = inlet_right\n    transform = SCALE\n    vector_value ='1e-03 1e-03 1e-03'\n  []\n[]\n\n[Modules]\n  [IncompressibleNavierStokes]\n    equation_type = steady-state\n    \n    velocity_boundary = 'WALL-CORE WALL-DOWN WALL-DVI WALL-HEAT WALL-INLET WALL-NOHEAT WALL-UP inlet_left   inlet_right  INLET-DVI'\n    velocity_function = '0 0 0     0 0 0     0 0 0    0 0 0     0 0 0      0 0 0       0 0 0   1 0 0        -1 0 0       4.09 0 -2.87'\n    \n    initial_velocity = '1e-15 1e-15 1'\n    add_standard_velocity_variables_for_ad = false\n\n    density_name = rho\n    dynamic_viscosity_name = mu\n\n    use_ad = true\n    laplace = true\n    family = LAGRANGE\n    order = FIRST\n\n    add_temperature_equation = false\n\n    alpha = 1\n    supg = true\n    pspg = true\n  []\n[]\n\n[BCs]\n  [./outlet]\n    type = DirichletBC\n    variable = p\n    boundary = 'OUTLET'\n    value = 0\n  [../]\n[]\n[Debug]\n   show_var_residual_norms = true\n[]\n\n[Materials]\n  [./user_defined]\n    type = ADGenericConstantMaterial\n    block = FLUID\n    prop_names = 'rho mu cp k'\n    prop_values = '1 1e-02 4.179e3 0.58 '\n  [../]\n[]\n[Executioner]\n  type = Steady\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type -sub_pc_type -ksp_gmres_restart'\n  petsc_options_value = 'bjacobi  asm          200'\n  line_search = 'none'\n  nl_rel_tol = 1e-20\n  nl_max_its = 60\n[]\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\nINS:\n[Mesh]\n  [./gen]\n    type = FileMeshGenerator\n    file = dvi-exodus.exo\n  [../]\n  [inlet_left]\n    type = ParsedGenerateSideset\n    input = gen\n    combinatorial_geometry = 'abs(x + 1500) < 1e-4'\n    new_sideset_name = 'inlet_left'\n  []\n  [inlet_right]\n    type = ParsedGenerateSideset\n    input = inlet_left\n    combinatorial_geometry = 'abs(x - 1500) < 1e-4'\n    new_sideset_name = 'inlet_right'\n  []\n  [./scale]\n    type = TransformGenerator\n    input = inlet_right\n    transform = SCALE\n    vector_value ='1e-03 1e-03 1e-03'\n  []\n[]\n[Variables]\n  [./vel_x]\n    [./InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    [../]\n  [../]\n  [./vel_y]\n    [./InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    [../]\n  [../]\n  [./vel_z]\n    [./InitialCondition]\n      type = ConstantIC\n      value = 1\n    [../]\n  [../]\n  [./p]\n  [../]\n[]\n[Kernels]\n  # mass\n  [./mass]\n    type = INSMass\n    variable = p\n    u = vel_x\n    v = vel_y\n    w = vel_z\n    pressure = p\n  [../]\n  # x-momentum, space\n  [./x_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    w = vel_z\n    pressure = p\n    component = 0\n  [../]\n  # y-momentum, space\n  [./y_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    w = vel_z\n    pressure = p\n    component = 1\n  [../]\n  # z-momentum, space\n  [./z_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = vel_z\n    u = vel_x\n    v = vel_y\n    w = vel_z\n    pressure = p\n    component = 2\n  [../]\n[]\n\n[BCs]\n  [./x_no_slip]\n    type = DirichletBC\n    variable = vel_x\n    boundary = 'WALL-CORE WALL-DOWN WALL-DVI WALL-HEAT WALL-INLET WALL-NOHEAT WALL-UP'\n    value = 0.0\n  [../]\n  [./y_no_slip]\n    type = DirichletBC\n    variable = vel_y\n    boundary = 'WALL-CORE WALL-DOWN WALL-DVI WALL-HEAT WALL-INLET WALL-NOHEAT WALL-UP'\n    value = 0.0\n  [../]\n  [./z_no_slip]\n    type = DirichletBC\n    variable = vel_z\n    boundary = 'WALL-CORE WALL-DOWN WALL-DVI WALL-HEAT WALL-INLET WALL-NOHEAT WALL-UP'\n    value = 0.0\n  [../]\n\n  [./x_in_left]\n    type = DirichletBC\n    variable = vel_x\n    boundary = 'inlet_left'\n    value = 1\n  [../]\n  [./y_in_left]\n    type = DirichletBC\n    variable = vel_y\n    boundary = 'inlet_left'\n    value = 0.0\n  [../]\n  [./z_in_left]\n    type = DirichletBC\n    variable = vel_z\n    boundary = 'inlet_left'\n    value = 0.0\n  [../]\n  \n  [./x_in_right]\n    type = DirichletBC\n    variable = vel_x\n    boundary = 'inlet_right'\n    value = -1\n  [../]\n  [./y_in_right]\n    type = DirichletBC\n    variable = vel_y\n    boundary = 'inlet_right'\n    value = 0.0\n  [../]\n  [./z_in_right]\n    type = DirichletBC\n    variable = vel_z\n    boundary = 'inlet_right'\n    value = 0.0\n  [../]\n  \n  [./x_in_dvi]\n    type = DirichletBC\n    variable = vel_x\n    boundary = 'INLET-DVI'\n    value = 4.09\n  [../]\n  [./y_in_dvi]\n    type = DirichletBC\n    variable = vel_y\n    boundary = 'INLET-DVI'\n    value = 0.0\n  [../]\n  [./z_in_dvi]\n    type = DirichletBC\n    variable = vel_z\n    boundary = 'INLET-DVI'\n    value = -2.87\n  [../]\n  \n  [./outlet]\n    type = DirichletBC\n    variable = p\n    boundary = 'OUTLET'\n    value = 0\n  [../]\n[]\n[Debug]\n   show_var_residual_norms = true\n[]\n\n[Materials]\n  [./user_defined]\n    type = GenericConstantMaterial\n    block = FLUID\n    prop_names = 'rho mu cp k'\n    prop_values = '1 1e-02 4.179e3 0.58 '\n  [../]\n[]\n[GlobalParams]\n  gravity = '0 0 0'\n  supg = true\n  pspg = true\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type -sub_pc_type -ksp_gmres_restart'\n  petsc_options_value = 'bjacobi  asm          200'\n  line_search = 'none'\n  nl_rel_tol = 1e-20\n  nl_max_its = 60\n[]\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\nThanks and best wishes.",
                  "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3877143",
                  "updatedAt": "2022-10-14T08:50:19Z",
                  "publishedAt": "2022-10-14T08:44:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You've reached residuals around 1e-16. This is very converged. You need to relax the convergence criteria to accept the solution.\nnl_rel_tol of 1e-20 is incredibly tight.\nWe cannot converge solutions down to infinitely small residuals. There are floating point precision issues at these levels.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3878923",
                          "updatedAt": "2022-10-14T12:54:30Z",
                          "publishedAt": "2022-10-14T12:54:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Hi, @GiudGiud\nIn this question, I deliberately set the residuals so small to find this problem. As I mentioned above, INS did not encounter the problem. Only in INSAD, the problem can be found.\nIn fact, if the problem diverged for the res_abs_tol set too small, the information on the screen should be DIVERGED_MAX_IT rather than DIVERGED_NANORINF.\nSo in order to prove the AD bug, I add some to the input file as:\n[Preconditioning]\n  [./fdp]\n    type = FDP\n    full = true\n  [../]\n[]\n\nIn a way, the jacobian matrix is built by FDP, So in a way, the jacobian matrix is completely accurate. As I had expected the screen show me DIVERGED_MAX_IT rather than DIVERGED_NANORINF\nAll in all, So I suspect that there are some bugs when the AD builds the jacobian matrix.\nTo say the least, it would not matter if the problem happen in rel so small. But unfortunately, There is the same problem in some situations when rel is not so small.\nIt's a really strange question, and I expect you don't quite believe it exists.\nThanks and best wishes.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879443",
                          "updatedAt": "2022-10-14T13:51:41Z",
                          "publishedAt": "2022-10-14T13:51:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Using AD the Jacobian is naturally correct you do not need to use FDP.\nYour preconditioner is on the weaker side. You could using a different one to see if that fixes the problem",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879474",
                          "updatedAt": "2022-10-14T13:55:42Z",
                          "publishedAt": "2022-10-14T13:55:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh do you mean you switched INSAD to FDP and then the problem went away?",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879476",
                          "updatedAt": "2022-10-14T13:56:22Z",
                          "publishedAt": "2022-10-14T13:56:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so an INF is not necessarily a bug. You do not have guaranteed convergence with this pre-conditionner.\na Nan would be more concerning. To find those, you will want to compile in devel mode (METHOD=devel make) then run with --trap-fpe on the command line",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879512",
                          "updatedAt": "2022-10-14T14:00:49Z",
                          "publishedAt": "2022-10-14T14:00:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "I must say yes.\nI set INS or INSAD with FDP, the problem is normal absolutely. Only when I set INSAD without FDP and set solve_type = 'NEWTON', does the screen show me DIVERGED_NANORINF.\nSo please believe my suspece.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879517",
                          "updatedAt": "2022-10-14T14:01:33Z",
                          "publishedAt": "2022-10-14T14:01:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "DIVERGED_NANORINF is not a problem. DIVERGED_NANORINF is just a facade. The problem is why show DIVERGED_NANORINF. As I know, the reason for DIVERGED_NANORINF is that divided by zero when the program solves the Linear equations. That means there are zeros on the diagonal of the matrix.\nSo It is the only reason appearing zeros on the diagonal of the matrix.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879562",
                          "updatedAt": "2022-10-14T14:06:03Z",
                          "publishedAt": "2022-10-14T14:06:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So there's a PETSc option to print the matrix you may use to check that.\n-ksp_view_mat\nThe alternative is to use the tagging interface to print contributions to the jacobian of each kernel. See moose/test/tests/tag for examples.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879861",
                          "updatedAt": "2022-10-14T14:38:04Z",
                          "publishedAt": "2022-10-14T14:38:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "ok, thanks for your help",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879911",
                          "updatedAt": "2022-10-14T14:42:56Z",
                          "publishedAt": "2022-10-14T14:42:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Yea this DIVERGED reason investigation is not how I would go about diagnosing a bad Jacobian at all. On a well scaled problem with < 1000 dofs or so you should run -snes_test_jacobian. On a really small problem you can run with -snes_test_jacobian -snes_test_jacobian_view to see the differences between the user and finite difference Jacobian. Note that this needs to be performed on a well scaled problem because the finite difference Jacobian is susceptible to floating point errors",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3880600",
                          "updatedAt": "2022-10-14T16:09:55Z",
                          "publishedAt": "2022-10-14T16:04:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "suqingji"
                  },
                  "bodyText": "Hi @lindsayad\nPlease forgive me for bothering you again.\nWhen I debugged I found a problem in MOOSE. Now please admit me introduce the problem to you.\nFirstly, let us consider a transient heat conduction problem. Here is the PDE of the heat conduction problem.\n\nIf we consider the problem as one dimension. Set the params as:\nkappa = 0.59\nrho = 1000\ncp = 4.2e3\nLx = 1\ndx = 0.01\nnx = 100\ndt = 10\nAnd Set boundary conditions as:\nT_left = 1\nT_right = 0\nNow, let us create an input file. Here are the details of the input file.\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 1\n    nx = 100\n  []\n[]\n\n[Variables]\n  [./T]\n  [../]\n[]\n\n[Kernels]\n  [./heat]\n    type = ADHeatConduction\n    variable = T\n  [../]\n  [./heat_ie]\n    type = ADHeatConductionTimeDerivative\n    variable = T\n  [../]\n[]\n\n[Materials]\n  [./const]\n    type = ADGenericConstantMaterial\n    prop_names = 'density   specific_heat     thermal_conductivity'\n    prop_values = '1000     4.2e3             0.59'\n  [../]\n[]\n\n[BCs]\n [./left]\n   type = DirichletBC\n   variable = T\n   boundary = left\n   value = 1\n [../]\n [./right]\n   type = DirichletBC\n   variable = T\n   boundary = right\n   value = 0\n [../]\n[]\n[Preconditioning]\n  [./fdp]\n    type = FDP\n    full = true\n  [../]\n[]\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n\n  dt = 10\n  end_time = 10\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nThe solution is shown here:\n\nObviously, there are some values that are bigger than 1 and smaller than 0.\nIn fact, this is an abnormal phenomenon.\nSecondly, let me prove my comment.\nI write a program for the question through the libMesh which also is the MOOSE's underlying framework.\nThis is the plot calculated by libMesh:\n\nAt last, I use python to write a program for the question through the finite difference method\nThis is the plot calculated by FDM with Python:\n\nSo, I suspect that there are some bugs in the Time Derivative part in MOOSE.\nThanks.",
                  "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4128789",
                  "updatedAt": "2022-11-13T15:33:50Z",
                  "publishedAt": "2022-11-13T15:33:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This looks like a really steep gradient to develop.\nhave you tried smaller time steps and a finer mesh?",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4129192",
                          "updatedAt": "2022-11-13T16:59:39Z",
                          "publishedAt": "2022-11-13T16:59:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Yes, this is a really steep gradient problem. But this is a transient diffusion problem without convection. In theory, generally, there is no oscillation problem in the diffusion problem.\nSo that finer mesh is not first choose. And if I tried smaller time steps the oscillation will be more serious in MOOSE. But if I use FDM FVM or FEM by libMesh, there is not oscillation problem.\nSo that I suspect that there are some bugs in the Time Derivative part in MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4131478",
                          "updatedAt": "2022-11-14T03:22:15Z",
                          "publishedAt": "2022-11-14T03:22:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "You initial condition is zero (the default), which does not satisfy your boundary condition. Not sure whether it will cause issue for the solution at infinity.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4137552",
                          "updatedAt": "2022-11-14T14:56:11Z",
                          "publishedAt": "2022-11-14T14:56:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Your time step size is way too small. You can see @hugary1995's answer at #22528 (reply in thread). Your characteristic time considering your element size is ~700 seconds but you are taking a time step that is 70 times smaller than that. You are bound to create boundary shocks under those conditions. So I would certainly not conclude that there is a bug in TimeDerivative. If you want to share your libMesh code, then I'd be happy to explore why you're getting fortuitious behavior there",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4139405",
                          "updatedAt": "2022-11-14T17:53:23Z",
                          "publishedAt": "2022-11-14T17:53:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Hi, Thanks for your reply. @YaqiWang @lindsayad @GiudGiud\nI got the reason why the 'abnormal' phenomenon come.\nBecause CG FEM in the transient diffusion problem is not a positive preserve scheme.\nThe root reason is that when dealing with transient terms, there are some values that will contribute to off-diagonal. That will cause the matrix not to meet the positive preserve conditions. This is a special problem which is only come in FEM.\nBut if we use FDM or FVM, the problem will not come.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4143003",
                          "updatedAt": "2022-11-15T10:44:59Z",
                          "publishedAt": "2022-11-15T05:16:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "While that's theoretically true, the result you showed is simply a manifestation of some poor choices made in your model definition. The consequence will appear in different forms in FEM, FDM, and FVM.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4145590",
                          "updatedAt": "2022-11-15T11:34:55Z",
                          "publishedAt": "2022-11-15T11:34:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Hi, @hugary1995\nThanks for your reply.\nIn this question, the problem maybe is not important because we can use finer mesh or select a bigger time stepper. But the problem similar to other problems is very important, especially in some temperature shock problems.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4146037",
                          "updatedAt": "2022-11-15T12:34:54Z",
                          "publishedAt": "2022-11-15T12:34:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay, good to know.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4146086",
                          "updatedAt": "2022-11-15T12:41:09Z",
                          "publishedAt": "2022-11-15T12:41:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Hi, @lindsayad, @GiudGiud, @YaqiWang\nAs I mentioned above, in the transient diffusion problem there is an oscillation problem. This is caused by CG FEM's non-local conservation.\nFortunately, there is a method that can be used to solve the problem. The method is lumping the transient term. I also found that in the PorousFlow module there is a class that has implemented the lumped transient term. Here is the detail page.\nBut unfortunately, in the Navier-Stokes module, if I want to couple a variable using some codes such as &adCoupledDot(\"temperature\"), there is no lumped coupled method. I try to add the method to Base Class, but I failed.\nWould you like to add the method to the class Coupleable.\nThanks. Best wishes.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4436378",
                          "updatedAt": "2022-12-17T06:48:29Z",
                          "publishedAt": "2022-12-17T06:48:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nWhich method are you missing in Coupleable? adCoupledDot does exist\nThe massLumpedTimeDerivative would likely only be added to NS if useful, coupleable is a very general framework-wide class\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4437221",
                          "updatedAt": "2022-12-17T11:30:16Z",
                          "publishedAt": "2022-12-17T11:30:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Random values based on space and time",
          "author": {
            "login": "batodon"
          },
          "bodyText": "Hello,\nIs there a function in moose to generate a random value as a function of space and time (i.e., [_qp] and _dt)? In other words, the function will take the arguments of space and time. I tried using the c++ rand() function, but it only gives a random value between two extreme values. Is there any moose example having such a function? Any help is deeply appreciated. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/22971",
          "updatedAt": "2022-12-17T22:46:10Z",
          "publishedAt": "2022-12-15T18:08:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "You ll want to have a look at the random interface\nhttps://mooseframework.inl.gov/source/interfaces/RandomInterface.html\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classRandomInterface.html",
                  "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4412427",
                  "updatedAt": "2022-12-15T18:12:12Z",
                  "publishedAt": "2022-12-15T18:12:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the randomIC is an example using it",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4412432",
                          "updatedAt": "2022-12-15T18:12:29Z",
                          "publishedAt": "2022-12-15T18:12:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hi @GiudGiud. Thanks for the suggestion. I took a look at the RandomInterface class. It seems the getRandomReal() or getRandomLong() functions generate the same random numbers for \u2018all\u2019 elements within the domain at a \u2018snapshot.\u2019 I mean, all the elements within the domain will have the same random numbers at a snapshot. What I\u2019m looking for, though, is a function that generates different random numbers for all the different elements at a snapshot (or single step). That is, element 1 should have a random value different from element 2 at a single step. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4413253",
                          "updatedAt": "2022-12-15T20:10:56Z",
                          "publishedAt": "2022-12-15T20:10:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it should not be like that. have a look at RandomIC, it s spatially random",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4413281",
                          "updatedAt": "2022-12-15T20:13:41Z",
                          "publishedAt": "2022-12-15T20:13:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Gotcha! Thanks, a lot @GiudGiud.",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4413428",
                          "updatedAt": "2022-12-15T20:43:28Z",
                          "publishedAt": "2022-12-15T20:43:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hello @GiudGiud\nI had to re-open this ticket since I did not achieve success with my simulation. Maybe, I did not properly communicate my objective for using the random values. What I really want to achieve is to rotate each element using a unique random angle of rotation for that element. I had previously rotated my model using a single rotation angle for all elements. However, I find it challenging to do the same thing using different rotation angles for all elements simultaneously. Yes, the RandomIC generates spatially varied field data for a given variable, but I wonder how I can apply this to my objective. The following code shows how I\u2019m using the RandomInterface class, but this approach only generates a single random rotation angle at a time. I believe this is incorrect, considering my objective. Please, do you have any suggestions on how to approach this problem? Thanks.\n// Whether to use spatially random angle of rotation at each timestep or a fixed angle of rotation.\n    Real  _randm_rad_xy;\n    Real  _randm_rad_yz;\n      if (_distribution)\n        {\n          _randm_rad_xy = _distribution->quantile(getRandomReal());\n          _randm_rad_yz = _distribution->quantile(getRandomReal());\n        }\n      else\n          {\n            _randm_rad_xy = getRandomReal() * (_max - _min) + _min;\n            _randm_rad_yz = getRandomReal() * (_max - _min) + _min;\n          }\n\n      Real  _rad_xy;\n      Real  _rad_yz;\n          if (_Random_field)\n        // Get the spatially random rotation angle (in radians) for each element at each timestep.\n          {\n            _rad_xy = _randm_rad_xy;\n            _rad_yz = _randm_rad_yz;\n          }\n          else\n        // Get the fixed (or user-specified) rotation angle for all elements in the domain at each timestep.\n          {\n          _rad_xy = _fix_rad_xy;\n          _rad_yz = _fix_rad_yz;\n          }",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4424770",
                          "updatedAt": "2022-12-16T16:45:42Z",
                          "publishedAt": "2022-12-16T16:42:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nI did not mean for you to use the RandomIC, sorry for the misunderstanding.\nI meant for you to look at the code in the RandomIC to extract the appropriate API calls from the randomInterface()\nIt uses\n    return generateRandom() * (_max - _min) + _min;\n\nThis generateRandom() is different at every quadrature point. I think it should be different every time you call it, so it can be different in time, in space etc.\nDoes this work for you?",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4434234",
                          "updatedAt": "2022-12-17T03:21:55Z",
                          "publishedAt": "2022-12-17T03:21:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hi @GiudGiud. Yeah, I got a bit confused. I'll work around it and let you know shortly. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4438301",
                          "updatedAt": "2022-12-17T16:26:48Z",
                          "publishedAt": "2022-12-17T16:26:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "I fixed it! It compiles, beautifully...",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4439027",
                          "updatedAt": "2022-12-17T19:40:39Z",
                          "publishedAt": "2022-12-17T19:40:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Test errors",
          "author": {
            "login": "felixcrazzolara"
          },
          "bodyText": "I tried to build Moose on an Ubuntu 20.04 distribution and exactly followed the install instructions. All steps went smoothly without errors, except for the following tests failing:\nmisc/hit_cli.find/parameter_exists ........................................................... FAILED (CODE 1)\nmisc/hit_cli.find/parameter_does_not_exist ................................................... FAILED (CODE 1)\nmisc/hit_cli.find/positive_pattern ........................................................... FAILED (CODE 1)\nmisc/hit_cli.find/negative_pattern ........................................................... FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern ......................................................... FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern_negative ................................................ FAILED (CODE 1)\nmisc/hit_cli.merge ........................................................................... FAILED (CODE 1)\nmisc/hit_cli.diff/vanilla .................................................................... FAILED (CODE 1)\nmisc/hit_cli.diff/color ...................................................................... FAILED (CODE 1)\nmisc/hit_cli.diff/verbose .................................................................... FAILED (CODE 1)\nmisc/hit_cli.diff/verbose_color .............................................................. FAILED (CODE 1)\nmisc/hit_cli.diff/common ..................................................................... FAILED (CODE 1)\n\nAny ideas on how to solve this? Is this even relevant?",
          "url": "https://github.com/idaholab/moose/discussions/22760",
          "updatedAt": "2023-01-03T23:19:26Z",
          "publishedAt": "2022-11-19T14:44:13Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis could be. Could you please paste the failure log for each test?\nYou may regenerate it quicker with\n./run_tests --failed-tests\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22760#discussioncomment-4184454",
                  "updatedAt": "2022-11-19T14:54:01Z",
                  "publishedAt": "2022-11-19T14:54:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "felixcrazzolara"
                          },
                          "bodyText": "Hello Guillaume\nThank you for your fast response. This is the output of './run_tests --failed-tests':\nmisc/hit_cli.find/parameter_exists: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/parameter_exists: Running command: ./hit_wrapper.py gold/parameter_exists find Kernels/\\*/variable input1.i input2.i\nmisc/hit_cli.find/parameter_exists: Failed to locate hit executable.\nmisc/hit_cli.find/parameter_exists: \nmisc/hit_cli.find/parameter_exists: ################################################################################\nmisc/hit_cli.find/parameter_exists: Tester failed, reason: CODE 1\nmisc/hit_cli.find/parameter_exists: \nmisc/hit_cli.find/parameter_exists ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/parameter_does_not_exist: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/parameter_does_not_exist: Running command: ./hit_wrapper.py gold/parameter_does_not_exist find -v Kernels/\\*/variable input1.i input2.i\nmisc/hit_cli.find/parameter_does_not_exist: Failed to locate hit executable.\nmisc/hit_cli.find/parameter_does_not_exist: \nmisc/hit_cli.find/parameter_does_not_exist: ################################################################################\nmisc/hit_cli.find/parameter_does_not_exist: Tester failed, reason: CODE 1\nmisc/hit_cli.find/parameter_does_not_exist: \nmisc/hit_cli.find/parameter_does_not_exist ........................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/positive_pattern: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/positive_pattern: Running command: ./hit_wrapper.py gold/positive_pattern find Kernels/\\*/variable=u input1.i\nmisc/hit_cli.find/positive_pattern: Failed to locate hit executable.\nmisc/hit_cli.find/positive_pattern: \nmisc/hit_cli.find/positive_pattern: ################################################################################\nmisc/hit_cli.find/positive_pattern: Tester failed, reason: CODE 1\nmisc/hit_cli.find/positive_pattern: \nmisc/hit_cli.find/positive_pattern ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/negative_pattern: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/negative_pattern: Running command: ./hit_wrapper.py gold/positive_pattern find Kernels/\\*/variable!=v input1.i\nmisc/hit_cli.find/negative_pattern: Failed to locate hit executable.\nmisc/hit_cli.find/negative_pattern: \nmisc/hit_cli.find/negative_pattern: ################################################################################\nmisc/hit_cli.find/negative_pattern: Tester failed, reason: CODE 1\nmisc/hit_cli.find/negative_pattern: \nmisc/hit_cli.find/negative_pattern ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/additional_pattern: Running command: ./hit_wrapper.py gold/additional_pattern find -p type=DirichletBC -- \\*/value input1.i input2.i\nmisc/hit_cli.find/additional_pattern: Failed to locate hit executable.\nmisc/hit_cli.find/additional_pattern: \nmisc/hit_cli.find/additional_pattern: ################################################################################\nmisc/hit_cli.find/additional_pattern: Tester failed, reason: CODE 1\nmisc/hit_cli.find/additional_pattern: \nmisc/hit_cli.find/additional_pattern .............................. [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern_negative: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/additional_pattern_negative: Running command: ./hit_wrapper.py gold/additional_pattern_negative find -p type!=DirichletBC -- \\*/value input1.i input2.i\nmisc/hit_cli.find/additional_pattern_negative: Failed to locate hit executable.\nmisc/hit_cli.find/additional_pattern_negative: \nmisc/hit_cli.find/additional_pattern_negative: ################################################################################\nmisc/hit_cli.find/additional_pattern_negative: Tester failed, reason: CODE 1\nmisc/hit_cli.find/additional_pattern_negative: \nmisc/hit_cli.find/additional_pattern_negative ..................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.merge: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.merge: Running command: ./hit_wrapper.py gold/merge merge -output - input1.i input2.i\nmisc/hit_cli.merge: Failed to locate hit executable.\nmisc/hit_cli.merge: \nmisc/hit_cli.merge: ################################################################################\nmisc/hit_cli.merge: Tester failed, reason: CODE 1\nmisc/hit_cli.merge: \nmisc/hit_cli.merge ................................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/vanilla: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.diff/vanilla: Running command: ./hit_wrapper.py gold/diff_vanilla diff input1.i input2.i\nmisc/hit_cli.diff/vanilla: Failed to locate hit executable.\nmisc/hit_cli.diff/vanilla: \nmisc/hit_cli.diff/vanilla: ################################################################################\nmisc/hit_cli.diff/vanilla: Tester failed, reason: CODE 1\nmisc/hit_cli.diff/vanilla: \nmisc/hit_cli.diff/vanilla ......................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/color: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.diff/color: Running command: ./hit_wrapper.py gold/diff_color diff -color input1.i input2.i\nmisc/hit_cli.diff/color: Failed to locate hit executable.\nmisc/hit_cli.diff/color: \nmisc/hit_cli.diff/color: ################################################################################\nmisc/hit_cli.diff/color: Tester failed, reason: CODE 1\nmisc/hit_cli.diff/color: \nmisc/hit_cli.diff/color ........................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/verbose: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.diff/verbose: Running command: ./hit_wrapper.py gold/diff_verbose diff -v input1.i input2.i\nmisc/hit_cli.diff/verbose: Failed to locate hit executable.\nmisc/hit_cli.diff/verbose: \nmisc/hit_cli.diff/verbose: ################################################################################\nmisc/hit_cli.diff/verbose: Tester failed, reason: CODE 1\nmisc/hit_cli.diff/verbose: \nmisc/hit_cli.diff/verbose ......................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/verbose_color: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.diff/verbose_color: Running command: ./hit_wrapper.py gold/diff_verbose_color diff -v -color input1.i input2.i\nmisc/hit_cli.diff/verbose_color: Failed to locate hit executable.\nmisc/hit_cli.diff/verbose_color: \nmisc/hit_cli.diff/verbose_color: ################################################################################\nmisc/hit_cli.diff/verbose_color: Tester failed, reason: CODE 1\nmisc/hit_cli.diff/verbose_color: \nmisc/hit_cli.diff/verbose_color ................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/common: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.diff/common: Running command: ./hit_wrapper.py gold/diff_common diff -common input1.i input2.i\nmisc/hit_cli.diff/common: Failed to locate hit executable.\nmisc/hit_cli.diff/common: \nmisc/hit_cli.diff/common: ################################################################################\nmisc/hit_cli.diff/common: Tester failed, reason: CODE 1\nmisc/hit_cli.diff/common: \nmisc/hit_cli.diff/common .......................................... [previous results: CODE 1] FAILED (CODE 1)\n\n\nFinal Test Results:\n--------------------------------------------------------------------------------------------------------------\nmisc/hit_cli.find/parameter_exists ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/parameter_does_not_exist ........................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/positive_pattern ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/negative_pattern ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern .............................. [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern_negative ..................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.merge ................................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/vanilla ......................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/color ........................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/verbose ......................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/verbose_color ................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/common .......................................... [previous results: CODE 1] FAILED (CODE 1)\n--------------------------------------------------------------------------------------------------------------\nRan 12 tests in 2.8 seconds. Average test time 0.0 seconds, maximum test time 0.0 seconds.\n0 passed, 0 skipped, 0 pending, 12 FAILED",
                          "url": "https://github.com/idaholab/moose/discussions/22760#discussioncomment-4187651",
                          "updatedAt": "2022-11-20T10:09:45Z",
                          "publishedAt": "2022-11-20T10:09:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It seems the hit (input file parser) executable did not build.\nYou can try to rebuild moose, see if it builds it this time\nYou can also build it directly in moose/framework/contrib/hit",
                          "url": "https://github.com/idaholab/moose/discussions/22760#discussioncomment-4189057",
                          "updatedAt": "2022-11-20T16:06:53Z",
                          "publishedAt": "2022-11-20T16:06:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Maohua10"
                          },
                          "bodyText": "Hi Guillaume, I also had some failed tests, although most of the test succeeded...\nDo you maybe what can be wrong? Thank you in advance!",
                          "url": "https://github.com/idaholab/moose/discussions/22760#discussioncomment-4437914",
                          "updatedAt": "2022-12-17T14:45:08Z",
                          "publishedAt": "2022-12-17T14:45:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "These are consistent with issues with the hit parser. Can you paste the log for the tests instead of the summary please",
                          "url": "https://github.com/idaholab/moose/discussions/22760#discussioncomment-4438114",
                          "updatedAt": "2022-12-17T15:38:39Z",
                          "publishedAt": "2022-12-17T15:38:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to define the grain boundary area between grains",
          "author": {
            "login": "Nuwanted"
          },
          "bodyText": "Dear MOOSE experts,\nRecently, I wanted to simulate the evolution of the void in the polycrystalline material, and different nonconservative order parameters are used to represent different grains. When I use the block function to distinguish different grains and give them different surface mobility, void cannot evolve. Why? Is it because the grain boundary area is not defined?\nAny suggestions or recommendations to fix the problem would be greatly appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/22870",
          "updatedAt": "2023-01-03T23:59:18Z",
          "publishedAt": "2022-12-05T12:33:25Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@permcody",
                  "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4312906",
                  "updatedAt": "2022-12-05T12:46:27Z",
                  "publishedAt": "2022-12-05T12:46:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "Bumping @permcody again.",
                          "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4361613",
                          "updatedAt": "2022-12-10T07:11:36Z",
                          "publishedAt": "2022-12-10T07:11:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "I'm not sure I understand exactly what you are doing here. Are you starting from some of our polycrystal examples or tests? We have a robust capability that allows you to identify each grain separately so that you can apply different attributes to each grain, which affect the Cahn-Hillard equations, which in turn impact your grain evolution. Normally in phase-field, we don't directly define the grain boundary area. Those quantities are calculated as by-product of solving the phase-field equations. We have a VectorPostprocessor that can inspect your converged solution and can calculate those quantities. I recommend you take a look at the examples here: https://github.com/idaholab/moose/tree/next/modules/phase_field/examples\nand perhaps the integration tests as well: https://github.com/idaholab/moose/tree/next/modules/phase_field/test/tests",
                  "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4402802",
                  "updatedAt": "2022-12-14T18:13:46Z",
                  "publishedAt": "2022-12-14T18:13:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Nuwanted"
                          },
                          "bodyText": "Thank you for your reply, I mean that I use two nonconservative variables eta1 and eta2 to represent two different grains. The internal variable value of the grain is 1, the external variable value is 0, and the grain boundary changes from 1 to 0. I want to distinguish different grains by variable values. Some of my code is as follows:\nInputParameters\nANisotropicForth::validParams()\n{\nParams.addRequiredCoupledVar(\"nop1\", \"nonconservtion Order parameter 1 \");\nParams.addRequiredCoupledVar(\"nop2\", \"nonconservtion Order parameter 2 \");\nreturn Params;\nreturn Params;\n}\nANisotropicForth::ANisotropicForth(const InputParameters & Parameters)\n: Material(Parameters),\n// Get the parameters from the input file\n_nop1(coupledValue(\"nop1\")),\n_nop2(coupledValue(\"nop2\"))\nif (0 < _nop1 < 1 & _nop2 = 0 & _nop1 = 0)\n{\n// Calculate  function of mobility\n\t_fun[_qp] = ((_delta1 * std::pow(cos(_j1 * (angle + _theta0 * libMesh::pi / 180)), 2.0) + 1.0) / (1.0 + _delta1));\n\nNop1 and nop2 represent eta1 and eta2 respectively. When I compile, Moose prompts me that nop does not match the<symbol. Why?",
                          "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4410170",
                          "updatedAt": "2022-12-15T13:26:36Z",
                          "publishedAt": "2022-12-15T13:26:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I've never written 0 < _nop1 < 1 in C++. Is that allowed?\nThis is definitely problematic:\nif (..... _nop2 = 0)\nit should be ==\nBut it does not make sense to check if nop1 is between 0 and 1, excluding 0, and at the same time nop1 =0 . These are mutually exclusive",
                          "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4410771",
                          "updatedAt": "2022-12-15T14:43:13Z",
                          "publishedAt": "2022-12-15T14:42:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "0 < _nop1 < 1 is an expression, but definitely not the one you want for any language. Your compiler should be screaming at you. Please fix your logic and see if that fixes your issue. You need to split that expression into two expressions. Also \"&\" should be \"&&\". I count no fewer than 6 bugs in that one line of code!",
                          "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4411950",
                          "updatedAt": "2022-12-15T17:02:26Z",
                          "publishedAt": "2022-12-15T17:02:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Nuwanted"
                          },
                          "bodyText": "Sorry, I am not familiar with the writing of C language, I will carefully modify my code, thank you very much for your reply.",
                          "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4437303",
                          "updatedAt": "2022-12-17T11:54:37Z",
                          "publishedAt": "2022-12-17T11:54:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Printout of Jacobian/Residual",
          "author": {
            "login": "joe61vette"
          },
          "bodyText": "I am trying to debug an app.  The contributions to the residuals from my kernels appear to be correct.  I am using AD to form the jacobian.  I did run  analyzejacobian and got \"No errors detected.  :-)\".  [of course, thanks to the AD system]\nBut something must not be quite right as I don't get the same results as for a hand calculation. I have seen a Moose developer show a printout of the jacobian for a small test problem (see below).  How can I do this?\n  SVD: condition number 2.441843322518e+11, 0 of 9 singular values are (nearly) zero\n  SVD: singular values:\n         1.501529298631e+06   1.038973912264e+06   3.701408259763e+05   4.668696900287e+01   1.192502051978e+01  \n         2.869699441978e+00   8.516552976210e-06   7.377570511006e-06   6.149163153854e-06  \n  0 Linear |R| = 2.824152e-04\n  1 Linear |R| = 4.153350e-13\n\nMat Object: () 1 MPI process\ntype: seqaij\nrow 0: (0, 583.966)  (1, 0.000186027)  (2, 0.000510781)  (3, -581.157)  (4, -0.000186357)  (5, 0.499837)\nrow 1: (0, 4221.37)  (1, 0.00139813)  (2, 0.0180354)  (3, -4224.11)  (4, -0.00135452)  (5, 3.63304)\nrow 2: (0, -833398.)  (1, -0.267009)  (2, 1437.37)  (3, 832664.)  (4, 0.267006)  (5, -716.151)\nrow 3: (0, -581.162)  (1, -0.000186357)  (2, -0.500163)  (3, 1165.65)  (4, 0.000372714)  (5, 0.00032579)  (6, -581.154)  (7, -0.000186357)  (8, 0.499837)\nrow 4: (0, -4233.51)  (1, -0.00136985)  (2, -3.64972)  (3, 8457.57)  (4, 0.00275771)  (5, 0.0166714)  (6, -4224.07)  (7, -0.00135452)  (8, 3.63302)\nrow 5: (0, -833558.)  (1, -0.26775)  (2, -717.614)  (3, 883.188)  (4, 0.000743158)  (5, 1437.09)  (6, 832654.)  (7, 0.267005)  (8, -716.147)\nrow 6: (3, -581.157)  (4, -0.000186357)  (5, -0.500163)  (6, 1165.14)  (7, 0.000372715)  (8, 0.499976)\nrow 7: (3, -4233.46)  (4, -0.00136985)  (5, -3.64971)  (6, 8453.85)  (7, 0.0027577)  (8, 3.64832)\nrow 8: (3, -833547.)  (4, -0.267749)  (5, -717.609)  (6, 1600.23)  (7, 0.000743599)  (8, 721.21)\nThanks,\nJoe Kelly",
          "url": "https://github.com/idaholab/moose/discussions/22961",
          "updatedAt": "2022-12-16T00:02:52Z",
          "publishedAt": "2022-12-14T14:36:15Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Joe\nThe flags at play here:\nThe svd monitor for the condition number\npetsc_options = '-pc_svd_monitor'\npetsc_options_iname = '-pc_type'\npetsc_options_value = 'svd'\n\nand this other petsc_option(s) for the matrix printout (you must use Newton method for that one, use pmat for PJFNK)\n-ksp_view_mat\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4401444",
                  "updatedAt": "2022-12-14T15:31:01Z",
                  "publishedAt": "2022-12-14T15:30:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "THANKS!!  That worked great.  But could you please explain a little.  I understand the jacobian matrix and it matches what I expected.  But what does the 'condition number' mean?  Mine is 10^21.\nAlso, what are the 'singular values'?   I get:\nSVD: condition number 7.113204853455e+20, 3 of 7 singular values are (nearly) zero\nSVD: singular values: 1.623154264692e-21\nSVD: singular values: 8.796004189038e-01\nAnd finally, with\nsolve_type = 'NEWTON'\npetsc_options = '-pc_svd_monitor -ksp_view_mat'\npetsc_options_iname = '-pc_type -pc_factor_shift_type -pc_factor_shift_amount'\npetsc_options_value = 'svd              NONZERO               1e-10'\nwhere svd replaced lu in petsc_options_value, my test problem CONVERGED!  Whereas I was getting a linear iteration failure.  Not only did it converge, it gave the correct answer.  So, what should my pets options be?\nThanks again,\nJoe",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4401677",
                          "updatedAt": "2022-12-14T15:54:43Z",
                          "publishedAt": "2022-12-14T15:54:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The condition number is the ratio of the first two largest eigenvalues (or smallest, I m likely getting confused with neutronics keff right here, no time to google I have a meeting) of the matrix. see below\n10^21 is very severely ill conditioned. We can get that down a little bit with scaling often, but at these heights it s usually a modeling issue like a missing boundary condition creating a null space.\nThe number of singular values is often tied to the number of dofs that are not well-posed.\nsvd is more of a debugging tool, it can barely be used (extremely slow) above 1k dofs.\nMoving forward if the matrix is only 7 by 7, the matrix print out should let you examine it in matlab or python. There is something wrong with it, making the inversion difficult. @lindsayad do you know of some resources for that?",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4401805",
                          "updatedAt": "2022-12-14T18:37:13Z",
                          "publishedAt": "2022-12-14T16:07:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Looking at it now.  There is something definitely wrong with the matrix.  Lot's for me to understand here as I am trying a hybrid rDG/CG scheme.  So velocity is essentially FVM while pressure is CG.  So, a 3 element model has 3 velocities and 4 pressures.\nThanks so much Guillaume.  I'll mark this as answered.",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4401837",
                          "updatedAt": "2022-12-14T16:11:45Z",
                          "publishedAt": "2022-12-14T16:11:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The condition number is the ratio of largest and smallest singular values",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4402708",
                          "updatedAt": "2022-12-14T17:59:28Z",
                          "publishedAt": "2022-12-14T17:59:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Since we always use the same matrix for the Jacobian and preconditioner, the -ksp_view_pmat option can be used for both NEWTON and PJFNK",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4402715",
                          "updatedAt": "2022-12-14T18:00:08Z",
                          "publishedAt": "2022-12-14T18:00:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I would be worried about LBB stability of a scheme in which you have more pressure dofs than velocity dofs. For incompressible flow the pressure is a Lagrange multiplier enforcing the divergence free constraint ... if you have more constraint dofs than primal dofs then I could easily see producing linearly dependent rows in your matrix",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4402730",
                          "updatedAt": "2022-12-14T18:02:28Z",
                          "publishedAt": "2022-12-14T18:02:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh yeah my bad I was thinking of the dominance ratio for some reason.",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4404646",
                          "updatedAt": "2022-12-14T22:53:35Z",
                          "publishedAt": "2022-12-14T22:53:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "The test problem is a simple one.  Three elements & 1 D single-phase.  No flow, just a stagnant liquid column to check pressure and gravity kernels.  Two variables, Vx and p.  Vx is a constant monomial at the cell-center.  P is first order gauss. So there are 4 nodes and hence 4 pressures. This is the hybrid scheme described in the paper Alex referenced.  But one of the pressures is at the outlet and hence is covered by a Dirichlet bc.  So, I have 2 eqs x 3 elements and 6 unknowns.\nThere is a problem with my jacobian.  I must have a mistake somewhere in my rDG flux kernels.  Although the contribution of the mass & momentum advection terms to the element/neighbor residuals are correct and have their correct AD derivatives, somehow those terms don\u2019t show up in the jacobian.  Indeed I have a row that is all zeros.  No wonder lu couldn\u2019t solve it.  I am amazed that svd (whatever it is) can solve it.\nI have an incompressible fluid, so the mass eq residuals are only fns of the velocity.  For momentum, due to zero velocity, the advection terms are zero and so the momentum residual is only a fn of the pressure gradient.  In other words, no diagonal terms whatsoever. Pretty severe test.  Lots of meetings today but hopefully some time to figure out why the derivatives of the mass eq residuals (advection so deriv is just the density) don\u2019t make it into jacobian.\nThanks for the help.  I like the idea of this hybrid scheme though making it 2nd order for a 3D problem will take a lot of work.  For now, simple 1st order upwind.\nOne more question, is it possible to printout the Residual vector?  Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4409895",
                          "updatedAt": "2022-12-15T12:52:27Z",
                          "publishedAt": "2022-12-15T12:52:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think it's possible to print the residual vector using vector tagging. I ll dig out an example",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4410814",
                          "updatedAt": "2022-12-15T14:47:57Z",
                          "publishedAt": "2022-12-15T14:47:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Thanks Guillaume.  Small correction in the above. My pressure variable is First/Lagrange.  It is the quadrature that is First/Gauss.",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4411406",
                          "updatedAt": "2022-12-15T16:00:07Z",
                          "publishedAt": "2022-12-15T16:00:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "NAFEMS Benchmark T3",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi All\nI'm sure I'm doing something super dumb, but I cannot get MOOSE Heat Conduction to agree with the NAFEMS T3 benchmark, initially I thought I was doing something wrong with a Kelvin conversion, but I shifted to C and I see the same problem.\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 10000\n  ny = 1\n  nz = 1\n  xmin = 0.0\n  xmax = 0.1\n  ymin = 0.0\n  ymax = 0.01\n  zmin = 0.0\n  zmax = 0.01\n  elem_type = HEX8\n[]\n\n[Variables]\n  [temp]\n    initial_condition = 0\n    order = FIRST\n  []\n[]\n\n[Kernels]\n  [heat]\n    type = ADHeatConduction\n    variable = temp\n  []\n[]\n\n[Functions]\n  [bc_func]\n    type = ParsedFunction\n    value = '100*(sin(pi*t/40))'\n  []\n[]\n\n[BCs]\n  [dceb]\n    type = ADFunctionDirichletBC\n    boundary = 'right'\n    variable = temp\n    function = bc_func\n  []\n  [ab]\n    type = ADDirichletBC\n    variable = temp\n    boundary = 'left' \n    value = 0 # 0 C\n  []\n[]\n\n[Kernels]\n  [isotropic-heat]\n    type = ADHeatConduction\n    variable = temp\n  []\n  [heat-dt]\n    type = ADHeatConductionTimeDerivative\n    variable = temp\n  []\n[]\n\n[Materials]\n  [density]\n    type = ADGenericConstantMaterial\n    prop_names = 'density'\n    prop_values = '7200.0'\n  []\n  [copper-heat]\n    type = ADHeatConductionMaterial\n    temp = temp\n    thermal_conductivity_temperature_function = '35.0'\n    specific_heat_temperature_function = '440.5'\n  []\n[]\n\n[Executioner]\n  automatic_scaling = true\n  type = Transient\n  solve_type = NEWTON\n  start_time = 0\n  end_time = 32\n  dt = 1\n  petsc_options = '-snes_converged_reason'\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n  line_search = none\n[]\n\n[Postprocessors]\n  [value_1.25]\n    type = PointValue\n    variable = temp\n    point = '0.08 0.0 0.0'\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nEven with a ridiculous mesh density I get 47.7 instead of 36.6, can someone spot my obvious mistake?",
          "url": "https://github.com/idaholab/moose/discussions/22964",
          "updatedAt": "2022-12-15T16:05:39Z",
          "publishedAt": "2022-12-14T21:47:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "You have two kernels of type = ADHeatConduction. I think you want to get rid of one of them.",
                  "url": "https://github.com/idaholab/moose/discussions/22964#discussioncomment-4404391",
                  "updatedAt": "2022-12-14T22:02:06Z",
                  "publishedAt": "2022-12-14T22:02:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "You're quite right, removing that fixes the issue - face palm! @GiudGiud any reason why MOOSE doesn't error or warn when you have a kernel in twice with the same type? Is there a use case where one would want to be able to have the same kernel in with the same definition twice?",
                          "url": "https://github.com/idaholab/moose/discussions/22964#discussioncomment-4404707",
                          "updatedAt": "2022-12-14T23:09:23Z",
                          "publishedAt": "2022-12-14T23:09:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you split a momentum diffusion term in molecular + turbulent diffusion I could see one use the same kernel to represent both\nSame for multiple reaction terms, a species reaction with multiple species or having multiple sources\nThe solution here is to use actions instead of specifying your kernels in the input file.\nThere s a thermo-mechanical action\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22964#discussioncomment-4404801",
                          "updatedAt": "2022-12-14T23:32:27Z",
                          "publishedAt": "2022-12-14T23:32:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "In those cases would they literally be the sample kernel instanciated twice with the same variable?",
                          "url": "https://github.com/idaholab/moose/discussions/22964#discussioncomment-4408946",
                          "updatedAt": "2022-12-15T10:48:27Z",
                          "publishedAt": "2022-12-15T10:48:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The same kernel with the same variable but not the same parameters",
                          "url": "https://github.com/idaholab/moose/discussions/22964#discussioncomment-4411464",
                          "updatedAt": "2022-12-15T16:05:40Z",
                          "publishedAt": "2022-12-15T16:05:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}