{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wOS0yM1QwODo1OTo1Mi0wNjowMM4ANq7p"
    },
    "edges": [
      {
        "node": {
          "title": "Set of Element IDs of new elements in a refined mesh",
          "author": {
            "login": "ritamcj"
          },
          "bodyText": "Hi everyone,\nI am trying to access the set of new element IDs in a refined mesh at each time step. Are there any existing functions in Moose that can help with this? I looked into the doxygen files such as Marker.h, ValueThresholdMarker, QuadraturePointMarker and ElementIDInterface but could not find a suitable option. Additionally, I am unable to understand the boolean variable \"refine_set\" in ValueThresholdMarker. I would appreciate any leads.\nWarm regards,\nRitam",
          "url": "https://github.com/idaholab/moose/discussions/18944",
          "updatedAt": "2022-10-17T10:24:37Z",
          "publishedAt": "2021-09-28T07:37:10Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Ritam\nWhere do you want this value stores? A vectorposprocessor? An AuxVariable? Would not be too hard to write an auxkernel to place that in an auxvariable.\nrefine_set is simply a boolean to check if the user asked for a refine. It's to avoid doing that check at every quadrature point, and doing it only once in the constructor\nOne thing to know is that elements can be renumbered. You may want to disable that in the Mesh block if you want the ids pre- and post- refinement of some elements to remain the same.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18944#discussioncomment-1397374",
                  "updatedAt": "2022-10-17T10:24:39Z",
                  "publishedAt": "2021-09-28T16:28:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Guillaume,\nThank you for your suggestions and explanation of \"refine_set\". I want to read the number of new elements inside FiniteStrainUObasedCP in tensor mechanics as I want to assign properties (Fp etc.) to the quadrature points on those elements. So, the number would be an integer that would be used to locate the correct quadrature points.\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/18944#discussioncomment-1397661",
                          "updatedAt": "2022-10-17T10:24:40Z",
                          "publishedAt": "2021-09-28T17:25:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok so you need this inside the code.\nTo only loop on the newly refined elements, you could loop over all elements and examine their refinement level. If the parent is not active, then the children element are new. Maybe the JUST_REFINED refinement state will help, I'm not sure.\nSee https://libmesh.github.io/doxygen/classlibMesh_1_1Elem.html for documentation on the element",
                          "url": "https://github.com/idaholab/moose/discussions/18944#discussioncomment-1397745",
                          "updatedAt": "2022-10-17T10:24:40Z",
                          "publishedAt": "2021-09-28T17:41:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Howto retrieve the dof_id of a node for a vector field?",
          "author": {
            "login": "QuangDom"
          },
          "bodyText": "Hi, I am learning Moose and I would like to know how can I get the dof_id(s) of a node for a vector field.\nWhy VectorMooseVariable.nodalDofIndex() returns a single value?\nThanks in advance,\n/ Q.",
          "url": "https://github.com/idaholab/moose/discussions/18946",
          "updatedAt": "2024-07-29T10:48:58Z",
          "publishedAt": "2021-09-28T08:59:39Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nnodalDofIndex will return the index for the first component.\nYou can then use componentDofIndices, defined in MooseVariableBase, to get the values for the other components.\nI think the reason why is because the definition of vector variables is done through templating and that routine was never added for the vector instantiation as it doesnt make sense for the single valued instantiation.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18946#discussioncomment-1397243",
                  "updatedAt": "2024-07-29T10:48:59Z",
                  "publishedAt": "2021-09-28T16:06:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Write a test",
          "author": {
            "login": "QuangDom"
          },
          "bodyText": "Could someone point me to an example or documentation that I can learn about writing a test.\nI would like to test the results by doing an integration over the whole simulation domain (a 2D surface); Or do doing a line integration over the outlet boundary and compare the integration results with a 'gold' values.",
          "url": "https://github.com/idaholab/moose/discussions/18952",
          "updatedAt": "2023-11-13T04:58:11Z",
          "publishedAt": "2021-09-28T15:24:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe test system documentation is here https://mooseframework.inl.gov/python/TestHarness.html#!\nYou can have a look at moose/test/tests/kernels/simple_diffusion/ for an example of a test.\nThis test is an exodiff, so it compares the values of the variables everywhere.\nFor a line integration, you may want to look at a CSVDiff test, as the postrprocessors are easily output to csv files.\nAn example of that is in moose/test/tests/postprocessors/num_elems/\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18952#discussioncomment-1396976",
                  "updatedAt": "2023-11-13T04:58:11Z",
                  "publishedAt": "2021-09-28T15:29:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Documentation confusing for ADComputeVariableIsotropicElasticityTensor",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi All\nIm working with a problem with lots of ADComputeVariableIsotropicElasticityTensor's, the documentation https://mooseframework.inl.gov/source/materials/ADComputeVariableIsotropicElasticityTensor.html states that the youngs_modulus entry is;\n\nWhich to me reads that if I have the following setup\n[Materials]\n  [./fred_youngs_modulus]\n    type = ADPiecewiseLinearInterpolationMaterial\n    xy_data = '0          10e+6\n               599.9999   10e+6\n               600        9.94e+6\n               99900      10e3'\n    property = youngs_modulus\n    variable = temp\n  [../]\n\n  [./elasticity_tensor]\n    type = ADComputeVariableIsotropicElasticityTensor\n    youngs_modulus = fred_youngs_modulus\n    poissons_ratio = 0.0\n  [../]\n[]\n\nThen all should be well, but it isnt, my material with name fred_youngs_modulus isn't found, I interpret the name to be the name of the HIT block. It isn't instead it needs to be the name of the property returned by the ADPieceWiseLinearInterpolation object. Is that a bug/intentional, either way I think the documentation should be a little clearer. Happy to submit a documentation PR if it helps.",
          "url": "https://github.com/idaholab/moose/discussions/18896",
          "updatedAt": "2021-09-28T00:40:40Z",
          "publishedAt": "2021-09-22T17:59:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThank you for reporting this. I ll add this to a documentation fix PR I have open.\nI ll look for other instances too.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18896#discussioncomment-1371139",
                  "updatedAt": "2021-09-22T18:30:24Z",
                  "publishedAt": "2021-09-22T18:30:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Fixed by #18866",
                          "url": "https://github.com/idaholab/moose/discussions/18896#discussioncomment-1393302",
                          "updatedAt": "2021-09-28T00:40:30Z",
                          "publishedAt": "2021-09-28T00:40:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "NonlinearEigen executioner with ArrayVariable",
          "author": {
            "login": "crb3874"
          },
          "bodyText": "Hello,\nI am implementing a simple eigenvalue multi-group neutron diffusion application, using ArrayVariable/Kernels for condensing energy groups to avoid the need for verbose kernel definitions for scattering/fission/etc. in the input file.\nI'd like to use the NonlinearEigen executioner for this, which requires deriving the fission kernel from the EigenKernel class. However, there does not appear to be an analagous \"ArrayEigenKernel\" to derive from for my specific case, as there are for ArrayKernels/ArrayDGKernels.\nIs there compatibility currently for doing this? If not, would the sensible path forward be to implement my own ArrayEigenKernel class?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/18935",
          "updatedAt": "2022-09-13T06:34:14Z",
          "publishedAt": "2021-09-27T16:53:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@YaqiWang will be able to give you some clues here",
                  "url": "https://github.com/idaholab/moose/discussions/18935#discussioncomment-1391717",
                  "updatedAt": "2022-09-13T06:34:14Z",
                  "publishedAt": "2021-09-27T17:01:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "I suggest to work with Eigenvalue executioner with which the eigen kernels are derived from the same base as other kernels except are tagged differently in the input file.  The folder moose/tests/problems/eigen_problem/arraykernels contains few examples.",
                  "url": "https://github.com/idaholab/moose/discussions/18935#discussioncomment-1391768",
                  "updatedAt": "2022-09-13T06:34:17Z",
                  "publishedAt": "2021-09-27T17:11:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "crb3874"
                          },
                          "bodyText": "Yaqi, thanks for the quick response. I'll take a look at these examples.",
                          "url": "https://github.com/idaholab/moose/discussions/18935#discussioncomment-1391794",
                          "updatedAt": "2022-09-13T06:34:24Z",
                          "publishedAt": "2021-09-27T17:18:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error registering tasks to build new objects",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Dear all,\nI am intending to create a new object \"ConstantVectorPostprocessor_UO\" which is based conceptually on \"ConstantVectorPostprocessor\" but does not inherit any of their member functions/variables as such. The former one is now being developed to read data from user objects rather than from the input file itself. The block of commands following is relevant to this new object.\n \n[VectorPostprocessors]\n  [from_main_vpp_UO]\n    type = ConstantVectorPostprocessor_UO\n    stresstens_UO = stresstens\n    vector_names = 'a b c'\n  []\n[]\n \nThe following section of code initialises the paramaters and the member variables.\n#include \"ConstantVectorPostprocessor_UO.h\"\n#include \"InputParameters.h\"\n\nregisterMooseObject(\"MooseApp\", ConstantVectorPostprocessor_UO);\n\n//registerMooseObjectTask(\"add_vector_postprocessor\", ConstantVectorPostprocessor_UO, false);\n\ndefineLegacyParams(ConstantVectorPostprocessor_UO);\n\nInputParameters\nConstantVectorPostprocessor_UO::validParams()\n{\n//  InputParameters params = emptyInputParameters();\n  InputParameters params = MooseObject::validParams();\n  params.addClassDescription(\n      \"Populate constant VectorPostprocessorValue directly from an user object.\");\n  params.addParam<std::vector<std::string>>(\"vector_names\",\n                                            \"Names of the column vectors in this object\");\n  params.addRequiredParam<UserObjectName>(\n      \"stresstens_UO\", \"Name of user object that defines the stress tensor.\");\n\n  params.registerBase(\"ConstantVectorPostprocessor_UO\");\n  return params;\n}\n\nConstantVectorPostprocessor_UO::ConstantVectorPostprocessor_UO(const InputParameters & parameters)\n   : MooseObject(parameters),\n   Restartable(this, \"ConstantVectorPostprocessor_UO\"),\n   _vector_names(getParam<std::vector<std::string>>(\"vector_names\"))\n{\n  _vector_names = getParam<std::vector<std::string>>(\"vector_names\");\n  unsigned int nvec = _vector_names.size();\n}\n\nExecuting this test gives the following run time error.\n\n*** ERROR ***\nTask add_vector_postprocessor is not registered to build ConstantVectorPostprocessor_UO derived objects\n\nI am pretty sure the above task is not properly resgistered to the new bject that is currently under development. I tried to set this right in Moose.C by setting the boolean to true in the following line of code.\n\nregisterMooseObjectTask(\"add_vector_postprocessor\",     VectorPostprocessor,    true);\n\nHowever this does not fix the issue even with a 'clobberall' build. Happy to welcome any suggestions in this regard.\nKind regards,\nArun",
          "url": "https://github.com/idaholab/moose/discussions/18884",
          "updatedAt": "2022-06-15T19:40:52Z",
          "publishedAt": "2021-09-21T18:32:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe issue that the inheritance chain for your new postprocessor does not include a postprocessor class.\nSo if you change MooseObject to GeneralPostprocessor then your object will actually be a postprocessor to the system.\nNote that while you may not want to re-use any of the member functions of the ConstantPP, some of the ones above the chains are pretty important",
                  "url": "https://github.com/idaholab/moose/discussions/18884#discussioncomment-1364316",
                  "updatedAt": "2022-06-15T19:40:56Z",
                  "publishedAt": "2021-09-21T20:48:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Hi Guillaume,\nInclusion of 'GeneralPostprocessor' seems to induce compilation issues deep in to the system files. The following error has been encountered.\n\n(base) abalasub@freia013> make -j10\nUsing HIT from /home/abalasub/Working/Projects/moose/framework/contrib/hit\nCreating Unity /home/abalasub/Working/Projects/moose/framework/build/unity_src/vectorpostprocessors_Unity.C\nCompiling C++ (in opt mode) /home/abalasub/Working/Projects/moose/framework/build/unity_src/vectorpostprocessors_Unity.C...\nIn file included from /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/x86_64-pc-linux-gnu/bits/c++allocator.h:33:0,\n                 from /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/allocator.h:46,\n                 from /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/string:41,\n                 from /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/locale_classes.h:40,\n                 from /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/ios_base.h:41,\n                 from /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/ios:42,\n                 from /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/istream:38,\n                 from /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/fstream:38,\n                 from /home/abalasub/Working/Projects/moose/framework/src/vectorpostprocessors/CSVReader.C:11,\n                 from /home/abalasub/Working/Projects/moose/framework/build/unity_src/vectorpostprocessors_Unity.C:2:\n/usr/local/depot/gcc-7.3.0/include/c++/7.3.0/ext/new_allocator.h: In instantiation of \u2018void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = exampleVectorPostprocessor; _Args = {const InputParameters&}; _Tp = exampleVectorPostprocessor]\u2019:\n/usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/alloc_traits.h:475:4:   required from \u2018static void std::allocator_traits >::construct(std::allocator_traits >::allocator_type&, _Up*, _Args&& ...) [with _Up = exampleVectorPostprocessor; _Args = {const InputParameters&}; _Tp = exampleVectorPostprocessor; std::allocator_traits >::allocator_type = std::allocator]\u2019\n/usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr_base.h:526:39:   required from \u2018std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc, _Args&& ...) [with _Args = {const InputParameters&}; _Tp = exampleVectorPostprocessor; _Alloc = std::allocator; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2]\u2019\n/usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr_base.h:637:4:   required from \u2018std::__shared_count<_Lp>::__shared_count(std::_Sp_make_shared_tag, _Tp*, const _Alloc&, _Args&& ...) [with _Tp = exampleVectorPostprocessor; _Alloc = std::allocator; _Args = {const InputParameters&}; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2]\u2019\n/usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr_base.h:1295:35:   required from \u2018std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator; _Args = {const InputParameters&}; _Tp = exampleVectorPostprocessor; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2]\u2019\n/usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr.h:344:64:   required from \u2018std::shared_ptr<_Tp>::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator; _Args = {const InputParameters&}; _Tp = exampleVectorPostprocessor]\u2019\n/usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr.h:690:14:   required from \u2018std::shared_ptr<_Tp> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = exampleVectorPostprocessor; _Alloc = std::allocator; _Args = {const InputParameters&}]\u2019\n/usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr.h:706:39:   required from \u2018std::shared_ptr<_Tp> std::make_shared(_Args&& ...) [with _Tp = exampleVectorPostprocessor; _Args = {const InputParameters&}]\u2019\n/home/abalasub/Working/Projects/moose/framework/build/header_symlinks/Registry.h:146:29:   required from \u2018std::shared_ptr moose::internal::buildObj(const InputParameters&) [with T = exampleVectorPostprocessor]\u2019\n/home/abalasub/Working/Projects/moose/framework/build/header_symlinks/Registry.h:207:21:   required from \u2018static char Registry::add(const RegistryEntry&) [with T = exampleVectorPostprocessor]\u2019\n/home/abalasub/Working/Projects/moose/framework/src/vectorpostprocessors/exampleVectorPostprocessor.C:12:1:   required from here\n/usr/local/depot/gcc-7.3.0/include/c++/7.3.0/ext/new_allocator.h:136:4: error: invalid new-expression of abstract class type \u2018exampleVectorPostprocessor\u2019\n  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /home/abalasub/Working/Projects/moose/framework/src/vectorpostprocessors/exampleVectorPostprocessor.C:10:0,\n                 from /home/abalasub/Working/Projects/moose/framework/build/unity_src/vectorpostprocessors_Unity.C:42:\n/home/abalasub/Working/Projects/moose/framework/build/header_symlinks/exampleVectorPostprocessor.h:21:7: note:   because the following virtual functions are pure within \u2018exampleVectorPostprocessor\u2019:\n class exampleVectorPostprocessor : public GeneralPostprocessor\n       ^~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/FEProblemBase.h:28:0,\n                 from /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/DistributionInterface.h:14,\n                 from /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/UserObject.h:13,\n                 from /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/GeneralUserObject.h:13,\n                 from /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/GeneralVectorPostprocessor.h:14,\n                 from /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/CSVReader.h:13,\n                 from /home/abalasub/Working/Projects/moose/framework/src/vectorpostprocessors/CSVReader.C:14,\n                 from /home/abalasub/Working/Projects/moose/framework/build/unity_src/vectorpostprocessors_Unity.C:2:\n/home/abalasub/Working/Projects/moose/framework/build/header_symlinks/Postprocessor.h:36:30: note:      virtual PostprocessorValue Postprocessor::getValue()\n   virtual PostprocessorValue getValue() = 0;\n                              ^~~~~~~~\nIn file included from /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/GeneralUserObject.h:13:0,\n                 from /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/GeneralVectorPostprocessor.h:14,\n                 from /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/CSVReader.h:13,\n                 from /home/abalasub/Working/Projects/moose/framework/src/vectorpostprocessors/CSVReader.C:14,\n                 from /home/abalasub/Working/Projects/moose/framework/build/unity_src/vectorpostprocessors_Unity.C:2:\n/home/abalasub/Working/Projects/moose/framework/build/header_symlinks/UserObject.h:67:16: note:         virtual void UserObject::execute()\n   virtual void execute() = 0;\n                ^~~~~~~\n/home/abalasub/Working/Projects/moose/framework/build/header_symlinks/UserObject.h:72:16: note:         virtual void UserObject::initialize()\n   virtual void initialize() = 0;\n                ^~~~~~~~~~\nmake: *** [/home/abalasub/Working/Projects/moose/framework/build/unity_src/vectorpostprocessors_Unity.x86_64-pc-linux-gnu.opt.lo] Error 1\n\nLine 12 in exampleVectorPostprocessor.C (renamed my class \"ConstantVectorPostprocessor_UO\" just for an example and to debug the issue) corresponds to\n\nregisterMooseObject(\"MooseApp\", exampleVectorPostprocessor);\n\nCommenting this line compiles the code, but falters when it searches for the registration of this new object. Another alternative is usage of MooseObject as the parent class for the new class, in which case it compiles without any problems, but asks me to register the task add_vector_postprocessor to the newly derived class at run time. I tried to check this very deep in to the Action classes to see if there is any missing link, and tried some experiments but eventually could not fix it.  I suspect there are some problems in the base level functions, especially when it comes to registering objects under VectorPostprocessors, which might need to be corrected.\nWelcome your suggesions in this regard.",
                          "url": "https://github.com/idaholab/moose/discussions/18884#discussioncomment-1376233",
                          "updatedAt": "2022-06-23T18:42:09Z",
                          "publishedAt": "2021-09-23T18:29:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Look at the header for GeneralPostprocessor and make sure all the pure virtual functions are implemented.\nSome of them you can just implement an empty routine\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/18884#discussioncomment-1376280",
                          "updatedAt": "2022-06-23T18:42:28Z",
                          "publishedAt": "2021-09-23T18:39:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm thinking there might be a derived class that is better than GeneralPostprocessor to inherit. Maybe ElementPostprocessor if you are working on elements, InterfacePP for sides on interfaces etc\nThat will implement a couple of these pure virtual routines (in generalPP) for you.",
                          "url": "https://github.com/idaholab/moose/discussions/18884#discussioncomment-1380806",
                          "updatedAt": "2022-06-23T18:42:27Z",
                          "publishedAt": "2021-09-24T15:49:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Yes, i think it is appropriate to derive from objects that has every thing self contained. The data to be stored in VPP comes from an integration point of a particular element that i choose programmatically based on certain calculations, which in my case would happen in an user object. The new VPP that i am planning to develop, will read this user oject and populate the variables to be transferred across the apps. This is very much inline with \"ConstantVectorPostprocessor\" and the good thing is inheriting this object works in our case, but the input structure is quite different and so i cannot use this object moving forward. Either we must identify the right object to inherit the vector post processor features or we might want to create a new object (as can be seen from this example SamplerBase.C and NodalValueSampler.C). Both of these approaches eventually comes down to the case of finding the right VPP object to inherit from, which in our case may be none. Probably we might be required to build an object with only basic framework that can sit inside VectorPostprocessor block and continue the developments from there on.",
                          "url": "https://github.com/idaholab/moose/discussions/18884#discussioncomment-1389232",
                          "updatedAt": "2022-08-10T15:09:58Z",
                          "publishedAt": "2021-09-27T09:14:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "Hi Guillaume,\nThis is now working OK after a struggle. I allowed my new object to inherit from GeneralVectorPostprocessor and retained the initialize() and execute pure virtual functions.\nKind regards,\nArun",
                  "url": "https://github.com/idaholab/moose/discussions/18884#discussioncomment-1390830",
                  "updatedAt": "2022-06-23T18:42:27Z",
                  "publishedAt": "2021-09-27T14:39:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Great! As there is no objects that does part of the work for you then, the General... are the recommended base classes.\nConstantVPP inherits from GeneralVPP",
                          "url": "https://github.com/idaholab/moose/discussions/18884#discussioncomment-1391023",
                          "updatedAt": "2022-06-23T18:42:34Z",
                          "publishedAt": "2021-09-27T15:08:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Is there a moose application for benchmarking and comparing results?",
          "author": {
            "login": "chippy-byron"
          },
          "bodyText": "Hi\nIs there a shared moose application that people use for benchmarking and comparing results?  In particular I would be interested to compare results when using mpi to run moose in parallel across many nodes.\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/18922",
          "updatedAt": "2021-10-11T03:52:30Z",
          "publishedAt": "2021-09-24T14:46:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFor benchmarking performance (scaling plots), there's a script that was merged in this PR #18005 that you can adapt quite easily\nFor comparing results, you can load previous results using a SolutionUserObject and then there's plenty of postprocessors and auxkernels to compute differences between two solutions.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18922#discussioncomment-1380434",
                  "updatedAt": "2021-09-24T15:02:39Z",
                  "publishedAt": "2021-09-24T15:02:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Density driven PorousFlow",
          "author": {
            "login": "MatiasAllay"
          },
          "bodyText": "Hi,\nIs there an example of density driven multiphase flow in PorousFlow?\nThanks!\nMatias",
          "url": "https://github.com/idaholab/moose/discussions/18904",
          "updatedAt": "2022-07-26T14:49:11Z",
          "publishedAt": "2021-09-23T12:16:39Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "MatiasAllay"
                  },
                  "bodyText": "Okay, I found the 1phase_convection.i example",
                  "url": "https://github.com/idaholab/moose/discussions/18904#discussioncomment-1379044",
                  "updatedAt": "2022-07-26T14:49:11Z",
                  "publishedAt": "2021-09-24T09:52:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to Manipulate Variables at Each Time Step?",
          "author": {
            "login": "mcrossover97"
          },
          "bodyText": "Hi everyone!\nI am trying to solve a reactive transport problem where equilibrium calculations are performed after solving momentum and continuity equations. However, I don't have a clue how I should implement this. I guess I have to hardcode some stuff in the main.c file (I have done this before using OpenFOAM).\nFor example, I want to write a code that multiplies the concentration of aqueous species by 2 at each time step. How is that possible and where should I write such code?\nThanks for your help and support!\nBest,\nMohammad",
          "url": "https://github.com/idaholab/moose/discussions/18905",
          "updatedAt": "2022-07-08T08:05:00Z",
          "publishedAt": "2021-09-23T12:54:47Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre aqueous species a nonlinear variable (one you solve for in the numerical system) ?\nIf not, then use an auxkernel to do those operations.\nIf so, then you can either:\n\nfit all the operations during the timestep (both equilibrium and momentum/continuity) and solve for them together. This is what really happens in the system anyway, reactions and advection are happening at the same time\nuse a transient multiapp setup and split both solves on each app, then use transfers to re-write the ICs to each app using the final state of the previous solve\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18905#discussioncomment-1375235",
                  "updatedAt": "2022-07-08T08:04:58Z",
                  "publishedAt": "2021-09-23T15:07:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcrossover97"
                          },
                          "bodyText": "Thanks for your answer!\nYes, they are nonlinear variables and I can't use an auxkernel. I probably have to go with your second suggestion as I'm treating transfer and chemistry separately (It's a sequential approach). This usually works if your timesteps are small enough.",
                          "url": "https://github.com/idaholab/moose/discussions/18905#discussioncomment-1375299",
                          "updatedAt": "2022-07-08T08:04:57Z",
                          "publishedAt": "2021-09-23T15:20:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some question about DerivativeMultiPhaseMaterial.i",
          "author": {
            "login": "AlexSacMorane"
          },
          "bodyText": "Dear all,\nI am studying the example input at moose/modules/phase_field/examples/multiphase/DerivativeMultiPhaseMaterial.i to understand how a multi phase simulation works. And I have some questions about it :\n\nThis example uses 3 unconserved variables etai but what should I change if I would like to use conserved variables ? If I understand well Basic Phase Field Equations, I just need to replace ACMultiInterface by CHInterface and AllenCahn by CahnHilliard.\nDoes the free energy used here depend only on the concentration c ? I do not see any etai in the definition of the phase_free_energy_i .\n\nI stay available. Regards\nAlexandre Sac--Morane",
          "url": "https://github.com/idaholab/moose/discussions/18870",
          "updatedAt": "2022-06-15T16:43:08Z",
          "publishedAt": "2021-09-20T20:15:35Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "souravmat-git"
                  },
                  "bodyText": "Hello,\nI am not sure about the model you are trying to use.\nTo my understanding, the ACMultiInterface kernel is based on the model by Steinbach et al. (see Eq. 6 in https://www.sciencedirect.com/science/article/pii/0167278995002987), while CHInterface kernel is needed to implement composition gradients, which is not assumed in this example model.\nNo. The total free energy F (see https://mooseframework.inl.gov/modules/phase_field/MultiPhase/WBM.html) depends on both concentration and phase-field variable etai. This expression is coded in the material DerivativeMultiPhaseMaterial.\nHope this helps.\nSourav",
                  "url": "https://github.com/idaholab/moose/discussions/18870#discussioncomment-1360471",
                  "updatedAt": "2022-06-15T16:44:29Z",
                  "publishedAt": "2021-09-21T05:07:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AlexSacMorane"
                          },
                          "bodyText": "Thanks you, I have well noticed the influence of c and etai on the total free energy F.\nConcerning my model, here the simuation considers unconserved variables etai. But I would like to do the same with conserved variables ci. I have just replaced Allen-Cahn equations by Cahn-Hilliard ones. Then I have trouble for the moment with SwitchingFunctionMaterial. I would like to impose the sum of my ci equals to 1 but the SwitchingFunctionMaterial seems to be designed for etai. Is there a same function concerning conserved variables?\nRegards\nAlexandre",
                          "url": "https://github.com/idaholab/moose/discussions/18870#discussioncomment-1364076",
                          "updatedAt": "2022-06-15T16:44:36Z",
                          "publishedAt": "2021-09-21T19:46:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "anilkunwar"
                          },
                          "bodyText": "Switching functions (function of eta_i) are principally designed to interpolate properties at the interface , and thus two different properties can be assigned to two different phases (eta1 and eta2). Generally, for a system with non-conserved volume, the phases (eta_i) are described by Allen-Cahn equation and conserved variables ci (e.g. composition) are described by Cahn-HIlliard equation. There is no need to define switching function of ci variables (if they mean mole fraction and do not mean phases ). I assume that the system is binary, ternary or multicomponent  (with the statement sum of ci equals 1) . In this case, the design rule for interface composition can be understood through WBM and KKS models (these models are implemented in moose).  In case like non-reactive wetting , volume is conserved and  in such cases Cahn-Hilliard equation represents the evolution of phases (eta or c  whichever notation is used) .",
                          "url": "https://github.com/idaholab/moose/discussions/18870#discussioncomment-1364434",
                          "updatedAt": "2022-06-15T16:44:42Z",
                          "publishedAt": "2021-09-21T21:18:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AlexSacMorane"
                          },
                          "bodyText": "Ok thanks for those details it becomes clearer. I think I have managed to get what I would like.",
                          "url": "https://github.com/idaholab/moose/discussions/18870#discussioncomment-1375193",
                          "updatedAt": "2022-06-15T16:44:46Z",
                          "publishedAt": "2021-09-23T14:59:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}