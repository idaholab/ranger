{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wOS0xMFQxMzoxNTo0NC0wNjowMM4ANmfv"
    },
    "edges": [
      {
        "node": {
          "title": "Elastic Modulus as a variable",
          "author": {
            "login": "alexchen4ai"
          },
          "bodyText": "I am using Automatic Differentiation in Moose.\nI used tensor mechanics modules. The elastic modulus are dependent on another variable. It seems that we could only enter the values of C_{ijkl} as float number. Is there a way to input a coupled variable for C_{ijkl}?\n  [elasticity_tensor]\n    type = ADComputeElasticityTensor\n    C_ijkl = '10868. 2457. 3279. 21613. 5000.'\n    fill_method = axisymmetric_rz\n  []\n\nFor example, I want to enter something like C_ijkl = '10868.*(1-x) 2457. 3279. 21613. 5000.' where x is another variables.\nIt doesn't work. Are there some tricks to do this?",
          "url": "https://github.com/idaholab/moose/discussions/18830",
          "updatedAt": "2022-06-26T08:45:48Z",
          "publishedAt": "2021-09-15T19:41:28Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "souravmat-git"
                  },
                  "bodyText": "Is \"x\" a moose variable or a spatial variable ?\nIf \"x\" is declared as a moose variable then check the following material and input file:\nmoose/modules/tensor_mechanics/src/materials/ComputeConcentrationDependentElasticityTensor.C\nmoose/modules/combined/test/tests/concentration_dependent_elasticity_tensor/\nYou will have to modify \"_elatictity_tensor\" and \"_delasticity_tensor_dc\" in the material file according to your variable-dependent expression for elasticity tensor.",
                  "url": "https://github.com/idaholab/moose/discussions/18830#discussioncomment-1345701",
                  "updatedAt": "2022-06-26T08:45:52Z",
                  "publishedAt": "2021-09-17T05:57:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you! This helps!",
                          "url": "https://github.com/idaholab/moose/discussions/18830#discussioncomment-1348191",
                          "updatedAt": "2022-06-26T08:46:04Z",
                          "publishedAt": "2021-09-17T15:40:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @AlexCHEN-Engineer\nYou can check this example in my repository, where I set the elasticity tensor as dependent on the temperature:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/ComputeElasticityTensorCPGrain.C\nIn my case temperature is an AuxVariable, but the same can be done with a MOOSE Variable.\nTrust this helps.\nBest Regards,\nNicol\u00f2 Grilli",
                  "url": "https://github.com/idaholab/moose/discussions/18830#discussioncomment-1348137",
                  "updatedAt": "2022-06-26T08:46:04Z",
                  "publishedAt": "2021-09-17T15:28:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you for sharing and it makes sense!",
                          "url": "https://github.com/idaholab/moose/discussions/18830#discussioncomment-1348190",
                          "updatedAt": "2022-06-26T08:46:18Z",
                          "publishedAt": "2021-09-17T15:40:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can't activate external modules",
          "author": {
            "login": "alexchen4ai"
          },
          "bodyText": "Dear moose experts and users,\nI am creating a new application and I set the tensor_mechanics as yes. However, it doesn't compile when I type \"make -j4\".\n\nI expect there should be more compiling. No kernels in tensor_mechanics is activated. And I tried to use some kernels in tensor_mechanics. But it doesn't work.\nI installed the moose successfully with all tests passed.",
          "url": "https://github.com/idaholab/moose/discussions/18840",
          "updatedAt": "2022-09-13T18:44:47Z",
          "publishedAt": "2021-09-16T18:16:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "So the tensor mechanics linking is missing from the log. We prefer you copy over the test in quotes (add code button) than post screenshots btw\nDid you try to make clobberall before compiling?\nCan you paste your Makefile here?",
                  "url": "https://github.com/idaholab/moose/discussions/18840#discussioncomment-1343816",
                  "updatedAt": "2022-09-13T18:45:02Z",
                  "publishedAt": "2021-09-16T18:18:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you for your reply. I didn't try make clobberall before compiling. The Makefile is here.\n###############################################################################\n################### MOOSE Application Standard Makefile #######################\n###############################################################################\n#\n# Optional Environment variables\n# MOOSE_DIR        - Root directory of the MOOSE project\n#\n###############################################################################\n# Use the MOOSE submodule if it exists and MOOSE_DIR is not set\nMOOSE_SUBMODULE    := $(CURDIR)/moose\nifneq ($(wildcard $(MOOSE_SUBMODULE)/framework/Makefile),)\n  MOOSE_DIR        ?= $(MOOSE_SUBMODULE)\nelse\n  MOOSE_DIR        ?= $(shell dirname `pwd`)/moose\nendif\n\n# framework\nFRAMEWORK_DIR      := $(MOOSE_DIR)/framework\ninclude $(FRAMEWORK_DIR)/build.mk\ninclude $(FRAMEWORK_DIR)/moose.mk\n\n################################## MODULES ####################################\n# To use certain physics included with MOOSE, set variables below to\n# yes as needed.  Or set ALL_MODULES to yes to turn on everything (overrides\n# other set variables).\n\nALL_MODULES                 := no\n\nCHEMICAL_REACTIONS          := no\nCONTACT                     := no\nEXTERNAL_PETSC_SOLVER       := no\nFLUID_PROPERTIES            := no\nFSI                         := no\nFUNCTIONAL_EXPANSION_TOOLS  := no\nGEOCHEMISTRY                := no\nHEAT_CONDUCTION             := no\nLEVEL_SET                   := no\nMISC                        := no\nNAVIER_STOKES               := no\nPHASE_FIELD                 := no\nPOROUS_FLOW                 := no\nRAY_TRACING                 := no\nRDG                         := no\nRICHARDS                    := no\nSTOCHASTIC_TOOLS            := no\nTENSOR_MECHANICS            := yes\nXFEM                        := no\n\ninclude $(MOOSE_DIR)/modules/modules.mk\n###############################################################################\n\n# dep apps\nAPPLICATION_DIR    := $(CURDIR)\nAPPLICATION_NAME   := farm\nBUILD_EXEC         := yes\nGEN_REVISION       := no\ninclude            $(FRAMEWORK_DIR)/app.mk\n\n###############################################################################\n# Additional special case targets should be added here",
                          "url": "https://github.com/idaholab/moose/discussions/18840#discussioncomment-1343834",
                          "updatedAt": "2022-09-13T18:45:22Z",
                          "publishedAt": "2021-09-16T18:22:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "I tried make clobberall. And it works now! Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18840#discussioncomment-1343847",
                          "updatedAt": "2022-09-13T18:45:46Z",
                          "publishedAt": "2021-09-16T18:25:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "error when use ActivateElementsByPath and mesh adaptivity at the same time",
          "author": {
            "login": "cztkatherine"
          },
          "bodyText": "Dear colleagues,\nIt appears that when we use ActivateElementsByPath and mesh adaptivity at the same time, there would be an error saying:\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)\nWe are able to reproduce this error by adapting the example (modules/combined/test/tests/additive_manufacturing/check_element_addition_2D.i), and a copy of the modified input is attached.\n[Problem]\n  kernel_coverage_check = false\n[]\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    ymin = 0\n    xmax = 1\n    ymax = 0.5\n    nx = 10\n    ny = 10\n  []\n  [bottom_domain]\n    input = gen\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0 0'\n    top_right = ' 1 0.1 0'\n    block_id = 1\n  []\n  [top_domain]\n    input = bottom_domain\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0.1 0'\n    top_right = '1 0.5 00'\n    block_id = 2\n  []\n  [sidesets]\n    input = top_domain\n    type = SideSetsAroundSubdomainGenerator\n    normal = '1 0 0'\n    block = 1\n    new_boundary = 'moving_interface'\n  []\n[]\n\n[Variables]\n  [temp]\n    block = '1 2'\n    initial_condition = '20'\n  []\n[]\n\n[Functions]\n  [fy]\n    type = ParsedFunction\n    value = '0.2'\n  []\n  [fx]\n    type = ParsedFunction\n    value = 't'\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  automatic_scaling = true\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  line_search = 'none'\n\n  l_max_its = 10\n  nl_max_its = 20\n  nl_rel_tol = 1e-4\n\n  start_time = 0.0\n  end_time = 1\n  dt = 5e-2\n  dtmin = 1e-4\n[]\n\n\n[Adaptivity]\n  marker = Marker3 #this line when commented, switches off adaptivity\n  max_h_level = 3\n  #steps = 2 #this line gets ignored in a transient run\n  [./Indicators]\n    [./Terror]\n      type = GradientJumpIndicator\n      variable = temp\n      outputs = none\n    [../]   \n  [../]\n  [./Markers]\n    [./Marker3]\n      type = ErrorFractionMarker\n      refine = 0.65\n      coarsen = 0.25\n      indicator = Terror\n      outputs = none\n    [../]\n  [../]\n[]\n\n\n[UserObjects]\n  [activated_elem_uo]\n    type = ActivateElementsByPath\n    execute_on = timestep_begin\n    activate_distance = 0.2\n    function_x = fx\n    function_y = fy\n    active_subdomain_id = 1\n    expand_boundary_name = 'moving_interface'\n  []\n[]\n\n[Outputs]\n  exodus = true\nfile_base = ./CheckEleAddition2D/CheckEleAddition2D\n[]\n\nWhen we run with the adaptivity block, the above error appears. If you delete the adaptivity block, the simulation runs successfully.\nCould any one share some thoughts about this conflicts?\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/18284",
          "updatedAt": "2022-08-12T03:17:15Z",
          "publishedAt": "2021-07-07T23:46:03Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "That might be a corner case that has not been fully tested.  @dewenyushu do you have any thoughts?",
                  "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-977039",
                  "updatedAt": "2022-08-12T03:17:25Z",
                  "publishedAt": "2021-07-07T23:50:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "We plan to replace ActivateElementsByPath with the new element subdomain modifiers. I modified your input file to use the CoupledVarThresholdElementSubdomainModifier and it works fine with adaptivity.\nHere is the animation:\nhttps://user-images.githubusercontent.com/31555204/124855357-d5246800-df76-11eb-9ffe-a9d563d93df7.mov\nThe modified input file is attached below.\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    ymin = 0\n    xmax = 1\n    ymax = 0.5\n    nx = 10\n    ny = 10\n  []\n  [bottom_domain]\n    input = gen\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0 0'\n    top_right = ' 1 0.1 0'\n    block_id = 1\n  []\n  [top_domain]\n    input = bottom_domain\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0.1 0'\n    top_right = '1 0.5 00'\n    block_id = 2\n  []\n  [sidesets]\n    input = top_domain\n    type = SideSetsAroundSubdomainGenerator\n    normal = '1 0 0'\n    block = 1\n    new_boundary = 'moving_interface'\n  []\n[]\n\n[Variables]\n  [temp]\n    block = '1 2'\n    initial_condition = '20'\n  []\n[]\n\n[Kernels]\n  [diff]\n    type = Diffusion\n    variable = temp\n  []\n[]\n\n[BCs]\n  [left]\n    type = DirichletBC\n    variable = temp\n    value = 20\n    boundary = 'left'\n  []\n  [right]\n    type = FunctionDirichletBC\n    variable = temp\n    function = '20+10*t'\n    boundary = right\n  []\n[]\n\n[Functions]\n  [fy]\n    type = ParsedFunction\n    value = '0.2'\n  []\n  [fx]\n    type = ParsedFunction\n    value = 't'\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  automatic_scaling = true\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  line_search = 'none'\n\n  l_max_its = 10\n  nl_max_its = 20\n  nl_rel_tol = 1e-4\n\n  start_time = 0.0\n  end_time = 1\n  dt = 5e-2\n  dtmin = 1e-4\n[]\n\n[Adaptivity]\n  marker = threshold\n  max_h_level = 1\n  [Markers]\n    [threshold]\n      type = ValueThresholdMarker\n      variable = temp\n      refine = 22\n    []\n  []\n[]\n\n[AuxVariables]\n  [dist]\n  []\n[]\n\n[AuxKernels]\n  [dist]\n    type = ParsedAux\n    variable = dist\n    function = 'sqrt((x-t)^2+(y-0.2)^2)'\n    use_xyzt = true\n    execute_on = 'TIMESTEP_BEGIN LINEAR TIMESTEP_END'\n  []\n[]\n\n[UserObjects]\n  [esm]\n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = dist\n    subdomain_id = 1\n    threshold = 0.2\n    criterion_type = BELOW\n    apply_initial_conditions = false\n    moving_boundary_name = 'moving_interface'\n    block = 2\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n[]\n\n[Outputs]\n  exodus = true\n  file_base = ./CheckEleAddition2D/CheckEleAddition2D\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-977418",
                  "updatedAt": "2022-08-12T03:17:25Z",
                  "publishedAt": "2021-07-08T03:00:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "But we should definitely add some regression tests including adaptivity.",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-977420",
                          "updatedAt": "2022-08-12T03:17:46Z",
                          "publishedAt": "2021-07-08T03:02:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dewenyushu"
                  },
                  "bodyText": "@jiangwen84 you're right. The ActivateElementsByPath has not been tested with mesh adaptivity.\n@hugary1995 's suggestion is the right way to go.",
                  "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-979871",
                  "updatedAt": "2022-08-24T19:01:05Z",
                  "publishedAt": "2021-07-08T14:28:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Thank you all @jiangwen84 @hugary1995 @dewenyushu and we will be using CoupledVarThresholdElementSubdomainModifier.\nBest,\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980032",
                          "updatedAt": "2022-08-24T19:01:06Z",
                          "publishedAt": "2021-07-08T15:00:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "I just have a quick test, it appears when adaptivity is based on ValueThresholdMarker, both CoupledVarThresholdElementSubdomainModifier and ActivateElementsByPath will work. If we use GradientJumpIndicator, neither of them will work. To be more specific, if we replace the adaptivity block of the input file provide by @hugary1995 using the block below:\n[Adaptivity]\nmarker = Marker3 #this line when commented, switches off adaptivity\nmax_h_level = 3\n[./Indicators]\n[./Terror]\ntype = GradientJumpIndicator\nvariable = temp\noutputs = none\n[../]\n[../]\n[./Markers]\n[./Marker3]\ntype = ErrorFractionMarker\nrefine = 0.65\ncoarsen = 0.25\nindicator = Terror\noutputs = none\n[../]\n[../]\n[]\nThe same error will occur. Could any of you take another look at it? Thank you all.\nBest,\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980105",
                          "updatedAt": "2022-08-24T19:01:13Z",
                          "publishedAt": "2021-07-08T15:15:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "This marker doesn't make sense in this problem -- the gradient jump is zero everywhere.",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980124",
                          "updatedAt": "2022-10-07T14:24:06Z",
                          "publishedAt": "2021-07-08T15:19:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Well, it probably implies that there are still some issues when combining ESMs (element subdomain modifier) with AMR (adaptive mesh refinement). If there is a more concrete non-working example, feel free to open an issue.",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980131",
                          "updatedAt": "2022-10-07T14:24:06Z",
                          "publishedAt": "2021-07-08T15:21:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "You are right @hugary1995 about zero temperature gradient in the above input file. I slightly modified your input file as below to change the left BC to a higher temperature to introduce the temperature gradient and same error persists. If switching to the ValueThresholdMarker, then it behaves as expected.\n[Mesh]\n[gen]\ntype = GeneratedMeshGenerator\ndim = 2\nxmin = 0\nymin = 0\nxmax = 1\nymax = 0.5\nnx = 10\nny = 10\n[]\n[bottom_domain]\ninput = gen\ntype = SubdomainBoundingBoxGenerator\nbottom_left = '0 0 0'\ntop_right = ' 1 0.1 0'\nblock_id = 1\n[]\n[top_domain]\ninput = bottom_domain\ntype = SubdomainBoundingBoxGenerator\nbottom_left = '0 0.1 0'\ntop_right = '1 0.5 00'\nblock_id = 2\n[]\n[sidesets]\ninput = top_domain\ntype = SideSetsAroundSubdomainGenerator\nnormal = '1 0 0'\nblock = 1\nnew_boundary = 'moving_interface'\n[]\n[]\n[Variables]\n[temp]\nblock = '1 2'\ninitial_condition = '20'\n[]\n[]\n[Kernels]\n[diff]\ntype = Diffusion\nvariable = temp\n[]\n[]\n[BCs]\n[left]\ntype = DirichletBC\nvariable = temp\nvalue = 50\nboundary = 'left'\n[]\n[right]\ntype = FunctionDirichletBC\nvariable = temp\nfunction = '20+10*t'\nboundary = right\n[]\n[]\n[Functions]\n[fy]\ntype = ParsedFunction\nvalue = '0.2'\n[]\n[fx]\ntype = ParsedFunction\nvalue = 't'\n[]\n[]\n[Preconditioning]\n[smp]\ntype = SMP\nfull = true\n[]\n[]\n[Executioner]\ntype = Transient\nautomatic_scaling = true\nsolve_type = 'NEWTON'\npetsc_options_iname = '-pc_type'\npetsc_options_value = 'lu'\nline_search = 'none'\nl_max_its = 10\nnl_max_its = 20\nnl_rel_tol = 1e-4\nstart_time = 0.0\nend_time = 1\ndt = 5e-2\ndtmin = 1e-4\n[]\n#[Adaptivity]\n#marker = threshold\n#max_h_level = 1\n#[Markers]\n#[threshold]\n#type = ValueThresholdMarker\n#variable = temp\n#refine = 40\n#[]\n#[]\n#[]\n[Adaptivity]\nmarker = Marker3 #this line when commented, switches off adaptivity\nmax_h_level = 3\n[./Indicators]\n[./Terror]\ntype = GradientJumpIndicator\nvariable = temp\noutputs = none\n[../]\n[../]\n[./Markers]\n[./Marker3]\ntype = ErrorFractionMarker\nrefine = 0.65\ncoarsen = 0.25\nindicator = Terror\noutputs = none\n[../]\n[../]\n[]\n[AuxVariables]\n[dist]\n[]\n[]\n[AuxKernels]\n[dist]\ntype = ParsedAux\nvariable = dist\nfunction = 'sqrt((x-t)^2+(y-0.2)^2)'\nuse_xyzt = true\nexecute_on = 'TIMESTEP_BEGIN LINEAR TIMESTEP_END'\n[]\n[]\n[UserObjects]\n[esm]\ntype = CoupledVarThresholdElementSubdomainModifier\ncoupled_var = dist\nsubdomain_id = 1\nthreshold = 0.2\ncriterion_type = BELOW\napply_initial_conditions = false\nmoving_boundary_name = 'moving_interface'\nblock = 2\nexecute_on = 'TIMESTEP_BEGIN'\n[]\n[]\n[Outputs]\nexodus = true\nfile_base = ./CheckEleAddition2D/CheckEleAddition2D\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980203",
                          "updatedAt": "2022-10-07T14:24:06Z",
                          "publishedAt": "2021-07-08T15:34:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Sorry I didn't follow. What did you do to make the temperature gradient jump nonzero?",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980314",
                          "updatedAt": "2022-10-07T14:24:16Z",
                          "publishedAt": "2021-07-08T15:59:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Sorry not making it clear. I simply change the prescribed temperature at the left boundary from 20 to 50. A snapshot of the temperature contour shows the expected temperature gradient if you run without adaptivity or using ValueThresholdMarker.\n\nBest,\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980492",
                          "updatedAt": "2022-10-07T14:24:16Z",
                          "publishedAt": "2021-07-08T16:40:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Sorry I think I made a false statement here. The temperature is linearly varying, and the gradient is constant. I will further work on that and post it here.",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980508",
                          "updatedAt": "2022-10-07T14:24:16Z",
                          "publishedAt": "2021-07-08T16:44:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Hi Gary,\nThe smallest example I can replicate the error I have regarding GradientJumpIndicator based mesh adaptivity  and CoupledVarThresholdElementSubdomainModifier is by combining the example we have with the FunctionPathEllipsoidHeatSource. A copy of the input file is shown below. The simulation will terminate after step 9 due to segmentation fault. Any suggestion is appreciated. Thank you.\nBest,\nXiang\n[Mesh]\n[gen]\ntype = GeneratedMeshGenerator\ndim = 3\nxmin = -5.0\nxmax = 5.0\nnx = 20\nymin = -5.0\nymax = 5.0\nny = 20\nzmin = 0.0\nzmax = 1.0\nnz = 1\n[]\n[left_domain]\ninput = gen\ntype = SubdomainBoundingBoxGenerator\nbottom_left = '-5 -5 0'\ntop_right = ' 0 5 1'\nblock_id = 1\n[]\n[right_domain]\ninput = left_domain\ntype = SubdomainBoundingBoxGenerator\nbottom_left = '0 -5 0'\ntop_right = '5 5  1'\nblock_id = 2\n[]\n[sidesets]\ninput = right_domain\ntype = SideSetsAroundSubdomainGenerator\nnormal = '1 0  0'\nblock = 1\nnew_boundary = 'moving_interface'\n[]\n[]\n[Variables]\n[./temp]\ninitial_condition = 30\n[../]\n[]\n[Kernels]\n[./time]\ntype = ADHeatConductionTimeDerivative\nvariable = temp\n[../]\n[./heat_conduct]\ntype = ADHeatConduction\nvariable = temp\nthermal_conductivity = thermal_conductivity\n[../]\n[./heat_source]\ntype = ADMatHeatSource\nmaterial_property = volumetric_heat\nvariable = temp\n[../]\n[]\n[BCs]\n[./temp_bottom_fix]\ntype = ADDirichletBC\nvariable = temp\nboundary = 1\nvalue = 30\n[../]\n[]\n[Materials]\n[./heat]\ntype = ADHeatConductionMaterial\nspecific_heat = 603\nthermal_conductivity = 10e-2\n[../]\n[./density]\ntype = ADGenericConstantMaterial\nprop_names = 'density'\nprop_values = '4.43e-6'\n[../]\n[./volumetric_heat]\ntype = FunctionPathEllipsoidHeatSource\nrx = 1\nry = 1\nrz = 1\npower = 100\nefficiency = 0.5\nfactor = 2\nfunction_x= path_x\nfunction_y= path_y\nfunction_z= path_z\n[../]\n[]\n[Functions]\n[./path_x]\ntype = ParsedFunction\n#value = 2cos(2.0pit)\nvalue = 2cos(2.0pit)\n[../]\n[./path_y]\ntype = ParsedFunction\nvalue = 2sin(2.0pi*t)\n[../]\n[./path_z]\ntype = ParsedFunction\nvalue = 1.0\n[../]\n[]\n[AuxVariables]\n[dist]\n[]\n[]\n[AuxKernels]\n[dist]\ntype = ParsedAux\nvariable = dist\nfunction = 'sqrt((y+5-t*10)^2+(x-1.5)^2+(z-0.5)^2)'\nuse_xyzt = true\nexecute_on = 'TIMESTEP_BEGIN LINEAR TIMESTEP_END'\n[]\n[]\n[UserObjects]\n[esm]\ntype = CoupledVarThresholdElementSubdomainModifier\ncoupled_var = dist\nsubdomain_id = 1    #--- new ID\nthreshold = 1.5\ncriterion_type = BELOW\napply_initial_conditions = false\nmoving_boundary_name = 'moving_interface'\nblock = 2          #-- old id\nexecute_on = 'TIMESTEP_BEGIN'\n[]\n[]\n[Postprocessors]\n[temp_max]\ntype = ElementExtremeValue\nvariable = temp\n[]\n[temp_min]\ntype = ElementExtremeValue\nvariable = temp\nvalue_type = min\n[]\n[temp_avg]\ntype = ElementAverageValue\nvariable = temp\n[]\n[]\n[Preconditioning]\n[./full]\ntype = SMP\nfull = true\n[../]\n[]\n[Adaptivity]\nmarker = Marker3 #this line when commented, switches off adaptivity\nmax_h_level = 3\n[./Indicators]\n[./Terror]\ntype = GradientJumpIndicator\nvariable = temp\noutputs = none\n[../]\n[../]\n[./Markers]\n[./Marker3]\ntype = ErrorFractionMarker\nrefine = 0.75\ncoarsen = 0.25\nindicator = Terror\noutputs = none\n[../]\n[../]\n[]\n[Executioner]\ntype = Transient\nsolve_type = PJFNK\nnl_rel_tol = 1e-6\nnl_abs_tol = 1e-6\npetsc_options_iname = '-ksp_type -pc_type -pc_factor_mat_solver_package'\npetsc_options_value = 'preonly lu       superlu_dist'\nl_max_its = 100\nend_time = 1\ndt = 0.05\ndtmin = 1e-4\n[]\n[Outputs]\ncsv = true\nexodus = true\nfile_base = ./FunctionHeatSource/FunctionHeatSource\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-995436",
                          "updatedAt": "2022-10-07T14:24:16Z",
                          "publishedAt": "2021-07-12T19:27:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Thanks for reporting that. I've created an issue #18368",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-1015943",
                          "updatedAt": "2022-10-07T14:24:18Z",
                          "publishedAt": "2021-07-17T11:35:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Should I use MatchedValueBC or PenaltyInterfaceDiffusion to enforce solution continuity at an interface?",
          "author": {
            "login": "lindsayad"
          },
          "bodyText": "The former enforces continuity strongly while the latter imposes continuity in a weak sense using a penalty method. Which one is better?",
          "url": "https://github.com/idaholab/moose/discussions/18799",
          "updatedAt": "2023-01-12T04:55:06Z",
          "publishedAt": "2021-09-09T22:49:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "The answer is that it depends on what you're after. MatchedValueBC may yield a better conditioned system because it does not introduce any penalty parameters. However, this may not always be the case. For instance if you are solving a diffusivity problem, and you impose a penalty equivalent to the diffiusivity, then the penalty method will actually be better conditioned than the strongly enforced method. However, you may not be satisfied with the jump between the solution value on either side of the face.\nWhat is unequivocal is that the penalty method (given wise choice of the penalty parameter) preserves optimal convergence of the finite element method while the strong method of enforcing continuity degrades the convergence by order 1. So if using first order Lagrange variables, the expected approximation error of the method is O(h^2). This is indeed the result when using the penalty method. However, in this case the strong enforcement method would yield error O(h^1). For more discussion please see the old MOOSE forum",
                  "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1304075",
                  "updatedAt": "2023-01-12T04:55:06Z",
                  "publishedAt": "2021-09-09T22:54:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@lindsayad  I was bit puzzled about the convergence rate you gave for strong enforcement v.s penalty method. Is it specific to the interfacial conditions? Or it is also true for boundary conditions?\nFor boundary condition, my experience is that the strong enforcement, i.e. DirichletBC, gives optimal rate while  PenaltyDirichletBC typically does not provide optimal rate convergence.  The penalty method requires theoretically very large number to give accurate result, and when the penalty becomes large, the optimal rate can not be obtained.",
                  "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1304125",
                  "updatedAt": "2023-01-12T04:55:42Z",
                  "publishedAt": "2021-09-09T23:17:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If you read that whole thread that I linked to, then I think you'll see that I was quite surprised as well! An analogy I can think of is that if we apply mechanical contact constraints in a point-wise way like we do for NodeFaceConstraints, then you fail the patch test and the method is not variationally consistent. However, if you apply the constraint in a weak/integral/weighted way then the variational consistency of the method is restored. @YaqiWang was the one who initially questioned the strong enforcement method and suggested that I look into the penalty method. I'm thankful that he did!",
                          "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1304334",
                          "updatedAt": "2023-05-01T16:51:50Z",
                          "publishedAt": "2021-09-10T01:07:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Instead of penalty we could also do weak enforcement with lagrange multipliers as well. Then you would get exact constraint enforcement (at the cost of making your system saddle point)",
                          "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1304349",
                          "updatedAt": "2023-05-01T16:51:50Z",
                          "publishedAt": "2021-09-10T01:13:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I agreed that the MatchedValueBC is not a variational consistent approach, just like the NodeFace Contact which is more like a collocation method. For MatchedValueBC, I do not think it can be called as strong enforcement. It has its own residual that needs to be minimized by the solver.  Unlike the Dirichlet boundary condition, we can choose a finite element space which exactly satisfies the BC. For that we say it is a strong enforcement.\nFor penalty, I am not sure if it is always optimal rate of convergence. It can be super or sub. Like you said, it is highly depends on the choice of the penalty parameter, which can be mesh dependent and problem dependent.\nFor stabilized Lagrange Multiplier method, I believe it always has optimal rate of convergence.",
                          "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1304918",
                          "updatedAt": "2023-05-01T16:51:50Z",
                          "publishedAt": "2021-09-10T05:08:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "For MatchedValueBC, I do not think it can be called as strong enforcement. It has its own residual that needs to be minimized by the solver.\n\nIt is implemented as a NodalBC though. It overwrites any existing residual information for the degree of freedom on the node and plugs the residual of the NodalBC in. The only way the residual can be zero is if if the NodalBC residual is satisfied. In addiition, no information from the boundary faces is considered, e.g. no integration is performed. I would consider that strong enforcement.",
                          "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1307096",
                          "updatedAt": "2023-05-01T16:51:50Z",
                          "publishedAt": "2021-09-10T13:54:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "For penalty, I am not sure if it is always optimal rate of convergence. It can be super or sub. Like you said, it is highly depends on the choice of the penalty parameter, which can be mesh dependent and problem dependent.\n\nThis statement is true. At least I have observed sub-convergence rates with too small a choice of penalty. I have not yet observed super-convergence rates. I will say that just last night @fdkong tried out both the matched and penalty approaches and his error was significantly less with the penalty approach which is consistent with the plots from the MOOSE users thread I linked to.\n\nFor stabilized Lagrange Multiplier method, I believe it always has optimal rate of convergence.\n\nYes, I think it would be great to add an object that does this with LMs",
                          "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1307109",
                          "updatedAt": "2023-05-01T16:51:50Z",
                          "publishedAt": "2021-09-10T13:57:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "If you look at the residual defined by MatchedValueBC, i.e., _u[_qp] - _v[_qp], it is a penalty-like enforcement with penalty number of 1. I think if you user a higher penalty number there, you will get better results.\nIn my opinion, those two methods are both penalty enforcement, with one enforces on the node, the other on the face/side.",
                          "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1316677",
                          "updatedAt": "2023-05-01T16:51:51Z",
                          "publishedAt": "2021-09-13T15:00:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "No it is exact. MatchedValueBC is a NodalBC. NodalBC overwrites (e.g. it calls NumericVector::set) its residual and its Jacobian row instead of adding to it.",
                          "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1317013",
                          "updatedAt": "2023-05-01T16:52:46Z",
                          "publishedAt": "2021-09-13T15:59:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I might not understand how it works well. Here is what I thought.\nThe residual cannot not be exactly zero. It will be minimized to meet the tolerance, e.g. L2 norm of the residual vector. So my understanding is that the _u won't be exactly equal to _v. If you add a larger penalty number to the residual term in MatchedValueBC, e.g. 1e6 * (_u[_qp] - _v[_qp]), the contribution of this term to the overall residual vector will become larger. With a same tolerance, the _u will get closer to _v.",
                          "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1317313",
                          "updatedAt": "2023-05-01T16:52:46Z",
                          "publishedAt": "2021-09-13T16:43:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "By that logic we should also add penalty parameters to Lagrange Multiplier residuals",
                          "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1317326",
                          "updatedAt": "2023-05-01T16:53:16Z",
                          "publishedAt": "2021-09-13T16:47:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "So yes you are right ... if you're registering your problem as converged when the L2 norm of the residual vector is, say, 1e-8, then you are requiring that u and v are at most 1e-4 apart. If you add a penalty parameter, then you will force them to be even closer than that. My suspicion is that even if you add a penalty parameter to MatchedValueBC, no matter what value you have for it, you will never get the optimal convergence rate for the same reason that node-face constraints do not yield optimal convergence. But I could be wrong. @fdkong would you want to try adding a penalty parameter to MatchedValueBC and see if you get better errors, both better constant and slope?",
                          "url": "https://github.com/idaholab/moose/discussions/18799#discussioncomment-1317343",
                          "updatedAt": "2023-05-01T16:53:27Z",
                          "publishedAt": "2021-09-13T16:50:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to refine mesh when current solve failed ?",
          "author": {
            "login": "xiekai-mc"
          },
          "bodyText": "I want to refine mesh, when current solve failed, not just to cut the time step.\nIs that easy to implement \uff1fWhich files might need to be modified?",
          "url": "https://github.com/idaholab/moose/discussions/18748",
          "updatedAt": "2022-10-18T18:39:21Z",
          "publishedAt": "2021-09-01T09:58:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think it would not be hard to implement. You would run a step of adaptivity. We might need a new execution flag for adaptivity though.\nI would look at Transient.C in framework/executioners\nAround line 413 you ll see the logic when a time step failed. Then you could add a run of adaptivity there _problem.adaptMesh(); I think",
                  "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1269242",
                  "updatedAt": "2022-07-04T08:36:56Z",
                  "publishedAt": "2021-09-02T00:47:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "Thank you for your reply.\nNow I am trying to set the new execution flag according to the values of an aux variable ( or an indicator ). But I do not know how to get the pointer to my aux variables. Which function should I use ? I find some functions in FEProblemBase.h:\nvirtual const MooseVariableFieldBase &\n getVariable(THREAD_ID tid,\n             const std::string & var_name,\n             Moose::VarKindType expected_var_type = Moose::VarKindType::VAR_ANY,\n             Moose::VarFieldType expected_var_field_type =\n                 Moose::VarFieldType::VAR_FIELD_ANY) const override;\n\nvirtual MooseVariableFieldBase & getActualFieldVariable(THREAD_ID tid,\n                                                 const std::string & var_name) override;\n\nvirtual MooseVariable & getStandardVariable(THREAD_ID tid, const std::string & var_name) override;\nI do not know what the THREAD_ID tid means. If I should use these functions, what should I do to the THREAD_ID tid ?",
                          "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1271746",
                          "updatedAt": "2022-07-04T08:36:55Z",
                          "publishedAt": "2021-09-02T12:30:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Since you are using the value, you should just use the Coupleable interface. You can find the code for that in interfaces/Coupleable.C and you can see many examples in kernels, like CoupledForce for example.\ntid can be set to _tid, which is the current thread id (=number)\nI'm not sure about using aux variables over indicators for adaptivity. Can you give more details about this?",
                          "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1272409",
                          "updatedAt": "2022-07-04T08:36:50Z",
                          "publishedAt": "2021-09-02T14:49:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "I want to add an additional adaptivity step, if the aux variable value of an element exceed the threshold and this element can still be refined (value > threshold && level < max_h_level). I have tried ValueThresholdMarker before. But the change of the mesh seems to be a step behind the change of the variable values.",
                          "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1273062",
                          "updatedAt": "2022-07-04T08:36:51Z",
                          "publishedAt": "2021-09-02T16:48:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ah it may be (it is) that auxckernels are not run when the solve failed.\nCan you base your mesh change on something else? Like a primary variable or a residual",
                          "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1293141",
                          "updatedAt": "2022-07-04T08:37:05Z",
                          "publishedAt": "2021-09-07T20:26:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "Thank you for the reply.\nI try to put this code into FixedPointSolve.C to check the variable value and the mesh level.\nbool\nFixedPointSolve::check_mesh_and_d()\n{\n  MooseVariable & _d_var = _problem.getStandardVariable(_tid,\"d\");\n  MooseMesh & _mesh = _problem.mesh();\n  for (dof_id_type i = 0; i < _mesh.nElem(); i++)\n  {\n    if (_mesh.elemPtr(i)->active()\n      && (_mesh.elemPtr(i)->level() < _problem.adaptivity().getMaxHLevel())\n      && (_d_var.getElementalValue(_mesh.elemPtr(i)) >= 1.0))\n    {\n      return false;\n    }\n  }\n  return true;\n}\nIt works when using only one processor. But it errors when using more processors.\n===================================================================================\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 106918 RUNNING AT node01\n=   EXIT CODE: 139\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\n===================================================================================\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions\n\nThe _tid here is only declared in the header file but not assigned value. I think this is the problem. Please help me, thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1295738",
                          "updatedAt": "2022-07-04T08:37:05Z",
                          "publishedAt": "2021-09-08T11:22:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What does it return for _tid?\n_tid is the thread id. Did you turn on threading or processes?",
                          "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1296919",
                          "updatedAt": "2022-07-04T08:37:07Z",
                          "publishedAt": "2021-09-08T15:41:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "_tid is 0. I didn't do anything, just declared _tid.",
                          "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1299320",
                          "updatedAt": "2022-07-04T08:37:08Z",
                          "publishedAt": "2021-09-09T03:55:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "mpiexec -n 1 ./myapp-opt -i input.i or ./myapp-opt -i input.i is ok.\nmpiexec -n 4 ./myapp-opt -i input.i would be wrong.",
                          "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1299638",
                          "updatedAt": "2022-07-04T08:37:07Z",
                          "publishedAt": "2021-09-09T06:19:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok tid seems fine.\nLet's get a backtrace on this error. Please compile in debug mode (METHOD=dbg make) then run in a debugger, one way is like this:\nmpirun -n 4 gdb --ex run --ex bt --args ./myapp-opt -i input.i",
                          "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1299667",
                          "updatedAt": "2022-07-04T08:37:09Z",
                          "publishedAt": "2021-09-09T06:30:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "Thread 1 \"myapp-opt\" received signal SIGSEGV, Segmentation fault.\n0x00007ffff614d20a in libMesh::PetscVector::operator()(unsigned long) const () from /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#0  0x00007ffff614d20a in libMesh::PetscVector::operator()(unsigned long) const () from /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#1  0x00007ffff5372d03 in MooseVariableData::getElementalValue(libMesh::Elem const*, Moose::SolutionState, unsigned int) const ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#2  0x00007ffff52f5a0c in FixedPointSolve::check_mesh_and_d() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#3  0x00007ffff5319d4e in FixedPointSolve::solve() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#4  0x00007ffff5f7687e in TimeStepper::step() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#5  0x00007ffff52f981e in Transient::takeStep(double) ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#6  0x00007ffff52f600e in Transient::execute() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#7  0x00007ffff60d420a in MooseApp::executeExecutioner() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#8  0x00007ffff60d8939 in MooseApp::run() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#9  0x0000555555557153 in main ()\nProgram received signal SIGSEGV, Segmentation fault.\n0x00007ffff614d20a in libMesh::PetscVector::operator()(unsigned long) const () from /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#0  0x00007ffff614d20a in libMesh::PetscVector::operator()(unsigned long) const () from /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#1  0x00007ffff5372d03 in MooseVariableData::getElementalValue(libMesh::Elem const*, Moose::SolutionState, unsigned int) const ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#2  0x00007ffff52f5a0c in FixedPointSolve::check_mesh_and_d() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#3  0x00007ffff5319d4e in FixedPointSolve::solve() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#4  0x00007ffff5f7687e in TimeStepper::step() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\nProgram received signal SIGSEGV, Segmentation fault.\n0x00007ffff614d20a in libMesh::PetscVector::operator()(unsigned long) const () from /home/redslime/projects/moose/framework/libmoose-opt.so.0\nProgram received signal SIGSEGV, Segmentation fault.\n0x00007ffff614d20a in libMesh::PetscVector::operator()(unsigned long) const () from /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#5  0x00007ffff52f981e in Transient::takeStep(double) ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#6  0x00007ffff52f600e in Transient::execute() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#7  0x00007ffff60d420a in MooseApp::executeExecutioner() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#8  0x00007ffff60d8939 in MooseApp::run() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#0  0x00007ffff614d20a in libMesh::PetscVector::operator()(unsigned long) const () from /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#0  0x00007ffff614d20a in libMesh::PetscVector::operator()(unsigned long) const () from /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#1  0x00007ffff5372d03 in MooseVariableData::getElementalValue(libMesh::Elem const*, Moose::SolutionState, unsigned int) const ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#1  0x00007ffff5372d03 in MooseVariableData::getElementalValue(libMesh::Elem const*, Moose::SolutionState, unsigned int) const ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#9  0x0000555555557153 in main ()\n#2  0x00007ffff52f5a0c in FixedPointSolve::check_mesh_and_d() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#2  0x00007ffff52f5a0c in FixedPointSolve::check_mesh_and_d() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#3  0x00007ffff5319d4e in FixedPointSolve::solve() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#3  0x00007ffff5319d4e in FixedPointSolve::solve() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#4  0x00007ffff5f7687e in TimeStepper::step() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#4  0x00007ffff5f7687e in TimeStepper::step() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#5  0x00007ffff52f981e in Transient::takeStep(double) ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#5  0x00007ffff52f981e in Transient::takeStep(double) ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#6  0x00007ffff52f600e in Transient::execute() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#6  0x00007ffff52f600e in Transient::execute() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#7  0x00007ffff60d420a in MooseApp::executeExecutioner() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#7  0x00007ffff60d420a in MooseApp::executeExecutioner() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#8  0x00007ffff60d8939 in MooseApp::run() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#8  0x00007ffff60d8939 in MooseApp::run() ()\nfrom /home/redslime/projects/moose/framework/libmoose-opt.so.0\n#9  0x0000555555557153 in main ()\n#9  0x0000555555557153 in main ()",
                          "url": "https://github.com/idaholab/moose/discussions/18748#discussioncomment-1310510",
                          "updatedAt": "2022-07-04T08:37:08Z",
                          "publishedAt": "2021-09-11T15:32:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solving the phase field model for brittle fracture using Multiapp and adptivity",
          "author": {
            "login": "MartimSalgado"
          },
          "bodyText": "Dear Moosers,\nI'm trying to solve the phase field model for brittle fracture using staggered (Picard) iterations. The history variable gets solved in the master (Tensor Mechanics) app and is transferred to the sub (phase field) app. The phase field variable is solved using a TransientApp and then transferred to the master (end of picard iteration).\nI'm getting incorrect crack propagation with angle cracks instead of horizontal cracks (as it should be). I think this may be due to the method used to transfer these variables or due to the meshes used.\nI'm cloning the master mesh and independently using the same markers to h-adapt each mesh so I get the same mesh after each time step.\nI'm using mesh function transfers (copy transfers are not possible since the transfer happens before the adaptivity step that would lead to the sub app having the same mesh as the master.\nAny suggestions for fixing this problem? I'm sending both input files attached.\nThanks!\nsub_sent_staggered.zip",
          "url": "https://github.com/idaholab/moose/discussions/18813",
          "updatedAt": "2022-07-04T11:07:12Z",
          "publishedAt": "2021-09-13T12:07:57Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "First, have you tried the picard iteration without adaptivity?\nA few comments:\n\nwithout adaptivity, you can use MultiAppCopyTransfer\nI usually transfer displacements from master to sub and damage from sub to master. In both master and sub input files, I add materials to recompute all quantities, including fracture driving energy so that I do not need to transfer them.",
                  "url": "https://github.com/idaholab/moose/discussions/18813#discussioncomment-1320547",
                  "updatedAt": "2022-07-04T11:07:14Z",
                  "publishedAt": "2021-09-13T20:33:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "I created LevelSetMeshRefinementTransfer 5 years ago for this same concept. There might be a better way to do it now, but if not you can take a look at it for some inspiration.",
                          "url": "https://github.com/idaholab/moose/discussions/18813#discussioncomment-1320876",
                          "updatedAt": "2022-07-04T11:07:15Z",
                          "publishedAt": "2021-09-13T21:59:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MartimSalgado"
                          },
                          "bodyText": "@jiangwen84 Thanks for your reply. I was trying to avoid recomputing the history variable, but I will follow your advice.\n@aeslaughter that's the perfect method to couple the adaptivity of my apps, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/18813#discussioncomment-1322823",
                          "updatedAt": "2022-07-04T11:07:16Z",
                          "publishedAt": "2021-09-14T09:43:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "There is an app for phase field fracture: RACCOON. This tutorial is doing exactly what you are describing.",
                  "url": "https://github.com/idaholab/moose/discussions/18813#discussioncomment-1322760",
                  "updatedAt": "2022-07-04T11:07:17Z",
                  "publishedAt": "2021-09-14T09:29:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "MartimSalgado"
                          },
                          "bodyText": "If only I had known.... Thanks @hugary1995! I'll definitely start using the RACOON",
                          "url": "https://github.com/idaholab/moose/discussions/18813#discussioncomment-1323105",
                          "updatedAt": "2022-07-04T11:07:17Z",
                          "publishedAt": "2021-09-14T10:42:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Smeared cracking rotation with respect to a principal axis",
          "author": {
            "login": "aashiquear"
          },
          "bodyText": "I like to model smeared cracking of a spherical particle by modeling a plane (half circle) in RZ coordinate. Now, in my understanding ComputeSmearedCrackingStress rotate the crack stiffness towards the principal axis (in my case r or z or theta) direction. But to model the half-circle as a spherical particle, the principal direction at each integration point needs to be rotated at an angle delta with respect to the r direction for the smeared cracking stiffness ratio.\ndelta would be a variable at each quadratic point. I am wondering how can I input delta into ComputeSmearedCrackingStress to rotate with respect to the r axis?",
          "url": "https://github.com/idaholab/moose/discussions/18786",
          "updatedAt": "2022-07-06T21:42:36Z",
          "publishedAt": "2021-09-07T19:58:31Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@ngrilli @jiangwen84",
                  "url": "https://github.com/idaholab/moose/discussions/18786#discussioncomment-1321236",
                  "updatedAt": "2022-07-06T21:42:37Z",
                  "publishedAt": "2021-09-14T00:31:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I don't believe you can do this without modifying the source code. Look at the method around \n  \n    \n      moose/modules/tensor_mechanics/src/materials/ADComputeSmearedCrackingStress.C\n    \n    \n         Line 287\n      in\n      7df3b09\n    \n  \n  \n    \n\n        \n          \n           ADComputeSmearedCrackingStress::updateLocalElasticityTensor() \n        \n    \n  \n\n where we perform the rotation.\n@bwspenc knows about the smeared crack models in moose better than anyone.",
                  "url": "https://github.com/idaholab/moose/discussions/18786#discussioncomment-1322891",
                  "updatedAt": "2022-07-06T21:42:35Z",
                  "publishedAt": "2021-09-14T09:56:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ComputeVariableEigenStrain",
          "author": {
            "login": "uchiha-JN"
          },
          "bodyText": "I am using AD for my simulation and I need to use the material module \"ComputeVariableEigenStrain\" in TensorMechanics.\nHowever, I cannot find its AD version and my input file won.t run otherwise . Can someone kindly help me out ?\nAm I not searching in the right place or does it not exist?",
          "url": "https://github.com/idaholab/moose/discussions/18797",
          "updatedAt": "2022-06-13T08:28:46Z",
          "publishedAt": "2021-09-09T12:01:15Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@hugary1995",
                  "url": "https://github.com/idaholab/moose/discussions/18797#discussioncomment-1303550",
                  "updatedAt": "2022-06-13T08:28:45Z",
                  "publishedAt": "2021-09-09T19:40:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I guess it does not exist. You should be able to mix AD with non-AD though.",
                          "url": "https://github.com/idaholab/moose/discussions/18797#discussioncomment-1304143",
                          "updatedAt": "2022-06-13T08:28:53Z",
                          "publishedAt": "2021-09-09T23:21:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "uchiha-JN"
                          },
                          "bodyText": "Okay... Thanks for your reply.\n\nI did not know AD and non-AD could be mixed . Thanks for the info. It gives me hope and an idea\nI keep getting errors about some properties being declared as AD while being requested as regular and vice versa. I guess that will require me to get into the CPP codes and header files. an example of the error message is below\n\nerror message\n*** ERROR ***\nThe requested AD material property mechanical_strain is declared as a regular material property. Either retrieve it as a regular material property with getMaterialProperty or declare it as an AD property with declareADProperty.",
                          "url": "https://github.com/idaholab/moose/discussions/18797#discussioncomment-1305920",
                          "updatedAt": "2022-06-13T08:28:55Z",
                          "publishedAt": "2021-09-10T09:28:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It can be mixed though there might be some difficulties on the way.\nFor example for this property (which is defined behind the scenes by the Tensor_Mechanics action I think), if you cannot sub the non_AD kernel that requires it with an AD version, then you will have to make a non-AD copy of the material property, will obviously loose the derivatives information.",
                          "url": "https://github.com/idaholab/moose/discussions/18797#discussioncomment-1307831",
                          "updatedAt": "2022-06-13T08:28:54Z",
                          "publishedAt": "2021-09-10T16:38:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "uchiha-JN"
                          },
                          "bodyText": "Gotcha... It did come with difficulties. Just like you said. And yes, I believe you are right about me losing the derivative information.\nHowever, I managed to make a copy like you suggested and changed a few things to make it work just fine.\nThank you @GiudGiud  and @jiangwen84  for your help. I really appreciate it.\nI am now running a simulation with the new kernel and I hope I do not run into any more issues :)",
                          "url": "https://github.com/idaholab/moose/discussions/18797#discussioncomment-1310976",
                          "updatedAt": "2022-06-13T08:29:02Z",
                          "publishedAt": "2021-09-11T19:50:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Sorry I'm late on this. Glad you've figured it out! You can also make a pull request to add the AD version of CompiteVariableEigenstrain to moose. I believe such contribution is very welcome.",
                          "url": "https://github.com/idaholab/moose/discussions/18797#discussioncomment-1322848",
                          "updatedAt": "2022-06-13T08:29:02Z",
                          "publishedAt": "2021-09-14T09:49:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Transfer of variable-dependent property between multiapps",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hi Moosers,\nI'm trying to pass a material property (K) from the main app to the sub app  using multiapps, as code below in main app:\n[MultiApps]\n  [sub]\n    type = TransientMultiApp\n    input_files = sub.i\n    cli_args = 'K=${K}'\n    execute_on = 'TIMESTEP_END'\n  []\n[]\n\nand define K as a GenericMaterial in sub.\nWhen K is a constant, it works well. Now I want to make it variable (temperature) -dependent, but it fails.\nThen I tried to define it as Auxvariable and use [transfer] block\n[to_K]\n     type = MultiAppCopyTransfer\n     multi_app = sub\n     direction = to_multiapp\n     variable = K\n     source_variable = K\n   []\n\nand retrieve it with MaterialRealAux, but it also don't work. Is this the right way to solve the problem?  How can I transfer this kind of nonlinear variable-dependent material property to sub app? Thanks.\nAny comments or suggestions are highly appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/18790",
          "updatedAt": "2022-08-02T18:18:11Z",
          "publishedAt": "2021-09-08T14:26:40Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe first block you pasted gives a command line argument to the subapp. More than that needs to be transferred. The whole field of material property values needs to make its way over.\nThe second block is the way to go. What do you mean by it doesnt work? Does K exist as a variable on both apps? Are they both populated with the right values?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1296830",
                  "updatedAt": "2022-07-07T04:44:30Z",
                  "publishedAt": "2021-09-08T15:24:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@GiudGiud Thanks for replying.\nYes, K(T) is used in both apps, and T is calculated in main, after K is updated I want it to be passed to sub.\nI define K as Auxvariable and Auxkernel in both apps\n[AuxVariables]\n  [K]\n  []\n[]\n[AuxKernels]\n  [K]\n    type = ADMaterialRealAux\n    variable = K\n    property = K\n  []\n[]\n\nand in main app, define K as material property\n  [K]\n    type = ADPiecewiseLinearInterpolationMaterial\n    variable = 'T'\n    property = 'K'\n    x = '300    600'\n    y = '42.47  21.235'\n    outputs = exodus\n  []\n\nThe error message is\n\n*** ERROR ***\nThe following error occurred in the object \"K\", of type \"ADMaterialRealAux\".\nNodal AuxKernel 'K' attempted to reference material property 'property'\nConsider using an elemental auxiliary variable for 'K'.\n\nWhat may be the problems? and how can I retrieve K in the sub in the right way? Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1297015",
                          "updatedAt": "2022-07-07T05:35:37Z",
                          "publishedAt": "2021-09-08T15:54:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "looks like an issue with the type of the variable.\nCan you make variable K a CONST MONOMIAL?  family=MONOMIAL, order = CONST\nplease use the triple quotes to format your posts",
                          "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1297051",
                          "updatedAt": "2022-07-07T04:44:32Z",
                          "publishedAt": "2021-09-08T15:59:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Hi, I changed K to \"  order = CONSTANT    family = MONOMIAL\" , and  has error below\n\n*** ERROR ***\nThe following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\nMaterial property 'K', requested by 'K' is not defined on block 0\n\n(used the triple quotes but it doesn't show as code format :(",
                          "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1297627",
                          "updatedAt": "2022-07-07T04:44:32Z",
                          "publishedAt": "2021-09-08T17:57:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "great we came through the first error.\nok so now, is there multiple subdomains in your simulation\nAlso can you please rename everything? Like everything is called K and it s really confusing.\nHow about K_var, K_material, K_matprop, K_auxkernel for the names",
                          "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1297983",
                          "updatedAt": "2022-07-07T04:45:29Z",
                          "publishedAt": "2021-09-08T19:25:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@GiudGiud Thank you for your patience.\nGreat advice! Now the error message is more clear:\n\n*** ERROR ***\nThe following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\nMaterial property 'K', requested by 'K_AuxKer_Sub' is not defined on block 0\n\nNow the question seems down to how to convert the AuxVariable K to a material property in sub app.",
                          "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1298087",
                          "updatedAt": "2022-07-07T04:45:29Z",
                          "publishedAt": "2021-09-08T19:58:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh this is from the subapp\nOk the issue is that the material property is not defined in the subapp. It s only defined in the main app.\nSo you should use a Transfer to copy the auxvariable from the main app to the subapp\nSee this\nhttps://mooseframework.inl.gov/syntax/Transfers/index.html#!\nThen you can work on turning the aux variable into a material property.",
                          "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1298095",
                          "updatedAt": "2022-07-07T04:45:29Z",
                          "publishedAt": "2021-09-08T20:02:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Hi, as you can see from my initial question, I have the [Transfer] block to transfer K from main to sub already.",
                          "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1301139",
                          "updatedAt": "2022-08-19T07:16:55Z",
                          "publishedAt": "2021-09-09T12:04:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok but have you created the material property in the subapp?",
                          "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1302018",
                          "updatedAt": "2022-08-19T07:17:52Z",
                          "publishedAt": "2021-09-09T14:38:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "actually you need some material that will have the same value as a variable. There are a few of those in Navier Stokes, but in the framework I m not sure?\nIf you cant find one, then I suggest you use the VarCouplingMaterial test object,\nTest objects may be used by passing the '--allow-test-objects' flag on the command line\nSet the \"var\" argument to the K variable in the subapp",
                          "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1302298",
                          "updatedAt": "2022-08-19T07:17:52Z",
                          "publishedAt": "2021-09-09T15:24:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Now the question seems down to how to convert the AuxVariable K to a material property in sub app.\n\nSomething like this can covert an AuxVariable/NonlinearVariable  to a material property\n[AuxVariables]\n  [vt]\n  []\n[]\n\n[Materials]\n  [diff]\n    type = ParsedMaterial\n    f_name = D\n    args = 'vt'\n    function = 'vt'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18790#discussioncomment-1304807",
                          "updatedAt": "2022-08-19T07:17:52Z",
                          "publishedAt": "2021-09-10T04:38:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Generate refined mesh with elements as the center",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "Hi,\nI have a square domain and it is symmetric about the x-axis. I need refined mesh around the x-axis but I still want to keep a line of elements as the center, not nodes. Is there a way to achieve that in moose? Simple refinement would always break central elements.\nBo",
          "url": "https://github.com/idaholab/moose/discussions/18802",
          "updatedAt": "2023-07-06T07:45:20Z",
          "publishedAt": "2021-09-10T16:11:47Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Bo\nThere is. You should define the center element to be in a different block then refine by block. This can be done easily in this PR: #18744\nBut in the mean time, you can use adaptivity to do it like in the example we are adding in this PR:\n#18657\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18802#discussioncomment-1307792",
                  "updatedAt": "2023-07-06T07:45:21Z",
                  "publishedAt": "2021-09-10T16:24:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "I think I did not make myself clear. I want to have odd number of elements in the y direction and they are dense mesh. The usual refinement will always split the initial elements and make a line of nodes on the x-axis. I do not care if I can keep the exact original central elements, I just want a line of refined element on the x-axis. The examples provided do not solve this issue.",
                          "url": "https://github.com/idaholab/moose/discussions/18802#discussioncomment-1308032",
                          "updatedAt": "2023-07-06T07:45:21Z",
                          "publishedAt": "2021-09-10T17:33:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "well we can\u2019t split elements in 3 parts in one direction. So unless I\u2019m missing something this isn\u2019t possible through refinement\nbut you could just change the ny in a RectiliearMeshGenerator and refine that way while keeping an element on the x axis",
                          "url": "https://github.com/idaholab/moose/discussions/18802#discussioncomment-1308055",
                          "updatedAt": "2023-07-06T07:46:20Z",
                          "publishedAt": "2021-09-10T17:41:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "If only quad in 2D or cube in 3D is needed, you can try CartesianMeshGenerator, which has more flexibility on controlling the element sizing than GeneratedMeshGenerator.",
                          "url": "https://github.com/idaholab/moose/discussions/18802#discussioncomment-1308366",
                          "updatedAt": "2023-07-06T07:46:55Z",
                          "publishedAt": "2021-09-10T19:15:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}