{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMS0yMFQxMDo1MDozMS0wNzowMM4ARexL"
    },
    "edges": [
      {
        "node": {
          "title": "Mesh adaptivity during one linear step",
          "author": {
            "login": "am-tc01"
          },
          "bodyText": "Hi,\nI am doing steady state thermo-fluid simulations with highly non-linear material properties where the solution changes drastically during one linear iteration. Now since the mesh adaptivity uses variable values from the previous step, it is sometimes difficult to converge. My question is, is it possible to do mesh adaptivity during one linear iteration?\nRegards!",
          "url": "https://github.com/idaholab/moose/discussions/22734",
          "updatedAt": "2022-12-10T07:25:59Z",
          "publishedAt": "2022-11-17T14:33:21Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nno we do not support that currently. We generally would not want to do that because unconverged solution vectors can be completely unphysical, there is no guarantee where the non linear solve lands at every iteration, only the final converged step may be physical.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22734#discussioncomment-4199846",
                  "updatedAt": "2022-11-21T23:11:24Z",
                  "publishedAt": "2022-11-21T23:11:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is the solve with adaptivity not converging though? You may run multiple cycles of adaptivity per timestep",
                          "url": "https://github.com/idaholab/moose/discussions/22734#discussioncomment-4199852",
                          "updatedAt": "2022-11-21T23:13:27Z",
                          "publishedAt": "2022-11-21T23:13:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "When the ACInterface module changes Kappa, why does it not converge\uff1f",
          "author": {
            "login": "biaogxb"
          },
          "bodyText": "I carefully read the snow.i example and found that the \u2018InterfaceOrientationMaterial\u2019 is used to calculate the kappa\uff08eps in that article\uff09 value I need,\n\nso I changed the code for calculating \u2018ACInterface\u2019 as follows\uff1a\n'[./anisoACinterface] type = ACInterface variable = eta  kappa_name=eps [../]'\n'[./material] type = InterfaceOrientationMaterial op = eta [../]'\n\nI don't know why my calculation is not convergent. Can't I directly fill \u2018eps\u2019 into ACInterface as \u2018kappa\u2019\uff1f\nHere is my input file\uff1a\ninput.txt\nCan someone help me? Thank you\uff01",
          "url": "https://github.com/idaholab/moose/discussions/22664",
          "updatedAt": "2023-01-03T23:51:22Z",
          "publishedAt": "2022-11-11T03:20:49Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "What is eps?",
                  "url": "https://github.com/idaholab/moose/discussions/22664#discussioncomment-4113505",
                  "updatedAt": "2022-11-11T03:26:17Z",
                  "publishedAt": "2022-11-11T03:26:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "'eps' represents the anisotropic interface parameter in the 'modules/phase_field/src/materials/InterfaceOrientationMaterial.C' source code.\uff08\uff1f\uff09\n\n\nI'm not sure if this is the way to couple the anisotropic interface parameter\uff08eps in InterfaceOrientationMaterial.C\uff09into the ACInterface. Do you have any suggestions\uff1f\nI just want to set the kappa in the ACInterface as shown in the following figure\uff1a\n\n\nDo you have any suggestions\uff1f",
                          "url": "https://github.com/idaholab/moose/discussions/22664#discussioncomment-4113612",
                          "updatedAt": "2022-11-11T03:56:21Z",
                          "publishedAt": "2022-11-11T03:51:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so is eps supposed to be the same as kappa? Pardon my ignorance.\nI would start from a working example, then make the minimal amounts of changes by replacing the object that defines kappa with a slightly modified version",
                          "url": "https://github.com/idaholab/moose/discussions/22664#discussioncomment-4184543",
                          "updatedAt": "2022-11-19T15:14:46Z",
                          "publishedAt": "2022-11-19T15:14:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Ok, thank you. If there is any progress, I hope you can remind me. Thank you very much\uff01",
                          "url": "https://github.com/idaholab/moose/discussions/22664#discussioncomment-4194823",
                          "updatedAt": "2022-11-21T11:52:41Z",
                          "publishedAt": "2022-11-21T11:52:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I won\u2019t be working on this @biaogxb . Please feel free to let us know your progress with this",
                          "url": "https://github.com/idaholab/moose/discussions/22664#discussioncomment-4199800",
                          "updatedAt": "2022-11-21T22:59:52Z",
                          "publishedAt": "2022-11-21T22:59:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Without \"Node Sets\"",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "All,\nI am using a mesh file generated by CUBIT and the MOOSE run generates a strange result.\nI removed \"Node Sets\" and then the result looks good.\nPlease let me know if MOOSE can run without \"Node Sets\" while \"Side Sets\" are kept.\nPlease help,\nS. Thomas",
          "url": "https://github.com/idaholab/moose/discussions/22744",
          "updatedAt": "2022-12-05T18:36:40Z",
          "publishedAt": "2022-11-18T00:55:24Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe should be able to load both node sets and side sets from a cubit generated mesh.\nThere must be something else wrong, like the boundary conditions are not set on the proper sideset.\nPlease note that MOOSE automatically converts nodesets to sidesets at the end of the mesh generation process\nsee this page\nhttps://mooseframework.inl.gov/source/mesh/MooseMesh.html#more_detail\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22744#discussioncomment-4192022",
                  "updatedAt": "2022-11-21T04:59:05Z",
                  "publishedAt": "2022-11-21T04:59:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you very much Guillaume.\nI would like to use this mesh file without Node Sets because it seems working.\nPlease let me know if it is OK.\nSincerely,\nS. Thomas",
                          "url": "https://github.com/idaholab/moose/discussions/22744#discussioncomment-4199474",
                          "updatedAt": "2022-11-21T21:48:27Z",
                          "publishedAt": "2022-11-21T21:48:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If the mesh file has the side sets you need then it should work.\nyou will get an error if you try to apply a boundary condition or an interface kernel on a boundary that does not exist\nyou should also be able to see what side set and node set exist in paraview so there s really no way to get it wrong",
                          "url": "https://github.com/idaholab/moose/discussions/22744#discussioncomment-4199586",
                          "updatedAt": "2022-11-21T22:08:39Z",
                          "publishedAt": "2022-11-21T22:08:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE on WSL2/Ubuntu-20.04",
          "author": {
            "login": "oMuransky"
          },
          "bodyText": "Hi Guys,\nI'm trying to repeat the MOOSE installation process from a few of weeks ago on WSL2/Ubuntu but it does not work anymore. When running \"make\" I'm getting a fatal error (missing file:  MooseRevision.h)\nMy current installation process on clean WSL2/Ubuntu:\n#---------------\n# Update Ubuntu & Install pre-requisites \n#---------------\nsudo apt update \nsudo apt upgrade\nsudo apt install build-essential python3 libmpich-dev git python-is-python3 cmake m4 python3-dev \nsudo apt install liblapack-dev libblas-dev libssl-dev bison flex\ncd ~\n#---------------\n# Install/Update cmake\n#---------------\nwget https://github.com/Kitware/CMake/releases/download/v3.23.0/cmake-3.23.0.tar.gz\ntar -zxvf cmake-3.23.0.tar.gz \ncd cmake-3.23.0/\n./bootstrap\nmake\nsudo make install\n#---------------\n# Remove mpich & Install openmpi\n#---------------\nsudo apt-get purge --auto-remove mpich \nsudo apt install openmpi-bin\nwhich runmpi\nrunmpi --version\n#---------------\n# Install MOOSE\n#---------------\nmkdir moose\ncd moose\ngit clone https://github.com/idaholab/moose.git\ncd moose/\ncd scripts/\n./update_and_rebuild_petsc.sh --download-mumps=no --with-mumps=no\n./update_and_rebuild_libmesh.sh \ncd ../framework/\nmake -j 8 <== fails here (fatal error: MooseRevision.h: No such file or directory)",
          "url": "https://github.com/idaholab/moose/discussions/22764",
          "updatedAt": "2022-11-21T21:18:03Z",
          "publishedAt": "2022-11-20T21:09:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Can you scroll up and check if there are any other errors or warnings further up?",
                  "url": "https://github.com/idaholab/moose/discussions/22764#discussioncomment-4190354",
                  "updatedAt": "2022-11-20T21:11:57Z",
                  "publishedAt": "2022-11-20T21:11:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "oMuransky"
                          },
                          "bodyText": "Hello Daniel,\nNo errors or warnings during the \"moose make\" process, however, a few warnings during the \"./update_and_rebuild_libmesh.sh\" process (attached) - not sure why I'm getting these hdf5 warnings because it is installing the hdf5 while running \"./update_and_rebuild_petsc.sh --download-mumps=no --with-mumps=no\"",
                          "url": "https://github.com/idaholab/moose/discussions/22764#discussioncomment-4190387",
                          "updatedAt": "2022-11-20T21:22:50Z",
                          "publishedAt": "2022-11-20T21:22:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this mooserevision.h missing error is a missing python package",
                          "url": "https://github.com/idaholab/moose/discussions/22764#discussioncomment-4191800",
                          "updatedAt": "2022-11-21T03:57:08Z",
                          "publishedAt": "2022-11-21T03:57:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "see this\n#22035 (reply in thread)",
                          "url": "https://github.com/idaholab/moose/discussions/22764#discussioncomment-4191808",
                          "updatedAt": "2022-11-21T03:57:54Z",
                          "publishedAt": "2022-11-21T03:57:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "oMuransky"
                  },
                  "bodyText": "Thanks for pointing me to this thread, Guillaume. Interesting, I installed \"python3-dev\", but the \"packaging\" was still missing (this is new). All what needs to be done is: \"pip install packaging\" and then the \"moose make\" process runs without errors. Many thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/22764#discussioncomment-4191973",
                  "updatedAt": "2022-11-21T04:42:18Z",
                  "publishedAt": "2022-11-21T04:42:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "oMuransky"
                  },
                  "bodyText": "The following process installs NEML, MOOSE, DEER, BLACKBEAR, and links them. Works for me on a clean WSL2/Ubunutu-20.04 (today).\n#---------------\nUpdate Ubuntu & Install pre-requisites\n#---------------\nsudo apt update\u200b\nsudo apt upgrade\nsudo apt install build-essential python3 libmpich-dev git python-is-python3 cmake m4 python3-dev\u200b\nsudo apt install liblapack-dev libblas-dev libssl-dev bison flex\ncd ~\u200b\n#---------------\nInstall required python packages\n#---------------\npip install packaging\n#---------------\nInstall/update cmake\n#---------------\nwget https://github.com/Kitware/CMake/releases/download/v3.23.0/cmake-3.23.0.tar.gz\ntar -zxvf cmake-3.23.0.tar.gz\ncd cmake-3.23.0/\n./bootstrap\nmake\nsudo make install\n#---------------\nRemove MPICH and install OPENMPI (not required)\n#---------------\nsudo apt-get purge --auto-remove mpich\nsudo apt install openmpi-bin\n#---------------\nExport paths in .bashrc file or .bash_profile\n#---------------\nexport MOOSE_DIR=$MOOSE_DIR/home/path-to-moose/moose\nexport NEML_DIR=$NEML_DIR/home/path-to-neml/neml\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH/home/path-to-neml/neml\nsource ~/.bashrc\n#---------------\nInstall NEML\n#---------------\nmkdir moose\u200b\ncd moose\ngit clone https://github.com/Argonne-National-Laboratory/neml.git\ncd neml/\ncmake .\nmake -j 8\n#---------------\nInstall MOOSE\n#---------------\ncd ..\ngit clone https://github.com/idaholab/moose.git\ncd moose/\ncd scripts/\n./update_and_rebuild_petsc.sh --download-mumps=no --with-mumps=no\n./update_and_rebuild_libmesh.sh\nexport MOOSE_DIR=/home/path-to-moose/moose\ncd ../framework/\nmake -j 8\n#---------------\nInstall DEER\n#---------------\ncd ..\ngit clone https://github.com/Argonne-National-Laboratory/deer.git\ncd deer/\nmake -j 8\n#---------------\nInstall BLACKBEAR\n#---------------\ncd ..\ngit clone https://github.com/idaholab/blackbear.git\ncd blackbear/\ngit submodule init\ngit submodule update contrib/neml\nmake -j 8",
                  "url": "https://github.com/idaholab/moose/discussions/22764#discussioncomment-4198845",
                  "updatedAt": "2022-11-24T21:17:23Z",
                  "publishedAt": "2022-11-21T20:15:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Do you think the swap between MPICH and OpenMPI was necessary? We've swapped back and forth over the years. This is more of a curiosity, than troubleshooting question. Cheers!",
                          "url": "https://github.com/idaholab/moose/discussions/22764#discussioncomment-4199149",
                          "updatedAt": "2022-11-21T21:00:35Z",
                          "publishedAt": "2022-11-21T21:00:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "oMuransky"
                          },
                          "bodyText": "Hi Jason, we are trying to test the openmpi, because we do have some memory leak when running crystal plasticity simulations in DEER - it seems to be related to MPI, but I'm unsure as yet if replacing MPICH with OpenMPI will sort the problem. Cheers",
                          "url": "https://github.com/idaholab/moose/discussions/22764#discussioncomment-4199273",
                          "updatedAt": "2022-11-21T21:18:04Z",
                          "publishedAt": "2022-11-21T21:18:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to create a rigid body?",
          "author": {
            "login": "Wang-Yihu"
          },
          "bodyText": "How to create a rigid body in MOOSE tensor mechanics? I try to make a material of 1000e9 Pa youngs_modulus or 0.4999 poissons_ratio, but it cannot get converge.\nHow to create a rigid body in MOOSE Multiphysics?",
          "url": "https://github.com/idaholab/moose/discussions/22750",
          "updatedAt": "2022-12-10T07:26:24Z",
          "publishedAt": "2022-11-18T14:43:18Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc @recuero",
                  "url": "https://github.com/idaholab/moose/discussions/22750#discussioncomment-4179104",
                  "updatedAt": "2022-11-18T17:16:28Z",
                  "publishedAt": "2022-11-18T17:16:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "bwspenc"
                  },
                  "bodyText": "We don't currently have a rigid body capability. This would be a fairly major undertaking, and we don't really have a need for this for currently funded projects, so I don't anticipate that this is something we would develop in the near future.\nIn the mean time, I think your best bet is to set the Young's modulus to a high value as you suggested. Setting the Poisson's ratio to something close to 0.5 won't make the block rigid -- it will just make it nearly incompressible and make the problem ill conditioned. I guess I don't know what the stiffnesses of your other materials is, so it's hard to say whether the high Young's modulus you suggested would be an issue. You'll generally have better luck converging problems with poor conditioning using LU rather than iterative preconditioners. Using automatic scaling can help too. These settings in your Executioner block might be helpful, although I can't say for sure since I haven't seen the rest of the input:\n  automatic_scaling = true\n  compute_scaling_once = true\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = ' lu       superlu_dist",
                  "url": "https://github.com/idaholab/moose/discussions/22750#discussioncomment-4198943",
                  "updatedAt": "2022-11-21T20:31:36Z",
                  "publishedAt": "2022-11-21T20:31:35Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to define an variable coupled AD ElasticityTensor correctly?",
          "author": {
            "login": "echo1115"
          },
          "bodyText": "Hi all,\nI want to define an variable (or aux) coupled AD ElasticityTensor, but it seems that most ElasticityTensor classes in MOOSE are variable (or aux) independed , which I couldn't refer to clearly.\nThe poissons ratio and youngs modulus in my case  are:\npoissons_ratio = 0.23 ;\nyoungs_modulus= 3.0e10* exp(-porosity)* Mm  , where porosity = 0.8\nMm= (1.0+0.23F)(1.0+1.5e-4*(T-293.15)) , where T and F are variables to be coupled.\nI used much time to create such a class and experienced many compilation errors. Coincidentally, it can be compiled successfully now. However, I'm not sure if there are potential hidden errors in it that will make my future calculations wrong. So I paste my h file and C file here.\nActurally, I'm quite uncertain about whether I should define the\n\n_temp and _fluence as 'ADVariableValue ' ?\n_porosity as 'Real' ?\n_youngs_modulus and _poissons_ratio as 'ADReal' ?\nmm as 'ADReal'?\n\nThe current way i defined them was just because the compilation succeeded. Maybe someone can address my concerns. Thanks in advance.\nADComputeVariableCoupledElasticityTensor.h :\n#pragma once\n\n#include \"ComputeElasticityTensorBase.h\"\n\nclass ADComputeVariableCoupledElasticityTensor : public ADComputeElasticityTensorBase\n{\npublic:\n  static InputParameters validParams();\n\n  ADComputeVariableCoupledElasticityTensor(const InputParameters & parameters);\n\nprotected:\n  virtual void computeQpElasticityTensor() override;\n\n  /*new parameters*/\n  const ADVariableValue & _temp;\n  const ADVariableValue & _fluence;\n  const Real & _porosity;\n\n  ADReal _youngs_modulus;\n  ADReal _poissons_ratio;\n\n  using ADComputeElasticityTensorBase::name;\n  using ADComputeElasticityTensorBase::_elasticity_tensor_name;\n  using ADComputeElasticityTensorBase::issueGuarantee;\n  using ADComputeElasticityTensorBase::isParamValid;\n  using ADComputeElasticityTensorBase::_elasticity_tensor;\n  using ADComputeElasticityTensorBase::_qp;\n  using ADComputeElasticityTensorBase::_effective_stiffness;\n};\n\nADComputeVariableCoupledElasticityTensor.C :\n#include \"ADComputeVariableCoupledElasticityTensor.h\"\n#include \"MooseVariable.h\"\n#include \"Coupleable.h\"\n\nregisterMooseObject(\"myApp\", ADComputeVariableCoupledElasticityTensor);\n\nInputParameters\nADComputeVariableCoupledElasticityTensor::validParams()\n{\n  InputParameters params = ADComputeElasticityTensorBase::validParams();\n  params.addClassDescription(\"Compute an elasticity tensor.\");\n\n  params.addCoupledVar(\"temperature\", 1000.0, \"Coupled temperature in units of Kelvin\");\n  params.addCoupledVar(\"fluence\",0.0,\"fluence.\");\n  params.addParam<Real>(\"porosity\",0.8,\" porosity\");\n\n  return params;\n}\n\nADComputeVariableCoupledElasticityTensor::ADComputeVariableCoupledElasticityTensor(\n    const InputParameters & parameters)\n    : ADComputeElasticityTensorBase(parameters),\n\n    _temp(adCoupledValue(\"temperature\")),\n    _fluence(adCoupledValue(\"fluence\")),\n    _porosity(getParam<Real>(\"porosity\"))\n{\n  // all tensors created by this class are always isotropic\n  issueGuarantee(_elasticity_tensor_name, Guarantee::ISOTROPIC);\n}\n\nvoid\nADComputeVariableCoupledElasticityTensor::computeQpElasticityTensor()\n{\n    ADReal mm;\n    mm = (1.0+0.23*_fluence[_qp])*(1.0+1.5e-4*(_temp[_qp]-293.15));\n    _youngs_modulus = 3.0e10*exp(-_porosity)*mm;\n    _poissons_ratio = 0.23;\n  // Assign elasticity tensor at a given quad point\n  _elasticity_tensor[_qp].fillSymmetricIsotropicEandNu(_youngs_modulus, _poissons_ratio);\n}",
          "url": "https://github.com/idaholab/moose/discussions/22587",
          "updatedAt": "2022-11-21T07:18:24Z",
          "publishedAt": "2022-11-03T16:57:37Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAll the variable and number types seem appropriate.\nUsing ADReal for _youngs_modulus correctly makes sure the derivatives in mm are not lost when computing the young s modulus.\n_poissons_ratio does not need to be an ADReal, it could be a Real. This is inconsequential though.\nUsing ADVariableValue for _temp and _fluence correctly makes sure the variables carry the derivative information.\nIf you are investigating issues with your Jacobian, please use the Jacobian analyzer.\nhttps://mooseframework.inl.gov/help/development/analyze_jacobian.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22587#discussioncomment-4191341",
                  "updatedAt": "2022-11-21T01:52:49Z",
                  "publishedAt": "2022-11-21T01:52:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "Thanks for your reply and suggestions! @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/22587#discussioncomment-4192701",
                          "updatedAt": "2022-11-21T07:17:38Z",
                          "publishedAt": "2022-11-21T07:17:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "converting two phase field problem with aux variable",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "I am trying to convert my two phase problem where order parameter eta serves for both phases as eta and (1-eta).  For this i am using DerivativeTwoPhaseMaterial and BarrierFunctionMaterial and  I am getting a good convergence.\nHowever, when i convert the same code with eta1 as auxvaribale and eta2 as variable and DerivativeMultiPhaseMaterial and MultiBarrierFunctionMaterial with the lagrangeconstraint for eta1+eta2=1. There is a convergence issue. I have changed the epsilon parameter in SwitchingFunctionConstraintLagrange. Still the issue persists.\nthe code is attached for the auxvariable case\n# input file.\n# Define mesh. 2-D system, simulation size 20*5.\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 40\n  xmax =20\n  ny=5\n  ymax=5\n[]\n# Creating functions for initial conditions.\n[Functions]\n[./ic_func_eta1]\n  type = ParsedFunction\n  value = 0.5*(1.0+1.0*tanh((x-5)*2))\n[../]\n[./ic_func_eta2]\n  type = ParsedFunction\n  value = 0.5*(1.0-1.0*tanh((x-5)*2))\n[../]\n[./ic_func_w]\n  type = ParsedFunction\n  value = 0\n[../]\n[./ic_func_pot]\ntype = ParsedFunction\nvalue = -0.225*(1.0-tanh((x-5)*2))\n[../]\n[]\n# Aux Variable.\n[AuxVariables]\n  [./eta1]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = FunctionIC\n      function = ic_func_eta1\n    [../]\n  [../]\n[]\n# variables. w: chemical potential, eta: order parameter, pot: applied overpotential.\n[Variables]\n  [./w]\n  [../]\n  [./eta2]\n  [../]\n  [./pot]\n  [../]\n  [./lambda]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 1.0\n  [../]\n[]\n\n# Initial conditions.\n[ICs]\n  [./eta2]\n    variable = eta2\n    type = FunctionIC\n    function = ic_func_eta2\n  [../]\n  [./w]\n    variable = w\n     type = FunctionIC\n     function = ic_func_w\n  [../]\n  [./pot]\n    variable = pot\n    type = FunctionIC\n    function = ic_func_pot\n  [../]\n[]\n# Boundary conditions.\n[BCs]\n[./bottom_eta2]\n  type = NeumannBC\n  variable = 'eta2'\n  boundary = 'bottom'\n  value = 0\n[../]\n[./top_eta2]\n  type = NeumannBC\n  variable = 'eta2'\n  boundary = 'top'\n  value = 0\n[../]\n[./left_eta2]\n  type = DirichletBC\n  variable = 'eta2'\n  boundary = 'left'\n  value = 1\n[../]\n[./right_eta2]\n  type = DirichletBC\n  variable = 'eta2'\n  boundary = 'right'\n  value = 0\n[../]\n [./bottom_w]\n  type = NeumannBC\n  variable = 'w'\n  boundary = 'bottom'\n  value = 0\n[../]\n[./top_w]\n  type = NeumannBC\n  variable = 'w'\n  boundary = 'top'\n  value = 0.0\n[../]\n [./left_w]\n  type = NeumannBC\n  variable = 'w'\n  boundary = 'left'\n  value = 0\n[../]\n[./right_w]\n  type = DirichletBC\n  variable = 'w'\n  boundary = 'right'\n  value = 0.0\n[../]\n[./left_pot]\ntype = DirichletBC\nvariable = 'pot'\nboundary = 'left'\nvalue = -0.45\n[../]\n[./right_pot]\ntype = DirichletBC\nvariable = 'pot'\nboundary = 'right'\nvalue = 0\n[../]\n[]\n[Kernels]\n# First part of equation 3 in main text . chi*dw/dt\n  [./w_dot]\n    type = SusceptibilityTimeDerivative\n    variable = w\n    f_name = chi\n    args = 'w'\n  [../]\n  # Intrinsic diffusion part of equation 3 in main text.\n   [./Diffusion1]\n    type = MatDiffusion\n    variable=w\n    diffusivity=D\n   [../]\n   # Migration.\n  [./Diffusion2]\n    type = Migration\n    variable = w\n    cv=eta2\n    Q_name = 0.\n    QM_name = DN\n    cp=pot\n  [../]\n  # Coupling between w and eta2.\n  [./coupled_eta2dot]\n    type = CoupledSusceptibilityTimeDerivative\n    variable = w\n    v = eta2\n    f_name = ft\n    args = 'eta1 eta2'\n  [../]\n\n  # Conduction, left handside of equation 4 in main text.\n [./Cond]\n   type = Conduction\n   variable = pot\n   cp=eta2\n   cv =w\n   Q_name = Le1\n   QM_name=0.\n  [../]\n# Source term for Equation 4 in main text.\n [./coupled_pos]\n    type = CoupledSusceptibilityTimeDerivative\n    variable = pot\n    v = eta2\n    f_name = ft2\n    args = 'eta1 eta2'\n  [../]\n\n  # Bulter-volmer equation, right hand side of Equation 1 in main text.\n  [./BV]\n    type = Kinetics\n    variable = eta2\n    f_name = G\n    cp=pot\n    cv=eta2\n  [../]\n  # Driving force from switching barrier, right hand side of Equation 1 in main text.\n  [./AC_bulk]\n    type = AllenCahn\n    variable = eta2\n    args = w\n    f_name = F\n  [../]\n\n  # interfacial energy\n  [./AC_int]\n    type = ACInterface\n    variable = eta2\n  [../]\n# deta/dt\n  [./e_dot]\n    type = TimeDerivative\n    variable = eta2\n  [../]\n  [./lagrange2]\n    type = SwitchingFunctionConstraintEta\n    variable = eta2\n    h_name   = h2\n    lambda = lambda\n  [../]\n\n  [./lagrange]\n    type = SwitchingFunctionConstraintLagrange\n    variable = lambda\n    etas    = 'eta1 eta2'\n    h_names = 'h1   h2'\n    # epsilon = 0.01\n  [../]\n[]\n\n[Materials]\n[./constants]\n  type = GenericConstantMaterial\n# kappa_op: gradient coefficient;  M0:diffucion coefficient of Li+ in electrolyte\n#  S1, S2 conductivity of electrode and electrolyte; L: kinetic coefficient; Ls: electrochemical kinetic coefficient; B: Barrier height;\n#  es, el: difference in the chemical potential of lithium and neutral components on the electrode/electrolyte phase at initial equilibrium state;\n# us, ul: free energy density of the electrode/electrolyte phases. Defined in Ref. 20 and 26 of the main text; A: prefactor; AA: nF/(R*T);\n# dv is the ratio of site density for the electrode/electrolyte phases; ft2: normalized used in Equation 4.\n\n  prop_names  = 'kappa_op  M0     S1      S2     L      Ls     B     es    el        A     ul     us     AA    dv  ft2'\n  prop_values = '0.3      317.9   1000000 1.19   6.25   0.0002  2.4  -13.8  2.631   1.0   0.0695 13.8   38.69 5.5 0.0074'\n[../]\n# grand potential of electrolyte phase\n  [./liquid_GrandPotential]\n    type = DerivativeParsedMaterial\n    function = 'ul-A*log(1+exp((w-el)/A))'\n    args = 'w'\n    f_name = f1\n    material_property_names = 'A ul el'\n  [../]\n  # grand potential of electrode phase\n  [./solid_GrandPotential]\n    type = DerivativeParsedMaterial\n    function = 'us-A*log(1+exp((w-es)/A))'\n    args = 'w'\n    f_name = f2\n    material_property_names = 'A us es'\n  [../]\n  #interpolation function h\n  [./switching_function1]\n    type = SwitchingFunctionMaterial\n    function_name = h1\n    eta ='eta1'\n    h_order = HIGH\n  [../]\n  [./switching_function2]\n    type = SwitchingFunctionMaterial\n    function_name = h2\n    eta ='eta2'\n    h_order = HIGH\n  [../]\n  # Barrier function g\n  [./barrier_function]\n    type = MultiBarrierFunctionMaterial\n    etas = 'eta1 eta2'\n  [../]\n  [./total_GrandPotential]\n    type = DerivativeMultiPhaseMaterial\n    args = 'w'\n    etas = 'eta1 eta2'\n    fi_names = 'f1 f2'\n    hi_names = 'h1 h2'\n    f_name = F\n    derivative_order = 2\n    W = 2.4\n  [../]\n # Coupling between eta and w\n  [./coupled_eta_function]\n    type = DerivativeParsedMaterial\n    function = '-(cs*dv-cl)*dh'  # in this code cs=-cs h=eta dh=1\n    args = ' w eta1 eta2'\n    f_name = ft\n    material_property_names = 'dh:=D[h2,eta2] h2 dv cs:=D[f2,w] cl:=D[f1,w]'\n    derivative_order = 1\n  [../]\n  [./susceptibility]\n      type = DerivativeParsedMaterial\n      function = '-d2F1*h1-d2F2*h2*dv'\n      args = 'w'\n      f_name = chi\n      derivative_order = 1\n      material_property_names = 'h1 h2 dv d2F1:=D[f1,w,w] d2F2:=D[f2,w,w]'\n    [../]\n    # Mobility defined by D*c/(R*T), whereR*T is normalized by the chemical potential\n    # M0*(1-h) is the effective diffusion coefficient; cl*(1-h) is the ion concentration\n   [./Mobility_coefficient]\n    type = DerivativeParsedMaterial\n    function = '-M0*h1*cl*h1'  #c is -c\n    f_name = D\n     args = 'eta1 eta2 w'\n    derivative_order = 1\n    material_property_names = ' M0 cl:=D[f1,w] h1'\n  [../]\n  # Migration coefficient.\n  [./Migration_coefficient]\n    type = DerivativeParsedMaterial\n    function = '-cl*h1*AA*M0*h1'\n    args = 'eta1 eta2 w'\n    f_name = DN\n    derivative_order = 1\n    material_property_names = 'M0 AA cl:=D[f1,w] h1'\n  [../]\n  [./Bultervolmer]\n      type = DerivativeParsedMaterial\n      function = 'Ls*(exp(pot*AA/2.)+14.89*cl*h1*exp(-pot*AA/2.))*dh2'\n      args = 'pot eta1 eta2 w'\n      f_name = G\n     derivative_order = 1\n      material_property_names = 'Ls dh2:=D[h2,eta2] h1 h2 cl:=D[f1,w] AA'\n      outputs = exodus\n    [../]\n # output the ion concentration\n  [./concentration]\n    type = ParsedMaterial\n    f_name = c\n    args='eta1 eta2 w'\n    material_property_names = 'h1 dFl:=D[f1,w]'\n    function = '-dFl*h1'\n   outputs = exodus\n  [../]\n  # Effective conductivity\n  [./Le1]\n  type = DerivativeParsedMaterial\n  f_name = Le1\n  args = 'eta1 eta2'\n  material_property_names = 'S1 S2 h1 h2'\n  function = 'S1*h2+S2*h1'\n   derivative_order = 1\n [../]\n []\n\n\n [GlobalParams]\n   enable_jit = false           # Disable JIT\n []\n\n [Preconditioning]\n   [./SMP]\n     type = SMP\n     full = true\n     petsc_options_iname = '-pc_type -ksp_grmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\n     petsc_options_value = 'asm      121                  preonly       lu           8'\n   [../]\n []\n\n [Executioner]\n   type = Transient\n   scheme = bdf2\n   #solve_type =Newton\n   l_max_its = 50\n   l_tol = 1e-4\n   nl_max_its = 20\n   nl_rel_tol = 1e-6\n   nl_abs_tol = 1e-6\n     dt=0.02\n     end_time = 3\n []\n\n [Outputs]\n   exodus = true\n   csv = true\n   execute_on = 'TIMESTEP_END'\n []",
          "url": "https://github.com/idaholab/moose/discussions/22745",
          "updatedAt": "2022-12-10T07:26:53Z",
          "publishedAt": "2022-11-18T06:25:25Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhen you use an auxiliary variable, you loose all the information about the derivative. If the derivative material are used to construct the Jacobian, then removing the derivatives with regards to eta for all (1-eta) terms will lower the quality of your Jacobian, likely creating convergence issues\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22745#discussioncomment-4179129",
                  "updatedAt": "2022-11-18T17:20:05Z",
                  "publishedAt": "2022-11-18T17:20:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Another reason this could break down is if the auxvariable equal to 1-eta is not up to date often enough.\nThis would result in a lagging of the variable value in one or more steps of the solve.\nBy default we execute auxkernels as often as possible.",
                          "url": "https://github.com/idaholab/moose/discussions/22745#discussioncomment-4180763",
                          "updatedAt": "2022-11-18T21:16:26Z",
                          "publishedAt": "2022-11-18T21:16:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "ok Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/22745#discussioncomment-4192099",
                          "updatedAt": "2022-11-21T05:19:16Z",
                          "publishedAt": "2022-11-21T05:19:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Diffusion Only Displaying in 1st Node",
          "author": {
            "login": "water984"
          },
          "bodyText": "I followed a very similar setup to the first tutorial with the differing values, but for some reason the simulation gets squished into the first node. Any ideas for a fix?\nDifConstants.h:\n#pragma once\n\n#include \"ADKernel.h\"\n\nclass DifConstants : public ADKernel\n{\npublic:\n  static InputParameters validParams();\n\n  DifConstants(const InputParameters & parameters);\n\nprotected:\n  virtual ADReal computeQpResidual() override;\n\n  const Real & _diffcoeff;\n  const Real & _sigA;\n};\n\n\nDifConstants.C:\n#include \"DifConstants.h\"\n\nregisterMooseObject(\"difApp\", DifConstants);\n\nInputParameters\nDifConstants::validParams()\n{\n  InputParameters params = ADKernel::validParams();\n  params.addClassDescription(\"Compute the diffusion term for diffusion equation: \"\n                             \"$-\\\\nabla \\\\cdot \\\\frac{\\\\mathbf{D}} \\\\nabla p = 0$\");\n  return params;\n}\n\nDifConstants::DifConstants(const InputParameters & parameters)\n  : ADKernel(parameters),\n\n    _diffcoeff(0.142),\n    _sigA(0.022)\n{\n}\n\nADReal\nDifConstants::computeQpResidual()\n{\n  return (_diffcoeff) * _grad_test[_i][_qp] * _grad_u[_qp];\n}\n\nNeutronDiffusion.i:\n[Mesh]\n  [gmg]\n    type = GeneratedMeshGenerator # Can generate simple lines, rectangles and rectangular prisms\n    dim = 2 # Dimension of the mesh\n    nx = 100 # Number of elements in the x direction\n    ny = 10 # Number of elements in the y direction\n    xmax = 0.304 # Length of test chamber\n    ymax = 0.0257 # Test chamber radius\n  []\n[]\n\n[Kernels]\n  [dif]\n    type = DifConstants\n    variable = phi # Operate on the \"phi\" variable from above\n  []\n[]\n\n[Problem]\n  type = FEProblem # This is the \"normal\" type of Finite Element Problem in MOOSE\n  coord_type = RZ # Axisymmetric RZ\n  rz_coord_axis = X # Which axis the symmetry is around\n[]\n\n[Variables]\n  [phi]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n\n[BCs]\n  [left]\n    type = ADDirichletBC # Simple u=value BC\n    variable = phi # Variable to be set\n    boundary = left # Name of a sideset in the mesh\n    value = 10E+10 # (Neutrons/cm/sec)\n  []\n  [right]\n    type = VacuumBC\n    variable = phi\n    boundary = right  \n  []\n[]\n\n[Executioner]\n  type = Steady # Steady state problem\n  solve_type = PJFNK\n\n  petsc_options_iname = '-pc_type -pc_hypre_type' # PETSc option pairs with values below\n  petsc_options_value = ' hypre    boomeramg'\n[]\n\n[Outputs]\n  exodus = true # Output Exodus format\n[]",
          "url": "https://github.com/idaholab/moose/discussions/22601",
          "updatedAt": "2022-12-10T07:29:16Z",
          "publishedAt": "2022-11-04T14:35:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI ran your case with the CoefDiffusion kernel since it's basically the same as it's the same as your DifConstants currently.\nThe issue is that with the DirichletBC at 1e11, the solver struggles to solve the problem in a single time step with the default relative tolerances. The errors starts very large because of the large value of the BC, and converging it down by a few orders of magnitude in the linear solve is not enough.\nYou should tighten l_tol down by a few orders of magnitude.\nPlease also note that given that your problem is linear, you may use the linear solve_type instead of PJFNK or Newton.\nGuillaume\nPS: note that 10e10 is 1e11. I m sure you know, it's just that 10e10 is odd to see.",
                  "url": "https://github.com/idaholab/moose/discussions/22601#discussioncomment-4191319",
                  "updatedAt": "2022-11-21T01:48:23Z",
                  "publishedAt": "2022-11-21T01:48:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Contact thermal conductance convergence issue",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "Hi,\nI am trying to simulate a 3D thermal mechanical problem between two parts with contact conductance. With GapFluxModelPressureDependentConduction the simulation failed to converge. Illustration of the system is shown below.\n\nContact of mortar formulation had proven to work well on avoiding penetration on its own. But when GapFluxModelPressureDependentConduction is enabled, simulation failed to converge. Whenever the residual interface_normal_lm does not equal to zero, no more nonlinear iteration occurred and executioner straight to smaller dt. A clip of the console output is shown below.\n...\nTime Step 6, time = 0.05125, dt = 0.000125\n 0 Nonlinear |R| = 2.631244e+03\n    |residual|_2 of individual variables:\n        disp_x:              4.91887e-19\n        disp_y:              1.35333e-18\n        disp_z:              1.90408e-19\n        T_K:                 2631.24\n        lm:                  0\n        interface_normal_lm: 0\n 1 Nonlinear |R| = 3.575491e+01\n    |residual|_2 of individual variables:\n        disp_x:              1.89764e-09\n        disp_y:              2.15038e-09\n        disp_z:              3.55831e-09\n        T_K:                 35.7549\n        lm:                  0\n        interface_normal_lm: 3.80056e-10\n Solve Did NOT Converge!\n  Finished Solving                                                                       [ 27.20 s] [    1 MB]\nAborting as solve did not converge\n\nTime Step 6, time = 0.0511875, dt = 6.25e-05\n...",
          "url": "https://github.com/idaholab/moose/discussions/22700",
          "updatedAt": "2023-01-03T23:18:31Z",
          "publishedAt": "2022-11-15T00:49:39Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "BoZeng1997"
                  },
                  "bodyText": "This is a short version of my input file. The usual tensor mechanics and thermal diffusion settings are not listed.\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  temperature = T_K\n[]\n\n[Mesh]\n  patch_update_strategy=iteration\n  [ori]\n    type = FileMeshGenerator\n    file = 'mesh/radiation_3d_half_thin_nbrot_transft.e'\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n  [T_K]\n    [InitialCondition]\n      type = ConstantIC\n      value = 300.0\n    []\n  []\n  [lm]\n    block = 'interface_secondary_subdomain'\n  []\n[]\n\n[Contact]\n  [interface]\n    primary = void_0\n    secondary = void_1\n    model = frictionless\n    penalty = 1e6\n    formulation = mortar\n    c_normal = 1e6 #balancing the size of the gap and contact pressure\n    correct_edge_dropping = true\n  []\n[]\n\n[UserObjects]\n  [closed]\n    type = GapFluxModelPressureDependentConduction\n    primary_conductivity = 34.0 # thermal_conductivity\n    secondary_conductivity = 81.98 # thermal_conductivity\n    temperature = T_K\n    contact_pressure = interface_normal_lm\n    primary_hardness = 1.0 # aluminum_hardness \n    secondary_hardness = 1.0 # steel_hardness\n    boundary = void_0\n    use_displaced_mesh = true\n  []\n[]\n\n[Constraints]\n  [gap_nb]\n    type = ModularGapConductanceConstraint\n    variable = lm\n    secondary_variable = T_K\n    primary_boundary = 'void_0'\n    primary_subdomain = interface_primary_subdomain\n    secondary_boundary = 'void_1'\n    secondary_subdomain = interface_secondary_subdomain\n    gap_flux_models = 'closed ' \n    gap_geometry_type = 'CYLINDER'\n    cylinder_axis_point_1 = '0 0 0'\n    cylinder_axis_point_2 = '0 0 1'\n    use_displaced_mesh = true\n    quadrature = SECOND\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -pc_factor_shift_type -pc_factor_shift_amount '\n  petsc_options_value = 'lu      superlu_dist NONZERO 1e-14' \n  automatic_scaling = true\n  line_search = bt\n  compute_scaling_once = true \n  scaling_group_variables = 'disp_x disp_y disp_z; T_K; interface_normal_lm; lm'\n  \n  nl_rel_tol = 1e-9\n  nl_abs_tol = 1e-5\n  nl_max_its = 500\n  dtmin = 1e-6\n  dt = 1e-3\n  start_time = 47e-3\n  end_time = 63e-3\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/22700#discussioncomment-4141916",
                  "updatedAt": "2022-11-15T00:59:20Z",
                  "publishedAt": "2022-11-15T00:58:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nCan you pass -snes_view to the petsc_options so we can have more information about why it does not converge\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22700#discussioncomment-4149423",
                          "updatedAt": "2022-11-15T18:20:14Z",
                          "publishedAt": "2022-11-15T18:20:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "HI,\nThis is the step that start to have convergence issue\nTime Step 4, time = 0.051, dt = 0.001\n 0 Nonlinear |R| = 3.019544e+03\n    |residual|_2 of individual variables:\n        disp_x:              4.91907e-19\n        disp_y:              1.30281e-18\n        disp_z:              1.84853e-19\n        T_K:                 3019.54\n        lm:                  0\n        interface_normal_lm: 0\n 1 Nonlinear |R| = 4.806744e+02\n    |residual|_2 of individual variables:\n        disp_x:              1.68227e-07\n        disp_y:              2.00317e-07\n        disp_z:              3.64272e-07\n        T_K:                 480.674\n        lm:                  0\n        interface_normal_lm: 1.31985e-07\nSNES Object: 4 MPI processes\n  type: newtonls\n  maximum iterations=500, maximum function evaluations=10000\n  tolerances: relative=1e-09, absolute=1e-05, solution=0.\n  total number of linear solver iterations=2\n  total number of function evaluations=16\n  norm schedule ALWAYS\n  SNESLineSearch Object: 4 MPI processes\n    type: bt\n      interpolation: cubic\n      alpha=1.000000e-04\n    maxstep=1.000000e+08, minlambda=1.000000e-12\n    tolerances: relative=1.000000e-08, absolute=1.000000e-15, lambda=1.000000e-08\n    maximum iterations=40\n  KSP Object: 4 MPI processes\n    type: gmres\n      restart=30, using Classical (unmodified) Gram-Schmidt Orthogonalization with no iterative refinement\n      happy breakdown tolerance 1e-30\n    maximum iterations=10000, initial guess is zero\n    tolerances:  relative=1e-05, absolute=1e-50, divergence=1e+100\n    right preconditioning\n    using UNPRECONDITIONED norm type for convergence test\n  PC Object: 4 MPI processes\n    type: lu\n      out-of-place factorization\n      tolerance for zero pivot 2.22045e-14\n      using diagonal shift to prevent zero pivot [NONZERO]\n      matrix ordering: external\n      factor fill ratio given 0., needed 0.\n        Factored matrix follows:\n          Mat Object: 4 MPI processes\n            type: superlu_dist\n            rows=20766, cols=20766\n            package used to perform factorization: superlu_dist\n            total: nonzeros=0, allocated nonzeros=0\n              SuperLU_DIST run parameters:\n                Process grid nprow 0 x npcol 0 \n                Equilibrate matrix TRUE \n                Replace tiny pivots TRUE \n                Use iterative refinement FALSE \n                Processors in row 0 col partition 0 \n                Row permutation LargeDiag_MC64\n                Column permutation METIS_AT_PLUS_A\n                Parallel symbolic factorization FALSE \n                Repeated factorization SamePattern\n    linear system matrix = precond matrix:\n    Mat Object: () 4 MPI processes\n      type: mpiaij\n      rows=20766, cols=20766\n      total: nonzeros=1568501, allocated nonzeros=2020640\n      total number of mallocs used during MatSetValues calls=23\n        using I-node (on process 0) routines: found 1231 nodes, limit used is 5\n Solve Did NOT Converge!\n  Finished Solving                                                                       [ 19.07 s] [    0 MB]\nAborting as solve did not converge\n\nThis is the step before that converged\n 4 Nonlinear |R| = 2.456882e-11\n    |residual|_2 of individual variables:\n        disp_x:              4.91907e-19\n        disp_y:              1.30281e-18\n        disp_z:              1.84853e-19\n        T_K:                 2.45688e-11\n        lm:                  0\n        interface_normal_lm: 0\nSNES Object: 4 MPI processes\n  type: newtonls\n  maximum iterations=500, maximum function evaluations=10000\n  tolerances: relative=1e-09, absolute=1e-05, solution=0.\n  total number of linear solver iterations=4\n  total number of function evaluations=5\n  norm schedule ALWAYS\n  SNESLineSearch Object: 4 MPI processes\n    type: bt\n      interpolation: cubic\n      alpha=1.000000e-04\n    maxstep=1.000000e+08, minlambda=1.000000e-12\n    tolerances: relative=1.000000e-08, absolute=1.000000e-15, lambda=1.000000e-08\n    maximum iterations=40\n  KSP Object: 4 MPI processes\n    type: gmres\n      restart=30, using Classical (unmodified) Gram-Schmidt Orthogonalization with no iterative refinement\n      happy breakdown tolerance 1e-30\n    maximum iterations=10000, initial guess is zero\n    tolerances:  relative=1e-05, absolute=1e-50, divergence=1e+100\n    right preconditioning\n    using UNPRECONDITIONED norm type for convergence test\n  PC Object: 4 MPI processes\n    type: lu\n      out-of-place factorization\n      tolerance for zero pivot 2.22045e-14\n      using diagonal shift to prevent zero pivot [NONZERO]\n      matrix ordering: external\n      factor fill ratio given 0., needed 0.\n        Factored matrix follows:\n          Mat Object: 4 MPI processes\n            type: superlu_dist\n            rows=20766, cols=20766\n            package used to perform factorization: superlu_dist\n            total: nonzeros=0, allocated nonzeros=0\n              SuperLU_DIST run parameters:\n                Process grid nprow 0 x npcol 0 \n                Equilibrate matrix TRUE \n                Replace tiny pivots TRUE \n                Use iterative refinement FALSE \n                Processors in row 0 col partition 0 \n                Row permutation LargeDiag_MC64\n                Column permutation METIS_AT_PLUS_A\n                Parallel symbolic factorization FALSE \n                Repeated factorization SamePattern\n    linear system matrix = precond matrix:\n    Mat Object: () 4 MPI processes\n      type: mpiaij\n      rows=20766, cols=20766\n      total: nonzeros=1571448, allocated nonzeros=4529961\n      total number of mallocs used during MatSetValues calls=35\n        using I-node (on process 0) routines: found 1231 nodes, limit used is 5\n Solve Converged!\n  Finished Solving                                                                       [ 16.13 s] [    1 MB]\n\nOutlier Variable Residual Norms:\n  T_K: 2.456882e-11",
                          "url": "https://github.com/idaholab/moose/discussions/22700#discussioncomment-4149577",
                          "updatedAt": "2022-11-15T18:42:30Z",
                          "publishedAt": "2022-11-15T18:42:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont see what went wrong.\nCan you try turning off the line_search?\nCan you please also try to recompile in debug mode and re-run the analysis, see if we hit a debug clause",
                          "url": "https://github.com/idaholab/moose/discussions/22700#discussioncomment-4149815",
                          "updatedAt": "2022-11-15T19:16:09Z",
                          "publishedAt": "2022-11-15T19:16:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "Hi,\nAfter turning off line_search there is no more convergence issue.\nI wonder why bt line search does not work well on thermal contact. It worked when there is only mechanical contact (avoiding penetration). But with thermal contact it does not work well.",
                          "url": "https://github.com/idaholab/moose/discussions/22700#discussioncomment-4159987",
                          "updatedAt": "2022-11-16T18:25:27Z",
                          "publishedAt": "2022-11-16T18:25:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "BoZeng1997"
                  },
                  "bodyText": "Also, although not related to this issue but I would like some advice. What do you recommend me to do with the executioner settings?\nThe complete system is a module consists tensor mechanics, heat conduction, contact and phase field. It will have multiple contact pairs and mesh will be huge. The mortar contact constraints will have GapFluxModelConduction, GapFluxModelRadiation, and GapFluxModelPressureDependentConduction. For the first few time steps there will be no contact with pressure. In this case, should I scale the variables separately as scaling_group_variables = 'disp_x disp_y disp_z; T_K' with ignore_variables_for_autoscaling = 'interface_normal_lm lm' and compute_scaling_once = true ?\nI also noticed there is a contact line_search. Is that the line search I should use?",
                  "url": "https://github.com/idaholab/moose/discussions/22700#discussioncomment-4160105",
                  "updatedAt": "2022-11-16T18:40:48Z",
                  "publishedAt": "2022-11-16T18:40:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nI m not familiar with the contact line search but yes, it s the one to use.\nThe most robust will be:\n\nautomatic scaling (in executioner)\ncompute-scaling_once = false\n\nIs the linear solve performance satisfactory? How many iterations? (all we're talking about is nonlinear so far, just checking)\nSame questions for non linear.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22700#discussioncomment-4180981",
                          "updatedAt": "2022-11-20T18:17:46Z",
                          "publishedAt": "2022-11-18T21:59:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I don't recommend using compute_scaling_once = false. It often gives unconverged result. I hope we can just deprecate that parameter.",
                          "url": "https://github.com/idaholab/moose/discussions/22700#discussioncomment-4181620",
                          "updatedAt": "2022-11-19T00:22:51Z",
                          "publishedAt": "2022-11-19T00:22:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I could see it lead to difficulties in accepting a converged answer but why would it lead to unconverged results?\nas for a lot of these solver parameters, my opinion is that we ought to be able to modify them at any point in the simulation",
                          "url": "https://github.com/idaholab/moose/discussions/22700#discussioncomment-4189679",
                          "updatedAt": "2022-11-20T18:19:12Z",
                          "publishedAt": "2022-11-20T18:19:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to use the rotateXyPlane() member function from RankTwoTensorTempl to rotate a vector",
          "author": {
            "login": "batodon"
          },
          "bodyText": "Hello,\nThe documentation of RankTwoTensorTempl indicates that rotateXyPlane() can rotate a tensor about the Z-axis (x-y-plane). I\u2019m looking to rotate a (unit) vector (i.e., _n) instead. I used the following lines of code below, but none seems to work.\nrotN_xy = RankTwoTensor::rotateXyPlane(_r);\nrotN_xy = _n.rotateXyPlane(_r);\nCould someone help me with the appropriate line of code that rotate the vector using the rotateXyPlane() function? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/22761",
          "updatedAt": "2023-01-03T23:10:02Z",
          "publishedAt": "2022-11-19T17:54:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "souravmat-git"
                  },
                  "bodyText": "Hi,\nI am unsure if the rotateXyPlane() function can rotate a vector.\nI will do this in the following way:\nReal theta = _the_angle_of_rotation;\nRankTwoTensor _transformation_matrix;\n\n_transformation_matrix(0, 0) = std::cos(theta);\n_transformation_matrix(0, 1) = std::sin(theta);\n_transformation_matrix(1, 0) = -std::sin(theta);\n_transformation_matrix(1, 1) = std::cos(theta);\n\nRealVectorValue _r;\nRealVectorValue rotN_xy = _transformation_matrix * _r;",
                  "url": "https://github.com/idaholab/moose/discussions/22761#discussioncomment-4185510",
                  "updatedAt": "2022-11-19T19:38:03Z",
                  "publishedAt": "2022-11-19T19:38:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hello! Thanks a million! The code compiles successfully. How about rotation around the X-axis (y-z plane)? I\u2019m assuming I need to change my cosine and sine functions. How do I go about it? Or should I use the same code? Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/22761#discussioncomment-4185707",
                          "updatedAt": "2022-11-19T20:41:06Z",
                          "publishedAt": "2022-11-19T20:41:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hello @souravmat-git ,\nFor some reason, I don\u2019t know why the previous code compiled successfully because my vector (i.e., RealVectorValue _r)  is 3x1. I\u2019m rotating in 3D, not 2D. I made a few changes to the transformation matrix (shown below) and the code compiles (for rotation in the x-y plane). I\u2019m a bit doubtful about my transformation matrix. Could you help? Thanks.\n    _transformation_matrix(0, 0) = std::cos(theta);\n    _transformation_matrix(0, 1) = std::sin(theta);\n    _transformation_matrix(0, 2) = 0;\n    _transformation_matrix(1, 0) = -std::sin(theta);\n    _transformation_matrix(1, 1) = std::cos(theta);\n    _transformation_matrix(1, 2) = 0;\n    _transformation_matrix(2, 0) = 0;\n    _transformation_matrix(2, 1) = 0;\n    _transformation_matrix(2, 2) = 1;",
                          "url": "https://github.com/idaholab/moose/discussions/22761#discussioncomment-4186332",
                          "updatedAt": "2022-11-20T00:18:43Z",
                          "publishedAt": "2022-11-20T00:17:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this looks fine for rotating in the XY plane\nsee wikipedia they have it written down\nhttps://en.wikipedia.org/wiki/Rotation_matrix",
                          "url": "https://github.com/idaholab/moose/discussions/22761#discussioncomment-4189204",
                          "updatedAt": "2022-11-20T16:28:44Z",
                          "publishedAt": "2022-11-20T16:28:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "sure!. Thanks a lot @GiudGiud.",
                          "url": "https://github.com/idaholab/moose/discussions/22761#discussioncomment-4189547",
                          "updatedAt": "2022-11-20T17:50:31Z",
                          "publishedAt": "2022-11-20T17:50:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}