{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wMy0wN1QxNzozMzozMC0wNzowMM4AMaJ9"
    },
    "edges": [
      {
        "node": {
          "title": "Help understanding elemental variables",
          "author": {
            "login": "aprilnovak"
          },
          "bodyText": "Hi all,\nI'm trying to get a better understanding of the MultiAppNearestNodeTransfer, but am finding myself confused on the interpretation of elemental variables. On the MOOSE website, it says:\n\nfor elemental shape functions the DOF values are not associated with nodes.\n\nbut rather with quadrature points. But then in the transfer itself, the target points in the receiving app for FIRST MONOMIAL are set to the nodes of element: (code here)\nif (elemental) {\n\n           // For L2_LAGRANGE, we take all the nodes of element\n            for (auto & node : elem->node_ref_range())\n            {\n              points.push_back(node);\n              point_ids.push_back(node.id());\n            }\n\n}\n\nHow do these two statements reconcile with one another? I'm trying to figure out why transfers to/from FIRST MONOMIAL give strange-looking results for this transfer (see here), and I feel like this (apparent, to me) inconsistency might explain something.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/17273",
          "updatedAt": "2022-08-30T15:37:03Z",
          "publishedAt": "2021-03-10T15:23:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "In libMesh, the dofs for elemental variables are represented on the element themselves.\nLet's say you have a system with just a single first order, elemental variable and QUAD4 elems. Each QUAD4 elem would have 4 dofs associated with it (a value at each \"node\"; note I use \"node\" here because it's not actually stored on the Node object!). Then, all of the physical Node objects (which represent the vertices for each QUAD4 elem, which are shared between elems) have no dofs whatsoever. In addition, for first-order L2_LAGRANGE variables, the spatial location of each node (where the dofs live physically in space) happen to also be the physical location of the Nodes - even though the Node objects do not own the dofs!\nWithin the loop that you linked, we're specifying that we need a value for each of the dof values for the L2_LAGRANGE element (again, the Node locations are the locations for the dofs, even though the dofs don't live on the Node objects). I'm still working through the validity of using the Node ID (stored here) for the purposes of mapping the incoming evaluations here.",
                  "url": "https://github.com/idaholab/moose/discussions/17273#discussioncomment-470242",
                  "updatedAt": "2022-08-30T15:37:26Z",
                  "publishedAt": "2021-03-11T16:30:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How can I run a single input file using MOOSE?",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Dear all,\nI just begin to learn how to use MOOSE. When I try to run an input file in tutorials, how could I give a command in the terminal? I mean not use ./run_tests for all, but just run one at a time.\nThanks in advance,\nQinglin",
          "url": "https://github.com/idaholab/moose/discussions/16158",
          "updatedAt": "2022-07-01T10:00:45Z",
          "publishedAt": "2020-11-11T22:46:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "You use the -i flag followed by the name of your input file.\nExample:\n./inch-worm-opt -i my_input_file.i\nYou can get the complete list of command line options by using the -h flag.",
                  "url": "https://github.com/idaholab/moose/discussions/16158#discussioncomment-127303",
                  "updatedAt": "2022-07-01T10:00:45Z",
                  "publishedAt": "2020-11-11T22:50:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Since you can ./run_tests then you must have successfully compiled and tested MOOSE.  Well done!   This is because the compilation will have produced a valid executable that was used by ./run_tests.  Have a look around in the directory that you used for ./run_tests and you will probably see an executable called your_app-opt, or combined-opt, etc.  It is the MOOSE executable.\n(If you compiled in debug mode, the executable will have -dbg on the end of its name.)\nThen, use .... what @permcody just wrote!    You might have to specify the paths, such as\n./inch-worm-opt -i path/to/my_input_file.i\n\nor\npath/to/inch-worm-opt -i another/path/to/my_input_file.i",
                  "url": "https://github.com/idaholab/moose/discussions/16158#discussioncomment-127307",
                  "updatedAt": "2022-07-01T10:00:46Z",
                  "publishedAt": "2020-11-11T22:52:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ali-toghraee"
                          },
                          "bodyText": "Hello Andy,\nI just installed moose (conda) and all the tests passed. I also did the \"make\" in the combined module folder and created the combined-opt file (however the tests did not run). Now I want to run my input files.\nPreviously, I used to navigate to the folder of my input file, and then opened that folder in a terminal , then I would typed:\n(moose) atoghraee@ME-DESKTOP102:~/projects02/ox_poly$ mpiexec -np 88 /home/atoghraee/projects02/moose/modules/combined/combined-opt -i fun05_absM_m8000_df.i\nBut now , when run this command I face the following errors ( part of that shown below).\n\nIs this because the combined-opt tests didnot run?\nI should mention that I already have a moose from 2019 in my projects forlder, to install the new version on moose using conda , I just followed the instructions in the \"https://mooseframework.inl.gov/getting_started/installation/conda.html\" and instead of \"projects\" folder , I created an used \"projects02\" . I would really appreciate if you could help me  make the moose up and running.\n\n(moose) atoghraee@ME-DESKTOP102:~/projects02/ox_poly$ mpiexec -np 88 /home/atoghraee/projects02/moose/modules/combined/combined-opt -i fun05_absM_m8000_df.i\n/home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/combined/test/lib/libcombined_test-opt.so.0) /home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/combined/lib/libcombined-opt.so.0)\n/home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/framework/libmoose-opt.so.0) /home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/chemical_reactions/test/lib/libchemical_reactions_test-opt.so.0)\n/home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/fluid_properties/test/lib/libfluid_properties_test-opt.so.0) /home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/ray_tracing/test/lib/libray_tracing_test-opt.so.0)\n/home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/heat_conduction/test/lib/libheat_conduction_test-opt.so.0) /home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/level_set/test/lib/liblevel_set_test-opt.so.0)\n/home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/misc/test/lib/libmisc_test-opt.so.0) /home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/rdg/test/lib/librdg_test-opt.so.0)\n/home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/navier_stokes/test/lib/libnavier_stokes_test-opt.so.0) /home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version GLIBCXX_3.4.26' not found (required by /home/atoghraee/projects02/moose/modules/tensor_mechanics/test/lib/libtensor_mechanics_test-opt.so.0)\n/home/atoghraee/projects02/moose/modules/combined/combined-opt: /opt/moose/gcc-7.3.0/lib64/libstdc++.so.6: version `GLIBCXX_3.4.26' not found (required by",
                          "url": "https://github.com/idaholab/moose/discussions/16158#discussioncomment-466467",
                          "updatedAt": "2022-07-01T10:00:48Z",
                          "publishedAt": "2021-03-11T02:04:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "EBSD Output format",
          "author": {
            "login": "KamalnathOSU"
          },
          "bodyText": "Dear MOOSE team,\nIn the Phase-field examples, we can take input from EBSD data and perform grain growth simulation (eg: IN100-111grn.i. Is there a way in which we can get the final microstructure in EBSD format?\nThanks,\nKamal",
          "url": "https://github.com/idaholab/moose/discussions/16932",
          "updatedAt": "2022-06-16T12:29:50Z",
          "publishedAt": "2021-02-09T14:05:11Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "We don't have the capability to do this currently- can you explain a bit more about what you are wanting to do? We may be able to suggest another route to accomplish it.",
                  "url": "https://github.com/idaholab/moose/discussions/16932#discussioncomment-371795",
                  "updatedAt": "2022-06-16T12:29:50Z",
                  "publishedAt": "2021-02-15T21:19:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "I am trying to study the growth of an amorphous (A) phase in a polycrystalline material ( G_1, G_2, G_3, ..., G_M ) at room temperature where grain growth can be neglected. The amorphous phase has significant growth rate even at room temperature. Hence, I want to  freeze the grain structure during the evolution of the amorphous phase A.  The amorphous phase interface with the solid grain (referred to as A-G_i ; i=1,2,..,M) has anisotropic mobility and it depends only on the orientation of the grain.\nI planned my simulation in two steps.\nStep1 : I generated a polycrystal structure from Dream.3D, relaxed it (to get diffuse interface) with phase-field module and got output of the microstructure. I was able to accomplish this step.\nStep2 : Load the relaxed polycrystal microstructure and simulate the growth of the amorphous phase. Here, I need to specify the anisotropic mobility of A-G_i in terms of the grain orientation. For this purpose, I need to know the number of grains co-existing  in a nodal point and its corresponding orientation.\nCan you please suggest me how to accomplish \"Step2\" ?",
                          "url": "https://github.com/idaholab/moose/discussions/16932#discussioncomment-373961",
                          "updatedAt": "2022-06-16T12:29:59Z",
                          "publishedAt": "2021-02-16T15:17:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "We don't currently have the capability to do exactly what you are trying; however, you could probably write some new code based on existing code. We do have the capability to set different grain boundary energies for different orientations, so you could use a similar approach to that code. Have a look at the documentation page https://mooseframework.inl.gov/modules/phase_field/Grain_Boundary_Anisotropy.html",
                          "url": "https://github.com/idaholab/moose/discussions/16932#discussioncomment-374772",
                          "updatedAt": "2022-06-16T12:30:10Z",
                          "publishedAt": "2021-02-16T19:28:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "KamalnathOSU"
                  },
                  "bodyText": "Hi,\nI have another question on this topic. After I complete my grain growth simulation, I want to the load the grain structure  into AuxVariable and perform some calculations with it.\n1)How to the load the order parameters in AuxVariable ? The usual instructions will allow me to load the order parameters only in NonLinearVariable.\n2)How to load the euler angles corresponding to each grain ?\n-Kamal",
                  "url": "https://github.com/idaholab/moose/discussions/16932#discussioncomment-465506",
                  "updatedAt": "2022-06-16T12:30:13Z",
                  "publishedAt": "2021-03-10T21:37:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "if you want to put an order parameter into an AuxVariable, you can use a ParsedAux AuxKernel. You would need to create an AuxVariable, then use the AuxKernel with args = 'eta0' and function = 'eta1' for order parameter eta1.\nYou can use the OutputEulerAngles AuxKernel to do this. There are other objects that would be needed; have a look at moose/modules/phase_field/test/tests/grain_tracker_test/grain_tracker_ebsd.i for an example.",
                          "url": "https://github.com/idaholab/moose/discussions/16932#discussioncomment-465626",
                          "updatedAt": "2022-06-16T12:30:18Z",
                          "publishedAt": "2021-03-10T22:05:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Deleting elements in tensor mechanics",
          "author": {
            "login": "ngrilli"
          },
          "bodyText": "Dear Moose Users,\nI was looking at the possibility of deleting elements, when a certain condition, for instance temperature increase, is satisfied.\nI have already implemented models where the element stiffness is degraded, however, I would like to compare them\nwith a model where certain elements are actually removed from the finite element problem.\nI have seen something similar is done in XFEM by creating the EFA mesh.\nMy understanding is that in the XFEM module, a copy of the original mesh is created and manipulated by creating cuts,\nthen the stress divergence kernel is calculated on the manipulated mesh. But I may be wrong here.\nCan someone point me to a strategy to try the element deletion?\nIs the creation of a separate mesh necessary?\nI would be happy if I could do the deletion just based on element index.\nThank you very much in advance.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
          "url": "https://github.com/idaholab/moose/discussions/16387",
          "updatedAt": "2022-06-22T18:26:00Z",
          "publishedAt": "2020-12-04T15:43:52Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "MatthewMavis"
                  },
                  "bodyText": "Hi all,\nI'm just jumping on this thread to say I'm also interested in this as I'm looking into topology optimisation using moose. I have developed some code to do this based on element IDs though it is currently very rough (https://github.com/MatthewMavis/moose/blob/TopOpt/framework/src/meshgenerators/ElementDeleter.C).\nYou should be able to hook into the ElementDeletionGeneratorBase.C like I have which will delete the elements, though one problem I'm currently having with this is that the element ID's are reassigned meaning any data from the simulation cannot be used with the original mesh. So if anyone has any ideas on how to preserve the original IDs it would be a great help.\nI hope this helps in some way.\nBest Regards,\nMatt Mavis",
                  "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-147293",
                  "updatedAt": "2022-06-22T18:25:57Z",
                  "publishedAt": "2020-12-04T16:24:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear Matthew,\nThank you very much for your reply.\nI will look into the details of your code and give you feedback.\nFor sure the issue with the elements ID is a difficult one.\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-147304",
                          "updatedAt": "2022-06-22T18:25:58Z",
                          "publishedAt": "2020-12-04T16:34:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I think this would be useful to me too, but don't have time to implement it.  I wrote the BlockDeleter, which may give you some hints about what to do, if you choose to do it...",
                  "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-147641",
                  "updatedAt": "2022-06-22T18:25:58Z",
                  "publishedAt": "2020-12-05T00:40:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear Andy,\nThank you very much for your reply.\nIndeed, I think if block with specific IDs are deleted, the other blocks will maintain the original ID.\nSo this may be a better solution for me.\nI will let you know how it goes\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-147692",
                          "updatedAt": "2022-06-22T18:25:59Z",
                          "publishedAt": "2020-12-05T02:59:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear Moose Users,\nI developed the following strategy to delete elements:\n\nGenerate a new block with new id using ElementSubdomainIDGenerator\nDeleting that block using BlockDeletionGenerator\nOf course this will require a restart of the simulation, I restart the simulations at the point where I want to delete the elements using the\nSolutionUserObject and SolutionFunction as explained here:\nhttps://mooseframework.inl.gov/modules/porous_flow/restart.html\nI have tested and seems the variables are assigned correctly at the correct spatial position in the elements remaining after restart\nOf course the Element Global ID changes\n\nYou can find a simple example here:\nhttps://github.com/ngrilli/c_pfor_am/tree/main/test/tests/DeleteElementsRestart\nNow the question is: will such a method preserve the Material Properties declared in the material blocks?\nFor instance, I have plastic deformation and I don't want it to be reinitialized to zero after restart.\nCan you envisage a method to do so?\nI mean restarting the simulation with elements deleted, but preserving the Material Properties at the correct spatial positions in the remaining elements.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-148719",
                  "updatedAt": "2022-06-22T18:25:59Z",
                  "publishedAt": "2020-12-07T10:20:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@ngrilli The element deletion method is somehow on our radar to work on in the future. Instead, we have started to implement element activation for AM application recently, see #16008  It does the opposite thing to deletion, but the method would be similar. It handles material initialization as you asked about in that PR.",
                  "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-149099",
                  "updatedAt": "2022-06-29T13:31:46Z",
                  "publishedAt": "2020-12-07T16:23:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@dschwen and @dewenyushu they can comment on this better.",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-149203",
                          "updatedAt": "2022-06-29T13:31:54Z",
                          "publishedAt": "2020-12-07T16:25:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear Jiang Wen,\nThank you for your answer, it would be great to have that feature in the future, but I guess it's complicated to implement.\nFor the moment, I am testing the restart with SolutionUserObject and SolutionFunction.\nI am trying to understand if the material properties in the non-deleted elements, like plastic deformation gradient,\nare initialized from the values of the previous solution or are reinitialized by the Material Class (like for a new simulation).\nI am sure the plastic deformation gradient is taken from the previous solution with the \"basic restart\" method,\nwhen the mesh before and after coincide,\nbut not sure if that is still valid with SolutionUserObject and SolutionFunction.\nI will let you know what I find.\nBest Regards,\nNicol\u00f2 Grilli",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-154290",
                          "updatedAt": "2022-06-29T13:31:54Z",
                          "publishedAt": "2020-12-07T17:13:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Our element activation capability should be readily extendable to element deletion. This is because we have \"active\" and \"inactive\" subdomains, during element activation, we move elements from \"inactive\" ->\"active\" subdomain. Element deletion will be the opposite (i.e., move elements from \"active\" ->\"inactive\" subdomain), which seems to be a minor change to #16008 .\nThe current PR already takes care of material initialization, updates boundary, does not require any change to the existing physics modules, and is computationally efficient since only the \"active\" dofs will appear in the system.",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-154411",
                          "updatedAt": "2022-06-29T13:31:55Z",
                          "publishedAt": "2020-12-07T17:25:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thanks @dewenyushu , this is a nice addition to MOOSE.   In the past i have simply set the solid-mechanical stiffness of \"deleted\" elements to zero, or the thermal conductivity to zero, or the permeability to zero, etc (depending on the physics).  But to be able to actually delete the elements is much nicer.",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-162481",
                          "updatedAt": "2022-09-02T14:11:54Z",
                          "publishedAt": "2020-12-07T21:12:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear Dewen,\nThank you very much for your answer,\nI will try your modifications and give you feedback.\nYes, I think element deletion is somehow easier than insertion.\nI have tried using simulation restart with SolutionUserObject and SolutionFunction,\nbut the Material Properties are reinitialized in the elements that are not deleted,\ntherefore this is not helpful for history dependent materials like plasticity.\nIt would be great to have your modifications released in MOOSE.\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-162961",
                  "updatedAt": "2022-06-29T13:31:55Z",
                  "publishedAt": "2020-12-08T09:08:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Sounds great! I suppose the solution provided in the PR can help with the material property issue. Let me know how it goes.",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-163730",
                          "updatedAt": "2022-06-29T13:31:56Z",
                          "publishedAt": "2020-12-08T16:15:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @dewenyushu\nI have tested your code modification for element activation/deactivation.\nIt works well in terms of moving elements from the \"inactive block\" to the \"active block\".\nHowever, I see that the stress is still calculated on both active and inactive domains\nand the boundary conditions I impose on the active domain are inducing stress and displacement also on the inactive domain.\nThis happens also in your example:\ncheck_element_addition_by_variable.i\nYou mentioned in your code only the active DOF will appear,\nso perhaps I am not understanding well.\nThis is the test I was looking at:\nhttps://github.com/ngrilli/c_pfor_am/tree/main/test/tests/AddElements\nBasically half the domain is active, half is inactive.\nI apply displacement on a boundary of the active and I see the inactive domain moving as well.\nTherefore the DOF of the inactive seem not be inactive.\nThank you very much in advance for your answer.\nBest Regards,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-205613",
                          "updatedAt": "2022-06-29T13:31:59Z",
                          "publishedAt": "2020-12-14T17:15:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "@ngrilli thanks for trying this!\nYou will need to make sure your variables (displacements and stresses), kernels (TensorMechanics), and materials are block-restricted, e.g., block = '1'.\nMOOSE will throw out error about no kernel is defined in the inactive block, so you will need to add the following in your input as well.\n[Problem]\n  kernel_coverage_check = false\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-205782",
                          "updatedAt": "2022-06-29T13:31:57Z",
                          "publishedAt": "2020-12-14T17:52:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @dewenyushu\nYes, your suggestion worked and your code seems to add elements fine for my application.\nI have created some test cases where I see the stress appearing in new elements under load:\nhttps://github.com/ngrilli/c_pfor_am/tree/main/test/tests/AddElements\nI will now try to modify the code to move elements from the active to the inactive block.\nI am still studying the part of the code that updates the boundary sets and not sure that has to be changed.\nFor the moment I will modify only the function\nActivateElementsUserObjectBase::execute()\nI will keep you updated about the results.\nThank you very much again for your help.\nBest Regards,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-210474",
                          "updatedAt": "2022-07-01T03:11:54Z",
                          "publishedAt": "2020-12-15T16:31:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Sounds great!\nBefore looking deeper/trying to change the code, I would suggest trying the following:\n\nDefine your kernels, variables, materials on the block that you want to delete elements from, say block = '2'\nThen in the ActivateElementsCoupled user object, set active_subdomain_id = '1'\n\nIt may just work. The element activation code is basically moving elements from one subdomain to another. So in theory it should not prevent us from doing element deletion without much code change. Outside of the user object, we can always define our FEProblem in the subdomain that the elements are moved to or from by using the block restricted capability.",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-210507",
                          "updatedAt": "2022-07-01T03:11:54Z",
                          "publishedAt": "2020-12-15T16:45:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@dewenyushu @MatthewMavis @jiangwen84\nDear Dewen,\nI have completed and tested an implementation where I can do both element activation and deactivation based on a condition:\nhttps://github.com/ngrilli/c_pfor_am\nIt is a minor modification of your code.\nAs you suggested I move elements from the inactive block to the active block and vice versa\nbased on the condition.\nIn this way the plastic deformation is reinitialised properly when elements are reactivated.\nThe \"moving interface\" is not yet updated correctly during element elimination.\nI think more modifications are needed for this.\nHowever, I am not applying any boundary condition on the \"moving interface\"\nand my understanding is that there is stress free boundary condition at the boundary between the\nactive block and deactivated block.\nI am happy if someone can check and test my implementation\nI think it is quite interesting for the mechanics community.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-256254",
                  "updatedAt": "2022-07-01T03:11:51Z",
                  "publishedAt": "2021-01-02T05:55:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Thanks @ngrilli for sharing your branch with us.\nI looked at your example c_pfor_am/test/tests/ElementAddDelete/ElementAddDeleteDispX.i. One issue may result in incorrect moving_interface  update is that you may have specified the wrong Mesh/sidesets/normal. It seems that you have left and right subdomains. Therefore, the initial moving_interface should have normal = '1 0 0' (+x direction) instead of normal='0 0 1'(+z direction). Hope this would fix the issue.\nNevertheless, I am happy that most of the part works for your application!",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-260307",
                          "updatedAt": "2022-07-01T03:11:58Z",
                          "publishedAt": "2021-01-04T15:42:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "@ngrilli  @dewenyushu\nHi guys,\nI am very new to MOOSE, been using it for less than a month, but I found it very powerful.\nI've been working on mine stimulation, right now I can do the blockdeletion for a simple model\nHowever, I would like to know if it is possible to add the block/element back to the void space (backfill) without altering the strain on surrounding area (strain-free).\nto make it clearer, here's the workflow:\ncreate a solid geometry -> remove a block -> run a equalibirum simulation with gravity activate -> the void is deformed due to stress\n-> backfill the material back into the void without altering the deformation from the previous step.\nAnother question I have is: when I use 'BlockDeletionGenerator', the block is gone, the issue would also be that: how can i locate the position of the backfill if I no longer have the deleted block in the system.\nI read @ngrilli reply back in Jan, but i am not sure if it will works for my problem, could you please clarify, thanks!.\nThank you\nKind regards,\nTrai\nbelow is my script for blockdeletion\n[Mesh]\n[./gen]\ntype = FileMeshGenerator\nfile = equlstep_step0.e\n# show_info = true\nuse_for_exodus_restart = true\n# exodus_extra_element_integers = 's11_aux s22_aux s33_aux'\n[]\n[mergedBox]\ntype = RenameBlockGenerator\ninput = gen\nold_block_id = '2'\nnew_block_id = '1'\n[]\n[ed0]\ntype = BlockDeletionGenerator\ninput = mergedBox\nblock_id = 1\n[]\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-428072",
                  "updatedAt": "2022-07-01T03:11:59Z",
                  "publishedAt": "2021-03-04T05:17:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "You are correct: once you have used BlockDeletionGenerator, the block simply does not exist and you cannot add the block's elements back to the simulation again.  You could: (1) create another model without the deletion and read the results from the deleted-model during the initialization; or (2) use a different method like setting the young's modulus of your \"deleted\" elements to zero, solving, and then resetting the young's modulus to the original value.   However, i suggest you use neither of these methods, and instead try the method described by @ngrilli and @dewenyushu above.",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-428092",
                          "updatedAt": "2022-07-18T13:12:14Z",
                          "publishedAt": "2021-03-04T05:36:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @Traiwit\nYou can find a test case for deleting and reactivating element in my repository:\nhttps://github.com/ngrilli/c_pfor_am/tree/main/test/tests/ElementAddDelete\nWhen an element is reactivated (moved to the active subdomain), it will not affect affect directly the strain in the other elements.\nThe nodes that are shared between the active elements and the reactivating element will keep the same displacement\nthat they had at the previous time step.\nThe displacement in the newly activated nodes will be initialized based on your displacement ICs (default is 0).\nThe Material Properties will be reinitialized based on your material objects.\nIf the element is reactivated at the beginning of the time step\n(flag execute_on = timestep_begin in ActDeactElementsCoupled),\nit will affect the strain in the neighbouring elements at the end of the time step\nbecause the element will be considered in the equilibrium equations.\nTrust this helps.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-429457",
                          "updatedAt": "2022-07-18T13:12:14Z",
                          "publishedAt": "2021-03-04T14:39:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "@Traiwit I agree with what @ngrilli explained above and I think the element deletion and reactivation should help your problem.\nIn addition to this, I would like to mention that there is a new implementation by @hugary1995 to unify element activation, deletion, and moving interface, which is based on the element activation code Nicolo and I used, but is more general and flexible in terms of moving elements from one subdomain to another.\n#17101",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-429876",
                          "updatedAt": "2022-07-18T13:12:13Z",
                          "publishedAt": "2021-03-04T16:15:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@WilkAndy @ngrilli @dewenyushu\nThank you for all your help, I attempted all the methods you all suggested, but I found \"use a different method like setting the young's modulus of your \"deleted\" elements to zero, solving, and then resetting the young's modulus to the original value.\" method is the most applicable to my problem.\nHowever, when I changed the young's modulus value of the 'deleted' block back to original and run the elastic equlibirium simulation, it pushes the deleted block back the the pre-deformed shape which i do not want. is there anyway to work around this?\nfigure1: pre elastic equlibirium simulation, the green block is the deleted block (applied low young's modulus)\n\nfigure2: after the simulation, the green block got pushed back\n\nI tried to use \"use_displaced_mesh = true\" at every possible location in my input file, but still couldn't solve this problem.\nThank you again\nKind regards,\nTraiwit from Australia",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-444322",
                          "updatedAt": "2022-07-18T13:12:24Z",
                          "publishedAt": "2021-03-08T04:00:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I think you've got to model what actually happens in real life.   What is the material being \"added back\"?",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-444394",
                          "updatedAt": "2022-07-18T13:12:41Z",
                          "publishedAt": "2021-03-08T04:04:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi Andy,\nExactly the same material as before it got deleted.\nas shown below, i have 3 materials = geo (geology), void, and blackfill.\nso for block2 the steps are: elastic bulk model > detetion > backfill\nThe objective here is to backfill the material into the deformed mesh.\nRegards,\nTraiwit\n[Materials]\n[./strain]\ntype = ComputeFiniteStrain\n# eigenstrain_names = ini_stress\ndisplacements = 'disp_x disp_y disp_z'\n[../]\n[./stress]\ntype = ComputeFiniteStrainElasticStress\n[../]\n[./elasticity_tensor_geo]\ntype = ComputeIsotropicElasticityTensor\nyoungs_modulus = 20e9\npoissons_ratio = 0.25\nblock = '0 3'\nuse_displaced_mesh = true\n[../]\n[./elasticity_tensor_void]\ntype = ComputeIsotropicElasticityTensor\nyoungs_modulus = 100000\npoissons_ratio = 0.3\nblock = '1'\nuse_displaced_mesh = true\n[../]\n[./elasticity_tensor_backfill]\ntype = ComputeIsotropicElasticityTensor\nyoungs_modulus = 20e9\npoissons_ratio = 0.3\nblock = '2'\nuse_displaced_mesh = true\n[../]\n[./density_geo]\ntype = GenericConstantMaterial\nprop_names = density\nprop_values = 2700 # kg/m3\nblock = '0 3'\nuse_displaced_mesh = true\n[../]\n[./density_void]\ntype = GenericConstantMaterial\nprop_names = density\nprop_values = 1.225 # kg/m3\nblock = '1'\nuse_displaced_mesh = true\n[../]\n[./density_backfill]\ntype = GenericConstantMaterial\nprop_names = density\nprop_values = 2700 # kg/m3\nblock = '2'\nuse_displaced_mesh = true\n[../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-444513",
                          "updatedAt": "2022-07-18T13:12:40Z",
                          "publishedAt": "2021-03-08T04:10:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "To me, this sounds like a mining scenario.  In mining, the \"backfill\" is not identical to the unmined rock.  It is significantly softer, and probably has a much larger Poisson's ratio.   You will have to determine exactly what material properties you need to assign to the backfill.  You will also need to set \"strain = 0\" in the element as it is backfilled (or measure the stress relative to the strained material).\nIf it is not a mining scenario and you really are backfilling with identical material, then MOOSE might be doing exactly what you want!",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-444801",
                          "updatedAt": "2022-07-18T13:12:43Z",
                          "publishedAt": "2021-03-08T04:33:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @WilkAndy,\nThank you for your suggestion, yes, I am making a prototype simulation for mining scenarios, and I am new to the field.\nI agree the backfill material should have a much lower young modulus, I set it to 0.001xE_orginal.\nI am currently looking for a strain-free (=0) way to backfill this material back into the particular block of the system using MOOSE, do you have any suggestion? Since we cannot directly change the value of strain within the input file.\nI found 'Compute Eigenstrain' https://mooseframework.inl.gov/source/materials/ComputeEigenstrain.html, will it work if I set all the 'eigen_base  = 0'. I've also found 'ComputeEigenstrainFromInitialStress' https://mooseframework.inl.gov/source/materials/ComputeEigenstrainFromInitialStress.html which sounds like it might work as well.\nThank you for help, I appreciate it\nKind regards,\nTraiwit from Australia",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-448138",
                          "updatedAt": "2022-07-18T13:12:43Z",
                          "publishedAt": "2021-03-08T07:55:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Hi @Traiwit ,\nSo, i think you might be able to use controls to ensure the strain-setting activates at the correct time, but it might also be easier to write some C++ yourself.\nA few related side notes:\n\nYou're probably aware, but your situation is likely to be inelastic.  I've created lots of rock-mechanics plasticity classes (various versions of Drucker-Prager, Mohr-Coulomb and weak-plane) that might be useful.\nYou will have to be careful about the roof penetrating the floor\nDo you work for CSIRO?  If so, i can help and we have our own private app designed for mining situations, and you can use it.\n\na",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-449513",
                          "updatedAt": "2022-07-18T13:12:45Z",
                          "publishedAt": "2021-03-08T09:54:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @WilkAndy,\nYes, I will look into that.\nRe: side notes\n\nYes I am fully aware, that will be my next step to work on the inelastic (plastic/non-linear) problems. Is the model you mentioned available online or it is internal to CSIRO? It will be very helpful for my project.\nWill keep that in mind\nI am not with CSIRO, but I know many people there are using MOOSE for their modelling, my PhD colleague is also working with CSIRO on the Hydrogen storage model.\n\nAgain, thank you for your suggestions.\nKind regards,\nTraiwit from Australia",
                          "url": "https://github.com/idaholab/moose/discussions/16387#discussioncomment-450049",
                          "updatedAt": "2022-07-18T13:12:45Z",
                          "publishedAt": "2021-03-08T13:06:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to avoid the bubble on the boundary using MultiSmoothCircleIC",
          "author": {
            "login": "wenpeng231024"
          },
          "bodyText": "Hi Moose group,\nNow I try to use \"MultiSmoothCircleIC\" to build multiple bubbles sample.  But I found there are some bubbles on the boundary. Because my boundary condition is not a periodic boundary, do you know how to avoid the bubble on the boundary?\nThanks,\nPeng",
          "url": "https://github.com/idaholab/moose/discussions/17201",
          "updatedAt": "2022-12-28T12:01:38Z",
          "publishedAt": "2021-03-03T15:19:33Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Right now it is only set up assuming periodic BCs. If you want to try modifying the code to avoid having bubbles intersect boundaries, I can suggest how it can be done. Another option would be to use SpecifiedSmoothCircleIC, then you can place the bubbles exactly where you want them.",
                  "url": "https://github.com/idaholab/moose/discussions/17201#discussioncomment-456155",
                  "updatedAt": "2022-12-28T12:01:38Z",
                  "publishedAt": "2021-03-09T16:58:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wenpeng231024"
                          },
                          "bodyText": "Got it. I will try to use SpecifiedSmoothCirclesIC to place the bubbles. Thanks very much.\nPeng",
                          "url": "https://github.com/idaholab/moose/discussions/17201#discussioncomment-456214",
                          "updatedAt": "2022-12-28T12:01:39Z",
                          "publishedAt": "2021-03-09T17:12:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How can I create a austenite growing in to pearlite microstructure?",
          "author": {
            "login": "Henrique-B-Pereira"
          },
          "bodyText": "Hello,\nI'm new to the program. I literally installed and ran the first example yesterday.\nI am looking to do a model that involves the growth of austenite from a completely pearlitic microstructure, similar to this example:\n\nAfterwards, I would like to use the same microstructure generated from the simulations and return with the pearlite transformation.\nIs there a tutorial / example that I can take as a basis?\nWhat suggestion can you give me that I can do this simulation?",
          "url": "https://github.com/idaholab/moose/discussions/17212",
          "updatedAt": "2023-03-10T11:20:12Z",
          "publishedAt": "2021-03-03T19:38:11Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hello Henrique,\nThis is probably best modeled with a single order parameter that distinguishes between the austenite and pearlite phases, and composition variables for each solute atom. A KKS-type model would probably work best:\nhttps://mooseframework.inl.gov/modules/phase_field/MultiPhase/KKS.html\nThere are some examples given on the above web page. However, they are not going to be physically parameterized for the system you are looking at. Before you start trying to parameterize the model, I would highly suggest that you do some background reading on phase-field modeling if you aren't familiar with the methodology. The following page has a lot of good resources:\nhttps://pages.nist.gov/pfhub/",
                  "url": "https://github.com/idaholab/moose/discussions/17212#discussioncomment-456189",
                  "updatedAt": "2023-03-10T11:20:25Z",
                  "publishedAt": "2021-03-09T17:08:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Porous media module: to output final permeability field from different reads",
          "author": {
            "login": "zhang-rite"
          },
          "bodyText": "Hi\nI set the permeability of different regions (e.g., block1,2...) in a model separately.\nSo these can be saved in the exodus file separately.\nBut how can I export the final permeability field of the entire model to an exodus file by one variable name for visualization?\nPerhaps also for the setting of other materials.\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/17253",
          "updatedAt": "2024-11-03T04:33:15Z",
          "publishedAt": "2021-03-09T02:45:42Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Just create an AuxVariable that's defined over all the blocks",
                  "url": "https://github.com/idaholab/moose/discussions/17253#discussioncomment-452477",
                  "updatedAt": "2024-11-03T04:33:15Z",
                  "publishedAt": "2021-03-09T03:25:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zhang-rite"
                          },
                          "bodyText": "Andy, Thanks always. The problem is I have defined several Auxvarible over individual blocks.\nEach is set via RandomIC. I want to apply random permeability fields with different ranges.",
                          "url": "https://github.com/idaholab/moose/discussions/17253#discussioncomment-452502",
                          "updatedAt": "2024-11-03T04:33:33Z",
                          "publishedAt": "2021-03-09T03:55:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "You can probably join the variables together in paraview\nAlternatively, define a new AuxVariable, and use PorousFlowPropertyAux with property = permeability, along with row and column to populate it.",
                          "url": "https://github.com/idaholab/moose/discussions/17253#discussioncomment-452513",
                          "updatedAt": "2024-11-03T04:33:33Z",
                          "publishedAt": "2021-03-09T04:08:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Calculation of reaction forces on the loading boundary",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Dear all,\nI wonder if there is any default method (possibly through the aux kernels) to compute the reaction forces in the boundary where the loads (displacement controlled) are applied. I know this can be done via the stresses (stress_xx) in the loading direction when multiplied by the cross-sectional area of the boundary, but can be slightly inaccurate at times. ANSYS does a better comparison where the loads are extracted for the respective boundary from the in-built 'Force-reaction' solution module. Attached please see the comparison. However it showed a huge difference when the conventional path of (stress_xx*area) was followed. Any guidance on the correct method to compute the loads in MOOSE would be highly appreciated.\nKind regards,\nArun",
          "url": "https://github.com/idaholab/moose/discussions/16945",
          "updatedAt": "2022-10-21T23:56:27Z",
          "publishedAt": "2021-02-10T19:23:07Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can save the residuals from the StressDivergence kernels into an AuxVariable, and then sum up the residual on whatever boundary you want to evaluate the reaction force there. If you search for \"save_in\" in the tensor_mechanics module's regression tests you'll find enough examples.",
                  "url": "https://github.com/idaholab/moose/discussions/16945#discussioncomment-357798",
                  "updatedAt": "2022-10-11T13:51:17Z",
                  "publishedAt": "2021-02-10T20:06:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Dear Gary,\nThanks for the suggestion. This seems to be the approach that would potentially give close results with ANSYS and experiments, however i am stuck with trouble when the volumetric locking correction is included, which screws up the results at large strains. The plasticity model at its usual self requires 'volumetric locking correction' option to be included to give correct results at these strains. The stress divergence calculations (done through ADStressDivergenceTensors) however requires this option to be switched OFF it it were to execute correctly. This however gives wrong results (please see the achieved matching in the attached plot). On the other hand setting 'volumetric locking correction' to TRUE gives the following error.\n*** ERROR ***\nVolumetric locking correction should be set to false for 1-D problems\nBeing a 3D problem, i could not find reasons for this error and would like to know from you whether there is any possible fix. I tried setting dim=3 in the mesh block with out much success. One more issue i wanted to discuss here is the negative jacobian obtained for certain elements during the course of computation (possibly stress divergence), although it does not interfere with the results. I wonder whether this is something that  needs attention. Also there seems to be 'MooseException' raised during the computation of Aux variable (please see the .log file) which needs a further look-in.\nI guess we almost found the correct set of input commands (see the attached .i file) to be included that calculate precisely the reaction forces. If this can be done with locking correction ON the problem is solved. I welcome your suggestions in this regard.\nKind regards,\nArun\n16022021.zip",
                          "url": "https://github.com/idaholab/moose/discussions/16945#discussioncomment-374389",
                          "updatedAt": "2022-10-11T13:51:17Z",
                          "publishedAt": "2021-02-16T17:32:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Sorry Arun I'm late on this. Setting volumetric_locking_correction = true is the correct thing to do here. The relevant logic for that error can be found in ADStressDivergenceTensors.C:\nif (_ndisp == 1 && _volumetric_locking_correction)\n    mooseError(\"Volumetric locking correction should be set to false for 1-D problems.\");\n\nSo the kernel must think you only coupled one displacement to it. Indeed, in the input file you had displacements = disp_x in ADStressDivergenceTensors, therefore it overrides your GlobalParams definition of displacements = 'disp_x disp_y disp_z'.\nSimply removing displacements = disp_x and similarly the lines displacements = disp_y and displacements = disp_z should work.",
                          "url": "https://github.com/idaholab/moose/discussions/16945#discussioncomment-381268",
                          "updatedAt": "2022-10-11T13:51:32Z",
                          "publishedAt": "2021-02-18T14:57:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "Dear all,\nI peformed an exercise in setting the elements to SECOND order to bye-pass the problems associated with 'volumetric_locking_correction' so that i get same response as physical tests.  This time i received a seg fault error (as given below), which i wanted to report. Please could you comment if the second order elements are a better way to avoid locking behaviour and achieve correct results.\nAlso let me know how this memory crash can be reported.\n(base) abalasub@freia013> ../../../hardening_model_app-opt -i PieceWise_test.i\nFramework Information:\nMOOSE Version:           git commit 4c15601 on 2021-02-12\nLibMesh Version:         c70ab40900490f44391f1b891c8c3731c45f0cf1\nPETSc Version:           3.14.2\nSLEPc Version:           3.14.0\nCurrent Time:            Thu Feb 18 11:00:26 2021\nExecutable Timestamp:    Mon Feb 15 19:33:31 2021\nParallelism:\nNum Processors:          1\nNum Threads:             1\nMesh:\nParallel Type:           replicated\nMesh Dimension:          3\nSpatial Dimension:       3\nNodes:\nTotal:                 12369\nLocal:                 12369\nElems:\nTotal:                 1242\nLocal:                 1242\nNum Subdomains:          1\nNum Partitions:          1\nNonlinear System:\nNum DOFs:                37107\nNum Local DOFs:          37107\nVariables:               { \"disp_x\" \"disp_y\" \"disp_z\" }\nFinite Element Types:    \"LAGRANGE\"\nApproximation Orders:    \"SECOND\"\nAuxiliary System:\nNum DOFs:                86787\nNum Local DOFs:          86787\nVariables:               { \"stress_xx\" \"strain_xx_av\" \"plastic_strain_xx\" \"vonmises\" } { \"resid_x\"\n\"resid_y\" \"resid_z\" }\nFinite Element Types:    \"MONOMIAL\" \"LAGRANGE\"\nApproximation Orders:    \"SECOND\" \"SECOND\"\nExecution Information:\nExecutioner:             Transient\nTimeStepper:             ConstantDT\nSolver Mode:             Preconditioned JFNK\nMOOSE Preconditioner:    SMP\nLEGACY MODES ENABLED:\nThis application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate diffs due to zero values being stored, and these tests should be re-golded.\nProjecting initial condition                                                               [  1.39 s]\nComputing initial stateful property values                                                 [  1.19 s]\nTime Step 0, time = 0\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | VonMises       | disp_xx        | p_xx           | resid_x        | s_xx           | strain_xx_pp   |\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\nTime Step 1, time = 0.1, dt = 0.1\nComputing initial residual .                                                               [  2.37 s]\n0 Nonlinear |R| = 1.192609e+09\nSegmentation fault\nKind regards,\nArun\nPieceWise_test.txt",
                  "url": "https://github.com/idaholab/moose/discussions/16945#discussioncomment-380701",
                  "updatedAt": "2022-10-13T08:34:56Z",
                  "publishedAt": "2021-02-18T11:26:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "Dear Gary,\nWe nearly identified the methods (especially the usage of 'ADStressDivergenceTensors') needed to achieve the correct results.  Definition of volumetric locking correction and displacements variables are done in the global parameters block and never allowed to get over-written thereafter. The only thing i wish to highlight was regarding the accuracy of the results computed by this kernel.  Setting OFF 'use_displaced_mesh' produced exact results (as ANSYS and experiments) up to the UTS and showed a marked difference thereafter.  On the other hand setting this option to TRUE gives acceptable close results (as in the attached plot), but not the exact fit one would look for. I still believe there is further scope to improve the accuracy of results, which i am unaware of.  Request you please to take a look at the attached input commands and let me know your suggestions.\n\nPieceWise_test.txt\nKind regards,\nArun",
                  "url": "https://github.com/idaholab/moose/discussions/16945#discussioncomment-401235",
                  "updatedAt": "2022-10-13T08:35:21Z",
                  "publishedAt": "2021-02-24T13:17:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Hello Arun,\nThere are two separate sets of things you are trying to do here:\n\nsetting up the correct input file, and\ntuning parameters to match the experiment.\n\nI don't think you can do both at the same time. I would first make sure 1 is done, then 2.\nI see that in the input file you are using the tensor mechanics action. That action will set up the correct kernels and strain calculators for you -- so you don't need to define them. In fact, I would just remove the kernel you had in there.\nJust so we are on the same page, the input file after modification should look like this:\n# A UserObject IsotropicSD test, with power rule hardening with rate 1e2.\n# Linear strain is applied in the x and y direction.\n\n[Mesh]\n  type = FileMesh\n  file = Specimen_QtrModel.e\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  volumetric_locking_correction = true\n[]\n\n[Modules/TensorMechanics/Master]\n  [./all]\n    strain = FINITE\n    incremental = true\n    add_variables = true \n    use_automatic_differentiation = true\n    save_in = 'resid_x resid_y resid_z'\n  [../]\n[]\n\n[BCs]\n  [./Load_RE]\n    type = FunctionDirichletBC\n    variable = disp_x\n    function = '0.0226*t*(0.15/0.125)'\n    boundary = \"Right_end\"\n  [../]\n  [./Symm_LE]\n    type = ADDirichletBC\n    variable = disp_x\n    value = 0\n    boundary = \"Left_end\"\n  [../]\n  [./Symm_BY]\n    type = ADDirichletBC\n    variable = disp_y\n    value = 0.0\n    boundary = \"Bottom\"\n  [../]\n  [./Symm_LZ]\n    type = ADDirichletBC\n    variable = disp_z\n    value = 0.0\n    boundary = \"Lateral_face\"\n  [../]\n  [./Const_RY]\n    type = ADDirichletBC\n    variable = disp_y\n    value = 0.0\n    boundary = \"Right_end\"\n  [../]\n  [./Const_RZ]\n    type = ADDirichletBC\n    variable = disp_z\n    value = 0.0\n    boundary = \"Right_end\"\n  [../]\n[]\n\n[AuxVariables]\n  [./stress_xx]\n    order = FIRST\n    family = MONOMIAL\n  [../]\n  [./strain_xx_av]\n   order = FIRST\n    family = MONOMIAL\n  [../]\n  [./plastic_strain_xx]\n    order = FIRST\n    family = MONOMIAL\n  [../]\n  [./vonmises]\n    order = FIRST\n    family = MONOMIAL\n  [../]\n  [./resid_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./resid_y]\n  [../]\n  [./resid_z]\n  [../]\n[] \n\n[AuxKernels]\n  [./stress_xx]\n    type = ADRankTwoAux\n    rank_two_tensor = stress\n    variable = stress_xx\n    index_i = 0\n    index_j = 0\n  [../]\n  [./strain_xx_ak]\n    type = ADRankTwoAux\n    rank_two_tensor = total_strain\n    variable = strain_xx_av\n    index_i = 0\n    index_j = 0\n  [../]\n  [./vonmises]\n    type = ADRankTwoScalarAux\n    rank_two_tensor = stress\n    variable = vonmises\n    scalar_type = VonMisesStress\n  [../]\n  [./plastic_strain_xx]\n    type = ADRankTwoAux\n    rank_two_tensor = plastic_strain\n    variable = plastic_strain_xx\n    index_i = 0\n    index_j = 0\n  [../]\n[] \n\n[Postprocessors]\n  [./disp_xx]\n    type = SideAverageValue\n    variable = disp_x\n    boundary = \"Right_end\"\n  [../]\n  [./s_xx]\n    type = SideAverageValue\n    variable = stress_xx\n    boundary = \"Right_end\"\n  [../]\n  [./p_xx]\n    type = SideAverageValue\n    variable = plastic_strain_xx\n    boundary = \"Left_end\"\n  [../]\n  [./strain_xx_pp]\n    type = SideAverageValue\n    variable = strain_xx_av\n    boundary = \"Left_end\"\n  [../]\n  [./VonMises]\n    type = SideAverageValue\n    variable = vonmises\n    boundary = \"Right_end\"\n  [../]\n  [./resid_x]\n    type = SideAverageValue\n    variable = resid_x\n    boundary = \"Right_end\"\n  [../]\n[]\n\n[Functions]\n  [./hf]\n    type = PiecewiseLinear\n    data_file = PW_last_iter_AsIs_extractedYield_start.csv\n    scale_factor = 1\n    format = columns\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 2.02E+11\n    poissons_ratio = 0.315\n  [../]\n  [./isotropic_plasticity]\n    type =ADIsotropicPlasticityStressUpdate\n    yield_stress = 554146341.5\n    hardening_function = hf\n    use_displaced_mesh=true\n  [../]\n  [./radial_return_stress]\n    type = ADComputeMultipleInelasticStress\n    inelastic_models = 'isotropic_plasticity'\n  [../]\n[]\n\n[Executioner]\n  num_steps = 500\n  dt = 0.1\n  type = Transient\n\n  nl_rel_tol = 1e-6\n  nl_max_its = 20\n  l_tol = 1e-4\n  l_max_its = 100\n\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n[]\n\n[Outputs]\n  perf_graph = false\n  exodus = true\n  csv = true\n[]\n\n[Preconditioning]\n [./smp]\n   type = SMP\n   full = true\n [../]\n[]\n\nThe parameters like \"use_displaced_mesh\" should be set to give you the correct solution, instead of tuned to give you results that are closer to the experimental data. In the case of finite deformation, we calculate cauchy stress in the stress calculator, so the stress divergence kernels should run on displaced mesh, i.e. use_displaced_mesh = true. Again, you don't need to worry about all this if you are using the action.",
                          "url": "https://github.com/idaholab/moose/discussions/16945#discussioncomment-427921",
                          "updatedAt": "2022-10-13T08:35:34Z",
                          "publishedAt": "2021-03-04T02:37:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "Dear Gary,\nThanks for the response. I agree that we must try and set up the correct solution with the input commands rather than matching with the experimental results. But the issue here is that we have variants of solution for different set of commands and the one that produces results close to the experiments is elusive here. If we manage to match the curves very closely, then we can say that we've found the most realistic solution. I would still like to retain the added kernel for stress divergence calculations as it gives a much improved fit as compared to running without them (Please see the attached plot). The fact that we achieve an exact fit without the usage of 'use_displaced_mesh' in the divergence kernel (other plot) atleast for the small strain limit suggests that some other options could play a part here and there is very much hope that we get an exact solution.\nKind regards,\nArun",
                  "url": "https://github.com/idaholab/moose/discussions/16945#discussioncomment-451078",
                  "updatedAt": "2022-10-13T08:37:11Z",
                  "publishedAt": "2021-03-08T17:56:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Switch DirichletBC to NeumannBC on the same boundary",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "Dear MOOSE Team,\nI need to set DirichletBC at time = 0, then switch the DirichletBC to NeumannBC for time > 0 on the same boundary.\nPlease help.\nS. Thomas",
          "url": "https://github.com/idaholab/moose/discussions/17238",
          "updatedAt": "2023-02-23T16:21:03Z",
          "publishedAt": "2021-03-05T18:50:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "josebastiase"
                  },
                  "bodyText": "Hi,\nI'm not sure whether this is implemented in MOOSE already, but I would try using controls.\nhttps://mooseframework.inl.gov/syntax/Controls/\nCheers,\nJose",
                  "url": "https://github.com/idaholab/moose/discussions/17238#discussioncomment-449606",
                  "updatedAt": "2023-03-06T07:44:17Z",
                  "publishedAt": "2021-03-08T10:43:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @styyokuda\nIf it's just at time 0, you could set an initial condition on the variable of interest using FunctionIC.\nBy setting the initial condition as a function of the coordinates x,y,z\nyou can make sure the initial condition is applied only on the boundary of choice at time 0.\nOtherwise, what I did in the past was to use the \"basic restart\" procedure described here:\nhttps://mooseframework.inl.gov/modules/porous_flow/restart.html\nIn the restart input file you can just remove the DirichletBC and the solver will apply NeumannBC\nin the restarted simulation.\nTrust this helps.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/17238#discussioncomment-450170",
                  "updatedAt": "2023-03-06T07:44:24Z",
                  "publishedAt": "2021-03-08T13:56:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Thank you for mesh-only plaintext info",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "To whoever added some nice plaintext info into the output generated by \"--mesh-only\": Thank you!\na",
          "url": "https://github.com/idaholab/moose/discussions/17244",
          "updatedAt": "2021-03-17T18:37:39Z",
          "publishedAt": "2021-03-07T23:26:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "Your agreement in #16783 gave me the idea to include it elsewhere!\nI was thinking about an option to make it a little less verbose - but only if people are frustrated by it \ud83d\ude06",
                  "url": "https://github.com/idaholab/moose/discussions/17244#discussioncomment-440896",
                  "updatedAt": "2021-03-08T00:33:42Z",
                  "publishedAt": "2021-03-08T00:33:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}