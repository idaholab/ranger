{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNy0yMlQwOToyMDo0MC0wNjowMM4AQKDq"
    },
    "edges": [
      {
        "node": {
          "title": "How to output variables in source codes to exodus file",
          "author": {
            "login": "pshen20127"
          },
          "bodyText": "Hello all\nI hope to output a variable 'equivalent_slip_increment' in the file 'ComputeMultipleCrystalPlasticityStress.C' when running the simulation. I directly add a AuxVariable in input file as below. But the output value is zero. What should I do to fix it? Thanks. (Input file 'polycrystal.txt' is attached)\n\n\n\n\npolycrystal.txt",
          "url": "https://github.com/idaholab/moose/discussions/21585",
          "updatedAt": "2022-07-25T16:13:54Z",
          "publishedAt": "2022-07-14T04:07:26Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "Hi @pshen20127,\nThe Rank-2 tensor equivalent_slip_increment is a local variable and the RankTwoAux auxvariable works with those Rank-2 tensors that are declared as material properties. See the declaration of the plastic_deformation_gradient in ComputeMultiCrystalPlasticityStress here: \n  \n    \n      moose/modules/tensor_mechanics/src/materials/crystal_plasticity/ComputeMultipleCrystalPlasticityStress.C\n    \n    \n         Line 82\n      in\n      3bb5876\n    \n  \n  \n    \n\n        \n          \n           _plastic_deformation_gradient(declareProperty<RankTwoTensor>(\"plastic_deformation_gradient\")), \n        \n    \n  \n\n\nIf you would like to monitor the change in plastic strain, the plastic_deformation_gradient may be a good option. If you would like to monitor the slip increment on individual slip systems, the vector slip_incrementwould be a good option. Use the AuxKernel MaterialStdVectorAux as shown in this regression test input file: https://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/test/tests/crystal_plasticity/stress_update_material_based/update_method_test.i\nFinally, please post input file snippets as quoted text, not as screenshots, as outlined in the posting guidelines here: #18270\nHope this helps!",
                  "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3147723",
                  "updatedAt": "2022-07-14T14:35:11Z",
                  "publishedAt": "2022-07-14T14:35:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Hi Thank you for reply. Very useful. Is there a way to output plastic strain instead of plastic deformation gradient?",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3148264",
                          "updatedAt": "2022-07-14T15:40:55Z",
                          "publishedAt": "2022-07-14T15:40:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "There is not a direct way to output the plastic strain. When I have wanted to determine the plastic strain, I output the total strain (e.g. total_lagrangian_strain), monitor the plastic deformation gradient diagonal terms for when the value changes from 1.0 (larger or smaller depends on the loading conditions and the location in the diagonal). I take the value of the total strain, at the timestep before the plastic deformation gradient changes from 1.0, as the elastic strain. Finally, I subtract that value of elastic strain from the total strain, at timesteps after the plastic deformation changes from 1.0, to determine the plastic strain.\nNote that this method assumes no eigenstrain in the simulation.",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3148505",
                          "updatedAt": "2022-07-14T16:06:02Z",
                          "publishedAt": "2022-07-14T16:06:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Nice. My output elastic strain is always zero. Do you know what's wrong with my setting(please see attached input file)? And is there a way to output true stress and strain?\npolycrystal.txt",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3149084",
                          "updatedAt": "2022-07-14T17:26:56Z",
                          "publishedAt": "2022-07-14T17:26:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "part a) I can take a look at your input file next week but I won't have time until then\npart b) Yes, use the material properties stress (the Cauchy stress) and total_strain",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3149252",
                          "updatedAt": "2022-07-14T17:48:50Z",
                          "publishedAt": "2022-07-14T17:48:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "No problem. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3150394",
                          "updatedAt": "2022-07-14T21:19:28Z",
                          "publishedAt": "2022-07-14T21:19:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Hi @pshen20127,\nThe elastic strain in your simulation is reported as zero because we do not save the calculated Green-Lagrange strain tensor  (defined with respect to the reference configuration) as a material property--turns out this is the same issue as with the equivalent_slip_increment tensor. In the crystal plasticity classes we have made the choice to not save this value to the elastic_strain variable because that strain measure is the Almansi strain tensor (defined with respect to the current configuration and the work conjugate of the Cauchy stress).\nThe elastic Green-Lagrange strain is defined locally in the ComputeMultipleCrystalPlasticityStress class here and the line 523 below: \n  \n    \n      moose/modules/tensor_mechanics/src/materials/crystal_plasticity/ComputeMultipleCrystalPlasticityStress.C\n    \n    \n         Line 522\n      in\n      4cb06f1\n    \n  \n  \n    \n\n        \n          \n           elastic_strain = ce - RankTwoTensor::Identity(); \n        \n    \n  \n\n\nIf you wanted to output that variable, you could define a new material property for that Green-Lagrange elastic strain within the ComputeMultipleCrystalPlasticityStress, and, if you wanted, contribute that change back to the MOOSE repository. As many members of the MOOSE team say, we accept merge requests :-)\nA final note: I saw in your input file that you are using only two displacement variables, disp_x and disp_y, and thus are essentially running a 2D simulation. Are you intended to use a crystal plasticity model in a 2D simulation?",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3193334",
                          "updatedAt": "2022-07-20T23:28:31Z",
                          "publishedAt": "2022-07-20T23:28:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Hi sapitts, yes, it's a 2D simulation. And thanks for your deteailed and very useful explanation.",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3224038",
                          "updatedAt": "2022-07-25T16:13:54Z",
                          "publishedAt": "2022-07-25T16:13:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Electromagnetics Module Based on edge element or node element\uff1f",
          "author": {
            "login": "AdelineHunter"
          },
          "bodyText": "Hi,\nIs the Electromagnetics Module developed based on the edge element method? Or based on the node element method\uff1f\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/21673",
          "updatedAt": "2022-08-13T16:13:37Z",
          "publishedAt": "2022-07-24T12:25:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "If you choose to solve the vector fields component-wise, you can use node elements. If you solve them directly as vectors, you use edge elements (specifically, Nedelec first order). See the benchmark examples for general module usage, and most of those use the edge element.",
                  "url": "https://github.com/idaholab/moose/discussions/21673#discussioncomment-3218508",
                  "updatedAt": "2022-07-25T03:13:59Z",
                  "publishedAt": "2022-07-25T03:09:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "One more note - you could use LAGRANGE_VEC type elements. That's just a vector of Lagrange node elements. Can be useful for transitioning an input file from component-wise to full vector.",
                          "url": "https://github.com/idaholab/moose/discussions/21673#discussioncomment-3218517",
                          "updatedAt": "2022-07-25T03:15:48Z",
                          "publishedAt": "2022-07-25T03:15:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Convergence Criterion",
          "author": {
            "login": "Krystalfang"
          },
          "bodyText": "Dear Expert,\nI recently tried to use MOOSE to simulate the conjugate heat transfer, but encountered the problem of non-convergence, so I want to ask what is the convergence criterion of MOOSE,  I set nl_rel_tol = 1e-6.\n\nBut it has been calculated until 10^-7, and the residuals of each variable are also less than 10^-6. The result is still not convergent, why is this?",
          "url": "https://github.com/idaholab/moose/discussions/21653",
          "updatedAt": "2022-08-13T16:14:08Z",
          "publishedAt": "2022-07-21T01:57:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "You are mixing absolute and relative tolerance up. Try setting nl_abs_tol = 1e-6. Your setting requires the initial residual to drop by 6 orders of magnitude, which is not always possible, if you start out with an initial guess that is very close to the solution.",
                  "url": "https://github.com/idaholab/moose/discussions/21653#discussioncomment-3193897",
                  "updatedAt": "2022-07-21T02:00:58Z",
                  "publishedAt": "2022-07-21T02:00:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The default convergence criteria are listed as the default parameters to the Executioner here:\nhttps://mooseframework.inl.gov/source/executioners/Steady.html\nPlease post a full log rather than these screenshots so we can see what is going on with the convergence history",
                  "url": "https://github.com/idaholab/moose/discussions/21653#discussioncomment-3218499",
                  "updatedAt": "2022-07-25T03:08:27Z",
                  "publishedAt": "2022-07-25T03:08:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE IGA",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "I've been doing some 'playing' with the recently merged IGA capabilities, which is great, I've been leveraging Coreform Cubit to generate the IGA relevant exodus files. One of the problems I've been playing with is a cylinder problem, one of the things I've noticed is that it I'm not getting the resolution I would expect from the output data, like its correct, but the output resolution seems to be tied to the underlying hex elements, rather than the highly curved elements originating from the IGA. I guess this is because its not clear how VTK should handle it, or is there a remap stage I should go through to get a better representation in plotting the data?\nAre other things supported as in 'regular' mesh, such as contact, I guess ray tracing doesn't work? I've not tried, but I'm sure someone is in the know.",
          "url": "https://github.com/idaholab/moose/discussions/21642",
          "updatedAt": "2022-08-13T16:14:32Z",
          "publishedAt": "2022-07-20T10:14:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@roystgnr",
                  "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3188990",
                  "updatedAt": "2022-07-20T13:08:59Z",
                  "publishedAt": "2022-07-20T13:08:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "I'm afraid right now there's two alternatives for IGA output: \"VTK 9\", or \"absolutely anything else\".  With the \"absolutely anything else\" option, we output Rational-Bernstein-Bezier control points as if they were Lagrange nodes, and yet no, no they aren't.  It's still useful for debugging a solution or visualizing the coarse features of a solution but not for any kind of post-processing.\nWith VTK 9 (or possibly 9.1?  see #21449), the Coreform folks added code for us to output rational elements natively in VTK (their own work on that end too! - https://www.kitware.com/implementation-of-rational-bezier-cells-into-vtk/ ).  I'm not sure how robust this is (I was getting failures from it locally, and we don't have the tests running in our regular CI...) however, and on top of that there's the problem that you need your viz program to also support rational elements.  IIRC Paraview is the only visualizer that supports rational curves so far, and you might need still need to put in some work on that side for proper support: https://discourse.paraview.org/t/nonlinear-subdivision-for-rational-bezier-curves-not-working/6522",
                  "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3190492",
                  "updatedAt": "2022-07-20T15:41:36Z",
                  "publishedAt": "2022-07-20T15:41:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Thanks for the reply, so I would compile libmesh with vtk 9.0, then that should be enough to get an appropriate vtk file out - possibly? Then build my own Paraview with vtk 9.0? Looking at one of the linked issues, I guess that would also allow MOOSE to export to VTK using the lagrangian FE elements for better represenation of 2nd order elements and results?",
                          "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3193095",
                          "updatedAt": "2022-07-20T22:16:04Z",
                          "publishedAt": "2022-07-20T22:16:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "msederberg"
                          },
                          "bodyText": "Do these details help? https://mooseframework.inl.gov/modules/tensor_mechanics/examples/cframe_iga.html",
                          "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3207154",
                          "updatedAt": "2022-07-22T15:13:30Z",
                          "publishedAt": "2022-07-22T15:13:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GregVernon"
                  },
                  "bodyText": "@makeclean - Do you have a screenshot that shows what you're seeing?  I believe it's a known issue atm that the Exodus export from MOOSE isn't supported for these IGA analyses.  Using the VTK output should allow you to specify the nonlinear subdivision level (see below).\nTo set the nonlinear subdivision level on a ParaView pipeline object:\n\nIn the Properties browser make sure the Advanced Properties are active\n\nScroll down to the Miscellaneous section where you'll see Nonlinear Subdivision Level\n\nI often find 4 to be sufficient and a good compromise with performance\n\nExample\nNonlinear subdivision level = 1 (default)\n\nNonlinear subdivision level = 4 (my recommendation)\n\nRendering higher-order elements with edges\nThere is an outstanding bug regarding rendering higher-order elements as Surface with Edges (see discussion here and here).  The workaround is to essentially create a duplicate of your data and render one as a Surface and the other as a Wireframe.  Creating the duplicate can either be done with some \"zero-op\" filters or by loading your data twice.\n\n\nSurface with Edges bug\n\n\n\nSurface with Edges workaround",
                  "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3207216",
                  "updatedAt": "2022-07-22T15:21:33Z",
                  "publishedAt": "2022-07-22T15:21:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "That's massively helpful thanks @GregVernon the only thing I would add to that documentation @msederberg is regarding the configuration of libmesh needing the vtk part, so making sure to build VTK with MPI support and the MPI group support being TRUE, then building libmesh using those libraries, otherwise - very smooth :)",
                          "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3214108",
                          "updatedAt": "2022-07-23T23:04:10Z",
                          "publishedAt": "2022-07-23T23:04:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unable to run split preconditioning",
          "author": {
            "login": "amosaha"
          },
          "bodyText": "When using the example provided by the official website of the split module, the problem in the figure appears. How should I solve it?",
          "url": "https://github.com/idaholab/moose/discussions/21670",
          "updatedAt": "2022-08-13T16:14:56Z",
          "publishedAt": "2022-07-23T00:30:21Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe [Splits] syntax isnt supported syntax outside of phase_field I think, but field splits are still definitely possible.\nRename this block as Preconditioning.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21670#discussioncomment-3212452",
                  "updatedAt": "2022-07-23T13:47:12Z",
                  "publishedAt": "2022-07-23T13:35:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Define the coordinates of the elements for a 2 element mesh in the input file",
          "author": {
            "login": "ambehnam"
          },
          "bodyText": "Hi there. I want to validate an interface kernel by creating a 2 element mesh with arbitrary coordinates. currently I am generating the mesh using the following input commands:\n[Mesh]\n  [./gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 2\n    xmax = 2\n    ny = 1\n    ymax = 1\n    nz = 1\n    zmax = 1\n    elem_type = HEX8\n  [../]\n  [./left]\n    type = SubdomainBoundingBoxGenerator\n    input = 'gen'\n    block_id = 1\n    bottom_left = '0 0 0'\n    top_right = '1 1 1'\n  [../]\n  [./right]\n    type = SubdomainBoundingBoxGenerator\n    input = 'left'\n    block_id = 2\n    bottom_left = '1 0 0'\n    top_right = '2 1 1'\n  [../]\n  [./breakmesh]\n    type = BreakMeshByBlockGenerator\n    input = right\n  []\n[]\n\nbut, I want to change the coordinate of the middle node slightly to activate the off diagonal parameters of a penalty tensor. So is there anyway to define the coordinates of these two elements in the input file?\nThanks,\nAmir",
          "url": "https://github.com/idaholab/moose/discussions/21671",
          "updatedAt": "2022-07-23T19:03:13Z",
          "publishedAt": "2022-07-23T04:16:57Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Some random remarks....   Do you have to use MOOSE to create your mesh?  If yes, and you're doing some sort of parametric study where the node position varies between multiple MOOSE simulations, then i think i'd write my own mesh generator.  Otherwise, then external meshers allow this sort of freedom, so i think i'd use one of those.",
                  "url": "https://github.com/idaholab/moose/discussions/21671#discussioncomment-3211447",
                  "updatedAt": "2022-07-23T08:35:04Z",
                  "publishedAt": "2022-07-23T08:35:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI see a few options within MOOSE mesh generation have a \"slightly off\" middle node.\n\nadd MoveNodeGenerator after those 3 https://mooseframework.inl.gov/moose/source/meshgenerators/MoveNodeGenerator.html\nOR\nuse a CartesianMG instead of GeneratedMG then use different lengths for two cells\nhttps://mooseframework.inl.gov/moose/source/meshgenerators/CartesianMeshGenerator.html\n\nGuilllaume",
                  "url": "https://github.com/idaholab/moose/discussions/21671#discussioncomment-3212428",
                  "updatedAt": "2022-07-23T13:29:41Z",
                  "publishedAt": "2022-07-23T13:29:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "prepareVectorTag and accumulateTaggedLocalResidual",
          "author": {
            "login": "dingqiushi"
          },
          "bodyText": "My MultiKernel.cpp inherited from the existing Kernel.cpp in moose, and I wanted to add multi-physics calculations, so I overloaded the computeResidual() function with an extra layer of p-loops, but this will cause some problems when opening the displacement (even if the displacement field was 0).\nvoid Kernel::computeResidual()\n{\nprepareVectorTag(_assembly, _var.number());\nprecalculateResidual();\nfor (_i = 0; _i < _test.size(); _i++)\n  for (_qp = 0; _qp < _qrule->n_points(); _qp++)\n    _local_re(_i) += _JxW[_qp] * _coord[_qp] * computeQpResidual();\naccumulateTaggedLocalResidual();\nif (_has_save_in)\n{\n   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n   for (const auto & var : _save_in)\n     var->sys().solution().add_vector(_local_re, var->dofIndices());\n}\n}\n\nvoid MultiKernel::computeResidual()\n{\n\tfor (unsigned int p = 0; p < _n_equation; ++p)\n\t{\n\t\tprepareVectorTag(_assembly, p);\n\t\tfor (_qp = 0; _qp < _qrule->n_points(); _qp++)\n\t\t{\n\t\t\tprecalculateResidual();\n\t\t\tfor (_i = 0; _i < _test.size(); _i++)\n\t\t\t\t_local_re(_i)+=_JxW[_qp] * _coord[_qp] * computeQpResidual(p);\n\t\t\t\n\n\t\t}\n\t\taccumulateTaggedLocalResidual();\n\t}\n}\n\nI tried to change the way I wrote it so that I could ensure that the calculations for 0 displacement field and no displacement field were exactly the same, but obviously neither was the result I wanted.\nvoid MultiKernel::computeResidual()\n{\n\tfor (unsigned int p = 0; p < _n_equation; ++p)\n\t{\n\t\tprepareVectorTag(_assembly, _var.number());\n\t\tfor (_qp = 0; _qp < _qrule->n_points(); _qp++)\n\t\t{\n\t\t\tprecalculateResidual();\n\t\t\tfor (_i = 0; _i < _test.size(); _i++)\n\t\t\t\t_local_re(_i)+=_JxW[_qp] * _coord[_qp] * computeQpResidual(p);\n\t\t\t\n\n\t\t}\n\t\taccumulateTaggedLocalResidual();\n\t}\n}\n\nI would like to know the exact meaning and use of the functions prepareVectorTag() and accumulateTaggedLocalResidual(), and my intuition is that there is a problem with placing these two functions in a p-loop. What is the problem with putting them in the p-loop I defined?\nvoid TaggingInterface::prepareVectorTag(Assembly & assembly, unsigned int ivar)\n{\n  _re_blocks.resize(_vector_tags.size());\n  mooseAssert(_vector_tags.size() >= 1, \"we need at least one active tag\");\n  auto vector_tag = _vector_tags.begin();\n  for (MooseIndex(_vector_tags) i = 0; i < _vector_tags.size(); i++, ++vector_tag)\n    _re_blocks[i] = &assembly.residualBlock(ivar, *vector_tag);\n  _local_re.resize(_re_blocks[0]->size());\n}\n\nvoid TaggingInterface::accumulateTaggedLocalResidual()\n{\n  for (auto & re : _re_blocks)\n    *re += _local_re;\n}",
          "url": "https://github.com/idaholab/moose/discussions/21386",
          "updatedAt": "2022-08-13T16:15:13Z",
          "publishedAt": "2022-06-23T03:21:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you are trying to get multiple kernels in a single kernel? For a single equation or for multiple terms in a single equation?\nEither way this is at a lower level than we'd advise users to work at. If you could please work with regular kernels first it ll be easier to support you.\nIf not you may use the MOOSE doxygen to get more information about all these routines\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classTaggingInterface.html#a7db1f9ea23c3f5fb0473118984dc4c0f\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21386#discussioncomment-3201968",
                  "updatedAt": "2022-07-21T23:43:19Z",
                  "publishedAt": "2022-07-21T23:43:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "I thought you decided to use ArrayKernel.",
                  "url": "https://github.com/idaholab/moose/discussions/21386#discussioncomment-3210018",
                  "updatedAt": "2022-07-22T22:53:46Z",
                  "publishedAt": "2022-07-22T22:53:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "TET4 element with one quadrature point",
          "author": {
            "login": "rcontinuum"
          },
          "bodyText": "Hello,\nmy aim is to use TET4 elements with one quadrature point. But with the following input fragment moose selects me a quadrature rule with four five quadrature points.\nWhat should I change so that a quadrature rule with only one quadrature point gets selected?\nI read a mesh file with one TET4 element, generated by gmsh, as\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  large_kinematics = false\n[]\n\n[Mesh]\n  [msh]\n    type = FileMeshGenerator\n    file = '1tet4.msh'\n    show_info = true\n  []\n[]\n\n[Variables]\n  [disp_x]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [disp_y]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [disp_z]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\nMesh check\nFileMeshGenerator 'msh':  Mesh Subdomains:\nFileMeshGenerator 'msh':   Subdomain 1 (Tetrahedron): 1 elems (TET4, 1 active), 4 active nodes\nFileMeshGenerator 'msh':    Volume: 0.166667\nFileMeshGenerator 'msh':    Bounding box minimum: (x,y,z)=(       0,        0,        0)\nFileMeshGenerator 'msh':    Bounding box maximum: (x,y,z)=(       1,        1,        1)\nFileMeshGenerator 'msh':    Bounding box delta: (x,y,z)=(       1,        1,        1)\nFileMeshGenerator 'msh':   Global mesh volume = 0.166667\n\nBut in my src/materials \"subroutine\" for calculating stresses and tangent operator the variable _qp runs from 0 to 4 3 .\nThus, it's a 4  5-point TET4 quadrature scheme. That works, but I was hoping to be able to select the one point quadrature rule.\nLike in libmesh the case FIRST: in line 53 ff. of the file\nhttps://mooseframework.inl.gov/docs/doxygen/libmesh/quadrature__gauss__3D_8C_source.html#l00029\n//---------------------------------------------\n      // Tetrahedral quadrature rules\n    case TET4:\n    case TET10:\n    case TET14:\n      {\n        switch(get_order())\n          {\n            // Taken from pg. 222 of \"The finite element method,\" vol. 1\n            // ed. 5 by Zienkiewicz & Taylor\n          case CONSTANT:\n          case FIRST:\n            {\n              // Exact for linears\n              _points.resize(1);\n              _weights.resize(1);\n \n \n              _points[0](0) = .25;\n              _points[0](1) = .25;\n              _points[0](2) = .25;\n \n              _weights[0] = Real(1)/6;\n \n              return;\n            }\n\nIf I use [Variables] ... order = CONSTANT I get an error message \"Unsupported order: 0\"\nAny hints?\nEdit: four -> five",
          "url": "https://github.com/idaholab/moose/discussions/21662",
          "updatedAt": "2022-07-22T16:43:55Z",
          "publishedAt": "2022-07-22T14:10:15Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou may use a constant monomial for that if you want to have this smaller quadrature all over the domain\n[Variables]\n  [u]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n[]\n\nnote that the kernels and boundary conditions are often different for these discontinuous FEM families.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21662#discussioncomment-3206694",
                  "updatedAt": "2022-07-22T14:12:51Z",
                  "publishedAt": "2022-07-22T14:12:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rcontinuum"
                          },
                          "bodyText": "Well, if I do this, then I get the runtime error (as you suspected)\n*** ERROR ***\nTrying to use nodal boundary condition 'fix_x' on a non-nodal variable 'disp_x'.\nBecause I want to apply boundary conditions at nodes (typical for Tensor Mechanics) like\n[BCs]\n  [fix_x]\n    type = DirichletBC\n    preset = true\n    boundary = 'Point_1 Point_3 Point_4'\n    variable = disp_x\n    value = 0.0\n  []\n  ...\n\nI mean, the numerical integration of the stiffness matrix of a TET4 element with one quadrature point rule is exact. As the gradients of the shape functions are constants. Sure, for a mass matrix that is not true. But even for the mass matrix it works from a practical point of view.\nDo you know any other possibility to select the quadrature rule \"manually\" for C0 elements like the TET4 element?\nEdit: Btw, _qp runs from 0 to 4. So it's actually a 5-point quadrature rule.",
                          "url": "https://github.com/idaholab/moose/discussions/21662#discussioncomment-3206805",
                          "updatedAt": "2022-07-22T14:29:40Z",
                          "publishedAt": "2022-07-22T14:27:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "are you trying to have a reduced quadrature only on the boundary?",
                          "url": "https://github.com/idaholab/moose/discussions/21662#discussioncomment-3206818",
                          "updatedAt": "2022-07-22T14:29:00Z",
                          "publishedAt": "2022-07-22T14:28:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rcontinuum"
                          },
                          "bodyText": "No, I don't have boundary integrals.\nSure, if I would have, e.g., NeumannBCs then one quadrature point for the triangular surface of the element would not be enough.\nI only apply DirichletBCs at the nodes (for debugging reasons). Thus I don't have integrals over the boundary of the domain.\nFor the usual Tensor Mechanics kernel, I use TotalLagrangianStressDivergence but doesn't really matter, we have only one volume integral to compute the stiffness matrix. And that volume integral is computed exact with a one-point quadrature rule for the TET4 element.",
                          "url": "https://github.com/idaholab/moose/discussions/21662#discussioncomment-3206964",
                          "updatedAt": "2022-07-22T14:47:16Z",
                          "publishedAt": "2022-07-22T14:47:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Do this:\n[Executioner]\n  [Quadrature]\n    order = CONSTANT\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/21662#discussioncomment-3206987",
                  "updatedAt": "2022-07-22T14:49:58Z",
                  "publishedAt": "2022-07-22T14:49:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Ref: https://mooseframework.inl.gov/moose/source/actions/SetupQuadratureAction.html",
                          "url": "https://github.com/idaholab/moose/discussions/21662#discussioncomment-3206998",
                          "updatedAt": "2022-07-22T14:51:25Z",
                          "publishedAt": "2022-07-22T14:51:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rcontinuum"
                          },
                          "bodyText": "Thank you!\nThat works!",
                          "url": "https://github.com/idaholab/moose/discussions/21662#discussioncomment-3207728",
                          "updatedAt": "2022-07-22T16:32:50Z",
                          "publishedAt": "2022-07-22T16:32:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Action of residuals in chemical potential kernels for KKS",
          "author": {
            "login": "aclin4"
          },
          "bodyText": "I'm trying to understand how exactly the non-linear variables are updated in kernels such as KKSPhaseChemicalPotential or SLKKSChemicalPotential. From my basic understanding, non-linear variables are updated using the residual R calculated in each kernel following:\nc(new) = c(old) + R\nHowever in the case of the chemical potential equality kernels, the non-linear variable only appears in the residual in the form of a partial derivative:\nR = df/dc - df'/dc'\nwhere c is the non-linear variable. In the kernels where the non-linear variable does not directly appear in the residual, how exactly is the calculated value of the residual used to update the non-linear variable?\nThanks!\nAlbert",
          "url": "https://github.com/idaholab/moose/discussions/21666",
          "updatedAt": "2022-07-22T16:41:20Z",
          "publishedAt": "2022-07-22T15:47:59Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nc(new) = c(old) + R dt\n\nthis is only very roughly (and actually not really) true for first order Euler time integrating.\nThe variables are updated as the result of the nonlinear solve. We can handle many time integration schemes, we can handle nonlinear variables that dont appear in the equations directly (like hidden in material properties for example), etc.\nIn the end, the solution returned when convergence is reached is the solution vector such that the residual is minimized.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21666#discussioncomment-3207514",
                  "updatedAt": "2022-07-22T16:55:28Z",
                  "publishedAt": "2022-07-22T16:00:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aclin4"
                          },
                          "bodyText": "I see. That makes more sense now, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/21666#discussioncomment-3207768",
                          "updatedAt": "2022-07-22T16:41:17Z",
                          "publishedAt": "2022-07-22T16:41:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "CoupledValueFunctionIC coupling more variables?",
          "author": {
            "login": "xueyang94"
          },
          "bodyText": "Hello,\nIn a phase-field KKS model, to define the IC of the global concentration variable as sum(c_i*eta_i) where i is phase and c_i is the phase concentration, we can use CoupledValueFunctionIC. This IC can couple variables up to four (x,y,z,t). However, I have a KKS model with more than four phase, so I need to couple more than four etas. Is there any existing method that does similar things as CoupledValueFunctionIC but can couple more variables? Thanks. @dschwen",
          "url": "https://github.com/idaholab/moose/discussions/21657",
          "updatedAt": "2022-08-13T16:15:57Z",
          "publishedAt": "2022-07-21T15:44:14Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont know about more than four variables in this IC since I didnt know about this IC.\nWhat you could (maybe) do is leverage block restriction if you can make sure that over each subdomain you only need four phases. Then you may use multiple of these CoupledValueFunctionICs with different block restrictions.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21657#discussioncomment-3200464",
                  "updatedAt": "2022-07-21T18:39:22Z",
                  "publishedAt": "2022-07-21T18:39:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "In general, how does the diffused interface work between two subdomains?",
                          "url": "https://github.com/idaholab/moose/discussions/21657#discussioncomment-3200904",
                          "updatedAt": "2022-07-21T19:44:55Z",
                          "publishedAt": "2022-07-21T19:44:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "as long as you dont block-restrict variables or kernels, only the IC, then the subdomain will have absolutely no impact on the simulation.\nIn other terms,\nIf all objects are block-restricted to two domains, then it is just as if these two blocks were the same",
                          "url": "https://github.com/idaholab/moose/discussions/21657#discussioncomment-3201101",
                          "updatedAt": "2022-07-21T20:19:41Z",
                          "publishedAt": "2022-07-21T20:19:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "The variable I want to use this IC for is interpolated within the whole domain, I don't know how using a subdomain will work...",
                          "url": "https://github.com/idaholab/moose/discussions/21657#discussioncomment-3206830",
                          "updatedAt": "2022-07-22T14:31:30Z",
                          "publishedAt": "2022-07-22T14:31:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "as long as you dont block-restrict variables or kernels, only the IC, then the subdomain will have absolutely no impact on the simulation.\nIn other terms, If all objects are block-restricted to two domains, then it is just as if these two blocks were the same\n\nIf a variable exists within the whole domain, and the domain has a few sub-blocks, how is the interfacial value between the two sub-blocks defined in that case?",
                          "url": "https://github.com/idaholab/moose/discussions/21657#discussioncomment-3206848",
                          "updatedAt": "2022-07-22T14:34:49Z",
                          "publishedAt": "2022-07-22T14:34:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m thinking subdomains are just for setting the IC subdomain by subdomain\nYou mean the value on a node shared between two subdomains?\nNot sure. it's probably defined by the order in which the ICs are run but I would need to check",
                          "url": "https://github.com/idaholab/moose/discussions/21657#discussioncomment-3207207",
                          "updatedAt": "2022-07-22T15:20:40Z",
                          "publishedAt": "2022-07-22T15:20:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "@xueyang94, unfortunately there is no such IC yet. I do have a system that could be used to generate a very high dimensional approximation if you have the data. Another option would be to perform a solve in the IC. We've recently been discussing to use a GEM solver for that.",
                  "url": "https://github.com/idaholab/moose/discussions/21657#discussioncomment-3201125",
                  "updatedAt": "2022-07-21T20:23:22Z",
                  "publishedAt": "2022-07-21T20:23:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "Currently I can define the IC for eta using BoundingBoxIC, and define the IC for global concentration using NestedBoundingBoxIC. I think that being able to set global concentration IC directly from eta is more accurate. What data do we need for the system you mentioned?",
                          "url": "https://github.com/idaholab/moose/discussions/21657#discussioncomment-3207175",
                          "updatedAt": "2022-07-22T15:16:26Z",
                          "publishedAt": "2022-07-22T15:16:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}