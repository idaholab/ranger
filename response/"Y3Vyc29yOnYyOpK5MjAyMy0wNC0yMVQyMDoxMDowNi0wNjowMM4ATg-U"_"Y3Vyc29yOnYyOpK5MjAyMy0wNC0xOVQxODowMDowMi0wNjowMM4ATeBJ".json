{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNC0xOVQxODowMDowMi0wNjowMM4ATeBJ"
    },
    "edges": [
      {
        "node": {
          "title": "Post processing variable values",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "Hi\nI am doing phase field modelling with eta (variable) as the order parameter. eta=1 for phase1 and eta = 0 for phase 2 and 0<eta<1 for the diffused interface between the two phases. I want to track the interface at the end of simulation with a condition as:\nFor 0.4<eta<0.6 I want all the x, y coordinates. I have no experience with handling exodus file system. So can I generate this data using the moose postprocessor.\nThe post processed file should look like:\nx     y      eta\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/24150",
          "updatedAt": "2023-04-24T10:55:28Z",
          "publishedAt": "2023-04-21T13:14:05Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs this just for output? You can use thresholds in paraview to limit the elements shown to those meeting a certain value.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24150#discussioncomment-5687155",
                  "updatedAt": "2023-04-21T14:34:55Z",
                  "publishedAt": "2023-04-21T14:34:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "This object will output all the values in each element.\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/ElementValueSampler.html\nWhat you COULD do to get just eta between two values is use this user object (below) to modify the subdomains\nhttps://mooseframework.inl.gov/source/userobjects/CoupledVarThresholdElementSubdomainModifier.html\nthen use the ElementVlaueSampler on the new subdomain using the block parameter\nBUT I reckon it's easier to just postprocessor the CSV for values of eta you care about",
                  "url": "https://github.com/idaholab/moose/discussions/24150#discussioncomment-5688138",
                  "updatedAt": "2023-04-21T16:06:33Z",
                  "publishedAt": "2023-04-21T16:06:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Capillary hysteresis",
          "author": {
            "login": "sinaomrani96"
          },
          "bodyText": "Hi,\nHope you are doing well.\nI came across some questions, and I appreciate if someone could help me with them. Sorry if they are naive :)\nI wnated to simulate an imbibtion-drainage (wetting-drying) by PorousFlow module. It supports hysteresis but the tests available are only one dimensional. So, I was wondering if this feature is supported in higher dimensions, and will it converge or not. My other question is that in the examples, hysteresis is only used with dirac kernels. Is this the only way to use hysteresis in PorousFlow?\nThanks,\nSina",
          "url": "https://github.com/idaholab/moose/discussions/23543",
          "updatedAt": "2023-04-21T14:28:16Z",
          "publishedAt": "2023-02-27T17:48:01Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@WilkAndy",
                  "url": "https://github.com/idaholab/moose/discussions/23543#discussioncomment-5126238",
                  "updatedAt": "2023-02-27T17:50:59Z",
                  "publishedAt": "2023-02-27T17:50:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Yes, hysteresis can be used in models with any dimensionality.   The only reason why the examples are all 1D is because, being part of the PorousFlow test suite, they need to run very quickly.\nRegarding convergence: it's quite likely that hysteresis won't impact convergence much, but whether that's true in your case depends upon your model.\nI suggest that you create your model without hysteresis, get everything running nicely, and then finally include hysteresis, using the procedures described here: https://mooseframework.inl.gov/modules/porous_flow/hysteresis.html\nA",
                  "url": "https://github.com/idaholab/moose/discussions/23543#discussioncomment-5128284",
                  "updatedAt": "2023-02-27T21:22:22Z",
                  "publishedAt": "2023-02-27T21:22:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Oh, and DiracKernels are unrelated to hysteresis: the examples you looked at all happen to have DiracKernels, but they do not impact hysteresis.",
                          "url": "https://github.com/idaholab/moose/discussions/23543#discussioncomment-5128427",
                          "updatedAt": "2023-02-27T21:24:50Z",
                          "publishedAt": "2023-02-27T21:24:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Hi,\nHope you are doing well.\nThank you for your answer. I created the model without hysteresis based on a PorousFlow example as you suggested and it works but when I try to use PC with hysteresis I get segmentation fault error. I run the model in debugg mode and I got\n'Assertion `i < _size' failed\nAccess out of bounds in MooseArray (i: 2 size: 2)\nat /home/sinaomrani/projects/moose/framework/build/header_symlinks/MooseArray.h, line 276'\nI do not know why I face this error. Can you please give me your insight? Also here is the input file.\nhttps://github.com/sinaomrani96/PorousFlow-hysteresis/blob/main/test\nThanks\nBest regards,\nSina",
                          "url": "https://github.com/idaholab/moose/discussions/23543#discussioncomment-5167053",
                          "updatedAt": "2023-03-01T14:00:56Z",
                          "publishedAt": "2023-03-01T14:00:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I took a quick look and the interaction between the PorousFlowSink and the PorousFlowHysteresis seems to have issues.\nThe out-of-bounds access happens on the boundary, when computing the material property for the 3rd quadrature point when the container has only been sized for 2. I m not sure why it would not be sized well yet. @WilkAndy what are your thoughts",
                          "url": "https://github.com/idaholab/moose/discussions/23543#discussioncomment-5169429",
                          "updatedAt": "2023-03-01T17:41:44Z",
                          "publishedAt": "2023-03-01T17:41:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I feel this is likely to be a bug!   Apologies, and kind-of-thanks (only kind-of because this means more work for me!).  I'm currently not at work, and won't be there for a few days, so can't fix it right now.  I'm not super sure why the boundary of a 2D mesh would have 3 quadpoints, but maybe something is getting evaluated on the interior element.",
                          "url": "https://github.com/idaholab/moose/discussions/23543#discussioncomment-5176106",
                          "updatedAt": "2023-03-02T08:31:54Z",
                          "publishedAt": "2023-03-02T08:31:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Dear @WilkAndy,\nHope you are doing well.\nI was wondering if you fixed this bug or you have not find the time yet.\nThanks.\nBest regards,\nSina",
                          "url": "https://github.com/idaholab/moose/discussions/23543#discussioncomment-5292530",
                          "updatedAt": "2023-03-13T14:45:41Z",
                          "publishedAt": "2023-03-13T14:45:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Sina, i'm sorry but i haven't fixed it yet.   I've been largely decoupled from MOOSE for the last month, and will not have time to work on it till after Easter.",
                          "url": "https://github.com/idaholab/moose/discussions/23543#discussioncomment-5447986",
                          "updatedAt": "2023-03-28T04:12:30Z",
                          "publishedAt": "2023-03-28T04:12:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "This has been fixed in #24104 , @sinaomrani96 .   Thank you for finding this bug, and I'm sorry it has impacted your work, and that i took so long to fix it.",
                          "url": "https://github.com/idaholab/moose/discussions/23543#discussioncomment-5682425",
                          "updatedAt": "2023-04-21T06:47:57Z",
                          "publishedAt": "2023-04-21T06:47:56Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sinaomrani96"
                  },
                  "bodyText": "Dear @WilkAndy,\nHope you are doing well.\nGreat. I just checked it, and it works fine. I appreciate your time. Thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/23543#discussioncomment-5687086",
                  "updatedAt": "2023-04-21T14:28:06Z",
                  "publishedAt": "2023-04-21T14:28:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ChromiumOxidation and ChromiumThermal is not a registered object",
          "author": {
            "login": "haqfariha"
          },
          "bodyText": "I am a new user and trying to work with oxidation problem for my project. I am trying built-in test input file of moose but I can not run it because of error messeges pop up - these kernels are not registered. How can I resolve this? The problem I am trying-\nhttps://mooseframework.inl.gov/bison/source/materials/ChromiumOxidation.html#chromiumoxidation\nThanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/24149",
          "updatedAt": "2023-05-31T19:06:39Z",
          "publishedAt": "2023-04-21T01:42:49Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is actually from the BISON website, and these are BISON objects.\nBISON is an export controlled application application, you may request access here:\nhttps://ncrcaims.inl.gov/Identity/Account/Register\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24149#discussioncomment-5681046",
                  "updatedAt": "2023-04-21T03:25:29Z",
                  "publishedAt": "2023-04-21T03:25:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to link external libraries to a MOOSE application",
          "author": {
            "login": "KamalnathOSU"
          },
          "bodyText": "Dear MOOSE team,\nI am developing a MOOSE-based app using heat conduction module and tensor mechanics module. From the app, I can get temperature as a function of time for each element. I have an external C library (*.so files along with some header files *.h) that can calculate some material properties (eg: grain size) as a function of thermal history.\nI want to create  auxiliary variables that store these properties. So, in my auxkernel, I want to call some functions from the external C library and assign the auxiliary variables.\nI want to know where to modify the Makefile in my app to link these external libraries. Can I any one of you help ?\nThank you very much!\nKamal",
          "url": "https://github.com/idaholab/moose/discussions/24129",
          "updatedAt": "2023-04-21T20:52:38Z",
          "publishedAt": "2023-04-19T21:05:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think your best bet if you have the .C and .h files is to just compile them in MOOSE.\nJust add them in the auxkernel folder or a new folder (in both src and include). If they compile standalone that's great. If not then you'll need to make sure they do\nthen just call this code from a custom auxkernel\nNote: If you want to use AD they should NOT be filling an auxvariable, but a material property instead. And there will be a bit of work to populate the derivatives there\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24129#discussioncomment-5667402",
                  "updatedAt": "2023-04-19T23:33:17Z",
                  "publishedAt": "2023-04-19T23:33:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "@GiudGiud I dont have the *.C file as it is a commercial code. They only provide *.so file that should be dynamically linked to the target executable.\nThank you for tip. I was trying to create auxvariable first. And latter when needed, I would shift to material property.",
                          "url": "https://github.com/idaholab/moose/discussions/24129#discussioncomment-5667478",
                          "updatedAt": "2023-04-19T23:49:40Z",
                          "publishedAt": "2023-04-19T23:49:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "beyond my skills then\n@permcody",
                          "url": "https://github.com/idaholab/moose/discussions/24129#discussioncomment-5667520",
                          "updatedAt": "2023-04-19T23:57:16Z",
                          "publishedAt": "2023-04-19T23:57:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "If you only need to link these libraries to the final executable you can define the libraries to link in a the variable $ADDITIONAL_DEPEND_LIBS. We do have a few other flags if you need to link them into the libraries themselves. Depending on how you refer to these symbols in the code will depend on where the linkage is required. Let\u2019s start with the above named variable. If that doesn\u2019t work as expected, I\u2019ll point you to some additional variables to try.\nYou can take a peek at framework/app.mk to see the exact link lines for libraries and executables.",
                          "url": "https://github.com/idaholab/moose/discussions/24129#discussioncomment-5667659",
                          "updatedAt": "2023-04-20T00:16:48Z",
                          "publishedAt": "2023-04-20T00:16:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "@permcody Thank you very much.\nFor example, if I have to two libraries libgrainsize.so libconductivity.so located at \"$HOME/external_code/lib\" that should be linked to the final executable, then can I define\nADDITIONAL_DEPEND_LIBS=-L$(HOME)/external_code/lib -llibgrainsize -llibconductivity\nat the Makefile of my app ?",
                          "url": "https://github.com/idaholab/moose/discussions/24129#discussioncomment-5667756",
                          "updatedAt": "2023-04-20T00:38:16Z",
                          "publishedAt": "2023-04-20T00:38:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Precisely!",
                          "url": "https://github.com/idaholab/moose/discussions/24129#discussioncomment-5667806",
                          "updatedAt": "2023-04-20T00:47:22Z",
                          "publishedAt": "2023-04-20T00:47:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "Hi @permcody !\nI read through app.mk file. There were multiples occurrences (3 times) of ADDITIONAL_DEPEND_LIBS. But the variable \"ADDITIONAL_LIBS\" occurred only once, at the creation of executable.\nSo, if I want to link it only with the final executable,  should I be using \"ADDITIONAL_LIBS\" variable ?",
                          "url": "https://github.com/idaholab/moose/discussions/24129#discussioncomment-5676274",
                          "updatedAt": "2023-04-20T17:01:35Z",
                          "publishedAt": "2023-04-20T17:01:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "\u276f git grep \"ADDITIONAL_DEP\"\nframework/app.mk:$(app_LIB): $(app_HEADER) $(app_plugin_deps) $(depend_libs) $(app_objects) $(ADDITIONAL_DEPEND_LIBS)\nframework/app.mk:$(app_test_LIB): $(app_HEADER) $(app_plugin_deps) $(depend_libs) $(app_test_objects) $(ADDITIONAL_DEPEND_LIBS)\nframework/app.mk:$(app_EXEC): $(app_LIBS) $(mesh_library) $(main_object) $(app_test_LIB) $(depend_test_libs) $(ADDITIONAL_DEPEND_LIBS)\nIf I am reading the above correctly, you were correct when asking about exporting ADDITIONAL_DEPEND_LIBS.\nedit: you'll want to encapsulate your export however (due to spaces):\nADDITIONAL_DEPEND_LIBS=\"-L$(HOME)/external_code/lib -llibgrainsize -llibconductivity\"",
                          "url": "https://github.com/idaholab/moose/discussions/24129#discussioncomment-5676655",
                          "updatedAt": "2023-04-20T17:47:18Z",
                          "publishedAt": "2023-04-20T17:46:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "Hi Jason ! @milljm\nThanks for the tip on encapsulation. For my case, ADDITIONAL_DEPEND_LIBS didn't work but ADDITIONAL_LIBS does the trick.\nADDITIONAL_LIBS=\"-L$(HOME)/external_code/lib -lgrainsize -lconductivity\"\n\nI modified the Makefile of my app to add the above line (as shown below) and then I could compile my app.\n# dep apps\nAPPLICATION_DIR    := $(CURDIR)\nAPPLICATION_NAME   := panda\nBUILD_EXEC                := yes\nGEN_REVISION           := no\nADDITIONAL_LIBS      :=\"-L$(HOME)/external_code/lib -lgrainsize -lconductivity\"\ninclude            $(FRAMEWORK_DIR)/app.mk",
                          "url": "https://github.com/idaholab/moose/discussions/24129#discussioncomment-5677025",
                          "updatedAt": "2023-04-20T18:31:15Z",
                          "publishedAt": "2023-04-20T18:29:12Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Applying different kernels on different sides of a moving interface",
          "author": {
            "login": "WayneX-Wong"
          },
          "bodyText": "Hi all,\nI'm trying to simulate kind of phase transition problem where interface moves based on calculated variable value, while governing PDEs of the subdomains on the two sides are different.\nI found XFEM Module quite suitable for this kind of simulation about moving interface, but I wonder whether it support different kernels on different Cut-subdomains. I didn't find any similar tests or examples yet.\nOr is there any alternative methods?\nThank you very much!",
          "url": "https://github.com/idaholab/moose/discussions/24133",
          "updatedAt": "2023-04-21T00:48:26Z",
          "publishedAt": "2023-04-20T04:52:10Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "For XFEM, currently we cannot restrict kernels to be calculated only on a specific subdomain.  One possible solution is to let kernels/physics to be solved on the whole domain, and then we just discard/ignore the solution that is relevant to that subdomain. I have not tried this myself yet, and you might encounter some issues.\nAlternatively, we would suggest you consider Phase Field approach for phase transition problem. It can eliminate a lot of troubles associated with moving the interface.",
                  "url": "https://github.com/idaholab/moose/discussions/24133#discussioncomment-5674760",
                  "updatedAt": "2023-04-20T14:46:15Z",
                  "publishedAt": "2023-04-20T14:46:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Did we ever merge the XFEM-based subdomain modifier?",
                          "url": "https://github.com/idaholab/moose/discussions/24133#discussioncomment-5675221",
                          "updatedAt": "2023-04-20T15:23:11Z",
                          "publishedAt": "2023-04-20T15:23:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Did we ever merge the XFEM-based subdomain modifier?\n\nThat is a good point. Maybe Yes. If so, we might be able to do it to some extend. It is not fully tested, and I am afraid there might be many issues here and there.",
                          "url": "https://github.com/idaholab/moose/discussions/24133#discussioncomment-5675324",
                          "updatedAt": "2023-04-20T15:31:22Z",
                          "publishedAt": "2023-04-20T15:31:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Why the Simulation.C in ThermalHydraulicModel can be the driver of the simulation?",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nI'd like to know why the Simulation.C can be the driver of the simulation in THM? How does it work? It really confused me. Could anyone kindly tell me?\nThank you!\nBest regards.",
          "url": "https://github.com/idaholab/moose/discussions/24120",
          "updatedAt": "2023-04-20T14:49:15Z",
          "publishedAt": "2023-04-19T13:20:58Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@joshuahansel any doc page on Simulation?",
                  "url": "https://github.com/idaholab/moose/discussions/24120#discussioncomment-5661599",
                  "updatedAt": "2023-04-19T13:55:56Z",
                  "publishedAt": "2023-04-19T13:55:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "No there isn't. It wasn't prioritized since it would be more of a developer documentation.",
                          "url": "https://github.com/idaholab/moose/discussions/24120#discussioncomment-5662025",
                          "updatedAt": "2023-04-19T14:34:05Z",
                          "publishedAt": "2023-04-19T14:34:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "I don't think it's really necessary for your question, but note that THMProblem inherits from FEProblem and Simulation:\nclass THMProblem : public FEProblem, public Simulation\n\nAs far as it being a \"driver\", I'd say just look at the actions/tasks that are executing and let those be your guide. Some of these actions go into the simulation class to do various things. For example, the components are stored in the Simulation class, and there is an action to add a component. I think if we wanted to, if we could put all of Simulation's data in a different place (like putting all of the components into MOOSE's existing warehouse), then we might be able to do away with Simulation and just have the \"action\" code directly in actions.\nLet me know if that answers your question.",
                  "url": "https://github.com/idaholab/moose/discussions/24120#discussioncomment-5662152",
                  "updatedAt": "2023-04-19T14:44:29Z",
                  "publishedAt": "2023-04-19T14:43:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thank you for your reply! So the simulation is just to store data, is that right? I just like to find out how the THM works if we give an input file and run this input file. It should run line by line according to a main function. If the simulation is not the main function, which file is the main function?",
                          "url": "https://github.com/idaholab/moose/discussions/24120#discussioncomment-5662280",
                          "updatedAt": "2023-04-19T14:54:16Z",
                          "publishedAt": "2023-04-19T14:54:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "For example, if we use the FlowChannel1Phase component, which function decides on building mesh first or initializing first? It should have an underlying logic.",
                          "url": "https://github.com/idaholab/moose/discussions/24120#discussioncomment-5662373",
                          "updatedAt": "2023-04-19T15:00:35Z",
                          "publishedAt": "2023-04-19T14:59:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "The main function is at modules/thermal_hydraulics/src/main.C, but it's a bit difficult to follow it all the way down.\n\nwhich function decides on building mesh first or initializing first?\n\nActions are used to do those two tasks. Task dependencies with each other are registered, and a dependency resolver takes that information and sorts all of the tasks/actions. There is a basic documentation for components: https://mooseframework.inl.gov/syntax/Components/index.html that tells you the order that the various component methods will be executed in, if that's all you're interested in.",
                          "url": "https://github.com/idaholab/moose/discussions/24120#discussioncomment-5664027",
                          "updatedAt": "2023-04-19T16:20:13Z",
                          "publishedAt": "2023-04-19T16:20:12Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "OK, thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/24120#discussioncomment-5664960",
                          "updatedAt": "2023-04-19T17:51:56Z",
                          "publishedAt": "2023-04-19T17:51:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Hi joshuahansel,\nCould you please tell me what is the difference between these two lines:\nsyntax.registerActionSyntax(\"AddComponentAction\", \"Components/*\", \"THM:add_component\");\nsyntax.registerActionSyntax(\"AddComponentAction\", \"Components/*/*\", \"THM:add_component\");.\nWhat's the meaning of this symbol: /* ?\nI also find some lines without this symbol, and it also doesn't have the task name, just like:\nsyntax.registerActionSyntax(\"THMCreateMeshAction\", \"Components\");\nThank you!",
                          "url": "https://github.com/idaholab/moose/discussions/24120#discussioncomment-5674132",
                          "updatedAt": "2023-04-20T13:50:30Z",
                          "publishedAt": "2023-04-20T13:50:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is for Regex. * means anything.\nso Components/* means anything within the components block\nComponents// means anything within any block inside the components block",
                          "url": "https://github.com/idaholab/moose/discussions/24120#discussioncomment-5674262",
                          "updatedAt": "2023-04-20T14:01:11Z",
                          "publishedAt": "2023-04-20T14:01:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "I got it, thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/24120#discussioncomment-5674790",
                          "updatedAt": "2023-04-20T14:49:15Z",
                          "publishedAt": "2023-04-20T14:49:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error while updating",
          "author": {
            "login": "sinaomrani96"
          },
          "bodyText": "Hi everyone.\nI wanted to update my moose repository and I am getting the following errors. I wanted to know if it is a general issue or only happened to me. Thanks.\n/home/sinaomrani/mambaforge3/envs/moose/libmesh/include/timpi/packing.h:279:22: error: 'pack' is not a member of 'libMesh::Parallel::Packing<MeshInfo::SubdomainInfo, void>'\n279 |     Packing::pack(comp, data_out, ctx);\n|     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/home/sinaomrani/mambaforge3/envs/moose/libmesh/include/timpi/packing.h:332:31: error: 'unpack' is not a member of 'libMesh::Parallel::Packing<MeshInfo::SubdomainInfo, void>'\n332 |     comp = Packing::unpack(in, ctx);\n|            ~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n/home/sinaomrani/mambaforge3/envs/moose/libmesh/include/timpi/packing.h:234:38: error: 'packable_size' is not a member of 'libMesh::Parallel::Packing<MeshInfo::SidesetInfo, void>'\n234 |     return Packing::packable_size(comp, ctx);\n|            ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\nand many more.\nBest regards,\nSina",
          "url": "https://github.com/idaholab/moose/discussions/24136",
          "updatedAt": "2023-04-20T13:57:50Z",
          "publishedAt": "2023-04-20T13:36:23Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou need to update libmesh at the same time as you update moose\nmamba update --all\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24136#discussioncomment-5674007",
                  "updatedAt": "2023-04-20T13:38:53Z",
                  "publishedAt": "2023-04-20T13:38:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "installation problems: wsl + python 3.8 / 3.9",
          "author": {
            "login": "cunyizju"
          },
          "bodyText": "When I install moose in windows 10 - wsl (python 3.9), the following messages are met:\n\n\n\nconda install moose-tools\n\n\n\nCollecting package metadata (current_repodata.json): done\nSolving environment: failed with initial frozen solve. Retrying with flexible solve.\nSolving environment: failed with repodata from current_repodata.json, will retry with next repodata source.\nCollecting package metadata (repodata.json): done\nSolving environment: failed with initial frozen solve. Retrying with flexible solve.\nSolving environment: \\\nFound conflicts! Looking for incompatible packages.\nThis can take several minutes.  Press CTRL-C to abort.\nfailed\n\nUnsatisfiableError: The following specifications were found to be incompatible with each other:\n\nOutput in format: Requested package -> Available versionsThe following specifications were found to be incompatible with your system:\n\n  - feature:/linux-64::__glibc==2.31=0\n  - feature:|@/linux-64::__glibc==2.31=0\n\nYour installed version is: 2.31\n\nconda install moose-libmesh (py3.9):\nCollecting package metadata (current_repodata.json): done\nSolving environment: failed with initial frozen solve. Retrying with flexible solve.\nSolving environment: failed with repodata from current_repodata.json, will retry with next repodata source.\nCollecting package metadata (repodata.json): done\nSolving environment: failed with initial frozen solve. Retrying with flexible solve.\nSolving environment: |\nFound conflicts! Looking for incompatible packages.\nThis can take several minutes.  Press CTRL-C to abort.\nfailed\n\nUnsatisfiableError: The following specifications were found to be incompatible with each other:\n\nOutput in format: Requested package -> Available versions\n\nPackage libgcc-ng conflicts for:\npython=3.9 -> zlib[version='>=1.2.11,<1.3.0a0'] -> libgcc-ng[version='>=7.2.0']\nmoose-libmesh -> moose-libmesh-vtk==6.3.0=build_7 -> libgcc-ng[version='>=7.2.0|>=9.3.0|>=7.3.0']\npython=3.9 -> libgcc-ng[version='>=7.3.0|>=7.5.0']The following specifications were found to be incompatible with your system:\n\n  - feature:/linux-64::__glibc==2.31=0\n  - feature:|@/linux-64::__glibc==2.31=0\n  - python=3.9 -> libgcc-ng[version='>=7.5.0'] -> __glibc[version='>=2.17']\n\nYour installed version is: 2.31\n\nSimilar problems occur for the python 3.8 environment.\nCould anyone please help me check how to fix the above installation problem?\nBest wishes,\nBruce",
          "url": "https://github.com/idaholab/moose/discussions/19029",
          "updatedAt": "2023-04-20T13:36:45Z",
          "publishedAt": "2021-10-07T01:33:30Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@milljm",
                  "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-1439785",
                  "updatedAt": "2022-06-15T19:35:36Z",
                  "publishedAt": "2021-10-07T01:59:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cunyizju"
                          },
                          "bodyText": "Let me answer this question on my own.\nconda create -n moose -q -y\nconda config --add channels idaholabCopy\nconda config --add channels conda-forge\n\nconda activate moose\nconda install moose-tools\nconda install moose-libmesh\n\nshould work.",
                          "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-1439915",
                          "updatedAt": "2022-06-15T19:35:42Z",
                          "publishedAt": "2021-10-07T02:38:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "The idaholab channel is being deprecated... It would seem I forgot to modify our FAQ section reflecting this change. While 'idaholab' still holds the necessary things, it won't forever. Also looks like the 'right-click select all' routine includes 'Copy' by mistake. The proper channel is our new public URL (https://conda.software.inl.gov/public):\nconda config --add channels https://conda.software.inl.gov/public\nconda config --remove channels idaholab # or idaholabCopy in your case\nThese commands are safe to use, as both channels contain identical packages.\nAs for your original error, I suspect a new environment would work (you're heading in the right direction).",
                          "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-1442463",
                          "updatedAt": "2022-06-15T19:35:44Z",
                          "publishedAt": "2021-10-07T13:42:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cunyizju"
                          },
                          "bodyText": "Thanks, Jason.\nI believe creating a clean environment is critical to avoid conflicts.\nconda create -n moose -q -y",
                          "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-1448922",
                          "updatedAt": "2022-06-15T19:36:17Z",
                          "publishedAt": "2021-10-08T15:21:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Can you post what you did in a new post (not a reply). I'd like to mark it as the answer, especially since you figured it out on your own. It will help others that come across this same error :)\nCheers!",
                          "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-1459358",
                          "updatedAt": "2022-06-15T19:36:36Z",
                          "publishedAt": "2021-10-11T14:03:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rlt97"
                          },
                          "bodyText": "Hi all,\nThanks for your insight  @milljm and @cunyizju !\nI am currently running into a similar issue regarding the installation of the moose packages\n\nC:\\Users\\lethai>conda activate moose\n\n\n(moose) C:\\Users\\lethai>conda install moose-tools\nCollecting package metadata (current_repodata.json): done\nSolving environment: failed with initial frozen solve. Retrying with flexible solve.\nCollecting package metadata (repodata.json): done\nSolving environment: failed with initial frozen solve. Retrying with flexible solve.\n\n\nPackagesNotFoundError: The following packages are not available from current channels:\n\n\n\nmoose-tools\n\n\n\nCurrent channels:\n\n\n\nhttps://conda.anaconda.org/idaholab/win-64\nhttps://conda.anaconda.org/idaholab/noarch\nhttps://conda.software.inl.gov/public/win-64\nhttps://conda.software.inl.gov/public/noarch\nhttps://conda.anaconda.org/conda-forge/win-64\nhttps://conda.anaconda.org/conda-forge/noarch\nhttps://repo.anaconda.com/pkgs/main/win-64\nhttps://repo.anaconda.com/pkgs/main/noarch\nhttps://repo.anaconda.com/pkgs/r/win-64\nhttps://repo.anaconda.com/pkgs/r/noarch\nhttps://repo.anaconda.com/pkgs/msys2/win-64\nhttps://repo.anaconda.com/pkgs/msys2/noarch\n\n\nIf you have any hints, it will be greatly appreciated.\nThanks in advance,\nRemi",
                          "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-1468143",
                          "updatedAt": "2022-06-15T19:36:35Z",
                          "publishedAt": "2021-10-13T03:10:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Unfortunately we do not have a Microsoft Windows channel at this time... You'll have to use Windows Subsystem for Linux (WSL) if you wish to make use of the MOOSE framework. Native Windows support is something we talk about on occasion, so perhaps someday!",
                          "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-1471166",
                          "updatedAt": "2022-06-15T19:36:43Z",
                          "publishedAt": "2021-10-13T14:03:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rlt97"
                          },
                          "bodyText": "Got it - thanks ! @milljm",
                          "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-1471972",
                          "updatedAt": "2022-06-15T19:36:50Z",
                          "publishedAt": "2021-10-13T16:10:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "LiHao1995"
                  },
                  "bodyText": "Hello everyone. When installing metawrap, even though I created the virtual environment metawrap, there were still conflicts.\nAs following:\n(metawrap) [localhost ~]$ conda install -c ursky metawrap-mg\nCollecting package metadata (current_repodata.json): done\nSolving environment: failed with initial frozen solve. Retrying with flexible solve.\nSolving environment: failed with repodata from current_repodata.json, will retry with next repodata source.\nCollecting package metadata (repodata.json): done\nSolving environment: failed with initial frozen solve. Retrying with flexible solve.\nSolving environment: \\\nFound conflicts! Looking for incompatible packages.                                                                                                                                                                                                                                    failed\nUnsatisfiableError: The following specifications were found to be incompatible with each other:\nOutput in format: Requested package -> Available versionsThe following specifications were found to be incompatible with your system:\n\nfeature:/linux-64::__glibc==2.18=0\npython=2.7 -> libgcc-ng[version='>=11.2.0'] -> __glibc[version='>=2.17']\n\nYour installed version is: 2.18\nHowever, I successfully reinstalled glibc 2.18 and upgraded libgcc-ng to the latest version, but the issue is still not resolved. Can anyone provide some better advice? Thank you very much.",
                  "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-5672371",
                  "updatedAt": "2023-04-20T11:11:07Z",
                  "publishedAt": "2023-04-20T11:11:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I think your best bet would be to ask the maintainers of Metawrap at the feed stock repo: https://github.com/conda-forge/metawrap-feedstock. However, it doesn't seem to be very active.\nFollowing all the links, I end up at https://github.com/jakirkham/metawrap for its homepage. And it looks like no one is home. I am not sure how much support you are going to find...\nYou may have better luck downloading the source from: https://github.com/jakirkham/metawrap and building it manually. Or attempting to modify the Feedstock recipe to grab the latest version from source and build the package yourself.\nSorry but I don't think we're going to be of much help beyond what I've suggested. Is this in some way related to MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-5673240",
                          "updatedAt": "2023-04-20T12:28:06Z",
                          "publishedAt": "2023-04-20T12:27:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "LiHao1995"
                  },
                  "bodyText": "Thanks for your valuable advice \uff01 I will try the next step. If it fails again, metarap will have to be replaced with other software, as it is not the only one available. [ 0_.._0 ]\n\n\n\n\n\n\n\n\n\nAt 2023-04-20 20:27:21, \"Jason Miller\" ***@***.***> wrote:\n\nI think your best bet would be to ask the maintainers for Metawrap at the feed stock repo: https://github.com/conda-forge/metawrap-feedstock. However, it doesn't seem to be very active.\n\nFollowing all the links, I end up at https://github.com/jakirkham/metawrap for its homepage. And it looks like no one is home. I am not sure how much support you are going to find...\n\nYou may have better luck downloading the source from: https://github.com/jakirkham/metawrap and building it manually. Or attempting to modify the Feedstock recipe to grab the latest version from source and build the package your self.\n\nSorry but I don't think we're going to be of much help beyond what I've suggested. Is this in some way related to MOOSE?\n\n\u2014\nReply to this email directly, view it on GitHub, or unsubscribe.\nYou are receiving this because you commented.Message ID: ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/19029#discussioncomment-5673984",
                  "updatedAt": "2023-04-20T13:36:45Z",
                  "publishedAt": "2023-04-20T13:36:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Supplying element-neighbor pairs for (periodic) interface calculations",
          "author": {
            "login": "ttruster"
          },
          "bodyText": "I am planning some implementations regarding periodic boundary conditions. Though there are several existing methods for them in MOOSE, I feel that adding the weak enforcement using surface integrals has some benefits not yet realized.\nTo start out, I studied the behavior of input files having BreakMeshByBlockGenerator. If the Exodus mesh is written out after calling this command, and then a new input file reads this mesh, then the computed result is different. As mentioned in the discussion here, #18240 (reply in thread), that is because a 'trick' is used in BreakMeshByBlockGenerator whereby the nodes are duplicated and the nodes-to-element connectivity is updated, but the element-neighbor information is not updated (i.e. is retained) internally. So it makes sense that if the modified mesh is written, though it contains a Side-Set, that set is one-sided and lacks the neighbor-element pairing required to recreate the internal state of the memory of the previous analysis.\nMy question is, is the only information I would be required to read in through a text file, the element-neighbor pairing (element ID and faces)? Or is there some other orientation information needed to update the Libmesh quadrature point projections? @arovinelli\nsuggested that only this information would be needed, and gave 4 lines of code for it. If this sounds like the approach, then I'll try hard-coding those lines within a new Mesh-Generator object, and see if that allows the read-in mesh to provide the same result as the original BreakMeshByBlockGenerator result.\nAlternatively, I saw a discussion here, #18580 (reply in thread), about Libmesh periodic features. Are those periodic listings node-based (like multi-point conditions) or face-based? From this discussion #20232, it sounds like they are face-based. I can't easily tell from the source code https://mooseframework.inl.gov/docs/doxygen/libmesh/periodic__boundaries_8C_source.html#l00038 what kind of periodic treatment Libmesh is doing (nodal, penalty, mortar, Nitsche); so suggested reading would help here as well.",
          "url": "https://github.com/idaholab/moose/discussions/22948",
          "updatedAt": "2023-04-20T03:14:01Z",
          "publishedAt": "2022-12-12T19:50:40Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Question at the bottom about inverse_map.\nSo I was able to verify that reassigning the element-neighbor pair through a Mesh-Generator class was able to restore the connection needed for the cohesive simulation.\nElem * current_elem = mesh->elem_ptr(elem_id);\nElem * neighbor_elem = mesh->elem_ptr(neighbor_id);\ncurrent_elem->set_neighbor(elem_side, neighbor_elem);\nneighbor_elem->set_neighbor(neighbor_side, current_elem);\nThus, maybe on day in the future, we could add a feature to BreakMeshByBlockGenerator to export a CSV list of this data while running, and having another mesh class that reads it back in.\nOn the second topic for periodic BC, I spent an hour looking through the code for how neighbor_data is initialized, and I finally found within the Assembly class the reinitElemAndNeighbor function and within it the Libmesh FEInterface::inverse_map call. That's what I expected to find, because somehow the neighbor quadrature point needs to know which element quadrature point to link up with. The face alone isn't enough; there needs to be some projection/lookup/reorientation that is checked.\nIs anyone familiar with the source code of inverse_map who can discuss how I would add the calculation of a translate/offset during the projection to handle periodic pairs that are parallel but translated (i.e. not adjacent like in usual meshes with Interface Kernels)? I can imagine doing this from the average coordinate of the corner nodes or of the quadrature point coordinates, such that it is internal and doesn't need any change to the argument list.",
                  "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4403244",
                  "updatedAt": "2022-12-14T19:14:58Z",
                  "publishedAt": "2022-12-14T19:14:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@roystgnr @lindsayad  on periodics BCs and FEInterface",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4404652",
                          "updatedAt": "2022-12-14T22:55:53Z",
                          "publishedAt": "2022-12-14T22:55:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "About the element-neighbor pairing: I noticed that BreakMeshByBlockGenerator can output two side sets (one for element and one for neighbor), and they are synced (i.e. the 5th element-face item is the one adjacent to the 5th neighbor-face item). Thus, instead of writing a CSV file and reading that, we could instead just write both sidesets to the .e file generated by --mesh-only. Then when this mesh is read back, a new MeshGenerator object could be run afterward with parameters pointing to the element and neighbor sidesets which then loops through them and sets the pairs into the mesh topology. First, we would need to make sure that the existing cohesive zone input files run fine if add_interface_on_two_sides parameter is true.\nWhen my current work gets done, I can open an issue to incorporate this change, which in short would allow meshes generated using BreakMeshByBlockGenerator to be written with --mesh-only and subsequently read back and updated for new analyses.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4415422",
                          "updatedAt": "2022-12-16T01:06:09Z",
                          "publishedAt": "2022-12-16T01:06:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I assume we can add interfaces on both sides but only run the czm material on one of them. I vaguely recall that's doable, but you want to double check before diving too deep, as we don't want to make the interface model twice expensive.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4415552",
                          "updatedAt": "2022-12-16T01:38:44Z",
                          "publishedAt": "2022-12-16T01:38:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "If there's no mesh refinement going on, and if the periodic variable is scalar-valued (not SCALAR meaning one component per mesh, but \"scalar\" meaning one component per point), things end up being very simple: all the DoFs on one side end up constrained to DoFs on the other side.  If the periodicity is a linear translation, each just has an x_i=x_j one-to-one constraint equation to one DoF on the other side.  If in addition the variable is LAGRANGE then it's just a matter of locating matching nodes; for other variable types we do matching at vertices but we solve little local projections via quadrature for edge and face DoFs.\nThe projections actually become important if there's any h refinement: in that case the fine element DoFs are always constrained to the coarse periodic neighbor rather than the other way around, and the solutions to the projection equations end up being much more interesting than identity matrices.  Even without adaptivity, if the periodicity involves a rotation and the variable type is more complicated than LAGRANGE, then at higher order the way we do DoF indexing can cause the constraint equations to be more of a permutation (albeit again unidirectional).\nAnyway, the inverse_map() calls come from the quadrature evaluations for those projection equations.  But the final enforcement isn't variational; the constrained space just doesn't contain any functions with a discontinuity across the boundary.  And we calculate the constraint equations once when the mesh changes; we don't do those lookups every time we have a residual and/or Jacobian to constrain, we just take the existing sparse constraint matrices and do K^T*r or K^T*J*K.\nSetting neighbor pointers manually is currently undefined behavior.  It might work, in the same sense as an OOB array access might work, but if it ever stops working and your code breaks then you don't get to tell the compiler/library to make it work again, you just get to keep the broken pieces.\nEdit:\n\nadd the calculation of a translate/offset during the projection to handle periodic pairs that are parallel but translated\n\nSorry that after all my rambling I haven't answered the real meat of your question, but I honestly don't understand it.  Periodic pairs that are parallel but translated aren't a weird special case, they're the common case.  The basic PeriodicBoundary class takes a translation vector in its constructor.  MOOSE has its auto_direction trick to auto-determine the translation vector for you, but you can also set a translation vector manually, or even an arbitrary transform_func and inv_transform_func.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4481121",
                          "updatedAt": "2022-12-23T02:15:44Z",
                          "publishedAt": "2022-12-23T02:07:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "Sorry it's taken me some time to get back to this point @roystgnr. The origin of the question is because we are implementing a variational version of enforcing the periodic conditions as opposed to the nodal-constraint (DOF-constrained equations with the K matrix that you mention). I was originally developing this for the MortarConstraint class similar to the tying constraint in https://mooseframework.inl.gov/source/constraints/EqualValueConstraint.html. However, to summarize my response below, that approach won't work easily for tensor-mechanics module because of stateful materials. So instead I'll be using InterfaceKernels, more like https://mooseframework.inl.gov/source/interfacekernels/PenaltyInterfaceDiffusion.html.\nThe physical reason for this: say you are modeling a polycrystalline material and you want to simulate grain boundary sliding or cracking or something, and now the crack runs along the periodic surface. So, that's easy to handle if the interface kernel is already handling the periodic condition; you just add a constitutive model to evolve the size of the discontinuity.\nMy question:\nYou mention that \"Setting neighbor pointers manually is currently undefined behavior\". However, the code compiles and runs fine for me with the four lines I mentioned above. Also, in the source code at https://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1Elem.html#a40980d9226643eb7dfd86b1c150c888e, the set_neighbor function seems to be defined. My assumption is, an element instance is initialized (i.e. when the mesh is first loaded) with an _elemlinks list that has as many entries as facets of the element. If their isn't a neighbor on a facet, then it's left as zero or something. Am I incorrect with that assumption, and the number of neighbors is fixed at the time the mesh is loaded? I notice calls to set_neighbor in ElementDeletionGeneratorBase of Moose that passes a null pointer, and several calls to it within the libmesh source.\nIf this is actually defined, then I'll be opening a discussion on the libmesh forum about including a changed I've made to identify non-adjacent boundary objects, which could be used for such InterfaceKernels mentioned above, and I'll link back to this discussion here.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4832656",
                          "updatedAt": "2023-01-31T17:56:53Z",
                          "publishedAt": "2023-01-31T17:56:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "At some point we need to make a firm design decision on whether we want to continue to evolve support for what I personally see as abuse of the element neighbor concept, or whether we want to think very seriously about how to support stateful material properties in mortar; see my response in another thread. I'm curious for @roystgnr's opinion on this, especially as he is currently working in the stateful material property projection code.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4844079",
                          "updatedAt": "2023-02-01T19:06:58Z",
                          "publishedAt": "2023-02-01T19:06:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "From working on interface methods for a while, my opinion is that there are three somewhat well-delineated categories:\n\nContinuous/conforming meshes and no interface; using multi-point constraints to tie blocks for separate parts or periodic conditions\nConforming or adaptively refined meshes with hanging nodes that have Penalty/Nitsche/Lagrange-multiplier enforcement of weak continuity along the interface. Here, the corner nodes on the coarse mesh are conforming everywhere, even on external boundaries.\nNonconforming interfaces, mesh tying, and contact/friction modeling as well as embedded mesh methods using Penalty/Nitsche/Mortar enforcement of the interface conditions.\n\nThese 3 categories increase in generality of problem class from top to bottom while also increasing in implementation/architecture complexity and projection errors. I've implemented all 3 categories before in my matlab FEM codes and in FEAP. Within MOOSE, I see these 3 mapping onto Kernels, InterfaceKernels, and MortarConstraints respectively. So, the middle category is a compromise in difficulty and generality. The difficulty is moderate since the quadrature point location on each side of the interface is identical once an offset vector (potentially zero) is introduced; I assume that idea works even for adaptively refined meshes and the InterfaceKernels for those. This means that no extra projection or copying of stateful materials from quadrature point locations on opposite sides is needed.\nSo, my suggested restriction is to say that non-adjacent element-neighbor concept would only be permitted for two parent element faces  that geometrically conform after a constant offset vector. This would allow usage of existing InterfaceKernel classes to solve problems with \"gaps\" between the two surfaces, for example finite-thickness cohesive zone (CZM) interfaces in solid mechanics. As an exaggeration of that, I made an example in Dropbox here  that uses one of the Tensor Mechanics CZM test files and adds a 1-unit offset between the interface. The computed behavior (initially linear, then debonding) is identical for the two input files except for the extra separation.\nI'm all for the improvement of the stateful materials for the Mortar method which will help a lot for contact problems and mesh tying, to be able to solve new problems. I just think that the middle category could be extended to its \"limit\" by allowing for the neighbors to be topologically defined (namely, conforming with an offset vector added) rather than solely adjacent.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4894902",
                          "updatedAt": "2023-02-07T15:30:38Z",
                          "publishedAt": "2023-02-07T15:30:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "As I reflect about my wording above, I probably am sounding \"mighty\" that I have experience on interfaces. Okay, fine, but I know my opinion isn't the only one or even the best one. I just advocate it because I'll keep needing to cherry-pick our adaptation in for reach future change in Libmesh/Moose so that our app developments keep working.\nI do want to remind us what got me started on the post, which is sort of the original \"abuse\" of element-neighbor concept that happens in BreakMeshByBlockGenerator. Most other InterfaceKernels act on a conforming mesh with two different variables on opposite sides of an interface that are coupled together; thus the element and neighbor share nodes/connectivity. The BreakMeshByBlockGenerator instead performs node duplications, revises the connectivity on the neighbor side, and keeps the element-neighbor pointers internally in the Moose job execution. Once that mesh is written to Exodus, that runtime connectivity is lost and can't be reloaded/restarted. Thus, the element-neighbor concept was \"abused\". However, it served the purpose for enabling cohesive zone modeling, with the same displacement variables on both sides of the interface yet with discontinuous interpolation. So that's why I feel this change would fall into that same umbrella. And, it would help to solve the lack of restart feature for cohesive modeling, as mentioned elsewhere in this discussion #22948 (reply in thread).",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4899368",
                          "updatedAt": "2023-02-08T00:26:00Z",
                          "publishedAt": "2023-02-08T00:25:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "What happens if the two sides of an \"interface\" live on two processors? I suppose the algebraic ghosting is not too difficult to handle with the relationship managers, but how about other data structures such as the element-neighbor pairs and their offsets? I guess my point is we should take distributed mesh into consideration if we are trying to make a design choice here. CZM is right now the sole limiting factor for scalability in our code.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4900061",
                          "updatedAt": "2023-02-08T02:16:19Z",
                          "publishedAt": "2023-02-08T02:16:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "I would say that the treatment of distributed meshes, neighbors across processors, should be the same either for adjacent or the separated pairs. The neighbor is just indicated by an element pointer, and the offset vector for projecting the quadrature point location is just computed from average coordinates. So, if current CZM or InterfaceKernels work for distributed meshes, then this approach should as well, as long as the neighbor pointer assignment can query across processors.\nWhen I was searching the Libmesh source before implementing my ideas in my repos, I had seen the topological_neighbor method for Elements, which makes reference to Periodic Boundary objects. https://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1Elem.html#ae81b9875caed609205c970d9cc0134a2. I couldn't find a routine in MOOSE that calls this method, and within Libmesh the places I found calling it seemed to be for adaptive meshing or for the creation/destruction of ghost elements, which is what you are referring to. Hopefully @roystgnr can comment on this method, as it might be partially what we need; though it seemed to me that it does a search over all members of a Periodic Boundary, which could be avoided if the pair is recorded once and for all.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4900314",
                          "updatedAt": "2023-02-08T03:01:38Z",
                          "publishedAt": "2023-02-08T03:01:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Do you not want to use mortar?",
                  "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4405162",
                  "updatedAt": "2022-12-15T00:20:40Z",
                  "publishedAt": "2022-12-15T00:20:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Good question! So, I had forgotten my notes from the summer when talking with @reverendbedford that the Mortar objects don't allow stateful materials. This is an issue for applying PBC using the Nitsche/DG method for Tensor Mechanics using the Mortar approach. So I was developing for the heat conduction/diffusion case using the mortar objects up to now (which you're familiar with that), and then we tried porting to Tensor Mechanics and hit the stateful error message.\nI can add more details later. What the two paths are for getting to our formulation goal is:\n\nAdd stateful materials to mortar objects in the case when quadrature points are fixed for all time (the case for mesh tying such as PBC; NOT the case for contact mechanics). Then add the ability to have a vector offset for the search/projection direction between primary and secondary sides; this is needed for non-rectangular RVE domains.\nUse interface kernels for the PBC Nitsche method and Lagrange multiplier methods, which work for stateful materials. This requires the reading in of element-neighbor pairs (demonstrated above) and the ability for the pair to not be physically adjacent. Obviously the mortar method functions already do that for quadrature points (using projection along the unit outward normal) since the surfaces can be separated. So I just need to access the inverse_map in a similar fashion.\n\nIt seemed to me that, option 2 would require less implementation (as I have existing codes that generates all the needed element-neighbor pairs; just need a MeshGenerator that reads a CSV file of those and updates the mesh). And I can use the diffusion mortar PBC implementations to check the new implementation.",
                  "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4405451",
                  "updatedAt": "2022-12-15T01:28:57Z",
                  "publishedAt": "2022-12-15T01:28:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I had a very similar discussion with Alex a while ago actually. 1 is tough, quoting Alex. Though it might be easier if we assume the mortar mesh never changes. Plus it doesn't require libmesh level changes, unlike option 2 which requires modifying inverse_map().\nI can see how 2 might work as well. Since implementing a mesh generator which enables restarting a CZM simulation also helps many of our simulations, I will also be supportive of option 2.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4405587",
                          "updatedAt": "2022-12-15T01:58:19Z",
                          "publishedAt": "2022-12-15T01:58:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Let's try to respond within relevant threads to keep the discussion thread clear. For cases where the mesh can change, I've often felt that the current way we do stateful material properties is a little disappointing. Yes we have an implementation for projection of material properties, but this would be very natural if the \"stateful properties\" were finite element approximations. Then we have incredibly generic projections (the libMesh GenericProjector for example) immediately at our disposal. Additionally within the mortar method, even if the mortar segments change, the ability to evaluate finite element bases connected to the parent mesh is flawless. So aux variables for instance work \"flawlessly\" with mortar, and you have access to old and older states (up to arbitrarily old states). I quote \"flawlessly\" because it's not quite flawless when you want to do AD as we do not yet have first class capability for storing aux variables with AD information",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4407007",
                          "updatedAt": "2022-12-15T06:15:20Z",
                          "publishedAt": "2022-12-15T06:15:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "For problems in which you do not have mesh adaptivity or something like mortar, the way we do stateful material properties is great... you do not introduce any error by projecting your material property evaluations into a finite element basis approximation.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4407022",
                          "updatedAt": "2022-12-15T06:19:28Z",
                          "publishedAt": "2022-12-15T06:19:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "I started discussing the mortar case sense you brought it up :) but my other problem is that I missed the \"Write a reply\" box.\nThe mortar system was helpful for testing out the weak imposition of periodic conditions, but it is more general than our typical use case which will be conforming mesh tying across the external surfaces. Mortar would allow for non-conforming PBC, but is a bit more expensive due to interface segments and also has a different parallelization compared to Interface Kernels. Also, the topic of stateful materials for constitutive models in tensor mechanics is a lengthy discussion which I agree is off topic here.\nSo, I will up-vote my response above about the element-neighbor pairing and comment on the inverse_map below, which can be moved to a separate discussion and issue.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4415467",
                          "updatedAt": "2022-12-16T01:16:15Z",
                          "publishedAt": "2022-12-16T01:16:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "I'm not sure how inverse_map() works, but if it has access to either the coordinates of 1. nodes of the face or 2. the quadrature points of the face or else 3. the centroid of the face, then the easy way to compute the offset is just to average them and subtract them. That can be done at EVERY interface, since for adjacent ones the offset will be (0,0,0). That way, no flags have to get passed in, at the expense of some vector additions/divisions for each element pair.",
                  "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4405761",
                  "updatedAt": "2022-12-15T02:36:47Z",
                  "publishedAt": "2022-12-15T02:36:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The inverse map solves a normal equation to locate a point in the parametric space. So 1. Yes. 2. It could be any point, not limited to qps. 3. I'm sure that information is indirectly available somehow.\nBut inverse_map() is a performance critical low level routine, you'll probably have to overload it, not modifying the existing implementation which adds any computational cost.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4405791",
                          "updatedAt": "2022-12-15T02:44:50Z",
                          "publishedAt": "2022-12-15T02:44:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "I found the source code with the source code in FEMap::inverse_map() that solves the normal equation you mentioned. So if I look up the data structure of element_data and neighbor_data, I will look for a low-impact way to incorporate the change, which will likely involve a flag and might get handled either in inverse_map or even nicer if in Assembly::reinitElemAndNeighbor.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4415490",
                          "updatedAt": "2022-12-16T01:21:41Z",
                          "publishedAt": "2022-12-16T01:21:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Axisymmetric coordinates postprocessing",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello everyone,\nI had two questions regarding the axisymmetric coordinates.\n\nLet's say that I solved my problem in RZ coordinates. Now I want to visualize my 2D data in 3D. What is the most convenient way to do it?\nI have a variable which is called \"c\". I want to integrate c over the 3D volume, not the 2D surface. Is there any available kernel for that? This volume integration would be an important part of my work.\n\nThank you,\nAli",
          "url": "https://github.com/idaholab/moose/discussions/24117",
          "updatedAt": "2023-04-29T02:35:05Z",
          "publishedAt": "2023-04-19T01:43:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "You can use Preview, see Rotational Extrusion filter.\nIf you are using PostProcessor, it will automatically account for coordinate system. It does volume integral.",
                  "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655435",
                  "updatedAt": "2023-04-19T02:22:02Z",
                  "publishedAt": "2023-04-19T02:22:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Not Preview, but Paraview :)\nYou may need to \"Extract Surface\" before applying the extrusion filter.",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655536",
                          "updatedAt": "2023-04-19T02:35:40Z",
                          "publishedAt": "2023-04-19T02:35:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "And \"Transform\" filter :-)",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655545",
                          "updatedAt": "2023-04-19T02:37:40Z",
                          "publishedAt": "2023-04-19T02:37:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "I used Paraview. Firstly, I needed to use \"Extract Surface\" and then  \"Rotational Extrusion\".\nThis is part of my input file and I use RZ coordinates. So this one calculates the c volume integral on the domain. Correct?\n\n[Postprocessors]\n  [./c_integral]\n    type = ElementIntegralVariablePostprocessor\n    variable = c\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655866",
                          "updatedAt": "2023-04-19T03:39:46Z",
                          "publishedAt": "2023-04-19T03:39:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Correct. This is over the entire mesh, and in 2D RZ it corresponds to a 3D volume integral because the local element Qp volumes are multiplicated by 2 pi r",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655912",
                          "updatedAt": "2023-04-19T04:07:51Z",
                          "publishedAt": "2023-04-19T03:47:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "No, it doesn't work by multiplying element volumes by 2 pi r, which would yield the wrong answer. There's a coordinate transformation Jacobian which is r.",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655971",
                          "updatedAt": "2023-04-19T04:02:50Z",
                          "publishedAt": "2023-04-19T04:02:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Ok, so because of the Jacobian coordinate transformation, the volume integral would be correctly calculated? Here is my results for c integration (order parameter in the phase field), which is supposed to be conserved. I don't know why I get the oscillation!\n\nThanks,\nAli",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5667379",
                          "updatedAt": "2023-04-19T23:30:27Z",
                          "publishedAt": "2023-04-19T23:30:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what is the X axis here ?",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5667409",
                          "updatedAt": "2023-04-19T23:34:49Z",
                          "publishedAt": "2023-04-19T23:34:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Y axis is c integral, and X axis is time.",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5667419",
                          "updatedAt": "2023-04-19T23:36:01Z",
                          "publishedAt": "2023-04-19T23:36:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "What is your BC? Are you running a C-H equation? It only conserves when zero flux BC is applied for chemical potential variable.",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5667428",
                          "updatedAt": "2023-04-19T23:38:51Z",
                          "publishedAt": "2023-04-19T23:38:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "I am running coupled cahn hilliard navier stokes equation. Chemical potential's BC is neumann BC on all 4 boundaries.",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5667470",
                          "updatedAt": "2023-04-19T23:48:31Z",
                          "publishedAt": "2023-04-19T23:48:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "alimostafavi24"
                  },
                  "bodyText": "Thank you very much (@jiangwen84 @hugary1995 @GiudGiud )!",
                  "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655958",
                  "updatedAt": "2023-04-19T03:59:36Z",
                  "publishedAt": "2023-04-19T03:59:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}