{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNS0xMlQwODo0NzozMi0wNjowMM4AMzad"
    },
    "edges": [
      {
        "node": {
          "title": "how to printout node number with std::cout",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "Dear MOOSE Team,\nI am working on debugging by printing variable \"flux_value\" using std::cout as:\nstd::cout << \" \" << _q_point[_qp]\n<< \" flux = \" << _flux_value[_qp]\n<< \" dt =\" << _dt << \" t =\" << _t\n<< std::endl;\nI am also trying to print the node number using \"_current_node\" but it is not working.\nPlease help.\nThomas",
          "url": "https://github.com/idaholab/moose/discussions/17803",
          "updatedAt": "2022-06-02T14:35:24Z",
          "publishedAt": "2021-05-11T19:47:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The '<<' operator probably has not been defined for the type of _current_node (libmesh Node). You can print its attributes or you can use the already defined routines.\nSee libmesh Node\nNote that if you used a debugger instead I think you could just do p _current_node and get everything about it.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-725743",
                  "updatedAt": "2022-06-02T14:35:48Z",
                  "publishedAt": "2021-05-11T20:04:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you GiudGiud.\nNo. I am not using a debugger.\nI am still new to MOOSE.\nCould you please explain more about \"You can print its attributes or you can use the already defined routines?\"\nIt would be appreciated if you could give me an example(s).\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-725833",
                          "updatedAt": "2022-06-02T14:35:50Z",
                          "publishedAt": "2021-05-11T20:33:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "like you can do std::cout << _current_node.get_info() or .get_id()",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-725963",
                          "updatedAt": "2022-06-02T14:36:17Z",
                          "publishedAt": "2021-05-11T21:09:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "I am sorry Guillaume but\nstd::cout << _current_node.get_info()\nor\nstd::cout << _current_node.get_id()\nare not working for me. :(\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-726226",
                          "updatedAt": "2022-06-02T14:36:17Z",
                          "publishedAt": "2021-05-11T22:13:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "Why are you trying to get the node ID?\nAlso, it's a pointer:\nstd::cout << _current_node->id() << std::endl;",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-726229",
                          "updatedAt": "2024-10-26T20:55:50Z",
                          "publishedAt": "2021-05-11T22:15:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "styyokuda"
                  },
                  "bodyText": "Thank you Logan,\nBy some reason, \"std::cout << _current_node->id() << std::endl;\" is not\nworking for me. :(\nIn my program, coefficients are calculated and I am trying to make sure the\ncoefficients values are correct by printing them with the node number. If I\ndon't use \"std::cout,\" what do you recommend?\nPlease let me know.\nThomas\n\u2026\nOn Tue, May 11, 2021 at 3:15 PM Logan Harbour ***@***.***> wrote:\n Why are you trying to get the node ID?\n\n Also, it's a pointer:\n\n std::cout << _current_node->id() << std::endl;\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#17803 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ASQAPL7LMCOVJO3D234MOFTTNGUABANCNFSM44WWSS2Q>\n .",
                  "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-731230",
                  "updatedAt": "2022-06-02T14:36:41Z",
                  "publishedAt": "2021-05-12T21:53:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I believe it's get_id() you should be using. <- not true, see below\nI recommend you use a debugger. They are incredibly powerful and can be used with any software. You will find tutorials online, and there is more information for using them in MOOSE there",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-731457",
                          "updatedAt": "2022-06-02T14:36:50Z",
                          "publishedAt": "2021-05-12T23:03:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "No, std::cout << _current_node->id() << std::endl; should work. Please let us know what do you mean by \"is not working for me\", then we can help.",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-733713",
                          "updatedAt": "2022-06-02T14:36:48Z",
                          "publishedAt": "2021-05-13T13:04:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "styyokuda"
                  },
                  "bodyText": "Thank you very much, Gary.\nThe compiler error is: *use of undeclared identifier '_current_node';**did\nyou mean '_current_elem'?*\nstd::cout << _current_elem->id() << std::endl; is working but this printout\nis for element number, isn't it?\nMy MacBOOK Pro is still running on macOS Mojave and I have not updated\nMOOSE for more than a year\nbecause I believe a higher macOS operating system is required for the\nupdate.\nDo you think this is the reason?\n\nIt is not exactly debugging. Because I wrote C++ objects to calculate a\nnumber of coefficients and boundary fluxes (for BC settings)\nfor a heat transfer and concentration diffusion model.\nI thought I could print coefficients and fluxes along with temperatures and\nconcentrations on nodes on the screen with std::cout.\nPlease let me know if any other way is possible.\nI would like to thank you for your time and help.\nThomas\n\u2026\nOn Thu, May 13, 2021 at 6:04 AM Gary (Tianchen) Hu ***@***.***> wrote:\n No, std::cout << _current_node->id() << std::endl; should work. Please\n let us know what do you mean by \"is not working for me\", then we can help.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#17803 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ASQAPL2ZJ6IQCR6ITAMN7TTTNPE6VANCNFSM44WWSS2Q>\n .",
                  "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-736088",
                  "updatedAt": "2022-06-02T14:37:03Z",
                  "publishedAt": "2021-05-13T22:59:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok _current_node is not set for the class of kernel that you are using. You should work off the _current_elem and _qp index to retrieve the node if you need it.\nSee libmesh Elem doxygen for all the routines you can use.\nYou dont need to update your macOS to update moose.",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-736110",
                          "updatedAt": "2022-06-02T14:38:16Z",
                          "publishedAt": "2021-05-13T23:07:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you GiudGiud for your time and effort.\nBecause your suggestion seems to be too much work for me, I will look for other way to do that.\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-740310",
                          "updatedAt": "2022-06-02T14:38:24Z",
                          "publishedAt": "2021-05-14T21:20:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Segment Fault for CNS Advection",
          "author": {
            "login": "ChrocheMisawa"
          },
          "bodyText": "Hello,\n  I'm current using the latest branch from @lindsayad , I was trying to produce some similar results for the model that I shown in #17760 . However, the code gives Segmentation fault error whenever I ran it with multiple cores, both for my input and the test input file at \"modules/navier_stokes/test/tests/finite_volume/cns/scalar_advection/mass-frac-advection.i\"\n\n  Both input file can run under single thread mode. (Although mine does not converge)\n\n  I wonder if the MPI feature is fully supported at this stage.\n\nFlow_Past_a_Cylinder_cns.zip\nThank you,\nZeyu Chen",
          "url": "https://github.com/idaholab/moose/discussions/17815",
          "updatedAt": "2022-06-21T01:11:15Z",
          "publishedAt": "2021-05-13T02:31:00Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad",
                  "url": "https://github.com/idaholab/moose/discussions/17815#discussioncomment-734542",
                  "updatedAt": "2022-06-21T01:11:15Z",
                  "publishedAt": "2021-05-13T16:09:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I will try to take a look at this soon",
                  "url": "https://github.com/idaholab/moose/discussions/17815#discussioncomment-735254",
                  "updatedAt": "2022-06-21T01:11:15Z",
                  "publishedAt": "2021-05-13T18:48:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@ChrocheMisawa if you pull my most recent branch updates these should run now. There was an error in the number of ghost layers being used. Previously that input was generating one ghost layer when it needed two.",
                          "url": "https://github.com/idaholab/moose/discussions/17815#discussioncomment-739778",
                          "updatedAt": "2022-06-21T01:11:48Z",
                          "publishedAt": "2021-05-14T18:32:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "interface conditions",
          "author": {
            "login": "dealmeidavf"
          },
          "bodyText": "Hello,\nIs there a MOOSE documentation of a weak formulation involving interfaces that I can read about? I am interested in understanding, at the mathematical level, what MOOSE does when we code a class derived from InterfaceKernel. I believe MOOSE considers unknown variables in different subdomains as discontinuous across the interface. If the interface condition calls for continuity, this needs to be imposed weakly using an InterfaceKernel class. Is there another way to impose continuity at an interface?\nA related issue is the code:\n\n  \n    \n      moose/modules/heat_conduction/src/interfacekernels/ConjugateHeatTransfer.C\n    \n    \n        Lines 42 to 56\n      in\n      1585ebf\n    \n  \n  \n    \n\n        \n          \n           Real \n        \n\n        \n          \n           ConjugateHeatTransfer::computeQpResidual(Moose::DGResidualType type) \n        \n\n        \n          \n           { \n        \n\n        \n          \n             switch (type) \n        \n\n        \n          \n             { \n        \n\n        \n          \n               case Moose::Element: \n        \n\n        \n          \n                 return raw_value(_h[_qp]) * (_T_fluid[_qp] - _neighbor_value[_qp]) * _test[_i][_qp]; \n        \n\n        \n          \n            \n        \n\n        \n          \n               case Moose::Neighbor: \n        \n\n        \n          \n                 return raw_value(_h[_qp]) * (_neighbor_value[_qp] - _T_fluid[_qp]) * _test_neighbor[_i][_qp]; \n        \n\n        \n          \n            \n        \n\n        \n          \n               default: \n        \n\n        \n          \n                 return 0.0; \n        \n\n        \n          \n             } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nIf the temperature is continuous at the interface, this would make the return value of the residual equal to zero correct?\nThanks.\n--\nValmor",
          "url": "https://github.com/idaholab/moose/discussions/17828",
          "updatedAt": "2022-06-11T02:18:08Z",
          "publishedAt": "2021-05-13T16:26:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "InterfaceKernel allows you to implement a weak form at the interface by providing you the shape/test functions, variable values, etc at both sides of the interface. At the mathematical level, you need to derive your weak form baed on your interfacial condition. It can be used to enforce continuity condition, like PenaltyInterfaceDiffusion.C, or transfer heat from one domain to another, like ConjugateHeatTransfer.C.\nFor your second question, if the temperature is continuous, the residual will be zero. Physically, it means there is no heat transfer if two domains have the same temperature across the interface.",
                  "url": "https://github.com/idaholab/moose/discussions/17828#discussioncomment-736637",
                  "updatedAt": "2022-06-11T02:18:35Z",
                  "publishedAt": "2021-05-14T03:17:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dealmeidavf"
                          },
                          "bodyText": "From this signature:\n\nReal\nConjugateHeatTransfer::computeQpResidual(Moose::DGResidualType type)\n{\n\nI take it the test function of the interface condition is discontinuous on finite elements. Correct?\nAlso on your last comment, even with continuous temperature there may still exist a non-zero heat flux; hence heat transfer can occur. The gradient of temperature at the interface is the deciding factor.\nI don't seem to be able to find a Galerkin weak formulation for interfacial problems in the MOOSE site/distribution. It would be instructive to have one or be directed to one.\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/17828#discussioncomment-739430",
                          "updatedAt": "2022-06-11T02:18:36Z",
                          "publishedAt": "2021-05-14T16:50:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "ConjugateHeatTransfer is not used to enforce temperature continuity across the interface unless the heat transfer coefficient is large enough (then it becomes the penalty parameter). It actually applies a Neumann boundary condition to both sides of the interface where the flux is defined as _h[_qp]) * (_T_fluid[_qp] - _neighbor_value[_qp]). The flux is always the same but opposite at two sides of the interface, so the flux is continuous. When there is no temperature jump, the flux becomes zero and it would apply a zero flux BC.\nSounds like this might not be what you would like to use for your application. If you could let us know what interfacial conditions you would like to apply, we can help on the weak form derivation and implementation.\nFor your first question, I believe interfaceKernel can be used on both continuous or discontinuous interface. It depends on whether your mesh is continuous or not across the interface.",
                          "url": "https://github.com/idaholab/moose/discussions/17828#discussioncomment-739631",
                          "updatedAt": "2022-06-11T02:19:31Z",
                          "publishedAt": "2021-05-14T17:52:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Thermal Radiation",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi, feel like im bombarding you guys today :). Im trying the new ray tracing based thermal radiation stuff, so I setup my geometry in Cubit as usual, with what I think are appropriate boundaries and so on. I've been trying to use my Cubit generated mesh, but I first hit an error:\n*** ERROR ***\nThis action adds MeshGenerator objects and therefore only works with a MeshGeneratorMesh.\n\nSo I changed my mesh section from\n[Mesh]\n  file = '../mesh/hot-cup.e'\n[]\n\nto\n type = MeshGeneratorMesh\n [bob]\n   type = FileMesh\n   file = '../mesh/hot-pipes.e'\n []\n\nBut I get the error message;\n*** ERROR ***\nTask add_mesh_generator is not registered to build MooseMesh derived objects\n\nI presume from this, I can't use a file based mesh? Looking at the tests that exist for this functionality, it seems that they only use internally generated mesh, just checking, is that right? I can't use an exeternal mesh?",
          "url": "https://github.com/idaholab/moose/discussions/17818",
          "updatedAt": "2022-06-24T02:41:58Z",
          "publishedAt": "2021-05-13T07:57:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "Ah, got it, I need to use\n[Mesh]\n  [bob]\n    type = FileMeshGenerator\n    file = '../mesh/hot-pipes-radiation.e'\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-732681",
                  "updatedAt": "2022-06-24T02:42:31Z",
                  "publishedAt": "2021-05-13T08:29:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Ok, almost there, my geometry is the following;\n\nI have the following boundaries (side sets) defined vol-1 to vol-9 which are the pipes in the middle, I have vol-10 which are the inner walls of the block. I have a further side set called outer-walls which is the exterior boundary. I have a ConvectiveHeatFlux boundary condition on the outside wall.\nMy problem, is it seems I need to define an additional RayBC either reflection or kill on the green (vol-10) side set, but when I do via a RayBCs section, I get an error\n*** ERROR ***\nThe following error occurred in the object \"ray_study_uo_cavity\", of type \"ViewFactorRayStudy\".\n\nRequires one and only one ViewFactorRayBC.\n\nStack frames: 12\n\nWithout it, I get the following error\n*** ERROR ***\nRay on processor 0 and thread 0 failed to trace at line 2137\n\nDon't know what to do with a Ray after it hit an external\nboundary at point (x,y,z)=( 0.37651,   0.4125, -0.0639156)!\n\nWhen hitting an external RayBC, a Ray must either:\n  Be killed by a RayBC\n  Have its trajectory changed by the RayBC\nby at least one of the executed RayBCs.\n\nYou need to either:\n  Kill/change the Ray sooner with RayKernels, internal RayBCs, or a max distance\n  Kill/change the Ray on the boundary with a RayBC\n\nBoundaries that did not have any RayBCs:\n  12 (outer-walls)\n\nMy diffuse radiaiton block looks like this;\n[GrayDiffuseRadiation]\n  [cavity]\n    boundary = 'vol-1 vol-2 vol-3 vol-4 vol-5 vol-6 vol-7 vol-8 vol-9 vol-10'\n    emissivity = '0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9'\n    n_patches = '10 10 10 10 10 10 10 10 10 10'\n    partitioners = 'centroid centroid centroid centroid centroid centroid centroid centroid centroid centroid'\n    centroid_partitioner_directions = 'radial radial radial radial radial radial radial radial radial radial'\n    temperature = temperature\n    ray_tracing_face_type = 'gauss'\n    view_factor_calculator = 'ray_tracing'\n  []\n[]\n\nSo I guess my question, has a few bits, is my setup sensible, and if so, what should I do about the outer-walls?",
                          "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-732972",
                          "updatedAt": "2022-06-24T02:42:31Z",
                          "publishedAt": "2021-05-13T09:45:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "The orientation of the internal sidesets for this capability are very important. Recall that for interior sidesets, the sideset will be associated with the side of an element, so there are two possible orientations.\nI suspect that what is happening here is that we're tracing rays from vol-10 outward to outer-walls because the orientation is off here, which is definitely not what you want to do. We trace rays based on the half space of the normal and the orientation. The default orientation is that the normals for your internal sidesets point inward to the cavity (see the picture below).\n\nWe probably need to improve the documentation here a bit \ud83d\ude2c",
                          "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-734123",
                          "updatedAt": "2022-06-24T02:42:42Z",
                          "publishedAt": "2021-05-13T14:32:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Thanks @loganharbour I believe the sideset convention above is honored by my geometry? I should point out I don't have any internal sidesets, the region between the cylinders and the start of the hollow brick, is not meshed.\n\n\nOr are you saying, my normals all need reversing?\nI think this requirement may be a little impossible to achieve in some models, given what Cubit does during imprinting and merging, surfaces that become merged can have inconsistent normals in this scheme and I think this will be true of the sidesets they belong to. E.g. two cubes that have an adjacent shared face will have a normal that points in a particular direction, the surface that is shared has a property sense_forward which can be FORWARD or REVERSE. I have no control over this if want to produce a consistent mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-737184",
                          "updatedAt": "2022-06-24T02:43:25Z",
                          "publishedAt": "2021-05-14T07:08:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "I should point out I don't have any internal sidesets, the region between the cylinders and the start of the hollow brick, is not meshed.\n\nAhh, this is actually a bigger issue. With the initial ray tracing capability, we're required to traverse through the mesh even when tracing from a boundary to another boundary. There are plans in the future to look into tracing by checking all possible boundary surfaces instead of requiring a mesh, but we unfortunately don't have time right now to do this.\nIf I recall correctly, @helen-brooks is looking into something that is like this (boundary-to-boundary tracing), but I cannot recall if it is using MOOSE or just libMesh.",
                          "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-738793",
                          "updatedAt": "2022-11-08T17:52:05Z",
                          "publishedAt": "2021-05-14T14:43:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "helen-brooks"
                          },
                          "bodyText": "@loganharbour The project you are referring to is using libMesh to do surface ray-tracing within DAGMC, which @makeclean is aware of since it was his idea. Recently haven't had much time to work on this, though if it's something you or the MOOSE community would be interested in, it might be an argument to put in more resources.",
                          "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-739017",
                          "updatedAt": "2022-11-08T17:52:05Z",
                          "publishedAt": "2021-05-14T15:14:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Questions about free energy in the official case DerivativeMultiPhaseMaterial.i",
          "author": {
            "login": "tmewhy"
          },
          "bodyText": "Hi guys\nI am studying the official case DerivativeMultiPhaseMaterial.i.\n\n(modules/phase_field/examples/multiphase/DerivativeMultiPhaseMaterial.i)\n\nIn this case, the free energy is set to F1=(c-1)^2, F2=(c-0.5) ^2, F3=c ^2, the initial conditions set the concentration c to smoothly change from 1 to 0. According to my own understanding, according to the principle of minimizing free energy, c=1, c=0.5, c=0, they should all be balanced phases, but the simulation result is that only c=0.5, c=0 are left.  I\u2019m very confused about this. Is my understanding of free energy not clear enough, or what setting was used in the case to cause c=1 not to be a minimum free energy phase.",
          "url": "https://github.com/idaholab/moose/discussions/17816",
          "updatedAt": "2022-10-03T11:00:02Z",
          "publishedAt": "2021-05-13T07:13:17Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "simopier"
                  },
                  "bodyText": "Hi,\nas you noticed, the phase with c=1 disappears in that simulation, despite c=1 being a minimum for the bulk free energy defined as Fb = h1*F1+h2*F2+h3*F3. This is because the total free energy also includes other sources of energy.\nAs you can see in the input file, it includes:\n\nan energy barrier defined by the MultiBarrierFunctionMaterial block and included in the energy by the free_energy block (g(\u03b7))\nthe cross energies for the order parameters defined in the cross_terms block (the equivalent of \u03ba/2 |\u2207 \u03b7| 2 for a multi-phase system)\nan energy term related to the gradient of the concentration introduced in local_free_energy (\u03ba/2 |\u2207 c| 2)\n\nThe microstructure evolves to reduce the integral of the total free energy, not only the bulk free energy contribution. By loosing the center phase with c=1, the system reduces the interfacial free energy due to the concentration and order parameter gradients.\nI hope that helps!",
                  "url": "https://github.com/idaholab/moose/discussions/17816#discussioncomment-735900",
                  "updatedAt": "2022-10-03T11:00:17Z",
                  "publishedAt": "2021-05-13T21:46:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tmewhy"
                          },
                          "bodyText": "I have fully understood this question through your answer, thank you very much for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/17816#discussioncomment-736376",
                          "updatedAt": "2022-12-12T00:21:17Z",
                          "publishedAt": "2021-05-14T01:30:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "simopier"
                          },
                          "bodyText": "You are welcome!",
                          "url": "https://github.com/idaholab/moose/discussions/17816#discussioncomment-738705",
                          "updatedAt": "2022-12-12T00:21:36Z",
                          "publishedAt": "2021-05-14T14:26:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Get a non-const Function",
          "author": {
            "login": "xuxiaobei1995"
          },
          "bodyText": "Hi all,\nRecently I updated my MOOSE and found that the returned type of getFunction() has been changed from \"Function &\" to \"const Function &\". However in my code I want to get the function and modify its data, which means a non-const Function is needed. Does anyone know the way to realize this? Any suggestion is appreciated.\nXiaobei",
          "url": "https://github.com/idaholab/moose/discussions/17796",
          "updatedAt": "2022-06-01T14:05:56Z",
          "publishedAt": "2021-05-11T14:45:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "See the accepted answer instead of this one.\nHave a look online, or inside MOOSE, for const_cast",
                  "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-725982",
                  "updatedAt": "2022-06-01T14:05:56Z",
                  "publishedAt": "2021-05-11T21:14:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Thank you Andy! This is just what I need.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-726540",
                          "updatedAt": "2022-06-01T14:06:26Z",
                          "publishedAt": "2021-05-12T01:01:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "I wouldn't recommend this, it is const for a reason. Any object can get a function, thus if it is non-const then any object could change it. You will find yourself in a situation that by adding a Material that uses a function changes the behavior of the function that is also used by some other object.",
                  "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-729334",
                  "updatedAt": "2022-06-01T14:06:26Z",
                  "publishedAt": "2021-05-12T14:05:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I second @aeslaughter 's point. @xuxiaobei1995 if you can let us know what you want to do by \"modifying its data\", we can offer more help.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-733737",
                          "updatedAt": "2022-06-01T14:06:41Z",
                          "publishedAt": "2021-05-13T13:10:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Thanks for your suggestion! What I want is to give an array to my function. The function is computed based on the array. I added a vector as a data member in the function for storing the array. My previous way is to get the function (using getFunction()) and access the vector directly. Do you know the safer way to implement this? @aeslaughter @hugary1995",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734425",
                          "updatedAt": "2022-06-01T14:06:43Z",
                          "publishedAt": "2021-05-13T15:36:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "What type of object is giving the array to the Function? And when do you need this to happen?",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734484",
                          "updatedAt": "2022-06-01T14:07:01Z",
                          "publishedAt": "2021-05-13T15:52:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "You should probably add a method that takes a const view of your array.\nFunctions really should only be used for simple calls when you always pass a position and time to get a value. I would advise against adding methods to them, because in my opinion you should only be using a Function when it follows through the normal value interfaces that take a point and time.\nI would suggest creating a UserObject that has such a custom method on it (where you pass in your data). You can then couple to this UserObject and call its methods from within your other MooseObject.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734485",
                          "updatedAt": "2022-06-01T14:07:28Z",
                          "publishedAt": "2021-05-13T15:53:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "What type of object is giving the array to the Function? And when do you need this to happen?\n\nIt is a transfer which receives the array from the masterapp. So it happens at TIMESTEP_BEGIN or TIMESTEP_END",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734608",
                          "updatedAt": "2022-06-01T14:07:29Z",
                          "publishedAt": "2021-05-13T16:23:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "You should probably add a method that takes a const view of your array.\nFunctions really should only be used for simple calls when you always pass a position and time to get a value. I would advise against adding methods to them, because in my opinion you should only be using a Function when it follows through the normal value interfaces that take a point and time.\nI would suggest creating a UserObject that has such a custom method on it (where you pass in your data). You can then couple to this UserObject and call its methods from within your other MooseObject.\n\nThanks for your nice advice! It is indeed more reasonable to store the array in a Userobject and let the function couples the userobject to get the data.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734636",
                          "updatedAt": "2022-06-01T14:07:28Z",
                          "publishedAt": "2021-05-13T16:29:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "It is indeed more reasonable to store the array in a Userobject and let the function couples the userobject to get the data.\n\nI don't think you want to store the array in the UserObject. Let's say your data structure that you're passing is a std::vector<Real>, my suggestion is to create a member function on your UO that has a signature something like:\nReal getValue(const std::vector<Real> & data) const;\n\nIn this case, you're passing a const reference to the UO so that it can look at the data, and then create a value based on it. I'm not suggesting that you actually store the data (your array) in the UO. By doing it this way, you only need const access to the UO and can call const methods on it.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734685",
                          "updatedAt": "2022-06-01T14:08:09Z",
                          "publishedAt": "2021-05-13T16:37:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "@loganharbour Thank you Logan! I think I know how to do it now.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734860",
                          "updatedAt": "2022-06-01T14:08:23Z",
                          "publishedAt": "2021-05-13T17:05:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ADMaterial Problems",
          "author": {
            "login": "YuhangNIU"
          },
          "bodyText": "Hi all\uff0c\nI know the old and older material property values can be obtained through \"getMaterialPropertyOld and getMaterialPropertyOlder\" in non-AD Material. However, could anyone kindly tell me how to get the AD material property value in ADMaterial at the previous time step?\nThanks,\nYuhang",
          "url": "https://github.com/idaholab/moose/discussions/17822",
          "updatedAt": "2023-03-22T08:33:49Z",
          "publishedAt": "2021-05-13T11:40:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "getMaterialPropertyOld and getMaterialPropertyOlder work for AD material properties as well.\nThere is no point in getting old and older material properties with their dual numbers, because all dual numbers will be zero.",
                  "url": "https://github.com/idaholab/moose/discussions/17822#discussioncomment-733673",
                  "updatedAt": "2023-03-22T08:33:49Z",
                  "publishedAt": "2021-05-13T12:54:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Setting value of an AuxVariable in an external program",
          "author": {
            "login": "bielsnohr"
          },
          "bodyText": "I am investigating how my MOOSE app would call an external program by dealing with a simple toy problem. My external program uses libMesh and only has one function that takes a libMesh System, the name of a variable in that system, and then the time step.\nvoid\nsweeping_gaussian(System & sys, const std::string var_name, Real time)\nThis function sets the value of the named variable on each node using the node coordinates.\nMy objective is to use this function to set the value of an AuxVariable within a sub-app that I will then MultiAppCopyTransfer up to the main app. My sub-app defines a FastIonProblem class that inherits from ExternalProblem. It takes the name of the AuxVariable as a Param, and then retrieves the associated underlying libMesh System in the initialiser list. Naively, I then pass that System directly in my call to the external program function above. Given the function directly \"understands\" the native MOOSE format of the System, I don't think there needs to be a separate in-memory representation of the \"ExternalMesh\" like is most other ExternalProblems. Please correct me if wrong on that point.\n#include \"FastIonProblem.h\"\n#include \"sweeping_gaussian.h\"\n\nregisterMooseObject(\"ExternalFastIonApp\", FastIonProblem);\n\nInputParameters\nFastIonProblem::validParams()\n{\n  InputParameters params = ExternalProblem::validParams();\n\n  params.addClassDescription(\"Retrieve fast ion heat fluxes from an external program\");\n  params.addRequiredParam<VariableName>(\n      \"sync_variable\", \"The variable that the external solution will be synced to\");\n  return params;\n}\n\nFastIonProblem::FastIonProblem(const InputParameters & parameters)\n  : ExternalProblem(parameters),\n    _sync_to_var_name(getParam<VariableName>(\"sync_variable\")),\n    _problem_system(getSystem(_sync_to_var_name))\n{\n}\n\n\nvoid\nFastIonProblem::externalSolve()\n{\n  sweeping_gaussian(_problem_system, _sync_to_var_name, time());\n}\nSo far so good, everything compiles, but upon trying to run the MultiApp with this input for the subapp:\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 10\n  ny = 10\n  nz = 10\n[]\n\n[Problem]\n  type = FastIonProblem\n  sync_variable = fi_heat_flux\n[]\n\n[AuxVariables]\n  [fi_heat_flux]\n  []\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 50\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\nI get the following error:\next_fast_ion0: *** ERROR ***\next_fast_ion0: The following error occurred in the object \"MOOSE Problem\", of type \"FastIonProblem\".\next_fast_ion0: \next_fast_ion0: Unable to find a system containing the variable fi_heat_flux\n\nEvidently, the AuxVariable isn't present on the System I am querying and passing to the external program. A few questions related to this:\n\nAm I going about this in the right way?\nIf yes, how do I get the system that the AuxVariable is on? I suspect related to the addExternalVariable() method that can be overridden for ExternalProblem children, but not quite sure how to go about doing that.\n\nThanks in advance!\n\nUPDATE 2021-05-10 17:38 BST\nI have made some progress myself by realising that I probably needed to call getAuxiliarySystem() instead of getSystem(). So, my constructor now looks like:\nFastIonProblem::FastIonProblem(const InputParameters & parameters)\n  : ExternalProblem(parameters),\n    _sync_to_var_name(getParam<VariableName>(\"sync_variable\")),\n    _problem_system(getAuxiliarySystem().system())\n{\n}\nThis gets rid of my previous error, but now I am getting this error:\n[0]PETSC ERROR: Object is in wrong state\n[0]PETSC ERROR: Not for unassembled vector\n...\n[0]PETSC ERROR: #1 VecCopy() line 1557 in /opt/civet/build_1/conda_builds/conda_envs/next-a7feace123/conda-bld/moose-petsc_1611687302001/work/src/vec/vec/interface/vector.c\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n\nI am wondering if this has to do with how I am setting the solution in my external program. This is what the external function looks like:\nvoid\nsweeping_gaussian(System & sys, const std::string var_name, Real time)\n{\n  // Get a constant reference to the mesh object, system number, and variable\n  // number\n  const MeshBase & mesh = sys.get_mesh();\n  const unsigned int & system_number = sys.number();\n  const unsigned short int & variable_number = sys.variable_number(var_name);\n\n  // Boundary information and the left side id\n  BoundaryInfo boundary_info = mesh.get_boundary_info();\n  boundary_id_type left_side = boundary_info.get_id_by_name(\"left\");\n\n  // Temporary variables for loop calculations\n  dof_id_type dof_i;\n  Real gauss;\n\n  // Loop through the local nodes\n  for (const auto & node_ptr : mesh.local_node_ptr_range())\n  {\n    const Node & node = *node_ptr;\n\n    // Check if the node is on the left side\n    if (boundary_info.has_boundary_id(node_ptr, left_side))\n    {\n      // Retrieve the dof_id for this node\n      dof_i = node.dof_number(system_number, variable_number, 0);\n\n      // Set solution vector at this index to some combination of the\n      // coordinate values\n      gauss = 10000.0 * exp(-(pow((node(1) - time / 50) / 0.1, 2)));\n      sys.solution->set(dof_i, gauss);\n    }\n  }\n};",
          "url": "https://github.com/idaholab/moose/discussions/17795",
          "updatedAt": "2022-07-20T14:55:31Z",
          "publishedAt": "2021-05-11T14:08:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@roystgnr Can you help with this?",
                  "url": "https://github.com/idaholab/moose/discussions/17795#discussioncomment-729357",
                  "updatedAt": "2022-07-20T14:55:39Z",
                  "publishedAt": "2021-05-12T14:10:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "Do you simply need to close the vector you're setting before you leave your program?  With PETSc (or any other distributed numerics), most write operations are merely initiated by the setter function, not necessarily completed (because you don't want every set() to potentially delay waiting on a network reply).\nYou might try doing a sys.solution->close() (which completes all the set()s) and a sys.update() (which syncs changes from solution to current_local_solution) at the end of sweeping_gaussian()",
                  "url": "https://github.com/idaholab/moose/discussions/17795#discussioncomment-730440",
                  "updatedAt": "2022-07-20T14:55:39Z",
                  "publishedAt": "2021-05-12T17:46:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bielsnohr"
                          },
                          "bodyText": "Yes, not closing the vector in sweeping_gaussian() was indeed the problem. Putting\nsys.solution->close()\nsys.update()\nat the end of the function resolved the error and now my MultiApp runs. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/17795#discussioncomment-733413",
                          "updatedAt": "2022-07-20T14:55:40Z",
                          "publishedAt": "2021-05-13T11:43:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Accessing shape functions for coupled variables in mixed finite elements for off-diag Jacobian",
          "author": {
            "login": "gridley"
          },
          "bodyText": "From what I can tell, the examples of computeOffDiagJacobian use the same shape and test functions between the primary and coupled variables. I've got a vector kernel that has a coupled scalar variable, so the main variable's shape functions are different from the coupled one's. I know that _phi contains the shape functions for the main variable, which is a vector, but how can I access the shape functions for the coupled scalar variable?\nI need this to get the derivative w.r.t. the term the coupled scalar variable gives in the vector kernel.",
          "url": "https://github.com/idaholab/moose/discussions/17789",
          "updatedAt": "2022-06-29T02:44:14Z",
          "publishedAt": "2021-05-10T14:10:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad Can you help out?",
                  "url": "https://github.com/idaholab/moose/discussions/17789#discussioncomment-729544",
                  "updatedAt": "2022-06-29T02:44:23Z",
                  "publishedAt": "2021-05-12T14:39:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "gridley"
                  },
                  "bodyText": "I think I figured this out as well. It seems you need to use a MooseVariable to access the other shape functions. For example, below, i store a MooseVariable pointer to _p_var and access its scalar shape functions in the computeQpOffDiagJacobian method. I have confirmed this gives the right answer.\n#pragma once\n\n#include \"VectorKernel.h\"\n\n/**\n * This class computes all\n */\nclass INSMomentum : public VectorKernel\n{\npublic:\n  static InputParameters validParams();\n\n  INSMomentum(const InputParameters & parameters);\n\n  virtual ~INSMomentum() {}\n\nprotected:\n  virtual Real computeQpResidual() override;\n  virtual Real computeQpJacobian() override;\n  virtual Real computeQpOffDiagJacobian(unsigned jvar) override;\n\n  const bool _transient;\n\n  // The pressure variable\n  const VariableValue & _p;\n  const VariableGradient & _grad_p;\n  const MooseVariable * _p_var;\n\n  // Velocity time derivatives\n  const VectorVariableValue & _u_dot;\n  const VariableValue & _du_dot_du;\n\n  // Material properties\n  const Real _mu;\n  const Real _rho;\n  const Real _alpha;\n  const Real _nu; // cache this\n};\n#include \"INSMomentum.h\"\n\nregisterMooseObject(\"whaleApp\", INSMomentum);\n\nInputParameters\nINSMomentum::validParams()\n{\n  InputParameters params = VectorKernel::validParams();\n  params.addClassDescription(\"all of the momentum eqn but its time derivative\");\n  params.addRequiredCoupledVar(\"p\", \"pressure\");\n  params.addParam<Real>(\"alpha\", 1, \"Multiplicative factor on the stabilization parameter tau.\");\n  params.addParam<bool>(\"transient\", false, \"whether this is a transient calculation\");\n  params.addRequiredParam<Real>(\"rho\", \"fluid density\");\n  params.addRequiredParam<Real>(\"mu\", \"fluid density\");\n  return params;\n}\n\nINSMomentum::INSMomentum(const InputParameters & params)\n  : VectorKernel(params),\n    _transient(getParam<bool>(\"transient\")),\n    _p(coupledValue(\"p\")),\n    _grad_p(coupledGradient(\"p\")),\n    _p_var(getVar(\"p\", 0)),\n    _u_dot(_transient ? _var.uDot() : _vector_zero),\n    _du_dot_du(_transient ? _var.duDotDu() : _zero),\n    _mu(getParam<Real>(\"mu\")),\n    _rho(getParam<Real>(\"rho\")),\n    _alpha(getParam<Real>(\"alpha\")),\n    _nu(_mu / _rho)\n{\n  if (_p_var == nullptr)\n    mooseError(\"fail to get pressur var?\");\n}\n\nReal\nINSMomentum::computeQpResidual()\n{\n  auto strong_resid_part = _rho * (_u_dot[_qp] + _grad_u[_qp] * _u[_qp]) + _grad_p[_qp];\n  return _test[_i][_qp] * strong_resid_part + _mu * _grad_u[_qp].contract(_grad_test[_i][_qp]) +\n         _u[_qp] * _grad_test[_i][_qp] * strong_resid_part;\n}\n\nReal\nINSMomentum::computeQpJacobian()\n{\n  return _rho * _test[_i][_qp] *\n             (_phi[_j][_qp] * _du_dot_du[_qp] + _grad_u[_qp] * _phi[_j][_qp] +\n              _grad_phi[_j][_qp] * _u[_qp]) +\n         _mu * _grad_phi[_j][_qp].contract(_grad_test[_i][_qp]);\n}\n\nReal\nINSMomentum::computeQpOffDiagJacobian(unsigned jvar)\n{\n  if (jvar == _p_var->number()) {\n    return _test[_i][_qp] * _p_var->gradPhi()[_j][_qp];\n  } else {\n    return 0.0;\n  }\n}",
                  "url": "https://github.com/idaholab/moose/discussions/17789#discussioncomment-729728",
                  "updatedAt": "2022-06-29T02:44:26Z",
                  "publishedAt": "2021-05-12T15:21:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Setting up a block diagonal (blocks separated by variables) preconditioner",
          "author": {
            "login": "gridley"
          },
          "bodyText": "Hi all,\nSo, I have a Jacobian of the form:\n\nNot very surprising, since you could write any matrix like this. The key is that the blocks are separated by the variables. The top row is a pressure Poisson equation, and the bottom row is a momentum equation. I know that A is a Poisson operator, so I'd like to use multigrid here. I'd like to apply block-diagonal preconditioning like:\n\nWhere \\tilde A^{-1}, an approximation to the true inverse of A, comes from one or two applications of boomeramg or the like, and \\tilde D^{-1}, an approximation to the inverse of D, would come from some other as-yet specified preconditioner I know will work well on that type of physics.\nSo, I think there's some way to do this with pcfieldsplit. Could any one point me at an example like this? It seems there is some undocumented Split.h file that may do this. Not sure which is the best way to approach this.\nEDIT: after thinking on this some more, this request maybe doesn't make sense. If anyone recommends reading that explains theory behind the object in Split.h, I'd really like to hear.\nThanks for your time,\nGavin",
          "url": "https://github.com/idaholab/moose/discussions/17775",
          "updatedAt": "2022-10-17T13:22:28Z",
          "publishedAt": "2021-05-07T23:24:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "gridley"
                  },
                  "bodyText": "To partially answer my own question, there are references to explain the different field split approaches in the MOOSE incompressible navier stokes module paper. I'm still not sure whether these are best applied using the Split object in Split.h or via Petsc arguments.\nhttps://arxiv.org/abs/1710.08898",
                  "url": "https://github.com/idaholab/moose/discussions/17775#discussioncomment-718615",
                  "updatedAt": "2022-10-17T13:22:29Z",
                  "publishedAt": "2021-05-10T13:52:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "@fdkong Can you help please?",
                          "url": "https://github.com/idaholab/moose/discussions/17775#discussioncomment-729546",
                          "updatedAt": "2022-10-17T13:22:28Z",
                          "publishedAt": "2021-05-12T14:39:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gridley"
                          },
                          "bodyText": "Hey, I had messaged Fande in the MOOSE slack and think I figured it out. You have to use -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_fact_type diag. Then there are tons of other options to set up the field split solve, but this seems to converge as expected, albeit seeming to have some serious associated overhead with setting up intermediate matrices needed for this approach.",
                          "url": "https://github.com/idaholab/moose/discussions/17775#discussioncomment-729587",
                          "updatedAt": "2022-10-17T13:23:26Z",
                          "publishedAt": "2021-05-12T14:47:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}