{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wNC0wNlQwMzo1MjowMi0wNjowMM4AYcAf"
    },
    "edges": [
      {
        "node": {
          "title": "Convergence Issue: Frictionless Contact",
          "author": {
            "login": "YuanxinXiao"
          },
          "bodyText": "Hi @GiudGiud\nI am working with frictionless contact between the two nested cylinders. I have tried different formulations, still getting convergence issue.\nPenalty Formulation:\n[Contact]\n  [up_center]\n    primary = secondcyl_outside\n    secondary = firstcyl_inside\n    model = frictionless\n    formulation = penalty\n    penalty = 4.5e4\n    al_penetration_tolerance = 1e-3\n  []\n[]\n\n***** Error\n\ufffd[31mLEGACY MODES ENABLED:\ufffd[39m\n This application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate diffs due to zero values being stored, and these tests should be re-golded.\n\ufffd[39m\n\nTime Step 0, time = 0\n\nTime Step 1, time = 0.05, dt = 0.05\n\nPerforming automatic scaling calculation\n\n\n\ufffd[33m\n*** Warning ***\nWarning in PenetrationLocator. Penetration is not detected for one or more secondary nodes. This could be because those secondary nodes simply do not project to faces on the primary surface. However, this could also be because contact should be enforced on those nodes, but the faces that they project to are outside the contact patch, which will give an erroneous result. Use appropriate options for 'patch_size' and 'patch_update_strategy' in the Mesh block to avoid this issue. Setting 'patch_update_strategy=iteration' is recommended because it completely avoids this potential issue. Also note that this warning is printed only once, so a similar situation could occur multiple times during the simulation but this warning is printed only at the first occurrence.\ufffd[39m\n 0 Nonlinear |R| = \ufffd[32m4.650960e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 1 Nonlinear |R| = \ufffd[31m5.490561e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 2 Nonlinear |R| = \ufffd[31m5.492031e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 3 Nonlinear |R| = \ufffd[31m5.555467e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 4 Nonlinear |R| = \ufffd[33m5.551036e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 5 Nonlinear |R| = \ufffd[31m5.831775e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 6 Nonlinear |R| = \ufffd[33m5.798017e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 7 Nonlinear |R| = \ufffd[31m5.864430e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 8 Nonlinear |R| = \ufffd[33m5.821809e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 9 Nonlinear |R| = \ufffd[33m5.811309e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n10 Nonlinear |R| = \ufffd[31m6.033031e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n11 Nonlinear |R| = \ufffd[31m6.071512e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n12 Nonlinear |R| = \ufffd[33m6.040373e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n13 Nonlinear |R| = \ufffd[31m6.071315e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n14 Nonlinear |R| = \ufffd[33m6.048557e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n15 Nonlinear |R| = \ufffd[33m6.022896e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n16 Nonlinear |R| = \ufffd[31m6.060576e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n17 Nonlinear |R| = \ufffd[33m6.048929e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n18 Nonlinear |R| = \ufffd[31m6.073762e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n19 Nonlinear |R| = \ufffd[33m6.060324e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n20 Nonlinear |R| = \ufffd[31m6.429214e-07\ufffd[39m\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 20\nCurrently Executing\n  Finished Solving                                                                       [\ufffd[33m 69.34 s\ufffd[39m] [\ufffd[33m  254 MB\ufffd[39m]\n\ufffd[31m Solve Did NOT Converge!\ufffd[39m\nAborting as solve did not converge\n\nTime Step 1, time = 0.025, dt = 0.025\n 0 Nonlinear |R| = \ufffd[32m2.325480e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 1 Nonlinear |R| = \ufffd[31m1.401177e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 2 Nonlinear |R| = \ufffd[31m1.476554e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 3 Nonlinear |R| = \ufffd[31m3.059321e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 4 Nonlinear |R| = \ufffd[31m3.279850e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 5 Nonlinear |R| = \ufffd[33m3.279108e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 6 Nonlinear |R| = \ufffd[31m3.319057e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 7 Nonlinear |R| = \ufffd[33m3.318562e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 8 Nonlinear |R| = \ufffd[33m3.318530e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 9 Nonlinear |R| = \ufffd[31m3.588273e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n10 Nonlinear |R| = \ufffd[31m3.590154e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n11 Nonlinear |R| = \ufffd[33m3.588876e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n12 Nonlinear |R| = \ufffd[31m3.595042e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n13 Nonlinear |R| = \ufffd[31m3.732917e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n14 Nonlinear |R| = \ufffd[31m3.735204e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n15 Nonlinear |R| = \ufffd[33m3.734657e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n16 Nonlinear |R| = \ufffd[31m3.734678e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n17 Nonlinear |R| = \ufffd[31m3.735573e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n18 Nonlinear |R| = \ufffd[31m3.756984e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n19 Nonlinear |R| = \ufffd[33m3.756708e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n20 Nonlinear |R| = \ufffd[31m1.627666e-06\ufffd[39m\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 20\n  Finished Solving                                                                       [\ufffd[33m 66.65 s\ufffd[39m] [\ufffd[33m  261 MB\ufffd[39m]\n\ufffd[31m Solve Did NOT Converge!\ufffd[39m\nAborting as solve did not converge\n\nTime Step 1, time = 0.0125, dt = 0.0125\n 0 Nonlinear |R| = \ufffd[32m1.162740e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 1 Nonlinear |R| = \ufffd[31m1.921528e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 2 Nonlinear |R| = \ufffd[31m2.808366e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 3 Nonlinear |R| = \ufffd[31m2.822550e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 4 Nonlinear |R| = \ufffd[31m2.841357e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 5 Nonlinear |R| = \ufffd[31m2.973138e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 6 Nonlinear |R| = \ufffd[31m6.819896e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n 7 Nonlinear |R| = \ufffd[31m6.822129e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 8 Nonlinear |R| = \ufffd[33m6.821818e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 9 Nonlinear |R| = \ufffd[31m6.911157e-08\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n10 Nonlinear |R| = \ufffd[31m1.565151e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n11 Nonlinear |R| = \ufffd[31m1.566183e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n12 Nonlinear |R| = \ufffd[31m2.036119e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n13 Nonlinear |R| = \ufffd[31m2.037523e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n14 Nonlinear |R| = \ufffd[31m2.837585e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n15 Nonlinear |R| = \ufffd[31m4.045563e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n16 Nonlinear |R| = \ufffd[31m4.046359e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n17 Nonlinear |R| = \ufffd[33m4.045620e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n18 Nonlinear |R| = \ufffd[31m4.521307e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n19 Nonlinear |R| = \ufffd[31m4.549773e-07\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 50\n20 Nonlinear |R| = \ufffd[31m4.586493e-07\ufffd[39m\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 20\n  Finished Solving                                                                       [\ufffd[33m 61.92 s\ufffd[39m] [\ufffd[33m  264 MB\ufffd[39m]\n\ufffd[31m Solve Did NOT Converge!\ufffd[39m\nAborting as solve did not converge\n\n\nAugmented Lagrange Formulation:\n[Contact]\n  [up_center]\n    primary = firstcyl_inside\n    secondary = secondcyl_outside\n    tangential_tolerance = 1e-3\n    formulation = augmented_lagrange\n    penalty = 1e+5\n    normalize_penalty = true\n    normal_smoothing_distance = 0.3\n    al_penetration_tolerance = 1e-6\n  []\n\n  [down_left]\n    primary = leftcyl_top\n    secondary = firstcyl_outside\n    tangential_tolerance = 1e-3\n    formulation = augmented_lagrange\n    normalize_penalty = true\n    penalty = 4.5e5\n    model = frictionless\n    al_penetration_tolerance = 1e-8\n  []\n[]\n\n\nFramework Information:\nMOOSE Version:           git commit cfc6594588 on 2023-03-23\nLibMesh Version:         14633497ea867c56053d1ea7a1fbe0442727eb24\nPETSc Version:           3.16.6\nSLEPc Version:           3.16.2\nCurrent Time:            Sun Apr  7 16:05:57 2024\nExecutable Timestamp:    Fri Mar 24 19:04:27 2023\n\nParallelism:\n  Num Processors:          20\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          3\n  Spatial Dimension:       3\n  Nodes:                   \n    Total:                 5641\n    Local:                 317\n    Min/Max/Avg:           178/360/282\n  Elems:                   \n    Total:                 19128\n    Local:                 983\n    Min/Max/Avg:           930/985/956\n  Num Subdomains:          3\n  Num Partitions:          20\n  Partitioner:             metis\n\nNonlinear System:\n  Num DOFs:                16923\n  Num Local DOFs:          951\n  Variables:               { \"disp_x\" \"disp_y\" \"disp_z\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                150819\n  Num Local DOFs:          7832\n  Variables:               { \"vonmises_stress\" \"stress_zz\" \"stress_xx\" \"stress_yy\" \"strain_zz\" \"strain_xx\" \n                             \"strain_yy\" } { \"penetration\" \"contact_pressure\" \"nodal_area\" } \n  Finite Element Types:    \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  TimeIntegrator:          ImplicitEuler\n  Solver Mode:             Preconditioned JFNK\n  MOOSE Preconditioner:    SMP\n\n\ufffd[31mLEGACY MODES ENABLED:\ufffd[39m\n This application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate diffs due to zero values being stored, and these tests should be re-golded.\n\ufffd[39m\n\nTime Step 0, time = 0\n\nTime Step 1, time = 0.05, dt = 0.05\n\nPerforming automatic scaling calculation\n\n\n\ufffd[33m\n*** Warning ***\nWarning in PenetrationLocator. Penetration is not detected for one or more secondary nodes. This could be because those secondary nodes simply do not project to faces on the primary surface. However, this could also be because contact should be enforced on those nodes, but the faces that they project to are outside the contact patch, which will give an erroneous result. Use appropriate options for 'patch_size' and 'patch_update_strategy' in the Mesh block to avoid this issue. Setting 'patch_update_strategy=iteration' is recommended because it completely avoids this potential issue. Also note that this warning is printed only once, so a similar situation could occur multiple times during the simulation but this warning is printed only at the first occurrence.\ufffd[39m\n 0 Nonlinear |R| = \ufffd[32m4.679054e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 0.00e+00  (inf     )\n   disp_y: 4.25e-06  disp_y_ref: 0.00e+00  (inf     )\n   disp_z: 2.78e-07  disp_z_ref: 0.00e+00  (inf     )\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 1 Nonlinear |R| = \ufffd[31m4.679056e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 1.59e-09  (1.22e+03)\n   disp_y: 4.25e-06  disp_y_ref: 2.63e-09  (1.61e+03)\n   disp_z: 2.78e-07  disp_z_ref: 1.21e-09  (2.30e+02)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 2 Nonlinear |R| = \ufffd[31m4.679065e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 2.16e-09  (8.97e+02)\n   disp_y: 4.25e-06  disp_y_ref: 4.64e-09  (9.16e+02)\n   disp_z: 2.78e-07  disp_z_ref: 3.27e-09  (8.51e+01)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 3 Nonlinear |R| = \ufffd[31m4.679226e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 6.57e-09  (2.95e+02)\n   disp_y: 4.25e-06  disp_y_ref: 1.97e-08  (2.15e+02)\n   disp_z: 2.78e-07  disp_z_ref: 1.20e-08  (2.32e+01)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 4 Nonlinear |R| = \ufffd[33m4.679218e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 7.73e-09  (2.51e+02)\n   disp_y: 4.25e-06  disp_y_ref: 2.32e-08  (1.83e+02)\n   disp_z: 2.77e-07  disp_z_ref: 1.42e-08  (1.95e+01)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 5 Nonlinear |R| = \ufffd[33m4.679156e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 9.14e-09  (2.12e+02)\n   disp_y: 4.25e-06  disp_y_ref: 2.79e-08  (1.52e+02)\n   disp_z: 2.77e-07  disp_z_ref: 1.70e-08  (1.63e+01)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 6 Nonlinear |R| = \ufffd[31m4.679227e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 1.23e-08  (1.57e+02)\n   disp_y: 4.25e-06  disp_y_ref: 3.55e-08  (1.20e+02)\n   disp_z: 2.77e-07  disp_z_ref: 2.14e-08  (1.30e+01)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 7 Nonlinear |R| = \ufffd[31m4.679260e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 1.27e-08  (1.53e+02)\n   disp_y: 4.25e-06  disp_y_ref: 3.66e-08  (1.16e+02)\n   disp_z: 2.77e-07  disp_z_ref: 2.18e-08  (1.27e+01)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 8 Nonlinear |R| = \ufffd[31m4.679425e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 1.38e-08  (1.41e+02)\n   disp_y: 4.25e-06  disp_y_ref: 3.75e-08  (1.13e+02)\n   disp_z: 2.78e-07  disp_z_ref: 2.43e-08  (1.15e+01)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 9 Nonlinear |R| = \ufffd[33m4.679391e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 1.39e-08  (1.40e+02)\n   disp_y: 4.25e-06  disp_y_ref: 3.76e-08  (1.13e+02)\n   disp_z: 2.78e-07  disp_z_ref: 2.34e-08  (1.19e+01)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n10 Nonlinear |R| = \ufffd[31m4.679401e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 1.39e-08  (1.40e+02)\n   disp_y: 4.25e-06  disp_y_ref: 3.80e-08  (1.12e+02)\n   disp_z: 2.78e-07  disp_z_ref: 2.34e-08  (1.19e+01)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n11 Nonlinear |R| = \ufffd[31m4.679515e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 1.64e-08  (1.18e+02)\n   disp_y: 4.25e-06  disp_y_ref: 4.59e-08  (9.27e+01)\n   disp_z: 2.78e-07  disp_z_ref: 2.69e-08  (1.04e+01)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n12 Nonlinear |R| = \ufffd[31m4.679778e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 2.40e-08  (8.09e+01)\n   disp_y: 4.25e-06  disp_y_ref: 6.62e-08  (6.42e+01)\n   disp_z: 2.80e-07  disp_z_ref: 3.65e-08  (7.67e+00)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n13 Nonlinear |R| = \ufffd[33m4.679772e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 2.40e-08  (8.09e+01)\n   disp_y: 4.25e-06  disp_y_ref: 6.62e-08  (6.42e+01)\n   disp_z: 2.80e-07  disp_z_ref: 3.65e-08  (7.67e+00)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n14 Nonlinear |R| = \ufffd[31m4.679894e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 2.41e-08  (8.05e+01)\n   disp_y: 4.25e-06  disp_y_ref: 6.64e-08  (6.40e+01)\n   disp_z: 2.80e-07  disp_z_ref: 3.74e-08  (7.50e+00)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n15 Nonlinear |R| = \ufffd[33m4.679715e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 2.44e-08  (7.93e+01)\n   disp_y: 4.25e-06  disp_y_ref: 6.71e-08  (6.34e+01)\n   disp_z: 2.79e-07  disp_z_ref: 3.78e-08  (7.38e+00)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n16 Nonlinear |R| = \ufffd[31m4.679821e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 2.95e-08  (6.58e+01)\n   disp_y: 4.25e-06  disp_y_ref: 7.12e-08  (5.97e+01)\n   disp_z: 2.80e-07  disp_z_ref: 4.07e-08  (6.88e+00)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n17 Nonlinear |R| = \ufffd[31m4.680340e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 3.20e-08  (6.06e+01)\n   disp_y: 4.25e-06  disp_y_ref: 7.70e-08  (5.52e+01)\n   disp_z: 2.80e-07  disp_z_ref: 4.51e-08  (6.21e+00)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n18 Nonlinear |R| = \ufffd[33m4.680284e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 3.23e-08  (5.99e+01)\n   disp_y: 4.25e-06  disp_y_ref: 7.68e-08  (5.53e+01)\n   disp_z: 2.80e-07  disp_z_ref: 4.42e-08  (6.32e+00)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n19 Nonlinear |R| = \ufffd[33m4.680230e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 3.25e-08  (5.96e+01)\n   disp_y: 4.25e-06  disp_y_ref: 7.73e-08  (5.50e+01)\n   disp_z: 2.79e-07  disp_z_ref: 4.48e-08  (6.24e+00)\nAugmented Lagrangian contact iteration 0\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n20 Nonlinear |R| = \ufffd[31m4.680797e-06\ufffd[39m\n   Solution, reference convergence variable norms:\n   disp_x: 1.94e-06  disp_x_ref: 3.53e-08  (5.50e+01)\n   disp_y: 4.25e-06  disp_y_ref: 8.39e-08  (5.07e+01)\n   disp_z: 2.81e-07  disp_z_ref: 5.36e-08  (5.24e+00)\nAugmented Lagrangian contact iteration 0\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 20\nCurrently Executing\n  Finished Solving                                                                       [\ufffd[33m 54.28 s\ufffd[39m] [\ufffd[33m  271 MB\ufffd[39m]\n\ufffd[31m Solve Did NOT Converge!\ufffd[39m\nAborting as solve did not converge",
          "url": "https://github.com/idaholab/moose/discussions/27308",
          "updatedAt": "2024-04-08T15:30:32Z",
          "publishedAt": "2024-04-07T20:22:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthe nonlinear residuals are fairly small so maybe the calculation is converged sufficiently already.\nPlease see if automatic or manual scaling can get you below the convergence criteria or if you can change the converge criteria to make it accept a solution. Then check the solution visually for correctness.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27308#discussioncomment-9038911",
                  "updatedAt": "2024-04-07T21:29:23Z",
                  "publishedAt": "2024-04-07T21:29:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "otherwise you ll need to work on the linear system solver. it seems to be failing to converge. it could just be tuning the tolerances, or you could use a stronger preconditioner",
                          "url": "https://github.com/idaholab/moose/discussions/27308#discussioncomment-9047438",
                          "updatedAt": "2024-04-08T14:49:34Z",
                          "publishedAt": "2024-04-08T14:49:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I would always recommend starting with -pc_type lu when debugging contact convergence",
                          "url": "https://github.com/idaholab/moose/discussions/27308#discussioncomment-9047999",
                          "updatedAt": "2024-04-08T15:30:32Z",
                          "publishedAt": "2024-04-08T15:30:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Time-dependent dislocation density",
          "author": {
            "login": "zahidhasan83"
          },
          "bodyText": "Dear MOOSE experts,\nI am using DeformedGrainMaterial to accumulate dislocations in grains. I am trying to make the dislocation density (Disloc_Den) time-dependent. For that the input file looks like:\n[Functions]\n  [./Dislocden_Gradient]\n    type = ParsedFunction\n    expression = '5e+17 + 10*t'\n  [../]\n[]\n\n[AuxVariables]\n[./Dislocden]\n[../]\n[]\n\n[AuxKernels]\n[./Dislocden_grad]\n    type = FunctionAux\n    variable = Dislocden\n    function = Dislocden_Gradient\n    execute_on = TIMESTEP_END\n  [../]\n[]\n\n[Materials]\n[./deformed]\n    type = DeformedGrainMaterial\n    int_width = 4.0\n    Burg_vec = 3.9e-10\n    Disloc_Den = Dislocden\n    Elas_Mod = 73e+9\n    GBE = 1.64\n    GBMobility = 2e-13\n    grain_tracker = grain_tracker\n    v = 'gr0 gr1 gr2 gr3'\n    outputs = exodus\n  [../]\n[]\n\nHowever, running the file it shows an error \"invalid float syntax for parameter: Materials/deformed/Disloc_Den=Dislocden\".\nWhat is the problem, would you be kind to let me know?\nThanks for your support,\nZahid",
          "url": "https://github.com/idaholab/moose/discussions/27306",
          "updatedAt": "2024-04-08T14:41:40Z",
          "publishedAt": "2024-04-07T14:43:47Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthe material you are using expects a floating point number for the Disloc_Den number.\nUnless this material also has a Disloc_Den_function parameter, you will need to either use a different material that lets you specify a function, or modify that material a little bit to use a function.\nThat modification would be really easy. There are many examples of using functions in material properties.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27306#discussioncomment-9037883",
                  "updatedAt": "2024-04-07T19:16:33Z",
                  "publishedAt": "2024-04-07T19:16:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zahidhasan83"
                          },
                          "bodyText": "Dear Dr. Guillaume,\nI appreciate your reply. Since I am a beginner in MOOSE, I am not familiar with modifications of materials to use a function. Also, I am not sure where to find those examples you have mentioned. Would you be kind to direct me to the right place where those examples are stored?\nI highly appreciate your time.\nThanks and best regards,\nZahid",
                          "url": "https://github.com/idaholab/moose/discussions/27306#discussioncomment-9044879",
                          "updatedAt": "2024-04-08T11:26:57Z",
                          "publishedAt": "2024-04-08T11:26:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nyou can see a material using a function here\nhttps://github.com/idaholab/moose/blob/next/framework/src/materials/GenericFunctionMaterial.C\ndont pay attention to the <is_ad> and template stuff, you do not need that.\nspecifically this routine for the evaluation\nGenericFunctionMaterialTempl<is_ad>::computeQpFunctions()\nExamples of code are in the repository. src/ for source file, include/ for headers. I recommend you follow the MOOSE tutorial to learn how to create code that runs in moose",
                          "url": "https://github.com/idaholab/moose/discussions/27306#discussioncomment-9047321",
                          "updatedAt": "2024-04-08T14:41:41Z",
                          "publishedAt": "2024-04-08T14:41:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Making a Moose function value dependent on the subdomain",
          "author": {
            "login": "jmeier"
          },
          "bodyText": "Dear Community,\nFor factoring material parameters I like to have some function values to depend on the subdomain. With this discussion I hope to get a hint in the right direction from you:\n\nIs there a way to make the function value dependent on the subdomain already build in?\nOne option would be to implement my own function object (derived from Function). The methods \"value\", \"gradient\", and \"timeDerivative\" in a (Moose) Function have the arguments Real t and Point & p. But obviously no subdomainID. To avoid hard-coding my geometry to my implementation, I need to get the subdomain when calculating the function value.  Is there an efficient way to get the subdomain?\nIs the question itself feasible? What about points in space occupied by two or more subdomains (e.g. corner nodes)? The alternative would be to have each subdomain have its own material. With a lot of subdomains this would give a lot of materials. But no need for my endeavor described above. Should this alternative be preferred?\n\nHope someone can give me some advice. Much appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/27315",
          "updatedAt": "2024-04-08T14:40:18Z",
          "publishedAt": "2024-04-08T11:41:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you want a dependency on the subdomain, it's better to use material properties.\nYou can code any function as a material property fairly easily (use the _current... attributes indexed [_qp] for the position) and the block restriction is very natural for material properties.\nIf you must use Functions,\nYou can create several functions, and then map them to subdomains using this functor material for example:\nhttps://mooseframework.inl.gov/source/functormaterials/PiecewiseByBlockFunctorMaterial.html\nthen functor materials can be converted to create regular material properties using this:\nhttps://mooseframework.inl.gov/source/materials/MaterialFunctorConverter.html\n\nIs the question itself feasible?\n\nthis is exactly why we didnt implement that dependency\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27315#discussioncomment-9047264",
                  "updatedAt": "2024-04-08T14:38:44Z",
                  "publishedAt": "2024-04-08T14:38:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Picard iterations",
          "author": {
            "login": "gabburgio"
          },
          "bodyText": "Hello everyone,\nI would like to ask how one should go about using fixed-point iterations in a MOOSE nonlinear solve.\nSpecifically, assuming there are two (nonlinear) Kernels A(u) and B(u), is there some way to assign to one the role of the \"source\" in the fixed point scheme, i.e. if the equation is:\nA(u) - B(u) = 0\nCan one get MOOSE to solve:\nA(u^{k+1}) = B(u^{k})\n(with some other nonlinear solver)\nThis is mostly with the goal of implementing the algorithm at page 5 of https://doi.org/10.1016/j.anucene.2017.09.027, but also as a general question.\nThanks in advance for the help\nGabriele",
          "url": "https://github.com/idaholab/moose/discussions/27318",
          "updatedAt": "2024-04-26T07:50:10Z",
          "publishedAt": "2024-04-08T14:18:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can set up fixed point iterations using the MultiApp system.\nhttps://mooseframework.inl.gov/syntax/MultiApps/index.html\nThere is a tutorial here\nhttps://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial02_multiapps/presentation/index.html#/\nYou set up two inputs for both equations and use the fixed point parameters in the Executioner of the main app\nIn the near future we will be able to set up fixed point iterations using multi-system. There is a test executioner that can be modified to do this for steady-state solves if you feel confident with coding\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27318#discussioncomment-9047204",
                  "updatedAt": "2024-04-08T14:33:28Z",
                  "publishedAt": "2024-04-08T14:33:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "peacock can not be started after upgrading moose",
          "author": {
            "login": "zhx999"
          },
          "bodyText": "Bug Description\nHi there,\nI have installed the latest version of moose and pulled the code from github. However, when I try to start peacock in terminal, it shows the following error:\nError starting peacock: Could not import matplotlib\nYou may need to either create or load an environment providing PyQt, VTK, etc.\nThe MOOSE development team provides a conda package with the required dependencies:\nmamba create -n peacock moose-peacock python=3.10\nmamba activate peacock\n\nThen run peacock again\nSteps to Reproduce\nRun command \"peacock\" in terminal\nImpact\nThe postprocessor doesn't work\n[Optional] Diagnostics\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/27317",
          "updatedAt": "2024-06-16T21:42:29Z",
          "publishedAt": "2024-04-06T16:46:08Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "I am afraid this is not going to be something we can change in our code that will fix this issue. Peacock not launching is always going to be some library missing on the failing machine, which needs to be installed. Be it by apt install or dnf install etc:\napt install libmesa opengl or other graphical missing libraries\ndnf install libmesa opengl or other graphical missing libraries\nIssues are further complicated if you are running Windows WSL. Firewall settings, etc.\nThe problem is getting accelerated graphical capabilities going in these operating systems being a finicky process.\nI will convert this to a discussion, as there is nothing we can change in the moose repository that will effect your situation in a positive way.",
                  "url": "https://github.com/idaholab/moose/discussions/27317#discussioncomment-9045882",
                  "updatedAt": "2024-04-08T12:57:54Z",
                  "publishedAt": "2024-04-08T12:57:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "As a troubleshooting step, and a possible solution to reading MOOSE generated output files, lets try to install Paraview. Which using many of the same dependencies as Peacock, but may produce more useful errors!\nconda deactivate\nconda activate base\nconda create -n paraview paraview\nconda activate paraview\nparaview\nIt may take over a minute to get some sort of response...",
                  "url": "https://github.com/idaholab/moose/discussions/27317#discussioncomment-9045925",
                  "updatedAt": "2024-04-08T13:01:39Z",
                  "publishedAt": "2024-04-08T13:01:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Von Mises as variable",
          "author": {
            "login": "sidharthsarmah"
          },
          "bodyText": "Hi @GiudGiud , I need to find the ratio of hydrostatic stress to Von Mises Stress at the nodes.\nFor the hydrostatic stress declared as variables, I used the following:\n[Variables]\n  [./sH]\n  [../]\n[]\n\n[Kernels]\n  [./ph_stress]\n    type = ADMaterialPropertyValue\n    prop_name = 'hydrostatic_stress'\n    variable = 'sH'\n  [../]\n[]\n\n[Materials]\n  [./hydrostatic_prop]\n    type = ADRankTwoInvariant\n    rank_two_tensor = stress\n    property_name = hydrostatic_stress\n    invariant = Hydrostatic\n  [../]\n\nDo you suggest I can similarly find the VM stress as variables?\n[Variables]\n  [./VM]\n  [../]\n[]\n\n[Kernels]\n  [./ph_stress]\n    type = ADMaterialPropertyValue\n    prop_name = 'vonmises'\n    variable = 'VM'\n  [../]\n\n  [./hydrostatic_prop]\n    type = ADRankTwoInvariant\n    rank_two_tensor = stress\n    property_name = vonmises\n    invariant = VonMisesStress\n  [../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/27300",
          "updatedAt": "2024-04-07T18:31:46Z",
          "publishedAt": "2024-04-06T22:19:58Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Rahim-Habibi"
                  },
                  "bodyText": "Hi,\nHydrostatic and Von mises stresses are defined as Auxkernel, you can call the proper aux to have them, here (https://mooseframework.inl.gov/source/auxkernels/RankTwoScalarAux.html).\nThen, to have the ratio of them, you can define a axuvariable/auxkenel to do the division.",
                  "url": "https://github.com/idaholab/moose/discussions/27300#discussioncomment-9035902",
                  "updatedAt": "2024-04-07T13:26:13Z",
                  "publishedAt": "2024-04-07T13:26:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you store both stresses as auxiliary variables (for example with the ADMaterialPropertyValue), then\nYou can use a ParsedAux to perform the division between two auxiliary variables.",
                          "url": "https://github.com/idaholab/moose/discussions/27300#discussioncomment-9037687",
                          "updatedAt": "2024-04-07T18:31:46Z",
                          "publishedAt": "2024-04-07T18:31:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error Threshold",
          "author": {
            "login": "ashishdhole"
          },
          "bodyText": "Hello,\nI am trying to model grain growth with particles. In my simulation that the grain are supposed to stop at one location and time continues. But what I see is the time step keeps reducing. I want to know if we can put a threshold on our error value calculated by kernels so that if it is below certain value, that state is considered a solution?\nThank you\nAshish",
          "url": "https://github.com/idaholab/moose/discussions/27296",
          "updatedAt": "2024-04-07T17:24:56Z",
          "publishedAt": "2024-04-06T11:25:05Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf the time step keeps reducing this is likely indicating convergence issues.\nif you are satisfied with the solution regardless, the convergence criteria parameters, and the steady state detection parameters are specified in the Executioner block\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27296#discussioncomment-9029180",
                  "updatedAt": "2024-04-06T12:02:34Z",
                  "publishedAt": "2024-04-06T12:02:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Thank you Guillaume. Does the steady state detection parameters apply to each QP? Because what I could see is some points shows easy convergence and some do not. Basically, some grain boundaries should move faster and some don't. But because the slow moving boundaries are not showing good convergence it affects other boundaries as well. I wonder if we can apply these condition to each QP so if the error is below certain value, it converges.",
                          "url": "https://github.com/idaholab/moose/discussions/27296#discussioncomment-9032080",
                          "updatedAt": "2024-04-06T22:18:44Z",
                          "publishedAt": "2024-04-06T22:18:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nthe convergence criteria is based on a norm of the residual vector.\nYou ll have to check the documentation for the nonlinear solve in petsc for more details as I don\u2019t recall which norm we use.\nIt will not be a Qp-based criterion, it s integrated over elements and then there s a global reduction to get the norm.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/27296#discussioncomment-9037344",
                          "updatedAt": "2024-04-07T17:24:57Z",
                          "publishedAt": "2024-04-07T17:24:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Modify non-linear variable at every timestep",
          "author": {
            "login": "rayaprolu143"
          },
          "bodyText": "Hello MOOSE users,\nI want to modify a nonlinear variable at every timestep, such as the chemical potential of a vacancy inside the void. So far, I have tried using the multi apps for this end. Although I successfully achieved the objective, there was a 3 to 4 order reduction in the time step to achieve the convergence. I would like to know if there is any other better way to modify the nonlinear variable at every timestep.\nThank you,\nSreekar",
          "url": "https://github.com/idaholab/moose/discussions/27291",
          "updatedAt": "2024-04-16T04:35:36Z",
          "publishedAt": "2024-04-05T04:29:41Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nare you performing fixed point iterations between the main app and the children applications?\nif you only perform a single step of coupling, the time integration scheme is effectively explicit in one (or more) variable, hence it can require smaller time steps\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27291#discussioncomment-9025541",
                  "updatedAt": "2024-04-07T17:19:43Z",
                  "publishedAt": "2024-04-05T19:39:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "And otherwise you can modify non linear variables inside user objects. They are not too difficult to create for that purpose.\nbut I would expect exactly the same results as a multiapp",
                          "url": "https://github.com/idaholab/moose/discussions/27291#discussioncomment-9037312",
                          "updatedAt": "2024-04-07T17:20:47Z",
                          "publishedAt": "2024-04-07T17:20:47Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Transform_Func Error for Plane Stress Study",
          "author": {
            "login": "racheljhur"
          },
          "bodyText": "Hi everyone,\nI am performing a plane stress simulation with periodic boundary conditions (for an SVE) and an applied uniaxial load equivalent to 1 MPa. Before I add more complex microstructure geometry, I am trying to get a simple baseline code to work on a 2x2 square. I followed the example on MooseDocs for weak_plane_stress, but adding PBCs and an applied traction as a BC is prompting this error:\n*** ERROR ***\nThe parameter \"transform_func\" is being retrieved before being set.\nThis is my script for reference:\n[GlobalParams]\ndisplacements = 'disp_x disp_y'\nout_of_plane_strain = strain_zz\n[]\n[Mesh]\n[./square]\ntype = GeneratedMeshGenerator\ndim = 2\nnx = 2\nny = 2\n[../]\n[]\n[Variables]\n[./disp_x]\n[../]\n[./disp_y]\n[../]\n[./strain_zz]\norder = FIRST\nfamily = SCALAR\n[../]\n[]\n[AuxVariables]\n[./nl_strain_zz]\norder = CONSTANT\nfamily = MONOMIAL\n[../]\n[]\n[Postprocessors]\n[./react_z]\ntype = MaterialTensorIntegral\nrank_two_tensor = stress\nindex_i = 2\nindex_j = 2\n[../]\n[./min_strain_zz]\ntype = NodalExtremeValue\nvariable = strain_zz\nvalue_type = min\n[../]\n[./max_strain_zz]\ntype = NodalExtremeValue\nvariable = strain_zz\nvalue_type = max\n[../]\n[]\n[Physics/SolidMechanics/QuasiStatic]\n[plane_stress]\nplanar_formulation = WEAK_PLANE_STRESS\nstrain = FINITE\ngenerate_output = 'stress_xx stress_xy stress_yy stress_zz strain_xx strain_xy strain_yy'\n[]\n[]\n[AuxKernels]\n[./strain_zz]\ntype = RankTwoAux\nrank_two_tensor = total_strain\nvariable = nl_strain_zz\nindex_i = 2\nindex_j = 2\n[../]\n[]\n[BCs]\n[Periodic]\n[x]\nvariable = disp_x\nprimary = 'right'\nsecondary = 'left'\ntranslation = '-2 0 0'\n[]\n[y]\nvariable = disp_y\nprimary = 'top'\nsecondary = 'bottom'\ntranslation = '0 -2 0'\n[]\n[uniaxial_traction_x]\ntype = NeumannBC\nvariable = disp_x\nboundary = right\nvalue = 1e6\n[]\n# constrain rigid body motion\n[fix_all_x]\ntype = DirichletBC\nboundary = 'right'\nvariable = disp_x\nvalue = 0\n[]\n[fix_all_y]\ntype = DirichletBC\nboundary = 'bottom'\nvariable = disp_y\nvalue = 0\n[]\n[]\n[]\n[Materials]\n[./elastic_tensor]\ntype = ComputeIsotropicElasticityTensor\nyoungs_modulus = 1e9\npoissons_ratio = 0.3\n[../]\n[./stress]\ntype = ComputeFiniteStrainElasticStress\n[../]\n[]\n[Executioner]\ntype = Steady\npetsc_options_iname = '-pc_type'\npetsc_options_value = 'lu'\n[]\n[Outputs]\nexodus = true\n[]\nAny help would be much appreciated. Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/27293",
          "updatedAt": "2024-04-07T01:36:32Z",
          "publishedAt": "2024-04-05T14:39:57Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nseems you need to set this transform_func parameter to the object that is returning this error\nThis error indicates the parameters have not been created properly in that object. We\u2019ll have to take a look if this is an object in moose\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27293#discussioncomment-9024241",
                  "updatedAt": "2024-04-05T17:14:52Z",
                  "publishedAt": "2024-04-05T17:14:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "racheljhur"
                          },
                          "bodyText": "I actually ended up using lagrangian kernels to homogenize as I was working with an SVE. I also canceled out appropriate terms to make it plane stress. Thank you for the response.",
                          "url": "https://github.com/idaholab/moose/discussions/27293#discussioncomment-9032696",
                          "updatedAt": "2024-04-07T01:36:33Z",
                          "publishedAt": "2024-04-07T01:36:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Sharp grain boundary visualization",
          "author": {
            "login": "ashishdhole"
          },
          "bodyText": "Hello All,\nIs there a way to make grain boundaries as sharp lines? 'BndsCalcAux' captures data 1/4 offset on either side of the actual grain boundary (where op=0.5). There there a way or option I can choose to make it look sharp in paraview?\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/27174",
          "updatedAt": "2024-04-06T09:52:05Z",
          "publishedAt": "2024-03-21T22:47:47Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "I am exactly sure about your purpose. If you just want plots look nicer, you can probably draw a 0.5 contour from all the grain order parameters.",
                  "url": "https://github.com/idaholab/moose/discussions/27174#discussioncomment-8951857",
                  "updatedAt": "2024-03-29T13:41:09Z",
                  "publishedAt": "2024-03-29T13:41:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Thank you very much. That worked like a charm.",
                  "url": "https://github.com/idaholab/moose/discussions/27174#discussioncomment-9028677",
                  "updatedAt": "2024-04-06T09:52:02Z",
                  "publishedAt": "2024-04-06T09:52:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}