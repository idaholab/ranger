{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNS0xN1QxMzo0NTozMS0wNjowMM4APjmx"
    },
    "edges": [
      {
        "node": {
          "title": "Why need both BC Pressure and Dirichlet in pore pressure in Porous Flow Tutorial 4",
          "author": {
            "login": "alexguev"
          },
          "bodyText": "Hello,\nAs I'm interested in injecting a fluid into a domain from a boundary, similarly in that regard to the tutorial 4 of the Porous Flow module, I was wondering why there were both the following BC:\n  [constant_injection_porepressure]\n    type = DirichletBC\n    variable = porepressure\n    value = 1E6\n    boundary = injection_area\n  []\n\nand\n  [cavity_pressure_x]\n    type = Pressure\n    boundary = injection_area\n    variable = disp_x\n    component = 0\n    factor = 1E6\n    use_displaced_mesh = false\n  []\n  [cavity_pressure_y]\n    type = Pressure\n    boundary = injection_area\n    variable = disp_y\n    component = 1\n    factor = 1E6\n    use_displaced_mesh = false\n  []\n\nFrom playing with both BC, I can see why they are both useful - I'd struggle to get the inner boundary (where the injection is applied) to expand without the Pressure BC. How to justify though, from a more theoretical point of view, that we need the Pressure BC on top of the Dirichlet BC?\nI understand at first sight that for the Dirichlet BC, the injection pressure affects the solid through the momentum balance, whereas for the Pressure BC, the pressure is a traction, so only affecting the stress times the normal to the boundary. But on paper, in 1D for instance, it seems to (almost) has the same effect, unless mistaken.\nI feel @WilkAndy might know :)\nCheers",
          "url": "https://github.com/idaholab/moose/discussions/20977",
          "updatedAt": "2022-06-28T02:29:48Z",
          "publishedAt": "2022-05-06T20:54:10Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@WilkAndy do you know?",
                  "url": "https://github.com/idaholab/moose/discussions/20977#discussioncomment-2755387",
                  "updatedAt": "2022-06-28T02:29:51Z",
                  "publishedAt": "2022-05-15T20:57:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I feel like you know the answer @alexguev , but you don't know that you know!  You can write out the equations and find the answer, but here's my wordy explanation....\nThe DirichletBC is needed because the borehole is at 1MPa pressure.  That fluid is also \"pushing\" on the rock skeleton: the fluid is mechanically loading the rock.  Eg, imagine a totally non-porous rock: it's pretty clear the borehole pressure will \"push\" on the rock.  Mathematically this means the porepressure is acting as an applied total stress (not effective stress) at the borehole boundary.   There is some discussion in the \"Barometric and oceanic loading\" section of https://mooseframework.inl.gov/modules/porous_flow/tidal.html .   All stresses in PorousFlow are effective stresses (eg, for the constitutive relations, and the output you see in exodus files) except for any Neumann boundary conditions, which are written in terms of total stresses - see discussion around Eqn(12) of https://mooseframework.inl.gov/modules/porous_flow/governing_equations.html .  Hence, we need two Pressure BCs for the total stress (the two mean the applied pressure is acting in the normal direction).",
                  "url": "https://github.com/idaholab/moose/discussions/20977#discussioncomment-2755772",
                  "updatedAt": "2022-06-28T02:30:21Z",
                  "publishedAt": "2022-05-15T23:05:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alexguev"
                          },
                          "bodyText": "Makes perfect sense, thanks @WilkAndy! I mistakenly thought the Pressure BC was acting on the effective stress.",
                          "url": "https://github.com/idaholab/moose/discussions/20977#discussioncomment-2767982",
                          "updatedAt": "2022-06-28T02:30:24Z",
                          "publishedAt": "2022-05-17T14:00:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alexguev"
                          },
                          "bodyText": "Follow-up question if I may @WilkAndy : how should I proceed to impose constant flow rate instead of constant pressure? Instead of DirichletBC for the pore pressure I would use NeumannBC, but what about the Pressure BC for the total stress?",
                          "url": "https://github.com/idaholab/moose/discussions/20977#discussioncomment-2785097",
                          "updatedAt": "2022-05-19T16:48:33Z",
                          "publishedAt": "2022-05-19T16:48:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "OK, that is more complicated, but still quite possible.  Have a look at https://mooseframework.inl.gov/modules/porous_flow/thm_example.html .  This isn't exactly your problem, so don't copy it exactly (it uses specific and rather hypothetical assumptions in order to compare with a case that has an analytical solution) but it explains the use of a postprocessor to record fluid pressure, and then apply that to the total stress.  If you understand the opaque comment note, this lags in the input file, you'll have understood everything!",
                          "url": "https://github.com/idaholab/moose/discussions/20977#discussioncomment-2786971",
                          "updatedAt": "2022-05-19T22:25:55Z",
                          "publishedAt": "2022-05-19T22:25:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alexguev"
                          },
                          "bodyText": "That works, thanks, provided one is careful to have timesteps small enough. I guess a potential issue might be when the pressure at the injection boundary is not homogeneous, like when the porosity is prescribed through a spatial field for instance; but then, there might exist some way to assign the pressure at each node - that will be for another day (unless there is an easy solution).",
                          "url": "https://github.com/idaholab/moose/discussions/20977#discussioncomment-2794341",
                          "updatedAt": "2022-05-21T14:08:13Z",
                          "publishedAt": "2022-05-21T00:50:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about different BC",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nI met a problem about the 'solve did not converge'.\nThe problem is, for the same system, when I use periodic BC, it can successfully run, however, when I use default BC, which is the zero flux BC, then it cannot converge, Why is this? Could anyone please give me some advice? How to make the input file with zero flux BC to successfully run?\nI put the two input files with different BC as below:\nThank you very much.\nThis is the zero flux BC condition input file, the solve cannot converge:\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 360\n  xmax = 6\n  uniform_refine = 4\n[]\n\n[Variables]\n  [./c]\n  [../]\n  [./w]\n  [../]\n[]\n# aux varaibles to track the free energy change (must decrease with time)\n[AuxVariables]\n  [./total_F]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  # the chemical potential gradients\n[]\n\n[ICs]\n  [./IC_c]\n    x1=0\n    y1=0\n    x2=2\n    y2=0\n    inside = 1\n    outside = 0 # Matrix is supersaturated with solute atoms\n    variable = c\n    type = BoundingBoxIC\n  [../]\n[]\n\n\n# [BCs]\n#   [./Periodic]\n#     [./cx]\n#       variable = c\n#       auto_direction = 'x'\n#     [../]\n#     [./wx]\n#       variable = w\n#       auto_direction = 'x'\n#     [../]\n#   [../]\n#\n# []\n\n\n\n[Kernels]\n  # Split form of Cahn-Hilliard equation with eta as coupled variable\n  # w is the chemical potential\n  [./c_dot]\n    type = CoupledTimeDerivative\n    variable = w\n    v = c\n  [../]\n  [./c_res]\n    type = SplitCHParsed\n    variable = c\n    f_name = F\n    kappa_name = kappa_c\n    w = w\n  [../]\n\n  [./w_res]\n    type = SplitCHWRes\n    args = 'c'\n    variable = w\n    mob_name = M\n  [../]\n\n[]\n\n[AuxKernels]\n  [./total_F]\n    type = TotalFreeEnergy\n    variable = total_F\n    interfacial_vars = c\n    kappa_names = kappa_c\n  [../]\n[]\n\n\n\n\n[Materials]\n\n  [./mobility]\n    type = DerivativeParsedMaterial\n    f_name = M\n    args = 'c'\n    function = 0.2+0.8*(1-c^2)^2\n    derivative_order = 1\n  [../]\n\n  [./kappa_c]\n    type = GenericConstantMaterial\n    prop_names  = 'kappa_c'\n    prop_values = '8.0e-4'\n  [../]\n\n  [./free_energy]\n    # equivalent to `MathFreeEnergy`\n    type = DerivativeParsedMaterial\n    f_name = F\n    args = 'c'\n    function = 1.5423*c^2*(0.807-3.4035*c^2+2*c^4)+0.92\n  [../]\n\n\n\n[]\n\n\n\n[Postprocessors]\n\n  [./ElementInt_c]\n    type = ElementIntegralVariablePostprocessor\n    variable = c\n  [../]\n\n  [./total_F]\n    type = ElementIntegralVariablePostprocessor\n    variable = total_F\n  [../]\n[]\n\n[VectorPostprocessors]\n # The numerical values of the variables/auxvariables across the centerline\n [./line_values]\n   type =  LineValueSampler\n   start_point = '0 0 0'\n   end_point = '6 0 0'\n   variable = 'c'\n   num_points = 361\n   sort_by = x\n   #execute_on = 'FINAL'\n [../]\n[]\n\n\n ##[VectorPostprocessors]\n  # The numerical values of the variables/auxvariables across the centerline\n  ##[./line_values]\n   ##type =  LineValueSampler\n    ##start_point = '0'\n    #end_point = '9'\n    #variable = 'c w j_tot'\n    #num_points = 199\n    #sort_by =  id\n    #execute_on = 'TIMESTEP_END'\n  #[../]\n#[]\n[Preconditioning]\n  [./SMP] # to produce the complete perfect Jacobian\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n\n  type = Transient\n  scheme = 'BDF2'\n  #petsc_options = '-snes_mf'\n\n  #Preconditioned JFNK (default)\n  solve_type = 'NEWTON'\n\n  petsc_options_iname = '-pc_type -ksp_grmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'asm      31                  preonly       lu           1'\n  #petsc_options_iname = '-pc_type'\n  #petsc_options_value = 'lu'\n\n  l_max_its = 30 # maximum linear iterations\n  l_tol = 1.0e-6 # 0.001 Linear Tolerance\n\n  nl_max_its = 50 # maximum number of nonlinear iterations. exceed will cut dt.\n  nl_rel_tol = 1.0e-9 # -8 nonlinear relative tolerance\n  #num_steps = 2\n\n\n\n\n\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1e-6\n    cutback_factor = 0.67\n    growth_factor = 1.5   # 1.6\n    optimal_iterations = 10\n    iteration_window = 2\n\n  [../]\n  [./Adaptivity]\n    coarsen_fraction = 0.1\n    refine_fraction = 0.7\n    max_h_level = 3\n    interval = 1\n\n  [../]\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  interval = 1\n\n[]\n\nThis is the input file using periodic BC case, the simulation can run successfully.\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 360\n  xmax = 6\n  uniform_refine = 4\n[]\n\n[Variables]\n  [./c]\n  [../]\n  [./w]\n  [../]\n[]\n# aux varaibles to track the free energy change (must decrease with time)\n[AuxVariables]\n  [./total_F]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  # the chemical potential gradients\n[]\n\n[ICs]\n  [./IC_c]\n    x1=0\n    y1=0\n    x2=3\n    y2=0\n    inside = 1\n    outside = 0 # Matrix is supersaturated with solute atoms\n    variable = c\n    type = BoundingBoxIC\n  [../]\n[]\n\n\n[BCs]\n  [./Periodic]\n    [./cx]\n      variable = c\n      auto_direction = 'x'\n    [../]\n    [./wx]\n      variable = w\n      auto_direction = 'x'\n    [../]\n  [../]\n\n[]\n\n\n\n[Kernels]\n  # Split form of Cahn-Hilliard equation with eta as coupled variable\n  # w is the chemical potential\n  [./c_dot]\n    type = CoupledTimeDerivative\n    variable = w\n    v = c\n  [../]\n  [./c_res]\n    type = SplitCHParsed\n    variable = c\n    f_name = F\n    kappa_name = kappa_c\n    w = w\n  [../]\n\n  [./w_res]\n    type = SplitCHWRes\n    args = 'c'\n    variable = w\n    mob_name = M\n  [../]\n\n[]\n\n[AuxKernels]\n  [./total_F]\n    type = TotalFreeEnergy\n    variable = total_F\n    interfacial_vars = c\n    kappa_names = kappa_c\n  [../]\n[]\n\n\n\n\n[Materials]\n\n  [./mobility]\n    type = DerivativeParsedMaterial\n    f_name = M\n    args = 'c'\n    function = 0.2+0.8*(1-c^2)^2\n    derivative_order = 1\n  [../]\n\n  [./kappa_c]\n    type = GenericConstantMaterial\n    prop_names  = 'kappa_c'\n    prop_values = '8.0e-4'\n  [../]\n\n  [./free_energy]\n    # equivalent to `MathFreeEnergy`\n    type = DerivativeParsedMaterial\n    f_name = F\n    args = 'c'\n    function = 1.5423*c^2*(0.807-3.4035*c^2+2*c^4)+0.92\n  [../]\n\n\n\n[]\n\n\n\n[Postprocessors]\n\n  [./ElementInt_c]\n    type = ElementIntegralVariablePostprocessor\n    variable = c\n  [../]\n\n  [./total_F]\n    type = ElementIntegralVariablePostprocessor\n    variable = total_F\n  [../]\n[]\n\n[VectorPostprocessors]\n # The numerical values of the variables/auxvariables across the centerline\n [./line_values]\n   type =  LineValueSampler\n   start_point = '0 0 0'\n   end_point = '6 0 0'\n   variable = 'c'\n   num_points = 361\n   sort_by = x\n   #execute_on = 'FINAL'\n [../]\n[]\n\n\n ##[VectorPostprocessors]\n  # The numerical values of the variables/auxvariables across the centerline\n  ##[./line_values]\n   ##type =  LineValueSampler\n    ##start_point = '0'\n    #end_point = '9'\n    #variable = 'c w j_tot'\n    #num_points = 199\n    #sort_by =  id\n    #execute_on = 'TIMESTEP_END'\n  #[../]\n#[]\n[Preconditioning]\n  [./SMP] # to produce the complete perfect Jacobian\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n\n  type = Transient\n  scheme = 'BDF2'\n  #petsc_options = '-snes_mf'\n\n  #Preconditioned JFNK (default)\n  solve_type = 'NEWTON'\n\n  petsc_options_iname = '-pc_type -ksp_grmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'asm      31                  preonly       lu           1'\n  #petsc_options_iname = '-pc_type'\n  #petsc_options_value = 'lu'\n\n  l_max_its = 30 # maximum linear iterations\n  l_tol = 1.0e-6 # 0.001 Linear Tolerance\n\n  nl_max_its = 50 # maximum number of nonlinear iterations. exceed will cut dt.\n  nl_rel_tol = 1.0e-9 # -8 nonlinear relative tolerance\n  #num_steps = 2\n\n\n\n\n\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1e-6\n    cutback_factor = 0.67\n    growth_factor = 1.5   # 1.6\n    optimal_iterations = 10\n    iteration_window = 2\n\n  [../]\n  [./Adaptivity]\n    coarsen_fraction = 0.1\n    refine_fraction = 0.7\n    max_h_level = 3\n    interval = 1\n\n\n  [../]\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  interval = 1\n\n[]",
          "url": "https://github.com/idaholab/moose/discussions/20923",
          "updatedAt": "2022-06-22T07:33:07Z",
          "publishedAt": "2022-04-30T05:01:10Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs it the linear solve or the nonlinear solve that cannot converge?\nWhat does the log look like?\nThere's a few things you can do to troubleshoot convergence issues.\nFirst, let's try to see if the system is singular, in case it's underdetermined with only flux BCs. For this, reduce the size of the problem to 1000dofs and use these petsc options -pc_type svd -pc_svd_monitor.\nMore info there:\nhttps://mooseframework.inl.gov/releases/moose/v1.0.0/application_usage/failed_solves.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20923#discussioncomment-2674399",
                  "updatedAt": "2022-06-28T11:44:17Z",
                  "publishedAt": "2022-05-02T15:10:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@abc-hy any update on this?",
                          "url": "https://github.com/idaholab/moose/discussions/20923#discussioncomment-2755396",
                          "updatedAt": "2022-06-28T11:44:18Z",
                          "publishedAt": "2022-05-15T21:00:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "Hi,\nI have made it run.\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/20923#discussioncomment-2793282",
                          "updatedAt": "2022-05-20T18:58:39Z",
                          "publishedAt": "2022-05-20T18:58:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Isogeometric Analysis in MOOSE",
          "author": {
            "login": "NorbertHofbauer"
          },
          "bodyText": "Hello,\nwhere can i find the c-frame.step file for the IGA example?\nhttps://mooseframework.inl.gov/modules/tensor_mechanics/examples/cframe_iga.html\nbest,\nnorbert",
          "url": "https://github.com/idaholab/moose/discussions/21054",
          "updatedAt": "2022-05-20T14:49:21Z",
          "publishedAt": "2022-05-19T07:36:15Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt's there\n/modules/tensor_mechanics/examples/cframe_iga/c-frame.step\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21054#discussioncomment-2786079",
                  "updatedAt": "2022-05-19T19:30:05Z",
                  "publishedAt": "2022-05-19T19:30:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "NorbertHofbauer"
                          },
                          "bodyText": "Thanks!\ni hadn't looked into the local files. i thought i could find the file somewhere in the online documentation.\nwish you a nice weekend!",
                          "url": "https://github.com/idaholab/moose/discussions/21054#discussioncomment-2790061",
                          "updatedAt": "2022-05-20T10:42:06Z",
                          "publishedAt": "2022-05-20T10:42:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Nemesis crashes (osx?)",
          "author": {
            "login": "veeshy"
          },
          "bodyText": "Bug Description\nUsing nemesis output causes some error where moose crashes. If the execute_on is only once at the end, this doesn't seem to cause the output to be wrong, but you still get an error message that doesn't seem to kill moose so tests pass (I'm speculating..). If you try to execute any nemesis test on initial it won't run.\nSteps to Reproduce\nin the moose tests folder:\n./moose_test-opt -I ./tests/outputs/nemesis/nemesis_elemental.i Outputs/execute_on=initial\n\ngives me\nzsh: illegal hardware instruction  ./moose_test-opt -i  Outputs/execute_on=initial\n\nNot setting the initial gives me the same as above but moose does run and the test associated does pass.\nTrying to run with mpiexec -n 4 causes an actual bad termination.\nMy moose:\nFramework Information:\nMOOSE Version:           git commit 668cd38e2e on 2020-07-07\nLibMesh Version:         6e07d0a45166892bdbeef78440bad7aa46e2a5b7\nPETSc Version:           3.12.5\nSLEPc Version:           3.12.1\n\nI'm on OS X 10.15.5 (19F101) using the standard conda moose. I haven't tried to replicate in ubuntu.\nImpact\nI can't run distributed mesh with a parallel output.",
          "url": "https://github.com/idaholab/moose/discussions/20844",
          "updatedAt": "2023-03-14T11:28:07Z",
          "publishedAt": "2020-07-28T16:09:42Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@veeshy is this fixed? or did you update the mac and now it s gone?",
                  "url": "https://github.com/idaholab/moose/discussions/20844#discussioncomment-2612050",
                  "updatedAt": "2023-04-10T20:43:05Z",
                  "publishedAt": "2022-04-21T23:19:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "veeshy"
                          },
                          "bodyText": "Do not have the specific versions listed here, happy to check next week though on a newer mac.",
                          "url": "https://github.com/idaholab/moose/discussions/20844#discussioncomment-2612342",
                          "updatedAt": "2023-04-10T20:43:05Z",
                          "publishedAt": "2022-04-22T00:59:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "veeshy"
                          },
                          "bodyText": "this is fixed (sorry for the delay)\nosx 12.3, latest moose",
                          "url": "https://github.com/idaholab/moose/discussions/20844#discussioncomment-2786263",
                          "updatedAt": "2022-05-19T19:58:34Z",
                          "publishedAt": "2022-05-19T19:58:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "great thank you for checking!",
                          "url": "https://github.com/idaholab/moose/discussions/20844#discussioncomment-2786301",
                          "updatedAt": "2022-05-19T20:04:15Z",
                          "publishedAt": "2022-05-19T20:04:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "installation error",
          "author": {
            "login": "leoving"
          },
          "bodyText": "after installing the conda, and type ./run_tests -j 4\nthere occured the error as following:\nRan 1807 tests in 967.7 seconds. Average test time 0.4 seconds, maximum test time 8.5 seconds.\n1757 passed, 85 skipped, 0 pending, 50 FAILED\nMAX FAILURES REACHED\nrunWorker Exception: Traceback (most recent call last):\n  File \"/home/dell/projects/moose-next/python/TestHarness/schedulers/Scheduler.py\", line 438, in runJob\n    self.queueJobs(jobs, j_lock)\n  File \"/home/dell/projects/moose-next/python/TestHarness/schedulers/Scheduler.py\", line 260, in queueJobs\n    self.run_pool.apply_async(self.runJob, (job, jobs, j_lock))\n  File \"/home/dell/miniconda3/envs/moose/lib/python3.9/multiprocessing/pool.py\", line 455, in apply_async\n    self._check_running()\n  File \"/home/dell/miniconda3/envs/moose/lib/python3.9/multiprocessing/pool.py\", line 350, in _check_running\n    raise ValueError(\"Pool not running\")\nValueError: Pool not running\n\nHOW can I solved\n\n that?",
          "url": "https://github.com/idaholab/moose/discussions/21053",
          "updatedAt": "2022-06-09T01:38:10Z",
          "publishedAt": "2022-05-19T04:38:25Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat are the errors you are getting? Like for each failing test what is the error message? The summary does not give enough information.\nUsually such high test failure rates are an issue with MPI.\nGuillaume\nbtw: please do not paste screenshots. They are not searchable later on.\nPosting guidelines are here: #18270",
                  "url": "https://github.com/idaholab/moose/discussions/21053#discussioncomment-2786074",
                  "updatedAt": "2022-05-19T19:29:09Z",
                  "publishedAt": "2022-05-19T19:29:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Postprocessors for values at single named node?",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "I have an input mesh with some nodes I'd like to sample the solution at. The mesh contains separate nodesets for each of those nodes (each nodeset contains exactly one node).\nI thought I could do a boundary-restricted Postprocessor but construct_side_list_from_node_list doesn't seem to work for single-node nodesets. The MOOSE Postprocessors that operate at node take the node id, which I don't necessarily know. I'd like to use the nodeset name instead.\nAny ideas how to handle this? Could I make a new Postprocessor that accepts a nodeset name? Is there an example of that anywhere?",
          "url": "https://github.com/idaholab/moose/discussions/21047",
          "updatedAt": "2022-05-19T14:47:25Z",
          "publishedAt": "2022-05-18T16:36:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Can you try the point value sampler?",
                  "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2778050",
                  "updatedAt": "2022-05-18T17:49:16Z",
                  "publishedAt": "2022-05-18T17:49:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "That takes the coordinates of the point which, like the node id, I may not know. I want to use the name of the nodeset.",
                          "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2778271",
                          "updatedAt": "2022-05-18T18:22:46Z",
                          "publishedAt": "2022-05-18T18:22:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "To give you a bit more information, what I'm doing is generating arbitrary meshes with another program and reading them into MOOSE. The meshes are coming in with the nodes labelled (\"node1\", \"node2\", etc) where I'd like to evaluate the solution. The labels are actually on the single-node-containing nodesets.",
                          "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2778311",
                          "updatedAt": "2022-05-18T18:27:42Z",
                          "publishedAt": "2022-05-18T18:27:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh ok my bad. i think NodalValueSampler will work, with a boundary parameter that is the nodeset\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/NodalValueSampler.html",
                          "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2778978",
                          "updatedAt": "2022-05-18T20:16:49Z",
                          "publishedAt": "2022-05-18T20:16:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if it doesnt work we can try this one too\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/SideValueSampler.html\nbut side should be a sideset not a nodeset. Let's see",
                          "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2778985",
                          "updatedAt": "2022-05-18T20:18:02Z",
                          "publishedAt": "2022-05-18T20:18:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "OK, those work. Also AverageNodalVariableValue with boundary=<nodeset name> works. Guess I was confused between nodeset, sideset, and boundary. Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2784118",
                          "updatedAt": "2022-05-19T15:07:38Z",
                          "publishedAt": "2022-05-19T14:28:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Tensor mechanics hardening documents",
          "author": {
            "login": "dineshp1"
          },
          "bodyText": "Hi\nI am interested in the different hardening schemes implemented in the module. The module is not documented yet so could you please provide some reference documents for hardening schemes?\nThank you,\nRegards,\nDinesh P",
          "url": "https://github.com/idaholab/moose/discussions/21022",
          "updatedAt": "2022-06-10T13:15:25Z",
          "publishedAt": "2022-05-13T00:37:07Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe module is actually documented. Please see these pages for the base documentation:\nhttps://mooseframework.inl.gov/modules/tensor_mechanics/index.html\nAnd a few hardening related pages:\nhttps://mooseframework.inl.gov/source/materials/IsotropicPlasticityStressUpdate.html\nhttps://mooseframework.inl.gov/source/materials/IsotropicPowerLawHardeningStressUpdate.html\nWhat kind of hardening are you looking for?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21022#discussioncomment-2746531",
                  "updatedAt": "2022-06-10T13:15:39Z",
                  "publishedAt": "2022-05-13T15:45:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dineshp1"
                          },
                          "bodyText": "Thank you for the reply. I want to apply linear softening like this:\n\nI found some hardening class implementation(TensorMechanicsHardeningCutExponential) and I can create linear softening now. Although I have a question, what is the internal parameter here? is it strain or something else?\nTensorMechanicsHardeningCutExponential::TensorMechanicsHardeningCutExponential(\n    const InputParameters & parameters)\n  : TensorMechanicsHardeningModel(parameters),\n    _val_0(getParam<Real>(\"value_0\")),\n    _val_res(parameters.isParamValid(\"value_residual\") ? getParam<Real>(\"value_residual\") : _val_0),\n    _intnl_0(getParam<Real>(\"internal_0\")),\n    _rate(getParam<Real>(\"rate\"))\n{\n}\n\nReal\nTensorMechanicsHardeningCutExponential::value(Real intnl) const\n{\n  Real x = intnl - _intnl_0;\n  if (x <= 0)\n    return _val_0;\n  else\n    return _val_res + (_val_0 - _val_res) * std::exp(-_rate * x);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/21022#discussioncomment-2764248",
                          "updatedAt": "2022-06-10T13:15:48Z",
                          "publishedAt": "2022-05-17T03:07:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "The internal parameter depends on your plastic model.  In your case it will be \"Plastic shear strain\".  Your plastic model (eg, J2, Mohr-Coulomb, etc) must define what \"Plastic shear strain\" actually is.  If you search through the TensorMechanics test cases you'll find many examples of softening and hardening.  Depending on your model, you may find the piecewise linear function that you are proposing leads to convergence problems due to the non-differentiability (unless you use an explicit time-stepping).  I have attached some documentation - not sure whether it's really what you want\nMOOSE Framework - Hardening and Softening.pdf\nMOOSE Framework - Plasticity and the Return-Mapping Algorithm.pdf\nMOOSE Framework - Plasticity and the Consistent Tangent Operator.pdf",
                          "url": "https://github.com/idaholab/moose/discussions/21022#discussioncomment-2764321",
                          "updatedAt": "2022-06-10T13:16:48Z",
                          "publishedAt": "2022-05-17T03:28:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dineshp1"
                          },
                          "bodyText": "@WilkAndy Thank you so much for the reference docs and for explaining issues with the sharp corner in softening function.",
                          "url": "https://github.com/idaholab/moose/discussions/21022#discussioncomment-2780003",
                          "updatedAt": "2022-05-19T01:01:32Z",
                          "publishedAt": "2022-05-19T01:01:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Implementation of Body Force in Peridynamics Module for Dynamic Fracture Modelling",
          "author": {
            "login": "ppandit95"
          },
          "bodyText": "Dear MOOSE Community\nI wish to simulate Dynamic Fracture for which constant stress needs to be applied on top and bottom of the domain but I am not sure how to implement that in MOOSE so any header in this regard will be beneficial.\nMany Thanks\nPushkar",
          "url": "https://github.com/idaholab/moose/discussions/19974",
          "updatedAt": "2022-07-14T20:12:33Z",
          "publishedAt": "2022-01-07T04:22:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc on peridynamics",
                  "url": "https://github.com/idaholab/moose/discussions/19974#discussioncomment-2093521",
                  "updatedAt": "2022-07-14T20:12:53Z",
                  "publishedAt": "2022-02-02T05:22:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@ppandit95 how's the status on this?",
                          "url": "https://github.com/idaholab/moose/discussions/19974#discussioncomment-2754403",
                          "updatedAt": "2022-07-14T20:12:56Z",
                          "publishedAt": "2022-05-15T14:57:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ppandit95"
                          },
                          "bodyText": "@GiudGiud I wanted to work on this but haven't got enough opportunity to look into it due to certain priorities and still I am not certain how this can be done by adding body force although I have looked into Body Force kernel but I guess it does not work with peridynamics module regarding which I may be wrong and in such a case it will be really helpful to get some leads in this regard.\nThanks\nPushkar",
                          "url": "https://github.com/idaholab/moose/discussions/19974#discussioncomment-2772493",
                          "updatedAt": "2022-07-14T20:12:56Z",
                          "publishedAt": "2022-05-18T04:46:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nSo you want to apply load on the surfaces right? For this it wont be a body force kernel, most likely it will be a boundary condition.\nI would go through the tensor mechanics tutorial, I think we have something very similar there, possibly only one side for the application of the force.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/19974#discussioncomment-2777089",
                          "updatedAt": "2022-05-18T15:46:00Z",
                          "publishedAt": "2022-05-18T15:46:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Specific time steps' output",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Hello, I have a question about output.\nI set the syntax for output like below.\n[Outputs]\n  exodus = true\n  [csv]\n    type = CSV\n    file_base = outputs/cathode_test\n    append_date = true\n    append_date_format = '%Y-%m-%d-%R-%S'\n  []\n  [exodus1]\n    type = Exodus\n    file_base = outputs/cathode_test1\n    append_date = true\n    append_date_format = '%Y-%m-%d-%R-%S'\n    start_time = 0\n    interval = 100\n    execute_on = 'timestep_end'\n  []\n[]\n\nFor example, this simulation give me results from time = -1 to time = 491.\nWhat I want to do is \"output the results at specific time (time = 0, 100, 200, 300, 400, 491(last time step)).\nPlus, currently always all output result file was generated as well. This is too big, so I don't want this to be generated.\nHow can I get this specific output file without generating the file including all results.\nThank you.\nBest regards,\nHokon Kim",
          "url": "https://github.com/idaholab/moose/discussions/21043",
          "updatedAt": "2022-06-11T06:51:00Z",
          "publishedAt": "2022-05-17T16:19:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou should use the interval parameter of the output. And set it to 100\nThen you also want to execute on final to catch this 491 timestep\nsee these docs, there's an example in the Multiple Output Blocks paragraph or in Common parameters\nhttps://mooseframework.inl.gov/syntax/Outputs/index.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2770790",
                  "updatedAt": "2022-06-11T06:51:02Z",
                  "publishedAt": "2022-05-17T20:44:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "actually it seems you are already using this parameter.\nWhat are you seeing? THe interval is not respected?",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2770802",
                          "updatedAt": "2022-06-11T06:51:02Z",
                          "publishedAt": "2022-05-17T20:46:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "time = 99, 199, 299, 399\nOnly four time steps are stored in the result output(*.e).\nI thought I could get the results when time = 0, 100, 200, 300, 400, ...",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2770834",
                          "updatedAt": "2022-06-11T06:51:02Z",
                          "publishedAt": "2022-05-17T20:53:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you want to offset it by one you should move the start_time of the output.\nYeah adding on final might be tricky with the current capability. I hope execute_on = 'timestep_end final' will do it but I suspect the interval is obeyed first and foremost",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2770907",
                          "updatedAt": "2022-06-11T06:51:02Z",
                          "publishedAt": "2022-05-17T21:09:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "I still don't get it about Output options.\nOptions doesn't work as I wanted.\n[Outputs]\n  [csv]\n    type = CSV\n    file_base = outputs/cathode_test\n    append_date = true\n    append_date_format = '%Y-%m-%d-%R-%S'\n    execute_on = 'initial timestep_end'\n  []\n  [exo]\n    type = Exodus\n    file_base = outputs/cathode_test1\n    append_date = true\n    append_date_format = '%Y-%m-%d-%R-%S'\n    start_time = 0\n    interval = 5\n  []\n[]\n\nI expected that time = 0, 5, 10, ..., but the result really I got was \"time = 4, 9, 14\".\nI think the interval option did not work properly as I wanted.\nI thought \"start_time + interval\", but actually it didn't work like this.\n(e.g, start_time = 1, interval = 3, then 1, 4, 7, 10, ..., but it is not...)\nInterval just printed out the result at \"N\"th time step whatever start_time is...",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2771265",
                          "updatedAt": "2022-06-11T06:51:05Z",
                          "publishedAt": "2022-05-17T22:31:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Yeah, I think the interval param just outputs every n steps, not every n time units. Having output every n time units would be a welcome addition. In the past, I've had to use sync_times and provide a list of times, which can be tedious!",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2771901",
                          "updatedAt": "2022-06-11T06:51:07Z",
                          "publishedAt": "2022-05-18T01:40:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "I think sync_times is the proper way for my results file, currently.\nThanks for your reply!",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2772290",
                          "updatedAt": "2022-06-11T06:51:07Z",
                          "publishedAt": "2022-05-18T03:55:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Treatment of templated classes: Generic vs Explicit type specification",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Dear Moose experts,\nAs part of my recent developments on ArrayAuxKernels i am trying to write the list of AuxKernel values on to the auxvariables through the setNodalValue function. One common thing i observed while implementing this function is that the templated class functions are executed both for the case of explict specification of the desired type (RealEigenVector) and for the generic type (OutputType). As a result i could not confine my developments to a single function relevant to my type. The following example will make this case clear.\nCase 1:\ntemplate <>\nvoid\nMooseVariableData<RealEigenVector>::computeValues()\n{\n\ncase 2:\ntemplate <typename OutputType>\nvoid\nMooseVariableData<OutputType>::computeValues()\n{\n\nI expect any calls pertaining to ArrayAuxKernel would go to case 1 rather than case 2. Execution of both these cases can sometimes lead to overwrite of data set by each of these functions and is generally not advisable. My question is how to restrict calls to only case 1 where the type is specified explicity inside <>.",
          "url": "https://github.com/idaholab/moose/discussions/21033",
          "updatedAt": "2022-08-05T18:05:03Z",
          "publishedAt": "2022-05-16T17:54:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "Another related question is that the following code would not compile throwing the below error.\ntemplate <>\nvoid\nMooseVariableData<RealEigenVector>::setNodalValue(const RealEigenVector & value, unsigned int idx)\n{\n      _has_dof_values = true;\n      _nodal_value = value;\n      for (unsigned int i = 0; i < _u.size(); i++)\n       _u[i] = value(i);\n}\n\nError:\n/home/abalasub/Working/Projects/moose/framework/src/variables/MooseVariableData.C: In member function \u2018void MooseVariableData<OutputType>::setNodalValue(const OutputType&, unsigned int) [with OutputType = Eigen::Matrix<double, -1, 1>]\u2019:\n/home/abalasub/Working/Projects/moose/framework/src/variables/MooseVariableData.C:1620:26: error: no match for \u2018operator=\u2019 (operand types are \u2018Eigen::Matrix<double, -1, 1>\u2019 and \u2018const double\u2019)\n         _u[qp] = value(qp);\n\nThe variable _u is defined in MooseVariableData.h as follows\nFieldVariableValue _u;\nAs can be seen from the compile log the type of RHS variable is evalated wrongly and hence the error. I am sure the explicit declaration of the type of value will certainly resolve this to Eigen::Matrix<double, -1, 1>, but in this case it only sees a const double. The following is the prototype declation in MooseVariableData.h.\ntemplate <typename OutputType>\nclass MooseVariableData\n{\nvoid setNodalValue(const OutputType & value, unsigned int idx = 0);\n\nAny idea what's going on here?\nKind regards,\nArun",
                  "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2761929",
                  "updatedAt": "2022-08-05T18:06:49Z",
                  "publishedAt": "2022-05-16T18:17:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think you want to instantiate this template to RealVectorValue RealEigenVector\nSo OutputType becomes RealVectorValue RealEigenVector.\nSee GenericConstantMaterial for example.\nThe whole class is defined with the parameter is_ad, then it's instantiated to true and false.\nWe want to do the same here, but with OutputType being replaced by RealVectorValue RealEigenVector.\nWhat's going on with your error is that in\n_u[i] = value(i);\nthe quantites on both sides have different types.\nvalue(i) is a single value, because value is a vector\n_u is a tensor material property [i] I believe should be _qp (indexing at quadrature point then into a row/column (I have not checked) )\nPlease look at the documentation for Eigen::Matrix to determine the appropriate indexing into _u[_qp]\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2762162",
                  "updatedAt": "2022-06-09T01:32:21Z",
                  "publishedAt": "2022-05-16T18:54:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Hi Guillaume,\nI think RealVectorValue is the relevant type to be used for this class template. On the question of preferrential execution, i wanted to ask if the templated class is not instantiated for a particular type, but a function has been defined for this type, will that function be executed? Consider the folowing case.\ntemplate <>\nvoid\nMooseVariableData<RealEigenVector>::setNodalValue(const RealEigenVector & value, unsigned int idx)\n{\n\nAnd i comment out this line in the end:\n//template class MooseVariableData<RealEigenVector>;\nWhen i checked this, the function is still executed, which seems quiet weird, as only the explicitly instantiated classes will be called.\nKind regards,\nArun",
                          "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2769050",
                          "updatedAt": "2022-11-18T08:03:56Z",
                          "publishedAt": "2022-05-17T16:12:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "I am working towards replacing the RealEigenVector type with RealVectorValue in all of my array auxkernel developments. After doing this  migration, i encountered this weird error when it reaches the last line in the below code\nArrayRankTwoAux.C:46:9: error: \u2018libMesh::RealVectorValue {aka class libMesh::VectorValue<double>}\u2019 has no member named \u2018resize\u2019; did you mean \u2018rebind\u2019?\n   evalm.resize(teval*_nsubvar);\n\ntemplate <bool is_ad>\nRealVectorValue\nArrayRankTwoAuxTempl<is_ad>::computeValue()\n{\n  auto nqpts=this->_qrule->n_points();\n  RealVectorValue  evalm;\n  std::vector<std::pair<unsigned int, unsigned int>> tindices = {{0,0},{1,1},{2,2},{0,1},{0,2},{1,2}};\n  auto teval = nqpts*tindices.size();\n  evalm.resize(teval*_nsubvar);\n\nSomehow the compiler is interpreting this type wrongly and look for resize inside a class that is mapped to RealVectorValue. Any suggestions/leads here?\nKind regards,\nArun",
                  "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2769619",
                  "updatedAt": "2022-11-18T08:03:56Z",
                  "publishedAt": "2022-05-17T17:29:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@abarun22\nNo I was wrong, it's RealEigenVector you want not RealVectorValue. The latter is fixed 3 size",
                          "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2770461",
                          "updatedAt": "2022-11-18T08:03:57Z",
                          "publishedAt": "2022-05-17T19:44:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I was trying to make a point about the template instantiation, did not think I was mentioning the wrong type",
                          "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2770468",
                          "updatedAt": "2022-11-18T08:03:58Z",
                          "publishedAt": "2022-05-17T19:45:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}