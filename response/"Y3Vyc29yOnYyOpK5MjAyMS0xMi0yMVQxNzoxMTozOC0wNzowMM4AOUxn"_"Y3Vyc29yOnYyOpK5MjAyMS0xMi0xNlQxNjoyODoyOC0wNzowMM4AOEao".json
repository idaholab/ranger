{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMi0xNlQxNjoyODoyOC0wNzowMM4AOEao"
    },
    "edges": [
      {
        "node": {
          "title": "Memory Usage",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "Hello,\nSo I am running into memory problems when running a larger mesh code with a lot of variables (almost a 100 variable).\n\nDoes using LAGRANGE_VEC for field data instead of 3 LAGRANGE variables would be more efficient memory usage?\nI am using a userObject in one of the primary kernels that I am using and it has large matrices , this one is called in computeResidual, computeJacobian, and computeOffDiagJacobian functions. for a nodal variable, does this mean that a userObject is created for each node or each element?\nWhen using meshes of 1+million elements, it hogs all the memory, is there a way to reduce memory usage? I am already using --use-distributed-mesh\nI can see moose has a memory logger, but it doesnt have a detailed usage for the kernels or objects in the MooseApp I have built, is there a simple way to analyze this? I have tried memscape and most of the tracebacks were leading back to libmesh.\n\nThanks in advance!",
          "url": "https://github.com/idaholab/moose/discussions/19660",
          "updatedAt": "2022-06-21T16:42:33Z",
          "publishedAt": "2021-12-16T23:50:38Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nNot really any advantage in memory. There's some advantages in simulation time with cache efficiencies when using vector variables. No real difference in how much data has to be stored. @lindsayad might know better\nNo the user object is created once per process. It's not created for every node or element. It may be ran on every node or element, depending on the type of the user object.\nTo reduce your memory footprint, please have a look at this post:\n#19460\nI think you should work on the numerics / petsc options now to reduce the memory costs.\nYou can use\n\n[Debug]\n  show_actions = true\n[]\n\nto see more information about the memory cost of each object. Note that a kernel or a UO usually do not have a large cost. It's more the cost of storing variables or solving the numerical systems.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19660#discussioncomment-1842109",
                  "updatedAt": "2022-06-21T16:42:33Z",
                  "publishedAt": "2021-12-19T00:22:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We have a section on memory profiling here. Also MOOSE will not recognize the option --use-distributed-mesh. It's just --distributed-mesh. When MOOSE prints out its header at the beginning of a simulation you should be able to see whether you're replicated or distributed.\nI don't think there's much resource advantage between multiple LAGRANGE variables and a LAGRANGE_VEC variable. The advantage to me is cleaner code and a cleaner input file.",
                          "url": "https://github.com/idaholab/moose/discussions/19660#discussioncomment-1843901",
                          "updatedAt": "2022-06-21T16:42:41Z",
                          "publishedAt": "2021-12-19T18:53:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "Thank you for the replies and clarifications!\nI am already using -ilu flag for PETSc, it doesn't seem to be that different.\nI'm also using 2 multiapps, so it is probably a big factor in this since i'm transfer-copying a lot of variables.\nis there a way to operate on the same variables without creating copies of them?\nAlso, is there a way to disable restart and restore? if it saves some memory, this might be helpful to test larger problems. it seems to be the largest factor in show actions.",
                          "url": "https://github.com/idaholab/moose/discussions/19660#discussioncomment-1855157",
                          "updatedAt": "2022-06-21T16:42:43Z",
                          "publishedAt": "2021-12-21T21:49:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "did you see a change in memory usage between replicated and distributed? I don't know a whole lot about the memory tracking through the actions. I usually rely on the heap profiler to show me exactly what is consuming memory otherwise my guesses are often inaccurate. If you have a MWE, then I could run the profiler for you if you're not well setup to run it yourself",
                          "url": "https://github.com/idaholab/moose/discussions/19660#discussioncomment-1855253",
                          "updatedAt": "2022-06-21T16:42:43Z",
                          "publishedAt": "2021-12-21T22:15:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "invalid active developer path, missing xcrun",
          "author": {
            "login": "ASKapat"
          },
          "bodyText": "Hi,\nAfter updating my MacOS to 11.2.3 from 11.2 (before which I wasn't having this issue) I'm now getting the following error when I activate moose:\nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun",
          "url": "https://github.com/idaholab/moose/discussions/17482",
          "updatedAt": "2022-10-27T19:22:33Z",
          "publishedAt": "2021-04-01T19:58:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "First I would try re-installing CommandLineTools. In your Terminal, run:\nxcode-select --install\n\nNote that after installation completes, you should probably close your Terminal window and open a new one.",
                  "url": "https://github.com/idaholab/moose/discussions/17482#discussioncomment-559888",
                  "updatedAt": "2022-06-10T15:47:20Z",
                  "publishedAt": "2021-04-01T20:21:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ASKapat"
                          },
                          "bodyText": "That did it, thanks for the help!",
                          "url": "https://github.com/idaholab/moose/discussions/17482#discussioncomment-559972",
                          "updatedAt": "2022-06-10T15:47:22Z",
                          "publishedAt": "2021-04-01T20:38:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "Glad I could help!",
                          "url": "https://github.com/idaholab/moose/discussions/17482#discussioncomment-560077",
                          "updatedAt": "2022-06-10T15:47:22Z",
                          "publishedAt": "2021-04-01T20:56:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Trevor1910"
                          },
                          "bodyText": "Perfect fix!  Thanks a lot!",
                          "url": "https://github.com/idaholab/moose/discussions/17482#discussioncomment-1853495",
                          "updatedAt": "2022-06-10T15:47:21Z",
                          "publishedAt": "2021-12-21T15:40:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "using watt as unit of heat source",
          "author": {
            "login": "PJohnYu"
          },
          "bodyText": "Hello, I have a mesh with multi-blocks, and I want to use watt density as heat source at specified block. But I don't find ways to realize it. Can you please tell me some ideas?\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/19670",
          "updatedAt": "2022-09-29T06:51:46Z",
          "publishedAt": "2021-12-20T12:07:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou want to specify a heat source term in Watts?\nIf your mesh is in meters, and the rest of your simulation is in SI units, then you dont need to do any conversion. Watt is J/s, the SI unit.\nYou can use the HeatSource\nhttps://mooseframework.inl.gov/source/kernels/HeatSource.html\nor the BodyForce kernels\nhttps://mooseframework.inl.gov/source/kernels/BodyForce.html\nto add a source term to an energy equation\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19670#discussioncomment-1847064",
                  "updatedAt": "2022-09-29T06:51:51Z",
                  "publishedAt": "2021-12-20T12:58:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PJohnYu"
                          },
                          "bodyText": "Thanks for your reply, Guillaume!\nI did a incomplete describe about my problem above.\nIn my app, heat source is created by SolutionAux so it is stored in a AuxVariable.\nIt maybe my  mistake that HeatSource and BodyForce can't seem to use AuxVariable object as source term. Do you have some suggestion?",
                          "url": "https://github.com/idaholab/moose/discussions/19670#discussioncomment-1847572",
                          "updatedAt": "2022-09-29T06:51:58Z",
                          "publishedAt": "2021-12-20T14:37:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "You can scale your SolutionAux with the \u201cscale_factor\u201d parameter, where here you would use the conversion from your units -> W",
                          "url": "https://github.com/idaholab/moose/discussions/19670#discussioncomment-1847659",
                          "updatedAt": "2022-09-29T06:51:55Z",
                          "publishedAt": "2021-12-20T14:55:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "You can use the CoupledForce kernel to use an auxvariable as a heat source\nhttps://mooseframework.inl.gov/source/kernels/CoupledForce.html\n\n\u2026\n Le 20 d\u00e9c. 2021 \u00e0 15:55, Logan Harbour ***@***.***> a \u00e9crit :\n\n \ufeff\n You can scale your SolutionAux with the \u201cscale_factor\u201d parameter, where here you would use the conversion from your units -> W\n\n \u2014\n Reply to this email directly, view it on GitHub, or unsubscribe.\n Triage notifications on the go with GitHub Mobile for iOS or Android.\n You are receiving this because you commented.",
                  "url": "https://github.com/idaholab/moose/discussions/19670#discussioncomment-1847675",
                  "updatedAt": "2022-09-29T06:51:55Z",
                  "publishedAt": "2021-12-20T14:59:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "PJohnYu"
                  },
                  "bodyText": "Thank you very much. I have found the suitable cases following your suggestion.",
                  "url": "https://github.com/idaholab/moose/discussions/19670#discussioncomment-1850988",
                  "updatedAt": "2022-09-29T06:51:55Z",
                  "publishedAt": "2021-12-21T06:18:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to realize the element average of a MaterialProperty in the material class?",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nThe MaterialProperty average value of a certain calculation domain is needed as another material parameter. So, I am trying to find the element average or node average of a MaterialProperty  in the material module. I focused on referring to the ElementAverageMaterialProperty class in the Postprocessors module.\nElementAverageMaterialPropertyTest was created to implement such operations, the code is as follows,\n// ElementAverageMaterialPropertyTest.h\nprotected:\nMaterialProperty<Real> & _material_property;\n\nvoid computeIntegral(Real & material_property); // Real & _material_property\n\ntemplate <typename T>\nvoid gatherSum(T & value)\n{\n  _communicator.sum(value);\n}\n// ElementAverageMaterialPropertyTest.C\nElementAverageMaterialPropertyTest::ElementAverageMaterialPropertyTest(const InputParameters & parameters):_material_property(declareProperty<Real>(_base_name + \"material_property\"))\n{    \n}\n\nvoid\nElementAverageMaterialPropertyTest::computeIntegral(Real & material_property)\n{\n  std::vector<Real> sum(2, 0);\n  std::vector<Real> area(2, 0); \n  Real average = 0.0;\n\n  unsigned int op_index = 0;\n  unsigned int size = _hard_factor.size();\n\n    //  Calculate the average for each element\n  for (unsigned int qp = 0; qp < _qrule->n_points(); qp++) // _qrule->n_points()--\u56db\u8282\u70b9\u5355\u5143\u7f51\u683c\n  {\n    sum[op_index] += _JxW[qp] * _coord[qp] * material_property; // Calculate the average of each element\n    area[op_index] += _JxW[qp] * _coord[qp]; // Calculate the area of each element\n\n    // _JxW[qp] = 0.03; // the area of each element is 0.03*4 = 0.12 for QUAD4\n    // _coord[qp] = 1;\n    // _qrule->n_points() = 4;\n  }\n\n    _communicator.sum(sum[op_index]);\n    _communicator.sum(area[op_index]);\n\n    average = sum[0]/area[0];\n}\nWhen using 30 Processors, an error occurred during the calculation process, the error is as follows,\napplication called MPI_Abort(MPI_COMM_WORLD, 805906695) - process 9\nGeneric Warning: In /opt/civet/build_1/conda_builds/conda_envs/next-2e4c730e2f/conda-bld/moose-libmesh-vtk_1626837403905/work/Parallel/MPI/vtkMPICommunicator.cxx, line 69\nMPI had an error\n------------------------------------------------\nInvalid root, error stack:\nPMPI_Bcast(448): MPI_Bcast(buf=0x7ffe66f8efa0, count=1, MPI_UNSIGNED_LONG, root=1074329026, comm=MPI_COMM_WORLD) failed\nPMPI_Bcast(408): Invalid root (value given was 1074329026)\n------------------------------------------------\n\napplication called MPI_Abort(MPI_COMM_WORLD, 269035783) - process 22\nFinally, It should be noted that if I cancel the following code, it can run normally.\n    _communicator.sum(sum[op_index]);\n    _communicator.sum(area[op_index]);\nI think I don't understand the execution mechanism of this code very well. In other words, I don't understand how to traverse all the finite element mesh operations in the material class.\nAny suggestions or recommendations to fix the problem would be greatly appreciated.\nThank you\nWei",
          "url": "https://github.com/idaholab/moose/discussions/19648",
          "updatedAt": "2022-06-10T13:19:18Z",
          "publishedAt": "2021-12-16T01:06:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "You must not perform MPI communication in the execute() method of an element userobject/postprocessor! computeIntegral is a virtual function that gets called by execute. execute is run on each element, and there is very likely not the same number of local elements on each processor, which means there are bound to be MPI calls that have no corresponding call on all other processors, which leads to failure.\nI'm not entirely clear what you want to do here. Do you need the average over elements or the average over a (sub)domain? The average over the element can be computed in computeProperties by looping over all QPs an additional time. If you need the average over the domain (and I'm curious what physics would require such a non-local effect) you need to couple in a postprocessor value, and let MOOSE compute the average using ElementAverageMaterialProperty.",
                  "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1824372",
                  "updatedAt": "2022-06-10T13:19:34Z",
                  "publishedAt": "2021-12-16T15:31:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you for your kind help.\n\nYou must not perform MPI communication, ..., which leads to failure.\n\nIn paragraph, ElementAverageMaterialPropertyTempl<is_ad>::execute() is responsible for calculating the sum value on each process or thread on a subset of the domain by calling the MaterialProperty on each point. At this stage, MPI communication is not performed, right?\nAfter that, the actual summations operation is done in ElementAverageMaterialPropertyTempl<is_ad>::getValue() througth the function gatherSum(). MPI needs to be called.\nI don't know if my understanding is correct?\nFinally, I dinn't see the relevent code for calling between execute() and getvalue(), so I am not very clear about the calling relationship between the them. And these two related codes are also listed at the back\nexecute()\n\nElementAverageMaterialPropertyTempl\n\ntemplate <bool is_ad> // ElementAverageMaterialPropertyTempl.C\nvoid\nElementAverageMaterialPropertyTempl<is_ad>::execute()\n{\n  ElementIntegralMaterialPropertyTempl<is_ad>::execute();\n  // _integral_value += computeIntegral(); \u79ef\u5206\u6240\u8ba1\u7b97\u7684\u503c\n\n  _volume += this->_current_elem_volume; // \u8ba1\u7b97\u6240\u7684\u4f53\u79ef\n}\n\nElementIntegralPostprocessor\n\nvirtual void execute() override; //*.h\nvirtual Real computeIntegral();\n\nvoid\nElementIntegralPostprocessor::execute()\n{\n  _integral_value += computeIntegral();\n}\n\nReal\nElementIntegralPostprocessor::computeIntegral()\n{\n  Real sum = 0;\n\n  for (_qp = 0; _qp < _qrule->n_points(); _qp++)\n    sum += _JxW[_qp] * _coord[_qp] * computeQpIntegral();\n  return sum;\n}\n\nElementIntegralMaterialPropertyTempl\n\ntemplate <bool is_ad>\nReal\nElementIntegralMaterialPropertyTempl<is_ad>::computeQpIntegral()\n{\n  return MetaPhysicL::raw_value(_scalar[_qp]);\n}\ngetValue()\n\nElementAverageMaterialPropertyTempl\n\ntemplate <bool is_ad>\nReal\nElementAverageMaterialPropertyTempl<is_ad>::getValue()\n{\n  const Real integral = ElementIntegralMaterialPropertyTempl<is_ad>::getValue();\n  // gatherSum(_integral_value); // in ElementIntegralPostprocessor.C\n\n  ElementIntegralMaterialPropertyTempl<is_ad>::gatherSum(_volume);\n  // gatherSum:: a gather operation is required to collect the values computed on all processes to the root process;\n  \n  return integral / _volume;\n}\n\nElementIntegralPostprocessor\n\nReal\nElementIntegralPostprocessor::getValue()\n{\n  gatherSum(_integral_value);\n  return _integral_value;\n}",
                          "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1830565",
                          "updatedAt": "2022-06-10T13:19:36Z",
                          "publishedAt": "2021-12-17T01:52:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Hi Wei,\nCould you tell us what you want to compute here? I'll repeat @dschwen here:\n\nDo you need the average over elements or the average over a (sub)domain?\n\nAdditionally, how do you want to use that average? Do you want to use that average in a material property calculation, in a kernel/auxkernel, or in a postprocessor, etc.? I have a feeling that you are probably going down the wrong path -- There could be a much simpler alternative to what you doing right now.\n\nFinally, I dinn't see the relevent code for calling between execute() and getvalue(), so I am not very clear about the calling relationship between the them. And these two related codes are also listed at the back\n\nTo understand the \"calling relationship\" you'll have to dig through the parent classes of the postprocessor. There are multiple ways of doing that. We do have a C++ fundamentals page to help you get started.",
                          "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1830930",
                          "updatedAt": "2022-06-10T13:19:44Z",
                          "publishedAt": "2021-12-17T02:53:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "I'm curious what physics would require such a non-local effect\n\nI am trying to establish a coupled model of phase field (the diffuse interface description) and tensor mechanics (the shrap interface description), such as J2 plasticity or crystal plasticity, based on moose to study the influence of deformed energy including elastic energy and plastic energy on microstructure evolution, such grain boundary migration or precipitation. Plase forgive me for the slow progress now, considering that I don't understand some of mechanisms in moose.\nIn the process of coupling modeling, in view of the incompatibility of the two calculation methods in the description of the microstructure, some assumptions need to be introduced at the interface. L. Zhao, P Chakraborty, M.R. Tonks, I. Szlufarska (2017) used an interpolation scheme to achieve the coupling between them.\nIn this article,\n\nThe sentence marked in green indicates that a weighted average operation is required for the stress and internal states in each grain. The operation of calculating the weighted average of MaterialProperty is my original intention to ask this question. This weighted value needs to be transmitted to the materials bolk again for the calculation of kenels.\nFinally, this model is also based on MOOSE:MARMOT, but I don't have the permission to read it. So I can only directly to the instructions in the article and try to reproduce its operation in my model.\nI truly appreciate your timely help.\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1830931",
                          "updatedAt": "2022-06-10T13:19:45Z",
                          "publishedAt": "2021-12-17T02:53:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay, this is much clearer. At the grain interface, you will have more than one nonzero order parameter. Since each order parameter represents a crystal (and each crystal has its own stress), you'll have to somehow \"blend\" them together.\nThis operation is performed at each quadrature point -- you don't need any additional loop for that. Suppose you have a set of order parameters phi_i, then one way to perform the weighted average is\nstress = sum(weight(phi_i) * stress_i) / sum(weight(phi_i))\n\nwhere weight(phi_i) is the weighting function of your choice. I think a common choice is phi_i^2.",
                          "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1830977",
                          "updatedAt": "2022-08-22T15:20:12Z",
                          "publishedAt": "2021-12-17T03:03:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Hi @hugary1995,\n\nI have a feeling that you are probably going down the wrong path -- There could be a much simpler alternative to what you doing right now.\n\nConsidering the clarity of the question, I divided the response into two. In the last reply, I gave the reason why I want to perform the averaging of the material parameters within the grain (in a certain domain). L. Q. Chen (2015) gives a detailed operation, and I sincerely hope that you have read related articles.\n\nTo understand the \"calling relationship\" you'll have to dig through the parent classes of the postprocessor.\n\nYeah, I also started my introduction to C++ based on the C++ fundamental. But my question now is what is the calling relationship between execute() and getValue(). In moose, I did not find any relevant lines of code to illustrate the calling relationship between them. ElementUserObject.C and Postprocessor.Calso have no related functions to coordinate the calling relationship between them.\nI don\u2019t know if my question is clear, if not, please explain directly.\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1831279",
                          "updatedAt": "2022-08-22T15:20:25Z",
                          "publishedAt": "2021-12-17T03:58:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Hi, @hugary1995\nThank you for your kind answer.\n\nstress = sum(weight(phi_i) * stress_i) / sum(weight(phi_i))\uff1b\n\nI absolutely understand what you mean, but the most important question now is how to get stress_i. So I want to calculate stress_i by weighted average, the tensor mechanics block can only get the only certain stress[ _qp] at the orthogonal point.",
                          "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1831574",
                          "updatedAt": "2022-08-22T15:20:37Z",
                          "publishedAt": "2021-12-17T04:57:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You can use MultiPhaseStressMaterial to do that.",
                          "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1831657",
                          "updatedAt": "2022-08-22T15:20:49Z",
                          "publishedAt": "2021-12-17T05:27:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Well, I guess I'm still not quite sure about what you really want to do, since what you described is different from what was suggested in the article screenshot you pasted above.\nAnyways, I also replied to your other post #19650, in case an average of material property over a grain is actually what you want. The grain average makes sense to me if you want to couple FFT and FEM.",
                          "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1831942",
                          "updatedAt": "2022-08-22T15:20:48Z",
                          "publishedAt": "2021-12-17T06:01:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "problem 1\n\nI guess I'm still not quite sure about what you really want to do,\u2026\n\nI give two articles that may cause some confusion.  I mainly refer to zhao's article, and Chen LongQing\u2019s is just as a supplement, in terms of interpolation processing at the interface.\nIn L. Zhao, P Chakraborty, M.R. Tonks, I. Szlufarska (2017), the processing method at the interface is done by interpolating stress and interal states variables,\n\nAccording to my understanding, a weighted sum of stresses in different crystals in the words marked in green indicate that a weighted average of the stress in each grain needs to be processed.\nA more detailed interpolation scheme is as follows,\n\nZhao applied the same interpolation method to the Cauchy stress $\\sigma_i$, the slip system resistence $s^\\alpha_i$ and the deformed energy $\\psi^{e}_i,\\ \\psi^{p}_i$\nHowever, zhao did not give calculation or description details of the ${\\sigma}{i}, s{i}^{\\alpha}, \\psi_{i}^{e}, \\psi_{i}^{p}}$ corresponding to each crystal or grain, just say a sentence a weighted sum of stresses in different crystals, ... . Therefore, I focused on the interpolation scheme mentioned in Long qingchen (2015), Since he explained their interpolation scheme in detail. The following is\n\nThe interpolation method mentioned in the chen Longqing article is just an alternative for me, because I am not sure how to calculate the stress and internal parameters of each grain in zhao. According to my understanding, the stress and internal parameters calculated by the tensor mechanics module are uniquely determined at each orthogonal point, without distinguishing which crystal grain they belong to.\nAnd today you said that I can try to use MultiPhaseStressMaterial to realize the stress interpolation process at the interface, and I carefully looked at two examples involving MultiPhaseStressMaterial, multiphasestress.i and Pattern1.i.\nI guess Zhao used this coupling modeling method to a large extent. In detail, the stress of each grain is calculated in the material module, and then they are weighted and averaged with MultiPhaseStressMaterial, and finally transmitted to to calculate the balance equation of the mechanics field in kernels. Moreover, I think the advantage of doing so is that the mechanical constitutive model used can be modified very flexibly.\nHowever, I did not see how this method can reset the state parameters at the interface. Specifically,  in the crystal plasticity model, the slip resistance corresponding to the newly activated order parameter during the interface migration process needs to be reset, according to the statement in the zhao's article.\nPlease forgive me for using such words to express my views. If I have not expressed clearly, your questions are very welcome.\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1834422",
                          "updatedAt": "2022-08-22T15:20:48Z",
                          "publishedAt": "2021-12-17T11:45:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Problem 2\n\nThe grain average makes sense to me if you want to couple FFT and FEM.\n\nI don't quite understand what you mean.\nThe simulation of phase field and tensor mechanics field both use FEM to solve, which is adopted by me. According to my understanding, if different numerical solution methods are used, the complexity of coupling modeling is artificially increased, because the results obtained by different numerical solutions will have certain differences in data representation and data transmission also needs to be converted.\nAt the same time, such a problem will not occur in FEM. It is only necessary to consider the mismatch of the two simulation methods for the description of the microstructure.\nThank you so much for the speedy reply.\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/19648#discussioncomment-1834641",
                          "updatedAt": "2022-08-22T15:21:12Z",
                          "publishedAt": "2021-12-17T12:29:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can the calculated results in Postprocessors modular be used for calculations in materials modular?",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nFor the same purpose in the problem #19648, here is a plan B that can be used.  So, I would like to ask whether the average value calculated in the Postprocessors module can be used to calculate a certain MaterialProperty  variable in the materials module.\nAny suggestions or recommendations to fix the problem would be greatly appreciated.\nThank you\nWei",
          "url": "https://github.com/idaholab/moose/discussions/19650",
          "updatedAt": "2022-06-13T12:08:29Z",
          "publishedAt": "2021-12-16T02:30:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyes you can use postprocessors when computing material properties.\njust save a reference to the postprocessor value with getPostprocessorValueByName(pp_name) with pp_name obtained from the input parameters.\nHowever, please be mindful that if you are using AD, postprocessors will not transfer the derivative information to your material property.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19650#discussioncomment-1824132",
                  "updatedAt": "2022-06-13T12:08:40Z",
                  "publishedAt": "2021-12-16T15:05:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Ok, Thank you for your very kind reply.\nI got it. Is it possible to couple variable (such as, gr#, the order parameter in phase field) in ElementAverageMaterialProperty, and then define the average value as,\n\nsum_value += material_property[_qp] * gr0 *gr0;\narea += element_area * gr0 *gr0;\naverage_value = sum_value /area ;\n\nThis is what I want to try next, if it can be coupled. What I really need to be weighted and average is only a material parameter in each grain, #19648.",
                          "url": "https://github.com/idaholab/moose/discussions/19650#discussioncomment-1831647",
                          "updatedAt": "2022-06-13T12:08:42Z",
                          "publishedAt": "2021-12-17T05:21:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yes, you can couple variables in objects derived from ElementUserobjects. But notice that you'll need to sum the material property and area separately in the execute() method, and compute the average in the getValue() method.",
                          "url": "https://github.com/idaholab/moose/discussions/19650#discussioncomment-1831922",
                          "updatedAt": "2022-06-13T12:08:41Z",
                          "publishedAt": "2021-12-17T05:54:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Ok, I know. I think that if the operation of performing the average value is executed in the Userobjects block or an postprocessing block, it does not seem to be a wise choice to execute it in the material module.\nBest Wishes\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/19650#discussioncomment-1850281",
                          "updatedAt": "2022-06-13T12:08:43Z",
                          "publishedAt": "2021-12-21T01:00:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Anisotropic Diffusivity using Euler Angles",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello\nI want to rotate the Anisotropic diffusivity tensor as per the crystallographic orientation of grains using Euler angles. In addition to that, I want to read the Euler angles from the file. So far I can able to simulate anisotropic diffusion by writing the kernels. Can you please help to find a way to rotate the anisotropic diffusivity tensor as per the grain orientation using Euler angles read from the file?\nKernel files and input files are as below:\nINPUT FILE\n[Mesh]\n  type = GeneratedMesh # Can generate simple lines, rectangles and rectangular prisms\n  dim = 2 # Dimension of the mesh\n  nx = 20 # Number of elements in the x direction\n  ny = 20 # Number of elements in the y direction\n  xmax = 1.0 # Length of test chamber\n  ymax = 1.0 # Test chamber radius\n[]\n\n[Variables]\n  [diffused]\n  []\n[]\n\n\n\n[Kernels]\n  [diffusion]\n    type = Concentration # Zero-gravity, divergence-free form of Darcys law\n    variable = diffused # Operate on the \"concentration\" variable from above\n    diffusivity = '7.08e-5 0 0\n                  0    0     0\n                  0    0     0'\n  [../]\n\n  [./euler]\n    type = DiffusionTimeDerivative\n    variable = diffused\n  [../]\n[]\n\n\n[BCs]\n\n [./flux_bc]\n    type = CoupledNeumannBC\n    variable = diffused\n    boundary = left\n    Flux_val = -0.0001\n     \n  [../]\n\n  [outlet]\n    type = ADDirichletBC\n    variable = diffused\n    boundary = right\n    value = 0  \n  []\n[]\n\n[Executioner]\n  type = Transient # Steady state problem\n  solve_type = NEWTON # Perform a Newton solve\n  num_steps = 250 # Run for 75 time steps, solving the system each step.\n  dt = 1 # each time step will have duration \"1\"\n  petsc_options_iname = '-pc_type -pc_hypre_type' # PETSc option pairs with values below\n  petsc_options_value = ' hypre    boomeramg'\n[]\n\n[Outputs]\n  execute_on = 'initial timestep_end'\n  interval = 10\n  exodus = true\n[]\n\n\n\n\n\nKERNELS\n\nConcentration.h\n\n#pragma once\n#include \"ADKernel.h\"\n\nclass Concentration : public ADKernel\n{\npublic:\n  static InputParameters validParams();\n\n  Concentration(const InputParameters & parameters);\n\nprotected:\n  /// ADKernel objects must override precomputeQpResidual\n  virtual ADReal computeQpResidual() override;\n\n  /// References to be set from input file\n  const RealTensorValue & _diffusivity;\n};\n\n\n\n\nConcentration.C\n\n#include \"Concentration.h\"\n\nregisterMooseObject(\"BabblerApp\", Concentration);\n\nInputParameters\nConcentration::validParams()\n{\n  InputParameters params = ADKernel::validParams();\n  params.addClassDescription(\"Compute the concentration term for Fickian diffusion ($c$) equation: \"\n                             \"$-\\\\nabla \\\\cdot \\\\frac{\\\\mathbf{K}}{\\\\mu} \\\\nabla p = 0$\");\n\n  params.addRequiredParam<RealTensorValue>(\"diffusivity\", \"The permeability ($\\\\mathrm{K}$) of the fluid.\");\n\n  return params;\n}\n\nConcentration::Concentration(const InputParameters & parameters)\n  : ADKernel(parameters),\n    _diffusivity(getParam<RealTensorValue>(\"diffusivity\"))\n{\n}\n\nADReal\nConcentration::computeQpResidual()\n{\n  return (_diffusivity) * _grad_test[_i][_qp] * _grad_u[_qp];\n}\n\nThanks in advance. If possible please suggest some examples as well.",
          "url": "https://github.com/idaholab/moose/discussions/19613",
          "updatedAt": "2022-06-02T15:05:08Z",
          "publishedAt": "2021-12-13T03:14:28Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNot sure about examples, I ll let experts on these systems weigh in.\nI think if you need to rotate the diffusivity tensor based on the local grain orientation, that will have to be done in the MaterialProperty.\nMaterial properties, such as _diffusivity here, are re-computed every time a new element is being considered.\nPS there are existing utilities for rotating tensors if that can save you time\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1798898",
                  "updatedAt": "2022-06-02T15:05:17Z",
                  "publishedAt": "2021-12-13T15:11:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thanks. Yes, I need to rotate it as per the orientation angle. D' = Q^T D Q, where Q is the orientation matrix. But I have a question about how to implement it in the above kernels. And I want to read the euler angles from the file.\nThere is one object called RotationTensor in the MOOSE but I cant able to figure out how to use that to rotate the diffusivity.",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1799235",
                          "updatedAt": "2022-06-02T15:05:19Z",
                          "publishedAt": "2021-12-13T15:42:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think the code to rotate tensor might be in utils/RankXXXTensor.h\nI think it may be more natural to do the rotation in the computeQpProperties of the material rather than the kernel.\nIt's likely to work in the kernel too, just that if you have another object or another kernel that will depend on this, then you could forget to do the rotation there.\nReading Euler angles from a file is done by an EulerAngleFileReader\nhttps://mooseframework.inl.gov/source/userobjects/EulerAngleFileReader.html\nwhich is then provided to other objects like for example a GrainTrackerElasticity\nhttps://mooseframework.inl.gov/moose/source/postprocessors/GrainTrackerElasticity.html\nYou can have a look at the latter's object s code to see how Euler angles are being passed\nhttps://github.com/idaholab/moose/blob/06bc1f73f0d4dfb3d01ce9ba77d6bb97346e07eb/modules/phase_field/src/postprocessors/GrainTrackerElasticity.C\nlooks like it s just getEulerAngles called on the reader with the grain id as the parameter.\nThe header (or the doxygen) for the EulerAngleFileReader will have all the options.",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1800132",
                          "updatedAt": "2022-06-02T15:05:19Z",
                          "publishedAt": "2021-12-13T17:45:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thank you. As per your suggestion, I am trying to rotate the diffusivity using computeQpProperties of the material.\nI am taking \"ComputeElasticityTensorCP.h\" and \"ComputeElasticityTensorCP.C\" as reference case.\nhttps://mooseframework.inl.gov/docs/doxygen/modules/ComputeElasticityTensorCP_8h_source.html\nhttps://mooseframework.inl.gov/docs/doxygen/modules/ComputeElasticityTensorCP_8C_source.html\nHowever, when I am implementing the same, I am getting the following error\nerror: 'MooseADWrapper<libMesh::TensorValue, false>' {aka 'class libMesh::TensorValue'} has no member named 'rotate'  _Diff_Tensor[_qp] = _Diff_Matrix[_qp].rotate(_crysrot[_qp]);\nAnisoDiffusivity.h is as below:::\n#pragma once\n\n#include \"Material.h\"\n#include \"ElementPropertyReadFile.h\"\n#include \"RankTwoTensor.h\"\n#include \"RotationTensor.h\"\n\nclass AnisoDiffusivity : public Material\n{\npublic:\n  static InputParameters validParams();\n  \n  AnisoDiffusivity(const InputParameters & parameters);\n\nprotected:\n    virtual void computeQpProperties() override;\n\n    virtual void assignEulerAngles();\n\n    RealVectorValue _Euler_angles;\n\n    const ElementPropertyReadFile * const _read_prop_user_object;\n\n    MaterialProperty<RealVectorValue> & _Euler_angles_mat_prop;\n\n    MaterialProperty<RankTwoTensor> & _crysrot;\n     \n    RotationTensor _R;\n\n    MaterialProperty<Real> & _diffusivity;\n\n    MaterialProperty<RealTensorValue> & _Diff_Matrix;\n    MaterialProperty<RealTensorValue> & _Diff_Tensor;\n};\n\nAnisoDiffusivity.C as below:\n#include \"AnisoDiffusivity.h\"\n#include \"RotationTensor.h\"\n\nregisterMooseObject(\"BabblerApp\", AnisoDiffusivity);\n\nInputParameters\nAnisoDiffusivity::validParams()\n{\n  InputParameters params = Material::validParams();\n  params.addClassDescription(\"Compute an diffusion tensor for anisotropic transport.\");\n  params.addParam<UserObjectName>(\"read_prop_user_object\",\n                                      \"The ElementReadPropertyFile\"\n                                      \"GeneralUserObject to read element \"\n                                      \"specific property values from file\");\n  params.addRequiredParam<RealTensorValue>(\"Diff_Matrix\", \"Anisotropic Diffusivity Tensor\");\n  return params;\n}\n\nAnisoDiffusivity::AnisoDiffusivity(const InputParameters & parameters)\n  : Material(parameters),\n   _read_prop_user_object(isParamValid(\"read_prop_user_object\")\n                                  ? &getUserObject<ElementPropertyReadFile>(\"read_prop_user_object\")\n                                   : nullptr),\n    _Euler_angles_mat_prop(declareProperty<RealVectorValue>(\"Euler_angles\")),\n    _crysrot(declareProperty<RankTwoTensor>(\"crysrot\")),\n    _R(_Euler_angles),\n    _diffusivity(declareProperty<Real>(\"diffusivity\")),\n    _Diff_Matrix(declareProperty<RealTensorValue>(\"Diff_Matrix\")),\n    _Diff_Tensor(declareProperty<RealTensorValue>(\"Diff_Tensor\"))\n{\n}\n\n void\n    AnisoDiffusivity::assignEulerAngles()\n    {\n      if (_read_prop_user_object)\n      {\n        _Euler_angles_mat_prop[_qp](0) = _read_prop_user_object->getData(_current_elem, 0);\n        _Euler_angles_mat_prop[_qp](1) = _read_prop_user_object->getData(_current_elem, 1);\n        _Euler_angles_mat_prop[_qp](2) = _read_prop_user_object->getData(_current_elem, 2);\n      }\n      else\n        _Euler_angles_mat_prop[_qp] = _Euler_angles;\n    }\n\n\n void\n    AnisoDiffusivity::computeQpProperties()\n    {\n     assignEulerAngles();\n     \n     _R.update(_Euler_angles_mat_prop[_qp]);\n     \n     _crysrot[_qp] = _R.transpose();\n\n     _Diff_Tensor[_qp] = _R*_Diff_Matrix[_qp]*_R.transpose();\n    }\n\nOn top of that Diff_Matrix values given in the input file is not properly passed to the kernels.\nCan you please see what is the issue?  I shall be very thankful.",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1814738",
                          "updatedAt": "2022-06-02T15:05:21Z",
                          "publishedAt": "2021-12-15T17:09:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The error message is pretty clear about what's going on here: error: 'MooseADWrapper<libMesh::TensorValue, false>' {aka 'class libMesh::TensorValue'} has no member named 'rotate'. You should use RankTwoTensor instead of RealTensorValue.",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1822086",
                          "updatedAt": "2022-07-30T17:01:49Z",
                          "publishedAt": "2021-12-16T09:53:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I agree for rotate.\nFor diff_matrix not being passed, what are you doing is declaring a material property with the name passed as the diff_matrix parameter, with declareProperty<RealTensorValue>(\"Diff_Matrix\"). You are not filling said matrix.\nTo do that please have a look at the code for ADGenericConstantRankTwoTensor\nhttps://mooseframework.inl.gov/source/materials/ADGenericConstantRankTwoTensor.html\nhttps://github.com/idaholab/moose/blob/next/framework/src/materials/GenericConstantRankTwoTensor.C\nthis line in particular:   _tensor.fillFromInputVector(getParam<std::vector<Real>>(\"tensor_values\"));",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1823966",
                          "updatedAt": "2022-07-30T17:01:49Z",
                          "publishedAt": "2021-12-16T14:58:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thank you very much, everyone. Now I can able to read the diffusion matrix. I can also able to rotate the matrix as\n_Diff_Matrix[_qp].rotate(_crysrot[_qp]);\nBut When I am trying to assign this value to another RankTwoTensor as\n_Temp[_qp] = _Diff_Matrix[_qp].rotate(_crysrot[_qp]);\nthe following error appears:\nerror: no match for 'operator=' (operand types are 'MooseADWrapper<RankTwoTensorTempl, false>' {aka 'RankTwoTensorTempl'} and 'void')\n58 |      _Temp[_qp] = _Diff_Matrix[_qp].rotate(_crysrot[_qp]);\nHeader file is as\n#pragma once\n#include \"Material.h\"\n#include \"ElementPropertyReadFile.h\"\n#include \"RankTwoTensor.h\"\n#include \"RotationTensor.h\"\nclass AnisoDiffusivity : public Material\n{\npublic:\nstatic InputParameters validParams();\nAnisoDiffusivity(const InputParameters & parameters);\nprotected:\nvirtual void computeQpProperties() override;\nvirtual void assignEulerAngles();\n\nRealVectorValue _Euler_angles;\n\nconst ElementPropertyReadFile * const _read_prop_user_object;\n\nMaterialProperty<RealVectorValue> & _Euler_angles_mat_prop;\n\nMaterialProperty<RankTwoTensor> & _crysrot;\nMaterialProperty<RankTwoTensor> & _Diff_Matrix;\nMaterialProperty<RankTwoTensor> & _Temp;\n \nRotationTensor _R;\n\nRankTwoTensor _diffusivity;\n\nMaterialProperty<RealTensorValue> & _Diff_Tensor;\n\n};\nSource file is as follows:\n#include \"AnisoDiffusivity.h\"\n#include \"RotationTensor.h\"\n#include \"GenericConstantRankTwoTensor.h\"\nregisterMooseObject(\"BabblerApp\", AnisoDiffusivity);\nInputParameters\nAnisoDiffusivity::validParams()\n{\nInputParameters params = Material::validParams();\nparams.addClassDescription(\"Compute an diffusion tensor for anisotropic transport.\");\nparams.addParam(\"read_prop_user_object\",\n\"The ElementReadPropertyFile\"\n\"GeneralUserObject to read element \"\n\"specific property values from file\");\nparams.addRequiredParam<std::vector>(\"diffusivity\", \"Stiffness tensor for material\");\nreturn params;\n}\nAnisoDiffusivity::AnisoDiffusivity(const InputParameters & parameters)\n: Material(parameters),\n_read_prop_user_object(isParamValid(\"read_prop_user_object\")\n? &getUserObject(\"read_prop_user_object\")\n: nullptr),\n_Euler_angles_mat_prop(declareProperty(\"Euler_angles\")),\n_crysrot(declareProperty(\"crysrot\")),\n_Diff_Matrix(declareProperty(\"Diff_Matrix\")),\n_Temp(declareProperty(\"Temp\")),\n_R(_Euler_angles),\n_Diff_Tensor(declareProperty(\"Diff_Tensor\"))\n{\n_diffusivity.fillFromInputVector(getParam<std::vector>(\"diffusivity\"));\n}\nvoid\nAnisoDiffusivity::assignEulerAngles()\n{\nif (_read_prop_user_object)\n{\n_Euler_angles_mat_prop_qp = _read_prop_user_object->getData(_current_elem, 0);\n_Euler_angles_mat_prop_qp = _read_prop_user_object->getData(_current_elem, 1);\n_Euler_angles_mat_prop_qp = _read_prop_user_object->getData(_current_elem, 2);\n}\nelse\n_Euler_angles_mat_prop[_qp] = _Euler_angles;\n}\nvoid\nAnisoDiffusivity::computeQpProperties()\n{\nassignEulerAngles();\n _R.update(_Euler_angles_mat_prop[_qp]);\n \n _crysrot[_qp] = _R.transpose();\n\n _Temp[_qp] = _Diff_Matrix[_qp].rotate(_crysrot[_qp]);\n _Diff_Tensor[_qp] = _Diff_Matrix[_qp].rotate(_crysrot[_qp]);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1827277",
                          "updatedAt": "2022-07-30T17:01:49Z",
                          "publishedAt": "2021-12-16T19:36:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Please format your code snippets with triple quotes. This makes them easier to read.\nWhy do you need this _Temp material property?\nSeems like you have everything you need in diff_matrix already\nTry to separate the operations too\n_Diff_Matrix[_qp].rotate(_crysrot[_qp]);\n _Temp[_qp] = _Diff_Matrix[_qp];",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1829195",
                          "updatedAt": "2022-08-15T09:17:19Z",
                          "publishedAt": "2021-12-16T22:55:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thank you very much. I thought it need to be passed to a variable in order to use it in the source code.\nNow, I implemented it as per your suggestion but didn't get the intended results. I am trying to print the _Diff_Matrix after the rotation\n\"\"\"   _Diff_Matrix[_qp].rotate(_crysrot[_qp]); \"\"\"\n\"\"\" std::cout << _Diff_Matrix[_qp] << std::endl; \"\"\"\nand find that there is no effect of the rotation, whatever Euler angles I choose results are the same which should not be the case. I am getting the same results with and without the rotation.\nResult: Diff_Matrix is same before and after the rotation\n(xx,xy,xz)=(7.08e-05,        0,        0)\n(yx,yy,yz)=(       0, 7.08e-05,        0)\n(zx,zy,zz)=(       0,        0, 7.08e-05)\nCan you please suggest if there are any loose ends in the code?",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1836159",
                          "updatedAt": "2022-08-15T09:17:24Z",
                          "publishedAt": "2021-12-17T15:07:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "looks like you can do either, rotate in place (second) or create a rotated copy (first definition)\n  /**\n   * Returns a rotated version of the tensor data given a rank two tensor rotation tensor\n   * _coords[i][j] = R_ij * R_jl * _coords[k][l]\n   * @param R rotation matrix as another RankTwoTensorTempl\n   */\n  RankTwoTensorTempl<T> rotated(const RankTwoTensorTempl<T> & R) const;\n\n  /**\n   * rotates the tensor data given a rank two tensor rotation tensor\n   * _coords[i][j] = R_ij * R_jl * _coords[k][l]\n   * @param R rotation matrix as a RankTwoTensorTempl\n   */\n  void rotate(const RankTwoTensorTempl<T> & R);",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1836293",
                          "updatedAt": "2022-08-15T09:18:54Z",
                          "publishedAt": "2021-12-17T15:33:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thank you. Actually, I am very new to MOOSE. Can you please let me know how to implement them in my case?\n#include \"AnisoDiffusivity.h\"\n#include \"RotationTensor.h\"\n#include \"GenericConstantRankTwoTensor.h\"\n#include \"RankTwoTensor.h\"\n\nregisterMooseObject(\"BabblerApp\", AnisoDiffusivity);\n\nInputParameters\nAnisoDiffusivity::validParams()\n{\n  InputParameters params = Material::validParams();\n  params.addClassDescription(\"Compute an diffusion tensor for anisotropic transport.\");\n  params.addParam<UserObjectName>(\"read_prop_user_object\",\n                                      \"The ElementReadPropertyFile\"\n                                      \"GeneralUserObject to read element \"\n                                      \"specific property values from file\");\n  params.addRequiredParam<std::vector<Real>>(\"diffusivity\", \"Stiffness tensor for material\");\n  return params;\n}\n\nAnisoDiffusivity::AnisoDiffusivity(const InputParameters & parameters)\n  : Material(parameters),\n   _read_prop_user_object(isParamValid(\"read_prop_user_object\")\n                                  ? &getUserObject<ElementPropertyReadFile>(\"read_prop_user_object\")\n                                   : nullptr),\n    _Euler_angles_mat_prop(declareProperty<RealVectorValue>(\"Euler_angles\")),\n    _crysrot(declareProperty<RankTwoTensor>(\"crysrot\")),\n    _Diff_Matrix(declareProperty<RankTwoTensor>(\"Diff_Matrix\")),\n    _R(_Euler_angles),\n    _Diff_Tensor(declareProperty<RealTensorValue>(\"Diff_Tensor\"))\n{\n    _diffusivity.fillFromInputVector(getParam<std::vector<Real>>(\"diffusivity\"));\n}\n\n void\n    AnisoDiffusivity::assignEulerAngles()\n    {\n      if (_read_prop_user_object)\n      {\n        _Euler_angles_mat_prop[_qp](0) = _read_prop_user_object->getData(_current_elem, 0);\n        _Euler_angles_mat_prop[_qp](1) = _read_prop_user_object->getData(_current_elem, 1);\n        _Euler_angles_mat_prop[_qp](2) = _read_prop_user_object->getData(_current_elem, 2);\n      }\n      else\n        _Euler_angles_mat_prop[_qp] = _Euler_angles;\n    }\n\n void\n    AnisoDiffusivity::computeQpProperties()\n    {\n     assignEulerAngles();\n     \n     _R.update(_Euler_angles_mat_prop[_qp]);\n     \n     _crysrot[_qp] = _R.transpose();\n\n     _Diff_Matrix[_qp] = _diffusivity; \n     \n     _Diff_Matrix[_qp].rotate(_crysrot[_qp]);\n    \n     std::cout << _Diff_Matrix[_qp] << std::endl;\n    }",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1836578",
                          "updatedAt": "2022-08-15T09:19:12Z",
                          "publishedAt": "2021-12-17T16:00:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "The right approach is to derive another object from GrainDataTracker that is similar to GrainTrackerElasticity, but provides a rotated RealTensorValue. I developed GrainDataTracker to deal with grain tracker edge cases like grain splitting, where new grain numbers can emerge that you won't have data for in your Euler angle table.\nYou can internally use RankTwoTensors to perform the matrix rotation and then downcast to a RealTensorValue.",
                  "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1824297",
                  "updatedAt": "2022-06-02T15:05:30Z",
                  "publishedAt": "2021-12-16T15:23:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thank you very much. I tried that it works to a certain extent but I can't able to assign the rotated value to a certain variable. I am getting the error which I listed in the above reply.",
                          "url": "https://github.com/idaholab/moose/discussions/19613#discussioncomment-1827292",
                          "updatedAt": "2022-06-02T15:05:30Z",
                          "publishedAt": "2021-12-16T19:38:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "single-phase benchmark validation-getting high value",
          "author": {
            "login": "rksin8"
          },
          "bodyText": "Hi,\nI am working on a single-phase hydromechanical benchmark problem:\n\nInjection rate: 0.02 kg/s/m\nI am getting the same shape for pressure but high values:\n\nDisplacement:\n\nMy input file & grid file:  https://github.com/rksin8/benchmark1p.\nAny idea to fix the problem would be greatly appreciated!\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/19665",
          "updatedAt": "2022-09-29T13:06:03Z",
          "publishedAt": "2021-12-19T06:02:38Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "At a guess, it is probably the non-standard units not being consistent throughout the input file somewhere. The PorousFlowFullySaturated action takes a pressure_unit and time_unit input parameter to make sure that the correct fluid properties are computed, see https://mooseframework.inl.gov/source/actions/PorousFlowFullySaturated.html\nDoes simply adding pressure_unit = MPa and time_unit = days to this action fix it?",
                  "url": "https://github.com/idaholab/moose/discussions/19665#discussioncomment-1844231",
                  "updatedAt": "2023-09-24T09:44:53Z",
                  "publishedAt": "2021-12-19T21:38:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MultiApp transfer AuxKernel object at Gauss points?",
          "author": {
            "login": "rcontinuum"
          },
          "bodyText": "Hello,\nI want to define an AuxKernel elemental variable directly at the Gauss points of the elements. And then transfer this variable to another app in the multiapp context. Say, both meshes of the master app and the sub app have the same mesh with the same quadrature rule, so that their Gauss points coincides. Then such a transfer should be feasible and would not involve any \"interpolation\".\nIs that currently possible? Is their a trick to do that? Any help is appreciated.\nIf I understand correctly, then MOOSE AuxKernel offers volume averaged elemental variables (only?).\nhttps://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/step10_auxkernels.html#step-10-develop-an-auxkernel-object\n\"When the variable type is elemental, the computeValue() method averages the values over the element quadrature points (QPs) weighted by their Gaussian quadratures in proportion to the total volume, area, or length of the element.\"\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/19634",
          "updatedAt": "2022-07-27T14:21:15Z",
          "publishedAt": "2021-12-15T08:52:19Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think the trick would be to use a shape function for the elemental variable that is exact on the Gauss points.\nAny of the ones in the family parameter on this page does the trick?\nhttps://mooseframework.inl.gov/syntax/Variables/index.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19634#discussioncomment-1813563",
                  "updatedAt": "2022-07-27T14:21:15Z",
                  "publishedAt": "2021-12-15T15:11:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "rcontinuum"
                  },
                  "bodyText": "Hello,\nwould you be so kind and elaborate a bit more?\nAssume I have a mesh of QUAD4 elements, bilinear Lagrange shape functions.\nTypically one uses a 2x2 Gauss integration. With Gauss points located at \u00b10.577... in the isoparametric space which I assume is\n\nFor this specific case which shape function would you use \"for the elemental variable that is exact on the Gauss points\".\nDoes there exists an example input file for this case or a similar case?",
                  "url": "https://github.com/idaholab/moose/discussions/19634#discussioncomment-1821584",
                  "updatedAt": "2022-07-08T08:03:31Z",
                  "publishedAt": "2021-12-16T08:22:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If the master app and the subapp have the same mesh, you can use the copy transfer to move fields between apps\nhttps://mooseframework.inl.gov/source/transfers/MultiAppCopyTransfer.html\nif they locally have the same mesh, but in some places don't then you can use the projection transfer, which will still copy the field exactly if the mesh coincides locally.\nhttps://mooseframework.inl.gov/source/transfers/MultiAppProjectionTransfer.html\nthis will make sure the two fields have the same value at the Gauss points, since they have the same value everywhere. Please note that the order for the quadrature is chosen so that the product of the shape functions is integrated exactly.\nBut I think you want to be specifying the value at quadrature points directly as well. This is exactly what the auxkernel does. But when it returns the results, it doesnt return it on the quadrature point. It returns it on the nodes or on the elements. So there is an integration going on, with a system solve for higher orders, to go from quadrature points to nodal or elemental values.",
                          "url": "https://github.com/idaholab/moose/discussions/19634#discussioncomment-1828175",
                          "updatedAt": "2022-07-08T08:03:31Z",
                          "publishedAt": "2021-12-16T21:22:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "rcontinuum"
                  },
                  "bodyText": "Thank you for the clarification!\nRalf",
                  "url": "https://github.com/idaholab/moose/discussions/19634#discussioncomment-1832891",
                  "updatedAt": "2022-07-08T08:03:34Z",
                  "publishedAt": "2021-12-17T08:36:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error opening mesh file",
          "author": {
            "login": "DYLDYLDYL"
          },
          "bodyText": "01.zip",
          "url": "https://github.com/idaholab/moose/discussions/19652",
          "updatedAt": "2022-01-31T18:46:07Z",
          "publishedAt": "2021-12-16T13:02:18Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe message is clear. The node set specified in the boundary parameter of the BC named bottom does not exist on the mesh. You need to add it to your mesh, either using trelis as you mentioned in your unprompted email, or using a mesh generator\nhttps://mooseframework.inl.gov/syntax/Mesh/index.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19652#discussioncomment-1823810",
                  "updatedAt": "2021-12-16T14:53:21Z",
                  "publishedAt": "2021-12-16T14:53:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "DYLDYLDYL"
                          },
                          "bodyText": "Thanks\uff01",
                          "url": "https://github.com/idaholab/moose/discussions/19652#discussioncomment-1830541",
                          "updatedAt": "2021-12-17T01:43:04Z",
                          "publishedAt": "2021-12-17T01:43:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "CH4, CO2, brine",
          "author": {
            "login": "mortezaaesmaeilpour"
          },
          "bodyText": "Dear MOOSE team\nI'm going to use the PorousFlow module to simulate multiphase flow in a reservoir. The main idea is to inject a mixture of brine and CO2 into a reservoir. the reservoir is initially filled with brine and CH4. since the solubility of CO2 in water is higher than CH4, CH4 will be released as a pure gas and we can extract it. the question is that is it possible to simulate mutual solubilities of CO2, CH4, and salt in the water together with accounting for salt precipitation. Is there any example for this kind of simulation.?\nKind regards\nMorteza",
          "url": "https://github.com/idaholab/moose/discussions/19409",
          "updatedAt": "2022-07-10T16:33:56Z",
          "publishedAt": "2021-11-16T09:38:58Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "Hi @mortezaaesmaeilpour,\nI do have this capability that I have used in the past (based on the model of Zirrahi et al, Mutual solubility of CH4, CO2, H2S and their mixtures in brine under subsurface disposal conditions, Fluid Phase Equilibria 324, 2012, pp 80-93), but it isn't publicly available at the moment, and most likely would need some work to make it compatible with the current MOOSE code.\nDo you need this right now, or could you wait a month or so for it? I just don't have the time to look into it at the moment.",
                  "url": "https://github.com/idaholab/moose/discussions/19409#discussioncomment-1661647",
                  "updatedAt": "2022-07-10T16:34:14Z",
                  "publishedAt": "2021-11-18T00:40:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mortezaaesmaeilpour"
                          },
                          "bodyText": "dear Chris\nI'm still waiting for your answer.",
                          "url": "https://github.com/idaholab/moose/discussions/19409#discussioncomment-1682987",
                          "updatedAt": "2022-07-10T16:34:15Z",
                          "publishedAt": "2021-11-22T17:25:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Sorry, I missed your previous message. I'm certain that the code won't compile without probably several hours of work as it will be in a stale branch somewhere. I could try and dig it out, but I really don't have the time to bring it up to date in the next few weeks.",
                          "url": "https://github.com/idaholab/moose/discussions/19409#discussioncomment-1684910",
                          "updatedAt": "2022-07-10T16:34:16Z",
                          "publishedAt": "2021-11-23T01:28:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mortezaaesmaeilpour"
                  },
                  "bodyText": "Dear @cpgr\nThat's great. Could you please provide it in one or two weeks? I need to convince my supervisor to use the PorousFlow module for the simulation of this problem. Nevertheless, if you have developed another MOOSE-based application, I can use it for now and you have time to integrate it into PorousFlow Module.\nCheers\nMorteza",
                  "url": "https://github.com/idaholab/moose/discussions/19409#discussioncomment-1663339",
                  "updatedAt": "2022-07-10T16:35:04Z",
                  "publishedAt": "2021-11-18T09:39:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@cpgr @mortezaaesmaeilpour can I close this?",
                          "url": "https://github.com/idaholab/moose/discussions/19409#discussioncomment-1828398",
                          "updatedAt": "2022-07-10T16:35:10Z",
                          "publishedAt": "2021-12-16T21:43:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "I'm going to do this next month @GiudGiud when I get some time - just been crunched by other project deadlines! Feel free to close this if you want.",
                          "url": "https://github.com/idaholab/moose/discussions/19409#discussioncomment-1829391",
                          "updatedAt": "2022-07-10T16:35:14Z",
                          "publishedAt": "2021-12-16T23:28:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}