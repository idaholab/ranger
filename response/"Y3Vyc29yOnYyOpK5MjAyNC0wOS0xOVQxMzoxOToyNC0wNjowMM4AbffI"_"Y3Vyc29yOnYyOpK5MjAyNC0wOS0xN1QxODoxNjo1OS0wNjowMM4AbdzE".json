{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wOS0xN1QxODoxNjo1OS0wNjowMM4AbdzE"
    },
    "edges": [
      {
        "node": {
          "title": "ProjectionAux in parallel with lower dimensional elements",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear moose team,\nI'm trying to convert an elemental auxvariable (storing a material property) onto a nodal auxvariable via ProjectionAux for cases where I have multiple lower dimensional elements in my simulation (3D, 2D and 1D). The error only occurs if I run on multiple nodes. I tried to debug in parallel, but after setting breakpoints, the simulations stops without giving me the chance to get the backtrace and the only message I have reads\n\nlibMesh terminating:\n[1] ../src/systems/system.C, line 2440, compiled May 15 2024 at 11:55:37\n\nI tried to have a look at the system class in libmesh, and it might point to a problem inside Number System::point_value (though I am relying on a conda installation locally and cannot tell if the files are the same).\nAny help? Thanks for any feedback\nOn a side note: I created a very simple file only relying on the framework objects, and I can share if needed.",
          "url": "https://github.com/idaholab/moose/discussions/28599",
          "updatedAt": "2024-09-19T19:14:43Z",
          "publishedAt": "2024-09-11T10:47:32Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "Forgot to add that without debugger the error is segfault (not sure to which libmesh_assert calls it does refer to)",
                  "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10613044",
                  "updatedAt": "2024-09-11T10:50:15Z",
                  "publishedAt": "2024-09-11T10:50:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Manage to have the bt (attached) and indeed it points to the Number System::point_value call. Sorry for multiple posting\nbt.log",
                          "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10613316",
                          "updatedAt": "2024-09-11T11:22:01Z",
                          "publishedAt": "2024-09-11T11:22:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The ProjectionAux has not been fitted to handle lower D elements. We can take a look if you have a minimal example, to see if it can be expanded",
                          "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10614939",
                          "updatedAt": "2024-09-11T13:51:46Z",
                          "publishedAt": "2024-09-11T13:51:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@GiudGiud thanks! My simple test case sums up to around 4k dofs. If you think is doable (in my case it debug over seconds and the segfault only occurs with >=3 processors) I can share it with you (mesh+input file). What would be your preferred options? Thanks for looking into it",
                          "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10615904",
                          "updatedAt": "2024-09-11T15:20:03Z",
                          "publishedAt": "2024-09-11T15:20:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "4k is a little much, we ll want something that should be useable as a test after",
                          "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10617346",
                          "updatedAt": "2024-09-11T17:32:11Z",
                          "publishedAt": "2024-09-11T17:32:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Ok, tomorrow will try to set up a simple model.",
                          "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10617618",
                          "updatedAt": "2024-09-11T18:00:26Z",
                          "publishedAt": "2024-09-11T18:00:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@GiudGiud I create a minimal example (17 dofs).\nMy suspect is that the error occurs once you have multiple families of LDs (2D and 1D in my test case).\nPlease, let me know how do you prefer for me to share the input and mesh file (sorry I could not find any MeshGenerator nor gmsh functions to have all LDs inside).\nThanks again for helping",
                          "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10624027",
                          "updatedAt": "2024-09-12T09:22:37Z",
                          "publishedAt": "2024-09-12T09:22:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think lower-D is immediately a problem, the other variable would not be defined on the lower-D element.\nyou could put the two files on a public github repo of yours and paste a link here for example",
                          "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10625388",
                          "updatedAt": "2024-09-12T11:50:06Z",
                          "publishedAt": "2024-09-12T11:50:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Sorry for being late. Here is the github repo (projectionAux).\nThanks again for helping",
                          "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10659183",
                          "updatedAt": "2024-09-16T12:33:43Z",
                          "publishedAt": "2024-09-16T12:33:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m not hitting a seg fault on this example.\nAre there lower D elements in this example? I see a nodal and an elemental variable but they are not block restricted so they would be defined everywhere",
                          "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10659398",
                          "updatedAt": "2024-09-16T12:55:57Z",
                          "publishedAt": "2024-09-16T12:55:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "There should be a 2D and 1D LD elements. Is it possible that you are running on a single processor? The segfault usually occurs while running over multiple processors. And yes, the auxvariables are defined for all blocks, 3D, 2D and 1D.",
                          "url": "https://github.com/idaholab/moose/discussions/28599#discussioncomment-10659424",
                          "updatedAt": "2024-09-16T12:58:33Z",
                          "publishedAt": "2024-09-16T12:58:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Applying Neumann BCs to Randomly Distributed Spherical Particles",
          "author": {
            "login": "Josh-Web-700"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI am working on a phase-field solidification simulation. I will be trying to create a set of randomly distributed solid spheres in the domain, each with a no-flux boundary condition applied at the surface.\nI was wondering if it would be possible to use MultiSmoothCircleIC for creating an initial condition with multiple spherical solid particles in the domain, and then to apply a no flux Neumann boundary condition to the surface of each of these particles (the dot product of the gradient of the order parameter with the sphere's surface normals should be zero).\nWhat is the best way to apply this BC? Is there any built-in functionality in MOOSE for this? If not, I was wondering if it is possible to modify MultiSmoothCircleIC so that it exports the locations and sizes of each of the spherical particles to a set of variables that can be read by the BCs or Mesh system. Then, the BCs system would somehow need to be able to compute the normal to the nodes on the surface of the sphere and apply the boundary condition.\nIf I understand the MOOSE system and my problem correctly, I have three questions:\n\nWould it be better to supply a mesh with randomly distributed spherical \"holes,\" and apply the BCs to these internal surfaces, or would it be better to begin with a uniform rectangular mesh and apply the BCs to some defined spherical surfaces contained in the domain?\nIf I do need to supply a mesh with randomly distributed spherical holes, how would I customize the BCs system in MOOSE to apply a Neumann BC to these interior surfaces?\nIf it is possible to create these BCs on a uniform rectangular mesh without any \"holes\", what is the best method and syntax for doing so?\n\nFrom my understanding, it looks like I might be able to use ParsedGenerateSideset to define spherical sidesets to apply these BCs, but I am just not sure if this is the most efficient way to do so.\nPlease let me know if you need further clarification. If this is possible with MOOSE, it would be greatly appreciated if you could guide me to the best way to do this. Thank you so much!",
          "url": "https://github.com/idaholab/moose/discussions/28663",
          "updatedAt": "2024-09-19T14:49:59Z",
          "publishedAt": "2024-09-19T03:37:04Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\n\nwould certainly be good. You can do this in gmsh, in cubit learn, or use the XYZDelaunayTriangulator which just got added yesterday (in the next branch only right now) with SphereMeshGenerators for the spheres (and transformGenerator to translate the spheres)\n\n\nBCs are not applied inside the domain of a variable. Is the variable you plan to apply the BC on defined on both sides of the spherical boundaries?\n\n\nMeshGenerators (such as the ParsedGenerateSideset), which are in charge of modifying the mesh at initialization, cannot read variable values, let alone gradient. So instead you will want to create a MeshModifier, and look at the variable gradient on every element side.",
                  "url": "https://github.com/idaholab/moose/discussions/28663#discussioncomment-10692356",
                  "updatedAt": "2024-09-19T11:36:51Z",
                  "publishedAt": "2024-09-19T11:23:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Josh-Web-700"
                          },
                          "bodyText": "Just to clarify, what is the purpose of using a MeshModifier? Would that be for a dynamic or changing mesh, or is there another reason to use a MeshModifier for a mesh like mine that would be static and unchanging with time?\nThank you again!",
                          "url": "https://github.com/idaholab/moose/discussions/28663#discussioncomment-10694411",
                          "updatedAt": "2024-09-19T14:36:35Z",
                          "publishedAt": "2024-09-19T14:35:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The intent of the MeshModifier system is to modify the mesh. It can be for dynamically modifying the mesh, or it can be executed on the INITIAL execue_on flag, only once. The difference with mesh generators is that mesh modifiers can couple to variables, because they execute after the setup phase",
                          "url": "https://github.com/idaholab/moose/discussions/28663#discussioncomment-10694450",
                          "updatedAt": "2024-09-19T14:40:26Z",
                          "publishedAt": "2024-09-19T14:40:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Josh-Web-700"
                          },
                          "bodyText": "That makes sense, thank you. That way, the Mesh Modifier can modify the mesh to adapt to the MultiSmoothCircleIC condition, and do so only on the INITIAL execute_on flag.\nThank you again for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/28663#discussioncomment-10694574",
                          "updatedAt": "2024-09-19T14:50:00Z",
                          "publishedAt": "2024-09-19T14:49:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Josh-Web-700"
                  },
                  "bodyText": "Yes, in case (2) my variable would be defined on both sides of the spherical boundaries, and I see now why that wouldn't work to apply a boundary condition. That is helpful, thank you so much!",
                  "url": "https://github.com/idaholab/moose/discussions/28663#discussioncomment-10692775",
                  "updatedAt": "2024-09-19T12:01:08Z",
                  "publishedAt": "2024-09-19T12:01:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issue with Custom kernel",
          "author": {
            "login": "ashishdhole"
          },
          "bodyText": "Hello,\nI made this new kernel to incorporate the friction pressure as explained in\n10.1088/0965-0393/20/6/065008\nIdeally, after sometime the friction pressure should get equal to or greater than driving pressure and there should not be any grain boundary movement. but for some reason this is not happening. Is there any issue with the code? Can you have a look at it.\nThe kernel is a combination of two existing kernels ACGrGrPoly and ACInterface with an extra condition and a term I called friction_energy.\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  params.addParam<bool>(\"variable_L\",\n                        true,\n                        \"The mobility is a function of any MOOSE variable (if false, L must be \"\n                        \"constant over the entire domain!)\");\n  params.addCoupledVar(\"g\", 0.0, \"Friction pressure\");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _variable_L(getParam<bool>(\"variable_L\")),\n    _dLdop(getMaterialPropertyDerivative<Real>(\"mob_name\", _var.name())),\n    _d2Ldop2(getMaterialPropertyDerivative<Real>(\"mob_name\", _var.name(), _var.name())),\n    _dkappadop(getMaterialPropertyDerivative<Real>(\"kappa_name\", _var.name())),\n    _dLdarg(_n_args),\n    _d2Ldargdop(_n_args),\n    _d2Ldarg2(_n_args),\n    _dkappadarg(_n_args),\n    _gradarg(_n_args),\n    _g(coupledValue(\"g\")),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n  // Initialize derivatives and gradients for mobility, kappa, and coupled variables\n  for (unsigned int i = 0; i < _n_args; ++i)\n  {\n    MooseVariable * ivar = _coupled_standard_moose_vars[i];\n    const VariableName iname = ivar->name();\n\n    if (iname == _var.name())\n    {\n      // Validate that the kernel variable is not specified in coupled variables\n      if (isCoupled(\"args\"))\n        paramError(\"args\",\n                   \"The kernel variable should not be specified in the coupled `args` parameter.\");\n      else\n        paramError(\"coupled_variables\",\n                   \"The kernel variable should not be specified in the coupled `coupled_variables` \"\n                   \"parameter.\");\n    }\n\n    // Assign material property derivatives and gradients\n    _dLdarg[i] = &getMaterialPropertyDerivative<Real>(\"mob_name\", i);\n    _dkappadarg[i] = &getMaterialPropertyDerivative<Real>(\"kappa_name\", i);\n    _d2Ldargdop[i] = &getMaterialPropertyDerivative<Real>(\"mob_name\", iname, _var.name());\n    _gradarg[i] = &(ivar->gradSln());\n\n    _d2Ldarg2[i].resize(_n_args);\n    for (unsigned int j = 0; j < _n_args; ++j)\n      _d2Ldarg2[i][j] = &getMaterialPropertyDerivative<Real>(\"mob_name\", i, j);\n  }\n}\n\nvoid\nAdvanceFrictionPressure::initialSetup()\n{\n  // Validate coupling for material properties\n  validateCoupling<Real>(\"mob_name\");\n  validateCoupling<Real>(\"kappa_name\");\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int s = 0; s < _op_num; ++s)\n    other_ops[s] = (*_vals[s])[_qp];\n\n  return other_ops;\n}\n\nRealGradient\nAdvanceFrictionPressure::gradL()\n{\n  RealGradient gradient = _grad_u[_qp] * _dLdop[_qp];\n  for (unsigned int i = 0; i < _n_args; ++i)\n    gradient += (*_gradarg[i])[_qp] * (*_dLdarg[i])[_qp];\n  return gradient;\n}\n\nRealGradient\nAdvanceFrictionPressure::nablaLPsi()\n{\n  // Compute the gradient of L*psi using the product rule\n  RealGradient gradient = _L[_qp] * _grad_test[_i][_qp];\n\n  if (_variable_L)\n    gradient += gradL() * _test[_i][_qp];\n\n  return gradient;\n}\n\nRealGradient\nAdvanceFrictionPressure::kappaNablaLPsi()\n{\n  return _kappa[_qp] * nablaLPsi();\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n  Real g = _g[_qp];\n\n  // Initialize sums for order parameters\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  // Compute intermediate values\n  Real inter = _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real op_cubed = op * op * op;\n  Real f_loc = _mu[_qp] * (op_cubed - op + 2.0 * _gamma[_qp] * op * SumOPj);\n  Real total = f_loc + inter;\n  Real friction_energy = 3.0 * g * op * SumOPGj;\n\n  // Compute sign of total\n  const int sgn = (total > 0) - (total < 0);\n\n  // Initialize residual result\n  Real epsilon = 1e-5;\n  Real Res = 0.0;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  // Compute residual if condition is met\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    Real op_cubed = op * op * op;\n    Real op_term = op_cubed - op + 2.0 * _gamma[_qp] * op * SumOPj;\n    Real grad_u_term = _grad_u[_qp] * kappaNablaLPsi();\n    Real sigma_term = _L[_qp] * sgn * (3.0 * g * op * SumOPGj);\n\n    Res = (_L[_qp] * _mu[_qp] * op_term) + grad_u_term - sigma_term;\n  }\n  else\n  {\n    Res = 0;\n  }\n\n  return Res;\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n  // Assign primary and other order parameters\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps(); // Direct assignment\n  const Real g = _g[_qp];\n\n  // Initialize sums for order parameters\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  // Compute intermediate values\n  Real inter = _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real op_cubed = op * op * op;\n  Real f_loc = _mu[_qp] * (op_cubed - op + 2.0 * _gamma[_qp] * op * SumOPj);\n  Real total = f_loc + inter;\n  Real friction_energy = 3.0 * g * op * SumOPGj;\n\n  // Compute sign of total\n  const int sgn = (total > 0) - (total < 0);\n\n  // Compute the derivative of the gradient of the mobility\n  RealGradient dsum =\n      (_dkappadop[_qp] * _L[_qp] + _kappa[_qp] * _dLdop[_qp]) * _phi[_j][_qp] * _grad_test[_i][_qp];\n\n  if (_variable_L)\n  {\n    RealGradient dgradL =\n        _grad_phi[_j][_qp] * _dLdop[_qp] + _grad_u[_qp] * _phi[_j][_qp] * _d2Ldop2[_qp];\n\n    for (unsigned int i = 0; i < _n_args; ++i)\n      dgradL += (*_gradarg[i])[_qp] * _phi[_j][_qp] * (*_d2Ldargdop[i])[_qp];\n\n    dsum += (_kappa[_qp] * dgradL + _dkappadop[_qp] * _phi[_j][_qp] * gradL()) * _test[_i][_qp];\n  }\n\n  Real epsilon = 1e-5;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  Real Jac = 0.0; // Initial value\n\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    Real op_squared = op * op;\n    Real phi_term = _phi[_j][_qp] * (3.0 * op_squared - 1.0 + 2.0 * _gamma[_qp] * SumOPj);\n    Real grad_phi_term = _grad_phi[_j][_qp] * kappaNablaLPsi();\n    Real grad_u_term = _grad_u[_qp] * dsum;\n    Real sigma_term = _L[_qp] * sgn * _phi[_j][_qp] * (3.0 * g * SumOPGj);\n\n    Jac = (_L[_qp] * _mu[_qp] * phi_term) + grad_phi_term + grad_u_term - sigma_term;\n  }\n  else\n  {\n    Jac = 0;\n  }\n\n  return Jac;\n}\n\nI deal behaviour\n\nBut I am getting something like this\n\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/28659",
          "updatedAt": "2024-09-19T02:01:11Z",
          "publishedAt": "2024-09-18T21:03:14Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nso this term is supposed to be added only in certain conditions and counter-balance another term in the equations?",
                  "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10686655",
                  "updatedAt": "2024-09-18T22:30:46Z",
                  "publishedAt": "2024-09-18T22:30:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "yes. only when the total energy is greater than friction energy it is added/subtracted otherwise the entire change is supposed to be zero",
                          "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10686712",
                          "updatedAt": "2024-09-18T22:38:08Z",
                          "publishedAt": "2024-09-18T22:38:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you track both total energy and friction energy? Does it ever get in those conditions?",
                          "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10686735",
                          "updatedAt": "2024-09-18T22:44:12Z",
                          "publishedAt": "2024-09-18T22:44:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Ideally it should get. As the grain grows and grain boundary curvature decreases, the total energy should reduce reaching a point where it is either equal or less than friction energy. I tried to put std::cout << total<<std::endl in the code but it gives me the value of each qp at each iteration so it is almost impossible to track it after say 100 timesteps because to reach 100 timestep it takes forever. if there is a way to trace it it would help. But do you think the code is right?",
                          "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10686753",
                          "updatedAt": "2024-09-18T22:48:00Z",
                          "publishedAt": "2024-09-18T22:47:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you could use material properties or auxiliary variables to output these as fields.\nI think the condition might be met on part of the domain, and not on the rest. This could be a problem for your results",
                          "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10686773",
                          "updatedAt": "2024-09-18T22:53:03Z",
                          "publishedAt": "2024-09-18T22:53:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "any example I should look for material properties or auxiliary variables to output these as fields. Even if I did that, the calculations happens at every qp. I can see the conditions are met, for different value of friction pressure I see different slope in the plot.\n\nbut never complete stop.",
                          "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10686787",
                          "updatedAt": "2024-09-18T22:58:39Z",
                          "publishedAt": "2024-09-18T22:58:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can look at the MaterialRealAux to see how material properties are output.\nBut now that I think about it, you wont be able to output _test and grad_test there.\nCan you examine the energy and friction-energy without using these terms?",
                          "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10686846",
                          "updatedAt": "2024-09-18T23:13:29Z",
                          "publishedAt": "2024-09-18T23:13:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I can but again there is not one single value for the entire time step. they are calculated for each qp. SO I don't think that will be of any help. also there are other variables that comes into picture like op which varies from 0 to 1 at the interface and  they can get any value for different interfaces. I just want to confirm that the code I make is following the logic if such conditions occur. If friction > total will my code give 0 value or there is something hidden that prevents this from happening. Because if the code is correct, then probably it is the material properties I need to check, but if the code is not right then the halt condition will never reach.",
                          "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10686883",
                          "updatedAt": "2024-09-18T23:20:48Z",
                          "publishedAt": "2024-09-18T23:20:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the if condition looks correct.\n\nI can but again there is not one single value for the entire time step. they are calculated for each qp.\n\nyes this is exactly why outputting the whole field using an auxiliary variable will show you where this condition is met or not met, spatially everywhere on the domain",
                          "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10686891",
                          "updatedAt": "2024-09-18T23:22:53Z",
                          "publishedAt": "2024-09-18T23:22:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Ok got it. Let me look into it. Say the condition is achieving, what changes I need to make?\nCan I simply go with\nif (total_abs > friction_energy_abs)\nI am worried about the floating points. because the total at some qp can reach 1e-45 or even less than this. same with friction energy.",
                          "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10686926",
                          "updatedAt": "2024-09-18T23:31:42Z",
                          "publishedAt": "2024-09-18T23:31:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I think I won't be able to output the total or friction pressure. Instead in the code I made some changes that output the _qp where the condition is achieved\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    Real op_cubed = op * op * op;\n    Real op_term = op_cubed - op + 2.0 * _gamma[_qp] * op * SumOPj;\n    Real grad_u_term = _grad_u[_qp] * kappaNablaLPsi();\n    Real sigma_term = _L[_qp] * sgn * (3.0 * g * op * SumOPGj);\n    Res = (_L[_qp] * _mu[_qp] * op_term) + grad_u_term - sigma_term;\n  }\n  else if (total_abs - friction_energy_abs < epsilon * max_abs)\n  {\n    std::cout << _op_num << std::endl;\n    std::cout << _qp << std::endl;\n    Res = 0;\n  }\n  else\n  {\n    Res = 0;\n  }\n\nsuch that it output the _qp when condition is met.\nI am getting following output\n\n3\n0\n3\n2\n2\n0\n3\n2\n1\n3\n0\n0\n2\n0\n2\n2\n2\n3\n3\n2\n 4 Nonlinear |R| = 3.038470e-03\n Solve Converged!\n  Finished Solving                                                                       [ 67.60 s] [  489 MB]\n\nOutlier Variable Residual Norms:\n  gr1: 1.568510e-03\n  gr7: 1.298072e-03\n  gr12: 1.777946e-03\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | R              | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   1.883946e+02 |   0.000000e+00 |   2.000000e+02 |\n|   5.000000e-02 |   7.855635e+00 |   1.938708e+02 |   8.322013e+03 |   2.000000e+02 |\n|   1.100000e-01 |   7.917776e+00 |   1.969501e+02 |   8.322013e+03 |   2.000000e+02 |\n|   1.820000e-01 |   7.930424e+00 |   1.975799e+02 |   8.322013e+03 |   2.000000e+02 |\n|   2.684000e-01 |   7.951380e+00 |   1.986255e+02 |   8.322013e+03 |   1.990000e+02 |\n|   3.720800e-01 |   7.971909e+00 |   1.996524e+02 |   8.322013e+03 |   1.980000e+02 |\n|   4.964960e-01 |   8.012429e+00 |   2.016872e+02 |   8.322013e+03 |   1.960000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\n\nthis is just a part of output. I think they are qp index number. can you make anything out of it?\nThanks",
                          "url": "https://github.com/idaholab/moose/discussions/28659#discussioncomment-10687170",
                          "updatedAt": "2024-09-19T00:30:15Z",
                          "publishedAt": "2024-09-19T00:30:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "App AuxKernel value changed with new MOOSE build",
          "author": {
            "login": "smpark7"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI am currently working on bringing the Moltres app up to date with the latest MOOSE build and moose-dev=2024.08.12.\nWe have tests containing an AuxKernel (WallShearStressAux) that we developed. With an old MOOSE build from March 6 2024, the auxkernel along a boundary evaluates to values ranging from 0.0007 to 0.016, which matches our manual calculations. With the latest MOOSE build, the auxkernel evaluates to values ranging from 0.008 to 5.4. As far as I can tell, all other variables and values match our gold copy.\nCould there have been any changes to MOOSE that affected the auxkernel? E.g., monomial constant auxvariable value computations along boundaries, retrieval of variable gradients for auxkernel computations, etc.\nOur source code for WallShearStressAux is here.  It works with vector velocity variables from the INSAD system.",
          "url": "https://github.com/idaholab/moose/discussions/28434",
          "updatedAt": "2024-09-18T19:09:03Z",
          "publishedAt": "2024-08-20T02:35:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhere are the diffs happening? In a regular external boundary? Or an internal boundary? Or an interface?\n@lindsayad",
                  "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10390796",
                  "updatedAt": "2024-08-20T03:55:23Z",
                  "publishedAt": "2024-08-20T03:55:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "The WallShearStressAux is limited to the top boundary with boundary = top, which is a regular external wall boundary.",
                          "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10391989",
                          "updatedAt": "2024-08-20T06:59:47Z",
                          "publishedAt": "2024-08-20T06:59:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I cannot think of anything off the top of my head. This test case must not have been checked in? Otherwise we would have caught the change in CI",
                          "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10401327",
                          "updatedAt": "2024-08-21T00:24:55Z",
                          "publishedAt": "2024-08-21T00:24:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "Could it be because the auxkernel is only in our heavy tests?\nProbably unrelated, but we recently accidentally broke the CIVET automated merge to master for Moltres because we wanted to limit push privileges of our group users. Do you know how to fix this without lifting the push restrictions?\nIn the meantime, I'll try building Moltres with various MOOSE builds to pinpoint the original issue.",
                          "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10401409",
                          "updatedAt": "2024-08-21T00:42:14Z",
                          "publishedAt": "2024-08-21T00:42:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If it's only tested with heavy, then yea that would be why we missed it when testing MOOSE. I will have to ask @milljm or @loganharbour about the push issue",
                          "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10402513",
                          "updatedAt": "2024-08-21T03:50:12Z",
                          "publishedAt": "2024-08-21T03:50:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "After some testing, we found that the tests pass when compiled with MOOSE from July 24 and moose-dev=2024.07.19. But tests start failing with moose-dev=2024.07.27 (moose version is unchanged). The only significant change between the two moose-dev packages appears to be libmesh.\nThese CIVET test results show the exodiff errors encountered. (Note these tests were on a different MOOSE version but the exodiff error is exactly the same.)\nRelevant info about WallShearStressAux in the tests:\nIt is an auxkernel defined on the top (external) boundary for a constant monomial auxvariable. It computes the magnitude of wall shear stress using gradient values from vector velocity variables (FE) and the boundary normal vector.",
                          "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10663789",
                          "updatedAt": "2024-09-16T20:30:41Z",
                          "publishedAt": "2024-09-16T20:23:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "great thanks @smpark7 . This should be enough information for me to fairly easily bisect libmesh",
                          "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10663901",
                          "updatedAt": "2024-09-16T20:35:57Z",
                          "publishedAt": "2024-09-16T20:35:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "Thanks for investigating this! Another detail that may be of interest: These are the only tests that use CartesianMeshGenerator.",
                          "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10664113",
                          "updatedAt": "2024-09-16T21:05:44Z",
                          "publishedAt": "2024-09-16T21:05:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Will really need to get non-heavy versions of these tests into moltres in the future both for CI coverage (so we know exactly when a breakage occurred in MOOSE) and for ease of doing thinks like bisecting. Have to wait a long time for the test result",
                          "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10677612",
                          "updatedAt": "2024-09-18T05:56:47Z",
                          "publishedAt": "2024-09-18T05:56:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I checked out the MOOSE hash you pointed too and also checked out the libmesh update that occurred when we changed to a moose-dev version of 7.27.24 in #28244. Your exodiffing tests pass for me there",
                          "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10677905",
                          "updatedAt": "2024-09-18T06:39:13Z",
                          "publishedAt": "2024-09-18T06:39:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "After running my own bisect, it appears to me that the \"bad commit\" is the merge of @GiudGiud's #28115",
                          "url": "https://github.com/idaholab/moose/discussions/28434#discussioncomment-10678650",
                          "updatedAt": "2024-09-18T07:52:43Z",
                          "publishedAt": "2024-09-18T07:52:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Running MultiApps run \"out of sync\" vs Restart",
          "author": {
            "login": "callaway-andrew-dykhuis"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi all, I have a problem setup question dealing with MultiApps and Restarts.\nAt a high level my simulation is this: heat transfer between block 1 and block 2 for a period of time, and then block 1 is removed and then heat transfer to/from block 2 via convection for a different period of time.\nI have a working simulation where I use the Controls system to turn off a Dirichlet BC and turn on a convective BC. I have a larger simulation, with additional blocks, where I use ThermalContact to set up GapHeatTransfer objects for the temperature BC instead (more accurate heat transfer modeling than a DirichletBC based on a function, as in the first case). I'd prefer to just toggle these off and switch to a convective BC at a given point in time, but GapHeatTransfer is not controllable....and then I also have extra blocks that aren't involved in my physics at all.\nFrom my review of the forum/discussions, it seems I have a few options:\n\nreplace the GapHeatTransfer BC with a SideSetHeatTransferKernel, which I believe is controllable. From my understanding, however, this would require me to create duplicate variables on each side of the interface, which I'd rather not do, and has the same extra mesh block issue as in my next point.\nMultiApps: I think this might be the more straightforward option. Use GapHeatTransfer in the parent app, and then run a TransientMultiApp that executes on \"final.\" The issue I'm having with this is getting the subapp to run more than a single timestep. I'm not sure how to use global_time_offset to set it up so that I run for say, 100 seconds, in the parent (from time = 0 to time = 100), and then 200 seconds (from time = 100 to time = 300) in the subapp AFTER the parent app in overall time. At that point the entire simulation should be done, even with the time mismatch, as I care about the subapp's final results. The mesh for the second portion has fewer blocks than the first portion of the problem, so setting this up as a separate simulation to me makes more sense than including extra mesh blocks that don't affect the heat transfer I care about.\nRestart - I haven't played around with this yet, but I'd be able to have the problem change from GapHeatTransfer to convective heat transfer by using the first output to initialize the second. Like the subapp input file, I could remove the extra blocks.\n\nAdditional information:\n\nin the subapp input file I delete the extra mesh blocks using BlockDeletionGenerator, and therefore the mesh that remains is the same as the corresponding block in the parent app, but not close enough to MOOSE to allow use of MultiAppCopyTransfer. It is a smaller problem, however, so an option that lets me skip solving \"block 1\" and just focusing on block 2 is more efficient.\nI have multiple stateful properties. In the MultiApp approach I'd update initQpStatefulProperties to use a variable (if provided) as the initial condition, and this variable would be the transferred values from the parent (MaterialRealAux transferred to a dummy auxvar in the sub app, then coupled to the material). I think stateful properties are now supported in restarts, but perhaps not...or perhaps not in my specific use case here.\nMultiApp or Restart would also enable me to tack on additional steps...add back the original blocks and simulate another step, and repeat.\n\nAny thoughts or guidance would be appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/28602",
          "updatedAt": "2024-09-18T16:07:54Z",
          "publishedAt": "2024-09-11T20:45:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI'm surpised we cant control GapHeatTransfer.\nBut assuming that, there are a few options for the multiapps.\n\nYou can try to use offset 'start_time' of each app's transient executioners to get one to run before the other. With sub_cycling turned on, you should see one app (the one with the early start_time) catch up to the other one's start time. Then depending on the end_time specified, the first app might stop solving.\nEasier way might be to just execute the multiapp and the transfers on FINAL. That way the main app runs to completion, then the sub-app is executed.\n\nFor restart, we don't support changing the mesh (especially with different variable numbers of DOFs) if you use Checkpoint restarts. And we do not support restarting stateful properties if you use SolutionUO or Exodus restart.\nBUT\nyou could use a multiapp that restarts from the checkpoint with an identical mesh from the first simulation, then transfers to another app (either the main one or a subapp) that has the different mesh\n\nbut not close enough to MOOSE to allow use of MultiAppCopyTransfer\n\nUse MultiAppGeneralFieldNearestLocationTransfer or ShapeEvaluation if the meshes strictly overlap\n\nMultiApp or Restart would also enable me to tack on additional steps...add back the original blocks and simulate another step, and repeat.\n\nMultiapp probably best if you plan to do very many steps / iterations between the two simulations",
                  "url": "https://github.com/idaholab/moose/discussions/28602#discussioncomment-10619347",
                  "updatedAt": "2024-09-11T21:26:49Z",
                  "publishedAt": "2024-09-11T21:26:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "callaway-andrew-dykhuis"
                          },
                          "bodyText": "Thanks for the quick response! Okay, so based on SolutionUO or Exodus restart I wouldn't have restart capability so MultiApp is the route. The thing is - I don't need the subapp to catch up to the parent: I want to run it like two separate simulations, just using the results from the end of the parent (execute_on = final) to start the subapp, which will then run past the end_time of the parent.\nRight now, I have the following settings (short times for debugging):\nparent start_time = 0\nparent end_time = 5.0\nsubapp start_time = 0\nsubapp end_time = 50.0\nThe subapp runs after the parent reaches 5.0 seconds, but it just runs a single timestep with dt equal to the final dt of the parent. Then it stops.",
                          "url": "https://github.com/idaholab/moose/discussions/28602#discussioncomment-10619562",
                          "updatedAt": "2024-09-11T21:48:21Z",
                          "publishedAt": "2024-09-11T21:48:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you are using a TransientMultiApp though. You could use a FullSolveMultiApp here since you run a full calculation",
                          "url": "https://github.com/idaholab/moose/discussions/28602#discussioncomment-10619587",
                          "updatedAt": "2024-09-11T21:53:08Z",
                          "publishedAt": "2024-09-11T21:53:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "with a transientMultiApp you could do:\n\nexecute_on = FINAL\nsubapp start_time = -50\nsubapp end_time = 0\nthat way, 'catching up' is running a full simulation for the subapp",
                          "url": "https://github.com/idaholab/moose/discussions/28602#discussioncomment-10619594",
                          "updatedAt": "2024-09-11T21:54:45Z",
                          "publishedAt": "2024-09-11T21:54:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "callaway-andrew-dykhuis"
                          },
                          "bodyText": "Looks like FullSolveMultiApp takes care of it.\nI just tried 0-5 for the parent and -50 to 0 for the subapp with a TransientMultiApp and I still get the one time step before it stops, but I believe FullSolveMultiApp solves my main issue. The stateful material initialization in the subapp should be doable via an auxvariable. I might lose a bit of resolution but I can live with that.",
                          "url": "https://github.com/idaholab/moose/discussions/28602#discussioncomment-10619641",
                          "updatedAt": "2024-09-11T22:07:59Z",
                          "publishedAt": "2024-09-11T22:05:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I just tried 0-5 for the parent and -50 to 0 for the subapp with a TransientMultiApp and I still get the one time step before it stop\n\nDid you turn on sub_cycling? SHould have done that.\nIf not then catch_up = true is similar",
                          "url": "https://github.com/idaholab/moose/discussions/28602#discussioncomment-10619704",
                          "updatedAt": "2024-09-11T22:15:20Z",
                          "publishedAt": "2024-09-11T22:15:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "callaway-andrew-dykhuis"
                          },
                          "bodyText": "The timing works out with FullSolveMultiApp, and using the adjusted start_time and end_time, but one additional question I have is in regards to initializing my stateful materials. I have optional coupling to an auxvariable set up so that if the variable is provided then that variable provides the value used in initQpStatefulProperties(). This works for a non-multiapp simulation to set the initial value of the material. However, in my multiapp I transfer material properties via MaterialRealAux to an auxvariable in the subapp, and then couple this auxvariable to the material, but I do not get the coupled value, just the default value. I assume it has something to do with when the transfer occurs vs when the material property is initialized? Is there an option to \"re-initialize\" the stateful material property?",
                          "url": "https://github.com/idaholab/moose/discussions/28602#discussioncomment-10664059",
                          "updatedAt": "2024-09-16T20:58:31Z",
                          "publishedAt": "2024-09-16T20:58:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont think we have this option.\nCould you try this material?\nhttps://mooseframework.inl.gov/source/materials/InterpolatedStatefulMaterial.html",
                          "url": "https://github.com/idaholab/moose/discussions/28602#discussioncomment-10664724",
                          "updatedAt": "2024-09-16T22:59:19Z",
                          "publishedAt": "2024-09-16T22:59:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "callaway-andrew-dykhuis"
                          },
                          "bodyText": "I have something working for now, so I should be good. Thanks again! Based on some optional parameters I can couple to a variable for the _old value and then it functions as desired from there.\nFor the record/to clean it up to mark this as the answer:\nThe fix was using FullSolveMultiApp that executes on \"final,\" and where the subapp uses offset start_time and end_time values. This lets me run from say 0 to 100 seconds in the parent, and then 100 to 200 seconds in the subapp. I transfer material properties to the subapp using MultiAppGeneralFieldNearestLocationTransfer from the parent app's MaterialRealAux auxvariables to auxvariables in the subapp. I adjusted my stateful materials so that I could effectively use the transferred auxvariable in the initial properties calculation.",
                          "url": "https://github.com/idaholab/moose/discussions/28602#discussioncomment-10683760",
                          "updatedAt": "2024-09-18T16:07:04Z",
                          "publishedAt": "2024-09-18T16:07:02Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Hydrogen Transportation",
          "author": {
            "login": "AlejandroRiano2023"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello everyone, I hope you are doing great.\nI am working in Hydrogen Embrittlement. I am aiming to include hydrogen transportation into the phase field model. I was thinking about creating a variable for hydrogen concentration (c) that depends as follows c = c0 + \u03b1d, with (c0 is the initial Hydrogen Concentration, \u03b1 is a parameter and d is the phase field value parameter).\nThe problem is that I have only found equations in the form that you can see in the image. (Huang et all 2020)\n\nDo you happen to know which approach will be easier to adopt?  Should I include a new kernel with the Hydrogen Transportation and recompile my application?",
          "url": "https://github.com/idaholab/moose/discussions/28655",
          "updatedAt": "2024-09-18T15:49:44Z",
          "publishedAt": "2024-09-18T15:48:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Cyclic loading",
          "author": {
            "login": "engrmessi"
          },
          "bodyText": "Good afternoon\nI successfully simulated phase field model of diffusion controlled stress corrosion cracking SCC. In this model, my loading conditions was in form of strain rate, i.e. I applied strain rate (time displacement) at the right boundary as shown in the section of my code share here. Now my Advisor wants me to change the loading condition with cyclic loading to simulate fatigue cracking. Could anyone help me with how to implement cyclic load on BC block. Thank you",
          "url": "https://github.com/idaholab/moose/discussions/28312",
          "updatedAt": "2024-09-18T14:24:10Z",
          "publishedAt": "2024-08-05T18:35:05Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can write down a cyclic load with for example a cosine function?\nexpression = 2.94e-7 * cos(2*pi * t / period)\nsymbol_names = 'period'\nsymbol_values = ...",
                  "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10248972",
                  "updatedAt": "2024-08-06T03:08:34Z",
                  "publishedAt": "2024-08-06T03:08:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "engrmessi"
                  },
                  "bodyText": "Thank you for your response.\nI particularly want to know the type of function to use. Is it still 'ParsedFunction'? or Wound \"FunctionExpression\" be a better option?\nIs there any MOOSE documentation for cyclic loading, if yes, please share the link with me. I already searched, but I could not find any\nBest regards",
                  "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10255084",
                  "updatedAt": "2024-08-06T15:09:45Z",
                  "publishedAt": "2024-08-06T15:09:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "parsedfunction can be great to create the period loading.\nyou can also chain functions if you want a complex profile in one and the periodicity in the other",
                          "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10255181",
                          "updatedAt": "2024-08-06T15:18:43Z",
                          "publishedAt": "2024-08-06T15:18:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "engrmessi"
                          },
                          "bodyText": "Thank you for your feedback. I am still not successful\n[Functions]\n[tdisp]\ntype = ParsedFunction\nexpression = 2.94e-7 * cos(2pit/period)\nsymbol_names = 'period'\nsymbol_values = '16'\n[]\n[]\nAbove is what I incorporated in my script, but my simulation is failing. the error says \"syntax error, unexpected invalid token, expecting = or :=\"\nI also used the below function and the error persists\n[Functions]\n[tdisp]\ntype = ParsedFunction\nexpression = 2.94e-7 * cos(2pit/16)\n[]\n[]\nPlease how do I fix this syntax error. This error occurs in the line containing   expression = 2.94e-7 * cos(2pit/period)  and expression = 2.94e-7 * cos(2pit/16)",
                          "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10278561",
                          "updatedAt": "2024-08-08T17:52:30Z",
                          "publishedAt": "2024-08-08T17:52:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "engrmessi"
                          },
                          "bodyText": "Sorry, I fixed the syntax problem.\nBest regards",
                          "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10279526",
                          "updatedAt": "2024-08-08T20:17:32Z",
                          "publishedAt": "2024-08-08T20:17:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Awesome. Yes you were simply missing multiply symbols",
                          "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10280182",
                          "updatedAt": "2024-08-08T21:52:23Z",
                          "publishedAt": "2024-08-08T21:52:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "engrmessi"
                  },
                  "bodyText": "Good morning GiudGiud,\nStill on modeling stress cracking fatigue under cyclic load. My PI asked that I model two cases (1) strain controlled cyclic load and (2) stress controlled cyclic load.\nThe figures (a) and (b) are the input file and result (plot of stress vs time) obtain from strain controlled load which looks nice as the the peak stress is uniform.\nThe figure (c) and (d) are for the stress controlled input file and plot of stress vs time. Here the pick stress is not uniform. My question is if this plot is ok. Must the peak stress be uniform as in the case (1). If this is not ok, what can I do to achieve the even stress pick?\nPlease also note that the amplitude of the functions used differs for both cases. case (1), requires 0.05 amplitude for the material to degrade while case (2) needs 50 amplitude, please see the input files used\nCase (1): Strain controlled cyclic load\n\n\nCase (2): Stress controlled cyclic load",
                  "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10682290",
                  "updatedAt": "2024-09-18T14:34:07Z",
                  "publishedAt": "2024-09-18T14:07:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are these results converged in the time grid?\n@bwspenc who would be a good person to comment on this?",
                          "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10682435",
                          "updatedAt": "2024-09-18T14:13:29Z",
                          "publishedAt": "2024-09-18T14:13:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "engrmessi"
                  },
                  "bodyText": "Yes the results converged, however because there are a lot oscillations (cycle time) ....... up to 200000s, I only plot up to just 1200s and 2000s respectively.",
                  "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10682509",
                  "updatedAt": "2024-09-18T14:19:16Z",
                  "publishedAt": "2024-09-18T14:19:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "engrmessi"
                  },
                  "bodyText": "These are the fatigue cracking for the cases respectively",
                  "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10682563",
                  "updatedAt": "2024-09-18T14:24:11Z",
                  "publishedAt": "2024-09-18T14:24:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "error when use CoupledVarThresholdElementSubdomainModifier and mesh adaptivity at the same time",
          "author": {
            "login": "PEI0214"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello\nWhen I used CoupledVarThresholdElementSubdomainModifier and mesh adaptivity at the same time , appeared the following error:\nlibMesh terminating:\nExodusII_IO_Helper: block id 2 not found in block_ids.\n[0] ../src/mesh/exodusII_io_helper.C, line 3266, compiled Aug 20 2024 at 14:09:52\n\nAbort(1) on node 0 (rank 0 in comm 0): application called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n\nThe input file is as follows:\n\ntest.i\n# primary model units (m | s | Pa | kg --> N/m\u00b2)\n[Problem]\n  kernel_coverage_check = false\n  material_coverage_check = false\n  boundary_restricted_node_integrity_check = false\n[]\n\nnew_domain_blocks = '1001\t1002'\n\n[Mesh]\n  [BaseMesh]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 20\n    ny = 20\n    nz = 2\n    xmin = -5\n    xmax = +5\n    ymin = -5\n    ymax = +5\n    zmin = -2\n    zmax = +2\n  []\n  [Box1]\n    type = SubdomainBoundingBoxGenerator\n    input = \"BaseMesh\"\n    block_id = 1\n    location = \"INSIDE\"\n    bottom_left = \"-10 -10 -2\"\n    top_right   = \"+10 +10 +2\"\n  []\n  [Box2]\n    type = SubdomainBoundingBoxGenerator\n    input = \"Box1\"\n    block_id = 2\n    location = \"INSIDE\"\n    bottom_left = \"-10 -10 0\"\n    top_right   = \"+10 +10 +2\"\n  []\n\n  add_subdomain_ids = ${new_domain_blocks}\n\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  use_displaced_mesh = false\n[]\n\n[Variables]\n  [disp_x]\n    block = '${new_domain_blocks}'\n  []\n  [disp_y]\n    block = '${new_domain_blocks}'\n  []\n  [disp_z]\n    block = '${new_domain_blocks}'\n  []\n[]\n\n[Physics/SolidMechanics/QuasiStatic]\n  [./all]\n    strain = finite\n    add_variables = true\n    block = '${new_domain_blocks}'\n    generate_output = 'stress_xx stress_zz strain_xx strain_zz'\n  [../]\n[]\n\n# ===== Gravity =====\n[Kernels]\n  [Gravity]\n    type = Gravity\n    block = '${new_domain_blocks}'\n    use_displaced_mesh = false\n    variable = disp_z\n    value = -10\n  []\n[]\n\n# ===== Boundary Conditions =====\n[BCs]\n  [archor_x]\n    type = DirichletBC\n    boundary = 'back'\n    variable = disp_x\n    value = 0\n  []\n\n  [archor_y]\n    type = DirichletBC\n    boundary = 'back'\n    variable = disp_y\n    value = 0\n  []\n\n  [archor_z]\n    type = DirichletBC\n    boundary = 'back'\n    variable = disp_z\n    value = 0\n  []\n[]\n\n# ===== Materials (linear-elastic to keep it simple) =====\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    block = '${new_domain_blocks}'\n    youngs_modulus = 50E6 # 50 MPa\n    poissons_ratio = 0.3\n  []\n\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n    block = '${new_domain_blocks}'\n  []\n\n  [density]\n    type = GenericConstantMaterial\n    block = '${new_domain_blocks}'\n    prop_names = density\n    prop_values = 2000\n  []\n[]\n\n# ===== Block Activation/Deactivation =====\n[Functions]\n  [Box_ActivationStateFunction]\n    type = PiecewiseConstant\n    direction = left\n    xy_data = '0   2\n               100 2\n               200 1\n               300 1\n               400 0\n               800 0'\n  []\n[]\n\n[AuxVariables]\n  [Box_Activation_AuxVariable]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n[]\n# link Box2_ActivationStateFunction and Box2_Activation_AuxVariable\n[AuxKernels]\n  [Box_Activation_FunctionAux]\n    type = FunctionAux\n    variable = 'Box_Activation_AuxVariable'\n    function = 'Box_ActivationStateFunction'\n    execute_on = 'INITIAL TIMESTEP_BEGIN'\n  []\n[]\n# move Box2 between subdomains\n[MeshModifiers]\n  [Box1_SubdomainModifier]\n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = 'Box_Activation_AuxVariable'\n    criterion_type = ABOVE\n    threshold = 1.5\n    block = 1\n    subdomain_id = 1\n    complement_subdomain_id = 1001\n    execute_on = 'INITIAL TIMESTEP_BEGIN'\n  []\n  [Box2_SubdomainModifier]\n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = 'Box_Activation_AuxVariable'\n    criterion_type = ABOVE\n    threshold = 0.5\n    block = 2\n    subdomain_id = 2\n    complement_subdomain_id = 1002\n    execute_on = 'INITIAL TIMESTEP_BEGIN'\n  []\n[]\n\n[Adaptivity]\n  marker = marker\n  max_h_level = 2\n  initial_steps = 1\n  stop_time = 200\n  [Markers]\n    [marker]\n      type = UniformMarker\n      mark = REFINE\n      block = '2'\n    []\n  []\n[]\n\n# ===== Executioner =====\n[Executioner]\n  type = Transient\n  automatic_scaling = true\n\n  end_time = 800\n  dt = 100\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = ' lu       mumps'\n\n  nl_abs_tol = 1E-2\n  nl_max_its = 400\n\n  l_tol = 1E-8\n  l_max_its = 200\n[]\n\n[Outputs]\n  [out]\n    type = Exodus\n  []\n  perf_graph = true\n[]\n\n[Debug]\n  show_var_residual_norms = true\n  # show_material_props = true\n[]\n\n\n\nWhen mesh adaptivity is not used, the simulation runs normally. CoupledVarThresholdElementSubdomainModifier and mesh adaptivity seems to conflicts. Is there a way to solve this problem?",
          "url": "https://github.com/idaholab/moose/discussions/28598",
          "updatedAt": "2024-09-18T08:17:54Z",
          "publishedAt": "2024-09-11T09:10:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis seems to come from the exodus output. It's a known issue\n#28005",
                  "url": "https://github.com/idaholab/moose/discussions/28598#discussioncomment-10618943",
                  "updatedAt": "2024-09-11T20:39:48Z",
                  "publishedAt": "2024-09-11T20:39:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "Hello, is there a solution to this problem now?",
                          "url": "https://github.com/idaholab/moose/discussions/28598#discussioncomment-10678601",
                          "updatedAt": "2024-09-18T07:47:50Z",
                          "publishedAt": "2024-09-18T07:47:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear @PEI0214, I dont know of any solution but there is an corresponding issue over there with libmesh: libMesh/libmesh#3949",
                          "url": "https://github.com/idaholab/moose/discussions/28598#discussioncomment-10678926",
                          "updatedAt": "2024-09-18T08:17:55Z",
                          "publishedAt": "2024-09-18T08:17:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Tools to split one boundary into two",
          "author": {
            "login": "pj131611"
          },
          "bodyText": "Hi there,\nWhile using \"Thermal Contact\" for mutually contacting geometry, we need to find a way to turn the interface or intersection between two geometry into two different boundaries. But I'm stuck on how to do so while the two contacting objects are in different size, let's say, a cube with length of 1 and a cube with length 2. Do I have to cut the larger cube in this case?\nAny help will be much appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/28642",
          "updatedAt": "2024-09-18T03:16:18Z",
          "publishedAt": "2024-09-17T11:16:44Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe contact interfaces do not have to match.\nIf your geometries are cubes, the sidesets-generators in moose (under MeshGenerator) should easily add the new sidesets\n(bottom of https://mooseframework.inl.gov/syntax/Mesh/index.html)\nIf your mesh started out with the two cubes merged together, you can use the BreakMeshByBlockGenerator to split them\nhttps://mooseframework.inl.gov/source/meshgenerators/BreakMeshByBlockGenerator.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10669548",
                  "updatedAt": "2024-09-17T11:28:56Z",
                  "publishedAt": "2024-09-17T11:28:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pj131611"
                          },
                          "bodyText": "Thanks for the quick response! That's exactly what I need!\nOn top of that, some of the interface are connected while I would like to take care of them one by one. So is there a function that breaks orthogonal connected interface into single pieces?",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676268",
                          "updatedAt": "2024-09-18T01:36:00Z",
                          "publishedAt": "2024-09-18T01:35:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "do you mean cutting subdomains apart? or do you mean cutting a large boundary in multiple parts?",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676284",
                          "updatedAt": "2024-09-18T01:39:00Z",
                          "publishedAt": "2024-09-18T01:39:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pj131611"
                          },
                          "bodyText": "Cutting a large boundary into multiple parts.",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676288",
                          "updatedAt": "2024-09-18T01:39:34Z",
                          "publishedAt": "2024-09-18T01:39:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you use the ParsedGenerateSideset with include_boundaries to do that?",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676401",
                          "updatedAt": "2024-09-18T02:00:37Z",
                          "publishedAt": "2024-09-18T02:00:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pj131611"
                          },
                          "bodyText": "I always run into error while using Parsed related functions, but I manage to split the interface with SideSetsAroundSubdomainGenerator by setting different normal vectors (benefit of cubes :D), but I noticed that some of the side side doesn't have a corresponding node set and the name of side set and node set doesn't agree either, did I missed anything?",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676656",
                          "updatedAt": "2024-09-18T02:51:22Z",
                          "publishedAt": "2024-09-18T02:51:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If there is a missing nodeset you can use an option in the Mesh block to convert the sidesets to nodeset s\nThere is also a generator for this conversion\nSidesetsToNodesetsGenerator iirc",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676769",
                          "updatedAt": "2024-09-18T03:14:54Z",
                          "publishedAt": "2024-09-18T03:14:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pj131611"
                          },
                          "bodyText": "That's Wonderful. Thanks again for all your help!",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676777",
                          "updatedAt": "2024-09-18T03:16:14Z",
                          "publishedAt": "2024-09-18T03:16:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Inconsistent precipitates",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "The precipitates in my simulation look very weird and I cannot figure out why. Below is a picture. Most of them are too long than usual.\n\nI had a multiphase script(two-precipitate) as seen below. That is the shapes I want. I changes it to only one precipitate and they grow too long.\n\nBelow are snippets of the code\n\n[Bounds]\n  [./eta_upper_bound]\n    type = ConstantBounds\n    variable = bounds_dummy\n    bounded_variable = eta0\n    bound_type = upper\n    bound_value = 1\n  [../]\n  [./eta_lower_bound]\n    type = ConstantBounds\n    variable = bounds_dummy\n    bounded_variable = eta0\n    bound_type = lower\n    bound_value = -1\n  [../]\n  \n[]\n[Functions]\n  [./ic_func_c]\n    type = ParsedFunction\n    expression = 0.5+0.01*(cos(1.05*x)*cos(1.1*y)+(cos(1.3*x)*cos(0.87*y))^2+cos(0.25*x-1.5*y)*cos(0.7*x-0.2*y))\n  [../]\n  [./bc_func]\n    type = ParsedFunction\n    expression = sin(alpha*pi*x)\n    symbol_names = alpha\n    symbol_values = 16\n  [../]\n  [./disp_func]\n    type = ParsedFunction\n    expression = 'if(t<50,6e-3*t,0.3)'\n  [../]\n  [./press_func]\n    type = ParsedFunction\n    expression = '1'\n  [../]\n[]\n\n[ICs]\n  [./eta0]\n    variable = eta0\n    type = RandomIC\n    min = -0.1625\n    max = 0.1625\n    seed = 192\n  [../]\n  \n  [./c]\n    variable = c\n    type = RandomIC\n    min = 0.24375\t\n    max = 0.25625\n    seed = 89\t\n  [../]\n[Materials]\n  # simple toy free energies\n  [./f0]\n    type = DerivativeParsedMaterial\n    property_name = fc_0\n    coupled_variables = 'c0'\n    expression = '100.0*(c0-0.3333)^2'\n  [../]\n  # Elastic energy of the phase 0\n  [./elastic_free_energy_0]\n    type = ElasticEnergyMaterial\n    base_name = phase0\n    property_name = fe_0\n    coupled_variables = ' '\n  [../]\n  # Total free energy of the phase 0\n  [./Total_energy_0]\n    type = DerivativeSumMaterial\n    property_name = F0\n    sum_materials = 'fc_0 fe_0'\n    coupled_variables = 'c0'\n  [../]\n\n \n\n  [./f1]\n    type = DerivativeParsedMaterial\n    property_name = fc_1\n    coupled_variables  = 'c1'\n    expression = '5.0*(c1-0.20)^2'\n  [../]\n  # Elastic energy of the phase 1\n  [./elastic_free_energy_1]\n    type = ElasticEnergyMaterial\n    base_name = phase1\n    property_name = fe_1\n    coupled_variables = ' '\n  [../]\n  # Total free energy of the phase 1\n  [./Total_energy_1]\n    type = DerivativeSumMaterial\n    property_name = F1\n    sum_materials = 'fc_1 fe_1'\n    coupled_variables = 'c1'\n  [../]\n\n  # Switching functions for each phase\n  # h0(eta0, eta1)\n  [./h0]\n    type = SwitchingFunctionMultiPhaseMaterial\n    phase_etas = eta0\n    all_etas = 'eta0  eta1'\n    h_name = h0\n  [../]\n  \n  # h1(eta0,  eta1)\n  [./h1]\n    type = SwitchingFunctionMultiPhaseMaterial\n    phase_etas = eta1\n    all_etas = 'eta0  eta1'\n    h_name = h1\n  [../]\n\n  # Coefficients for diffusion equation\n  [./Dh0]\n    type = DerivativeParsedMaterial\n    material_property_names = 'D h0'\n    function = D*h0\n    f_name = Dh0\n  [../]\n  \n  [./Dh1]\n    type = DerivativeParsedMaterial\n    material_property_names = 'D h1'\n    function = D*h1\n    f_name = Dh1\n  [../]\n\n  # Barrier functions for each phase\n  [./g0]\n    type = BarrierFunctionMaterial\n    g_order = SIMPLE\n    eta = eta0\n    function_name = g0\n  [../]\n\n  [./g1]\n    type = BarrierFunctionMaterial\n    g_order = SIMPLE\n    eta = eta1\n    function_name = g1\n  [../]\n\n  # constant properties\n  [./constants]\n    type = GenericConstantMaterial\n    prop_names  = 'L    kappa  D    W'\n    prop_values = '0.3  0.01   1    0.01'\n  [../]\n\n  #Mechanical properties\n  [./Stiffness_phase0]\n    type = ComputeElasticityTensor\n    C_ijkl = '1982 534 496 1606 605 1788 985 1056 388'    \n    base_name = phase0\n    fill_method = symmetric9\n  [../]\n  \n  [./Stiffness_phase1]\n    type = ComputeElasticityTensor\n    C_ijkl = '2008.5 448.9 918.5 2008.5 918.5 1538.7 779.8 779.8 309.9'    \n    base_name = phase1\n    fill_method = symmetric9\n  [../]\n\n  [./stress_phase0]\n    type = ComputeLinearElasticStress\n    base_name = phase0\n  [../]\n  \n  [./stress_phase1]\n    type = ComputeLinearElasticStress\n    base_name = phase1\n  [../]\n\n  [./strain_phase0]\n    type = ComputeSmallStrain\n    displacements = 'disp_x disp_y'\n    base_name = phase0\n    eigenstrain_names = eigenstrain0\n  [../]\n \n  [./strain_phase1]\n    type = ComputeSmallStrain\n    displacements = 'disp_x disp_y'\n    base_name = phase1\n  [../]\n\n  [./eigen_strain0]\n   type = ComputeEigenstrain\n   base_name = phase0\n   eigen_base = '1 0 0 0 0 0'\n   prefactor = '0.005 0.005 0.005'\n   eigenstrain_name = eigenstrain0\n  [../]\n\n\n\n  # Generate the global stress from the phase stresses\n  [./global_stress]\n    type = MultiPhaseStressMaterial\n    phase_base = 'phase0  phase1'\n    h          = 'h0        h1'\n  [../]\n\n  [./global_strain]\n    type = ComputeSmallStrain\n    displacements = 'disp_x disp_y'\n  [../]\n[]\n\n[Kernels]\n  \n\n  #Kernels for diffusion equation\n  [./diff_time]\n    type = TimeDerivative\n    variable = c\n  [../]\n  [./diff_c0]\n    type = MatDiffusion\n    variable = c\n    diffusivity = Dh0\n    v = c1\n  [../]\n\n  [./diff_c1]\n    type = MatDiffusion\n    variable = c\n    diffusivity = Dh1\n    v = c1\n  [../]\n\n  # Kernels for Allen-Cahn equation for eta0\n  [./deta0dt]\n    type = TimeDerivative\n    variable = eta0\n  [../]\n  [./ACBulkF0]\n    type = KKSMultiACBulkF\n    variable  = eta0\n    Fj_names  = 'F0  F1'\n    hj_names  = 'h0  h1'\n    gi_name   = g0\n    eta_i     = eta0\n    wi        = 0.01\n    args      = 'c0  c1  eta1'\n  [../]\n  [./ACBulkC0]\n    type = KKSMultiACBulkC\n    variable  = eta0\n    Fj_names  = 'F0  F1'\n    hj_names  = 'h0  h1'\n    cj_names  = 'c0  c1'\n    eta_i     = eta0\n    args      = 'eta1'\n  [../]\n  [./ACInterface0]\n    type = ACInterface\n    variable = eta0\n    kappa_name = kappa\n  [../]\n\n \n\n  # Kernels for constraint equation eta0 + eta1 = 1\n  # eta1 is the nonlinear variable for the constraint equation\n  [./eta1reaction]\n    type = MatReaction\n    variable = eta1\n    mob_name = 1\n  [../]\n  [./eta0reaction]\n    type = MatReaction\n    variable = eta1\n    v = eta0\n    mob_name = 1\n  [../]\n  \n  [./one]\n    type = BodyForce\n    variable = eta1\n    value = -1.0\n  [../]\n\n\n  # Phase concentration constraints\n  [./chempot13]\n    type = KKSPhaseChemicalPotential\n    variable = c0\n    cb       = c1\n    fa_name  = F0\n    fb_name  = F1\n  [../]\n  \n  [./phaseconcentration]\n    type = KKSMultiPhaseConcentration\n    variable = c1\n    cj = 'c0  c1'\n    hj_names = 'h0 h1'\n    etas = 'eta0  eta1'\n    c = c\n  [../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/28649",
          "updatedAt": "2024-09-18T00:16:59Z",
          "publishedAt": "2024-09-17T20:13:19Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou left out the executonier block. We should check your solver parameters to be sure this is converged.",
                  "url": "https://github.com/idaholab/moose/discussions/28649#discussioncomment-10675653",
                  "updatedAt": "2024-09-17T23:06:20Z",
                  "publishedAt": "2024-09-17T23:06:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "Below is the executioner block.\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu            mumps            vinewtonrsls'\n\n  l_max_its = 50\n  nl_max_its = 25\n  l_tol = 1.0e-3\n  nl_rel_tol = 1.0e-6\n  nl_abs_tol = 1.0e-8\n\n  end_time = 10000\n\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 5e-4\n    cutback_factor = 0.75\n    growth_factor = 1.2\n    optimal_iterations = 20\n  [../]\n\n  [./Adaptivity]\n    initial_adaptivity = 0\n    refine_fraction = 0.7\n    coarsen_fraction = 0.1\n    max_h_level = 1\n  [../]\n\n[]\n\nI have attached a snippet of the .out file\nResetting modules to system default. Reseting $MODULEPATH back to system default. All extra directories will be removed from $MODULEPATH.\nRun 'mamba init' to be able to run mamba activate/deactivate\nand start a new shell session. Or use conda to activate/deactivate.\n\n\n\ufffd[36m\n*** Info ***\nSolidMechanics Action: selecting 'incremental finite strain' formulation.\ufffd[39m\n\n\ufffd[33m\n*** Warning, This code is deprecated and will be removed in future versions:\n/home/emmanuel324/projects/belson/My_Project/My_two_phase/Test_5_two_phase_test_trial_5/Test_5_two_phase_test_trial_5.i:257: (Materials/Dh0/f_name):\nThe parameter 'f_name' is deprecated.\nf_name is deprecated, use property_name\n\ufffd[39m\n\n\ufffd[33m\n*** Warning, This code is deprecated and will be removed in future versions:\n/home/emmanuel324/projects/belson/My_Project/My_two_phase/Test_5_two_phase_test_trial_5/Test_5_two_phase_test_trial_5.i:256: (Materials/Dh0/function):\nThe parameter 'function' is deprecated.\n'function' is deprecated, use 'expression' instead\n\ufffd[39m\n\n\ufffd[33m\n*** Warning, This code is deprecated and will be removed in future versions:\n/home/emmanuel324/projects/belson/My_Project/My_two_phase/Test_5_two_phase_test_trial_5/Test_5_two_phase_test_trial_5.i:385: (Kernels/ACBulkF0/args):\n'args' has been deprecated and will be removed on 02/07/2024. Please use 'coupled_variables' instead.\n\ufffd[39m\nCurrently Setting Up\n  Initializing\n    Finished Initializing Equation Systems                                               [\ufffd[33m  0.69 s\ufffd[39m] [\ufffd[33m  427 MB\ufffd[39m]\n  Finished Initializing                                                                  [\ufffd[33m  0.92 s\ufffd[39m] [\ufffd[33m  427 MB\ufffd[39m]\nUsing EXPERIMENTAL Stateful Material Property projection with Adaptivity!\nFinished Setting Up                                                                      [\ufffd[33m  3.77 s\ufffd[39m] [\ufffd[33m  427 MB\ufffd[39m]\nFramework Information:\nMOOSE Version:           git commit 4505a3e on 2024-06-10\nLibMesh Version:         1c5369aa05eaae8ebeb7930845fce3b1d59cbb37\nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1\nCurrent Time:            Mon Sep 16 14:55:44 2024\nExecutable Timestamp:    Wed Sep 11 14:18:50 2024\n\nParallelism:\n  Num Processors:          2\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   \n    Total:                 22801\n    Local:                 11492\n    Min/Max/Avg:           11309/11492/11400\n  Elems:                   \n    Total:                 22500\n    Local:                 11250\n    Min/Max/Avg:           11250/11250/11250\n  Num Subdomains:          1\n  Num Partitions:          2\n  Partitioner:             metis\n\nNonlinear System:\n  Num DOFs:                159607\n  Num Local DOFs:          80444\n  Variables:               { \"c\" \"eta0\" \"eta1\" \"c0\" \"c1\" } { \"disp_x\" \"disp_y\" } \n  Finite Element Types:    \"LAGRANGE\" \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                90301\n  Num Local DOFs:          45242\n  Variables:               \"Energy\" \"stress_xx\" \"e_xx\" \"bounds_dummy\" \n  Finite Element Types:    \"MONOMIAL\" \"MONOMIAL\" \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"CONSTANT\" \"CONSTANT\" \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             IterationAdaptiveDT\n  TimeIntegrator:          ImplicitEuler\n  Solver Mode:             Preconditioned JFNK\n  PETSc Preconditioner:    lu \n  MOOSE Preconditioner:    SMP\n\nCurrently Executing\n  Performing Initial Setup\n    Finished Setting Up Initial Conditions                                               [\ufffd[33m  0.24 s\ufffd[39m] [\ufffd[33m  643 MB\ufffd[39m]\n  Finished Performing Initial Setup                                                      [\ufffd[33m  1.38 s\ufffd[39m] [\ufffd[33m  675 MB\ufffd[39m]\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\n\nTime Step 1, time = 0.0005, dt = 0.0005\n 0 Nonlinear |R| = \ufffd[32m3.867241e+04\ufffd[39m\n      0 Linear |R| = \ufffd[32m3.867241e+04\ufffd[39m\n      1 Linear |R| = \ufffd[33m3.867241e+04\ufffd[39m\n      2 Linear |R| = \ufffd[33m3.867241e+04\ufffd[39m\n      3 Linear |R| = \ufffd[33m3.867240e+04\ufffd[39m\n      4 Linear |R| = \ufffd[33m3.867235e+04\ufffd[39m\n      5 Linear |R| = \ufffd[33m3.867210e+04\ufffd[39m\n      6 Linear |R| = \ufffd[33m3.867025e+04\ufffd[39m\n      7 Linear |R| = \ufffd[33m3.867025e+04\ufffd[39m\n      8 Linear |R| = \ufffd[33m3.867011e+04\ufffd[39m\n      9 Linear |R| = \ufffd[33m3.867011e+04\ufffd[39m\n     10 Linear |R| = \ufffd[33m3.866875e+04\ufffd[39m\n     11 Linear |R| = \ufffd[33m3.866621e+04\ufffd[39m\n     12 Linear |R| = \ufffd[33m3.866498e+04\ufffd[39m\n     13 Linear |R| = \ufffd[33m3.865598e+04\ufffd[39m\n     14 Linear |R| = \ufffd[33m3.861835e+04\ufffd[39m\n     15 Linear |R| = \ufffd[33m3.861363e+04\ufffd[39m\n     16 Linear |R| = \ufffd[33m3.861319e+04\ufffd[39m\n     17 Linear |R| = \ufffd[33m3.861305e+04\ufffd[39m\n     18 Linear |R| = \ufffd[33m3.847891e+04\ufffd[39m\n     19 Linear |R| = \ufffd[33m3.841992e+04\ufffd[39m\n     20 Linear |R| = \ufffd[33m3.841864e+04\ufffd[39m\n     21 Linear |R| = \ufffd[33m3.838637e+04\ufffd[39m\n     22 Linear |R| = \ufffd[33m3.829653e+04\ufffd[39m\n     23 Linear |R| = \ufffd[33m3.828652e+04\ufffd[39m\n     24 Linear |R| = \ufffd[33m3.821860e+04\ufffd[39m\n     25 Linear |R| = \ufffd[33m3.821019e+04\ufffd[39m\n     26 Linear |R| = \ufffd[33m3.813820e+04\ufffd[39m\n     27 Linear |R| = \ufffd[33m3.803107e+04\ufffd[39m\n     28 Linear |R| = \ufffd[33m3.801110e+04\ufffd[39m\n     29 Linear |R| = \ufffd[33m3.799088e+04\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 1 Nonlinear |R| = \ufffd[33m3.867241e+04\ufffd[39m\n      0 Linear |R| = \ufffd[32m3.867241e+04\ufffd[39m\n      1 Linear |R| = \ufffd[33m3.867239e+04\ufffd[39m\n      2 Linear |R| = \ufffd[33m3.867224e+04\ufffd[39m\n      3 Linear |R| = \ufffd[33m3.866658e+04\ufffd[39m\n      4 Linear |R| = \ufffd[33m3.863841e+04\ufffd[39m\n      5 Linear |R| = \ufffd[33m3.856503e+04\ufffd[39m\n      6 Linear |R| = \ufffd[33m3.780299e+04\ufffd[39m\n      7 Linear |R| = \ufffd[33m3.761568e+04\ufffd[39m\n      8 Linear |R| = \ufffd[33m3.760762e+04\ufffd[39m\n      9 Linear |R| = \ufffd[33m3.745536e+04\ufffd[39m\n     10 Linear |R| = \ufffd[33m3.727775e+04\ufffd[39m\n     11 Linear |R| = \ufffd[33m3.715244e+04\ufffd[39m\n     12 Linear |R| = \ufffd[33m3.560428e+04\ufffd[39m\n     13 Linear |R| = \ufffd[33m3.421370e+04\ufffd[39m\n     14 Linear |R| = \ufffd[33m3.418394e+04\ufffd[39m\n     15 Linear |R| = \ufffd[33m3.371675e+04\ufffd[39m\n     16 Linear |R| = \ufffd[33m3.354023e+04\ufffd[39m\n     17 Linear |R| = \ufffd[33m3.336458e+04\ufffd[39m\n     18 Linear |R| = \ufffd[33m3.252735e+04\ufffd[39m\n     19 Linear |R| = \ufffd[32m2.777352e+04\ufffd[39m\n     20 Linear |R| = \ufffd[33m2.659539e+04\ufffd[39m\n     21 Linear |R| = \ufffd[33m2.608524e+04\ufffd[39m\n     22 Linear |R| = \ufffd[33m2.491752e+04\ufffd[39m\n     23 Linear |R| = \ufffd[33m2.491735e+04\ufffd[39m\n     24 Linear |R| = \ufffd[33m2.476447e+04\ufffd[39m\n     25 Linear |R| = \ufffd[33m2.361111e+04\ufffd[39m\n     26 Linear |R| = \ufffd[33m2.286284e+04\ufffd[39m\n     27 Linear |R| = \ufffd[33m2.269276e+04\ufffd[39m\n     28 Linear |R| = \ufffd[33m2.268898e+04\ufffd[39m\n     29 Linear |R| = \ufffd[33m2.162033e+04\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 2 Nonlinear |R| = \ufffd[32m2.589565e+04\ufffd[39m\n      0 Linear |R| = \ufffd[32m2.589565e+04\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.144917e+02\ufffd[39m\n      2 Linear |R| = \ufffd[32m1.939679e-01\ufffd[39m\n 3 Nonlinear |R| = \ufffd[32m1.718004e+03\ufffd[39m\n      0 Linear |R| = \ufffd[32m1.718004e+03\ufffd[39m\n      1 Linear |R| = \ufffd[32m6.564048e-01\ufffd[39m\n 4 Nonlinear |R| = \ufffd[32m1.054581e+01\ufffd[39m\n      0 Linear |R| = \ufffd[32m1.054581e+01\ufffd[39m\n      1 Linear |R| = \ufffd[32m2.552648e-03\ufffd[39m\n 5 Nonlinear |R| = \ufffd[32m2.544406e-03\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m 96.31 s\ufffd[39m] [\ufffd[33m  808 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m7.603077e-12\ufffd[39m\n  eta0: \ufffd[31m2.561580e-04\ufffd[39m\n  eta1: \ufffd[31m4.820619e-14\ufffd[39m\n  c0: \ufffd[31m2.340218e-12\ufffd[39m\n  c1: \ufffd[31m2.140194e-06\ufffd[39m\n  disp_x: \ufffd[31m2.451197e-03\ufffd[39m\n  disp_y: \ufffd[31m6.324660e-04\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\n  Adapting Mesh\n  Finished Adapting Mesh                                                                 [\ufffd[33m 14.45 s\ufffd[39m] [\ufffd[33m 1252 MB\ufffd[39m]\n\nTime Step 2, time = 0.0011, dt = 0.0006\n 0 Nonlinear |R| = \ufffd[32m6.006612e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.86 s\ufffd[39m] [\ufffd[33m 1407 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m6.006612e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m5.328848e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m5.316300e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.75 s\ufffd[39m] [\ufffd[33m 3488 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m5.316300e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m7.714357e-07\ufffd[39m\n      2 Linear |R| = \ufffd[32m7.090030e-11\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m1.255470e-10\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m110.95 s\ufffd[39m] [\ufffd[33m 1544 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m9.528201e-11\ufffd[39m\n  eta0: \ufffd[31m7.168654e-11\ufffd[39m\n  eta1: \ufffd[31m7.472552e-13\ufffd[39m\n  c0: \ufffd[31m3.539682e-11\ufffd[39m\n  c1: \ufffd[31m1.974631e-13\ufffd[39m\n  disp_x: \ufffd[31m1.640355e-11\ufffd[39m\n  disp_y: \ufffd[31m4.671379e-12\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\n  Adapting Mesh\n  Finished Adapting Mesh                                                                 [\ufffd[33m 17.39 s\ufffd[39m] [\ufffd[33m 1393 MB\ufffd[39m]\n\nTime Step 3, time = 0.00182, dt = 0.00072\n 0 Nonlinear |R| = \ufffd[32m1.786843e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  8.21 s\ufffd[39m] [\ufffd[33m 1551 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.786843e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.523108e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m1.522840e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.79 s\ufffd[39m] [\ufffd[33m 3785 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.522840e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.674963e-07\ufffd[39m\n      2 Linear |R| = \ufffd[32m3.133248e-11\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m9.677091e-11\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m128.34 s\ufffd[39m] [\ufffd[33m 1482 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m8.186533e-11\ufffd[39m\n  eta0: \ufffd[31m2.438065e-11\ufffd[39m\n  eta1: \ufffd[31m7.638718e-13\ufffd[39m\n  c0: \ufffd[31m3.699846e-11\ufffd[39m\n  c1: \ufffd[31m1.932151e-13\ufffd[39m\n  disp_x: \ufffd[31m2.568946e-11\ufffd[39m\n  disp_y: \ufffd[31m6.229445e-12\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n|   1.820000e-03 |   4.500000e+04 |   9.945580e+05 |   6.519926e+01 |   8.993480e+04 |   5.509244e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 4, time = 0.002684, dt = 0.000864\n 0 Nonlinear |R| = \ufffd[32m1.217144e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.55 s\ufffd[39m] [\ufffd[33m 1501 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.217144e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.515804e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m1.515815e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.57 s\ufffd[39m] [\ufffd[33m 3779 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.515815e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m5.053920e-08\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m5.053913e-08\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m123.99 s\ufffd[39m] [\ufffd[33m 1492 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m2.321059e-12\ufffd[39m\n  eta0: \ufffd[31m5.042481e-08\ufffd[39m\n  eta1: \ufffd[31m2.414986e-14\ufffd[39m\n  c0: \ufffd[31m1.172858e-12\ufffd[39m\n  c1: \ufffd[31m6.881574e-15\ufffd[39m\n  disp_x: \ufffd[31m3.226314e-09\ufffd[39m\n  disp_y: \ufffd[31m1.064560e-09\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n|   1.820000e-03 |   4.500000e+04 |   9.945580e+05 |   6.519926e+01 |   8.993480e+04 |   5.509244e+03 |\n|   2.684000e-03 |   4.500000e+04 |   9.945580e+05 |   6.521072e+01 |   8.993479e+04 |   5.509244e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 5, time = 0.0037208, dt = 0.0010368\n 0 Nonlinear |R| = \ufffd[32m1.212686e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.61 s\ufffd[39m] [\ufffd[33m 1511 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.212686e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.819112e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m1.819128e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.47 s\ufffd[39m] [\ufffd[33m 3788 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.819128e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m6.065502e-08\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m6.065484e-08\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m121.59 s\ufffd[39m] [\ufffd[33m 1568 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m2.120318e-12\ufffd[39m\n  eta0: \ufffd[31m6.051764e-08\ufffd[39m\n  eta1: \ufffd[31m2.414130e-14\ufffd[39m\n  c0: \ufffd[31m1.178198e-12\ufffd[39m\n  c1: \ufffd[31m7.662110e-15\ufffd[39m\n  disp_x: \ufffd[31m3.871935e-09\ufffd[39m\n  disp_y: \ufffd[31m1.277637e-09\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n|   1.820000e-03 |   4.500000e+04 |   9.945580e+05 |   6.519926e+01 |   8.993480e+04 |   5.509244e+03 |\n|   2.684000e-03 |   4.500000e+04 |   9.945580e+05 |   6.521072e+01 |   8.993479e+04 |   5.509244e+03 |\n|   3.720800e-03 |   4.500000e+04 |   9.945580e+05 |   6.522447e+01 |   8.993478e+04 |   5.509244e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 6, time = 0.00496496, dt = 0.00124416\n 0 Nonlinear |R| = \ufffd[32m1.207379e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.36 s\ufffd[39m] [\ufffd[33m 1568 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.207379e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m2.183145e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m2.183168e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.34 s\ufffd[39m] [\ufffd[33m 3818 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m2.183168e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m7.279718e-08\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m7.279711e-08\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m121.23 s\ufffd[39m] [\ufffd[33m 1591 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m2.161549e-12\ufffd[39m\n  eta0: \ufffd[31m7.263246e-08\ufffd[39m\n  eta1: \ufffd[31m2.419832e-14\ufffd[39m\n  c0: \ufffd[31m1.186779e-12\ufffd[39m\n  c1: \ufffd[31m9.005750e-15\ufffd[39m\n  disp_x: \ufffd[31m4.646854e-09\ufffd[39m\n  disp_y: \ufffd[31m1.533397e-09\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n|   1.820000e-03 |   4.500000e+04 |   9.945580e+05 |   6.519926e+01 |   8.993480e+04 |   5.509244e+03 |\n|   2.684000e-03 |   4.500000e+04 |   9.945580e+05 |   6.521072e+01 |   8.993479e+04 |   5.509244e+03 |\n|   3.720800e-03 |   4.500000e+04 |   9.945580e+05 |   6.522447e+01 |   8.993478e+04 |   5.509244e+03 |\n|   4.964960e-03 |   4.500000e+04 |   9.945580e+05 |   6.524097e+01 |   8.993476e+04 |   5.509244e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 7, time = 0.00645795, dt = 0.00149299\n 0 Nonlinear |R| = \ufffd[32m1.201069e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.79 s\ufffd[39m] [\ufffd[33m 1591 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.201069e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m2.620077e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m2.620109e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.73 s\ufffd[39m] [\ufffd[33m 3818 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m2.620109e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m8.737295e-08\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m8.737272e-08\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m123.53 s\ufffd[39m] [\ufffd[33m 1576 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m2.549443e-12\ufffd[39m\n  eta0: \ufffd[31m8.717512e-08\ufffd[39m\n  eta1: \ufffd[31m2.412127e-14\ufffd[39m\n  c0: \ufffd[31m1.178910e-12\ufffd[39m\n  c1: \ufffd[31m1.119583e-14\ufffd[39m\n  disp_x: \ufffd[31m5.576988e-09\ufffd[39m\n  disp_y: \ufffd[31m1.840444e-09\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n|   1.820000e-03 |   4.500000e+04 |   9.945580e+05 |   6.519926e+01 |   8.993480e+04 |   5.509244e+03 |\n|   2.684000e-03 |   4.500000e+04 |   9.945580e+05 |   6.521072e+01 |   8.993479e+04 |   5.509244e+03 |\n|   3.720800e-03 |   4.500000e+04 |   9.945580e+05 |   6.522447e+01 |   8.993478e+04 |   5.509244e+03 |\n|   4.964960e-03 |   4.500000e+04 |   9.945580e+05 |   6.524097e+01 |   8.993476e+04 |   5.509244e+03 |\n|   6.457952e-03 |   4.500000e+04 |   9.945580e+05 |   6.526078e+01 |   8.993474e+04 |   5.509244e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/28649#discussioncomment-10675758",
                          "updatedAt": "2024-09-17T23:32:46Z",
                          "publishedAt": "2024-09-17T23:32:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "nl_rel_tol could be tighter but I think the convergence looks good enough.\nYou might want to confer with phase field experts",
                          "url": "https://github.com/idaholab/moose/discussions/28649#discussioncomment-10675786",
                          "updatedAt": "2024-09-17T23:40:40Z",
                          "publishedAt": "2024-09-17T23:40:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "Yeah. When I had two precipitates, they evolved into reasonable sizes but after I modified to one and started tracking the average area they grew uncontrollably. Can you tag someone on my behalf?",
                          "url": "https://github.com/idaholab/moose/discussions/28649#discussioncomment-10675825",
                          "updatedAt": "2024-09-17T23:52:32Z",
                          "publishedAt": "2024-09-17T23:52:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@amjokisaari @dschwen",
                          "url": "https://github.com/idaholab/moose/discussions/28649#discussioncomment-10675897",
                          "updatedAt": "2024-09-18T00:17:00Z",
                          "publishedAt": "2024-09-18T00:16:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}