{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNS0wMy0wNFQxNDowNTo0MC0wNzowMM4Aeqs8"
    },
    "edges": [
      {
        "node": {
          "title": "Adding a custom diffusion term",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI wanted to add the following term to a transport equation for c:\n\nHere c is the main nonlinear variable for my particular equation, and \\phi is the coupled nonlinear variable. Is it possible to store an auxiliary variable for \\nabla\\phi . \\nabla\\phi and call it E and then use it to implement the following\n\nPlease let me know if there is a better way to implement this term.\nThanks,\nAli",
          "url": "https://github.com/idaholab/moose/discussions/30047",
          "updatedAt": "2025-03-06T23:38:33Z",
          "publishedAt": "2025-03-06T23:30:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nIs it possible to store an auxiliary variable for \\nabla\\phi . \\nabla\\phi and call it E and then use it to implement the following\n\nCertainly is possible. Though keep in the mind auxiliary variables don't work with automatic differentiation so you will have to write the Jacobian term manually.\nI would :\n\nintegrate by parts the term to remove the outer divergence term\nexpand the gradient of grad phi times grad phi\nuse a second order variable for phi so that this term is nonzero (make sure the Mesh is second order, or convert with Mesh/second_order=true_\nwhether using AD or not, the term can now be written easily using coupledSecond/adCoupledSecond to retrieve the phi derivatives\n\nimplementing it two different ways and examining the results is a good way to get it right",
                  "url": "https://github.com/idaholab/moose/discussions/30047#discussioncomment-12419933",
                  "updatedAt": "2025-03-06T23:38:34Z",
                  "publishedAt": "2025-03-06T23:38:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Subapp (when executed on MULTIAPP_FIXED_POINT_BEGIN) solution update wrongly if fixed point iterates more than 1",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nIssue description\nIn a multiapp system, when the subapp's execute_on=MULTIAPP_FIXED_POINT_BEGIN and the number of fixed point iteration exceeds 1, the subapp solution will not be updated. From the console output information we can see that the subapp executes all steps as usual, but the solution is not updated. I have reproduced this issue on both conda environment and HPC installation.\nTo reproduce the issue\nMoose's version that is giving this issue to me\nMOOSE Version:           git commit 33ae80ec85 on 2025-02-10\nLibMesh Version:         \nPETSc Version:           3.22.1\nSLEPc Version:           3.22.1\n\nInput deck\nA simple problem that reproduce the issue will be posted in the following comment section\nExpected behaviors\nNormal result\nThis will give you a normal results where the temperature field solved in the subapp is successfully updated and transferred to the main app\nitr=2 # this can be any number\n _execute_on=TIMESTEP_BEGIN\n\nwith example csv results\ntime,T10,Tmax,Tmed,Tmin\n0,0,0,0,0\n0.1,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n0.2,300.95738602135,345.60741454915,322.80371374336,300.00001293757\n0.3,302.26890341423,368.25099586961,334.1255347396,300.00007360958\n0.4,304.12307975971,390.65392143627,345.32710706579,300.00029269532\n0.5,306.43815208062,412.70393011112,356.35242279925,300.00091548738\n0.6,309.13393345952,434.30175925264,367.15208112657,300.00240300051\n0.7,312.14264025838,455.37068834537,377.68810087517,300.00551340497\n0.8,315.40946226991,475.8584980048,387.93493398591,300.01136996701\n0.9,318.89055377774,495.73498299563,397.87824348904,300.02150398245\n1,322.55078324441,514.98769972472,407.51278345666,300.03786718861\n\nAbnormal result\nWith this\n itr=2\n_execute_on=MULTIAPP_FIXED_POINT_BEGIN\n\nin subapp the temperature field is solved as the console output reports normal nonlinear residual behavior\ntemp0: Time Step 9, time = 0.9, dt = 0.1\ntemp0:  0 Nonlinear |R| = 4.203058e+01\ntemp0:  1 Nonlinear |R| = 3.352155e-13\ntemp0:  Solve Converged!\n\nbut the results is not updated. An example temperature reported by the subapp csv is\ntime,T10,Tmax,Tmed,Tmin\n0,0,0,0,0\n0.1,0,0,0,0\n0.2,0,0,0,0\n0.3,0,0,0,0\n0.4,0,0,0,0\n0.5,0,0,0,0\n0.6,0,0,0,0\n0.7,0,0,0,0\n0.8,0,0,0,0\n0.9,0,0,0,0\n1,0,0,0,0\n\nHowever, the main app result move forward by 1 step (only)\ntime,T10,Tmax,Tmed,Tmin\n0,0,0,0,0\n0.1,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n0.2,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n0.3,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n0.4,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n0.5,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n0.6,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n0.7,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n0.8,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n0.9,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n1,300.23059129783,322.8302654104,311.41513330067,300.00000119095\n\nWhen the fixed point scheme iterates more than 1, somehow the subapp loses its step 1 solution and go back to step0 but mainapp still receive the step 1 solution. Then the next step when subapp is called, it is still computing step 0+1.\nSupplementary result: restrict the max_itr=1\nWith\n itr=1\n_execute_on=MULTIAPP_FIXED_POINT_BEGIN\n\nthe result will go back to normal behavior.\nMore info\nA moose version that is not giving this issue\nMOOSE Version:           git commit af2039e2a4 on 2024-01-28\nLibMesh Version:         \nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1",
          "url": "https://github.com/idaholab/moose/discussions/29898",
          "updatedAt": "2025-03-06T18:35:04Z",
          "publishedAt": "2025-02-17T20:21:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "BoZeng1997"
                  },
                  "bodyText": "bug_main.i\n# unit m, kg, s\n\nA=8e8\nT_h=300\ndt=0.1\n\n##########\n# Please uncomment one section to see different behaviors\n############\n\n# This set of para will give normal behavior\n# itr=2\n# _execute_on=TIMESTEP_BEGIN\n\n# This set of para will give normal behavior\n# itr=1\n# _execute_on=MULTIAPP_FIXED_POINT_BEGIN\n\n# subapp solution is not updated\nitr=2\n_execute_on=MULTIAPP_FIXED_POINT_BEGIN\n\n[Problem]\n  type = FEProblem\n  verbose_multiapps = true\n  solve = False\n  kernel_coverage_check = false\n  material_coverage_check = false\n[]\n\n[MultiApps]\n  [temp]\n    type = TransientMultiApp\n    input_files = bug_sub.i\n    cli_args = 'T_h=${T_h};A=${A};dt=${dt};_execute_on=${_execute_on};itr=${itr}'\n    execute_on = ${_execute_on}\n  []\n[]\n\n[Transfers]\n  [from_temp]\n    type = MultiAppCopyTransfer\n    from_multi_app = temp\n    variable = 'T_K '\n    source_variable = 'T_K '\n    execute_on = SAME_AS_MULTIAPP\n  []\n[]\n\n[Mesh]\n  [ori]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 15\n    xmax = 15e-3\n    ny = 15\n    ymax = 15e-3\n  []\n[]\n\n[AuxVariables]\n  [T_K]\n    [InitialCondition]\n      type = ConstantIC\n      value = ${T_h}\n    []\n  []\n[]\n\n\n[Debug]\n  show_var_residual_norms = TRUE\n  # show_execution_order = MULTIAPP_FIXED_POINT_BEGIN\n[]\n\n\n[Postprocessors]\n  [T10]\n    type = PointValue\n    point = '10e-3 0 0'\n    variable = T_K\n  []\n  [Tmin]\n    type = NodalExtremeValue\n    variable = T_K\n    value_type = min\n  []\n  [Tmax]\n    type = NodalExtremeValue\n    variable = T_K\n    value_type = max\n  []\n  [Tmed]\n    type = ParsedPostprocessor\n    expression = '0.5*(Tmax+Tmin)'\n    pp_names = 'Tmax Tmin'\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu      superlu_dist    '\n  automatic_scaling = true\n  # auto_advance=true\n  line_search = bt\n  compute_scaling_once = true # true #is recommended\n\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-8\n  nl_max_its = 200\n\n  l_max_its = 10000\n  dtmin = 1e-9\n  start_time = 0\n  end_time = 1\n  dt = ${dt}\n\n  fixed_point_max_its = ${itr}\n  fixed_point_min_its = ${itr}\n  accept_on_max_fixed_point_iteration = true\n  verbose=true\n[]\n\n[Outputs]\n  [nemesis]\n    type = Exodus\n  []\n  [csv]\n    type = CSV\n  []\n  file_base = '${_execute_on}_itr${itr}/${_execute_on}_itr${itr}'\n  print_linear_residuals = false\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/29898#discussioncomment-12228908",
                  "updatedAt": "2025-02-17T20:22:59Z",
                  "publishedAt": "2025-02-17T20:22:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "bug_sub.i\n# unit m, kg, s\n\n\nspecific_heat = 880 # J/(kg K)\nthermal_conductivity = 25.0 # W/(mK)\ndensity = 3980 #kg/m^3\n\n\n[Problem]\n  type = FEProblem\n  # solve = False\n[]\n\n[Mesh]\n  [ori]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 15\n    xmax = 15e-3\n    ny = 15\n    ymax = 15e-3\n  []\n  [inner]\n    type = ParsedSubdomainMeshGenerator\n    input = ori\n    block_id=1\n    block_name = 'inner'\n    combinatorial_geometry = 'sqrt((x)^2+y^2)<=7.25e-3'\n  []\n[]\n\n[Variables]\n  [T_K]\n    [InitialCondition]\n      type = ConstantIC\n      value = ${T_h}\n    []\n  []\n[]\n\n\n[Kernels]\n  [timeder]\n    type = ADHeatConductionTimeDerivative\n    variable = 'T_K'\n    density_name = density\n    specific_heat = specific_heat\n    use_displaced_mesh = false\n  []\n  [diff]\n    type = ADHeatConduction\n    variable = 'T_K'\n    thermal_conductivity = thermal_conductivity\n    use_displaced_mesh = false\n  []\n  [heatsource]\n    type = ADMatHeatSource\n    variable = 'T_K'\n    material_property = heating\n    block = inner\n    use_displaced_mesh = false\n  []\n[]\n\n\n[Materials]\n  [heating]\n    type = ADParsedMaterial\n    property_name = heating\n    constant_names = 'A'\n    constant_expressions = '${A}'\n    expression = 'A'\n    block = 'inner'\n    use_displaced_mesh = false\n  []\n  [bulk]\n    type = ADGenericConstantMaterial\n    prop_names = 'density thermal_conductivity specific_heat'\n    prop_values = '${density} ${thermal_conductivity} ${specific_heat}'\n  []\n[]\n\n[Postprocessors]\n  [T10]\n    type = PointValue\n    point = '10e-3 0 0'\n    variable = T_K\n  []\n  [Tmin]\n    type = NodalExtremeValue\n    variable = T_K\n    value_type = min\n  []\n  [Tmax]\n    type = NodalExtremeValue\n    variable = T_K\n    value_type = max\n  []\n  [Tmed]\n    type = ParsedPostprocessor\n    expression = '0.5*(Tmax+Tmin)'\n    pp_names = 'Tmax Tmin'\n  []\n[]\n\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n    # petsc_options_iname = '-pc_type -pc_hypre_type '\n    # petsc_options_value = 'hypre boomeramg '\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu      superlu_dist    '\n  automatic_scaling = true\n\n  line_search = bt\n  compute_scaling_once = true # true #is recommended\n\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-8\n  nl_max_its = 20\n  # l_abs_tol = 1e-9\n  l_tol = 1e-5\n  l_max_its = 10000\n  dtmin = 1e-9\n  start_time = 0\n  dt = '${dt}'\n  # auto_advance=true\n[]\n\n\n[Outputs]\n  [nemesis]\n    type = Exodus\n  []\n  [csv]\n    type = CSV\n  []\n  file_base = '${_execute_on}_itr${itr}/${_execute_on}_itr${itr}_temp'\n  print_linear_residuals = false\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/29898#discussioncomment-12228910",
                          "updatedAt": "2025-02-17T20:23:37Z",
                          "publishedAt": "2025-02-17T20:23:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Thanks for reporting. I ll confirm the issue then we'll open an issue",
                  "url": "https://github.com/idaholab/moose/discussions/29898#discussioncomment-12232375",
                  "updatedAt": "2025-02-18T05:57:20Z",
                  "publishedAt": "2025-02-18T05:57:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "@GiudGiud Any news?",
                          "url": "https://github.com/idaholab/moose/discussions/29898#discussioncomment-12417568",
                          "updatedAt": "2025-03-06T18:25:38Z",
                          "publishedAt": "2025-03-06T18:25:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "nope, I ll look at this after the MOOSE conference.",
                          "url": "https://github.com/idaholab/moose/discussions/29898#discussioncomment-12417661",
                          "updatedAt": "2025-03-06T18:35:05Z",
                          "publishedAt": "2025-03-06T18:35:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Obtaining timing data for non-linear iterations",
          "author": {
            "login": "TheBEllis"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi MOOSE dev team,\nI'm looking for a way to output timing data for each non-linear iteration of a simulation. I just want to get the time it takes for each non-linear iteration to converge.\nI've looked at the IterationInfo reporter, but while it can output the number of non-linear iterations, from what I can tell it doesn't output the time taken by each iteration. I've also looked at the PerfGraphOutput documentation, the Outputs System documentation and other questions on the discussion forum and can't seem to find anything.\nAny pointers in the right direction would be much appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/30024",
          "updatedAt": "2025-03-06T18:24:46Z",
          "publishedAt": "2025-03-05T14:28:21Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou could modify the code that sets the perf graph section to include the iteration number in the name\nThis would then create different timed sections for each iteration\nAlternatively, you could make the threshold for printing a section's time very small, then every section would report their time in the log\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/30024#discussioncomment-12403400",
                  "updatedAt": "2025-03-05T15:53:16Z",
                  "publishedAt": "2025-03-05T15:53:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheBEllis"
                          },
                          "bodyText": "Cheers Guillaume, that's exactly what I needed, looking at PerfGraph instead of PerfGraphOuput docs made it clear.\nI'm trying to find a function in NonlinearSystemBase.C that has scope which is consistent with the time taken to complete a singular non-linear iteration but am currently struggling, do you happen to have any suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/30024#discussioncomment-12417256",
                          "updatedAt": "2025-03-06T17:53:17Z",
                          "publishedAt": "2025-03-06T17:53:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you use computeResidual and computeJacobian in the FEProblem ? This will let you get the assembly time for each iteration\nSolve time I am not sure yet. Maybe petsc has some timing options",
                          "url": "https://github.com/idaholab/moose/discussions/30024#discussioncomment-12417531",
                          "updatedAt": "2025-03-06T18:21:33Z",
                          "publishedAt": "2025-03-06T18:21:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok for the solve, we call the libmesh solve from the MOOSE system base solve\n  if (time_integrator_solve)\n    _time_integrators.front()->solve();\n  else\n    system().solve();\n\nso there's no timing capability on a per-iteration basis there",
                          "url": "https://github.com/idaholab/moose/discussions/30024#discussioncomment-12417558",
                          "updatedAt": "2025-03-06T18:24:47Z",
                          "publishedAt": "2025-03-06T18:24:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fault modeling using Contact Module",
          "author": {
            "login": "NeohopeNY"
          },
          "bodyText": "Hi,\nI am trying to model a vertical fault in an elastic medium for a circular cavity that is submitted to a biaxial stress.\nThe rock mass on the left is called left rock, the rock mass on the right is called rightrock and the the line in between is called 'fault' (see the mesh below). I would like to model the fault as a discontinuity with no penetrability and with friction tangential contact.\n\nIn moose, I am using the Contact module. However, even if the script converges, I am not sure if it is the right way to proceed as perhaps I should create two lines to model the fault. Could you please let me know?  Here is my code: https://github.com/NeohopeNY/Fault.git\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/30013",
          "updatedAt": "2025-03-05T21:25:42Z",
          "publishedAt": "2025-03-03T22:54:44Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo the fault, is that the equivalent to a fracture problem?\nIf so we have XFEM capabilities for that purpose\nGuilllaume",
                  "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12382578",
                  "updatedAt": "2025-03-04T01:46:04Z",
                  "publishedAt": "2025-03-04T01:46:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "NeohopeNY"
                          },
                          "bodyText": "Hello, thanks for your reply. It's not really a fracture that propagates, it's a discontinuity plane where there can be sliding between the two blocks with friction but no penetration. Which module would be best best suited: Contact or XFEM?",
                          "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12388951",
                          "updatedAt": "2025-03-04T14:01:22Z",
                          "publishedAt": "2025-03-04T14:01:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "contact seems better fitted.\ndid you disconnect the mesh where the fault is?",
                          "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12389040",
                          "updatedAt": "2025-03-04T14:08:56Z",
                          "publishedAt": "2025-03-04T14:08:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "NeohopeNY"
                          },
                          "bodyText": "The Mesh is as the one described in the picture above. There is only one line (called fault) between the left and right blocks.  On this line the nodes are the same for the left and right blocks. I guess there are connected then. How would you disconnect the two blocks? By creating two lines?",
                          "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12389112",
                          "updatedAt": "2025-03-04T14:15:20Z",
                          "publishedAt": "2025-03-04T14:15:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can use this mesh generator to disconnect blocks\nhttps://mooseframework.inl.gov/source/meshgenerators/BreakMeshByBlockGenerator.html",
                          "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12389268",
                          "updatedAt": "2025-03-04T14:27:36Z",
                          "publishedAt": "2025-03-04T14:27:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "NeohopeNY"
                          },
                          "bodyText": "I have defined two block names using Gmsh so the nodes should already be disconnected at the interface. However, when I write the following code using Contact module:\n[Contact]\n    [fault_contact]\n      primary = 'leftrock'\n      secondary = 'rightrock'\n      model = coulomb\n      friction_coefficient = 0.2\n      formulation = penalty\n      penalty = 10e9\n      normalize_penalty = true\n    []\n  []\n\nI get the following error:\n\"The following parameter error occurred in the UserObject 'nodal_area_object_0' of type NodalArea.\nboundary:\nthe following side sets (ids) do not exist on the mesh: rightrock (23)\"",
                          "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12389724",
                          "updatedAt": "2025-03-04T15:19:06Z",
                          "publishedAt": "2025-03-04T15:06:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "use --mesh-only to see a summary of what exists and does not in the mesh. If it does not exist, you have to go back to gmsh or work on re-generating it using mesh generators in moose",
                          "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12389889",
                          "updatedAt": "2025-03-04T15:19:44Z",
                          "publishedAt": "2025-03-04T15:19:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "NeohopeNY"
                          },
                          "bodyText": "Dear GiudGiud,\nI hope you are doing well!\nI have simplified the problem to model a simple diagonal fault in a continuous elastic domain. Now, the nodes are disconnected at the interface. \"top_fault\" and \"bottom_fault\" correspond to the boundaries of the fault line (see picture below). I am applying Pressure BCs on \"top\", \"bottom\", \"left\" and \"right\" ( with sigma_h < sigma_v).\n\nIn the Contact block (see code below), the primary parameter is set to \"top_fault\" and the secondary parameter is set to \"bottom_fault\".  Still, the code won't converge. Perhaps you would have an idea why?\nThanks!\n[Contact]\n[fault_contact]\nprimary = 'top_fault'\nsecondary = 'bottom_fault'\nmodel = coulomb\nfriction_coefficient = 0.2\nformulation = penalty\npenalty = 10e9\nnormalize_penalty = true\n[]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12403690",
                          "updatedAt": "2025-03-05T16:15:25Z",
                          "publishedAt": "2025-03-05T16:15:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou should try the troubleshooting failed solves instructions on our website first\nAlso this converged without the contact block right?",
                          "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12403810",
                          "updatedAt": "2025-03-05T16:24:37Z",
                          "publishedAt": "2025-03-05T16:24:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "NeohopeNY"
                          },
                          "bodyText": "Without the contact block, it does converge when the nodes are connected on the fault. When the nodes are disconnected, it does does not converge.",
                          "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12404668",
                          "updatedAt": "2025-03-05T17:45:29Z",
                          "publishedAt": "2025-03-05T17:45:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "NeohopeNY"
                          },
                          "bodyText": "Do you know if primary and secondary parameters should refer to the boundaries of the lines \"top_fault\" and \"bottom_fault\" or to the blocks? Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/30013#discussioncomment-12404865",
                          "updatedAt": "2025-03-05T18:06:45Z",
                          "publishedAt": "2025-03-05T18:06:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE defaults vs explicit PETSc calls",
          "author": {
            "login": "Cattaneo123"
          },
          "bodyText": "Greetings\nI've been looking at the solid mechanics cohesive zone example codes and I'm a little confused about what the default behaviors are. In the stretch_rotate_large_deformation.i (https://mooseframework.inl.gov/syntax/Modules/TensorMechanics/CohesiveZoneMaster/) example the solver called is JACOBIAN, that being the MOOSE option. However if I try to recreate the default behavior by passing default Newton to PETSc and the default inner solver (GMRES) as well, I get slightly worse performance.\nWhat's more, if I remove all options the output to console says it uses \"preconditioned JFNK\" and it will converge, but if I pass it the MOOSE options JFNK and a preconditioner it will fail and run forever.\nWhat is the actual default that MOOSE uses, and how do I replicate it through PETSc arguments? I'd like to try using some other solvers (Broyden's Method or LBFGS for example), but I'm hesitant to do so without knowing what needs to be specified. Thank you for your help.",
          "url": "https://github.com/idaholab/moose/discussions/30009",
          "updatedAt": "2025-03-05T20:32:04Z",
          "publishedAt": "2025-03-03T21:56:21Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDefault is PJFNK\nJFNK is not used very often, preconditioning is important",
                  "url": "https://github.com/idaholab/moose/discussions/30009#discussioncomment-12381242",
                  "updatedAt": "2025-03-03T22:00:28Z",
                  "publishedAt": "2025-03-03T22:00:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Cattaneo123"
                          },
                          "bodyText": "So when the console output says \"Solver Mode: Preconditioned JFNK\", the solver it is being passed from the 3 solver options available in MOOSE (https://mooseframework.inl.gov/modules/phase_field/Solving.html) PJFNK, not JFNK.\nIn that case, if I pass a PETSc quasi-newton method in the executioner, why does the console still say \"Solver Mode: Preconditioned JFNK\"? Is that just the default output if one of the other 2 solver types in MOOSE isn't selected? Is that also why attempting to duplicate the performance of the MOOSE Newton solver by passing PETSc options seems to result in poorer performance?",
                          "url": "https://github.com/idaholab/moose/discussions/30009#discussioncomment-12381800",
                          "updatedAt": "2025-03-03T23:36:45Z",
                          "publishedAt": "2025-03-03T23:36:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I don't think we can use different solve types than the explicitly supported ones",
                          "url": "https://github.com/idaholab/moose/discussions/30009#discussioncomment-12381877",
                          "updatedAt": "2025-03-03T23:52:31Z",
                          "publishedAt": "2025-03-03T23:52:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ll check later but the console output is probably only from the supported list. So an unrecognized option would not display as expected",
                          "url": "https://github.com/idaholab/moose/discussions/30009#discussioncomment-12382113",
                          "updatedAt": "2025-03-04T00:32:09Z",
                          "publishedAt": "2025-03-04T00:32:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Cattaneo123"
                          },
                          "bodyText": "I don't think we can use different solve types than the explicitly supported ones\n\nI thought it was possible as there is this post\n#24798\nalthough that is in general so maybe it doesn't extend to the solid mechanic package?",
                          "url": "https://github.com/idaholab/moose/discussions/30009#discussioncomment-12382188",
                          "updatedAt": "2025-03-04T00:43:51Z",
                          "publishedAt": "2025-03-04T00:43:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I was wrong. We can use other solve types, that you set up through petsc options directly.\nIt may not be optimal, and may not work when requiring additional setup (for example newton-arc length)\nalso do not expect moose to report on the correct solve type, it only knows these ones\nstd::string\nstringify(const SolveType & t)\n{\n  switch (t)\n  {\n    case ST_NEWTON:\n      return \"NEWTON\";\n    case ST_JFNK:\n      return \"JFNK\";\n    case ST_PJFNK:\n      return \"Preconditioned JFNK\";\n    case ST_FD:\n      return \"FD\";\n    case ST_LINEAR:\n      return \"Linear\";\n  }\n  return \"\";\n}",
                          "url": "https://github.com/idaholab/moose/discussions/30009#discussioncomment-12382567",
                          "updatedAt": "2025-03-04T01:44:25Z",
                          "publishedAt": "2025-03-04T01:44:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Cattaneo123"
                          },
                          "bodyText": "I see, thank you for your help. Do you happen to know what the NEWTON solver tells PETSc to use?",
                          "url": "https://github.com/idaholab/moose/discussions/30009#discussioncomment-12392426",
                          "updatedAt": "2025-03-04T18:45:30Z",
                          "publishedAt": "2025-03-04T18:45:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Newton is default options I think (not default for MOOSE, that s PFJNK)\nYou can use -options_view to get PETSC to show the options active\nand -snes_view to see PETSc do its thing with the options active",
                          "url": "https://github.com/idaholab/moose/discussions/30009#discussioncomment-12405727",
                          "updatedAt": "2025-03-05T20:37:43Z",
                          "publishedAt": "2025-03-05T19:39:07Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Cattaneo123"
                          },
                          "bodyText": "Thank you, that's exactly what I needed.",
                          "url": "https://github.com/idaholab/moose/discussions/30009#discussioncomment-12406198",
                          "updatedAt": "2025-03-05T20:32:04Z",
                          "publishedAt": "2025-03-05T20:32:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "moose-dev-openmpi module not found",
          "author": {
            "login": "AndrewPanter"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nHello, I am trying to run a MOOSE application on the INL HPC (Sawtooth specifically). I am trying to follow the instructions at https://mooseframework.inl.gov/getting_started/installation/inl_hpc_install_moose.html. I was able to get this work a week or two ago, but now the module load use.moose moose-dev-openmpi/version cannot find the module I need. How can I make this work?\n(Optional) code in question / simulation log / errors\n[pantandr2@sawtooth1 griffin]$ module purge\n[pantandr2@sawtooth1 griffin]$ module load use.moose versioner\n[pantandr2@sawtooth1 griffin]$ moose/scripts/versioner.py moose-dev\n5b49120\n[pantandr2@sawtooth1 griffin]$ module load use.moose moose-dev-openmpi/5b49120\nLmod has detected the following error:  The following module(s) are unknown: \"moose-dev-openmpi/5b49120\"\n\nPlease check the spelling or version number. Also try \"module spider ...\"\nIt is also possible your cache file is out-of-date; it may help to try:\n  $ module --ignore_cache load \"moose-dev-openmpi/5b49120\"\n\nAlso make sure that all modulefiles written in TCL start with the string #%Module\n\n\n\n[pantandr2@sawtooth1 griffin]$\nEncountering Errors? Please include diagnostic output\n####################################################################################################\nInfluential Environment Variables\n\nCONDA_CHANNEL=https://conda.software.inl.gov/public\nCURL_CA_BUNDLE=\nMODULESHOME=/apps/spack/opt/gcc-12.3.0/lmod-8.7.32-jpqjeet2bt3lyiiwrph7mo6iiznyuiea/lmod/lmod\nMOOSE_JOBS=6\nPATH=/apps/moose/stack/versioner/bin:/opt/clmgr/sbin:/opt/clmgr/bin:/opt/sgi/sbin:/opt/sgi/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/opt/c3/bin:/opt/pbs/bin:/home/pantandr2/projects/griffin:/home/pantandr2/projects/griffin/isoxml/contrib/pynjoy/FGLibraryGenerator/build\nREQUESTS_CA_BUNDLE=\nSSL_CERT_FILE=\n####################################################################################################\nCompiler(s) (CC CXX FC F77 F90):\n\nCC\tnot set\nCXX\tnot set\nFC\tnot set\nF77\tnot set\nF90\tnot set\n\nFAIL: One or more compiler environment variables not set, or set incorrectly\n####################################################################################################\nPython Sanity Checks\n\n/usr/bin/env python3 --version; (reporting as: Python 3.12.7) matches\nwhich python3 python;\n\n/apps/moose/stack/versioner/bin/python3 --version; == Python 3.12.7\n/apps/moose/stack/versioner/bin/python --version; == Python 3.12.7\n\nOK\n####################################################################################################\nPython Modules (TestHarness, run-ability)\n\n\nFAIL:    missing module(s): packaging \n\nEither install the above packages, or perhaps you have yet\nto activate the moose environment: conda activate moose\n\nMissing 'failing' Python modules will prevent you from building MOOSE.\n\nFAIL: One or more Python issues present.\n\n\nchecks FAILED",
          "url": "https://github.com/idaholab/moose/discussions/30026",
          "updatedAt": "2025-03-05T19:30:13Z",
          "publishedAt": "2025-03-05T16:26:01Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Use module spider to find all the versions available of moose-dev\nThere is a container workflow on INL HPC",
                  "url": "https://github.com/idaholab/moose/discussions/30026#discussioncomment-12404459",
                  "updatedAt": "2025-03-05T17:25:22Z",
                  "publishedAt": "2025-03-05T17:25:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Use module spider to find all the versions available of moose-dev\nThere is a container workflow on INL HPC. Are you trying to use that?",
                  "url": "https://github.com/idaholab/moose/discussions/30026#discussioncomment-12404560",
                  "updatedAt": "2025-03-05T17:34:42Z",
                  "publishedAt": "2025-03-05T17:34:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AndrewPanter"
                          },
                          "bodyText": "Hi Guillaume, thanks for your reply. Module spider moose-dev-openmpi does pull up multiple versions, but none of them are the version matching the hash that the versioner.py script gave me (5b49120). Yes, I am trying to use the container workflow found here: https://mooseframework.inl.gov/getting_started/installation/inl_hpc_install_moose.html.\nI was able to access this module version last week, but I can't seem to find it now. Is there some reason this version would be deprecated?",
                          "url": "https://github.com/idaholab/moose/discussions/30026#discussioncomment-12404584",
                          "updatedAt": "2025-03-05T17:37:21Z",
                          "publishedAt": "2025-03-05T17:37:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": ", but none of them are the version matching the hash that the versioner.py script gave me (5b49120).\n\nwe don't release containers / moose-dev packages for every version of MOOSE either. Are you using the master branch?",
                          "url": "https://github.com/idaholab/moose/discussions/30026#discussioncomment-12405148",
                          "updatedAt": "2025-03-05T18:34:09Z",
                          "publishedAt": "2025-03-05T18:34:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you are using a version over the last week or so, HPC outages have prevented a release of the constainers. But our documentation still updated the hash for the last container regardless!\nSo you ll just need to use a little older container",
                          "url": "https://github.com/idaholab/moose/discussions/30026#discussioncomment-12405177",
                          "updatedAt": "2025-03-05T18:36:23Z",
                          "publishedAt": "2025-03-05T18:36:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Looks like our instructions are outdated ever since we moved to using dates over hashes... ugh. Sorry for the inconvenience. The latest available moose-dev container you are after is the following:\nmodule load use.moose moose-dev-openmpi/2025.02.27\nEdit:\nCorrection, our instructions are correct... (they were updated a day or so ago)",
                          "url": "https://github.com/idaholab/moose/discussions/30026#discussioncomment-12405224",
                          "updatedAt": "2025-03-05T18:45:11Z",
                          "publishedAt": "2025-03-05T18:40:26Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AndrewPanter"
                          },
                          "bodyText": "Thanks for the help. I do see that the instructions have been updated, but that didn't really change what I was trying to do. the versioner.py script still produced the hash '5b49120' rather than a date. I wonder if a MOOSE submodule update would change that, but I did not want to change the MOOSE version I have. However, since Bitterroot is back up, I checked out the available module versions on there instead, and the one I need is available, though I can't find it on Sawtooth. I'm not sure if this is intentional, as I thought the purpose of the container was to enable MOOSE usage across any of the HPC servers.\nIn any case, because I am able to access the package on Bitterroot, the issue has been resolved. Thanks again for the assistance!",
                          "url": "https://github.com/idaholab/moose/discussions/30026#discussioncomment-12405639",
                          "updatedAt": "2025-03-05T19:29:53Z",
                          "publishedAt": "2025-03-05T19:29:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Variable Number and DOF Mapping in MOOSE",
          "author": {
            "login": "YKumar1999"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello All,\nHave been trying to get the information about the variable number or information which can be then used with DOF mapping to find out the location/index of that variable in the solution vector. I am trying it for my XFEM level set user object. Any suggestions for that ?",
          "url": "https://github.com/idaholab/moose/discussions/30021",
          "updatedAt": "2025-03-05T18:41:53Z",
          "publishedAt": "2025-03-04T20:44:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou generally should not be accessing the solution vector directly.\nBut maybe for some cases in XFEM it might be the best way, I dont know.\nThe index into the solution vector can be retrieved from the DoFObject APIs: dof_number() that is accessible in a Node and an Element\nhttps://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1DofObject.html#a4e8bf039eb9c13b7eb3aaf96afc8c8b8\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/30021#discussioncomment-12405246",
                  "updatedAt": "2025-03-05T18:41:53Z",
                  "publishedAt": "2025-03-05T18:41:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Errorfractionmarker: how does it work?",
          "author": {
            "login": "tqcthai"
          },
          "bodyText": "Dear all,\nI try to understand how ARM work with the errrorfractionmarker. There is an example here, but I don't get it\nhttps://mooseframework.inl.gov/source/markers/ErrorFractionMarker.html\nAccording to the example, we have total error 89, refine fraction is 0.6. As I understand, the elements have the error larger than 89x0.6=53.4 will be refined which shouldn't be elements #7, #9 and #6 as their corresponding errors are under 53.4. Similarly for the coarsen ratio 0.1, we have 89x0.1=8.9 and elements #1, #2, #4, #8, #10 should be coarsen in this case as their errors smaller than 8.9. Am I correct?\nAnother question is about level 2 and higher refinement levels for the transient problem. After being level 1 refinement, are the sub-elements are treated as the parents element in the above framework of computing error and sorting?\nThanks,\nT",
          "url": "https://github.com/idaholab/moose/discussions/26119",
          "updatedAt": "2025-03-05T15:56:13Z",
          "publishedAt": "2023-11-21T22:01:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "You add elements to refine until your aggregate error reaches 53.4 Similarly you add elements to coarsen until you reach an aggregate error of 8.9\nActive elements (regardless of level) are the only elements considered for computing error and for doing refinement/coarsening. Does that answer your question?",
                  "url": "https://github.com/idaholab/moose/discussions/26119#discussioncomment-7635865",
                  "updatedAt": "2023-11-21T22:18:04Z",
                  "publishedAt": "2023-11-21T22:18:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tqcthai"
                          },
                          "bodyText": "In the example on the above link, we have both coarsen and refine ratios. According to your answer, what aggregate errors that the system follows? I guess the aggregate error you indicated is the average error of the whole domain which is unique.\n[Adaptivity]\n  [Indicators]\n    [error]\n      type = AnalyticalIndicator\n      variable = u\n      function = solution\n    []\n  []\n  [Markers]\n    [marker]\n      type = ErrorFractionMarker\n      coarsen = 0.1\n      indicator = error\n      refine = 0.3\n    []\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/26119#discussioncomment-7635915",
                          "updatedAt": "2023-11-21T22:25:40Z",
                          "publishedAt": "2023-11-21T22:25:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The aggregate error of the error indicator. Look at the sum of that variable over the whole mesh",
                          "url": "https://github.com/idaholab/moose/discussions/26119#discussioncomment-7635934",
                          "updatedAt": "2023-11-21T22:28:13Z",
                          "publishedAt": "2023-11-21T22:28:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tqcthai"
                          },
                          "bodyText": "Ok, so it's 89 in the illustrated example. As the explanation from Alex, if I use the refine ratio 0.001, the mesh will generate more refined elements than the refine ratio 0.1 because the expecting error of 0.001 is smaller than the case of 0.1 . Am I correct?",
                          "url": "https://github.com/idaholab/moose/discussions/26119#discussioncomment-7635991",
                          "updatedAt": "2023-11-21T22:37:22Z",
                          "publishedAt": "2023-11-21T22:37:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no you will get less refinement\nThe elements comprising the \"refine\" fraction, from highest error to lowest, of the total error are marked for refinement.\n\nso you will only refine the elements accounting for 1 thousandth of the error as opposed to 10% of the error",
                          "url": "https://github.com/idaholab/moose/discussions/26119#discussioncomment-7636020",
                          "updatedAt": "2023-11-21T22:42:04Z",
                          "publishedAt": "2023-11-21T22:41:50Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "I am also a bit confused about how it works. I checked the source code of ErrorFractionMarker and two important methods are shown below. According to the implementation, firstly the maximum and minimum errors of the whole elements are determined through the loop, then the _refine_cutoff and _coarsen_cutoff are calculated. Here _coarsen_cutoff = _coarsen * _delta + _min seems to be common in mathematics, however, _refine_cutoff = (1.0 - _refine) * _max is a bit weird. It's more intuitive if we define it as _refine_cutoff = _max - _refine * _delta.\nvoid\nErrorFractionMarker::markerSetup()\n{\n  if (_clear_extremes)\n  {\n    _min = std::numeric_limits<Real>::max();\n    _max = 0;\n  }\n\n  // First find the max and min error\n  for (const auto & val : _error_vector)\n  {\n    _min = std::min(_min, static_cast<Real>(val));\n    _max = std::max(_max, static_cast<Real>(val));\n  }\n\n  _delta = _max - _min;\n  _refine_cutoff = (1.0 - _refine) * _max;\n  _coarsen_cutoff = _coarsen * _delta + _min;\n}\n\nMarker::MarkerValue\nErrorFractionMarker::computeElementMarker()\n{\n  Real error = _error_vector[_current_elem->id()];\n\n  if (error > _refine_cutoff)\n    return REFINE;\n  else if (error < _coarsen_cutoff)\n    return COARSEN;\n\n  return DO_NOTHING;\n}",
                          "url": "https://github.com/idaholab/moose/discussions/26119#discussioncomment-12395641",
                          "updatedAt": "2025-03-05T02:22:23Z",
                          "publishedAt": "2025-03-05T02:22:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "however, _refine_cutoff = (1.0 - _refine) * _max is a bit weird.  It's more intuitive if we define it as _refine_cutoff = _max - _refine * _delta.\n\nI think both options make sense in a way, though I do like yours better. Feel free to add a boolean to switch to your option instead",
                          "url": "https://github.com/idaholab/moose/discussions/26119#discussioncomment-12403442",
                          "updatedAt": "2025-03-05T15:56:13Z",
                          "publishedAt": "2025-03-05T15:56:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Usage of muitlapps system",
          "author": {
            "login": "lvkas521424"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nIn order to ensure that I am well applying the basic functions of MOOSE, please allow me to briefly introduce my current work content. I want to use MOOSE to complete the coupling of two external programs, namely the neutronics program and the sub-channel program, that is, the nuclear-thermal coupling.\nCurrently, I have completed the code-level compilation and interface design. My current idea is to encapsulate the two subroutines as two multiapps, and use the multiapp system to complete the scheduling. However, I have doubts.\nFirst, the preprocessing of each individual external program (such as reading the input card) should theoretically only be run once. Should I set them to be executed only once in the code, or is there any other ingenious design?\nSecondly, how should I control my iteration strategy (currently I plan to use the Picard iteration method by multiappcopytransfer)?\nFinally, I would like to ask you whether it is correct that after I use multi app, my current architecture is that the main-app is empty, and the two external programs are sub-app1 and sub-app2 respectively?\nForgive me for some rather funny questions. I am a novice, and because the code is on the intranet, I cannot directly show it to you.\nThanks very much,\nlvkas",
          "url": "https://github.com/idaholab/moose/discussions/30022",
          "updatedAt": "2025-03-05T00:41:46Z",
          "publishedAt": "2025-03-05T00:41:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Issues when installing moose on HPC",
          "author": {
            "login": "saeedvdi"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello!\nI am trying to install moose on computecanada HPC. The wasp and petsc libraries are already installed on the HPC, and I just need to call them and rebuild libmesh. On older Moose versions, I was able to do so; however, on the newer version of Moose, I am not able to install it, and I get the following error.\nThe wasp version is 4.2.0 and the petsc version is 3.21.6.\nI am also calling these dependencies as well: python scipy-stack petsc slepc vtk parmetis wasp eigen boost.\nhome/saeedvdi/projects/def-biaoli66/saeedvdi/projects/moose/framework/contrib/hit/src/hit/parse.cc:1246:44: error: 'is_override' is not a member of 'wasp'\n1246 |         bool override_for_old_node = wasp::is_override(found_field->getNodeView());\n|                                            ^~~~~~~~~~~\n/home/saeedvdi/projects/def-biaoli66/saeedvdi/projects/moose/framework/contrib/hit/src/hit/parse.cc:1247:44: error: 'is_override' is not a member of 'wasp'\n1247 |         bool override_for_new_node = wasp::is_override(hnv_child);\n|                                            ^~~~~~~~~~~\nCompiling C++ (in opt mode) /home/saeedvdi/projects/def-biaoli66/saeedvdi/projects/moose/framework/contrib/exodiff/STRINGLIB_tokenize.C...\nmake: *** [/home/saeedvdi/projects/def-biaoli66/saeedvdi/projects/moose/framework/build.mk:135: /home/saeedvdi/projects/def-biaoli66/saeedvdi/projects/moose/framework/contrib/hit/src/hit/parse.x86_64-pc-linux-gnu.opt.lo] Error 1\nmake: *** Waiting for unfinished jobs....\n/home/saeedvdi/projects/def-biaoli66/saeedvdi/projects/moose/framework/contrib/hit/src/hit/parse.cc: In function \u2018void hit::buildHITTree(std::shared_ptr<wasp::HITInterpreter<> >, wasp::HITNodeView, Node*, std::string&, std::size_t&)\u2019:\n/home/saeedvdi/projects/def-biaoli66/saeedvdi/projects/moose/framework/contrib/hit/src/hit/parse.cc:1246:44: error: \u2018is_override\u2019 is not a member of \u2018wasp\u2019\n1246 |         bool override_for_old_node = wasp::is_override(found_field->getNodeView());\n|                                            ^~~~~~~~~~~\n/home/saeedvdi/projects/def-biaoli66/saeedvdi/projects/moose/framework/contrib/hit/src/hit/parse.cc:1247:44: error: \u2018is_override\u2019 is not a member of \u2018wasp\u2019\n1247 |         bool override_for_new_node = wasp::is_override(hnv_child);\n|                                            ^~~~~~~~~~~\nmake: *** [/home/saeedvdi/projects/def-biaoli66/saeedvdi/projects/moose/framework/moose.mk:149: /home/saeedvdi/projects/def-biaoli66/saeedvdi/projects/moose/framework/contrib/hit/hit.so] Error 1",
          "url": "https://github.com/idaholab/moose/discussions/30018",
          "updatedAt": "2025-03-04T21:05:40Z",
          "publishedAt": "2025-03-04T17:27:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis looks like error for an old version with a new version of moose\nHow did thry install wasp?\nCan you just install it from moose/scripts?",
                  "url": "https://github.com/idaholab/moose/discussions/30018#discussioncomment-12391762",
                  "updatedAt": "2025-03-04T17:44:15Z",
                  "publishedAt": "2025-03-04T17:44:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "saeedvdi"
                          },
                          "bodyText": "I have already installed Wasp using moose scripts. However, Moose does not recognize it after the install is completed. I tried to export the path to wasp installation like \" wasp_dir = path to wasp install\" and still was not able to install my app correctly. What version of Wasp and PETSc do I need?",
                          "url": "https://github.com/idaholab/moose/discussions/30018#discussioncomment-12392157",
                          "updatedAt": "2025-03-04T18:20:46Z",
                          "publishedAt": "2025-03-04T18:20:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Whatever your current checkout of MOOSE requires really:\n$ git submodule\n<trimmed>\n c8c9ce4259115973f147e345608450d87dc390c4 framework/contrib/wasp (4.3.0-2-gc8c9ce4)\n 6ef7d4395794104f48dae1fd48e64077207188e8 libmesh (cpp03_final-10580-g6ef7d4395)\n 72c1e49ee3d896ae53f9f914a80b983ec63c03c7 petsc (v3.22.1-193-g72c1e49ee3d)\nAnd I am glad you asked, because I was about to post why your older version of MOOSE may be working vs a recent one. Depending on how old it was, that version may not even require 'wasp'.",
                          "url": "https://github.com/idaholab/moose/discussions/30018#discussioncomment-12392211",
                          "updatedAt": "2025-03-04T18:24:21Z",
                          "publishedAt": "2025-03-04T18:24:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "when using the script, you automatically get the right version\nmake sure to remove the HPC version of wasp when building a new one.\non my machine if I use the local wasp it is version\n[4.3.0] - 5-03-2024",
                          "url": "https://github.com/idaholab/moose/discussions/30018#discussioncomment-12392230",
                          "updatedAt": "2025-03-04T18:25:56Z",
                          "publishedAt": "2025-03-04T18:25:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "saeedvdi"
                  },
                  "bodyText": "Thank you. I was able to install it.\nPreviously I was using \"--branch 2024-03-08 https://github.com/idaholab/moose.git\"",
                  "url": "https://github.com/idaholab/moose/discussions/30018#discussioncomment-12393643",
                  "updatedAt": "2025-03-04T21:05:41Z",
                  "publishedAt": "2025-03-04T21:05:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}