{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNC0yOFQxMDo1Mzo1MC0wNjowMM4ATlKH"
    },
    "edges": [
      {
        "node": {
          "title": "MALAMUTE ROM Development: Jacobian Reduction",
          "author": {
            "login": "raj-anant"
          },
          "bodyText": "Dear MOOSE Team,\nWe are developing a ROM for MALAMUTE and are exploring different parts of the problem where we can achieve a reduction. In particular, we are interested in achieving reduction at the level of the Jacobian. However, we had a few concerns about the feasibility of the implementation of any such approach. Specifically, we had the following questions:\n(i) Is it possible to read in an approximate base Jocobian for the problem through a file or generate it through a script inside MOOSE?\n(ii) Is it possible to make small updates to the base Jacobian as the solution evolves using a script inside MOOSE? Essentially, we want to explore bypassing the computation of the Jacobian through AD at each non-linear iteration.\n(iii) Is it possible to bypass PetSci for the solution of the non-linear iteration?\n(iv) Is there a convenient way for dumping the Jacobian to a file every few time steps/iterations? Write now we are using \"-ksp_view_mat\" option, but that dumps the Jacobian directly into the text output file serially at every non-linear iteration, which is very difficult to post-process.\n(v) Similarly, is there a way to dump the residuals to a file every few non-linear iterations? We are looking for the residuals at the start of the iteration, not just the final value after convergence.\nWe would appreciate any help on this.\nThanks,\nAnant",
          "url": "https://github.com/idaholab/moose/discussions/24240",
          "updatedAt": "2023-06-24T22:33:05Z",
          "publishedAt": "2023-05-01T20:05:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cticenhour",
                  "url": "https://github.com/idaholab/moose/discussions/24240#discussioncomment-5774895",
                  "updatedAt": "2023-05-01T20:16:39Z",
                  "publishedAt": "2023-05-01T20:16:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@GiudGiud This is more like framework/solver level question. @raj-anant worked with me, and I do not have sufficient knowledge to answer some of his question. We hope posting those questions here will provide us better directions to approach next.",
                          "url": "https://github.com/idaholab/moose/discussions/24240#discussioncomment-5774950",
                          "updatedAt": "2023-05-01T20:26:33Z",
                          "publishedAt": "2023-05-01T20:26:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "The short answer to all of your questions is sadly no but we welcome contributions.  You can write your own Executioner and SolveObject and FEProblemBase derived objects in which you can do almost anything you want. You could override the Jacobian computation routine from the latter for instance.\nI'll give a little more detail on a few:\niii) You can write your own custom line search if that's what you mean by bypassing PETSc's nonlinear solution. However, you would still be using the built-in KSP in the PETSc SNES object\niv) You could hack in some condition MatView calls within the framework contingent on time step/iteration number etc.\nv) similarly as iv)",
                  "url": "https://github.com/idaholab/moose/discussions/24240#discussioncomment-5774963",
                  "updatedAt": "2023-05-01T20:29:31Z",
                  "publishedAt": "2023-05-01T20:28:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Linking material property to ADDirichletBC",
          "author": {
            "login": "LukeFisherUKAEA"
          },
          "bodyText": "Hello,\nI am looking to bring the output of a MaterialProperty block into an AD Dirichlet boundary condition and wondered if code for this already exists in the BCs library?  I can see that an ADMatNeumann BC exists, but cannot see the same for a Dirichlet condition.  Is there something fundamental (e.g. integrated vs nodal boundary condition type) that would prevent this from working?  For context, we are looking to implement Sieverts Law on a boundary:\n\nwhere\n\nInitially temperature, T, will be implemented as an AuxVariable but we will want to get to the point where we can solve for heat transfer in parallel, meaning T will become a non-linear variable.  The intention would be to calculate the solubility coefficient in a ParsedMaterial block and feed that into a Dirichlet boundary condition to calculate surface concentration, C, with pressure also an AuxVariable.\nAny advice or suggestions would be much appreciated.  Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/23634",
          "updatedAt": "2023-05-01T18:08:09Z",
          "publishedAt": "2023-03-07T09:58:57Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe do not have such a BC currently.\nYou may consider the ADMatchedValueBC for an example.\nUsing AD will simplify the implementation\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23634#discussioncomment-5231226",
                  "updatedAt": "2023-03-07T16:59:13Z",
                  "publishedAt": "2023-03-07T16:59:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Is there something fundamental (e.g. integrated vs nodal boundary condition type) that would prevent this from working?\n\nCorrect. Material properties are stored on quadrature points, and nodal BCs are nodal... The two natural workarounds are:\n\nconvert the nodal BC to integrated BC, for example MatchedValueBC as @GiudGiud suggested.\nproject (extrapolate) the material properties onto the boundary nodes.",
                  "url": "https://github.com/idaholab/moose/discussions/23634#discussioncomment-5291384",
                  "updatedAt": "2023-03-13T13:07:34Z",
                  "publishedAt": "2023-03-13T13:07:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Let's link those threads\n#24106",
                          "url": "https://github.com/idaholab/moose/discussions/23634#discussioncomment-5759727",
                          "updatedAt": "2023-04-29T03:14:45Z",
                          "publishedAt": "2023-04-29T03:14:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "ADMatchedValueBC is also a nodal BC",
                          "url": "https://github.com/idaholab/moose/discussions/23634#discussioncomment-5774009",
                          "updatedAt": "2023-05-01T18:08:09Z",
                          "publishedAt": "2023-05-01T18:08:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "dt suddenly drops to 1e-19 and stops working. How to fix this issue?",
          "author": {
            "login": "K-Komal-98"
          },
          "bodyText": "I am working on a dendrite growth problem.\nThere are two input files:\n\nwithout mechanics. This works well even beyond 17000 time steps\nwith mechanics. This works well upto 169 time steps and suddenly dt reduces to 1e-13.\n\nI have followed the instructions given in this link but couldn't solve the issue: https://mooseframework.inl.gov/application_usage/failed_solves.html\nI am pasting the input files for both the parts and marking the added part in between --------------\nThis is my thesis work. Can you please guide me what can I do to solve this issue?\nInput file for WITHOUT MECHANICS:\ninput file.\nDefine mesh. 2-D system, simulation size 200*200.\n[Mesh]\ntype = GeneratedMesh\ndim = 2\nnx = 200\nxmax =200\nny=200\nymax=200\n[]\nvariables. w: chemical potential, eta: order parameter, pot: applied overpotential.\n[Variables]\n[./w]\n[../]\n[./eta]\n[../]\n[./pot]\n[../]\n[]\nCreating functions for initial conditions.\n[Functions]\n[./ic_func_eta]\ntype = ParsedFunction\nvalue = 0.5*(1.0-1.0*tanh((x-20)2))\n[../]\n[./ic_func_c]\ntype = ParsedFunction\nvalue = 0\n[../]\n[./ic_func_pot]\ntype = ParsedFunction\nvalue = -0.225(1.0-tanh((x-20)*2))\n[../]\n[]\nInitial conditions.\n[ICs]\n[./eta]\nvariable = eta\ntype = FunctionIC\nfunction = ic_func_eta\n[../]\n[./w]\nvariable = w\ntype = FunctionIC\nfunction = ic_func_c\n[../]\n[./pot]\nvariable = pot\ntype = FunctionIC\nfunction = ic_func_pot\n[../]\n[]\nBoundary conditions.\n[BCs]\n[./bottom_eta]\ntype = NeumannBC\nvariable = 'eta'\nboundary = 'bottom'\nvalue = 0\n[../]\n[./top_eta]\ntype = NeumannBC\nvariable = 'eta'\nboundary = 'top'\nvalue = 0\n[../]\n[./left_eta]\ntype = DirichletBC\nvariable = 'eta'\nboundary = 'left'\nvalue = 1\n[../]\n[./right_eta]\ntype = DirichletBC\nvariable = 'eta'\nboundary = 'right'\nvalue = 0\n[../]\n[./bottom_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'bottom'\nvalue = 0\n[../]\n[./top_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'top'\nvalue = 0.0\n[../]\n[./left_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'left'\nvalue = 0\n[../]\n[./right_w]\ntype = DirichletBC\nvariable = 'w'\nboundary = 'right'\nvalue = 0.0\n[../]\n[./left_pot]\ntype = DirichletBC\nvariable = 'pot'\nboundary = 'left'\nvalue = -0.45\n[../]\n[./right_pot]\ntype = DirichletBC\nvariable = 'pot'\nboundary = 'right'\nvalue = 0\n[../]\n[]\n[Kernels]\nFirst part of equation 3 in main text . chi*dw/dt\n[./w_dot]\ntype = SusceptibilityTimeDerivative\nvariable = w\nf_name = chi\nargs = 'w'\n[../]\nIntrinsic diffusion part of equation 3 in main text.\n[./Diffusion1]\ntype = MatDiffusion\nvariable=w\nD_name=D\n[../]\nMigration.\n[./Diffusion2]\ntype = Migration\nvariable = w\ncv=eta\nQ_name = 0.\nQM_name = DN\ncp=pot\n[../]\nCoupling between w and eta.\n[./coupled_etadot]\ntype = CoupledSusceptibilityTimeDerivative\nvariable = w\nv = eta\nf_name = ft\nargs = 'eta'\n[../]\nConduction, left handside of equation 4 in main text.\n[./Cond]\ntype = Conduction\nvariable = pot\ncp=eta\ncv =w\nQ_name = Le1\nQM_name=0.\n[../]\nSource term for Equation 4 in main text.\n[./coupled_pos]\ntype = CoupledSusceptibilityTimeDerivative\nvariable = pot\nv = eta\nf_name = ft2\nargs = 'eta'\n[../]\nBulter-volmer equation, right hand side of Equation 1 in main text.\n[./BV]\ntype = Kinetics\nvariable = eta\nf_name = G\ncp=pot\ncv=eta\n[../]\nDriving force from switching barrier, right hand side of Equation 1 in main text.\n[./AC_bulk]\ntype = AllenCahn\nvariable = eta\nf_name = FF\n[../]\ninterfacial energy\n[./AC_int]\ntype = ACInterface\nvariable = eta\n[../]\n[./Noiseeta]\ntype = LangevinNoise\nvariable = eta\namplitude=0.04\n[../]\ndeta/dt\n[./e_dot]\ntype = TimeDerivative\nvariable = eta\n[../]\n[]\n[Materials]\n[./constants]\ntype = GenericConstantMaterial\nkappa_op: gradient coefficient;  M0:diffucion coefficient of Li+ in electrolyte\nS1, S2 conductivity of electrode and electrolyte; L: kinetic coefficient; Ls: electrochemical kinetic coefficient; B: Barrier height;\nes, el: difference in the chemical potential of lithium and neutral components on the electrode/electrolyte phase at initial equilibrium state;\nus, ul: free energy density of the electrode/electrolyte phases. Defined in Ref. 20 and 26 of the main text; A: prefactor; AA: nF/(R*T);\ndv is the ratio of site density for the electrode/electrolyte phases; ft2: normalized used in Equation 4.\nprop_names  = 'kappa_op  M0     S1    S2     L    Ls       B   es       el    A     ul    us    AA  dv   ft2'\nprop_values = '0.3   317.9   1000000 1.19   6.25   0.001  2.4  -13.8  2.631   1.0   0.0695 13.8   38.69 5.5 0.0074'\n[../]\ngrand potential of electrolyte phase\n[./liquid_GrandPotential]\ntype = DerivativeParsedMaterial\nfunction = 'ul-A*log(1+exp((w-el)/A))'\nargs = 'w'\nf_name = f1\nmaterial_property_names = 'A ul el'\n[../]\ngrand potential of electrode phase\n[./solid_GrandPotential]\ntype = DerivativeParsedMaterial\nfunction = 'us-A*log(1+exp((w-es)/A))'\nargs = 'w'\nf_name = f2\nmaterial_property_names = 'A us es'\n[../]\n#interpolation function h\n[./switching_function]\ntype = SwitchingFunctionMaterial\neta ='eta'\nh_order = HIGH\n[../]\nBarrier function g\n[./barrier_function]\ntype = BarrierFunctionMaterial\neta = eta\n[../]\n[./total_GrandPotential]\ntype = DerivativeTwoPhaseMaterial\nargs = 'w'\neta = eta\nfa_name = f1\nfb_name = f2\nderivative_order = 2\nW = 2.4\n[../]\nCoupling between eta and w\n[./coupled_eta_function]\ntype = DerivativeParsedMaterial\nfunction = '-(csdv-cl)dh'  # in this code cs=-cs h=eta dh=1\nargs = ' w eta'\nf_name = ft\nmaterial_property_names = 'dh:=D[h,eta] h dv cs:=D[f2,w] cl:=D[f1,w]'\nderivative_order = 1\n[../]\n[./susceptibility]\ntype = DerivativeParsedMaterial\nfunction = '-d2F1(1-h)-d2F2hdv'\nargs = 'w'\nf_name = chi\nderivative_order = 1\nmaterial_property_names = 'h dv d2F1:=D[f1,w,w] d2F2:=D[f2,w,w]'\n[../]\n# Mobility defined by Dc/(RT), whereRT is normalized by the chemical potential\n# M0*(1-h) is the effective diffusion coefficient; cl*(1-h) is the ion concentration\n[./Mobility_coefficient]\ntype = DerivativeParsedMaterial\nfunction = '-M0*(1-h)cl(1-h)'  #c is -c\nf_name = D\nargs = 'eta w'\nderivative_order = 1\nmaterial_property_names = ' M0 cl:=D[f1,w] h'\n[../]\nEnergy of the barrier\n[./Free]\ntype = DerivativeParsedMaterial\nf_name = FF\nmaterial_property_names = 'B'\nargs='eta'\nfunction = 'Betaeta*(1-eta)*(1-eta)'\nderivative_order = 1\n[../]\nMigration coefficient.\n[./Migration_coefficient]\ntype = DerivativeParsedMaterial\nfunction = '-cl*(1-h)AAM0*(1-h)'\nargs = 'eta w'\nf_name = DN\nderivative_order = 1\nmaterial_property_names = 'M0 AA cl:=D[f1,w] h'\n[../]\n[./Bultervolmer]\ntype = DerivativeParsedMaterial\nfunction = 'Ls*(exp(potAA/2.)+14.89cl*(1-h)exp(-potAA/2.))*dh'\nargs = 'pot eta w'\nf_name = G\nderivative_order = 1\nmaterial_property_names = 'Ls dh:=D[h,eta] h cl:=D[f1,w] AA'\noutputs = exodus\n[../]\noutput the ion concentration\n[./concentration]\ntype = ParsedMaterial\nf_name = c\nargs='eta w'\nmaterial_property_names = 'h dFl:=D[f1,w]'\nfunction = '-dFl*(1-h)'\noutputs = exodus\n[../]\nEffective conductivity\n[./Le1]\ntype = DerivativeParsedMaterial\nf_name = Le1\nargs = 'eta'\nmaterial_property_names = 'S1 S2 h'\nfunction = 'S1h+S2(1-h)'\nderivative_order = 1\n[../]\n[]\n[GlobalParams]\nenable_jit = false           # Disable JIT\n[]\n[Preconditioning]\n[./SMP]\ntype = SMP\nfull = true\npetsc_options_iname = '-pc_type -ksp_grmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\npetsc_options_value = 'lu      121                  preonly       lu           8'\npetsc_options_value = 'asm      121                  preonly       lu           8'\n[../]\n[]\n[Executioner]\ntype = Transient\nscheme = bdf2\nsolve_type =Newton\nl_max_its = 50\nl_tol = 1e-4\nnl_max_its = 100\nnl_rel_tol = 1e-6\nnl_abs_tol = 1e-6\ndt= 0.001\nend_time = 400\n[TimeStepper]\ntype=IterationAdaptiveDT\noptimal_iterations = 50\niteration_window = 5\nlinear_iteration_ratio = 10\ndt = 1\n[]\n[]\n[Outputs]\nexodus = true\ncsv = true\nexecute_on = 'TIMESTEP_END'\n[./other]        # creates input_other.e output every 30 timestep\ntype = Exodus\ninterval = 30\n[../]\n[]\nInput file for WITH MECHANICS:\ninput file.\n#-------------------------------------------------------------------------\n[GlobalParams]\ndisplacements = 'disp_x disp_y'\n[]\n[Modules/TensorMechanics/Master]\n[./all]\nadd_variables = true\ngenerate_output = 'stress_xy stress_yx stress_xx stress_yy'\neigenstrain_names = 'eigenstrain'\n[../]\n[]\n#--------------------------------------------------------------------------\nDefine mesh. 2-D system, simulation size 200*200.\n[Mesh]\ntype = GeneratedMesh\ndim = 2\nnx = 200\nxmax =200\nny=200\nymax=200\n[]\nvariables. w: chemical potential, eta: order parameter, pot: applied overpotential.\n[Variables]\n[./w]\n[../]\n[./eta]\n[../]\n[./pot]\n[../]\n[]\nCreating functions for initial conditions.\n[Functions]\n[./ic_func_eta]\ntype = ParsedFunction\nvalue = 0.5*(1.0-1.0*tanh((x-20)2))\n[../]\n[./ic_func_c]\ntype = ParsedFunction\nvalue = 0\n[../]\n[./ic_func_pot]\ntype = ParsedFunction\nvalue = -0.225(1.0-tanh((x-20)*2))\n[../]\n[]\nInitial conditions.\n[ICs]\n[./eta]\nvariable = eta\ntype = FunctionIC\nfunction = ic_func_eta\n[../]\n[./w]\nvariable = w\ntype = FunctionIC\nfunction = ic_func_c\n[../]\n[./pot]\nvariable = pot\ntype = FunctionIC\nfunction = ic_func_pot\n[../]\n[]\nBoundary conditions.\n[BCs]\n#--------------------------------------------------------------------------\n[./all_y]\ntype = DirichletBC\nvariable = disp_y\nboundary = 'top bottom left right'\nvalue = 0\n[../]\n[./all_x]\ntype = DirichletBC\nvariable = disp_x\nboundary = 'top bottom left right'\nvalue = 0\n[../]\n#--------------------------------------------------------------------------\n[./bottom_eta]\ntype = NeumannBC\nvariable = 'eta'\nboundary = 'bottom'\nvalue = 0\n[../]\n[./top_eta]\ntype = NeumannBC\nvariable = 'eta'\nboundary = 'top'\nvalue = 0\n[../]\n[./left_eta]\ntype = DirichletBC\nvariable = 'eta'\nboundary = 'left'\nvalue = 1\n[../]\n[./right_eta]\ntype = DirichletBC\nvariable = 'eta'\nboundary = 'right'\nvalue = 0\n[../]\n[./bottom_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'bottom'\nvalue = 0\n[../]\n[./top_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'top'\nvalue = 0.0\n[../]\n[./left_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'left'\nvalue = 0\n[../]\n[./right_w]\ntype = DirichletBC\nvariable = 'w'\nboundary = 'right'\nvalue = 0.0\n[../]\n[./left_pot]\ntype = DirichletBC\nvariable = 'pot'\nboundary = 'left'\nvalue = -0.45\n[../]\n[./right_pot]\ntype = DirichletBC\nvariable = 'pot'\nboundary = 'right'\nvalue = 0\n[../]\n[]\n[Kernels]\nFirst part of equation 3 in main text . chi*dw/dt\n[./w_dot]\ntype = SusceptibilityTimeDerivative\nvariable = w\nf_name = chi\nargs = 'w'\n[../]\nIntrinsic diffusion part of equation 3 in main text.\n[./Diffusion1]\ntype = MatDiffusion\nvariable=w\nD_name=D\n[../]\nMigration.\n[./Diffusion2]\ntype = Migration\nvariable = w\ncv=eta\nQ_name = 0.\nQM_name = DN\ncp=pot\n[../]\nCoupling between w and eta.\n[./coupled_etadot]\ntype = CoupledSusceptibilityTimeDerivative\nvariable = w\nv = eta\nf_name = ft\nargs = 'eta'\n[../]\nConduction, left handside of equation 4 in main text.\n[./Cond]\ntype = Conduction\nvariable = pot\ncp=eta\ncv =w\nQ_name = Le1\nQM_name=0.\n[../]\nSource term for Equation 4 in main text.\n[./coupled_pos]\ntype = CoupledSusceptibilityTimeDerivative\nvariable = pot\nv = eta\nf_name = ft2\nargs = 'eta'\n[../]\nBulter-volmer equation, right hand side of Equation 1 in main text.\n[./BV]\ntype = Kinetics\nvariable = eta\nf_name = G\ncp=pot\ncv=eta\n[../]\nDriving force from switching barrier, right hand side of Equation 1 in main text.\n[./AC_bulk]\ntype = AllenCahn\nvariable = eta\nf_name = FF\n[../]\ninterfacial energy\n[./AC_int]\ntype = ACInterface\nvariable = eta\n[../]\n[./Noiseeta]\ntype = LangevinNoise\nvariable = eta\namplitude=0.04\n[../]\ndeta/dt\n[./e_dot]\ntype = TimeDerivative\nvariable = eta\n[../]\n[]\n[Materials]\n[./constants]\ntype = GenericConstantMaterial\nkappa_op: gradient coefficient;  M0:diffucion coefficient of Li+ in electrolyte\nS1, S2 conductivity of electrode and electrolyte; L: kinetic coefficient; Ls: electrochemical kinetic coefficient; B: Barrier height;\nes, el: difference in the chemical potential of lithium and neutral components on the electrode/electrolyte phase at initial equilibrium state;\nus, ul: free energy density of the electrode/electrolyte phases. Defined in Ref. 20 and 26 of the main text; A: prefactor; AA: nF/(R*T);\ndv is the ratio of site density for the electrode/electrolyte phases; ft2: normalized used in Equation 4.\nprop_names  = 'kappa_op  M0     S1    S2     L    Ls       B   es       el    A     ul    us    AA  dv   ft2'\nprop_values = '0.3   317.9   1000000 1.19   6.25   0.001  2.4  -13.8  2.631   1.0   0.0695 13.8   38.69 5.5 0.0074'\n[../]\ngrand potential of electrolyte phase\n[./liquid_GrandPotential]\ntype = DerivativeParsedMaterial\nfunction = 'ul-A*log(1+exp((w-el)/A))'\nargs = 'w'\nf_name = f1\nmaterial_property_names = 'A ul el'\n[../]\ngrand potential of electrode phase\n[./solid_GrandPotential]\ntype = DerivativeParsedMaterial\nfunction = 'us-A*log(1+exp((w-es)/A))'\nargs = 'w'\nf_name = f2\nmaterial_property_names = 'A us es'\n[../]\n#interpolation function h\n[./switching_function]\ntype = SwitchingFunctionMaterial\neta ='eta'\nh_order = HIGH\n[../]\nBarrier function g\n[./barrier_function]\ntype = BarrierFunctionMaterial\neta = eta\n[../]\n[./total_GrandPotential]\ntype = DerivativeTwoPhaseMaterial\nargs = 'w'\neta = eta\nfa_name = f1\nfb_name = f2\nderivative_order = 2\nW = 2.4\n[../]\nCoupling between eta and w\n[./coupled_eta_function]\ntype = DerivativeParsedMaterial\nfunction = '-(csdv-cl)dh'  # in this code cs=-cs h=eta dh=1\nargs = ' w eta'\nf_name = ft\nmaterial_property_names = 'dh:=D[h,eta] h dv cs:=D[f2,w] cl:=D[f1,w]'\nderivative_order = 1\n[../]\n[./susceptibility]\ntype = DerivativeParsedMaterial\nfunction = '-d2F1(1-h)-d2F2hdv'\nargs = 'w'\nf_name = chi\nderivative_order = 1\nmaterial_property_names = 'h dv d2F1:=D[f1,w,w] d2F2:=D[f2,w,w]'\n[../]\n# Mobility defined by Dc/(RT), whereRT is normalized by the chemical potential\n# M0*(1-h) is the effective diffusion coefficient; cl*(1-h) is the ion concentration\n[./Mobility_coefficient]\ntype = DerivativeParsedMaterial\nfunction = '-M0*(1-h)cl(1-h)'  #c is -c\nf_name = D\nargs = 'eta w'\nderivative_order = 1\nmaterial_property_names = ' M0 cl:=D[f1,w] h'\n[../]\nEnergy of the barrier\n[./Free]\ntype = DerivativeParsedMaterial\nf_name = Fc\nmaterial_property_names = 'B'\nargs='eta'\nfunction = 'Betaeta*(1-eta)*(1-eta)'\nderivative_order = 1\n[../]\nMigration coefficient.\n[./Migration_coefficient]\ntype = DerivativeParsedMaterial\nfunction = '-cl*(1-h)AAM0*(1-h)'\nargs = 'eta w'\nf_name = DN\nderivative_order = 1\nmaterial_property_names = 'M0 AA cl:=D[f1,w] h'\n[../]\n[./Bultervolmer]\ntype = DerivativeParsedMaterial\nfunction = 'Ls*(exp(potAA/2.)+14.89cl*(1-h)exp(-potAA/2.))*dh'\nargs = 'pot eta w'\nf_name = G\nderivative_order = 1\nmaterial_property_names = 'Ls dh:=D[h,eta] h cl:=D[f1,w] AA'\noutputs = exodus\n[../]\noutput the ion concentration\n[./concentration]\ntype = ParsedMaterial\nf_name = c\nargs='eta w'\nmaterial_property_names = 'h dFl:=D[f1,w]'\nfunction = '-dFl*(1-h)'\noutputs = exodus\n[../]\nEffective conductivity\n[./Le1]\ntype = DerivativeParsedMaterial\nf_name = Le1\nargs = 'eta'\nmaterial_property_names = 'S1 S2 h'\nfunction = 'S1h+S2(1-h)'\nderivative_order = 1\n[../]\n#---------------------------------------------------------------------------\n[./one_minus_h_eta]\ntype = DerivativeParsedMaterial\nf_name = one_minus_h\nargs = 'eta'\nfunction = '1-h'\nmaterial_property_names = 'h'\n[../]\n[./electrode]\ntype = ComputeIsotropicElasticityTensor\nbase_name = electrode\nyoungs_modulus = 1960\npoissons_ratio = 0.36\n[../]\n[./electrolyte]\n  type = ComputeIsotropicElasticityTensor\n  base_name = electrolyte\n  youngs_modulus = 392.7\n  poissons_ratio = 0.36\n[../]\n\n[./elasticity_tensor]\ntype = CompositeElasticityTensor\nargs = 'eta'\ntensors = 'electrode   electrolyte'\nweights = 'h   one_minus_h'\n[../]\n#Added stress\n#calculate sigma(stress)\n[./stress]\ntype = ComputeLinearElasticStress\n[../]\n#Added eigen strain eta dependency\n#to calculate equation 8\n[./var_dependence]\ntype = DerivativeParsedMaterial\nf_name = var_dep\nargs = 'eta'\nfunction = eta\nderivative_order = 1\n[../]\n[./eigenstrain]\ntype = ComputeVariableEigenstrain\neigen_base = '-0.000866 -0.000773 -0.000529 0.0 0.0 0.0'\nprefactor = var_dep\nargs = 'eta'\neigenstrain_name = eigenstrain\n[../]\n#Added elastic energy block\n[./elastic_free_energy]\ntype = ElasticEnergyMaterial\nf_name = Fe\nargs = 'eta'\nderivative_order = 2\n[../]\n#Added sum of energy block\n[./sum_of_Fc_and_Fe_free_energy]\ntype = DerivativeSumMaterial\nf_name = FF\nsum_materials = 'Fc Fe'\nargs = 'eta'\nderivative_order = 2\n[../]\n[]\n#---------------------------------------------------------------------------\n[GlobalParams]\nenable_jit = false           # Disable JIT\n[]\n#------------------------------------------------------------------------\n[Postprocessors]\n[./liquid_GrandPotential]\ntype = ElementIntegralMaterialProperty\nmat_prop = f1\n[../]\n[./solid_GrandPotential]\ntype = ElementIntegralMaterialProperty\nmat_prop = f2\n[../]\n[./Free]\ntype = ElementIntegralMaterialProperty\nmat_prop = Fc\n[../]\n[./Elastic]\ntype = ElementIntegralMaterialProperty\nmat_prop = Fe\n[../]\n[./Total]\ntype = ElementIntegralMaterialProperty\nmat_prop = FF\n[../]\n[./dt]\ntype = TimestepSize\n[../]\n[./NL_iter]\ntype = NumNonlinearIterations\n[../]\n[./numDOFs]\ntype = NumDOFs\nsystem = NL\n[../]\n[]\n#-------------------------------------------------------------------------\n[Preconditioning]\n[./SMP]\ntype = SMP\nfull = true\npetsc_options_iname = '-pc_type -ksp_grmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\npetsc_options_value = 'lu      121                  preonly       lu           8'\npetsc_options_value = 'asm      121                  preonly       lu           8'\n[../]\n[]\n[Executioner]\ntype = Transient\nscheme = bdf2\nsolve_type =Newton\nl_max_its = 50\nl_tol = 1e-4\nnl_max_its = 100\nnl_rel_tol = 1e-6\nnl_abs_tol = 1e-6\ndt= 0.001\nend_time = 400\n[TimeStepper]\ntype=IterationAdaptiveDT\noptimal_iterations = 50\niteration_window = 5\nlinear_iteration_ratio = 10\ndt = 1\n[]\n[]\n[Outputs]\nexodus = true\ncsv = true\nexecute_on = 'TIMESTEP_END'\n[./other]        # creates input_other.e output every 30 timestep\ntype = Exodus\ninterval = 30\n[../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24231",
          "updatedAt": "2023-04-30T19:21:18Z",
          "publishedAt": "2023-04-30T19:16:27Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "K-Komal-98"
                  },
                  "bodyText": "Preview is not desirable. Hence, starting a new discussion.",
                  "url": "https://github.com/idaholab/moose/discussions/24231#discussioncomment-5767632",
                  "updatedAt": "2023-04-30T19:21:19Z",
                  "publishedAt": "2023-04-30T19:21:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "fictitious Boundaries",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Is it possible to implement fictitious boundary methods in moose, and are there any examples to demonstrate how?",
          "url": "https://github.com/idaholab/moose/discussions/24211",
          "updatedAt": "2023-06-24T22:32:59Z",
          "publishedAt": "2023-04-28T04:40:11Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDo you have a link? I dont recall what that is\nWhich field is this for?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5754638",
                  "updatedAt": "2023-04-28T13:32:36Z",
                  "publishedAt": "2023-04-28T13:32:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@maxnezdyur",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5754653",
                          "updatedAt": "2023-04-28T13:33:38Z",
                          "publishedAt": "2023-04-28T13:33:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for inquiring. Here is a paper that discusses the method.\nhttps://www.sciencedirect.com/science/article/abs/pii/S0021999100965422",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5754852",
                          "updatedAt": "2023-04-28T13:47:21Z",
                          "publishedAt": "2023-04-28T13:47:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yes, @maxnezdyur is developing a MOOSE-based app for that.",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5759384",
                          "updatedAt": "2023-04-29T00:52:44Z",
                          "publishedAt": "2023-04-29T00:52:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Will it be made available for beta testers, in particular me? Is there an existing preliminary framework for simple 1D models?",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5759425",
                          "updatedAt": "2023-04-29T01:11:35Z",
                          "publishedAt": "2023-04-29T01:11:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "It's still a work in progress, with a few kinks that need to be taken care of. I want to make it public at the end of the summer. The app is more of an embedded boundary method than the fictitious method you linked, but it should still be helpful, depending on what you are trying to do.",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5761910",
                          "updatedAt": "2023-04-29T14:18:13Z",
                          "publishedAt": "2023-04-29T14:18:13Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "It appears from what you @maxnezdyur are describing, is that implementing FBM can not be easily applied by using existing apps and moose interfaces. An app and custom code has to be created to accomplish it.",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5763583",
                          "updatedAt": "2023-04-29T20:56:43Z",
                          "publishedAt": "2023-04-29T20:56:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Changing AD material property variable to regular variable",
          "author": {
            "login": "steam-simulator"
          },
          "bodyText": "Hello,\nI\u2019m retrieving an ADmaterial property, but I want to strip the AD from it and convert it to a regular property before using it in my code. How do I do this? I tried using the .value() function but got this error:\nerror: 'const class ADMaterialProperty<RankTwoTensorTempl<double> >' has no member named 'value'; did you mean '_value'?\n 132 |         RankTwoTensor _stress = (_stress_o).value();\n     |                                             ^~~~~\n     |                                             _value\n/home/jay/MOOSE/projects/creep/src/materials/perm.C:133:16: error: no match for 'operator[]' (operand types are 'RankTwoTensor' {aka 'RankTwoTensorTempl<double>'} and 'unsigned int')\n 133 |         _stress[_qp].symmetricEigenvaluesEigenvectors(eigvals, eigvec);\n     |                ^\nIn file included from /home/jay/MOOSE/projects/creep/build/unity_src/materials_Unity.C:4:\n/home/jay/MOOSE/projects/creep/src/materials/perm2.C: In member function 'void perm2Templ<is_ad>::computeQpProperties()':\n/home/jay/MOOSE/projects/creep/src/materials/perm2.C:93:9: error: '_stress' was not declared in this scope; did you mean '_stress_o'?\n  93 |         _stress[_qp].symmetricEigenvaluesEigenvectors(eigvals, eigvec);\n\nI have the following in my header and source:\nconst ADMaterialProperty<RankTwoTensor>& _stress;\n_stress_o(getADMaterialProperty<RankTwoTensor>(_base_name + \"stress\")),\nMy code:\nRankTwoTensor _stress[_qp] = (_stress_o[_qp]).value();\nDo I need to include any special type of header? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/24215",
          "updatedAt": "2023-04-29T17:58:19Z",
          "publishedAt": "2023-04-28T16:05:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "this should be fine\n(_stress_o[_qp]).value()\nbut\n(_stress_o).value(); is not, you need to index to get the ADReal before stripping the derivative.\nNote that there is already a converter between AD and non AD:\nhttps://mooseframework.inl.gov/source/materials/MaterialADConverter.html",
                  "url": "https://github.com/idaholab/moose/discussions/24215#discussioncomment-5756366",
                  "updatedAt": "2023-04-28T16:09:29Z",
                  "publishedAt": "2023-04-28T16:09:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "or raw_value(_stress_o[_qp])",
                          "url": "https://github.com/idaholab/moose/discussions/24215#discussioncomment-5759346",
                          "updatedAt": "2023-04-29T00:39:45Z",
                          "publishedAt": "2023-04-29T00:39:44Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "steam-simulator"
                          },
                          "bodyText": "Thank you very much, @hugary1995 and @GiudGiud , for the recommendations. In this case, raw_value(_stress_o[_qp]) works best!",
                          "url": "https://github.com/idaholab/moose/discussions/24215#discussioncomment-5762971",
                          "updatedAt": "2023-04-29T17:57:37Z",
                          "publishedAt": "2023-04-29T17:57:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can I solve these coupled differential equations in MOOSE without creating a custom kernel?",
          "author": {
            "login": "K-Komal-98"
          },
          "bodyText": "I have solved a single second order differential equation using the ADMatdiffusion and Reaction kernel. Can you assist me on how to solve this problem with the existing moose kernels?",
          "url": "https://github.com/idaholab/moose/discussions/24059",
          "updatedAt": "2023-04-29T09:21:24Z",
          "publishedAt": "2023-04-13T07:28:03Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe BCs are Dirichlet and Neumann, you can use off-the-shelf MOOSE BCs for this.\nYou ll want to write a new kernels (start from ADCoupledForce) for the u^2, v^2 and u^2 v^2 terms.\nThe second order space derivatives you can use a Diffusion kernel for the one that is in its own equation.\nFor the other one you ll need to create a coupledDiffusion kernel, that has a \"variable\" argument that is different than the variable that gets the second derivative taken from.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24059#discussioncomment-5603609",
                  "updatedAt": "2023-04-13T12:06:41Z",
                  "publishedAt": "2023-04-13T12:06:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "K-Komal-98"
                  },
                  "bodyText": "Can I use ADMatDiffusion kernel for the second order space derivatives. I have written a simple code for a problem attached here. Can you please guide me if this is a correct usage or not?\n\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    nx = 60 \n    xmax = 30\n[]\n[Variables]\n    [u]\n    []\n    [v]\n    []\n[]\n\n[Kernels]\n  [1_diff_u]\n    type = ADMatDiffusion\n    diffusivity = 1\n    variable = u\n  []\n  [1_diff_v]\n    type = ADMatDiffusion\n    diffusivity = 2\n    variable = u\n    v = v\n  []\n  [2_diff_u]\n    type = ADMatDiffusion\n    diffusivity = 3\n    variable = v\n    v = u\n  []\n  [2_diff_v]\n    type = ADMatDiffusion\n    diffusivity = 4\n    variable = v\n  []\n[]\n\n[BCs]\n  [left_u]\n    type = DirichletBC\n    variable = u\n    boundary = left\n    value = 0\n  []\n  [right_u]\n    type = DirichletBC\n    variable = u\n    boundary = right\n    value = 10\n  []\n  [left_v]\n    type = DirichletBC\n    variable = v\n    boundary = left\n    value = 0\n  []\n  [right_v]\n    type = DirichletBC\n    variable = v\n    boundary = right\n    value = 10\n  []\n[]\n[Executioner]\n     type = Steady\n     nl_max_its = 100\n     solve_type = Newton\n[]\n[VectorPostprocessors]\n  [u]\n    type = NodalValueSampler\n    sort_by = id\n    variable = u\n  []\n  [v]\n    type = NodalValueSampler\n    sort_by = id\n    variable = v\n  []\n[]\n[Outputs]\n  [out]\n    type = CSV\n    execute_on = final\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/24059#discussioncomment-5661761",
                  "updatedAt": "2023-04-19T14:59:31Z",
                  "publishedAt": "2023-04-19T14:10:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes this seems fine actually",
                          "url": "https://github.com/idaholab/moose/discussions/24059#discussioncomment-5662274",
                          "updatedAt": "2023-04-19T14:53:54Z",
                          "publishedAt": "2023-04-19T14:53:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "K-Komal-98"
                  },
                  "bodyText": "Thank you",
                  "url": "https://github.com/idaholab/moose/discussions/24059#discussioncomment-5760776",
                  "updatedAt": "2023-04-29T09:21:25Z",
                  "publishedAt": "2023-04-29T09:21:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "a libMesh error in ThreadedElementLoopBase",
          "author": {
            "login": "DYLDYLDYL"
          },
          "bodyText": "Hello\nI'd like to ask you about my \"Solve Did NOT Converge!\" My dt = 10day.\nTime Step 8, time = 6.912e+06, dt = 864000\n 0 Nonlinear |R| = 5.542185e-01\n      0 Linear |R| = 5.542185e-01\n     \u2026\u2026\n      9 Linear |R| = 1.099421e-06\n  Elem Information\n   id()=31, unique_id()=11306, processor_id()=0\n   type()=HEX8\n   dim()=3\n   n_nodes()=8\n   mapping=LAGRANGE_MAP\n    0  Node id()=78, processor_id()=0, Point=(x,y,z)=(0.00347698, 0.000283549, 0.0251831)\n    DoFs=(0/0/312) (0/1/313) (0/2/314) (0/3/315) (1/0/156) (1/1/157) \n    1  Node id()=76, processor_id()=0, Point=(x,y,z)=(0.00340455, 0.00028917, 0.0251833)\n    DoFs=(0/0/304) (0/1/305) (0/2/306) (0/3/307) (1/0/152) (1/1/153) \n   \u2026\u2026\nWe caught a libMesh error in ThreadedElementLoopBase\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n Solve Did NOT Converge!\n\nThanks in advance for your help!",
          "url": "https://github.com/idaholab/moose/discussions/23714",
          "updatedAt": "2023-06-24T22:32:15Z",
          "publishedAt": "2023-03-14T12:00:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSorry we missed this.\nThere's not enough information there, we would need your input file, mesh and what you used to run this\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23714#discussioncomment-5759721",
                  "updatedAt": "2023-04-29T03:12:31Z",
                  "publishedAt": "2023-04-29T03:12:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Modifying BCs",
          "author": {
            "login": "mjyang123"
          },
          "bodyText": "Hi! I am new to Moose, and new to C++ coding. I have this code snippet that describes the boundary condition of a plate, how do I change them so it fits this new image I have attached? I want to try different boundary conditions where my edges are fixed, free, and semi-fixed? How do I modify the codes? The code right now is for free edges. Thank you!\n\n\nThe entire code is:\nE = 2.1e5\nnu = 0.3\nK = '${fparse E/3/(1-2*nu)}'\nG = '${fparse E/2/(1+nu)}'\n\nGc = 2.7\nl = 0.02\n\n[MultiApps]\n  [fracture]\n    type = TransientMultiApp\n    input_files = fracture.i\n    cli_args = 'Gc=${Gc};l=${l}'\n    execute_on = 'TIMESTEP_END'\n  []\n[]\n\n[Transfers]\n  [from_d]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = from_multiapp\n    variable = d\n    source_variable = d\n  []\n  [to_psie_active]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = to_multiapp\n    variable = psie_active\n    source_variable = psie_active\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 30\n    ny = 15\n    ymax = 0.5\n  []\n  [noncrack]\n    type = BoundingBoxNodeSetGenerator\n    input = gen\n    new_boundary = noncrack\n    bottom_left = '0.5 0 0'\n    top_right = '1 0 0'\n  []\n  construct_side_list_from_node_list = true\n[]\n\n[Adaptivity]\n  marker = marker\n  initial_marker = marker\n  initial_steps = 2\n  stop_time = 0\n  max_h_level = 2\n  [Markers]\n    [marker]\n      type = BoxMarker\n      bottom_left = '0.4 0 0'\n      top_right = '1 0.05 0'\n      outside = DO_NOTHING\n      inside = REFINE\n    []\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n[]\n\n[AuxVariables]\n  [fy]\n  []\n  [d]\n  []\n[]\n\n[Kernels]\n  [solid_x]\n    type = ADStressDivergenceTensors\n    variable = disp_x\n    component = 0\n  []\n  [solid_y]\n    type = ADStressDivergenceTensors\n    variable = disp_y\n    component = 1\n    save_in = fy\n  []\n[]\n\n[BCs]\n  [ydisp]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = top\n    function = 't'\n  []\n  [yfix]\n    type = DirichletBC\n    variable = disp_y\n    boundary = noncrack\n    value = 0\n  []\n  [xfix]\n    type = DirichletBC\n    variable = disp_x\n    boundary = top\n    value = 0\n  []\n[]\n\n[Materials]\n  [bulk]\n    type = ADGenericConstantMaterial\n    prop_names = 'K G'\n    prop_values = '${K} ${G}'\n  []\n  [degradation]\n    type = PowerDegradationFunction\n    f_name = g\n    function = (1-d)^p*(1-eta)+eta\n    phase_field = d\n    parameter_names = 'p eta '\n    parameter_values = '2 1e-6'\n  []\n  [strain]\n    type = ADComputeSmallStrain\n  []\n  [elasticity]\n    type = SmallDeformationIsotropicElasticity\n    bulk_modulus = K\n    shear_modulus = G\n    phase_field = d\n    degradation_function = g\n    decomposition = NONE\n    output_properties = 'elastic_strain psie_active'\n    outputs = exodus\n  []\n  [stress]\n    type = ComputeSmallDeformationStress\n    elasticity_model = elasticity\n    output_properties = 'stress'\n    outputs = exodus\n  []\n[]\n\n[Postprocessors]\n  [Fy]\n    type = NodalSum\n    variable = fy\n    boundary = top\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu       superlu_dist                 '\n  automatic_scaling = true\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-10\n\n  dt = 2e-5\n  end_time = 3.5e-3\n\n  fixed_point_max_its = 20\n  accept_on_max_fixed_point_iteration = true\n  fixed_point_rel_tol = 1e-8\n  fixed_point_abs_tol = 1e-10\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23882",
          "updatedAt": "2023-04-29T03:03:33Z",
          "publishedAt": "2023-03-29T12:18:50Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "There should be a tutorial for mode II fracture...",
                  "url": "https://github.com/idaholab/moose/discussions/23882#discussioncomment-5465480",
                  "updatedAt": "2023-03-29T12:40:17Z",
                  "publishedAt": "2023-03-29T12:40:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mjyang123"
                          },
                          "bodyText": "If I want to make the top half fixed, do I modify the code to this:\n[BCs]\n  [xdisp]\n    type = FunctionDirichletBC\n    variable = 'disp_x'\n    boundary = 'top_half_top'\n    value = 0\n  []\n\nJust like the bottom half. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/23882#discussioncomment-5465810",
                          "updatedAt": "2023-03-29T13:17:28Z",
                          "publishedAt": "2023-03-29T13:17:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to use RankTwoTensor within MOOSE? Tried following the documentation but I'm still having issues.",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "I have a custom material class where I want to calculate some values from the strain tensor. I calculated the strain tensor with the \"ADComputeSmallStrain\" material class and fed it into mine.\nThe strain tensor can be accessed as  _strain[_qp] , correct? I have used components of the strain in other parts of the code, and they all seem to be Real/Doubles. For example, computing the 1st invariant:\nADReal I_1 = _strain[_qp](0,0) + _strain[_qp](1,1) + _strain[_qp](2,2); \nworks fine.\nNow I want to calculate the principal strains, which can be gotten from the eigenvalues of the strain tensor. I found this documentation for working with RankTwoTensors:\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classRankTwoTensorTempl.html#ad2be11b8c319023932c59f2b09d330b1\nHere's where the confusion begins. The header describes the function as:\nvoid RankTwoTensorTempl< T >::symmetricEigenvalues (std::vector< T > & eigvals) const\nThat is, a function with only one argument. How is the symmetricEigenvalues function supposed to compute the eigenvalues without me even passing the tensor to it?\nNext, an example is given as:\n{ RankTwoTensorTempl<T> a; symmetricEigenvaluesEigenvectors (eigvals, a); }\nwhere you actually do pass the tensor to it and it edits the vector in place, I assume, with the eigenvalues. This function has a slightly different name, though. I tried it, and couldn't get it to work because of yet another problem- the function does not recognize _strain[_qp] as a RankTwoTensor.\nI tried what I could find to convert it to a rank two tensor, even initializing the individual components like in the documentation:\nRankTwoTensor A(1, 2, 3, 4, 5, 6, 7, 8, 9); // A = [ 1 4 7 //       2 5 8 //       3 6 9 ]\ni.e,\nRankTwoTensor A(_strain[_qp](0,0), ...)\nbut that does not seem to work. I also noticed that when I tried to intialize a RankTwoTensor, other methods mentioned in the documentation were not found. For example, A.square() to find the square of the tensor.\nCan someone please point me in the right direction on how to do tensor algebra within MOOSE? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/24210",
          "updatedAt": "2023-04-28T17:23:15Z",
          "publishedAt": "2023-04-28T00:40:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I have a custom material class where I want to calculate some values from the strain tensor. I calculated the strain tensor with the \"ADComputeSmallStrain\" material class and fed it into mine.\nThe strain tensor can be accessed as  _strain[_qp] , correct? I have used components of the strain in other parts of the code, and they all seem to be Real/Doubles. For example, computing the 1st invariant:\nADReal I_1 = _strain[_qp](0,0) + _strain[_qp](1,1) + _strain[_qp](2,2); \nworks fine.\n\nCorrect. More concisely,\nADReal I_1 = _strain[_qp].trace();\n\n\nNow I want to calculate the principal strains, which can be gotten from the eigenvalues of the strain tensor. I found this documentation for working with RankTwoTensors:\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classRankTwoTensorTempl.html#ad2be11b8c319023932c59f2b09d330b1\nHere's where the confusion begins. The header describes the function as:\nvoid RankTwoTensorTempl< T >::symmetricEigenvalues (std::vector< T > & eigvals) const\nThat is, a function with only one argument. How is the symmetricEigenvalues function supposed to compute the eigenvalues without me even passing the tensor to it?\n\nThis is C++ basic. See tutorials on C++ classes, for example this one https://cplusplus.com/doc/tutorial/classes/\nWhat you need is\nstd::vector<ADReal> eigvals;\nA.symmetricEigevalues(eigvals);\n\n\nNext, an example is given as:\n{ RankTwoTensorTempl<T> a; symmetricEigenvaluesEigenvectors (eigvals, a); }\nwhere you actually do pass the tensor to it and it edits the vector in place, I assume, with the eigenvalues. This function has a slightly different name, though. I tried it, and couldn't get it to work because of yet another problem- the function does not recognize _strain[_qp] as a RankTwoTensor.\n\nThat is not an example. You misread the doxygen documentation. The quoted code below the method definition is its source code.\n\nI tried what I could find to convert it to a rank two tensor, even initializing the individual components like in the documentation:\nRankTwoTensor A(1, 2, 3, 4, 5, 6, 7, 8, 9); // A = [ 1 4 7 // 2 5 8 // 3 6 9 ]\ni.e,\nRankTwoTensor A(_strain[_qp](0,0), ...)\nbut that does not seem to work. I also noticed that when I tried to intialize a RankTwoTensor, other methods mentioned in the documentation were not found. For example, A.square() to find the square of the tensor.\n\nThat should work. Did you get a compiler error, or is it giving you wrong results? If it is a compiler error, the error messages are usually sufficient to help you figure out what's wrong. You can also post the compiler errors here, which is usually a better way than just saying \"that does not seem to work\".\n\nCan someone please point me in the right direction on how to do tensor algebra within MOOSE? Thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5748873",
                  "updatedAt": "2023-04-28T00:53:10Z",
                  "publishedAt": "2023-04-28T00:53:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Thanks for the quick response. I realize I should've included an error message\n error: no matching function for call to 'RankTwoTensorTempl<double>::RankTwoTensorTempl(const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>&, const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>&, const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>&, const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>&, const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>&, const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>&, const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>&, const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>&, const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>&)' 108 |      _strain[_qp](2,0), _strain[_qp](2,1), _strain[_qp](2,2));\nApparently, there is an issue with the \"type\". I keep seeing something about expecting a double instead of a DualNumber. Do I need to individually convert each component to a double first?\nAlso, thank you for clarifying the documentation to me. I see now that the issue is most likely conversion between types.",
                          "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5748967",
                          "updatedAt": "2023-04-28T01:11:31Z",
                          "publishedAt": "2023-04-28T01:11:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "My confusion also comes from trying simpler methods and letting it figure out the type itself with \"auto\". For example:\nauto strain_square = _strain[_qp].square();\nbased on the documentation (https://mooseframework.inl.gov/docs/doxygen/moose/classRankTwoTensorTempl.html#afc410261c1e9a68ffa4ef8721bec7669) gave the error:\nerror: 'MooseADWrapper<RankTwoTensorTempl<double>, true>' {aka 'const class RankTwoTensorTempl<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true> >'} has no member named 'square' 83 |  auto strain_square = _strain[_qp].square();\nI  needed to compute the square of the tensor earlier in the code, but ended up doing it manually with the components. I'd love to be able to figure out what's wrong.\nAlso, I don't know if I missed it, but I couldn't find the documentation for a simple matrix multiplication, i.e A_ij * B_jk.\nI was thinking to simply do _strain[_qp] * _strain[_qp], but wasn't sure.",
                          "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5749011",
                          "updatedAt": "2023-04-28T01:21:53Z",
                          "publishedAt": "2023-04-28T01:21:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The error message suggests that you are trying to construct a non AD RankTwoTensor from ADReals. If your material uses automatic differentiation, it is usually a good idea to make everything AD, e.g., ADReal, ADRealVectorValue, ADRankTwoTensor, ADRankFourTensor, etc., unless you are absolutely sure that something will never need AD.\nYour second error message (on square) is a weird one though. Either the compiler is lying, or you have an outdated MOOSE whose RankTwoTensorTempl does not offer a method called square. You can check the version of your MOOSE using git rev-parse HEAD. Alternatively, open the file RankTwoTensor.h and check if there is a definition of square() which looks like\n  RankTwoTensorTempl<T> square() const;",
                          "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5749078",
                          "updatedAt": "2023-04-28T01:36:05Z",
                          "publishedAt": "2023-04-28T01:36:05Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Also, I don't know if I missed it, but I couldn't find the documentation for a simple matrix multiplication, i.e A_ij * B_jk.\nI was thinking to simply do _strain[_qp] * _strain[_qp], but wasn't sure.\n\nThat's not your fault. The RankTwoTensor class inherits from TypeTensor in libMesh, see\nhttps://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1TypeTensor.html\nSome basic operators are inherited from there.",
                          "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5749104",
                          "updatedAt": "2023-04-28T01:40:07Z",
                          "publishedAt": "2023-04-28T01:40:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Also, if you click on the operator*() in the RankTwoTensor doxygen, it should automatically send you to the right method (in libMesh): https://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1TypeTensor.html#a3f5f5939e09b4b07ecfc9d3ba2c4fc15",
                          "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5749113",
                          "updatedAt": "2023-04-28T01:41:43Z",
                          "publishedAt": "2023-04-28T01:41:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "So I tried to update moose and unearthed another can of worms. Followed the instructions for updating (https://mooseframework.inl.gov/getting_started/new_users.html) and it is compiling with several errors, most of which look like this:\n/home/richmondodufisan/projects/moose/framework/build/header_symlinks/MooseUtils.h:457:46: error: 'TensorTraits' is not a member of 'libMesh::TensorTools' 457 |     else if constexpr (libMesh::TensorTools::TensorTraits<T>::rank == 1) |                                              ^~~~~~~~~~~~ /home/richmondodufisan/projects/moose/framework/build/header_symlinks/MooseUtils.h:457:60: error: expected primary-expression before '>' token 457 |     else if constexpr (libMesh::TensorTools::TensorTraits<T>::rank == 1) |                                                            ^ /home/richmondodufisan/projects/moose/framework/build/header_symlinks/MooseUtils.h:457:63: error: '::rank' has not been declared; did you mean 'std::rank'? 457 |     else if constexpr (libMesh::TensorTools::TensorTraits<T>::rank == 1)\nIs it possible to revert to the previous version of MOOSE that worked fine? What could be the problem here?\n\nRegarding the RankTwoTensor issues, I see- the problem was switching between doubles and ADReals. If I get you right, the default for RankTwoTensor is a non-AD variable, so to initialize an AD Tensor, would I need to do something like this?\nRankTwoTensor<ADReal> A (1, 2, ...)\nI would've tested it but for the issues with MOOSE itself now.",
                          "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5749292",
                          "updatedAt": "2023-04-28T02:00:20Z",
                          "publishedAt": "2023-04-28T02:00:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "If you are using conda, you're probably just missing a conda update --all or mamba update --all. After which you should make clobberall and remake. @GiudGiud may have other suggestions on the updating issue.\nUse RankTwoTensor for non AD tensor, and ADRankTwoTensor for AD tensor. You do not need to provide the template parameter which is included in the typedefs, i.e.\ntypedef RankTwoTensorTempl<Real> RankTwoTensor;\ntypedef RankTwoTensorTempl<ADReal> ADRankTwoTensor;",
                          "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5749321",
                          "updatedAt": "2023-04-28T02:07:01Z",
                          "publishedAt": "2023-04-28T02:07:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Gotcha. Thanks! I did the conda update but it still isn't compiling (same errors). I also tried git clean -xfd and redid make clobberall and make -j4 but it still has the same errors, so I'll wait on @GiudGiud . Thank you so much for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5749408",
                          "updatedAt": "2023-04-28T02:24:26Z",
                          "publishedAt": "2023-04-28T02:24:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does mamba list | grep moose return ?",
                          "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5749722",
                          "updatedAt": "2023-04-28T03:39:27Z",
                          "publishedAt": "2023-04-28T03:39:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "I got\n`Command 'mamba' not found, did you mean:\ncommand 'samba' from deb samba (2:4.13.14+dfsg-0ubuntu0.20.04.4)\nTry: sudo apt install `\nDo I need to install something? The last time I updated MOOSE on this particular computer was probably in late 2021",
                          "url": "https://github.com/idaholab/moose/discussions/24210#discussioncomment-5749741",
                          "updatedAt": "2023-04-28T03:43:46Z",
                          "publishedAt": "2023-04-28T03:43:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "What may a \"Parameter _fe_problem_base is NULL\" means?",
          "author": {
            "login": "WayneX-Wong"
          },
          "bodyText": "Hi all,\nI'm trying to modify a MOOSE-based app to have my custom ability. The compilation process went smoothly, while when I run, an error raised \"Parameter _fe_problem_base is NULL\". What could be the reason for this error?\nI inherit my custom UserObject from TransientInterface to use _t to get current time, where I speculate that the problem may be. My custom UserObject indeed inherited from FEProblemBase, so I don't know exactly what the problem is.\nPlease let me know if more information about my modification needed. And any suggestions will be appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/24182",
          "updatedAt": "2023-04-28T16:53:50Z",
          "publishedAt": "2023-04-26T10:45:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt s very odd that your user object inherits from FEProblemBase and user objects.\nSo that might be challenging.\nWhat are you trying to do?\nThe parameter error is not hard to fix I think. You need to find where it's retrieving the _fe_problem_base pointer parameter, and either change that code OR set the parameter like this:\nparams.set<FEProblemBase *>(\"_fe_problem_base\") = &_fe_problem;\n\nbefore retrieving it\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5733100",
                  "updatedAt": "2023-04-26T15:20:11Z",
                  "publishedAt": "2023-04-26T15:20:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WayneX-Wong"
                          },
                          "bodyText": "Thanks for your reply Guillaume. I will try to fix this error according to your suggestion.\n\nWhat are you trying to do?\n\nI'm trying to realize a time dependent InputParameter in my user object, so I naturally thought of using addParam<FunctionName> to get a ParsedFunction, which need  time and  as input, so\n\nI inherit my custom UserObject from TransientInterface to use _t to get current time.",
                          "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5737497",
                          "updatedAt": "2023-04-27T01:34:49Z",
                          "publishedAt": "2023-04-27T01:34:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Inheriting from transient interface seems fine.\nWhat does your object inherit from currently? Maybe a derived (General, Element etc) user object class makes sense",
                          "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5737509",
                          "updatedAt": "2023-04-27T01:38:02Z",
                          "publishedAt": "2023-04-27T01:38:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WayneX-Wong"
                          },
                          "bodyText": "I'm using OpenMC wrapped in Cardinal, and try to make some modifications on OpenMCCellAverageProblem, which I think is inherited from OpenMCProblemBase and then ExternalProblem, and some other MOOSE based class. So I think this issue may be more related to MOOSE and didn't ask on Cardinal's forum.",
                          "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5737610",
                          "updatedAt": "2023-04-27T01:52:26Z",
                          "publishedAt": "2023-04-27T01:52:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok be mindful that in Cardinal the time is not usually physical time. It might tied to openmc simulation parameters, I dont recall",
                          "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5737623",
                          "updatedAt": "2023-04-27T01:54:41Z",
                          "publishedAt": "2023-04-27T01:54:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WayneX-Wong"
                          },
                          "bodyText": "OK, Thanks again for your patience. I'll have another try",
                          "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5737683",
                          "updatedAt": "2023-04-27T02:06:03Z",
                          "publishedAt": "2023-04-27T02:06:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "Hi @WayneX-Wong - can you explain a bit more what you are trying to do? I might be able to give some ideas on how to accomplish specific things in Cardinal.",
                          "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5737714",
                          "updatedAt": "2023-04-27T02:12:35Z",
                          "publishedAt": "2023-04-27T02:12:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WayneX-Wong"
                          },
                          "bodyText": "Hello @aprilnovak , still that question I asked on Cardinal's forum about CSG modeling parameter, and accroding to your suggestion, which can be realized by fetching openmc::model::surfaces and then modify it in OpenMCCellAverageProblem::setupProblem.\nNow I wanna make some further modification, to get time dependent geometry parameters in OpenMCCellAverageProblem's InputParameter, that's why I raised the above question.\nI'm really sorry that my code was modified on a public LAN computer in the laboratory, so it is not easy to take out (request needed to be submitted). I will showcase my code if more details are needed, while it may take some time to request.",
                          "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5737795",
                          "updatedAt": "2023-04-27T02:31:19Z",
                          "publishedAt": "2023-04-27T02:30:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "What time-dependent information do you want to pass into OpenMC? You can access information in the form of postprocessors (scalar values), auxvariables (mesh-based data), or userobjects (something custom) from inside OpenMCCellAverageProblem (we do all three of these at the moment).\nIf I had to guess, you have a vector of numbers which represent different coefficients of the openMC CSG surfaces? Like, an array of length N where each entry is the new diameter of a pincell?",
                          "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5738306",
                          "updatedAt": "2023-04-27T04:05:12Z",
                          "publishedAt": "2023-04-27T04:05:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WayneX-Wong"
                          },
                          "bodyText": "If I had to guess, you have a vector of numbers which represent different coefficients of the openMC CSG surfaces? Like, an array of length N where each entry is the new diameter of a pincell?\n\nExactly is. To be more specific, I try to modify a z0 of a ZPlane surface after each transient time step. What I thought is to get a ParsedFunction which describe the change of z0 wrt to time, then pass it into OpenMCCellAverageProblem so that I can change openmc::model::surfaces according to that function.",
                          "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5738402",
                          "updatedAt": "2023-04-27T04:26:49Z",
                          "publishedAt": "2023-04-27T04:26:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "All of the methods you can call inside of OpenMCCellAverageProblem are derived from FEProblem - if you go to the Doxygen page, you'll see there is a method called getFunction. I think you should be able to use that to access your function with those values.",
                          "url": "https://github.com/idaholab/moose/discussions/24182#discussioncomment-5738451",
                          "updatedAt": "2023-04-27T04:35:37Z",
                          "publishedAt": "2023-04-27T04:35:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}