{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMS0wNlQwODo0Mzo0OC0wNzowMM4AWMvo"
    },
    "edges": [
      {
        "node": {
          "title": "How to set all nodes in same displacement by BCs?",
          "author": {
            "login": "LifengGan"
          },
          "bodyText": "Dear moose users,\nI want to let all nodes on one surface with same displacement in one paticular direction. But it is not fixed, just all node deformed in the same way in one direction.\nHow can I do that with BCs?\nBest regards,\nLifeng",
          "url": "https://github.com/idaholab/moose/discussions/25961",
          "updatedAt": "2023-11-23T02:01:28Z",
          "publishedAt": "2023-11-03T09:28:49Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can set a DirichletBC on disp_x or disp_y for example.\nAre you solving the solid mechanics equations? Are you solving for the total mesh deformation or are you simply modifying the location of nodes at a certain location?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25961#discussioncomment-7466579",
                  "updatedAt": "2023-11-03T12:38:16Z",
                  "publishedAt": "2023-11-03T12:22:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "LifengGan"
                          },
                          "bodyText": "I just want all the nodes on selected surface moving in the same way, more like a \"weak\" constrain to let nodes tie together\nCound it be done in the follwing way, by not define the value? I want those to be passive movement\n[./right_v]\n  type = DirichletBC\n  variable = disp_x\n  boundary = right\n[../]",
                          "url": "https://github.com/idaholab/moose/discussions/25961#discussioncomment-7468414",
                          "updatedAt": "2023-11-03T15:29:12Z",
                          "publishedAt": "2023-11-03T15:29:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it would not be done like that. DirichletBCs impose a value.\nDo you want to impose the displacement value or just constrain the nodes to move together with the same amplitude / direction?",
                          "url": "https://github.com/idaholab/moose/discussions/25961#discussioncomment-7468483",
                          "updatedAt": "2023-11-03T15:36:34Z",
                          "publishedAt": "2023-11-03T15:36:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LifengGan"
                          },
                          "bodyText": "Yes, the latter, just constrain the nodes to move together with the same amplitude / direction",
                          "url": "https://github.com/idaholab/moose/discussions/25961#discussioncomment-7468729",
                          "updatedAt": "2023-11-03T16:01:33Z",
                          "publishedAt": "2023-11-03T16:01:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You'll want to work in the Constraints system.\nBut we don't have this object right now. So you ll have to make a new one",
                          "url": "https://github.com/idaholab/moose/discussions/25961#discussioncomment-7469107",
                          "updatedAt": "2023-11-03T16:36:54Z",
                          "publishedAt": "2023-11-03T16:36:53Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LifengGan"
                          },
                          "bodyText": "Thanks a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/25961#discussioncomment-7472728",
                          "updatedAt": "2023-11-04T06:25:34Z",
                          "publishedAt": "2023-11-04T06:25:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LifengGan"
                          },
                          "bodyText": "Hi, @GiudGiud\nMaybe it can be done this way?\n[Constraints]\n  [./z_top]\n    type = EqualValueBoundaryConstraint\n    variable = disp_z\n    primary = '45' # node on top boundary\n    secondary = 'top' # boundary\n    penalty = 10e6\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/25961#discussioncomment-7493780",
                          "updatedAt": "2023-11-08T09:33:38Z",
                          "publishedAt": "2023-11-07T01:55:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So one node by one node? You can try but these constraints come at a cost (harder to solve)\nIt's also not very friendly if you have 100 nodes to set together, or if you go from one mesh to another mesh (all the ids change)\nso I would develop a custom constraint instead",
                          "url": "https://github.com/idaholab/moose/discussions/25961#discussioncomment-7510063",
                          "updatedAt": "2023-11-08T12:37:18Z",
                          "publishedAt": "2023-11-08T12:32:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LifengGan"
                          },
                          "bodyText": "Here the idea is to use  EqualValueBoundaryConstraint to link the surface top and the node with id 45, which is also one node on top surface. And we those nodes in top surface can move in the same way.\nIf develop a custon constraint, which one i should take it as reference? and any suggestions on that?",
                          "url": "https://github.com/idaholab/moose/discussions/25961#discussioncomment-7511394",
                          "updatedAt": "2023-11-08T14:25:36Z",
                          "publishedAt": "2023-11-08T14:25:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I havent worked much with Constraints unfortunately.\nI see @bwspenc @jbadger95 and @dschwen have contributed to that system, if they want to guide you",
                          "url": "https://github.com/idaholab/moose/discussions/25961#discussioncomment-7513378",
                          "updatedAt": "2023-11-08T17:19:23Z",
                          "publishedAt": "2023-11-08T17:19:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some tests fail",
          "author": {
            "login": "bylore"
          },
          "bodyText": "Hi, I am building moose on  HPC cluster. Follwing the construction, I arrive at the test step. After excuting the ./run_test -j 6. I get the following.\n\nmesh/split_uniform_refine.square ................................................. [min_cpus=3] FAILED (CRASH)\nmesh/mesh_only.mesh_only_checkpoint .............................................. [min_cpus=3] FAILED (CRASH)\npostprocessors/num_elems.test_split .............................................. [min_cpus=4] FAILED (CRASH)\nmesh/nemesis.nemesis_repartitioning_test ......................................... [min_cpus=4] FAILED (CRASH)\npartitioners/petsc_partitioner.ptscotch ........................ [min_cpus=4] FAILED (EXPECTED OUTPUT MISSING)\npartitioners/petsc_partitioner.ptscotch_weight_elment .......... [min_cpus=4] FAILED (EXPECTED OUTPUT MISSING)\npostprocessors/num_nodes.test_split .............................................. [min_cpus=4] FAILED (CRASH)\npartitioners/petsc_partitioner.ptscotch_weight_side ............ [min_cpus=4] FAILED (EXPECTED OUTPUT MISSING)\npartitioners/petsc_partitioner.ptscotch_weight_both ............ [min_cpus=4] FAILED (EXPECTED OUTPUT MISSING)\npartitioners/petsc_partitioner.parmetis ........................ [min_cpus=4] FAILED (EXPECTED OUTPUT MISSING)\npartitioners/petsc_partitioner.parmetis_weight_element ......... [min_cpus=4] FAILED (EXPECTED OUTPUT MISSING)\npartitioners/petsc_partitioner.parmetis_weight_side ............ [min_cpus=4] FAILED (EXPECTED OUTPUT MISSING)\npartitioners/petsc_partitioner.parmetis_weight_both ............ [min_cpus=4] FAILED (EXPECTED OUTPUT MISSING)\n\n\nRan 3919 tests in 526.5 seconds. Average test time 0.7 seconds, maximum test time 23.6 seconds.\n3906 passed, 200 skipped, 0 pending, 13 FAILED\nDo you have any advice? Can I just ignore thest failures, or what these failure mean? Thank you!",
          "url": "https://github.com/idaholab/moose/discussions/25999",
          "updatedAt": "2023-11-08T16:31:22Z",
          "publishedAt": "2023-11-08T06:39:54Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "bylore"
                  },
                  "bodyText": "It seems these failures related to my mpich (4.0.2) mpich/install/lib/libucs.so.0",
                  "url": "https://github.com/idaholab/moose/discussions/25999#discussioncomment-7506853",
                  "updatedAt": "2023-11-08T07:02:19Z",
                  "publishedAt": "2023-11-08T07:02:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "configure --with-ucx=embedded",
                          "url": "https://github.com/idaholab/moose/discussions/25999#discussioncomment-7506884",
                          "updatedAt": "2023-11-08T07:07:11Z",
                          "publishedAt": "2023-11-08T07:07:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "If you happen to have the exact errors produced, can you paste those?",
                          "url": "https://github.com/idaholab/moose/discussions/25999#discussioncomment-7512537",
                          "updatedAt": "2023-11-08T16:06:09Z",
                          "publishedAt": "2023-11-08T16:06:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "run_tests --re=mesh/split_uniform_refine.square -v for example.\n\nmesh/split_uniform_refine.square: Working Directory: */moose/test/tests/mesh/split_uniform_refine\nmesh/split_uniform_refine.square: Running command: mpiexec -n 3 */moose/test/moose_test-opt -i 3d_diffusion.i -r 1 Mesh/skip_refine_when_use_split=false --use-split --split-file square --error --error-override --no-gdb-backtrace\nmesh/split_uniform_refine.square:\nmesh/split_uniform_refine.square: ===================================================================================\nmesh/split_uniform_refine.square: =   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\nmesh/split_uniform_refine.square: =   PID 21523 RUNNING AT ln3\nmesh/split_uniform_refine.square: =   EXIT CODE: 139\nmesh/split_uniform_refine.square: =   CLEANING UP REMAINING PROCESSES\nmesh/split_uniform_refine.square: =   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\nmesh/split_uniform_refine.square: ===================================================================================\nmesh/split_uniform_refine.square: YOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)\nmesh/split_uniform_refine.square: This typically refers to a problem with your application.\nmesh/split_uniform_refine.square: Please see the FAQ page for debugging suggestions\nmesh/split_uniform_refine.square: [ln3:21523:0:21523] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x30)\nmesh/split_uniform_refine.square: ==== backtrace (tid:  21523) ====\nmesh/split_uniform_refine.square:  0  /data/home/yongzhang/software/mpich/install/lib/libucs.so.0(ucs_handle_error+0x2a4) [0x7f087cbd3674]\nmesh/split_uniform_refine.square:  1  /mpich/install/lib/libucs.so.0(+0x2f86c) [0x7f087cbd386c]\nmesh/split_uniform_refine.square:  2  /mpich/install/lib/libucs.so.0(+0x2fb36) [0x7f087cbd3b36]\nmesh/split_uniform_refine.square:  3  /lib64/libpthread.so.0(+0xf630) [0x7f087c56f630]\nmesh/split_uniform_refine.square:  4  */moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(+0xcb4388) [0x7f0886a65388]\nmesh/split_uniform_refine.square:  5  */moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(_ZN7libMesh11Partitioner22set_node_processor_idsERNS_8MeshBaseE+0x10c1) [0x7f0886a71431]\nmesh/split_uniform_refine.square:  6  */moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(_ZN7libMesh11Partitioner9partitionERNS_8MeshBaseEj+0x61) [0x7f0886a71b91]\nmesh/split_uniform_refine.square:  7  */moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(_ZN7libMesh8MeshBase15prepare_for_useEv+0x6a) [0x7f08867da6ea]\nmesh/split_uniform_refine.square:  8  */moose/framework/libmoose-opt.so.0(_ZN10Adaptivity13uniformRefineEP9MooseMeshj+0x5a) [0x7f088af1fb2a]\nmesh/split_uniform_refine.square:  9  */moose/framework/libmoose-opt.so.0(_ZN23SetupMeshCompleteAction3actEv+0x3e8) [0x7f088ac17278]\nmesh/split_uniform_refine.square: 10  */moose/framework/libmoose-opt.so.0(_ZN6Action8timedActEv+0x2b) [0x7f088ac1470b]\nmesh/split_uniform_refine.square: 11  */moose/framework/libmoose-opt.so.0(_ZN15ActionWarehouse24executeActionsWithActionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x51) [0x7f088ac20451]\nmesh/split_uniform_refine.square: 12  */moose/framework/libmoose-opt.so.0(_ZN15ActionWarehouse17executeAllActionsEv+0x1a1) [0x7f088ac20ad1]\nmesh/split_uniform_refine.square: 13  */moose/framework/libmoose-opt.so.0(_ZN8MooseApp12runInputFileEv+0x88) [0x7f088aed9428]\nmesh/split_uniform_refine.square: 14  */moose/framework/libmoose-opt.so.0(_ZN8MooseApp3runEv+0x302) [0x7f088aed8b02]\nmesh/split_uniform_refine.square: 15  */moose/test/moose_test-opt(main+0x6f) [0x40236f]\nmesh/split_uniform_refine.square: 16  /lib64/libc.so.6(__libc_start_main+0xf5) [0x7f087ab21555]\nmesh/split_uniform_refine.square: 17  */moose/test/moose_test-opt() [0x4025c1]\nmesh/split_uniform_refine.square: =================================\nmesh/split_uniform_refine.square:\nmesh/split_uniform_refine.square: ===================================================================================\nmesh/split_uniform_refine.square: =   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\nmesh/split_uniform_refine.square: =   PID 21523 RUNNING AT ln3\nmesh/split_uniform_refine.square: =   EXIT CODE: 139\nmesh/split_uniform_refine.square: =   CLEANING UP REMAINING PROCESSES\nmesh/split_uniform_refine.square: =   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\nmesh/split_uniform_refine.square: ===================================================================================\nmesh/split_uniform_refine.square: YOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)\nmesh/split_uniform_refine.square: This typically refers to a problem with your application.\nmesh/split_uniform_refine.square: Please see the FAQ page for debugging suggestions\nmesh/split_uniform_refine.square: [ln3:21523:0:21523] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x30)\nmesh/split_uniform_refine.square: ==== backtrace (tid:  21523) ====\nmesh/split_uniform_refine.square:  0  /install/lib/libucs.so.0(ucs_handle_error+0x2a4) [0x7f087cbd3674]\nmesh/split_uniform_refine.square:  1  /install/lib/libucs.so.0(+0x2f86c) [0x7f087cbd386c]\nmesh/split_uniform_refine.square:  2  /install/lib/libucs.so.0(+0x2fb36) [0x7f087cbd3b36]\nmesh/split_uniform_refine.square:  3  /lib64/libpthread.so.0(+0xf630) [0x7f087c56f630]\nmesh/split_uniform_refine.square:  4  */moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(+0xcb4388) [0x7f0886a65388]\nmesh/split_uniform_refine.square:  5  */moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(_ZN7libMesh11Partitioner22set_node_processor_idsERNS_8MeshBaseE+0x10c1) [0x7f0886a71431]\nmesh/split_uniform_refine.square:  6  */moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(_ZN7libMesh11Partitioner9partitionERNS_8MeshBaseEj+0x61) [0x7f0886a71b91]\nmesh/split_uniform_refine.square:  7  */moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(_ZN7libMesh8MeshBase15prepare_for_useEv+0x6a) [0x7f08867da6ea]\nmesh/split_uniform_refine.square:  8  */moose/framework/libmoose-opt.so.0(_ZN10Adaptivity13uniformRefineEP9MooseMeshj+0x5a) [0x7f088af1fb2a]\nmesh/split_uniform_refine.square:  9  */moose/framework/libmoose-opt.so.0(_ZN23SetupMeshCompleteAction3actEv+0x3e8) [0x7f088ac17278]\nmesh/split_uniform_refine.square: 10  */moose/framework/libmoose-opt.so.0(_ZN6Action8timedActEv+0x2b) [0x7f088ac1470b]\nmesh/split_uniform_refine.square: 11  */moose/framework/libmoose-opt.so.0(_ZN15ActionWarehouse24executeActionsWithActionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x51) [0x7f088ac20451]\nmesh/split_uniform_refine.square: 12  */moose/framework/libmoose-opt.so.0(_ZN15ActionWarehouse17executeAllActionsEv+0x1a1) [0x7f088ac20ad1]\nmesh/split_uniform_refine.square: 13  */moose/framework/libmoose-opt.so.0(_ZN8MooseApp12runInputFileEv+0x88) [0x7f088aed9428]\nmesh/split_uniform_refine.square: 14  */moose/framework/libmoose-opt.so.0(_ZN8MooseApp3runEv+0x302) [0x7f088aed8b02]\nmesh/split_uniform_refine.square: 15  */moose/test/moose_test-opt(main+0x6f) [0x40236f]\nmesh/split_uniform_refine.square: 16  /lib64/libc.so.6(__libc_start_main+0xf5) [0x7f087ab21555]\nmesh/split_uniform_refine.square: 17  */moose/test/moose_test-opt() [0x4025c1]\nmesh/split_uniform_refine.square: =================================\nmesh/split_uniform_refine.square:\nmesh/split_uniform_refine.square:\nmesh/split_uniform_refine.square: Exit Code: 139\nmesh/split_uniform_refine.square: ################################################################################\nmesh/split_uniform_refine.square: Tester failed, reason: CRASH\nmesh/split_uniform_refine.square:\nmesh/split_uniform_refine.square ....................................... [min_cpus=3,OVERSIZED] FAILED (CRASH)",
                          "url": "https://github.com/idaholab/moose/discussions/25999#discussioncomment-7512777",
                          "updatedAt": "2023-11-08T16:32:59Z",
                          "publishedAt": "2023-11-08T16:27:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "I just tried mpich-4.1.2 configure --with-ucx=embeded, and these failure tests all passed! So there seems to be some mismatch between mpich-4.0.2 (--with-ucx=embeded) and the latest moose(2023.11.09).",
                          "url": "https://github.com/idaholab/moose/discussions/25999#discussioncomment-7512813",
                          "updatedAt": "2023-11-08T16:31:22Z",
                          "publishedAt": "2023-11-08T16:31:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Computing Vector Electric Field from grad V",
          "author": {
            "login": "jsevic"
          },
          "bodyText": "I think I should know this by now, I have voltage V as a state variable and I want to compute E = grad V as a vector so I can use in Paraview. I have this in an AuxKernel I get a compile error as follows...\nerror: no viable conversion from returned value of type 'const libMesh::VectorValue' to function return type 'libMesh::Real' (aka 'double')\nreturn  _grad_V[_qp];\n^~~~~~~~~~~~\n/Users/johnsevic/projects/xenon/src/auxkernels/ElectricFieldVector.C:47:10: error: no viable conversion from returned value of type 'const libMesh::VectorValue' to function return type 'libMesh::Real' (aka 'double')\nreturn _grad_V[_qp];\nIn my .h file I declared as follows...\n  const VariableGradient & _grad_V;\n  const VariableValue & _D;\n\nIn my .c file I have the following...\nInputParameters\nElectricFieldVector::validParams()\n{\n  InputParameters params = Kernel::validParams();\nparams.addRequiredCoupledVar(\"coupled_V\", \"grad V is E\");\nparams.addRequiredCoupledVar(\"coupled_sigma\", \"The sigma variable\");\n\n  return params;\n}\n\nElectricFieldVector::ElectricFieldVector(const InputParameters & parameters)\n  : Kernel(parameters),\n    _grad_V(coupledGradient(\"coupled_V\")),\n    _D(coupledValue(\"coupled_sigma\"))\n{\n}\n\nReal\nElectricFieldVector::computeQpResidual()\n{\n  return  _grad_V[_qp];\n}\n\nReal\nElectricFieldVector::computeQpJacobian()\n{\n  return _grad_V[_qp];\n}\n\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/25993",
          "updatedAt": "2023-11-08T01:37:39Z",
          "publishedAt": "2023-11-07T20:32:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "The error you are seeing is because the computeQpResidual method wants a Real number, but you are attempting to return a RealVectorValue.\nIf you are only wanting E for visualization, I would compute this as a VectorAuxKernel instead of inheriting from Kernel. Then, you'd only need to define a computeValue method (removing the Residual and Jacobian methods you have defined).\nDid you mean in your original message that you wanted to compute E = - grad V? That's the normal form I see it in. Thus computeValue would simply be\nRealVectorValue\nElectricFieldVector::computeValue()\n{\n   return -_grad_V[_qp];\n}",
                  "url": "https://github.com/idaholab/moose/discussions/25993#discussioncomment-7503712",
                  "updatedAt": "2023-11-07T21:45:51Z",
                  "publishedAt": "2023-11-07T21:45:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jsevic"
                          },
                          "bodyText": "That works thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/25993#discussioncomment-7505013",
                          "updatedAt": "2023-11-08T01:37:37Z",
                          "publishedAt": "2023-11-08T01:37:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Import EBSD data error",
          "author": {
            "login": "LifengGan"
          },
          "bodyText": "Dear moose users,\nI am trying import ebsd data from deam3d\nThe error message I got when I runing modules/phase_field/test/tests/reconstruction/1phase_reconstruction.i with input file of\nSmall_IN100.txt\nfrom dream3d through\nINL_Export.json\nThe following error occurred in the object \"ebsd_reader\", of type \"EBSDReader\".\nData point must be on the interior of the mesh elements. In EBSD Reader ebsd_reader\n\nBest regards,\nLifeng",
          "url": "https://github.com/idaholab/moose/discussions/25960",
          "updatedAt": "2023-11-07T07:34:01Z",
          "publishedAt": "2023-11-03T05:34:53Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nis the error message inaccurate? What is the spatial extent of your mesh?\nEBSD data seems to lie in [-50,0] x [0.50]\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25960#discussioncomment-7466615",
                  "updatedAt": "2023-11-03T12:27:12Z",
                  "publishedAt": "2023-11-03T12:27:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "LifengGan"
                          },
                          "bodyText": "Probably not accurate. I dont know how to set mesh element spatial extent,\nThe X_MIN, X_MAX, Y_MIN, Y_MAX is given in this file, and there is no limit setting of size in the i file? (I just only change the input file name)\nSo why me data point did not on the interior of the mesh elements?",
                          "url": "https://github.com/idaholab/moose/discussions/25960#discussioncomment-7469026",
                          "updatedAt": "2023-11-03T16:27:50Z",
                          "publishedAt": "2023-11-03T16:27:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does your mesh block look like? in your MOOSE simulation input file",
                          "url": "https://github.com/idaholab/moose/discussions/25960#discussioncomment-7470092",
                          "updatedAt": "2023-11-03T18:47:06Z",
                          "publishedAt": "2023-11-03T18:37:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LifengGan"
                          },
                          "bodyText": "Here is the mesh block\n[Mesh]\n  [ebsd_mesh]\n    type = EBSDMeshGenerator\n    filename = Small_IN100.txt\n    show_info = true\n  []\n[]\n\n\nand show_info gives\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m Mesh Information:\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  elem_dimensions()={3}\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  spatial_dimension()=3\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  n_nodes()=76760\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m    n_local_nodes()=76760\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  n_elem()=37989\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m    n_local_elem()=37989\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m    n_active_elem()=37989\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  n_subdomains()=1\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  n_elemsets()=0\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  n_partitions()=1\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  n_processors()=1\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  n_threads()=1\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  processor_id()=0\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  is_prepared()=false\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  is_replicated()=true\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m Mesh Bounding Box:\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Minimum: (x,y,z)=(     -47,        0,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Maximum: (x,y,z)=(    0.25,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Delta:   (x,y,z)=(   47.25,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m Mesh Element Type(s):\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  HEX8\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m Mesh Nodesets:\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Nodeset 0 (back), 38380 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,        0,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,    50.25,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(   47.25,    50.25,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Nodeset 1 (bottom), 380 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,        0,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,        0,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(   47.25,        0,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Nodeset 2 (right), 404 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(    0.25,        0,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Nodeset 3 (top), 380 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,    50.25,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(   47.25,        0,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Nodeset 4 (left), 404 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,        0,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(     -47,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Nodeset 5 (front), 38380 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,        0,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(   47.25,    50.25,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m Mesh Sidesets:\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Sideset 0 (back), 37989 sides (QUAD4), 37989 elems (HEX8), 38380 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Side volume: 2374.31\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,        0,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,    50.25,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(   47.25,    50.25,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Sideset 1 (bottom), 189 sides (QUAD4), 189 elems (HEX8), 380 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Side volume: 47.25\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,        0,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,        0,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(   47.25,        0,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Sideset 2 (right), 201 sides (QUAD4), 201 elems (HEX8), 404 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Side volume: 50.25\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(    0.25,        0,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Sideset 3 (top), 189 sides (QUAD4), 189 elems (HEX8), 380 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Side volume: 47.25\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,    50.25,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(   47.25,        0,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Sideset 4 (left), 201 sides (QUAD4), 201 elems (HEX8), 404 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Side volume: 50.25\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,        0,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(     -47,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Sideset 5 (front), 37989 sides (QUAD4), 37989 elems (HEX8), 38380 nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Side volume: 2374.31\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,        0,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(   47.25,    50.25,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m Mesh Edgesets:\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  None\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m Mesh Subdomains:\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Subdomain 0: 37989 elems (HEX8, 37989 active), 76760 active nodes\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Volume: 2374.31\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box minimum: (x,y,z)=(     -47,        0,        0)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box maximum: (x,y,z)=(    0.25,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m   Bounding box delta: (x,y,z)=(   47.25,    50.25,        1)\n\ufffd[36mEBSDMeshGenerator 'ebsd_mesh': \ufffd[39m  Global mesh volume = 2374.31",
                          "url": "https://github.com/idaholab/moose/discussions/25960#discussioncomment-7494181",
                          "updatedAt": "2023-11-07T05:15:36Z",
                          "publishedAt": "2023-11-07T03:07:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LifengGan"
                          },
                          "bodyText": "I update my DREAM3D from 6.5.141 to 6.5.171, then I sort this out. Thanks a lot for your reply.",
                          "url": "https://github.com/idaholab/moose/discussions/25960#discussioncomment-7495651",
                          "updatedAt": "2023-11-07T07:33:57Z",
                          "publishedAt": "2023-11-07T07:33:56Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Improving 'LinearNodalConstraint' as a means to apply periodic BC's more conveniently",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Hi,\nI was using LinearNodalConstraint to constrain my periodic boundaries for an example model with minimal set of nodes and obtained results that are realistic enough to be applicable for bigger models. The issue being that, this class only accepts direct node numbers as a way of specifying the periodic boundaries and this i feel might get replaced (or perhaps included) with boundary ID's option if we've to go bigger. In principle, i am interested in solving the following set of constraint equations for the model here i am considering.\n\nLooking at these equations, i see that we may have to innovate slightly here to implement these equations in a more simplistic manner. Creation of boundary ID's for the primary and secondary faces will help here, as it's hard for the user to specify many number of nodes in the input file when the model grows. I am particularly keen on including the third term in the equation in an elegant way, so a manual nodal entry against an item like \"secondary_node_ids\" would be handy here and would be included in the system along with the nodes identified for the boundary ID's. I am kind of checking the various constraint methods implemented in Moose to see if we can specify a mixed way (from ID's and manual entry) of including the participating nodes within the computeQpResidual setup. I welcome your suggestions here and appreciate your references in identifying the right methods to be used as a base for improving this class. I envisage the following block of input commands that best describes this proposed method.\n[./disp_x_1]\n    type = LinearNodalConstraint_new\n    variable = disp_x\n    primary = left\n\tsecondary = right    \n\tsecondary_node_ids = 3\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n[]\n[./disp_y_1]\n    type = LinearNodalConstraint_new\n    variable = disp_y\n    primary = left\n\tsecondary = right    \n\tsecondary_node_ids = 3\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n[]\n[./disp_x_2]\n    type = LinearNodalConstraint_new\n    variable = disp_x\n    primary = bottom\n\tsecondary = top\n\tsecondary_node_ids = 7\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n[]\n[./disp_y_2]\n    type = LinearNodalConstraint_new\n    variable = disp_y\n    primary = bottom\n\tsecondary = top\n\tsecondary_node_ids = 7\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n[]\n\n\nThanks and regards,\nArun",
          "url": "https://github.com/idaholab/moose/discussions/25441",
          "updatedAt": "2023-11-07T04:32:20Z",
          "publishedAt": "2023-09-11T18:30:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "boundary IDs and boundary names would be way better than manually suppling the node IDs",
                  "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-6971642",
                  "updatedAt": "2023-09-11T19:55:28Z",
                  "publishedAt": "2023-09-11T19:55:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is LinearNodalConstraint only accepting one node at a time?",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-6973633",
                          "updatedAt": "2023-09-12T01:28:01Z",
                          "publishedAt": "2023-09-12T01:28:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "It allows passing a vector of node IDs, but still definitely not ideal",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-6973877",
                          "updatedAt": "2023-09-12T02:21:02Z",
                          "publishedAt": "2023-09-12T02:21:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "To be specific it is actually problem dependent. For the case i've described above, i can only specify one secondary node against a set of primary nodes. Specification of multiple secondary nodes may not help here, as it would repetitively process all the primary nodes irrespective of the matching pairs. The proposed implementation should be able to detect the matching pairs from the supplied boundary ID's, plus the additional node (third term) taken from the manual entry of nodes (possibly through 'secondary_node_ids'). I am  looking for the right constraint methods in Moose that has similar way of implementation.",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-6976804",
                          "updatedAt": "2023-09-12T09:31:32Z",
                          "publishedAt": "2023-09-12T09:31:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "Here is an example i am working at present where it requires 8 blocks of this constraint class for matching four pairs of periodic middle nodes. For a reasonably sized problem with 20 pairs, we might need 40 blocks, which is too muck ask on the user.\n# Constraining secondary nodes to move a linear combination of primary nodes\n#\n# The test consists of a 2D rectangular block divided into two Quad elements\n# (along its height) which have different material properties.\n# A displacement of 2 m is applied to the top surface of the block in x direction and the\n# bottom surface is held fixed.\n# The nodes of the interface between the two elements will tend to move as\n# dictated by the material models of the two elements.\n\n# LinearNodalConstraint forces the interface nodes to move as a linear combination\n# of the nodes on the top and bottom of the block.\n# primary node ids and the corresponding weights are taken as input by the LinearNodalConstraint\n# along with the secondary node set or secondary node ids.\n# The constraint can be applied using either penalty or penalty formulation.\n\n# In this example, the final x displacement of the top surface is 2m and bottom surface is 0m.\n# Therefore, the final x displacement of the interface nodes would be 0.25*top+0.75*bottom = 0.5m\n\n[Mesh]\n  file=Square_coarse.e\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Variables]\n  # scale with one over Youngs modulus\n  [./disp_x]\n    scaling = 1e-10\n  [../]\n  [./disp_y]\n    scaling = 1e-10\n  [../]\n[]\n\n[UserObjects]\n  [./prop_read]\n    type = PropertyReadFile\n    prop_file_name = 'pcrystal_standard.csv'\n    # Enter file data as prop#1, prop#2, .., prop#nprop\n    nprop = 3\n    read_type = element\n  [../]\n[]\n\n[AuxVariables]\n  [./fp_xx]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e_xx]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./gss]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./slin]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[Modules/TensorMechanics/Master/all]\n  strain = FINITE\n  add_variables = true\n  generate_output = stress_xx\n[]\n\n[AuxKernels]\n  [./fp_xx]\n    type = RankTwoAux\n    variable = fp_xx\n    rank_two_tensor = plastic_deformation_gradient\n    index_j = 0\n    index_i = 0\n    execute_on = timestep_end\n  [../]\n  [./e_xx]\n    type = RankTwoAux\n    variable = e_xx\n    rank_two_tensor = total_lagrangian_strain\n    index_j = 0\n    index_i = 0\n    execute_on = timestep_end\n  [../]\n  [./gss]\n    type = MaterialStdVectorAux\n    variable = gss\n    property = slip_resistance\n    index = 0\n    execute_on = timestep_end\n  [../]\n  [./sincr]\n    type = MaterialStdVectorAux\n    variable = slin\n    property = slip_increment\n    index = 0\n    execute_on = timestep_end\n  [../]\n[]\n\n[BCs]\n  [./lbot_x]\n      type = ADDirichletBC\n      variable = disp_x\n      boundary = \"left_bottom\"\n      value = 0.0\n  [../]\n  [./ltop_x]\n      type = ADDirichletBC\n      variable = disp_x\n      boundary = \"left_top\"\n      value = 0.0\n  [../]\n  [./lbot_y]\n      type = ADDirichletBC\n      variable = disp_y\n      boundary = \"left_bottom\"\n      value = 0.0\n  [../]\n  [./rbot_y]\n      type = ADDirichletBC\n      variable = disp_y\n      boundary = \"right_bottom\"\n      value = 0.0\n  [../]\n  [./dispLoad]\n    type = ADFunctionDirichletBC\n    variable = disp_x\n    function = '0.1*t'\n    boundary = \"right_bottom\"\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '1.684e5 1.214e5 1.214e5 1.684e5 1.214e5 1.684e5 0.754e5 0.754e5 0.754e5'\n    fill_method = symmetric9\n    read_prop_user_object = prop_read   \n  [../]\n  [./stress]\n    type = ComputeMultipleCrystalPlasticityStress\n    crystal_plasticity_models = 'trial_xtalpl'\n    tan_mod_type = exact\n    maximum_substep_iteration = 10\n  [../]\n  [./trial_xtalpl]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.txt\n    resistance_tol = 1.0e-2\n    gss_initial = 60.8\n  [../]\n[]\n\n[Constraints]\n  [./disp_x_1]\n    type = LinearNodalConstraint\n    variable = disp_x\n    primary = '8 14'\n    weights = '1 1'\n    secondary_node_ids = '4'\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n  [./disp_x_2]\n    type = LinearNodalConstraint\n    variable = disp_x\n    primary = '12 14'\n    weights = '1 1'\n    secondary_node_ids = '10'\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n  [./disp_y_1]\n    type = LinearNodalConstraint\n    variable = disp_y\n    primary = '8 14'\n    weights = '1 1'\n    secondary_node_ids = '4'\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n  [./disp_y_2]\n    type = LinearNodalConstraint\n    variable = disp_y\n    primary = '12 14'\n    weights = '1 1'\n    secondary_node_ids = '10'\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n  [./disp_x_3]\n    type = LinearNodalConstraint\n    variable = disp_x\n    primary = '15 7'\n    weights = '1 1'\n    secondary_node_ids = '5'\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n  [./disp_x_4]\n    type = LinearNodalConstraint\n    variable = disp_x\n    primary = '13 7'\n    weights = '1 1'\n    secondary_node_ids = '2'\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n  [./disp_y_3]\n    type = LinearNodalConstraint\n    variable = disp_y\n    primary = '15 7'\n    weights = '1 1'\n    secondary_node_ids = '5'\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n  [./disp_y_4]\n    type = LinearNodalConstraint\n    variable = disp_y\n    primary = '13 7'\n    weights = '1 1'\n    secondary_node_ids = '2'\n    penalty = 1e8\n    formulation = kinematic\n  [../]\n[]\n\n[Postprocessors]\n  [./stress_xx]\n    type = ElementAverageValue\n    variable = stress_xx\n  [../]\n  [./fp_xx]\n    type = ElementAverageValue\n    variable = fp_xx\n  [../]\n  [./e_xx]\n    type = ElementAverageValue\n    variable = e_xx\n  [../]\n  [./gss]\n    type = ElementAverageValue\n    variable = gss\n  [../]\n  [./slin]\n    type = ElementAverageValue\n    variable = slin\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  dt = 2.0\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -ksp_type -ksp_gmres_restart'\n  petsc_options_value = ' asm      2              lu            gmres     200'\n  nl_abs_tol = 1e-8\n  nl_rel_step_tol = 1e-8\n  dtmax = 10.0\n  nl_rel_tol = 1e-8\n  dtmin = 0.5\n  end_time = 20\n  nl_abs_step_tol = 1e-10\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  gnuplot = true\n[]\n\nAnd the relevant model showing the nodal numbers (add 1 to match moose node numbering scheme)",
                  "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-6976912",
                  "updatedAt": "2023-09-12T09:52:49Z",
                  "publishedAt": "2023-09-12T09:43:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "primary = '12 14'\n\nare these ids too?\ndo you have a nodeset that includes all the primary nodes?\nand all the secondary nodes?",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-6980128",
                          "updatedAt": "2023-09-12T15:00:30Z",
                          "publishedAt": "2023-09-12T15:00:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "When you want to match 12 1 and 14 4 on the primary and secondary sides and if you say\nprimary = '12 14'\nsecondary='1 4'\nThis will just solve u1-u12-u14=0 and u4-u12-u14=0 respectively.\nYou will have to say\nprimary = '12 '\nsecondary='1'\nprimary = '14'\nsecondary='4'\nA complete revamp of LinearNodalConstraint is necessary if we want to simplify this class with the specification of boundary ID's.",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-6981278",
                          "updatedAt": "2023-09-12T16:46:53Z",
                          "publishedAt": "2023-09-12T16:46:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok I see what you want. This is another way of thinking the input of these constraints. We could add a parameter to enable both ways, since both make sense in their own way\nWe dont have anyone working on this right now.\nWould you do it? We can review the contribution",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-6994611",
                          "updatedAt": "2023-09-13T20:17:35Z",
                          "publishedAt": "2023-09-13T20:17:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Is the periodic boundary system not good enough for this? You can also use mortar constraints to weakly impose periodicity",
                  "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-6981096",
                  "updatedAt": "2023-09-12T16:28:19Z",
                  "publishedAt": "2023-09-12T16:28:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "That was my first idea also since I used the auto PBC successfully before in a diffusion setting. But I can't quite seem to get it working properly for a mechanical problem. My input is:\n[Mesh]\n  [domain]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 10\n    ymin = 0\n    ymax = 10\n    nx = 10\n    ny = 10\n  []\n  [top_right]\n    type = ExtraNodesetGenerator\n    input = domain\n    new_boundary = tr\n    coord = '10 10 0'\n  []\n  [bottom_right]\n    type = ExtraNodesetGenerator\n    input = top_right\n    new_boundary = br\n    coord = '10 0 0'\n  []\n  [top_left]\n    type = ExtraNodesetGenerator\n    input = bottom_right\n    new_boundary = tl\n    coord = '0 10 0'\n  []\n  [bottom_left]\n    type = ExtraNodesetGenerator\n    input = top_left\n    new_boundary = bl\n    coord = '0 0 0'\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    strain = SMALL\n    add_variables = true\n    incremental = false\n    generate_output = 'vonmises_stress'\n  []\n[]\n\n[Functions]\n  [tdisp]\n    type = ParsedFunction\n    expression = 't'\n  []\n[]\n\n[BCs]\n  [Periodic]\n    [all]\n      variable = 'disp_x disp_y'\n      auto_direction = 'x y'\n    []\n  []\n  [no_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bl br tl'\n    value = 0\n  []\n  [no_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bl'\n    value = 0\n  []\n  [tdisp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = tl\n    function = tdisp\n  []\n[]\n\n\n[Materials]\n  [elasticity]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 210000\n    poissons_ratio = 0.3\n  []\n  [stress]\n    type = ComputeLinearElasticStress\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  dt = 0.5\n  end_time = 1\n  solve_type = 'PJFNK'\n  petsc_options_iname = -pc_type\n  petsc_options_value = lu\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nIn theory, this should behave like a homogeneous shear experiment. But the auto PBC makes it not deform at all. Why is that?",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7357303",
                          "updatedAt": "2023-10-23T10:22:12Z",
                          "publishedAt": "2023-10-23T10:20:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\ntopleft is on a corner right?\nso you are imposing two BCs on that node, one periodic and tdisp\ncan you move the loading point inside the boundary away from the corner?",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7358399",
                          "updatedAt": "2023-10-23T12:33:42Z",
                          "publishedAt": "2023-10-23T12:33:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "I mean you can, but then the four corner nodes act as fixed which is usually not the behavior one aims to achieve in this kind of model setup.\nWhen you think of the square in the original post as a RVE, then a common approach for imposing PBCs is to fix the bottom left corner node and use the bottom right and the top left corner nodes as the \"controlling nodes\". You do this by coupling the displacement of all the boundary nodes to the displacement of these corner nodes  (like @abarun22 showed in his post).\nI don't have any knowledge about the implementation of the Periodic BC System in MOOSE but it seems like this approach is not compatible. Which leads back to the use of LinearNodalConstraint which - as already discussed previously - would become quite tedious for larger models. It's the same way in ABAQUS (Constraint Equations).\nConcluding I'd say being able to impose a Periodic BC and a normal DirichletBC on one node would be quite nice but I don't know if that's a feasible approach.",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7358613",
                          "updatedAt": "2023-10-23T13:09:31Z",
                          "publishedAt": "2023-10-23T12:56:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@lindsayad\nIf mixing Dirichlet and periodic BCs does not work right now I think we'd need to refactor periodic BCs in libmesh to change that",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7359072",
                          "updatedAt": "2023-10-23T13:37:00Z",
                          "publishedAt": "2023-10-23T13:36:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Let me see if I understand the issue. What I would expect to happen is that the periodic boundary constraint is overriding the Dirichlet constraint? Both are strong enforcement conditions; it just so happens that right now I believe the strong periodicity constraint will be enforced after the Dirichlet one",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7360721",
                          "updatedAt": "2023-10-23T16:00:39Z",
                          "publishedAt": "2023-10-23T16:00:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "I guess so, yes. This is also true for BCs like NeumannBC oder NodalGravity though.\nBeing able to apply normal BCs in conjunction with the Periodic BCs would be a pretty elegant solution for solving RVE problems.",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7366545",
                          "updatedAt": "2023-10-24T06:47:59Z",
                          "publishedAt": "2023-10-24T06:47:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@roystgnr is there a way to weakly enforce periodicity?",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7372517",
                          "updatedAt": "2023-10-24T16:59:44Z",
                          "publishedAt": "2023-10-24T16:59:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "\"Weakly\" == \"add a residual term\", but the details of that then depend on how the rest of your residual works, so we can't do it at the libMesh level.\nIs MOOSE even enforcing Dirichlet constraints via libMesh DirichletBoundary objects, though?  Last I looked it was just some manually applied NodalBC residual term, not anything that would construct a constraint row; and then at the libMesh level we can't even distinguish between \"residual entry that needs to be respected\" vs \"residual entry that should be overridden by a constraint\".  I was actually so surprised to see that (while trying to figure out why it wasn't working for IGA) that I feel like I have to be missing something.  What happens if someone tries to do a Dirichlet BC on a cubic Hierarchic variable?",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7372733",
                          "updatedAt": "2023-10-24T17:22:42Z",
                          "publishedAt": "2023-10-24T17:22:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Hahaha. We've talked about this... I believe MOOSE Dirichlet BCs pre-date libMesh Dirichlet boundaries. Yea MOOSE Dirichlet BCs are not done through libMesh. I think when I suggested that we should move to libMesh Dirichlet boundary enforcement you responded by saying that we would then lose the ability to apply nonlinear Dirichlet BCs which would be problematic.\n\nWhat happens if someone tries to do a Dirichlet BC on a cubic Hierarchic variable?\n\nMOOSE would probably die.\n\n\"Weakly\" == \"add a residual term\", but the details of that then depend on how the rest of your residual works, so we can't do it at the libMesh level.\n\nSo @Flolaffel I think weak enforcement of the periodic BC is the way to go. As I mentioned somewhere on this thread, we can do periodic BCs (weakly) using mortar. Note that you may also then want to consider enforcing the Dirichlet BCs weakly as well unless you're fine having the Dirichlet BCs always \"win\" at the place the Dirichlet BCs intersect the periodic BC conditions.",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7372858",
                          "updatedAt": "2023-10-24T17:37:17Z",
                          "publishedAt": "2023-10-24T17:37:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "I'll definitely be making libMesh Dirichlet boundary enforcement available for the purposes of IGA, high-order (or non-Lagrange in general?) elements, etc. in the near future.  Better to support linear-only than nothing at all for those cases.  Nonlinear libMesh::DirichletBoundary is something we really ought to have too, and until we have it there's no way to wholly replace the MOOSE-level Dirichlet BCs, but that's not going to be something I can fix this year.\nI'd strongly agree with falling back on weak enforcement for this sort of use case for now.",
                          "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7373608",
                          "updatedAt": "2023-10-24T19:03:26Z",
                          "publishedAt": "2023-10-24T19:03:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Ttw0626"
                  },
                  "bodyText": "Hi, is there any updated info about pervious discussion ?\nthe multiple point constraints or periodic condition by boundary-constraints seems like be most-stable\nand common way to do homogenization.\nBy the way, as @abarun22 mentioned before, his opinion is also called as dummy nodes approach (Multiple Point Constraints).\nMy suggestion is that we do not need to put the secondary_node_ids as node which belong to mesh with the material property. It is not advanced or novel method but important from my view, I would like to do this.\n`[./disp_y_2]`\n`   type = LinearNodalConstraint_new`\n`   variable = disp_y`\n`   primary = bottom`\n`   secondary = top`\n`   dummy_node_ids = \"any node outside material domain\"`\n`   penalty = 1e8`\n`   formulation = kinematic`\n`[../]`\n\nWe cannot ignore the shared object such as corner nodes in 2D and corner nodes / shared ledges in 3D.",
                  "url": "https://github.com/idaholab/moose/discussions/25441#discussioncomment-7494587",
                  "updatedAt": "2024-03-30T14:08:35Z",
                  "publishedAt": "2023-11-07T04:32:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MacOS Sonoma",
          "author": {
            "login": "milljm"
          },
          "bodyText": "As with any latest release from Apple, we are not ready to officially support it. Give us some time to rattle the cage before allowing your machine(s) to be upgraded, if possible!",
          "url": "https://github.com/idaholab/moose/discussions/25601",
          "updatedAt": "2023-11-06T23:37:44Z",
          "publishedAt": "2023-09-27T18:01:54Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "UPDATE: MacOS Sonoma is now fully supported! Please reach out in a new Discussion post with any support requests, as normal.",
                  "url": "https://github.com/idaholab/moose/discussions/25601#discussioncomment-7493031",
                  "updatedAt": "2023-11-06T23:37:45Z",
                  "publishedAt": "2023-11-06T23:37:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "INSFV model - periodic boundary conditions",
          "author": {
            "login": "thomas-petersen-1"
          },
          "bodyText": "Does MOOSE currently support periodic boundary conditions in its finite volume implementation of the Navier-Stokes equations?",
          "url": "https://github.com/idaholab/moose/discussions/25946",
          "updatedAt": "2023-11-06T20:41:28Z",
          "publishedAt": "2023-11-02T03:04:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFor velocity?\nI ll check tomorrow what we need for that. We have not looked into it so it s unlikely we support it\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7451982",
                  "updatedAt": "2023-11-02T03:08:37Z",
                  "publishedAt": "2023-11-02T03:08:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "thomas-petersen-1"
                          },
                          "bodyText": "Yes, for the velocity components. Thank you for verifying, Guillaume.",
                          "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7452071",
                          "updatedAt": "2023-11-02T03:28:53Z",
                          "publishedAt": "2023-11-02T03:28:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Periodic BCs seem to be silently ignored.\nIf I set a flat inlet velocity it gets obeyed first.\nIf I set an inlet and outlet pressure, then the periodic solution in velocity appears with or without PeriodicBCs (could you use that?)\nIf I set an outlet pressure and a momemtum source and PeriodicBCs I dont get convergence which makes me think they are not applied",
                          "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7456803",
                          "updatedAt": "2023-11-02T13:25:23Z",
                          "publishedAt": "2023-11-02T13:25:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@roystgnr do we do periodic BCs on constant monomials?",
                          "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7456809",
                          "updatedAt": "2023-11-02T13:25:42Z",
                          "publishedAt": "2023-11-02T13:25:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grmnptr"
                          },
                          "bodyText": "I dont think we have an FVPeriodicBC. FV has its own system for BCs.",
                          "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7456880",
                          "updatedAt": "2023-11-02T13:31:55Z",
                          "publishedAt": "2023-11-02T13:31:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grmnptr"
                          },
                          "bodyText": "If I remember correctly in the assembly loops we query FVFluxBCs and the FVDirichletBCs are applied in the different residual terms which need face values (laplacians, gradients etc).",
                          "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7456923",
                          "updatedAt": "2023-11-02T13:35:59Z",
                          "publishedAt": "2023-11-02T13:35:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If we did it on the MOOSE side it would be a dirichlet BC on one side that goes to retrieve the value on the other side.\nPeriodic BCs are not done in MOOSE, they rely on some libmesh mechanics I havent dwelled in",
                          "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7456959",
                          "updatedAt": "2023-11-02T13:40:08Z",
                          "publishedAt": "2023-11-02T13:40:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grmnptr"
                          },
                          "bodyText": "Yeah we need coupling between (potentially multiple) cell layers next to the boundaries, especially if we use Newton's method and want perfect Jacobians.",
                          "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7457669",
                          "updatedAt": "2023-11-02T14:38:44Z",
                          "publishedAt": "2023-11-02T14:38:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "periodic enforcement in libMesh won't work for DISCONTINUOUS finite element types",
                          "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7459210",
                          "updatedAt": "2023-11-02T16:59:41Z",
                          "publishedAt": "2023-11-02T16:59:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "we could make this work with a finite volume implementation of the EqualValueConstraint",
                          "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7459228",
                          "updatedAt": "2023-11-02T17:01:10Z",
                          "publishedAt": "2023-11-02T17:01:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "but it would require adding more Lagrange multipliers to the system",
                          "url": "https://github.com/idaholab/moose/discussions/25946#discussioncomment-7459232",
                          "updatedAt": "2023-11-02T17:01:31Z",
                          "publishedAt": "2023-11-02T17:01:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "construct_node_list_from_side_list adding nodes to existing nodesets",
          "author": {
            "login": "naabwxt"
          },
          "bodyText": "Quick question on how construct_node_list_from_side_list is intended to work. I have defined a model in Cubit with SideSets and NodeSets...by default cubit gives the first sideset an ID of 1 and the first node set an ID of 1. When this exodus is loaded into MOOSE with construct_node_list_from_side_list = true as is the default, it is adding the nodes from sideset ID 1 to the nodeset ID 1. Is that what is supposed to happen? Am I supposed to make sure the nodesets in cubit start at double the highest id in sidesets? Or am I missing a setting somewhere?",
          "url": "https://github.com/idaholab/moose/discussions/25983",
          "updatedAt": "2023-11-06T19:19:49Z",
          "publishedAt": "2023-11-06T19:19:48Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Local axes displaying for line element",
          "author": {
            "login": "andrey1887"
          },
          "bodyText": "Hello. I want to show a local axes of line element in Paraview, but as far as i understood, it is needed to define some data for it in input file.\nFor example i took a code from Moose framework site: https://mooseframework.inl.gov/modules/tensor_mechanics/beam_vandv.html\n\"Small strain Euler beam bending\"\nFinally i would like to get something like this: https://www.youtube.com/watch?v=FUiFjAtCyX0&ab_channel=AetherEngineering\nWoluld you help me with such problem, please.",
          "url": "https://github.com/idaholab/moose/discussions/25653",
          "updatedAt": "2023-11-06T16:49:45Z",
          "publishedAt": "2023-10-03T11:05:31Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis looks like mostly work in Paraview work to me.\nIf you identify which fields you need to output them in Paraview, we can help you output them.\n@cbolisetti  on beam elements plotting\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7175542",
                  "updatedAt": "2023-10-03T13:06:21Z",
                  "publishedAt": "2023-10-03T13:06:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Thank you. It's fields wich coressponds to x, y and z direction of local axes for each element. For this case https://mooseframework.inl.gov/modules/tensor_mechanics/beam_vandv.html i assumed such direction:\nx - along elment\ny - according to 'y-orientation' parameter in material block\nz - with x and y constitutes a right hand coordinate system\nI can't understand how to define this data and in what place of input file.",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7175885",
                          "updatedAt": "2023-10-03T13:35:48Z",
                          "publishedAt": "2023-10-03T13:35:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Seems like you want a VectorVariable to have this information\ni think you should build a VectorAuxKernel to do this",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7179458",
                          "updatedAt": "2023-10-03T19:22:10Z",
                          "publishedAt": "2023-10-03T19:22:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Thank you. I will try it.",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7179693",
                          "updatedAt": "2023-10-03T19:47:38Z",
                          "publishedAt": "2023-10-03T19:47:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Hello.\nI think the orientation of the x and y axes is already defined.\nFor beams there is an option \"Y-axis orientation\". Can i pass this parameter in VectorVariable?\nAnd what about x an z axes. Are they defined implicitly? But how to extract them?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7217533",
                          "updatedAt": "2023-10-07T14:06:46Z",
                          "publishedAt": "2023-10-07T14:06:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@cbolisetti\nI could try to have a look\nWhere is this all defined? What are the element types called? What kind of kernels are you using?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7224105",
                          "updatedAt": "2023-10-08T17:39:26Z",
                          "publishedAt": "2023-10-08T17:39:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Sorry, maybe i don't understand the approach correctly. I took the input file euler_small_strain_y.i from here\nhttps://mooseframework.inl.gov/modules/tensor_mechanics/beam_vandv.html .\nIn materials block there is 'y_orientation'.\nI see second moments of area Iy Iz, wich related to y and z axes is not it?\nHow i can change z and x orientation in this context?\nI think the axes displayed in the paraview should follow these parameters.\nIf i not right, please help me to understand process of specifying axes in input file.\n[Materials]\n  [./elasticity]\n    type = ComputeElasticityBeam\n    youngs_modulus = 2.60072400269\n    poissons_ratio = -0.9998699638\n    shear_coefficient = 0.85\n    block = 0\n  [../]\n  [./strain]\n    type = ComputeIncrementalBeamStrain\n    block = '0'\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y rot_z'\n    area = 0.554256\n    Ay = 0.0\n    Az = 0.0\n    Iy = 0.0141889\n    Iz = 0.0141889\n    y_orientation = '0.0 1.0 0.0'\n  [../]\n  [./stress]\n    type = ComputeBeamResultants\n    block = 0\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7229112",
                          "updatedAt": "2023-10-09T13:16:23Z",
                          "publishedAt": "2023-10-09T10:41:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Kind of looks like it's a constant. I checked the LineElementAction and it kind of just stays as a constant.\nIf you look at the material properties defined you also cant see them?\nSo I m not sure how you would retrieve it",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7231594",
                          "updatedAt": "2023-10-09T15:07:47Z",
                          "publishedAt": "2023-10-09T15:07:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Do i need to define a common variable in input, wich value will be assigned to\nVectorVariable for axis representation and\n'y_orientation' in Materials block ?\n\n\nHow i can extract an element orientation from the mesh for x-axis definition?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7231980",
                          "updatedAt": "2023-10-09T15:46:46Z",
                          "publishedAt": "2023-10-09T15:46:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "wich value will be assigned to VectorVariable for axis representation and 'y_orientation' in Materials block ?\n\nIt s whichever value is specified in the input\n\nHow i can extract an element orientation from the mesh for x-axis definition?\n\nI dont know. @cbolisetti if you know or if you know who may know",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7232540",
                          "updatedAt": "2023-10-09T16:48:33Z",
                          "publishedAt": "2023-10-09T16:48:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cbolisetti"
                  },
                  "bodyText": "Hello @andrey1887, sorry for the late response. Beam orientation is defined as follows:\n\nX axis is along the length of the beam and this cannot be changed.\nY axis is defined according to the y_orientation input parameter in the strain block (e.g., ComputeIncrementalBeamStrain). Note that you may not see this block if you are using the LineElementMaster action, in which case, you provide this input parameter in the LineElementMaster block.\nZ axis is the cross product of X and Y. So you basically adjust the orientation using the y_orientation parameter.\nAnd you are right, Ix, Iy, Iz, and other cross sectional inputs relate to the local coordinate system of the beam, so you need to input them accordingly.\n\ny_orientation is currently just a LibMesh VectorValue type. So I am not sure how to plot this in paraview. I don't think plotting in paraview was an intention when the beam element formulation was developed, but its a nice thing to have.",
                  "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7232834",
                  "updatedAt": "2023-10-09T17:25:08Z",
                  "publishedAt": "2023-10-09T17:22:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Hello @cbolisetti. Thank you for your answer. But what determines the direction of X axis? Are these element node numbers?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7233043",
                          "updatedAt": "2023-10-09T17:48:22Z",
                          "publishedAt": "2023-10-09T17:48:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "Yes, that is correct. When the elements are looped over, each of them first gets assigned an X axis based on the nodal coordinates. Y and Z axis definitions follow, according to my previous response.",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7233064",
                          "updatedAt": "2023-10-09T17:50:24Z",
                          "publishedAt": "2023-10-09T17:50:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Thank you.\nI think, that i need another variable for axes representation with the same value of y-orientation.\n@cbolisetti, what are you think about this way for local axes definition for representation:\n\nSeems like you want a VectorVariable to have this information\ni think you should build a VectorAuxKernel to do this\n\n#25653 (reply in thread)\nAnd how i can get X-axis vector from the element?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7233477",
                          "updatedAt": "2023-10-09T18:52:04Z",
                          "publishedAt": "2023-10-09T18:52:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "(@GiudGiud correct me if I am wrong) I believe we currently don't have an object to do that. You will have to develop a small AuxKernel object to do that. @GiudGiud can you suggest an AuxKernel that @andrey1887 can use as a template for this? Also, do you know if the orientations have to be converted to MaterialProperty objects to make this possible, or can they write an AuxKernel for any VectorValue?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7233580",
                          "updatedAt": "2023-10-09T19:05:28Z",
                          "publishedAt": "2023-10-09T19:05:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There are VectorAuxKernels so you could use that as the base class\nI think the difficulty for me is how to go from _current_elem to knowing x,y and z\nx is probably easy enough using the nodes of the _current_elem to compute the change in X",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7234031",
                          "updatedAt": "2023-10-09T20:05:14Z",
                          "publishedAt": "2023-10-09T20:05:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "Here's how its done in ComputeIncrementalBeamStrain. I think these lines can just be copied into the new AuxKernel to get the orientations, although its not ideal to do that twice.",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7234392",
                          "updatedAt": "2023-10-09T20:58:28Z",
                          "publishedAt": "2023-10-09T20:58:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "I copied these lines:\n  const std::vector<RealGradient> * orientation =\n      &_subproblem.assembly(_tid).getFE(FEType(), 1)->get_dxyzdxi();\n  RealGradient x_orientation = (*orientation)[0];\n  x_orientation /= x_orientation.norm();\n\n  RealGradient y_orientation = getParam<RealGradient>(\"y_orientation\");\n  y_orientation /= y_orientation.norm();\n  Real sum = x_orientation(0) * y_orientation(0) + x_orientation(1) * y_orientation(1) +\n             x_orientation(2) * y_orientation(2);\n\n  if (std::abs(sum) > 1e-4)\n    mooseError(\"ComputeIncrementalBeamStrain: y_orientation should be perpendicular to \"\n               \"the axis of the beam.\");\n\n  // Calculate z orientation as a cross product of the x and y orientations\n  RealGradient z_orientation;\n  z_orientation(0) = (x_orientation(1) * y_orientation(2) - x_orientation(2) * y_orientation(1));\n  z_orientation(1) = (x_orientation(2) * y_orientation(0) - x_orientation(0) * y_orientation(2));\n  z_orientation(2) = (x_orientation(0) * y_orientation(1) - x_orientation(1) * y_orientation(0));\n\nBut what i need to add for getting access to these variables in paraview?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7303116",
                          "updatedAt": "2023-10-17T11:44:50Z",
                          "publishedAt": "2023-10-17T11:44:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You need to write an auxkernel that takes as parameters the component to output.\nThen in the computeValue routine for the auxkernel, you simply have the expression you just wrote, but returning the component selected by the user with the parameter",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7303436",
                          "updatedAt": "2023-10-17T12:19:52Z",
                          "publishedAt": "2023-10-17T12:19:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Hello. This is my .C file:\n#include \"libmesh/quadrature.h\"\n#include \"libmesh/utility.h\"\n\n#include \"LocalAxisVectorAux.h\"\n\nregisterMooseObject(\"LocalAxisVectorAux\", LocalAxisVectorAux);\n\nInputParameters\nLocalAxisVectorAux::validParams()\n{\n  InputParameters params = VectorAuxKernel::validParams();\n\n  /*\u0437\u0430\u0434\u0430\u043d\u043d\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0443, \u044f\u043a\u0438\u0439 \u043f\u0440\u0438\u0439\u043c\u0430\u0454\u0442\u044c\u0441\u044f \u0431\u0435\u0437\u043f\u043e\u0441\u0435\u0440\u0435\u0434\u043d\u044c\u043e \u0437 input \u0444a\u0439\u043b\u0443,\n  \u044f\u043a\u0449\u043e \u0436 \u0432\u0456\u043d \u0432\u0456\u0434\u0441\u0443\u0442\u043d\u0456\u0439, \u0431\u0443\u0434\u0435 \u0432\u0438\u0434\u0430\u043d\u0430 \u043f\u043e\u043c\u0438\u043b\u043a\u0430*/\n  params.addRequiredParam<RealGradient>(\"y_orientation\",\n                                        \"Orientation of the y direction along \"\n                                        \"with Iyy is provided. This should be \"\n                                        \"perpendicular to the axis of the beam.\");\n\n  return params;\n}\n\nLocalAxisVectorAux::LocalAxisVectorAux(const InputParameters & parameters)\n  : VectorAuxKernel(parameters){\n\n    };\n\nRealVectorValue\nLocalAxisVectorAux::computeValue()\n{\n  // compute initial orientation of the beam for calculating initial rotation matrix\n  const std::vector<RealGradient> * orientation =\n      &_subproblem.assembly(_tid).getFE(FEType(), 1)->get_dxyzdxi();\n  RealGradient x_orientation = (*orientation)[0];\n  x_orientation /= x_orientation.norm();\n\n  RealGradient y_orientation = getParam<RealGradient>(\"y_orientation\");\n  y_orientation /= y_orientation.norm();\n  Real sum = x_orientation(0) * y_orientation(0) + x_orientation(1) * y_orientation(1) +\n             x_orientation(2) * y_orientation(2);\n\n  if (std::abs(sum) > 1e-4)\n    mooseError(\"ComputeIncrementalBeamStrain: y_orientation should be perpendicular to \"\n               \"the axis of the beam.\");\n\n  // Calculate z orientation as a cross product of the x and y orientations\n  RealGradient z_orientation;\n  z_orientation(0) = (x_orientation(1) * y_orientation(2) - x_orientation(2) * y_orientation(1));\n  z_orientation(1) = (x_orientation(2) * y_orientation(0) - x_orientation(0) * y_orientation(2));\n  z_orientation(2) = (x_orientation(0) * y_orientation(1) - x_orientation(1) * y_orientation(0));\n  \n  return \n}\n\n\nBut i don't entirely understand what i must return in computeValue() method. y_orientation is the single input required parameter in my case.",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7341743",
                          "updatedAt": "2023-10-20T17:21:41Z",
                          "publishedAt": "2023-10-20T17:21:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou are trying to output z_orientation right? So you can visualize that vector?\nI would make your auxkernel derived from the VectorAuxkernel base class, then return z_orientation will do what you want\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7342856",
                          "updatedAt": "2023-10-20T19:59:36Z",
                          "publishedAt": "2023-10-20T19:59:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "andrey1887"
                  },
                  "bodyText": "use 3 auxkernels then. One for each vector\n\nDo i need 3 separate .C files and 3 .h ?",
                  "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7390383",
                  "updatedAt": "2023-10-26T08:54:38Z",
                  "publishedAt": "2023-10-26T08:54:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no you should be able to have a parameter in that kernel to select the component.\nUse a MooseEnum for example in the validParams\nMooseEnum component(\"x y z\");\nparams.addParam<MooseEnum>(component, component, \"Component to output\");",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7392085",
                          "updatedAt": "2023-10-26T12:06:54Z",
                          "publishedAt": "2023-10-26T12:06:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Thank you, @GiudGiud . But what about glyphs displaying at the center point of elements in Paraview ?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7392158",
                          "updatedAt": "2023-10-26T12:14:27Z",
                          "publishedAt": "2023-10-26T12:14:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont know about that one. maybe ask on the paraview forum",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7392281",
                          "updatedAt": "2023-10-26T12:26:28Z",
                          "publishedAt": "2023-10-26T12:26:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "andrey1887"
                  },
                  "bodyText": "MooseEnum component(\"x y z\");\nparams.addParam<MooseEnum>(component, component, \"Component to output\");\n\n\n@GiudGiud, how i can use this in defining parameters in input file how it will look?",
                  "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7394597",
                  "updatedAt": "2023-10-26T15:51:25Z",
                  "publishedAt": "2023-10-26T15:51:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "add this to your validParams routine\nthen in your header:\nconst MooseEnum _component;\n\nin your initializer list:\n_component(getParam<MooseEnum>(\"component\")),\n\nthen in your code you can do:\nif (_component == \"x\")\n{\ndo this\n}\nelse if (_component == \"y\")\n{\ndo this other thing, return y component\n}",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7394769",
                          "updatedAt": "2023-10-26T17:45:26Z",
                          "publishedAt": "2023-10-26T16:08:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "In file included from /home/and/projects/thin_walled/build/unity_src/auxkernels_Unity.C:2:\n/home/and/projects/thin_walled/src/auxkernels/LocalAxisVectorAux.C: In member function 'virtual libMesh::RealVectorValue LocalAxisVectorAux::computeValue()':\n/home/and/projects/thin_walled/src/auxkernels/LocalAxisVectorAux.C:69:1: warning: control reaches end of non-void function [-Wreturn-type]\n   69 | }\n      | ^\n\n@GiudGiud, i got this warning during compilation.\nmy file computeValue method:\nRealVectorValue\nLocalAxisVectorAux::computeValue()\n{\n  // compute initial orientation of the beam for calculating initial rotation matrix\n  const std::vector<RealGradient> * orientation =\n      &_subproblem.assembly(_tid).getFE(FEType(), 1)->get_dxyzdxi();\n  RealGradient x_orientation = (*orientation)[0];\n  x_orientation /= x_orientation.norm(); // \u043d\u043e\u0440\u043c\u0430\u043b\u0456\u0437\u0430\u0446\u0456\u044f \u0432\u0435\u043a\u0442\u043e\u0440\u0430\n\n  RealGradient y_orientation = getParam<RealGradient>(\"y_orientation\");\n  y_orientation /= y_orientation.norm();\n  Real sum = x_orientation(0) * y_orientation(0) + x_orientation(1) * y_orientation(1) +\n             x_orientation(2) * y_orientation(2);\n\n  if (std::abs(sum) > 1e-4)\n    mooseError(\"ComputeIncrementalBeamStrain: y_orientation should be perpendicular to \"\n               \"the axis of the beam.\");\n\n  // Calculate z orientation as a cross product of the x and y orientations\n  RealGradient z_orientation;\n  z_orientation(0) = (x_orientation(1) * y_orientation(2) - x_orientation(2) * y_orientation(1));\n  z_orientation(1) = (x_orientation(2) * y_orientation(0) - x_orientation(0) * y_orientation(2));\n  z_orientation(2) = (x_orientation(0) * y_orientation(1) - x_orientation(1) * y_orientation(0));\n\n  if (_component == \"x\")\n  {\n    return x_orientation;\n  }\n  else if (_component == \"y\")\n  {\n    return y_orientation;\n  }\n  else if (_component == \"z\")\n  {\n    return z_orientation;\n  }\n}",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7396865",
                          "updatedAt": "2023-10-26T20:04:22Z",
                          "publishedAt": "2023-10-26T20:04:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "/home/and/projects/thin_walled/src/auxkernels/LocalAxisVectorAux.C:69:1: warning: control reaches end of non-void function [-Wreturn-type]\n\nthat means you forgot a brakcet",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7396919",
                          "updatedAt": "2023-10-26T20:12:37Z",
                          "publishedAt": "2023-10-26T20:12:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "@GiudGiud , may be something wrong in the input file?\n[AuxVariables]\n  [local_axis_x]\n    family = MONOMIAL_VEC\n  []\n  [local_axis_y]\n    family = MONOMIAL_VEC\n  []\n  [local_axis_z]\n    family = MONOMIAL_VEC\n  []\n[]\n\n[AuxKernels]\n  [local_axis_x]\n    type = LocalAxisVectorAux\n    variable = local_axis_x\n    y_orientation = '0.0 1.0 0.0'\n    component = 'x'\n  []\n  [local_axis_y]\n    type = LocalAxisVectorAux\n    variable = local_axis_y\n    y_orientation = '0.0 1.0 0.0'\n    component = 'y'\n  []\n  [local_axis_z]\n    type = LocalAxisVectorAux\n    variable = local_axis_z\n    y_orientation = '0.0 1.0 0.0'\n    component = 'z'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7396993",
                          "updatedAt": "2023-10-26T20:22:01Z",
                          "publishedAt": "2023-10-26T20:22:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no this is a compilation error\nIn file included from /home/and/projects/thin_walled/build/unity_src/auxkernels_Unity.C:2:\n/home/and/projects/thin_walled/src/auxkernels/LocalAxisVectorAux.C: In member function 'virtual libMesh::RealVectorValue LocalAxisVectorAux::computeValue()':\n/home/and/projects/thin_walled/src/auxkernels/LocalAxisVectorAux.C:69:1: warning: control reaches end of non-void function [-Wreturn-type]\n   69 | }\n      | ^\n\nit comes from the C file",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7396997",
                          "updatedAt": "2023-10-26T20:22:57Z",
                          "publishedAt": "2023-10-26T20:22:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "i changed the last snipped this way:\n  RealGradient returnValue;\n\n  if (_component == \"x\")\n  {\n    returnValue = x_orientation;\n  }\n  else if (_component == \"y\")\n  {\n    returnValue = y_orientation;\n  }\n  else if (_component == \"z\")\n  {\n    returnValue = z_orientation;\n  }\n\n  return returnValue;\n\nThen the warning disappeared",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7397080",
                          "updatedAt": "2023-10-27T08:07:27Z",
                          "publishedAt": "2023-10-26T20:35:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "@GiudGiud  if i open exodus file in paraview, i can't access to display it.\nMay i output local axes in csv file to check it before.",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7401066",
                          "updatedAt": "2023-10-27T08:12:26Z",
                          "publishedAt": "2023-10-27T08:12:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is odd. Exodus is well supported. Can you try the latest paraview?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7403208",
                          "updatedAt": "2023-10-27T12:16:09Z",
                          "publishedAt": "2023-10-27T12:16:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "I will try to describe what i have:\n\n@GiudGiud, I doubt that the data for the glyphs is displayed according to the local_axis_ vectors data. I can display one direction, but switching a component gives no result.",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7403737",
                          "updatedAt": "2023-10-27T13:14:03Z",
                          "publishedAt": "2023-10-27T13:07:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "where do you select the glyphs in paraview?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7404045",
                          "updatedAt": "2023-10-27T13:40:12Z",
                          "publishedAt": "2023-10-27T13:40:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "andrey1887"
                  },
                  "bodyText": "@cbolisetti, @GiudGiud, now i have solution for elements along one line. To put it briefly : there are 2 enums: first - for axis name, the second one is for separate component (number), when axis is defined by 3 components. So i have 9 variables, which are define 3 vectors.\n\n\nBut when i try to extend mesh to more than one direction line elements i see 9 variables\n\n\nWhich additionally is empty. Help me please, what  i need to do to solve this issue?\nLocalAxisVectorAux.C:\n#include \"libmesh/quadrature.h\"\n#include \"libmesh/utility.h\"\n\n#include \"LocalAxisVectorAux.h\"\n\nregisterMooseObject(\"ThinWalledApp\", LocalAxisVectorAux);\n\nInputParameters\nLocalAxisVectorAux::validParams()\n{\n  InputParameters params = VectorAuxKernel::validParams();\n\n  params.addRequiredParam<RealGradient>(\"y_orientation\",\n                                        \"Orientation of the y direction along \"\n                                        \"with Iyy is provided. This should be \"\n                                        \"perpendicular to the axis of the beam.\");\n\n  MooseEnum axis(\"x y z\");\n  params.addParam<MooseEnum>(\"axis\", axis, \"Axis to output\");\n\n  MooseEnum component(\"x y z\");\n  params.addParam<MooseEnum>(\"component\", component, \"Component to output\");\n\n  return params;\n}\n\nLocalAxisVectorAux::LocalAxisVectorAux(const InputParameters & parameters)\n  : VectorAuxKernel(parameters),\n    _axis(getParam<MooseEnum>(\"axis\")),\n    _component(getParam<MooseEnum>(\"component\")){\n\n    };\n\nRealVectorValue\nLocalAxisVectorAux::computeValue()\n{\n  // compute initial orientation of the beam for calculating initial rotation matrix\n  const std::vector<RealGradient> * orientation =\n      &_subproblem.assembly(_tid).getFE(FEType(), 1)->get_dxyzdxi();\n\n  RealGradient x_orientation = (*orientation)[0];\n  x_orientation /= x_orientation.norm(); // \u043d\u043e\u0440\u043c\u0430\u043b\u0456\u0437\u0430\u0446\u0456\u044f \u0432\u0435\u043a\u0442\u043e\u0440\u0430\n\n  RealGradient y_orientation = getParam<RealGradient>(\"y_orientation\");\n  y_orientation /= y_orientation.norm();\n\n  Real sum = x_orientation(0) * y_orientation(0) + x_orientation(1) * y_orientation(1) +\n             x_orientation(2) * y_orientation(2);\n\n  if (std::abs(sum) > 1e-4)\n    mooseError(\"ComputeIncrementalBeamStrain: y_orientation should be perpendicular to \"\n               \"the axis of the beam.\");\n\n  // Calculate z orientation as a cross product of the x and y orientations\n  RealGradient z_orientation;\n  z_orientation(0) = (x_orientation(1) * y_orientation(2) - x_orientation(2) * y_orientation(1));\n  z_orientation(1) = (x_orientation(2) * y_orientation(0) - x_orientation(0) * y_orientation(2));\n  z_orientation(2) = (x_orientation(0) * y_orientation(1) - x_orientation(1) * y_orientation(0));\n\n  Real returnValue;\n  RealGradient direction;\n\n  if (_axis == \"x\")\n  {\n    direction = x_orientation;\n  }\n  else if (_axis == \"y\")\n  {\n    direction = y_orientation;\n  }\n  else if (_axis == \"z\")\n  {\n    direction = z_orientation;\n  }\n\n  if (_component == \"x\")\n  {\n    returnValue = direction(0);\n  }\n  else if (_component == \"y\")\n  {\n    returnValue = direction(1);\n    // std::cout << \"y_orientation\" << y_orientation << std::endl;\n  }\n  else if (_component == \"z\")\n  {\n    returnValue = direction(2);\n    // std::cout << \"z_orientation\" << z_orientation << std::endl;\n  }\n\n  return returnValue;\n}\n\nLocalAxisVectorAux.h\n#pragma once\n\n#include \"AuxKernel.h\"\n\nclass LocalAxisVectorAux : public VectorAuxKernel\n{\n\npublic:\n  static InputParameters validParams();\n\n  LocalAxisVectorAux(const InputParameters & parameters);\n\nprotected:\n  /**\n   * AuxKernels MUST override computeValue.  computeValue() is called on\n   * every quadrature point.  For Nodal Auxiliary variables those quadrature\n   * points coincide with the nodes.\n   */\n  virtual RealVectorValue computeValue() override;\n  const MooseEnum _axis;\n  const MooseEnum _component;\n};\n\nAnd the next line are described local axes in input-file:\n[AuxVariables]\n  [local_axisX_x]\n    family = MONOMIAL_VEC\n  []\n  [local_axisX_y]\n    family = MONOMIAL_VEC\n  []\n  [local_axisX_z]\n    family = MONOMIAL_VEC\n  []\n\n  [local_axisY_x]\n    family = MONOMIAL_VEC\n  []\n  [local_axisY_y]\n    family = MONOMIAL_VEC\n  []\n  [local_axisY_z]\n    family = MONOMIAL_VEC\n  []\n\n  [local_axisZ_x]\n    family = MONOMIAL_VEC\n  []\n  [local_axisZ_y]\n    family = MONOMIAL_VEC\n  []\n  [local_axisZ_z]\n    family = MONOMIAL_VEC\n  []\n[]\n\n[AuxKernels]\n  [local_axisX_x]\n    type = LocalAxisVectorAux\n    variable = local_axisX_x\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'x'\n    component = 'x'\n  []\n  [local_axisX_y]\n    type = LocalAxisVectorAux\n    variable = local_axisX_y\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'x'\n    component = 'y'\n  []\n  [local_axis_x_z]\n    type = LocalAxisVectorAux\n    variable = local_axisX_z\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'x'\n    component = 'z'\n  []\n\n  [local_axisY_x]\n    type = LocalAxisVectorAux\n    variable = local_axisY_x\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'y'\n    component = 'x'\n  []\n  [local_axisY_y]\n    type = LocalAxisVectorAux\n    variable = local_axisY_y\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'y'\n    component = 'y'\n  []\n  [local_axisY_z]\n    type = LocalAxisVectorAux\n    variable = local_axisY_z\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'y'\n    component = 'z'\n  []\n\n  [local_axisZ_x]\n    type = LocalAxisVectorAux\n    variable = local_axisZ_x\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'z'\n    component = 'x'\n  []\n  [local_axisZ_y]\n    type = LocalAxisVectorAux\n    variable = local_axisZ_y\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'z'\n    component = 'y'\n  []\n  [local_axisZ_z]\n    type = LocalAxisVectorAux\n    variable = local_axisZ_z\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'z'\n    component = 'z'\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7469357",
                  "updatedAt": "2023-11-03T17:02:32Z",
                  "publishedAt": "2023-11-03T17:02:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you are using one variable per component you do not need to use vector variables.\nSo it should be\n  [local_axisX_y]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n\nfor all 9 variables",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7470079",
                          "updatedAt": "2023-11-03T18:35:50Z",
                          "publishedAt": "2023-11-03T18:35:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "BUT since you coded a VectorAuxKernel instead of an auxkernel you could keep vector varaible, but you only need 3 of them",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7470086",
                          "updatedAt": "2023-11-03T18:36:44Z",
                          "publishedAt": "2023-11-03T18:36:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Thank you, @GiudGiud.  I have added order = CONSTANT but i expect  for another result: that 3 components will make up a 1 vector. Since i also can't use obtained data as orientation array, because this needs 3 component - vectors.\nMaybe it depends on using blocks for mesh. How i can do this correctly? Now i have two blocks: Beams and Columns:\n[Mesh]\n  type = FileMesh\n  file = 'beam.msh'\n[]\n\n[AuxVariables]\n  [local_axisX_x]\n    family = MONOMIAL_VEC\n    order = CONSTANT\n  []\n  [local_axisX_y]\n    family = MONOMIAL_VEC\n    order = CONSTANT\n  []\n  [local_axisX_z]\n    family = MONOMIAL_VEC\n    order = CONSTANT\n  []\n\n  [local_axisY_x]\n    family = MONOMIAL_VEC\n    order = CONSTANT\n  []\n  [local_axisY_y]\n    family = MONOMIAL_VEC\n    order = CONSTANT\n  []\n  [local_axisY_z]\n    family = MONOMIAL_VEC\n    order = CONSTANT\n  []\n\n  [local_axisZ_x]\n    family = MONOMIAL_VEC\n    order = CONSTANT\n  []\n  [local_axisZ_y]\n    family = MONOMIAL_VEC\n    order = CONSTANT\n  []\n  [local_axisZ_z]\n    family = MONOMIAL_VEC\n    order = CONSTANT\n  []\n[]\n\n[Variables]\n  [disp_x]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [disp_y]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [disp_z]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [rot_x]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [rot_y]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [rot_z]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[BCs]\n  [fixx1]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'Supports'\n    value = 0.0\n  []\n  [fixy1]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'Supports'\n    value = 0.0\n  []\n  [fixz1]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'Supports'\n    value = 0.0\n  []\n  [fixr1]\n    type = DirichletBC\n    variable = rot_x\n    boundary = 'Supports'\n    value = 0.0\n  []\n  [fixr2]\n    type = DirichletBC\n    variable = rot_y\n    boundary = 'Supports'\n    value = 0.0\n  []\n  [fixr3]\n    type = DirichletBC\n    variable = rot_z\n    boundary = 'Supports'\n    value = 0.0\n  []\n[]\n\n[NodalKernels]\n  [force_y2]\n    type = ConstantRate\n    variable = disp_z\n    boundary = 'Force'\n    rate = -1.0e-4\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  line_search = 'none'\n  nl_max_its = 15\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-10\n\n  dt = 1\n  dtmin = 1\n  end_time = 2\n[]\n\n[Kernels]\n  [solid_disp_x]\n    type = StressDivergenceBeam\n    block = '1'\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y rot_z'\n    component = 0\n    variable = disp_x\n  []\n  [solid_disp_y]\n    type = StressDivergenceBeam\n    block = '1'\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y rot_z'\n    component = 1\n    variable = disp_y\n  []\n  [solid_disp_z]\n    type = StressDivergenceBeam\n    block = '1'\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y rot_z'\n    component = 2\n    variable = disp_z\n  []\n  [solid_rot_x]\n    type = StressDivergenceBeam\n    block = '1'\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y rot_z'\n    component = 3\n    variable = rot_x\n  []\n  [solid_rot_y]\n    type = StressDivergenceBeam\n    block = '1'\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y rot_z'\n    component = 4\n    variable = rot_y\n  []\n  [solid_rot_z]\n    type = StressDivergenceBeam\n    block = '1'\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y rot_z'\n    component = 5\n    variable = rot_z\n  []\n[]\n\n[AuxKernels]\n  [local_axisX_x]\n    type = LocalAxisVectorAux\n    variable = local_axisX_x\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'x'\n    component = 'x'\n\n  []\n  [local_axisX_y]\n    type = LocalAxisVectorAux\n    variable = local_axisX_y\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'x'\n    component = 'y'\n\n  []\n  [local_axis_x_z]\n    type = LocalAxisVectorAux\n    variable = local_axisX_z\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'x'\n    component = 'z'\n\n  []\n\n  [local_axisY_x]\n    type = LocalAxisVectorAux\n    variable = local_axisY_x\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'y'\n    component = 'x'\n\n  []\n  [local_axisY_y]\n    type = LocalAxisVectorAux\n    variable = local_axisY_y\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'y'\n    component = 'y'\n\n  []\n  [local_axisY_z]\n    type = LocalAxisVectorAux\n    variable = local_axisY_z\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'y'\n    component = 'z'\n\n  []\n\n  [local_axisZ_x]\n    type = LocalAxisVectorAux\n    variable = local_axisZ_x\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'z'\n    component = 'x'\n\n  []\n  [local_axisZ_y]\n    type = LocalAxisVectorAux\n    variable = local_axisZ_y\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'z'\n    component = 'y'\n\n  []\n  [local_axisZ_z]\n    type = LocalAxisVectorAux\n    variable = local_axisZ_z\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'z'\n    component = 'z'\n\n  []\n\n[]\n\n[Materials]\n  [elasticity]\n    type = ComputeElasticityBeam\n    youngs_modulus = 2.60072400269\n    poissons_ratio = -0.9998699638\n    shear_coefficient = 0.85\n    block = '1 2'\n  []\n  [strain]\n    type = ComputeIncrementalBeamStrain\n    block = '1 2'\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y rot_z'\n    area = 0.554256\n    Ay = 0.0\n    Az = 0.0\n    Iy = 0.0141889\n    Iz = 0.0141889\n    y_orientation = '0.0 1.0 0.0'\n  []\n  [stress]\n    type = ComputeBeamResultants\n    block = '1 2'\n  []\n[]\n\n[Postprocessors]\n  [disp_x]\n    type = PointValue\n    point = '3.0 0.0 0.0'\n    variable = disp_x\n  []\n  [disp_y]\n    type = PointValue\n    point = '3.0 0.0 0.0'\n    variable = disp_y\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7470222",
                          "updatedAt": "2023-11-03T19:10:47Z",
                          "publishedAt": "2023-11-03T19:10:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you have 9 vector variables in the input file, when you only have 3 vectors to define. This isnt right",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7470236",
                          "updatedAt": "2023-11-03T19:13:50Z",
                          "publishedAt": "2023-11-03T19:13:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "@GiudGiud, tell mwe please what data type i should use instead of enum to make possible such notation in input file:\ncomponent = 'x y z'",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7470427",
                          "updatedAt": "2023-11-03T19:42:18Z",
                          "publishedAt": "2023-11-03T19:42:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can use MultiMooseEnum for that.\nIt s a mooseenum but with the option to have multiple options active at the same time",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7470582",
                          "updatedAt": "2023-11-03T20:05:59Z",
                          "publishedAt": "2023-11-03T20:05:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "@GiudGiud , thank you,  but how i can check this conditions :",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7471192",
                          "updatedAt": "2023-11-03T21:47:39Z",
                          "publishedAt": "2023-11-03T21:47:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "see MultiMooseEnum.h.\nI think the routine is called \"contains\" instead of == since there are multiple choices",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7471234",
                          "updatedAt": "2023-11-03T21:54:01Z",
                          "publishedAt": "2023-11-03T21:54:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "@GiudGiud , may be i need Coupled variable for this case like made in https://github.com/idaholab/moose/blob/df1150a47192719fbde83216251b259770a3a77a/modules/tensor_mechanics/src/kernels/StressDivergenceBeam.C#L35C20-L35C20 ?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7471524",
                          "updatedAt": "2023-11-03T22:46:30Z",
                          "publishedAt": "2023-11-03T22:46:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont think so. \"x\", \"y\", \"z\" are not variables, they are strings. And an enum is appropriate for comparisons / selection of strings",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7471893",
                          "updatedAt": "2023-11-04T00:32:23Z",
                          "publishedAt": "2023-11-04T00:32:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "ok bad news. Vector variables were a bad idea. The output is really buggy. At 0th order the monomial_vec dont even appear in the exodus file and at 1st order they are output wrong.\nI ll paste a way with regular variables soon",
                  "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7476868",
                  "updatedAt": "2023-11-05T00:32:26Z",
                  "publishedAt": "2023-11-05T00:32:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "this seems to work\nheader\n#pragma once\n\n#include \"AuxKernel.h\"\n\n/**\n *\n */\nclass LocalAxisAux : public AuxKernel\n{\npublic:\n  static InputParameters validParams();\n\n  LocalAxisAux(const InputParameters & parameters);\n\nprotected:\n  virtual Real computeValue() override;\n\n  const MooseEnum _axis;\n  const MooseEnum _component;\n};\n\nsource\n#include \"libmesh/quadrature.h\"\n#include \"libmesh/utility.h\"\n\n#include \"LocalAxisAux.h\"\n\nregisterMooseObject(\"MooseApp\", LocalAxisAux);\n\nInputParameters\nLocalAxisAux::validParams()\n{\n  InputParameters params = AuxKernel::validParams();\n\n  params.addRequiredParam<RealGradient>(\"y_orientation\",\n                                        \"Orientation of the y direction along \"\n                                        \"with Iyy is provided. This should be \"\n                                        \"perpendicular to the axis of the beam.\");\n\n  MooseEnum axis(\"x y z\");\n  params.addRequiredParam<MooseEnum>(\"axis\", axis, \"Axis to output\");\n  params.addRequiredParam<MooseEnum>(\"component\", axis, \"Axis component to output\");\n  return params;\n}\n\nLocalAxisAux::LocalAxisAux(const InputParameters & parameters)\n  : AuxKernel(parameters),\n    _axis(getParam<MooseEnum>(\"axis\")),\n    _component(getParam<MooseEnum>(\"component\"))\n{\n}\n\nReal\nLocalAxisAux::computeValue()\n{\n  // compute initial orientation of the beam for calculating initial rotation matrix\n  const std::vector<RealGradient> * orientation =\n      &_subproblem.assembly(_tid).getFE(FEType(), 1)->get_dxyzdxi();\n  RealGradient x_orientation = (*orientation)[0];\n  x_orientation /= x_orientation.norm(); // \u043d\u043e\u0440\u043c\u0430\u043b\u0456\u0437\u0430\u0446\u0456\u044f \u0432\u0435\u043a\u0442\u043e\u0440\u0430\n\n  RealGradient y_orientation = getParam<RealGradient>(\"y_orientation\");\n  y_orientation /= y_orientation.norm();\n\n  Real sum = x_orientation(0) * y_orientation(0) + x_orientation(1) * y_orientation(1) +\n             x_orientation(2) * y_orientation(2);\n\n  if (std::abs(sum) > 1e-4)\n    mooseError(\"ComputeIncrementalBeamStrain: y_orientation should be perpendicular to \"\n               \"the axis of the beam.\");\n\n  // Calculate z orientation as a cross product of the x and y orientations\n  RealGradient z_orientation;\n  z_orientation(0) = (x_orientation(1) * y_orientation(2) - x_orientation(2) * y_orientation(1));\n  z_orientation(1) = (x_orientation(2) * y_orientation(0) - x_orientation(0) * y_orientation(2));\n  z_orientation(2) = (x_orientation(0) * y_orientation(1) - x_orientation(1) * y_orientation(0));\n\n  // _console << x_orientation << \" \" << y_orientation << \" \" << z_orientation << std::endl;\n\n  int comp = -1;\n  if (_component == \"x\")\n    comp = 0;\n  else if (_component == \"y\")\n    comp = 1;\n  else if (_component == \"z\")\n    comp = 2;\n\n  if (_axis == \"x\")\n    return x_orientation(comp);\n  else if (_axis == \"y\")\n    return y_orientation(comp);\n  else\n    return z_orientation(comp);\n}\n\ninput\n[Mesh]\n  [1d_beam]\n    type = CartesianMeshGenerator\n    dim = 1\n    dx = 3\n    ix = 2\n    subdomain_id = '1'\n  []\n  # this makes it a 3D problem\n  [translate]\n    type = TransformGenerator\n    input = 1d_beam\n    transform = TRANSLATE\n    vector_value = '1 1 1'\n  []\n[]\n\n[AuxVariables]\n  [local_axisX_x]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [local_axisX_y]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [local_axisX_z]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [local_axisY_x]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [local_axisY_y]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [local_axisY_z]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [local_axisZ_x]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [local_axisZ_y]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [local_axisZ_z]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n[]\n\n[AuxKernels]\n  [local_axisXx]\n    type = LocalAxisAux\n    variable = local_axisX_x\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'x'\n    component = 'x'\n  []\n  [local_axisXy]\n    type = LocalAxisAux\n    variable = local_axisX_y\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'x'\n    component = 'y'\n  []\n  [local_axisXz]\n    type = LocalAxisAux\n    variable = local_axisX_z\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'x'\n    component = 'z'\n  []\n\n  [local_axisYx]\n    type = LocalAxisAux\n    variable = local_axisY_x\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'y'\n    component = 'x'\n  []\n  [local_axisYy]\n    type = LocalAxisAux\n    variable = local_axisY_y\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'y'\n    component = 'y'\n  []\n  [local_axisYz]\n    type = LocalAxisAux\n    variable = local_axisY_z\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'y'\n    component = 'z'\n  []\n\n  [local_axisZx]\n    type = LocalAxisAux\n    variable = local_axisZ_x\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'z'\n    component = 'x'\n  []\n  [local_axisZy]\n    type = LocalAxisAux\n    variable = local_axisZ_y\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'z'\n    component = 'y'\n  []\n  [local_axisZz]\n    type = LocalAxisAux\n    variable = local_axisZ_z\n    y_orientation = '0.0 1.0 0.0'\n    axis = 'z'\n    component = 'z'\n  []\n[]\n\n[Problem]\n  solve = false\n[]\n\n[Executioner]\n  type = Steady\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nthe variables are not identically 0 anyway.\nIn the future will you always need to specify the Y orientation? What if there are beam elements in several directions in a single mesh?",
                  "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7476888",
                  "updatedAt": "2023-11-05T00:43:13Z",
                  "publishedAt": "2023-11-05T00:42:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Thank you, @GiudGiud . I think it can be possible to use blocks:\n [./block_1]\n    block = 1\n    area = 9e-2\n    Iy = 6.75e-4\n    Iz = 6.75e-4\n    y_orientation = '0.0 0.0 1.0'\n  [../]\n  [./block_2]\n    block = 2\n    area = 9e-2\n    Iy = 6.75e-1\n    Iz = 6.75e-1\n    y_orientation = '0.0 1.0 0.0'\n  [../]\n\nTell me please how i can write a values in components when i  use coupled Variables? As i use auxkernels i must override computeValue method, which returns a RealVectorValue. But how it related to coupled Variables?\nHow to assign values to the components of coupled variable.",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7476927",
                          "updatedAt": "2023-11-05T01:03:05Z",
                          "publishedAt": "2023-11-05T00:57:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Blocks work, as long as all the elements with the same orientation are in the same block,\nI dont think writing to components of coupled varaibles will work since the output to exodus is the part that is not working as expected. the VectorAuxkErnel with a RealVectorValue are working fine.\nDid you try to use what I pasted?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7477109",
                          "updatedAt": "2023-11-05T02:18:44Z",
                          "publishedAt": "2023-11-05T02:18:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Hello. @GiudGiud ,\n\nDid you try to use what I pasted?\n\nYes, it works thank you.\n\nBut not at all elements, although it is more better then it was.\nMaybe it's related to paraview?",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7488443",
                          "updatedAt": "2023-11-06T14:42:02Z",
                          "publishedAt": "2023-11-06T14:42:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont know why that would be.\nIf you visualize the components without the glyph (using the coloring for example) are they correct?\nIf this is purely a glyph problem you should ask there https://discourse.paraview.org/c/paraview-support/7",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7488526",
                          "updatedAt": "2023-11-06T14:48:42Z",
                          "publishedAt": "2023-11-06T14:48:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Ok, it solved here: https://discourse.paraview.org/t/glyphs-displayed-not-in-all-elements/13199\nThanks for all of you for your help.\n@GiudGiud, thank you so much for working solution.",
                          "url": "https://github.com/idaholab/moose/discussions/25653#discussioncomment-7489919",
                          "updatedAt": "2023-11-06T16:49:30Z",
                          "publishedAt": "2023-11-06T16:49:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "October 2023 Newsletter",
          "author": {
            "login": "cticenhour"
          },
          "bodyText": "The October 2023 MOOSE Newsletter has been released! A summary of the content is below:\n\nMOOSE Improvements\n\nInput file includes\nArbitrary Langrangian Eulerian coupling FE and FV\nHybrid CG-DG formulation for Navier-Stokes\nSIMPLE algorithm for Navier-Stokes\nHeat conduction module rename to \"heat transfer\"\n\n\nPETSc-level Changes\n\nPETSc updated to 3.20.0\n\n\nBug Fixes and Minor Enhancements",
          "url": "https://github.com/idaholab/moose/discussions/25978",
          "updatedAt": "2023-11-06T15:43:49Z",
          "publishedAt": "2023-11-06T15:43:48Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      }
    ]
  }
}