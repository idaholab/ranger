{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNS0wMi0xMFQxMTo0MTo0Mi0wNzowMM4AeS8i"
    },
    "edges": [
      {
        "node": {
          "title": "Turn all Pressure BC's off",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "I've got a model with a bunch of different pressures (using Pressure BC) applied to different surfaces. At some time, I'd like to turn all that off (zero pressure everywhere). What's a good way to do that? I've heard about controllable parameters but it doesn't look like any parameters in Pressure BC are controllable?",
          "url": "https://github.com/idaholab/moose/discussions/22706",
          "updatedAt": "2025-02-14T21:15:12Z",
          "publishedAt": "2022-11-15T13:31:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre the pressure BC directly in the input file or are they added by an Action?\nThe Control system is able to turn on and off most blocks in the input file at will.\n@YaqiWang might have advice on how to do this for an action\nIf you are refering to this system, https://mooseframework.inl.gov/syntax/BCs/Pressure/index.html\nI d investigate the control tags parameter\nAnother solution is to modify/remove the sidesets when you want to turn the pressure BCs off\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-4147260",
                  "updatedAt": "2022-11-15T14:38:39Z",
                  "publishedAt": "2022-11-15T14:38:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "I'm using the action if that helps. Actually, I have my own custom action that calls the Pressure action!",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-4147460",
                          "updatedAt": "2022-11-15T14:56:21Z",
                          "publishedAt": "2022-11-15T14:56:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok so the control_tags parameter is likely not forwarded at this point down to the BCs.\nI would try to add the show_actions parameter to [Debug], get the names of the pressure BCs from there, then specify those names in a ConditionalEnableControl\n  [turn_off]\n    type = ConditionalFunctionEnableControl\n    disable_objects = 'BCs::name'\n    conditional_function = 'conditional_function'\n    execute_on = 'timestep_begin'\n  []\n\nif this does not work because the object name is not in the input file, then I would look at forwarding the control_tags parameter.\nYou can look at this PR to see how this was worked on recently, I may be mistaken\n#22069",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-4147633",
                          "updatedAt": "2022-11-15T15:13:24Z",
                          "publishedAt": "2022-11-15T15:13:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "@GiudGiud sanity check - What's a simple way to get a signal this is working, and working for all Pressure BCs (of which there may be many)? Maybe a Postprocessor I can use to check that the applied force is zero?",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-4510314",
                          "updatedAt": "2022-12-28T19:25:24Z",
                          "publishedAt": "2022-12-28T19:25:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah I have a PR that can do that for you but it s not in yet :(\nYou can put a print statement in the BC\nor\nyou can design a postprocessor to measure the force",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-4510568",
                          "updatedAt": "2022-12-28T20:18:05Z",
                          "publishedAt": "2022-12-28T20:18:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "@GiudGiud another question: can I add the ConditionalFunctionEnableControl object from an action? I don't see an addControl method.",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-4510791",
                          "updatedAt": "2022-12-28T21:22:46Z",
                          "publishedAt": "2022-12-28T21:21:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If it s been done it will have been in the thermal hydraulics module",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-4510821",
                          "updatedAt": "2022-12-28T21:29:58Z",
                          "publishedAt": "2022-12-28T21:29:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "THMAddControlAction.C seems to have some logic for that",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-4510824",
                          "updatedAt": "2022-12-28T21:30:45Z",
                          "publishedAt": "2022-12-28T21:30:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "How much of that logic do I need for a non-THM problem?",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-4510931",
                          "updatedAt": "2022-12-28T21:55:50Z",
                          "publishedAt": "2022-12-28T21:55:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "@GiudGiud Now that your PR on this is merged, can you explain/demostrate how you would do this from another action?. Right now, I have an action that adds PressureAction like\nstd::string surface_name = \"top\";\nauto params = _action_factory.getValidParams(\"PressureAction\");\nparams.set<std::vector<BoundaryName>>(\"boundary\") = {surface_name};\nparams.set<Real>(\"factor\") = factor;\nstd::string obj_name = surface_name+\"_pressure\";\nauto action = MooseSharedNamespace::static_pointer_cast<MooseObjectAction>(_action_factory.create(\"PressureAction\", obj_name, params));\n_awh.addActionBlock(action);\n\nThen later on in my Action I add a Control. How do I point it at this?",
                  "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12180238",
                  "updatedAt": "2025-02-12T21:49:31Z",
                  "publishedAt": "2025-02-12T21:49:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "effectively, control the \"enable\" parameter of the PressureAction.\nso either through some enable/disable parameters of control\n  [pressure_crank]\n    type = TimePeriod\n    enable_objects = 'BCs/Pressure/Side1'\n    disable_objects = 'BCs/Pressure/Side2 BCs/Pressure/Side3'\n\nor control the enable boolean for a control that acts on booleans",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12180296",
                          "updatedAt": "2025-02-12T21:56:34Z",
                          "publishedAt": "2025-02-12T21:56:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "OK so effectively my disable/enable_objects needs to be BCs/Pressure/obj_name?",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12180343",
                          "updatedAt": "2025-02-12T22:04:17Z",
                          "publishedAt": "2025-02-12T22:04:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think so because that s what the action is effectively creating\nby obj_name, it s the PressureAction name",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12180385",
                          "updatedAt": "2025-02-12T22:09:56Z",
                          "publishedAt": "2025-02-12T22:09:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "hmm, The desired parameter 'BCs/Pressure/top_pressure/enable' was not located...",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12180405",
                          "updatedAt": "2025-02-12T22:11:29Z",
                          "publishedAt": "2025-02-12T22:11:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "top_pressure is my obj_name here",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12180410",
                          "updatedAt": "2025-02-12T22:12:07Z",
                          "publishedAt": "2025-02-12T22:12:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you remove this line of code for now then use the brand new Debug/show_controllable to get the actual name/syntax to use",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12180449",
                          "updatedAt": "2025-02-12T22:18:10Z",
                          "publishedAt": "2025-02-12T22:18:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "do you mean remove the check in Control.C?",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12180604",
                          "updatedAt": "2025-02-12T22:42:13Z",
                          "publishedAt": "2025-02-12T22:42:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no I mean removing any instance of \"connectControllable\" that you are currently using\nare you saying that your action, creating the PressureAction, is erroring right now?",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12180638",
                          "updatedAt": "2025-02-12T22:48:34Z",
                          "publishedAt": "2025-02-12T22:48:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "no it's a runtime error - when it comes time for the Control to activate and turn PressureAction off, I get that error\nMy Control has: disable_objects = 'BCs/Pressure/top_pressure'\nIf I use PressureAction in an input file like this, it seems to work:\n  [Pressure]\n    [top_pressure]\n      boundary = top\n      factor = -10\n      use_displaced_mesh = true\n    []\n  []\n\nBut if I add a PressureAction from inside my Action (code shown above) I get that error",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12181307",
                          "updatedAt": "2025-02-13T00:54:07Z",
                          "publishedAt": "2025-02-13T00:54:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does Debug/show_controllable say ?",
                          "url": "https://github.com/idaholab/moose/discussions/22706#discussioncomment-12181319",
                          "updatedAt": "2025-02-13T00:54:56Z",
                          "publishedAt": "2025-02-13T00:54:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "slipsystem.C file",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "I am trying to locate the sourcecode that contains the code for different types of crystal structures used in the crystal plasticity model.\nBelow is a snippet of the relevant code:\n[trial_xtalpl_phase0]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.txt\n    crystal_lattice_type = BCC\n    resistance_tol = 0.01\n    r = 1.4             \n    h = 6000            \n    t_sat = 598.5        \n    gss_a = 1.5         \n    ao = 0.001           \n    xm = 0.017             \n    gss_initial = 400\n    base_name = phase0\n  []\n\nBelow is also the CrystalPlasticityKalidindiUpdate.C\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"CrystalPlasticityKalidindiUpdate.h\"\n#include \"libmesh/int_range.h\"\n\nregisterMooseObject(\"SolidMechanicsApp\", CrystalPlasticityKalidindiUpdate);\n\nInputParameters\nCrystalPlasticityKalidindiUpdate::validParams()\n{\n  InputParameters params = CrystalPlasticityStressUpdateBase::validParams();\n  params.addClassDescription(\"Kalidindi version of homogeneous crystal plasticity.\");\n  params.addParam<Real>(\"r\", 1.0, \"Latent hardening coefficient\");\n  params.addParam<Real>(\"h\", 541.5, \"hardening constants\");\n  params.addParam<Real>(\"t_sat\", 109.8, \"saturated slip system strength\");\n  params.addParam<Real>(\"gss_a\", 2.5, \"coefficient for hardening\");\n  params.addParam<Real>(\"ao\", 0.001, \"slip rate coefficient\");\n  params.addParam<Real>(\"xm\", 0.1, \"exponent for slip rate\");\n  params.addParam<Real>(\"gss_initial\", 60.8, \"initial lattice friction strength of the material\");\n\n  params.addParam<MaterialPropertyName>(\n      \"total_twin_volume_fraction\",\n      \"Total twin volume fraction, if twinning is considered in the simulation\");\n\n  return params;\n}\n\nCrystalPlasticityKalidindiUpdate::CrystalPlasticityKalidindiUpdate(\n    const InputParameters & parameters)\n  : CrystalPlasticityStressUpdateBase(parameters),\n    // Constitutive values\n    _r(getParam<Real>(\"r\")),\n    _h(getParam<Real>(\"h\")),\n    _tau_sat(getParam<Real>(\"t_sat\")),\n    _gss_a(getParam<Real>(\"gss_a\")),\n    _ao(getParam<Real>(\"ao\")),\n    _xm(getParam<Real>(\"xm\")),\n    _gss_initial(getParam<Real>(\"gss_initial\")),\n\n    // resize vectors used in the consititutive slip hardening\n    _hb(_number_slip_systems, 0.0),\n    _slip_resistance_increment(_number_slip_systems, 0.0),\n\n    // resize local caching vectors used for substepping\n    _previous_substep_slip_resistance(_number_slip_systems, 0.0),\n    _slip_resistance_before_update(_number_slip_systems, 0.0),\n\n    // Twinning contributions, if used\n    _include_twinning_in_Lp(parameters.isParamValid(\"total_twin_volume_fraction\")),\n    _twin_volume_fraction_total(_include_twinning_in_Lp\n                                    ? &getMaterialPropertyOld<Real>(\"total_twin_volume_fraction\")\n                                    : nullptr)\n{\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::initQpStatefulProperties()\n{\n  CrystalPlasticityStressUpdateBase::initQpStatefulProperties();\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    _slip_resistance[_qp][i] = _gss_initial;\n    _slip_increment[_qp][i] = 0.0;\n  }\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::setInitialConstitutiveVariableValues()\n{\n  // Would also set old dislocation densities here if included in this model\n  _slip_resistance[_qp] = _slip_resistance_old[_qp];\n  _previous_substep_slip_resistance = _slip_resistance_old[_qp];\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::setSubstepConstitutiveVariableValues()\n{\n  // Would also set substepped dislocation densities here if included in this model\n  _slip_resistance[_qp] = _previous_substep_slip_resistance;\n}\n\nbool\nCrystalPlasticityKalidindiUpdate::calculateSlipRate()\n{\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    _slip_increment[_qp][i] =\n        _ao * std::pow(std::abs(_tau[_qp][i] / _slip_resistance[_qp][i]), 1.0 / _xm);\n    if (_tau[_qp][i] < 0.0)\n      _slip_increment[_qp][i] *= -1.0;\n\n    if (std::abs(_slip_increment[_qp][i]) * _substep_dt > _slip_incr_tol)\n    {\n      if (_print_convergence_message)\n        mooseWarning(\"Maximum allowable slip increment exceeded \",\n                     std::abs(_slip_increment[_qp][i]) * _substep_dt);\n\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::calculateEquivalentSlipIncrement(\n    RankTwoTensor & equivalent_slip_increment)\n{\n  if (_include_twinning_in_Lp)\n  {\n    for (const auto i : make_range(_number_slip_systems))\n      equivalent_slip_increment += (1.0 - (*_twin_volume_fraction_total)[_qp]) *\n                                   _flow_direction[_qp][i] * _slip_increment[_qp][i] * _substep_dt;\n  }\n  else // if no twinning volume fraction material property supplied, use base class\n    CrystalPlasticityStressUpdateBase::calculateEquivalentSlipIncrement(equivalent_slip_increment);\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::calculateConstitutiveSlipDerivative(\n    std::vector<Real> & dslip_dtau)\n{\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    if (MooseUtils::absoluteFuzzyEqual(_tau[_qp][i], 0.0))\n      dslip_dtau[i] = 0.0;\n    else\n      dslip_dtau[i] = _ao / _xm *\n                      std::pow(std::abs(_tau[_qp][i] / _slip_resistance[_qp][i]), 1.0 / _xm - 1.0) /\n                      _slip_resistance[_qp][i];\n  }\n}\n\nbool\nCrystalPlasticityKalidindiUpdate::areConstitutiveStateVariablesConverged()\n{\n  return isConstitutiveStateVariableConverged(_slip_resistance[_qp],\n                                              _slip_resistance_before_update,\n                                              _previous_substep_slip_resistance,\n                                              _resistance_tol);\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::updateSubstepConstitutiveVariableValues()\n{\n  // Would also set substepped dislocation densities here if included in this model\n  _previous_substep_slip_resistance = _slip_resistance[_qp];\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::cacheStateVariablesBeforeUpdate()\n{\n  _slip_resistance_before_update = _slip_resistance[_qp];\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::calculateStateVariableEvolutionRateComponent()\n{\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    // Clear out increment from the previous iteration\n    _slip_resistance_increment[i] = 0.0;\n\n    _hb[i] = _h * std::pow(std::abs(1.0 - _slip_resistance[_qp][i] / _tau_sat), _gss_a);\n    const Real hsign = 1.0 - _slip_resistance[_qp][i] / _tau_sat;\n    if (hsign < 0.0)\n      _hb[i] *= -1.0;\n  }\n\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    for (const auto j : make_range(_number_slip_systems))\n    {\n      unsigned int iplane, jplane;\n      iplane = i / 3;\n      jplane = j / 3;\n\n      if (iplane == jplane) // self vs. latent hardening\n        _slip_resistance_increment[i] +=\n            std::abs(_slip_increment[_qp][j]) * _hb[j]; // q_{ab} = 1.0 for self hardening\n      else\n        _slip_resistance_increment[i] +=\n            std::abs(_slip_increment[_qp][j]) * _r * _hb[j]; // latent hardenign\n    }\n  }\n}\n\nbool\nCrystalPlasticityKalidindiUpdate::updateStateVariables()\n{\n  // Now perform the check to see if the slip system should be updated\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    _slip_resistance_increment[i] *= _substep_dt;\n    if (_previous_substep_slip_resistance[i] < _zero_tol && _slip_resistance_increment[i] < 0.0)\n      _slip_resistance[_qp][i] = _previous_substep_slip_resistance[i];\n    else\n      _slip_resistance[_qp][i] =\n          _previous_substep_slip_resistance[i] + _slip_resistance_increment[i];\n\n    if (_slip_resistance[_qp][i] < 0.0)\n      return false;\n  }\n  return true;\n}\n\n@dschwen @sapitts Can you help me locate the code/ source for the different crystal structures(FCC, BCC, HCP) used in the model ?above.",
          "url": "https://github.com/idaholab/moose/discussions/29784",
          "updatedAt": "2025-02-14T17:50:24Z",
          "publishedAt": "2025-01-31T22:33:19Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "yes, of course. That's set by a parameter in the base class, see CrystalPlasticityStressUpdateBase.C#L34 Search through the code in that class to see how and where the lattice type is used.\nPlease note too that the Kalidindi model is hard coded for an FCC structure, as described in the documentation, Eq 3: https://mooseframework.inl.gov/source/materials/crystal_plasticity/CrystalPlasticityKalidindiUpdate.html",
                  "url": "https://github.com/idaholab/moose/discussions/29784#discussioncomment-12022849",
                  "updatedAt": "2025-01-31T22:53:45Z",
                  "publishedAt": "2025-01-31T22:53:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "@sapitts I tried to add a new crystal structure(specifically the DO22 structure, which is a tetragonal structure). It compiles successfully, but I just wanted to share with you if there is room for improvement or if there is something that I am missing.\nBelow are relevant snippets of the code:\nIn the CrystalPlasticityStressUpdateBase.C\nvoid\nCrystalPlasticityStressUpdateBase_abs::getSlipSystems()\n{\n  bool orthonormal_error = false;\n\n  // read in the slip system data from auxiliary text file\n  MooseUtils::DelimitedFileReader _reader(_slip_sys_file_name);\n  _reader.setFormatFlag(MooseUtils::DelimitedFileReader::FormatFlag::ROWS);\n  _reader.read();\n\n  // check the size of the input\n  if (_reader.getData().size() != _number_slip_systems)\n    paramError(\n        \"number_slip_systems\",\n        \"The number of rows in the slip system file should match the number of slip system.\");\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    // initialize to zero\n    _slip_direction[i].zero();\n    _slip_plane_normal[i].zero();\n  }\n  if (_crystal_lattice_type == CrystalLatticeType::DO22)\n    transformDO22SlipSystems(_reader);\n  else if (_crystal_lattice_type == CrystalLatticeType::HCP)\n    transformHexagonalMillerBravaisSlipSystems(_reader);\n  else if (_crystal_lattice_type == CrystalLatticeType::BCC ||\n           _crystal_lattice_type == CrystalLatticeType::FCC)\n  {\n    for (const auto i : make_range(_number_slip_systems))\n    {\n      // directly grab the raw data and scale it by the unit cell dimension\n      for (const auto j : index_range(_reader.getData(i)))\n      {\n        if (j < LIBMESH_DIM)\n          _slip_plane_normal[i](j) = _reader.getData(i)[j] / _unit_cell_dimension[j];\n        else\n          _slip_direction[i](j - LIBMESH_DIM) =\n              _reader.getData(i)[j] * _unit_cell_dimension[j - LIBMESH_DIM];\n      }\n    }\n  }\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    // normalize\n    _slip_plane_normal[i] /= _slip_plane_normal[i].norm();\n    _slip_direction[i] /= _slip_direction[i].norm();\n\n    if (_crystal_lattice_type != CrystalLatticeType::HCP)\n    {\n      const auto magnitude = _slip_plane_normal[i] * _slip_direction[i];\n      if (std::abs(magnitude) > libMesh::TOLERANCE)\n      {\n        orthonormal_error = true;\n        break;\n      }\n    }\n  }\n  if (orthonormal_error)\n    mooseError(\"CrystalPlasticityStressUpdateBase_abs Error: The slip system file contains a slip \"\n               \"direction and plane normal pair that are not orthonormal in the Cartesian \"\n               \"coordinate system.\");\n}\n\nvoid CrystalPlasticityStressUpdateBase_abs::transformDO22SlipSystems(\n    const MooseUtils::DelimitedFileReader & reader)\n{\n    // Example logic for transforming DO22 slip systems \n    const unsigned int expected_columns = 6; \n    RealVectorValue temporary_slip_direction, temporary_slip_plane;\n\n    for (const auto i : make_range(_number_slip_systems))\n    {\n        // Read the slip plane and direction data from the file\n        for (const auto j : index_range(reader.getData(i)))\n        {\n            if (j < 3)\n                temporary_slip_plane(j) = reader.getData(i)[j];\n            else\n                temporary_slip_direction(j - 3) = reader.getData(i)[j];\n        }\n        // Normalize the slip direction and slip plane normal\n\n        _slip_plane_normal[i] = temporary_slip_plane / temporary_slip_plane.norm();\n        _slip_direction[i] = temporary_slip_direction / temporary_slip_direction.norm();\n    }\n\n}",
                          "url": "https://github.com/idaholab/moose/discussions/29784#discussioncomment-12088582",
                          "updatedAt": "2025-02-07T01:33:14Z",
                          "publishedAt": "2025-02-07T01:33:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "how often are getSlipSystems() and transformDO22SlipSystems() called? once at initialization right?",
                          "url": "https://github.com/idaholab/moose/discussions/29784#discussioncomment-12089334",
                          "updatedAt": "2025-02-07T03:28:38Z",
                          "publishedAt": "2025-02-07T03:28:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "@GiudGiud Yes.\nAlso, @sapitts @dschwen  do you have any suggestions about how to get different slip system strengths for certain slip systems? For example, out of the 12 slip systems for FCC, I specify every 4 with different slip system strengths in the input script.\nSo basically each of the 4 groupings has a different slip system in the same input script.",
                          "url": "https://github.com/idaholab/moose/discussions/29784#discussioncomment-12098088",
                          "updatedAt": "2025-02-07T19:23:42Z",
                          "publishedAt": "2025-02-07T19:23:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "@sapitts @dschwen A quick update on the different slip modes I tried to implement in a similar way as the HCP. Below are snippets of it.\nInputParameters\nCrystalPlasticityKalidindiUpdate_slip::validParams()\n{\n  InputParameters params = CrystalPlasticityStressUpdateBase_abs::validParams();\n  params.addParam<unsigned int>(\n    \"slip_system_modes\",\n    1,\n    \"Number of different types of slip systems, each with its own friction strength.\");\n  params.addParam<std::vector<unsigned int>>(\n    \"number_slip_systems_per_mode\",\n    std::vector<unsigned int>(),\n    \"The number of slip systems per slip mode.\");\n  params.addParam<std::vector<Real>>(\n    \"lattice_friction_per_mode\",\n    std::vector<Real>(),\n    \"Lattice friction strength for each slip mode in MPa.\");\n\n  params.addClassDescription(\"Kalidindi version of homogeneous crystal plasticity.\");\n  params.addParam<Real>(\"r\", 1.0, \"Latent hardening coefficient\");\n  params.addParam<Real>(\"h\", 541.5, \"hardening constants\");\n  params.addParam<Real>(\"t_sat\", 109.8, \"saturated slip system strength\");\n  params.addParam<Real>(\"gss_a\", 2.5, \"coefficient for hardening\");\n  params.addParam<Real>(\"ao\", 0.001, \"slip rate coefficient\");\n  params.addParam<Real>(\"xm\", 0.1, \"exponent for slip rate\");\n  params.addParam<Real>(\"gss_initial\", 60.8, \"initial lattice friction strength of the material\");\n\n  params.addParam<MaterialPropertyName>(\n      \"total_twin_volume_fraction\",\n      \"Total twin volume fraction, if twinning is considered in the simulation\");\n\n  return params;\n}\n\nCrystalPlasticityKalidindiUpdate_slip::CrystalPlasticityKalidindiUpdate_slip(\n    const InputParameters & parameters)\n  : CrystalPlasticityStressUpdateBase_abs(parameters),\n    // Constitutive values\n    _slip_system_modes(getParam<unsigned int>(\"slip_system_modes\")),\n    _number_slip_systems_per_mode(getParam<std::vector<unsigned int>>(\"number_slip_systems_per_mode\")),\n    _lattice_friction(getParam<std::vector<Real>>(\"lattice_friction_per_mode\")),\n    _r(getParam<Real>(\"r\")),\n    _h(getParam<Real>(\"h\")),\n    _tau_sat(getParam<Real>(\"t_sat\")),\n    _gss_a(getParam<Real>(\"gss_a\")),\n    _ao(getParam<Real>(\"ao\")),\n    _xm(getParam<Real>(\"xm\")),\n    _gss_initial(getParam<Real>(\"gss_initial\")),\n\n    // resize vectors used in the consititutive slip hardening\n    _hb(_number_slip_systems, 0.0),\n    _slip_resistance_increment(_number_slip_systems, 0.0),\n\n    // resize local caching vectors used for substepping\n    _previous_substep_slip_resistance(_number_slip_systems, 0.0),\n    _slip_resistance_before_update(_number_slip_systems, 0.0),\n\n    // Twinning contributions, if used\n    _include_twinning_in_Lp(parameters.isParamValid(\"total_twin_volume_fraction\")),\n    _twin_volume_fraction_total(_include_twinning_in_Lp\n                                    ? &getMaterialPropertyOld<Real>(\"total_twin_volume_fraction\")\n                                    : nullptr)\n{\n    // check that the number of slip systems is equal to the sum of the types of slip system\n    if (_number_slip_systems_per_mode.size() != _slip_system_modes)\n    paramError(\"number_slip_systems_per_mode\",\n               \"The size the number of slip systems per mode is not equal to the number of slip \"\n               \"system types.\");                                \n                                    \n    if (_lattice_friction.size() != _slip_system_modes)\n    paramError(\"lattice_friction_per_mode\",\n               \"Please ensure that the size of lattice_friction_per_mode equals the value supplied \"\n               \"for slip_system_modes\");\n\n  unsigned int sum = 0;\n  for (const auto i : make_range(_slip_system_modes))\n    sum += _number_slip_systems_per_mode[i];\n  if (sum != _number_slip_systems)\n    paramError(\"slip_system_modes\",\n               \"The number of slip systems and the sum of the slip systems in each of the slip \"\n               \"system modes are not equal\");\n\n}\n\nvoid CrystalPlasticityKalidindiUpdate_slip::initQpStatefulProperties()\n{\n  CrystalPlasticityStressUpdateBase_abs::initQpStatefulProperties();\n  \n  // Set initial resistance from lattice friction, which is type dependent\n  unsigned int slip_mode = 0;\n  unsigned int counter_adjustment = 0;\n\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    if ((i - counter_adjustment) < _number_slip_systems_per_mode[slip_mode])\n      _slip_resistance[_qp][i] = _lattice_friction[slip_mode];\n    else\n    {\n      counter_adjustment += _number_slip_systems_per_mode[slip_mode];\n      ++slip_mode;\n      _slip_resistance[_qp][i] = _lattice_friction[slip_mode];\n    }\n\n    _slip_increment[_qp][i] = 0.0;\n  }\n\n}\n\nvoid CrystalPlasticityKalidindiUpdate_slip::calculateStateVariableEvolutionRateComponent()\n{\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    _slip_resistance_increment[i] = 0.0;\n\n    unsigned int slip_mode = 0;\n    unsigned int counter_adjustment = 0;\n    for (const auto j : make_range(_number_slip_systems))\n    {\n      if ((j - counter_adjustment) < _number_slip_systems_per_mode[slip_mode])\n      {\n        _hb[j] = _h * std::pow(std::abs(1.0 - _slip_resistance[_qp][j] / _tau_sat), _gss_a);\n      }\n      else\n      {\n        counter_adjustment += _number_slip_systems_per_mode[slip_mode];\n        ++slip_mode;\n        _hb[j] = _h * std::pow(std::abs(1.0 - _slip_resistance[_qp][j] / _tau_sat), _gss_a);\n      }\n\n      Real hsign = 1.0 - _slip_resistance[_qp][j] / _tau_sat;\n      if (hsign < 0.0)\n        _hb[j] *= -1.0;\n\n      unsigned int iplane = i / 3;\n      unsigned int jplane = j / 3;\n\n      if (iplane == jplane) \n        _slip_resistance_increment[i] += std::abs(_slip_increment[_qp][j]) * _hb[j];\n      else \n        _slip_resistance_increment[i] += std::abs(_slip_increment[_qp][j]) * _r * _hb[j];\n    }\n  }\n}",
                          "url": "https://github.com/idaholab/moose/discussions/29784#discussioncomment-12204063",
                          "updatedAt": "2025-02-14T17:51:26Z",
                          "publishedAt": "2025-02-14T17:50:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Large Deformation Formulation",
          "author": {
            "login": "drebbel1z"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nIs it possible to point me to some tutorials that will explain moose's large deformation formulation? I am trying to understand the formulation but haven't found enough details around the documentation. I would appreciate any leads. Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/29823",
          "updatedAt": "2025-02-14T14:51:57Z",
          "publishedAt": "2025-02-06T16:25:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthe summary of all our strain models are here\nhttps://mooseframework.inl.gov/modules/solid_mechanics/Strains.html\nwe are adding more dynamics capability if that's what you're looking for",
                  "url": "https://github.com/idaholab/moose/discussions/29823#discussioncomment-12084199",
                  "updatedAt": "2025-02-06T16:29:52Z",
                  "publishedAt": "2025-02-06T16:29:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "drebbel1z"
                  },
                  "bodyText": "Hi,\nAssuming I am using the finite strain formulation for isotropic plasticity, will this still be using the additive decomposition of strains or will it swtich to multiplicative decomposition?",
                  "url": "https://github.com/idaholab/moose/discussions/29823#discussioncomment-12103655",
                  "updatedAt": "2025-02-08T15:23:11Z",
                  "publishedAt": "2025-02-08T15:21:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I don't think we do multiplicative decomposition. Do you have a page that references it in moose so I can read up on it?",
                          "url": "https://github.com/idaholab/moose/discussions/29823#discussioncomment-12103773",
                          "updatedAt": "2025-02-08T15:43:35Z",
                          "publishedAt": "2025-02-08T15:43:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "drebbel1z"
                          },
                          "bodyText": "I did not find a page on it. I just wanted to confirm because the isotropic plasticity page is written in additive decomposition. Can I still use this when the strains are finite?",
                          "url": "https://github.com/idaholab/moose/discussions/29823#discussioncomment-12104114",
                          "updatedAt": "2025-02-08T16:45:33Z",
                          "publishedAt": "2025-02-08T16:45:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "The Lagrangian kernels may be of interest. https://mooseframework.inl.gov/modules/solid_mechanics/NewMaterialSystem.html",
                          "url": "https://github.com/idaholab/moose/discussions/29823#discussioncomment-12201821",
                          "updatedAt": "2025-02-14T14:51:57Z",
                          "publishedAt": "2025-02-14T14:51:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Modeling the Thermal Contact Resistance R_t,c Between Two Blocks",
          "author": {
            "login": "CadenWil"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi,\nI've been modeling heat conduction between two blocks. I know this has been asked before, but I was unable to answer my question by looking at those forum posts. I would like to add a resistance between the two blocks without modeling a gap as the gap would be extremely small compared to the blocks themselves.  The description of the SideSetHeatTransferKernel says\n\nThis kernel models the heat transfer across a side set using all three heat transfer mechanisms. The purpose is to model the heat transfer across a small gap without modeling the gap itself.\n\nThis sounds like it should fit my needs for this problem.  When I attempt to run the problem however I get this error:\n\nVariable and neighbor variable are the same, but they are not elemental variables.\n\nI believe I've set up the problem correctly, and I'm unsure why this error is occurring.  Here is my input file for this problem:\nSiliconChip_3D.txt\nI have an interface between the two blocks but the mesh should be continuous.\nThanks for any help you can offer.",
          "url": "https://github.com/idaholab/moose/discussions/29866",
          "updatedAt": "2025-02-13T18:45:59Z",
          "publishedAt": "2025-02-12T16:09:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Variable and neighbor variable are the same, but they are not elemental variables.\n\nThis means that SideSetHeatTransferKernel was coded for elemental variables, e.g. probably using a discontinuous Galerkin discretization. You are using nodal variables (the default is linear lagrange),\n[Variables]\n  [T]\n    initial_condition = 298.15\n  []\n[]\n\nFor modeling a gap, which mechanicms do you you need capture? Just radiation? Or convection as well?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/29866#discussioncomment-12179785",
                  "updatedAt": "2025-02-12T20:48:09Z",
                  "publishedAt": "2025-02-12T20:48:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "CadenWil"
                          },
                          "bodyText": "Currently I was trying to do just conduction.  The gap is extremely small so I was going to use SideSetHeatTransferKernel to model it rather than add an additional block with it's own material properties.",
                          "url": "https://github.com/idaholab/moose/discussions/29866#discussioncomment-12179922",
                          "updatedAt": "2025-02-12T21:07:57Z",
                          "publishedAt": "2025-02-12T21:07:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you use this? it works for nodal variables\nhttps://mooseframework.inl.gov/source/bcs/GapHeatTransfer.html",
                          "url": "https://github.com/idaholab/moose/discussions/29866#discussioncomment-12180039",
                          "updatedAt": "2025-02-12T21:24:07Z",
                          "publishedAt": "2025-02-12T21:24:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah but you want it to be an interface.\nTHis wont be possible with a single variable",
                          "url": "https://github.com/idaholab/moose/discussions/29866#discussioncomment-12180043",
                          "updatedAt": "2025-02-12T21:24:36Z",
                          "publishedAt": "2025-02-12T21:24:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "a single continuous* variable\nit will need to be discontinuous to be able to model a gap. So either switch to DG OR use two continuous variables on each side of the domain\nthen you can use the interface kernel",
                          "url": "https://github.com/idaholab/moose/discussions/29866#discussioncomment-12180050",
                          "updatedAt": "2025-02-12T21:25:28Z",
                          "publishedAt": "2025-02-12T21:25:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "CadenWil"
                          },
                          "bodyText": "can you use this? it works for nodal variables https://mooseframework.inl.gov/source/bcs/GapHeatTransfer.html\n\nI decided to try this route. Here is my result:\nSiliconChip_addGapHeat.txt\nMy issue with this method is that it is taking a much longer time to run what I would've thought to be a fairly simple problem.  Can you see anything I might have gotten wrong when implementing the GapHeatTransfer method?\nThanks for all your help in this.  I'm hoping to moved to more advanced problems in the future, but I'm trying to make sure I understand a lot of the basics.",
                          "url": "https://github.com/idaholab/moose/discussions/29866#discussioncomment-12191298",
                          "updatedAt": "2025-02-13T18:12:48Z",
                          "publishedAt": "2025-02-13T18:12:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "both of these options are not necessary\n  off_diagonals_in_auto_scaling = true\n  compute_scaling_once = false\n\nand the latter could be hurting your convergence by making the criteria tigther on every solve",
                          "url": "https://github.com/idaholab/moose/discussions/29866#discussioncomment-12191624",
                          "updatedAt": "2025-02-13T18:44:42Z",
                          "publishedAt": "2025-02-13T18:44:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "LU might be getting slow. How many elements do you have ? 15k roughly? That should still work for LU\nfor heat conduction problem, hypre + boomeramg should work well for solving the linear systems",
                          "url": "https://github.com/idaholab/moose/discussions/29866#discussioncomment-12191648",
                          "updatedAt": "2025-02-13T18:46:00Z",
                          "publishedAt": "2025-02-13T18:45:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to handle hanging nodes?",
          "author": {
            "login": "PEI0214"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI would like to learn about how the constraints on 'hanging nodes' are handled in mesh adaptation. Where can I find relevant materials on this?",
          "url": "https://github.com/idaholab/moose/discussions/29867",
          "updatedAt": "2025-02-12T16:52:31Z",
          "publishedAt": "2025-02-12T16:12:09Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nYou ll need to go in libMesh for this\nIt will be documented in the code\nhttps://mooseframework.inl.gov/docs/doxygen/libmesh/index.html\nnot really any theory documentation on this implementation detail",
                  "url": "https://github.com/idaholab/moose/discussions/29867#discussioncomment-12176618",
                  "updatedAt": "2025-02-12T16:52:32Z",
                  "publishedAt": "2025-02-12T16:52:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Density-based topology optimization with MOOSE",
          "author": {
            "login": "Flolaffel"
          },
          "bodyText": "Hello,\nI'm currently working on topology optimization and am looking for open-source codes (educational/research) to study and possibly extend in the future. Is there currently a known implementation of a density-based topology optimization algorithm using MOOSE?\nThanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/25508",
          "updatedAt": "2025-02-12T01:49:22Z",
          "publishedAt": "2023-09-19T09:27:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@maxnezdyur @zachmprince @lynnmunday",
                  "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-7045285",
                  "updatedAt": "2023-09-19T11:47:06Z",
                  "publishedAt": "2023-09-19T11:47:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "There is a PR that will be pushed to MOOSE soon. It is a density-based method that has both a convolution and a PDE based sensitivity filter. It uses the OC method to keep the volume constraint. Currently, it just minimizes compliance.",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-7045401",
                          "updatedAt": "2023-09-19T11:59:21Z",
                          "publishedAt": "2023-09-19T11:59:20Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Sounds very interesting. Will definitely keep an eye on that.\nAre you using SIMP?",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-7046977",
                          "updatedAt": "2023-09-19T14:13:45Z",
                          "publishedAt": "2023-09-19T14:13:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Yes.",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-7047030",
                          "updatedAt": "2023-09-19T14:18:16Z",
                          "publishedAt": "2023-09-19T14:18:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Just saw your TopOp fork. Very excited for the update! When do you expect to push to master?",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-7055686",
                          "updatedAt": "2023-09-20T08:33:36Z",
                          "publishedAt": "2023-09-20T08:33:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "In a week or so, I have to change few things and add more documentation.",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-7057325",
                          "updatedAt": "2023-09-20T11:05:44Z",
                          "publishedAt": "2023-09-20T11:05:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "kurtenkera"
                          },
                          "bodyText": "Hi @maxnezdyur @Flolaffel - I am new to topology optimisation (TO), but I have a project where I have to perform TO using MOOSE. Where can I find the TopOp implementation in MOOSE that was discussed above?\nAlso, do you guys have any recommended learning resources for someone who is new to TO? I find a lot of sources are very deep and technical, but are there any nice broad introductions to TO that I can visit before diving into the rigorous details?",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9020561",
                          "updatedAt": "2024-04-05T11:36:50Z",
                          "publishedAt": "2024-04-05T11:36:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Hi, you can find some example inputs under moose/modules/combined/examples/optimization. Most basic example is the 2d_mbb.\nI think good resources to start are:\nBendsoe & Sigmund (2003) - Topology Optimization - Theory, Methods and Applications\nSigmund (2001) - A 99 line topology optimization code written in Matlab\nAndreassen (2011) - Efficient topology optimization in MATLAB using 88 lines of code\nUnderstanding these MATLAB codes will help a lot. You can also work through the MOOSE code of SensitivityFilter and DensityUpdate which do basically the same thing as the MATLAB codes.",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9020742",
                          "updatedAt": "2024-04-05T11:56:58Z",
                          "publishedAt": "2024-04-05T11:56:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "kurtenkera"
                          },
                          "bodyText": "Hi @Flolaffel - thanks for your helpful response. I have just run the 2d_mbb example in moose/modules/combined/examples/optimization. The resulting optimized topology can be seen below:\n\nI have a question: How did you learn to make sense of this topology optimization (TO) implementation in MOOSE? I cannot find any tutorials on TO in MOOSE, so I can't see exactly how things have been implemented, other than by inspecting the format of 2d_mbb.i (see below). For example, I can see that this is a SIMP implementation, purely from the presence of expression = '${Emin} + (mat_den ^ ${power}) * (${E0}-${Emin})'. But how is the volume constraint applied for example? Furthermore, how are sensitivities calculated and used? How is the strain energy density function computed (the function being minimized)?\nI feel like if there were a tutorial somewhere, explaining where these important steps are executed, this would clear things up for me. Also, perhaps if I were an expert on TO, I might be able to answer these questions myself - but as I am still learning, I'm finding it quite difficult to understand!\nvol_frac = 0.5\nE0 = 1\nEmin = 1e-8\npower = 2\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Mesh]\n  [MeshGenerator]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 150\n    ny = 50\n    xmin = 0\n    xmax = 30\n    ymin = 0\n    ymax = 10\n  []\n  [node]\n    type = ExtraNodesetGenerator\n    input = MeshGenerator\n    new_boundary = pull\n    nodes = 0\n  []\n  [push]\n    type = ExtraNodesetGenerator\n    input = node\n    new_boundary = push\n    coord = '30 10 0'\n  []\n\n[]\n\n[AuxVariables]\n\n  [Emin]\n    family = MONOMIAL\n    order = CONSTANT\n    initial_condition = ${Emin}\n  []\n  [power]\n    family = MONOMIAL\n    order = CONSTANT\n    initial_condition = ${power}\n  []\n  [E0]\n    family = MONOMIAL\n    order = CONSTANT\n    initial_condition = ${E0}\n  []\n  [Dc]\n    family = MONOMIAL\n    order = CONSTANT\n    initial_condition = -1.0\n  []\n  [mat_den]\n    family = MONOMIAL\n    order = CONSTANT\n    initial_condition = ${vol_frac}\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    strain = SMALL\n    add_variables = true\n    incremental = false\n  []\n[]\n\n[BCs]\n  [no_x]\n    type = DirichletBC\n    variable = disp_y\n    boundary = pull\n    value = 0.0\n  []\n  [no_y]\n    type = DirichletBC\n    variable = disp_x\n    boundary = right\n    value = 0.0\n  []\n\n[]\n[NodalKernels]\n  [pull]\n    type = NodalGravity\n    variable = disp_y\n    boundary = push\n    gravity_value = -1\n    mass = 1\n  []\n[]\n[Materials]\n  [elasticity_tensor]\n    type = ComputeVariableIsotropicElasticityTensor\n    youngs_modulus = E_phys\n    poissons_ratio = poissons_ratio\n    args = 'Emin mat_den power E0'\n  []\n  [E_phys]\n    type = DerivativeParsedMaterial\n    # Emin + (density^penal) * (E0 - Emin)\n    expression = '${Emin} + (mat_den ^ ${power}) * (${E0}-${Emin})'\n    coupled_variables = 'mat_den'\n    property_name = E_phys\n  []\n  [poissons_ratio]\n    type = GenericConstantMaterial\n    prop_names = poissons_ratio\n    prop_values = 0.3\n  []\n  [stress]\n    type = ComputeLinearElasticStress\n  []\n  [dc]\n    type = ComplianceSensitivity\n    design_density = mat_den\n    youngs_modulus = E_phys\n    incremental = false\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n[UserObjects]\n  [rad_avg]\n    type = RadialAverage\n    radius = 1.2\n    weights = linear\n    prop_name = sensitivity\n    execute_on = TIMESTEP_END\n    force_preaux = true\n  []\n  [update]\n    type = DensityUpdate\n    density_sensitivity = Dc\n    design_density = mat_den\n    volume_fraction = ${vol_frac}\n    execute_on = TIMESTEP_BEGIN\n  []\n  [calc_sense]\n    type = SensitivityFilter\n    density_sensitivity = Dc\n    design_density = mat_den\n    filter_UO = rad_avg\n    execute_on = TIMESTEP_END\n    force_postaux = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu superlu_dist'\n  nl_abs_tol = 1e-8\n  dt = 1.0\n  num_steps = 70\n[]\n\n[Outputs]\n  [out]\n    type = Exodus\n    execute_on = 'TIMESTEP_END'\n  []\n  print_linear_residuals = false\n[]\n\n[Postprocessors]\n  [total_vol]\n    type = ElementIntegralVariablePostprocessor\n    variable = mat_den\n    execute_on = 'INITIAL TIMESTEP_END'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9091520",
                          "updatedAt": "2024-04-12T05:45:30Z",
                          "publishedAt": "2024-04-12T05:38:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "The MOOSE tutorial on the SIMP implementation can be found here.\nRegarding your picture, you have to uncheck the \"Apply Displacements\" box in paraview to get a good look at the actual solution of the problem. Otherwise it's so heavily distorted, you can't really make sense of it.\nIf you really want to understand the underlying mechanisms, just reading the input file you attached won't be sufficient. You'll have to read the actual source code of the used classes.\n\nThe volume constraint is enforced in the Optimality Criteria method implemented in DensityUpdate.C\nThe compliance sensitivity (our objective function sensitivity) is computed in ComplianceSensitivity.C\nThe strain energy (density) is computed in StrainEnergyDensity.C which ComplianceSensitivity.C inherits from\n\nTo see and understand the actual formulas for computation, I'd recommend you check out the literature I recommended in my last answer.",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9093549",
                          "updatedAt": "2024-04-12T09:13:28Z",
                          "publishedAt": "2024-04-12T09:13:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "kurtenkera"
                          },
                          "bodyText": "Thankyou @Flolaffel and @lynnmunday - this has helped enormously!\nBy the way, do you know if a general method exists to convert an Exodus (.e) or VTK (.vtu) file of a topology-optimized component in MOOSE into a Gmsh (.msh) file or STL file? Basically, I'm trying to simulate my topology optimized component in a dynamical simulator, and to do this I need to convert the topology optimized component into a .msh file or .stl file. Furthermore, if I wanted to 3D print the resulting component, I would need to convert to an STL file? I tried outputting the 2D MBB example first as a .vtk file in MOOSE, and then converting to a .msh file using Meshio in Python. Below is the .vtk file of the optimized component in Paraview:\n\nBelow is the resulting .msh file in Gmsh (created by converting the .vtk file to a .msh file w/ Meshio). As you can see, the .msh file is just the original rectangular domain, whereas I need it to exclude all of the void regions? Would I need to somehow create code that converts all element density values to 0 or 1, and then exclude all nodes in the mesh that are associated with void regions in the rectangular domain, before converting to an STL or MSH file type?",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9123237",
                          "updatedAt": "2024-04-15T22:42:00Z",
                          "publishedAt": "2024-04-15T22:03:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "@maxnezdyur also structured the code similar to what is in this reference which is good tutorial on simp:\nOle Sigmund. A 99 line topology optimization code written in matlab. Structural and multidisciplinary optimization, 21:120\u2013127, 2001.\nIn the moose implementation of simp, each transient step is an optimization iteration.  In the input file you'll see Execute_on timestep_begin or end and that is how we control the optimization steps within an iteration but @Flolaffel is right, you'll need to look at the source code to figure it out how SIMP is implemented.",
                  "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9098487",
                  "updatedAt": "2024-04-12T17:01:19Z",
                  "publishedAt": "2024-04-12T17:01:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "kurtenkera"
                  },
                  "bodyText": "Hi @GiudGiud @Flolaffel @GregVernon @maxnezdyur @lynnmunday. I am trying to generate a Python script that can automate the following Paraview file conversion/smoothing pipeline (using Paraview version 5.11.2):\n(1) Read Exodus/VTK file (e.g., 3d_mbb_out.e) into Paraview,\n(2) Apply Cell Data to Point Data filter,\n(3) Apply Iso Volume filter, with lower bound = 0.95 and upper bound = 2 (something above 1),\n(4) Apply Extract Surface filter and save as an STL (ASCII) file (e.g., 3dmbb.stl).\nI've generated a Python script by simply opening Paraview, and going into Tools >> Start Trace, and then executing the steps above, and then clicking Tools >> Stop Trace once I'm finished. This generates a Python script which should in theory be capable of executing the above steps automatically, without needing to manually open the Paraview GUI. However, when I attempt to do this with the file 3d_mbb_out.e (i.e. the outputted file when running TopOpt on 3d_mbb.i located here), my resulting Python script is incapable of saving a smoothed STL file called 3dmbb.stl. The script I generated is seen below:\n# trace generated using paraview version 5.11.2\n#import paraview\n#paraview.compatibility.major = 5\n#paraview.compatibility.minor = 11\n\n#### import the simple module from the paraview\nfrom paraview.simple import *\n#### disable automatic camera reset on 'Show'\nparaview.simple._DisableFirstRenderCameraReset()\n\n# create a new 'IOSS Reader'\na3d_mbb_oute = IOSSReader(registrationName='3d_mbb_out.e', FileName=['/home/enk001/Documents/PHD/PHD-Code/projects-MOOSE/moose/modules/combined/examples/optimization/3d_mbb_out.e'])\na3d_mbb_oute.ElementBlocks = ['block_0']\na3d_mbb_oute.NodeBlockFields = ['Dc', 'disp', 'mat_den_nodal', 'sensitivity']\na3d_mbb_oute.ElementBlockFields = ['Dc_elem', 'E0', 'Emin', 'mat_den', 'power']\na3d_mbb_oute.NodeSets = ['back', 'bottom', 'right', 'top', 'left', 'front', 'hold_y', 'push']\na3d_mbb_oute.SideSets = ['back', 'bottom', 'right', 'top', 'left', 'front']\n\n# get animation scene\nanimationScene1 = GetAnimationScene()\n\n# get the time-keeper\ntimeKeeper1 = GetTimeKeeper()\n\n# get active view\nrenderView1 = GetActiveViewOrCreate('RenderView')\n\n# get display properties\na3d_mbb_outeDisplay = GetDisplayProperties(a3d_mbb_oute, view=renderView1)\n\n# get color transfer function/color map for 'vtkBlockColors'\nvtkBlockColorsLUT = GetColorTransferFunction('vtkBlockColors')\n\n# get opacity transfer function/opacity map for 'vtkBlockColors'\nvtkBlockColorsPWF = GetOpacityTransferFunction('vtkBlockColors')\n\n# get 2D transfer function for 'vtkBlockColors'\nvtkBlockColorsTF2D = GetTransferFunction2D('vtkBlockColors')\n\n# update animation scene based on data timesteps\nanimationScene1.UpdateAnimationUsingDataTimeSteps()\n\n# Properties modified on a3d_mbb_oute\na3d_mbb_oute.ElementBlockFields = ['Dc_elem', 'E0', 'Emin', 'mat_den']\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# Properties modified on a3d_mbb_oute\na3d_mbb_oute.ElementBlockFields = ['Dc_elem', 'E0', 'mat_den']\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# Properties modified on a3d_mbb_oute\na3d_mbb_oute.ElementBlockFields = ['Dc_elem', 'mat_den']\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# Properties modified on a3d_mbb_oute\na3d_mbb_oute.ElementBlockFields = ['mat_den']\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# Properties modified on a3d_mbb_oute\na3d_mbb_oute.NodeBlockFields = ['Dc', 'disp', 'mat_den_nodal']\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# Properties modified on a3d_mbb_oute\na3d_mbb_oute.NodeBlockFields = ['Dc', 'disp']\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# Properties modified on a3d_mbb_oute\na3d_mbb_oute.NodeBlockFields = ['Dc']\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# Properties modified on a3d_mbb_oute\na3d_mbb_oute.NodeBlockFields = []\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# Properties modified on a3d_mbb_oute\na3d_mbb_oute.ApplyDisplacements = 0\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# set scalar coloring\nColorBy(a3d_mbb_outeDisplay, ('CELLS', 'mat_den'))\n\n# Hide the scalar bar for this color map if no visible data is colored by it.\nHideScalarBarIfNotNeeded(vtkBlockColorsLUT, renderView1)\n\n# rescale color and/or opacity maps used to include current data range\na3d_mbb_outeDisplay.RescaleTransferFunctionToDataRange(True, False)\n\n# show color bar/color legend\na3d_mbb_outeDisplay.SetScalarBarVisibility(renderView1, True)\n\n# get color transfer function/color map for 'mat_den'\nmat_denLUT = GetColorTransferFunction('mat_den')\n\n# get opacity transfer function/opacity map for 'mat_den'\nmat_denPWF = GetOpacityTransferFunction('mat_den')\n\n# get 2D transfer function for 'mat_den'\nmat_denTF2D = GetTransferFunction2D('mat_den')\n\n# create a new 'Cell Data to Point Data'\ncellDatatoPointData1 = CellDatatoPointData(registrationName='CellDatatoPointData1', Input=a3d_mbb_oute)\ncellDatatoPointData1.CellDataArraytoprocess = ['element_side', 'ids', 'mat_den', 'object_id']\n\n# show data in view\ncellDatatoPointData1Display = Show(cellDatatoPointData1, renderView1, 'UnstructuredGridRepresentation')\n\n# trace defaults for the display properties.\ncellDatatoPointData1Display.Representation = 'Surface'\ncellDatatoPointData1Display.ColorArrayName = [None, '']\ncellDatatoPointData1Display.SelectTCoordArray = 'None'\ncellDatatoPointData1Display.SelectNormalArray = 'None'\ncellDatatoPointData1Display.SelectTangentArray = 'None'\ncellDatatoPointData1Display.OSPRayScaleArray = 'element_side'\ncellDatatoPointData1Display.OSPRayScaleFunction = 'PiecewiseFunction'\ncellDatatoPointData1Display.SelectOrientationVectors = 'None'\ncellDatatoPointData1Display.ScaleFactor = 3.0\ncellDatatoPointData1Display.SelectScaleArray = 'None'\ncellDatatoPointData1Display.GlyphType = 'Arrow'\ncellDatatoPointData1Display.GlyphTableIndexArray = 'None'\ncellDatatoPointData1Display.GaussianRadius = 0.15\ncellDatatoPointData1Display.SetScaleArray = ['POINTS', 'element_side']\ncellDatatoPointData1Display.ScaleTransferFunction = 'PiecewiseFunction'\ncellDatatoPointData1Display.OpacityArray = ['POINTS', 'element_side']\ncellDatatoPointData1Display.OpacityTransferFunction = 'PiecewiseFunction'\ncellDatatoPointData1Display.DataAxesGrid = 'GridAxesRepresentation'\ncellDatatoPointData1Display.PolarAxes = 'PolarAxesRepresentation'\ncellDatatoPointData1Display.ScalarOpacityUnitDistance = 1.008114241552259\ncellDatatoPointData1Display.OpacityArrayName = ['POINTS', 'element_side']\ncellDatatoPointData1Display.SelectInputVectors = [None, '']\ncellDatatoPointData1Display.WriteLog = ''\n\n# init the 'PiecewiseFunction' selected for 'ScaleTransferFunction'\ncellDatatoPointData1Display.ScaleTransferFunction.Points = [1.0, 0.0, 0.5, 0.0, 24000.0, 1.0, 0.5, 0.0]\n\n# init the 'PiecewiseFunction' selected for 'OpacityTransferFunction'\ncellDatatoPointData1Display.OpacityTransferFunction.Points = [1.0, 0.0, 0.5, 0.0, 24000.0, 1.0, 0.5, 0.0]\n\n# hide data in view\nHide(a3d_mbb_oute, renderView1)\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# set scalar coloring\nColorBy(cellDatatoPointData1Display, ('FIELD', 'vtkBlockColors'))\n\n# show color bar/color legend\ncellDatatoPointData1Display.SetScalarBarVisibility(renderView1, True)\n\n# set scalar coloring\nColorBy(cellDatatoPointData1Display, ('POINTS', 'mat_den'))\n\n# Hide the scalar bar for this color map if no visible data is colored by it.\nHideScalarBarIfNotNeeded(vtkBlockColorsLUT, renderView1)\n\n# rescale color and/or opacity maps used to include current data range\ncellDatatoPointData1Display.RescaleTransferFunctionToDataRange(True, False)\n\n# show color bar/color legend\ncellDatatoPointData1Display.SetScalarBarVisibility(renderView1, True)\n\n# create a new 'Iso Volume'\nisoVolume1 = IsoVolume(registrationName='IsoVolume1', Input=cellDatatoPointData1)\nisoVolume1.InputScalars = ['POINTS', 'mat_den']\nisoVolume1.ThresholdRange = [8.614340690391311e-09, 1.0]\n\n# show data in view\nisoVolume1Display = Show(isoVolume1, renderView1, 'UnstructuredGridRepresentation')\n\n# trace defaults for the display properties.\nisoVolume1Display.Representation = 'Surface'\nisoVolume1Display.ColorArrayName = ['POINTS', 'mat_den']\nisoVolume1Display.LookupTable = mat_denLUT\nisoVolume1Display.SelectTCoordArray = 'None'\nisoVolume1Display.SelectNormalArray = 'None'\nisoVolume1Display.SelectTangentArray = 'None'\nisoVolume1Display.OSPRayScaleArray = 'mat_den'\nisoVolume1Display.OSPRayScaleFunction = 'PiecewiseFunction'\nisoVolume1Display.SelectOrientationVectors = 'None'\nisoVolume1Display.ScaleFactor = 3.0\nisoVolume1Display.SelectScaleArray = 'mat_den'\nisoVolume1Display.GlyphType = 'Arrow'\nisoVolume1Display.GlyphTableIndexArray = 'mat_den'\nisoVolume1Display.GaussianRadius = 0.15\nisoVolume1Display.SetScaleArray = ['POINTS', 'mat_den']\nisoVolume1Display.ScaleTransferFunction = 'PiecewiseFunction'\nisoVolume1Display.OpacityArray = ['POINTS', 'mat_den']\nisoVolume1Display.OpacityTransferFunction = 'PiecewiseFunction'\nisoVolume1Display.DataAxesGrid = 'GridAxesRepresentation'\nisoVolume1Display.PolarAxes = 'PolarAxesRepresentation'\nisoVolume1Display.ScalarOpacityFunction = mat_denPWF\nisoVolume1Display.ScalarOpacityUnitDistance = 1.1167665609818371\nisoVolume1Display.OpacityArrayName = ['POINTS', 'mat_den']\nisoVolume1Display.SelectInputVectors = [None, '']\nisoVolume1Display.WriteLog = ''\n\n# init the 'PiecewiseFunction' selected for 'ScaleTransferFunction'\nisoVolume1Display.ScaleTransferFunction.Points = [8.614340690391311e-09, 0.0, 0.5, 0.0, 1.0, 1.0, 0.5, 0.0]\n\n# init the 'PiecewiseFunction' selected for 'OpacityTransferFunction'\nisoVolume1Display.OpacityTransferFunction.Points = [8.614340690391311e-09, 0.0, 0.5, 0.0, 1.0, 1.0, 0.5, 0.0]\n\n# hide data in view\nHide(cellDatatoPointData1, renderView1)\n\n# show color bar/color legend\nisoVolume1Display.SetScalarBarVisibility(renderView1, True)\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# Properties modified on isoVolume1\nisoVolume1.ThresholdRange = [8.614340690391311e-09, 2.0]\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# Properties modified on isoVolume1\nisoVolume1.ThresholdRange = [0.95, 2.0]\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# create a new 'Extract Surface'\nextractSurface1 = ExtractSurface(registrationName='ExtractSurface1', Input=isoVolume1)\n\n# show data in view\nextractSurface1Display = Show(extractSurface1, renderView1, 'GeometryRepresentation')\n\n# trace defaults for the display properties.\nextractSurface1Display.Representation = 'Surface'\nextractSurface1Display.ColorArrayName = ['POINTS', 'mat_den']\nextractSurface1Display.LookupTable = mat_denLUT\nextractSurface1Display.SelectTCoordArray = 'None'\nextractSurface1Display.SelectNormalArray = 'None'\nextractSurface1Display.SelectTangentArray = 'None'\nextractSurface1Display.OSPRayScaleArray = 'mat_den'\nextractSurface1Display.OSPRayScaleFunction = 'PiecewiseFunction'\nextractSurface1Display.SelectOrientationVectors = 'None'\nextractSurface1Display.ScaleFactor = 3.0\nextractSurface1Display.SelectScaleArray = 'mat_den'\nextractSurface1Display.GlyphType = 'Arrow'\nextractSurface1Display.GlyphTableIndexArray = 'mat_den'\nextractSurface1Display.GaussianRadius = 0.15\nextractSurface1Display.SetScaleArray = ['POINTS', 'mat_den']\nextractSurface1Display.ScaleTransferFunction = 'PiecewiseFunction'\nextractSurface1Display.OpacityArray = ['POINTS', 'mat_den']\nextractSurface1Display.OpacityTransferFunction = 'PiecewiseFunction'\nextractSurface1Display.DataAxesGrid = 'GridAxesRepresentation'\nextractSurface1Display.PolarAxes = 'PolarAxesRepresentation'\nextractSurface1Display.SelectInputVectors = [None, '']\nextractSurface1Display.WriteLog = ''\n\n# init the 'PiecewiseFunction' selected for 'ScaleTransferFunction'\nextractSurface1Display.ScaleTransferFunction.Points = [0.95, 0.0, 0.5, 0.0, 1.0, 1.0, 0.5, 0.0]\n\n# init the 'PiecewiseFunction' selected for 'OpacityTransferFunction'\nextractSurface1Display.OpacityTransferFunction.Points = [0.95, 0.0, 0.5, 0.0, 1.0, 1.0, 0.5, 0.0]\n\n# hide data in view\nHide(isoVolume1, renderView1)\n\n# show color bar/color legend\nextractSurface1Display.SetScalarBarVisibility(renderView1, True)\n\n# update the view to ensure updated data information\nrenderView1.Update()\n\n# save data\nSaveData('/home/enk001/Documents/PHD/PHD-Code/projects-MOOSE/moose/modules/combined/examples/optimization/3dmbb.stl', proxy=extractSurface1, PointDataArrays=['mat_den'],\n    FieldDataArrays=['Information Records', 'QA Records', 'total_vol'],\n    FileType='Ascii')\n\nWhen I run this script, I get the following output/error messages:\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.336s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5b79bdc0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.430s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c4732f0): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\n(   1.441s) [paraview        ]vtkTableBasedClipDataSe:214    ERR| vtkPVClipDataSet (0x571e5c47bb40): no input scalars.\n\nHas anyone been able to generate a Python script of the file conversion/smoothing pipeline that successfully writes a smoothed STL file (ASCII)? To be clear, when I execute the above file conversion pipeline in the Paraview GUI, I get the above error messages, but an STL file is still written successfully despite the error messages. However, using my Python script, I cannot write a smoothed STL file.",
                  "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9182069",
                  "updatedAt": "2024-04-21T23:09:13Z",
                  "publishedAt": "2024-04-21T23:06:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GregVernon"
                          },
                          "bodyText": "You may try asking over on the ParaView Discourse",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9190366",
                          "updatedAt": "2024-04-22T15:11:55Z",
                          "publishedAt": "2024-04-22T15:11:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "I don't know how to do this but keep me updated.  It would be useful.",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9190547",
                          "updatedAt": "2024-04-22T15:24:05Z",
                          "publishedAt": "2024-04-22T15:24:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "kurtenkera"
                  },
                  "bodyText": "Hi all, I am currently in the process of trying to run 2d_mbb.i, but I want to run it with this GMSH mesh file 2d_rectangle.msh attached in this zip folder (2d_rectangle.zip). Note that this is just a .msh file of the same rectangular domain as in 2d_mbb.i.\nHowever, I'm struggling to do this as I am having trouble understanding what the boundary conditions are in 2d_mbb.i? I have seen 'visualisations' of the boundary conditions in images like the one below, but in all honesty I don't know how to convert these visualisations into mathematical equations of the Dirichlet and Neumann BCs such as $u_x = 0$ for $x = 0, y \\in [0,10]$? What are the explicit BCs expressed as equations for the 2D and 3D MBB examples?\n\nHere is my attempt at interpreting the BCs for the 2D MBB example, based on the 2d_mbb.i input file. From this section of the input file:\n[Mesh]\n  [MeshGenerator]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 150\n    ny = 50\n    xmin = 0\n    xmax = 30\n    ymin = 0\n    ymax = 10\n  []\n  [node]\n    type = ExtraNodesetGenerator\n    input = MeshGenerator\n    new_boundary = pull\n    nodes = 0\n  []\n  [push]\n    type = ExtraNodesetGenerator\n    input = node\n    new_boundary = push\n    coord = '30 10 0'\n  []\n\n[]\n\nIs it true that the boundary named pull represents the bottom line of the rectangle (i.e. the bottom line characterised by $x \\in [0,30], y = 0$)? The reason I think pull represents the bottom line is because we have nodes = 0 in the [node] block, and the 0 tag represents the bottom boundary when using GeneratedMeshGenerator in 2D? Furthermore, I think the boundary push is the upper right corner of the rectangular domain, where a body force of -1N is applied in the y-direction? It appears that this downward body force is applied in the NodalKernels block below:\n[BCs]\n  [no_x]\n    type = DirichletBC\n    variable = disp_y\n    boundary = pull\n    value = 0.0\n  []\n  [no_y]\n    type = DirichletBC\n    variable = disp_x\n    boundary = right\n    value = 0.0\n  []\n\n[]\n[NodalKernels]\n  [pull]\n    type = NodalGravity\n    variable = disp_y\n    boundary = push\n    gravity_value = -1\n    mass = 1\n  []\n[]\n\nFinally, in the no_x block above, it appears that we are enforcing $u_y = 0$ along  $x \\in [0,30], y = 0$ (i.e. the pull boundary)? And in the no_y block, is it true that we are enforcing $u_x = 0$ along $y \\in [0,10], x = 30$ (i.e. the right boundary)?\nPlease let me know if my interpretation of the BCs is correct or incorrect.",
                  "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9260592",
                  "updatedAt": "2024-04-29T11:05:21Z",
                  "publishedAt": "2024-04-29T09:28:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is it true that the boundary named pull represents the bottom line of the rectangle (i.e. the bottom line characterised by\n)?\n\nno these nodesets are only a single node. You are using the node ids to select them\nUsing Paraview you can visualize these nodesets.\nYou can use the other generators to generate nodesets, and sidesets (and nodesets from sidesets)\nsomething like \"a line\" or \"a plane at the bottom / on the left\" is easy to specify from the normal or from a parsed expression based on the coordinates",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9263638",
                          "updatedAt": "2024-04-29T14:30:37Z",
                          "publishedAt": "2024-04-29T14:30:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Finally, in the no_x block above, it appears that we are enforcing. ...\n\nI think pull is only a single node on which we are pulling.",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9263727",
                          "updatedAt": "2024-04-29T14:37:45Z",
                          "publishedAt": "2024-04-29T14:37:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "This model doesn't match exactly with the picture.  This model uses half symmetry with the symmetry plane where disp_x=0 is set on the \"right\" nodeset.  The roller displacement boundary condition where disp_y=0 is set on the single node in the \"pull\" nodeset on the bottom left corner of the model.  We didn't use very good names in this example for nodesets or the nodal kernel block.  This input file is similar to the one we made for the \"hanger\" example where a force is applied to the \"pull\" node.",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9265694",
                          "updatedAt": "2024-04-29T16:51:31Z",
                          "publishedAt": "2024-04-29T16:51:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "kurtenkera"
                          },
                          "bodyText": "Thanks for the replies guys that has helped with my understanding tremendously.\nAs for 3d_mbb.i, I can see that the roller boundary condition is applied at the two nodes (0,0,0) and (0,0,10) in a similar manner to the 2d example. Likewise, the push downward force is applied in a similar manner. The main difference appears to be the inclusion of the ADRobinBC boundary condition (see below):\n[BCs]\n  [no_x]\n    type = DirichletBC\n    variable = disp_y\n    boundary = hold_y\n    value = 0.0\n  []\n  [no_y]\n    type = DirichletBC\n    variable = disp_x\n    boundary = right\n    value = 0.0\n  []\n  [boundary_penalty]\n    type = ADRobinBC\n    variable = Dc\n    boundary = 'left top front back'\n    coefficient = 10\n  []\n  [boundary_penalty_right]\n    type = ADRobinBC\n    variable = Dc\n    boundary = 'right'\n    coefficient = 10\n  []\n[]\n\nI understand the mathematical definition of the ADRobinBC provided below, but I don't know (1) what it represents physically and (2) why it wasn't included in the 2d_mbb.i example?\n\nMoreover, (3) why does the line enable_objects = 'BCs::boundary_penalty_right' appear in the input file, but there is no analogous line enable_objects = 'BCs::boundary_penalty' for the left, top, front and back faces? Finally, (4) why does the bottom face not have an ADRobinBC condition applied to it but all other faces do?\n[Controls]\n  [first_period]\n    type = TimePeriod\n    start_time = 0.0\n    end_time = 10\n    enable_objects = 'BCs::boundary_penalty_right'\n    execute_on = 'initial timestep_begin'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9269963",
                          "updatedAt": "2024-04-30T04:02:27Z",
                          "publishedAt": "2024-04-30T04:02:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "The RobinBC is for the filter. It allows us to penalize having excessive material on the boundary which happens with the radial filter. This is for the PDE filter. I believe we have a tutorial that talks about this a bit. It is user preference on which faces one would like to prevent excessive material on. Here is a link to a paper that gives more information: https://doi.org/10.1007/s00158-020-02556-w",
                          "url": "https://github.com/idaholab/moose/discussions/25508#discussioncomment-9274335",
                          "updatedAt": "2024-04-30T11:32:44Z",
                          "publishedAt": "2024-04-30T11:32:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about the Heat Source Kernel",
          "author": {
            "login": "CadenWil"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi,\nI am attempting to recreate a problem in The Fundamentals of Heat and Mass Transfer 6th Edition using Moose so that I can understand the uses of the HeatSource kernel and the SideSetHeatTransferKernel.\nIn this problem a silicon wafer is attached to an aluminum block with epoxy. The wafer is generating heat which is being removed by convection with air.\nMy hope is to use the SideSetHeatTransferKernel to represent the thin epoxy gap that creates a thermal contact resistance.\nI plan to use the HeatSource kernel to act as volumetric heating of the silicon wafer.\nI've run into two issues.  The first one is that I'm not sure how the HeatSource kernels \"value\" variable works.\nAt first I thought its units are power/volume (W/m^3).  I set up the problem accordingly. This didn't work as when I increase the volume of my cube by increasing the Z direction the temperature of the answer doesn't change.\nIf I replace the [Mesh] block of this input:\n[Mesh]\n  [generated]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 100\n    ny = 100\n    nz = 10\n    xmin = 0\n    xmax = 0.01\n    ymin = 0\n    ymax = 0.01\n    zmin = 0\n    zmax = 0.02\n  []\n  [block1]\n    type = SubdomainBoundingBoxGenerator\n    input = generated\n    block_id = 1\n    bottom_left = '0 0 0'\n    top_right = '0.01 0.008 0.02'\n  []\n  [block2]\n    type = SubdomainBoundingBoxGenerator\n    input = block1\n    block_id = 2\n    bottom_left = '0.0 0.008 0'\n    top_right = '0.01 0.01 0.02'\n  []\n  [interface]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = block2\n    primary_block = 1\n    paired_block = 2\n    new_boundary = 'interface1'\n  []\n[]\n\n[Variables]\n  [T]\n    initial_condition = 298.15\n  []\n[]\n\n[Kernels]\n  [heat_conduction]\n    type = HeatConduction\n    variable = T\n  []\n  [time_derivative]\n    type = HeatConductionTimeDerivative\n    variable = T\n  []\n  [heat_source]\n    type = HeatSource\n    variable = T\n    value = 5000000\n    block = 2\n  []\n[]\n\n[Materials]\n  [thermal_alum]\n    type = HeatConductionMaterial\n    thermal_conductivity = 239\n    specific_heat = 0.9\n    block = 1\n  []\n  [density_alum]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = 2.7\n    block = 1\n  []\n\n  [thermal_sil]\n    type = HeatConductionMaterial\n    thermal_conductivity = 149\n    specific_heat = 0.7\n    block = 2\n  []\n  [density_sil]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = 2.33\n    block = 2\n  []\n[]\n\n[BCs]\n  [convect_top]\n    type = ConvectiveHeatFluxBC\n    variable = T\n    boundary = 'top'\n    T_infinity = 298.15\n    heat_transfer_coefficient = 100\n  []\n  [convect_bottom]\n    type = ConvectiveHeatFluxBC\n    variable = T\n    boundary = 'bottom'\n    T_infinity = 298.15\n    heat_transfer_coefficient = 100\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1e-3\n    optimal_iterations = 6\n  []\n  end_time = 5000\n\n  nl_abs_tol = 1e-9\n  nl_max_its = 50\n  line_search = 'none'\n\n  automatic_scaling = true\n  off_diagonals_in_auto_scaling = true\n  compute_scaling_once = false\n[]\n\n[Outputs]\n  exodus = true\n[]\n\"\"\"\nwith this:\n''''\n[Mesh]\n  [generated]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 100\n    ny = 100\n    nz = 10\n    xmin = 0\n    xmax = 0.01\n    ymin = 0\n    ymax = 0.01\n    zmin = 0\n    zmax = 0.002\n  []\n  [block1]\n    type = SubdomainBoundingBoxGenerator\n    input = generated\n    block_id = 1\n    bottom_left = '0 0 0'\n    top_right = '0.01 0.008 0.002'\n  []\n  [block2]\n    type = SubdomainBoundingBoxGenerator\n    input = block1\n    block_id = 2\n    bottom_left = '0.0 0.008 0'\n    top_right = '0.01 0.01 0.002'\n  []\n  [interface]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = block2\n    primary_block = 1\n    paired_block = 2\n    new_boundary = 'interface1'\n  []\n[]\n\nBoth will give me the same answer for the top and bottom temperatures.  What is the HeatSource kernel doing and how do I determine its value?\nThanks for any assistance you can offer.",
          "url": "https://github.com/idaholab/moose/discussions/29860",
          "updatedAt": "2025-02-11T21:44:05Z",
          "publishedAt": "2025-02-11T20:27:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nAt first I thought its units are power/volume (W/m^3). I set up the problem accordingly. This didn't work as when I increase the volume of my cube by increasing the Z direction the temperature of the answer doesn't change.\n\nit should be a power density, in that unit.\n\nthe answer doesn't change.\n\nyou can probably derive the analytical solution here. Should it change? You have two flux BCs on the side. I would definitely expect the answer to change with dirichlet BCs in top/bottom.\nBut with flux in 1D you are solving (roughly)\n-Dd2Tdz2 + q = 0\n\nwith T = az2 + bz + c\nthat gives:\na = - q/ D (so independent of z)\nthen by symmetry, b = 0\nthen the flux equations are\ndT/dz(0) = h ( T(0) - 297)\ndT/dz(L) = h ( T(L) - 297)\n\nso  first the first one\nD b = h (c-297)\n\nso c = 297",
                  "url": "https://github.com/idaholab/moose/discussions/29860#discussioncomment-12152034",
                  "updatedAt": "2025-02-11T20:45:07Z",
                  "publishedAt": "2025-02-11T20:38:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "dont rely on my math I did this very quickly. You should redo this",
                          "url": "https://github.com/idaholab/moose/discussions/29860#discussioncomment-12152035",
                          "updatedAt": "2025-02-11T20:39:12Z",
                          "publishedAt": "2025-02-11T20:39:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "CadenWil"
                          },
                          "bodyText": "I was using the 1D resistance calculations found in the book.\nI think my issue is in how I went about this.  I was given a heat flux of 10,000 W/m^2.  I tried to turn that into a W/m^3 by multiplying the flux by 1/z where z is the length of my cube in the z direction.\nThis would cause my volumetric heat source to increase or decrease depending of the length of z which I think is wrong entirely.  So I've got to figure out a way to calculate a volumetric heat source from a heat flux.",
                          "url": "https://github.com/idaholab/moose/discussions/29860#discussioncomment-12152100",
                          "updatedAt": "2025-02-11T20:47:21Z",
                          "publishedAt": "2025-02-11T20:47:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "CadenWil"
                          },
                          "bodyText": "Interestingly if I change the thickness of my wafer in the y direction the temperatures do change.",
                          "url": "https://github.com/idaholab/moose/discussions/29860#discussioncomment-12152146",
                          "updatedAt": "2025-02-11T20:55:01Z",
                          "publishedAt": "2025-02-11T20:54:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Increase in stiffness over time",
          "author": {
            "login": "jmeier"
          },
          "bodyText": "Dear Moose Community,\nConcrete will increase its stiffness over time (and increase in strength, and shrink a little). Ignoring strength and shrinking, I'd like to model this increase in stiffness in a very simplified way just by increasing the Young's modulus of a linear-elastic material over time (using Executioner/Transient, SolidMechanics/QuasiStatic/strain = SMALL, SolidMechanics/QuasiStatic/incremental = true).\nIf I model a purely linear-elastic block under constant loading and increase the Young's modulus over time, the stresses will remain constant and the material will expand. Fixing the boundaries of this block and increasing the Young's modulus would increase the stress within the block. Both options seem not suitable to model the stiffness increase of concrete.\nWhat is the best way to model this? Do I also have to apply a negative volumetric strain? If yes, how? Are there other options?\nThanks & kind regards,\nJ\u00f6rg",
          "url": "https://github.com/idaholab/moose/discussions/29808",
          "updatedAt": "2025-02-11T15:32:11Z",
          "publishedAt": "2025-02-04T07:49:20Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc",
                  "url": "https://github.com/idaholab/moose/discussions/29808#discussioncomment-12061444",
                  "updatedAt": "2025-02-05T01:18:05Z",
                  "publishedAt": "2025-02-05T01:18:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Hmm, this is tricky! It seems like what you want is to keep the stresses that have been incurred under prior loading constant, and then have the increased stiffness only affect additional incremental strains. I assume you're using ComputeFiniteStrainElasticStress. It currently computes the stress like this:\n   intermediate_stress =\n        elasticity_tensor_rotated * (_elastic_strain_old[_qp] + _strain_increment[_qp]);\n\nYou probably want something more like this:\n   intermediate_stress =\n        _stress_old[_qp] + elasticity_tensor_rotated * _strain_increment[_qp];\n\nMaybe try this and see if that does what you want. I'm not really sure what the right way to do this is in general, but maybe we should consider doing something like that.",
                          "url": "https://github.com/idaholab/moose/discussions/29808#discussioncomment-12076388",
                          "updatedAt": "2025-02-06T01:51:21Z",
                          "publishedAt": "2025-02-06T01:51:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Ben, Thanks for your answer! Yes, I'm using ComputeFiniteStrainElasticStress. I will try your suggestion.\nIn the meantime: Is there a way to apply change of (plastic) strain in Moose for a Material (e.g. introduce a user-given plastic strain increments)?",
                          "url": "https://github.com/idaholab/moose/discussions/29808#discussioncomment-12078266",
                          "updatedAt": "2025-02-06T07:16:28Z",
                          "publishedAt": "2025-02-06T07:14:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "@jmeier I was thinking about this some more, and we actually do just what I proposed in some cases for inelastic models. This code is in ComputeMultipleInelasticStress:\n     if (_is_elasticity_tensor_guaranteed_isotropic || !_perform_finite_strain_rotations)\n        _stress[_qp] =\n            _elasticity_tensor[_qp] * (_elastic_strain_old[_qp] + elastic_strain_increment);\n      else\n      {\n        if (_damage_model)\n          _stress[_qp] = _undamaged_stress_old + _elasticity_tensor[_qp] * elastic_strain_increment;\n        else\n          _stress[_qp] = _stress_old[_qp] + _elasticity_tensor[_qp] * elastic_strain_increment;\n      }\n\nThe last block is the one that applies an increment to the old stress, which only happens if the elasticity tensor is not isotropic. If I remember correctly, we do that because we do not rotate the elasticity tensor. You can actually run this model on elastic problems by supplying an empty list of inelastic models (i.e., inelastic_models = \"\"), but you'd get the same thing as you're getting now if you're using isotropic elasticity.\nRegarding your second question: Probably the easiest way to do what you are asking is to have a user-defined eigenstrain model. You can set any of the components of the strain tensor that is used as an eigenstrain any way you like. That eigenstrain tensor is subtracted from the total strain before the stress calculation.",
                          "url": "https://github.com/idaholab/moose/discussions/29808#discussioncomment-12083572",
                          "updatedAt": "2025-02-06T15:37:06Z",
                          "publishedAt": "2025-02-06T15:37:04Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Ben, thank you so much! This looks very good. I'm going to use ComputeMultipleInelasticStress and probably have a look at a user-defined eigenstrain model later.",
                          "url": "https://github.com/idaholab/moose/discussions/29808#discussioncomment-12145285",
                          "updatedAt": "2025-02-11T15:32:10Z",
                          "publishedAt": "2025-02-11T15:32:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Singular values using custom ADKernels",
          "author": {
            "login": "atarias1"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello, I am posting because I have been trying to implement some custom ADKernels to later expand to solve some problems I am interested in. But currently my system cannot be solved and it is reporting singular values when applying SVD.\nHere is a link to the application:\nhttps://github.com/atarias1/creep.git\nThere are 2 custom AD kernels: one for stress divergence and one for velocity divergence.\nThere is 1 custom material: right now it just assigns a viscosity of 1.\nI thought originally that I had forgotten a boundary condition, but I think what I have provided is sufficient.\nI appreciate any help to solving this problem!\nThanks,\nAustin\nI will also show the input file here for reference.\n  type = GeneratedMesh\n  dim = 2\n  nx = 10\n  ny = 10\n  nz = 0\n\n  xmax = 20\n  ymax = 20\n  zmax = 0\n  elem_type = QUAD4\n  second_order = true\n[]\n\n[Variables]\n  [V_x]\n    order = SECOND\n    family = LAGRANGE\n  []\n\n  [V_y]\n    order = SECOND\n    family = LAGRANGE\n  []\n\n  [P_tot]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[ICs]\n  [V_x]\n    type = ConstantIC\n    value = 0.0\n    variable = V_x\n  []\n\n  [V_y]\n    type = ConstantIC\n    value = 0.0\n    variable = V_y\n  []\n\n  [P_tot]\n    type = ConstantIC\n    value = 1\n    variable = P_tot\n  []\n[]\n\n[BCs]\n  active = 'bottom_V_x bottom_V_y top_V_x top_V_y bottom_P top_P'\n  [bottom_V_y]\n    type = ADDirichletBC\n    boundary = 'bottom'\n    value = 0\n    variable = V_y\n  []\n\n  [bottom_V_x]\n    type = ADDirichletBC\n    boundary = 'bottom'\n    value = 0\n    variable = V_x\n  []\n\n  [top_V_y]\n    type = ADDirichletBC\n    boundary = 'top'\n    value = 0\n    variable = V_y\n  []\n\n  [top_V_x]\n    type = ADDirichletBC\n    boundary = 'top'\n    value = 1\n    variable = V_x\n  []\n\n  [bottom_P]\n    type = ADNeumannBC\n    boundary = 'bottom'\n    variable = P_tot\n    value = 0\n  []\n\n  [top_P]\n    type = ADNeumannBC\n    boundary = 'top'\n    variable = P_tot\n    value = 0\n  []\n\n  [Periodic]\n    # active = 'x_V_x x_V_y x_P'\n    [x_V_x]\n      variable = V_x\n      primary = 'left'\n      secondary = 'right'\n      translation = '20 0 0'\n    []\n    [x_V_y]\n      variable = V_y\n      primary = 'left'\n      secondary = 'right'\n      translation = '20 0 0'\n    []\n\n    [x_P]\n      variable = P_tot\n      primary = 'left'\n      secondary = 'right'\n      translation = '20 0 0'\n    []\n  []\n[]\n\n[Materials]\n  [Serpentinite]\n    type = Serpentinite\n  []\n[]\n\n[Kernels]\n  [div_stress_x]\n    type = ViscousStress2D\n    P_tot = P_tot\n    V_x_s = V_x\n    V_y_s = V_y\n    component = 0\n    variable = V_x\n  []\n\n  [div_stress_y]\n    type = ViscousStress2D\n    P_tot = P_tot\n    V_x_s = V_x\n    V_y_s = V_y\n    component = 1\n    variable = V_y\n  []\n\n  [pressure]\n    type = VelocityDiv2D\n    V_x_s = V_x\n    V_y_s = V_y\n    variable = P_tot\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'svd'\n  end_time = 1\n  dt = 1\n  automatic_scaling = true\n  petsc_options = '-pc_svd_monitor'\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = true\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/29854",
          "updatedAt": "2025-02-11T11:18:41Z",
          "publishedAt": "2025-02-10T21:41:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nare you sure the problem is not ill-posed as it is?\nIs this an advection problem?  What is the inlet and the outlet? Top and bottom? Is setting the pressure on both normal? That does not seem right while also setting velocities?",
                  "url": "https://github.com/idaholab/moose/discussions/29854#discussioncomment-12130776",
                  "updatedAt": "2025-02-11T16:26:20Z",
                  "publishedAt": "2025-02-10T23:51:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "atarias1"
                          },
                          "bodyText": "Hi thanks for the reply.\nYeah I think the problem set-up was sloppy.\nI was intending to test a simple Couette flow with a pressure gradient to later advect some other variables.\nI removed the pressure and restructured my viscous stress divergence kernel and now I get the correct steady state solution using just velocity BCs. I will work from here to include other variables.  Mostly I just needed a sanity check to ensure I didn't need to include custom boundary conditions with custom kernels, and wanted to make sure that my component wise formulations were correct. But it all seems to work now.\nThanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/29854#discussioncomment-12139350",
                          "updatedAt": "2025-02-11T11:18:34Z",
                          "publishedAt": "2025-02-11T11:18:33Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can 'FilePositions' type in 'Positions' block work with the 'PointValueSampler' type in 'VectorPostProcessors' block?",
          "author": {
            "login": "caolwec"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nWish to specify a long list of position coordinates in an external text file when using 'PointValueSampler' VectorPostProcessors.",
          "url": "https://github.com/idaholab/moose/discussions/29851",
          "updatedAt": "2025-02-10T18:41:42Z",
          "publishedAt": "2025-02-10T16:15:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo, it does not. It works with this VPP, which can handle any functor (includes variables, functions, functor matprops, postprocessors for now)\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/PositionsFunctorValueSampler.html",
                  "url": "https://github.com/idaholab/moose/discussions/29851#discussioncomment-12123069",
                  "updatedAt": "2025-02-10T16:34:02Z",
                  "publishedAt": "2025-02-10T16:33:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "caolwec"
                  },
                  "bodyText": "Thanks! It seems to work using the 'PostionsFunctorValueSample' \ud83d\udc4d",
                  "url": "https://github.com/idaholab/moose/discussions/29851#discussioncomment-12125854",
                  "updatedAt": "2025-02-10T18:41:42Z",
                  "publishedAt": "2025-02-10T18:41:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}