{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNC0yMVQwODo0MTo1Mi0wNjowMM4AMtG5"
    },
    "edges": [
      {
        "node": {
          "title": "History variables in a kernel",
          "author": {
            "login": "etauq"
          },
          "bodyText": "Hi,\nI was wondering if we can require history variables in a kernel. If possible, how can we do that?\nThanks,\nJack",
          "url": "https://github.com/idaholab/moose/discussions/17644",
          "updatedAt": "2023-06-29T08:46:06Z",
          "publishedAt": "2021-04-19T18:49:29Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "If you want your kernel to couple old solutions of variables in a transient calculation, you can add implicit = false in the kernel parameters in the input.",
                  "url": "https://github.com/idaholab/moose/discussions/17644#discussioncomment-631854",
                  "updatedAt": "2023-06-29T08:46:06Z",
                  "publishedAt": "2021-04-19T19:15:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "If you want to access old solution in additional to the current solution, you can use coupledValueOld(var_name)",
                  "url": "https://github.com/idaholab/moose/discussions/17644#discussioncomment-650716",
                  "updatedAt": "2023-06-29T08:46:20Z",
                  "publishedAt": "2021-04-23T16:07:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some problems in crytatl.i material module, regarding crystal plasticity",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nIn order to complete the #17577  job, I have some doubts about the elastic modulus and crystal plastic constitutive part of the material in crystal.i. I hope to get your guidance.\nAccording to my understanding, FiniteStrainCrystalPlasticityis responsible for the constitutive part of crystal plasticity,in the materials module of crystal.i.\nAnd ComputeElasticityTensorCP is responsible for inputting Euler angles and rotation matrix to the FiniteStrainCrystalPlasticity sub-module. I have the following questions and hope to get your answers,\nFirst, does FiniteStrainCrystalPlasticity only need to input _elasticity_tensor and ComputeElasticityTensorCP from ComputeElasticityTensorCP at initial time? and these two variables are already included in the MaterialProperty variable at timestep_begin, I don\u2019t know if my understanding is correct?\nSecond, the material rotation annotated in MaterialProperty<RankTwoTensor>&_update_rot refers to the rotation caused by the entire material deformation process during the loading process, that is,\n\nrot = get_current_rotation(_deformation_gradient[_qp]); // Calculate material rotation\n_update_rot[_qp] = rot * _crysrot[_qp];\n\nThe crystal orientation refers to the rotation tensor, _crysrot, calculated after the material initially gives the crystal grain Euler angles. If my understanding is wrong, please give me more guidance.\nAny suggestions or recommendations would be greatly appreciated.\nThank you\nWei Peng",
          "url": "https://github.com/idaholab/moose/discussions/17592",
          "updatedAt": "2022-06-06T12:17:29Z",
          "publishedAt": "2021-04-13T14:39:10Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "PengWei97"
                  },
                  "bodyText": "@jiangwen84\uff0cCould you give me some guidance?",
                  "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-610145",
                  "updatedAt": "2022-06-06T12:17:32Z",
                  "publishedAt": "2021-04-14T13:53:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Dear MOOSE experts,\nIn order to complete the #17577 job, I have some doubts about the elastic modulus and crystal plastic constitutive part of the material in crystal.i. I hope to get your guidance.\nAccording to my understanding, FiniteStrainCrystalPlasticityis responsible for the constitutive part of crystal plasticity,in the materials module of crystal.i.\nAnd ComputeElasticityTensorCP is responsible for inputting Euler angles and rotation matrix to the FiniteStrainCrystalPlasticity sub-module. I have the following questions and hope to get your answers,\nFirst, does FiniteStrainCrystalPlasticity only need to input _elasticity_tensor and ComputeElasticityTensorCP from ComputeElasticityTensorCP at initial time? and these two variables are already included in the MaterialProperty variable at timestep_begin, I don\u2019t know if my understanding is correct?\n\n_elasticity_tensor is initial rotated elasticity tensor. If the Euler angles do not change, its value remains the same during  every linear residual calculation.\n\nSecond, the material rotation annotated in MaterialProperty<RankTwoTensor>&_update_rot refers to the rotation caused by the entire material deformation process during the loading process, that is,\n\nrot = get_current_rotation(_deformation_gradient[_qp]); // Calculate material rotation\n_update_rot[_qp] = rot * _crysrot[_qp];\n\nThe crystal orientation refers to the rotation tensor, _crysrot, calculated after the material initially gives the crystal grain Euler angles. If my understanding is wrong, please give me more guidance.\n\n_crysrot is the initial grain orientation. The rot is the incremental rotation due to deformation.\n\nAny suggestions or recommendations would be greatly appreciated.\nThank you\nWei Peng",
                  "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-611722",
                  "updatedAt": "2022-06-06T12:17:32Z",
                  "publishedAt": "2021-04-14T19:32:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you very much @jiangwen84  for your patient reply.\nAccording to my understanding, ComputeElasticityTensorCP is responsible for outputting the elasticity modulus after rotation, namely _elasticity_tensor .\nAnd the rotation matrix, namely _crysrot ,  for update slip direction and normal with crystal orientation.\nIs this correct?\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-615934",
                          "updatedAt": "2022-06-29T07:43:29Z",
                          "publishedAt": "2021-04-15T14:41:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Thank you very much @jiangwen84 for your patient reply.\nAccording to my understanding, ComputeElasticityTensorCP is responsible for outputting the elasticity modulus after rotation, namely _elasticity_tensor .\n\nComputeElasticityTensorCP calculates the elasticity tensor _elasticity_tensor based on grain orientation (Euler angles). The _elasticity_tensor will be used in CrystalPlasticity Stress Calculation to compute the stress at intermediate configuration. You can also visualize the component of _elasticity_tensor using a AuxVariable.\n\nAnd the rotation matrix, namely _crysrot , for update slip direction and normal with crystal orientation.\n\n_crysrot is basically the rotation matrix for grain orientation. It is used to rotate the slip system. The rotation due to deformation is calculated by _update_rotation.\n\nIs this correct?\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-616155",
                          "updatedAt": "2022-06-29T07:43:34Z",
                          "publishedAt": "2021-04-15T15:19:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you @jiangwen84  very much for your guidance. I have understood the role of two material parameters.\nPlease forgive me for repeatedly determining whether my understanding is correct, because I need to develop a model that couples crystal plasticity and phase field to study the mechanical field, especially the influence of plasticity on the behavior of grain growth. So I need to confirm that only two MaterialPropertys in ComputeElasticityTensorCP: _elasticity_tensor and _crysrot are output as the input parameters of FiniteStrainCrystalPlasticity.\nBased on the existing coupling model of moose, it is the corresponding coupled linear elastic force field, and the file is bicrystal.i. The current thinking about crystal plasticity and phase-field coupled simulation is to replace the method of Element property read user object in ComputeElasticityTensorCP with GrainDataTracker to assign elastic modulus and Euler angles. I wonder if it is reasonable? I hope you can give me some suggestions.\nThanks for the help,\nBest,\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-621052",
                          "updatedAt": "2022-06-29T07:43:35Z",
                          "publishedAt": "2021-04-16T15:28:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "hi @jiangwen84\uff0c\nThank you very much for your careful guidance. Through reading the tensor module on the moose official website, I understand that the module that calculates the elastic tensor needs to output two material parameters: elastic modulus and rotation matrix.\nFinally, if you have any suggestions for issue #17577, your guidance is welcome.\nBest,\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-648564",
                          "updatedAt": "2023-03-06T14:00:24Z",
                          "publishedAt": "2021-04-23T08:33:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Develop a coupled model of grain plasticity and phase field grain growth",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nI am trying to couple crystal plasticity and phase field to simulate grain growth. I read modules\\combined\\test\\tests\\ACGrGrElasticDrivingForce\\bicrystal.i and modules\\tensor_mechanics\\test\\tests\\cp_user_object\\crysp.i carefully. And I also read the Elastic Driving Force for Grain Growth webpage.\n\nIn the model where the linear elastic force field and the phase field are coupled, bicrystal.i, Kernels\\PolycrystalElasticDrivingForce acts as a bridge.\nInput the elastic_strain calculated in the Materials\\stress submodule and the D_elastic_tensor calculated in the Materials\\elasticity_tensor submodule.\nIn ACGrGrElasticDrivingForce kernels, it is used to calculate the deformation energy part of the Allen-Cahn equation because of the elastic driving force.\n\nMoreover, I also tried to change the strain calculation type in the Materials module from ComputeSmallStrain to ComputeFiniteStrain, and the stress calculation type from ComputeLinearElasticStress to ComputeFiniteStrainElasticStress, and the verification is feasible.\nThe comparison found that if I want to complete this work, I think it is mainly to modify the Materials\\elasticity_tensor part, and I need to refer to ComputeElasticityTensorCP in crystal.i to modify ComputePolycrystalElasticityTensor in bicrystal.i. I think it is necessary to add the rotation matrix srysrot_ij in ComputePolycrystalElasticityTensor. I don\u2019t know if my understanding is correct?\nFinally, when only considering the elastic energy, if I want to complete the establishment of the crystal plasticity and phase-field coupled grain growth model, What else do I need to consider?\nAny suggestions or recommendations would be greatly appreciated.\nThank you\nWei Peng",
          "url": "https://github.com/idaholab/moose/discussions/17577",
          "updatedAt": "2022-06-29T18:26:10Z",
          "publishedAt": "2021-04-12T09:14:35Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "PengWei97"
                  },
                  "bodyText": "Hi everyone,\nThe first idea to develop this paradigm was to write another UserObjects named GrainTrackerRotation, used to input the rotation matrix, similar to GrainTrackerElasticity used to output the elastic modulus after rotation.\nBased on this, two major modifications have been made,\nFirst, create a UserObjects named GrainTrackerRotation to output the rotation matrix.\nSecond, modify the ComputeElasticityTensorCP to become ComputePolyElasticityTensorCP, which is used to accept the elastic modulus after the rotation in the UserObjects module and the rotation matrix derived from the known Euler angle.\nAfter compiling the application I created, there are no bugs.\nBut in the debugging stage, using the modified bicrystal_2.i as input, the terminal displays the bug as follows,\nAssertion `grain_id <_grain_data.size()' failed\nRequested data for invalid grain index.\nat /home/xia/projects/moose/modules/phase_field/build/header_symlinks/GrainDataTracker.h, line 46\nI don't know what stupid I did that caused such a problem. Could anyone answer me in this regard?\nAny suggestions or recommendations would be greatly appreciated.\nThank you\nWei Peng",
                  "url": "https://github.com/idaholab/moose/discussions/17577#discussioncomment-648547",
                  "updatedAt": "2022-06-29T18:26:10Z",
                  "publishedAt": "2021-04-23T08:29:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The problem of grain size distribution curve in grain growth",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nI'm very sorry to ask you such a rudimentary question here, but this question has really bothered me for a long time.\nI\u2019m not sure how the frequency provided in the discussion #17422 is defined? The area enclosed by the grain size distribution curve and the x-axis represents the frequency (after extracting the data of Yadav 2016, I calculated that the area is about 1),\n\nor the y-axis itself is the frequency (frequency = Number of grains in a certain interval after the normalized grain radius/Total number of crystal grains).\nMoreover, I used moose to simulate a grain growth with 6400 initial grains. And using the first frequency calculation method I think, the following curve is obtained, which is very different from the theoretical Hillert grain size distribution curve. So I don't know if the number of initial grains is too small, or the calculated y-axis, that is, the frequency is not calculated as I think.\n\nAny suggestions or recommendations to fix these problems would be greatly appreciated.\nThank you\nWei Peng",
          "url": "https://github.com/idaholab/moose/discussions/17663",
          "updatedAt": "2022-09-22T09:18:01Z",
          "publishedAt": "2021-04-22T15:22:39Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "PengWei97"
                  },
                  "bodyText": "@ykvishal\uff0cCould you give me some guidance?",
                  "url": "https://github.com/idaholab/moose/discussions/17663#discussioncomment-648146",
                  "updatedAt": "2022-09-22T09:18:10Z",
                  "publishedAt": "2021-04-23T06:33:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "strain-based plasticity models",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hi everyone,\nI'm considering implementing some strain-based plasticity models, and i'm wondering whether anyone has done this in MOOSE already, or even toyed with the idea.\nMy reason for doing this is to more easily/accurately capture post-yield behaviour for rocks.  When rocks fail (Mohr-Coulomb plasticity is often used) and further deform, their mechanics is quite different from the pre-yield elastic behaviour.  Eg, consider pulling apart a rock via a tensile stress: after failure the rock has fractured so essentially has \"zero Young's modulus\" (this may not be really true, because tension in an orthogonal direction will encounter competent rock), but then upon recompaction to its original state, the Young's modulus will assume its original value, since the fracture will have \"squashed back\" to nothing.  This mechanics may be captured with softening and hardening of the plastic strengths, but that ends up being computationally quite challenging.\nSo, i'm toying with strain-based plasticity.   Any comments?\nExample article:\nhttps://doi.org/10.1016/S0045-7825(96)01245-5",
          "url": "https://github.com/idaholab/moose/discussions/17666",
          "updatedAt": "2022-06-13T08:30:53Z",
          "publishedAt": "2021-04-22T22:41:24Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "So first possibly dumb question I have: what you described is pretty much just softening plasticity. How does \"strain-based\" factor in here?",
                  "url": "https://github.com/idaholab/moose/discussions/17666#discussioncomment-647738",
                  "updatedAt": "2022-06-13T08:30:53Z",
                  "publishedAt": "2021-04-23T02:59:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "So after reading the abstract of that article, it sounds like strain-based and stress-based plasticity are equally valid choices, but one may be more convenient than the other in certain cases. Correct me if I'm wrong.\nSo is your focus here \"strain space plasticity\" or \"softening plasticity\"? Even if you want both in the end, it may be easier to pursue one of them first, than the other one.\nI don't know how hard \"strain-space plasticity\", but I guess all it needs is a different set of material models in moose. Maybe the return mapping is done on strain?\n\"Softening plasticity\" is trickier, as you may need fixed point iteration to obtain a solution post yielding.",
                          "url": "https://github.com/idaholab/moose/discussions/17666#discussioncomment-647768",
                          "updatedAt": "2022-06-13T08:31:00Z",
                          "publishedAt": "2021-04-23T03:09:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "You're right - i believe that strain-based might be more convenient in my case.  This is just an intuition at the moment, as i haven't tried anything.\nI'm not really interested in softening.  I use it a lot, and find it's too computationally expensive, even if it appears to capture reality somewhat realistically in some cases.\nI'm not sure whether i'm going to pursue this strain-based-plasticity work.  At the moment i'm just wondering if anyone has done stuff in MOOSE (or otherwise) using it.",
                          "url": "https://github.com/idaholab/moose/discussions/17666#discussioncomment-647777",
                          "updatedAt": "2022-06-13T08:31:03Z",
                          "publishedAt": "2021-04-23T03:14:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "breaking (fracturing) elements or breaking meshes (DEM-FEM)",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hi everyone,\nIn some solid-mechanics simulations, such as the tensile failure of materials due to fracture creation, breaking the finite-element mesh along element edges, or breaking individual elements into multiple pieces, might be an appropriate modelling strategy.   Has anyone done this using MOOSE?   I'm hoping you'll say \"yes - this is fully developed in module XXXX, didn't you know?!\".\nNot only does the underlying finite-element package (libmesh) have to be flexible enough to break elements, but the problem becomes numerically complicated, as contact-detection between broken surfaces bogs the code down (you don't want those freshly-created surfaces just passing through each other!).\nAn example of a commercial package that does this: https://www.geomechanica.com/software\na",
          "url": "https://github.com/idaholab/moose/discussions/17667",
          "updatedAt": "2022-09-20T12:58:15Z",
          "publishedAt": "2021-04-22T22:51:05Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "yes - this is fully developed in module Xfem, didn't you know?!",
                  "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647263",
                  "updatedAt": "2022-09-20T12:58:31Z",
                  "publishedAt": "2021-04-22T22:54:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "OMG, you aren't kidding!   I'm so happy.  Now lots of reading for me.",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647290",
                          "updatedAt": "2022-09-20T12:58:31Z",
                          "publishedAt": "2021-04-22T23:09:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "FYI, @bwspenc and @jiangwen84 are the main points of contact for the XFEM module.",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647303",
                          "updatedAt": "2022-09-20T12:58:31Z",
                          "publishedAt": "2021-04-22T23:14:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Hi @WilkAndy @hugary1995\nSince you guys are on this topic, I want to do a mine simulation that has faults in it.\nMy supervisor suggested using 'Cohesive Zone'  https://mooseframework.inl.gov/syntax/Modules/TensorMechanics/CohesiveZoneMaster/index.html\nwhen I see that it does not support the 'Large strain' model, is there any way to work around this problem?\nThank you!\nTraiwit",
                  "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647360",
                  "updatedAt": "2022-09-20T12:58:38Z",
                  "publishedAt": "2021-04-22T23:49:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@Traiwit here is the PR for large deformation CZM.\n#17157",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647383",
                          "updatedAt": "2022-09-20T12:58:51Z",
                          "publishedAt": "2021-04-23T00:00:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Nice! Thank you @jiangwen84",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647475",
                          "updatedAt": "2022-09-20T12:58:53Z",
                          "publishedAt": "2021-04-23T00:51:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "When using XFEM to pull apart a material, everything works fine.  But upon recompaction, the fracture surfaces don't \"push back\" against each other.  Is this correct, or am i driving XFEM incorrectly?",
                  "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647414",
                  "updatedAt": "2022-09-20T12:59:06Z",
                  "publishedAt": "2021-04-23T00:18:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "When using XFEM to pull apart a material, everything works fine. But upon recompaction, the fracture surfaces don't \"push back\" against each other. Is this correct, or am i driving XFEM incorrectly?\n\nYou  can implement a contact constrain on the fracture surfaces.",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647441",
                          "updatedAt": "2022-10-13T18:04:56Z",
                          "publishedAt": "2021-04-23T00:35:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Where is there an example of this?",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647457",
                          "updatedAt": "2022-10-13T18:04:56Z",
                          "publishedAt": "2021-04-23T00:43:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Where is there an example of this?\n\nWe do not have an example in MOOSE. The basic idea is to use ElemElemConstraint to enforce contact.  One example to enforce glued contact at fracture surfaces using a penalty method is  XFEMSingleVariableConstraint. For more complicated contact constraint, stateful properties at interfaces are usually needed and  #16891 will address that.",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647569",
                          "updatedAt": "2022-09-20T12:59:11Z",
                          "publishedAt": "2021-04-23T01:36:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I tried XFEMSingleVariableConstraint but putting in a few if (_u[_qp] - _u_neighbor[_qp] > 0) conditions so the penalty didn't try to glue the surfaces together.  That won't work if the surfaces move too much relative to each other (and setting the variable in that object seems only possible in very simple situations).\nI looked at the Contact module, but i believe you have to pre-specify the surfaces, which is not what i want.\nAny ideas?",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647571",
                          "updatedAt": "2022-09-20T12:59:11Z",
                          "publishedAt": "2021-04-23T01:38:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Oh, sorry, i didn't see your reply @jiangwen84 .  i don't want to glue the faces together.  i want to prevent interpenetration.",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647575",
                          "updatedAt": "2022-09-20T12:59:21Z",
                          "publishedAt": "2021-04-23T01:40:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Oh, sorry, i didn't see your reply @jiangwen84 . i don't want to glue the faces together. i want to prevent interpenetration.\n\nXFEM won't work naturally work with Contact module, but we can possibly reuse some existing contact codes. You are correct that we always assume the constraint is applied on a pair of element and large sliding and opening might be a problem.",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647588",
                          "updatedAt": "2022-09-20T12:59:21Z",
                          "publishedAt": "2021-04-23T01:49:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "OK, this is good to know.  I think that contact detection throughout the mesh is quite a significant addition to MOOSE, and one that i currently don't have time to contribute to.  It will likely involve fairly cumbersome checks involving looking at what's happening on other processors, in the same way that DEM codes are hard to parallelise using MPI.  So, i think for now the XFEM/Contact stuff won't really work for me, but it's good to know what XFEM is after seeing 1E6 emails about it!",
                          "url": "https://github.com/idaholab/moose/discussions/17667#discussioncomment-647605",
                          "updatedAt": "2022-09-20T12:59:21Z",
                          "publishedAt": "2021-04-23T01:57:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to read solution file from adaptive meshing simulations ?",
          "author": {
            "login": "KamalnathOSU"
          },
          "bodyText": "I tried to read-in the variables from another simulation into my current simulation. My previous simulation used adaptive meshing.  Hence, it created a series of files like precipitation_exo.e, precipitation_exo.e-s002, precipitation_exo.e-s003, ..., precipitation_exo.e-s018.\nI tried to load the result file as follows\n[./soln_ppt]\ntype  = SolutionUserObject\nsystem_variables='eta'\nmesh = 'precipitation_exo.e'\n[../]\n\nBut this loads only the first time step results. I want to load all the files so that I can do time interpolation for any time in my current simulation.\nAny suggestions ?\nThank you very much.\n-Kamal",
          "url": "https://github.com/idaholab/moose/discussions/17635",
          "updatedAt": "2022-06-21T21:17:50Z",
          "publishedAt": "2021-04-17T12:56:25Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "To my knowledge this is not supported. @friedmud do you recall for sure? Also, @roystgnr do/can we support time interpolation across adaptive steps?\nIn a related area, this capability was only recently added to VTK. I was involved in the research grant that added it and provided them some data. In the future we will have this ability in our visualization scripts, but it doesn't exist now.",
                  "url": "https://github.com/idaholab/moose/discussions/17635#discussioncomment-640528",
                  "updatedAt": "2022-06-21T21:17:53Z",
                  "publishedAt": "2021-04-21T15:01:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "A couple of things:\n\nYou cannot read in adapted Exodus files at all.  They do not contain the correct element hierarchy for MOOSE to be able to understand them.  They are strictly visualization only.\nYou can read adapted meshes from xdr/xda output or from the checkpoint format (see https://mooseframework.inl.gov/application_usage/restart_recover.html )\nI have no idea if we have the ability to read a transient simulation with adapted meshes at all\nYou may want to use a MultiApp approach instead.  That way you can march both of your solutions forward in time together - transferring back and forth.",
                          "url": "https://github.com/idaholab/moose/discussions/17635#discussioncomment-640835",
                          "updatedAt": "2022-06-21T21:17:53Z",
                          "publishedAt": "2021-04-21T16:04:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "Thank you Derek.\nActually, I was able to read in adapted Exodus files !!! I was able to load the solution from previous simulation into my current simulation and proceed with the calculation. I was able to load the Euler angles from grain growth simulation  into my precipitation model (KKS - two phase) , and simulate anisotropic precipitate growth.\nBut I could not do time interpolation with adaptive meshes.",
                          "url": "https://github.com/idaholab/moose/discussions/17635#discussioncomment-640888",
                          "updatedAt": "2022-06-21T21:17:57Z",
                          "publishedAt": "2021-04-21T16:15:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "@friedmud Can you give me guidance on how to proceed with MultiApp ?",
                          "url": "https://github.com/idaholab/moose/discussions/17635#discussioncomment-640893",
                          "updatedAt": "2022-06-21T21:17:57Z",
                          "publishedAt": "2021-04-21T16:17:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "do/can we support time interpolation across adaptive steps\n\nYeah; if you're using any of the libMesh transient classes, or even if you're adding your own solution vectors corresponding to other timesteps but you're not changing the default vector_preservation() setting for your vectors, we'll project them to the new space whenever we adapt the mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/17635#discussioncomment-640984",
                          "updatedAt": "2022-06-21T21:17:57Z",
                          "publishedAt": "2021-04-21T16:36:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Can you give me guidance on how to proceed with MultiApp ?\n\nhttps://mooseframework.inl.gov/syntax/MultiApps",
                          "url": "https://github.com/idaholab/moose/discussions/17635#discussioncomment-641156",
                          "updatedAt": "2022-06-21T21:17:57Z",
                          "publishedAt": "2021-04-21T17:15:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Heat source time data",
          "author": {
            "login": "ali-mhassaan"
          },
          "bodyText": "Hi,\nI'm currently using the FunctionPathEllipsoidHeatSource for a part of my simulation. I need to output the temperature data w.r.t. time and space and use that in another MOOSE input file. I have tried using the NodalValueSampler, but output is not a function of time. Also, any help regarding reading the data (in this particular case), in the input file would also be appreciated.\nCheers,\nHassaan",
          "url": "https://github.com/idaholab/moose/discussions/17616",
          "updatedAt": "2022-10-19T20:40:27Z",
          "publishedAt": "2021-04-15T06:41:11Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "I think you can get what you need from FunctionAux. The documentation is not complete, but the test input files listed should give you the enough to get it running.\nUsing it will result in the calculation of an AuxVariable using the function that will be stored in the Exodus output as a field variable.",
                  "url": "https://github.com/idaholab/moose/discussions/17616#discussioncomment-640626",
                  "updatedAt": "2022-10-19T20:40:28Z",
                  "publishedAt": "2021-04-21T15:21:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to acquire moose soon",
          "author": {
            "login": "xchengood"
          },
          "bodyText": "Hi moose experts and users,\nThis is a general question. Although I roughly look through the get started section including examples, tutorials as well as the complete syntax, and try my best to understand them, there are still much confusion in my head and I am not able to write complete code for my own model if there are no any example files for reference. I have no idea what syntax I should use even if I go through complete syntax. Does anyone share any good experiences or tips with me? Thanks for your help in advance.",
          "url": "https://github.com/idaholab/moose/discussions/17658",
          "updatedAt": "2021-04-27T15:14:11Z",
          "publishedAt": "2021-04-21T15:05:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "I suggest you start here: https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/index.html\nThis includes a step-by-step guide for creating a MOOSE-based application. If you read it completely and do the steps yourself you will begin to understand the process. It would also be worth watching the video on the homepage.",
                  "url": "https://github.com/idaholab/moose/discussions/17658#discussioncomment-640580",
                  "updatedAt": "2021-04-21T15:13:26Z",
                  "publishedAt": "2021-04-21T15:13:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Move the boundary for central void formation",
          "author": {
            "login": "xuxiaobei1995"
          },
          "bodyText": "Hi all,\n I'm working on a 2D-RZ cylindrical problem in which a void caused by the temperature gradient gradually forms at the center of the cylinder.  So my question is that is there any way to move the centerline boundary to simulate the central void formation? Any suggestion is appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/17657",
          "updatedAt": "2021-04-21T14:42:36Z",
          "publishedAt": "2021-04-21T03:10:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "coskrrb2002"
                  },
                  "bodyText": "Dear xuxiaobei1995,\nI think you can do it with activation of element.\nYou should read this post: #16008 .\nBest regards,\nNakkyu",
                  "url": "https://github.com/idaholab/moose/discussions/17657#discussioncomment-639528",
                  "updatedAt": "2021-04-21T11:42:42Z",
                  "publishedAt": "2021-04-21T11:42:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Hi Nakkyu,\nI read the documentation of the ActivateElementUserObject. It seems that the object can only activate the elements. But what I need is to de-activate the elements... Anyway, thanks for your reply!",
                          "url": "https://github.com/idaholab/moose/discussions/17657#discussioncomment-639705",
                          "updatedAt": "2021-04-21T12:24:25Z",
                          "publishedAt": "2021-04-21T12:24:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can use this: https://mooseframework.inl.gov/source/userobject/CoupledVarThresholdElementSubdomainModifier.html. If you don't add kernels on a subdomian, then that subdomain is effectively \"deactivated\".",
                  "url": "https://github.com/idaholab/moose/discussions/17657#discussioncomment-640064",
                  "updatedAt": "2021-04-21T13:44:54Z",
                  "publishedAt": "2021-04-21T13:44:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Hi Gary,\nThanks for your suggestion! It is just what I need. I will try it for my problem.",
                          "url": "https://github.com/idaholab/moose/discussions/17657#discussioncomment-640401",
                          "updatedAt": "2021-04-21T14:41:52Z",
                          "publishedAt": "2021-04-21T14:41:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}