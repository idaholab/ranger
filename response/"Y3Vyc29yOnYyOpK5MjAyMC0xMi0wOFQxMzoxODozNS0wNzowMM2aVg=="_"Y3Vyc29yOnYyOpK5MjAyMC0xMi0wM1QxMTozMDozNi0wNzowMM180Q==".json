{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMC0xMi0wM1QxMTozMDozNi0wNzowMM180Q=="
    },
    "edges": [
      {
        "node": {
          "title": "libtool: error: unknown tag cxx",
          "author": {
            "login": "LiuPengPeter"
          },
          "bodyText": "Hell,\nI try to install Moose on a work station. Everything goes well.\nBut when\ncd ~/projects/moose/test\nmake -j 4\n\nIt shows : libtool: error: unknown tag cxx",
          "url": "https://github.com/idaholab/moose/discussions/16319",
          "updatedAt": "2023-02-13T19:03:46Z",
          "publishedAt": "2020-11-28T12:14:21Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "LiuPengPeter"
                  },
                  "bodyText": "Could anyone help?\nIt could run simulation, but will always show that problem. Will it affect?",
                  "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-142076",
                  "updatedAt": "2023-02-13T19:03:46Z",
                  "publishedAt": "2020-11-29T23:18:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "What operating system are you using? Can you post some of the context of the error?",
                  "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-142608",
                  "updatedAt": "2023-02-13T19:04:01Z",
                  "publishedAt": "2020-11-30T14:33:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "LiuPengPeter"
                          },
                          "bodyText": "Thnak you for your help!\nIt shows taht:\n(moose) lizhen1@dlut:/Project/big_cat$ make > a.txt\nlibtool: error: ignoring unknown tag CXX\n(moose) lizhen1@dlut:/Project/big_cat$ make\nChecking if header needs updating: /home/lizhen1/Project/moose/framework/include/base/MooseRevision.h...\nRebuilding symlinks in /home/lizhen1/Project/big_cat/build/header_symlinks\nCreating Unity Directory /home/lizhen1/Project/big_cat/build/unity_src\nCreating Unity /home/lizhen1/Project/big_cat/build/unity_src/kernels_Unity.C\nCompiling C++ (in opt mode) /home/lizhen1/Project/big_cat/build/unity_src/kernels_Unity.C...\nlibtool: error: ignoring unknown tag CXX\nLinking Library /home/lizhen1/Project/big_cat/lib/libbig_cat-opt.la...\nlibtool: error: ignoring unknown tag CXX\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\n/home/lizhen1/miniconda3/envs/moose/libmesh/contrib/bin/libtool: 9009: /usr/bin/grep: not found\nLinking Executable /home/lizhen1/Project/big_cat/big_cat-opt...\nlibtool: error: ignoring unknown tag CXX",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-143222",
                          "updatedAt": "2023-02-13T19:04:02Z",
                          "publishedAt": "2020-12-01T03:02:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "@lindsayad  /usr/bin/grep is also hard coded?\nOkay, so this feels like a moose-libmesh issue. There is a similar discussion going on about contrib/bin/libtool in moose-libmesh #16123.\nI think your only option will be to build libMesh yourself, and not use the one supplied by us. Please do the following:\nconda deactivate\nconda env remove -n moose\nconda create -n moose moose-petsc moose-tools\nconda activate moose\nThe above basically re-installs everything needed to build moose except libMesh. So we will need to build that manually. But first, let's clean the moose repository, just in case the previous failed build left any lingering issues:\ncd /home/lizhen1/Project/moose\ngit clean -xfd\nOnce moose is clean, we can try to build libMesh:\nexport MOOSE_JOBS=4\ncd /home/lizhen1/Project/moose\nscripts/update_and_rebuild_libmesh.sh\nHopefully, you can now build your application:\ncd /home/lizhen1/Project/big_cat\nmake -j 4",
                  "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-143805",
                  "updatedAt": "2023-02-13T19:04:13Z",
                  "publishedAt": "2020-12-01T14:32:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@lindsayad /usr/bin/grep is also hard coded?\n\nYes. I think we should build our next libmesh package on a non-meowbuild machine so that we can reproduce the grep and sed (and probably other things) paths that we had before. We're not going to have a real fix until we decide what we want to use for configuration, e.g. cmake or autotools.",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-143848",
                          "updatedAt": "2020-12-03T21:37:29Z",
                          "publishedAt": "2020-12-01T15:17:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I doubt meowbuild has anything to do with it... meowbuild is running the same singularity image as buildq, mobuild, hpcbuild, etc. Which is/was CentOS 7.7.",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-143873",
                          "updatedAt": "2020-12-03T21:37:29Z",
                          "publishedAt": "2020-12-01T15:48:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I dunno. You said everything was fine until this most recent libmesh package...and wasn't that the first time we used meowbuild to create the package?",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-143926",
                          "updatedAt": "2023-02-13T19:04:14Z",
                          "publishedAt": "2020-12-01T16:10:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Maybe it's the difference between CentOS 7.6 and 7.7? I was wrong in saying they are using the same image. Turns out meowbuild is using CentOS-7.7 (and now 8), while the rest are using 7.6.\nCan't use 7.6 or 7.7 (valgrind issues as you discovered). So I stepped it up to 8.\nI can attempt to manually build our moose-libmesh package using 8, see if that works. If not... not sure stepping backwards is the right solution.",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-143935",
                          "updatedAt": "2023-02-13T19:04:13Z",
                          "publishedAt": "2020-12-01T16:20:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "You're right. Stepping back is not the right solution. I would say that if we're unable to get /bin/sed, /bin/grep with CentOS 8, then we should probably modify our conda instructions to tell the user to build libMesh...until we get an independent MOOSE configuration",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-144033",
                          "updatedAt": "2023-02-13T19:04:14Z",
                          "publishedAt": "2020-12-01T17:56:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I have an issue building libMesh on CentOS 8 using Conda supplied compilers. I have a sample PR busy working on all the moose- packages.\nhttps://civet.inl.gov/job/637387/\nI suspect it will make it, and then fail on moose-libmesh. It feels like a CentOS 8 issue. But I am not sure how to fix it.",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-144169",
                          "updatedAt": "2023-02-13T19:04:14Z",
                          "publishedAt": "2020-12-01T20:07:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Attaching the log generated by conda build . while in moose/conda/libmesh\nlibmesh.txt",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-144231",
                          "updatedAt": "2023-02-13T19:04:14Z",
                          "publishedAt": "2020-12-01T20:57:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Can we (@milljm) not patch the generated libtool scripts? The shell command paths that cause problems are assigned to variables at the top of libtool (SED=\"/bin/sed\"). Wouldn't it be possible to change this to SED=\"sed\"?",
                  "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-144200",
                  "updatedAt": "2023-02-13T19:04:14Z",
                  "publishedAt": "2020-12-01T20:28:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "And for grep as well? As the OP ran into.",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-144235",
                          "updatedAt": "2023-02-13T19:04:21Z",
                          "publishedAt": "2020-12-01T21:02:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Yes, of course",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-144237",
                          "updatedAt": "2023-02-13T19:04:21Z",
                          "publishedAt": "2020-12-01T21:03:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "This was fixed, along with /usr/bin/sed early this morning. Please perform the following:\nconda update --all\nAnd try to build again.",
                  "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-163483",
                  "updatedAt": "2023-02-13T19:04:24Z",
                  "publishedAt": "2020-12-08T15:43:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "Very cool. Thanks Jason",
                          "url": "https://github.com/idaholab/moose/discussions/16319#discussioncomment-164918",
                          "updatedAt": "2023-02-13T19:04:25Z",
                          "publishedAt": "2020-12-08T18:05:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Removing Boundary Conditions from specific elements",
          "author": {
            "login": "MatthewMavis"
          },
          "bodyText": "Hi all,\nI'm currently looking into trying to do topology optimisation using moose. I have looked into multiple ways of changing elements to do this. I have been able to create a meshgenerator to delete elements based on defined element IDs, though one problem with this is that to do so I'm using the ElementDeletionGeneratorBase.C which reassigns the element IDs after the elements have been removed. This means that the element IDs no longer match those of the original mesh which causes problems for example if you have to step back if you take off too much in the optimisation process.\nTo get around this I have created another meshgenerator that instead changes the blockID of the element so that the element can have its density set to 0. The problem with this method is that the elements on the boundary condition interfaces retain the BCs. So is there any way to remove them on an element by element basis?\nI'm also open to any ideas on how to retain the element IDs after deletion.\nBest Regards,\nMatt Mavis",
          "url": "https://github.com/idaholab/moose/discussions/16390",
          "updatedAt": "2023-01-04T16:42:25Z",
          "publishedAt": "2020-12-04T16:39:47Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "If you can change blockID of elements, why cannot you do block restriction to your variables, kernels, etc.? You can add new boundaries excluding the part connecting to a certain mesh block. I am not sure if this helps.",
                  "url": "https://github.com/idaholab/moose/discussions/16390#discussioncomment-147490",
                  "updatedAt": "2023-01-04T20:38:10Z",
                  "publishedAt": "2020-12-04T20:17:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "I'm not sure that MOOSE will support dynamically changing the boundary definition on-the-fly very well. However, there are a few workarounds to your issue:\n\nGoing back to your original issue, you could simply turn off the renumbering of elements. We do that to keep data structures contiguous, but this is not a requirement. There is an option in the [Mesh] block that will allow you to do this.\nThere is a method in the BoundaryCondition class that lets you programmatically define when a boundary condition should be applied. You could extend the boundary condition you are using and define that method (shouldApply) to take into account your zero density property.",
                  "url": "https://github.com/idaholab/moose/discussions/16390#discussioncomment-163946",
                  "updatedAt": "2023-01-04T20:38:10Z",
                  "publishedAt": "2020-12-08T17:01:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "add/modify moose conda environment",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "@milljm How should I add extra python packages to my moose conda environment? Should I just add them to the moose conda environment or make a clone and add to the clone? Just wasn't sure if at some point in the future there could be issues if I modify the moose conda environment and try to update it for example. I'm on Linux if it matters.",
          "url": "https://github.com/idaholab/moose/discussions/16421",
          "updatedAt": "2024-01-23T16:05:18Z",
          "publishedAt": "2020-12-08T15:04:29Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "For things I use regularly I just add them to my default 'moose' environment. When I am trying something out I create a new environment.",
                  "url": "https://github.com/idaholab/moose/discussions/16421#discussioncomment-163408",
                  "updatedAt": "2024-01-23T16:05:19Z",
                  "publishedAt": "2020-12-08T15:10:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Sounds good.",
                          "url": "https://github.com/idaholab/moose/discussions/16421#discussioncomment-163498",
                          "updatedAt": "2024-01-23T16:05:18Z",
                          "publishedAt": "2020-12-08T15:49:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "share adaptive mesh from master app to sub app",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "I am trying to clone the adaptive mesh from master app to sub app. I have set the clone_master_app=true  in block [Multiapps] for the sub app in the master.i file.  What should I do for the [Mesh] block in sub.i? I tried leaving it empty or add the original mesh file as  FileMesh to read. Either way returned with error: Use either FileMesh with an Exodus mesh file or FileMeshGenerator with an Exodus mesh file and with use_for_exodus_restart equal to true",
          "url": "https://github.com/idaholab/moose/discussions/16389",
          "updatedAt": "2023-05-25T20:13:37Z",
          "publishedAt": "2020-12-04T16:39:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Hi Bo, see the discussion here .",
                  "url": "https://github.com/idaholab/moose/discussions/16389#discussioncomment-148048",
                  "updatedAt": "2023-05-25T20:13:37Z",
                  "publishedAt": "2020-12-05T23:51:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "We have some basic capability in the level set module for doing this. Check out the tests here: https://github.com/idaholab/moose/tree/next/modules/level_set/test/tests/transfers/markers",
                  "url": "https://github.com/idaholab/moose/discussions/16389#discussioncomment-149057",
                  "updatedAt": "2023-05-25T20:13:37Z",
                  "publishedAt": "2020-12-07T15:54:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error from file mesh transform",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi\nI have the following mesh block\n[Mesh]\n  [div_mesh]\n    type = FileMesh\n    file = 'divertor-monoblock-htc.e'\n    use_displaced_mesh = false\n  []\n  [rotate]\n    type = TransformGenerator\n    input = div_mesh\n    transform = SCALE\n    vector_value = '0.01 0.01 0.01'\n  []\n[]\n\nHowever, moose complains that\n*** ERROR ***\nTask add_mesh_generator is not registered to build MooseMesh derived objects\n\nBut as far as I can tell its no different to this from example test/tests/mesh_modifiers/transform/rotate_and_scale.i\n[Mesh]\n  [file]\n    type = FileMeshGenerator\n    file = cylinder.e\n  []\n\n  [rotate]\n    type = TransformGenerator\n    input = file\n    transform = ROTATE\n    vector_value = '0 90 0'\n  []\n\n  [scale]\n    type = TransformGenerator\n    input = rotate\n    transform = SCALE\n    vector_value = '1e2 1e2 1e2'\n  []\n[]\n\nAny ideas?",
          "url": "https://github.com/idaholab/moose/discussions/16400",
          "updatedAt": "2022-08-16T01:18:46Z",
          "publishedAt": "2020-12-05T17:16:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear makeclean,\nI just had the same problem, you need to use FileMeshGenerator instead of FileMesh in the first block.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/16400#discussioncomment-148683",
                  "updatedAt": "2022-08-16T01:19:10Z",
                  "publishedAt": "2020-12-07T10:10:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Increase the number of grains to simulate grain growth",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Recently I learned an example of grain growth in the phase field module, \"grain_growth_2D_graintracker.i\". Based on this input file, I modified the number of grains and order parameters (op_num = 180,grain_num=1000) , increasing the number of grains, but the simulation has problems, as follows\uff1a\n`Uniformly refining mesh ............                                                       [ 13.40 s]\nCaching mesh information                                                                   [  1.65 s]\nInitializing equation system .............................................................\n...........................................................................                [137.15 s]\nCaching mesh information                                                                   [  1.65 s]\nComputing max dofs per elem/node .                                                         [  2.53 s]\nFramework Information:\nMOOSE Version:           git commit ef9631d on 2020-11-30\nLibMesh Version:         0d19e76fc8e7345a0634cba450f488b3a5626eb3\nPETSc Version:           3.13.3\nSLEPc Version:           3.13.3\nCurrent Time:            Wed Dec  2 09:12:13 2020\nExecutable Timestamp:    Tue Dec  1 15:13:50 2020\nParallelism:\nNum Processors:          20\nNum Threads:             1\nMesh:\nParallel Type:           replicated\nMesh Dimension:          2\nSpatial Dimension:       2\nNodes:\nTotal:                 776161\nLocal:                 39202\nElems:\nTotal:                 774400\nLocal:                 38775\nNum Subdomains:          1\nNum Partitions:          20\nPartitioner:             metis\nNonlinear System:\nNum DOFs:                139708980\nNum Local DOFs:          7056360\nVariables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" ... \"gr175\" \"gr176\" \"gr177\" \"gr178\" \"gr179\"\n}\nFinite Element Types:    \"LAGRANGE\"\nApproximation Orders:    \"FIRST\"\nAuxiliary System:\nNum DOFs:                3873761\nNum Local DOFs:          194302\nVariables:               \"bnds\" { \"unique_grains\" \"var_indices\" \"ghost_regions\" \"halos\" }\nFinite Element Types:    \"LAGRANGE\" \"MONOMIAL\"\nApproximation Orders:    \"FIRST\" \"CONSTANT\"\nExecution Information:\nExecutioner:             Transient\nTimeStepper:             IterationAdaptiveDT\nSolver Mode:             Preconditioned JFNK\nPETSc Preconditioner:    hypre boomeramg\nLEGACY MODES ENABLED:\nThis application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material\n_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate dif\nfs due to zero values being stored, and these tests should be re-golded.\nCaching mesh information                                                                   [  1.69 s]\nComputing Polycrystal Initial Condition ...........                                        [ 12.19 s]\nProjecting initial condition .............................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................                 [2116.46 s]\nComputing initial stateful property values ..                                              [  3.86 s]\nInitial adaptivity step 1 of 2 ...........................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n....................................................\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 1894809 RUNNING AT pwmoose-PowerEdge-T640\n=   EXIT CODE: 9\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Killed (signal 9)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions\n`\nAny idea what I am doing wrong?\nThanks in advance,\nwei peng",
          "url": "https://github.com/idaholab/moose/discussions/16370",
          "updatedAt": "2022-07-12T03:28:08Z",
          "publishedAt": "2020-12-02T09:53:29Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "PengWei97"
                  },
                  "bodyText": "And this is my input file and Display information running in simulation\npw8.txt\ngrain_growth_2D_graintracker_1000.txt",
                  "url": "https://github.com/idaholab/moose/discussions/16370#discussioncomment-144677",
                  "updatedAt": "2022-07-12T03:28:27Z",
                  "publishedAt": "2020-12-02T10:07:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "You are probably running out of memory. You don't need to increase the number of order parameters, you should be able to maintain 8 order parameters for a 2D simulation and just increase the number of grains and corresponding mesh size. The advantage of the GrainTracker system is that it will allow you to re-use order parameters. I would suggest reading up on it more here to understand how it works better:\nhttps://mooseframework.inl.gov/source/postprocessors/GrainTracker.html",
                  "url": "https://github.com/idaholab/moose/discussions/16370#discussioncomment-144923",
                  "updatedAt": "2022-07-12T03:28:26Z",
                  "publishedAt": "2020-12-02T15:07:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "You are probably running out of memory. You don't need to increase the number of order parameters, you should be able to maintain 8 order parameters for a 2D simulation and just increase the number of grains and corresponding mesh size. The advantage of the GrainTracker system is that it will allow you to re-use order parameters. I would suggest reading up on it more here to understand how it works better:\nhttps://mooseframework.inl.gov/source/postprocessors/GrainTracker.html\n\nThank you very much for your response. , I got it.\nNow I have another question, in the \"voronoi\" sub-block, what does \"rand_seed = 5\" mean? Through the study of PolycrystalVoronoi webpage, I know that it is used to generate a voronoi diagram with 5 subdomains. But if I set \"grain_num = 10\", the output cloud image is composed of 18 sub-domains and represents 10 grains.\n[UserObjects] [./voronoi] type = PolycrystalVoronoi grain_num = 100 # Number of grains rand_seed = 10 [../] []\nSo I want to ask\uff1a\n\nWhat does \"voronoi/rand_seed\" affect in the model?\nAnd for different numbers of grains, how to choose the appropriate number of \"rand_seed\"?\nThank you for your precious time. Do you have any information to understand the \"voronoi\" and \"grain_tracker\" in the UserObjects block, which is a better Moose program for beginners like me? Learning from the web, I still don't quite understand the meaning of some auxiliary variables in the input file, such as ghost_regions, halos and so on.",
                          "url": "https://github.com/idaholab/moose/discussions/16370#discussioncomment-145669",
                          "updatedAt": "2022-07-12T03:28:26Z",
                          "publishedAt": "2020-12-03T07:48:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Whenever you see rand_seed or something similar, it's a number for seeding the pseudo-random number generator(s) in MOOSE. In this case, each number will give you a different \"random\" initial condition so you can repeat your simulations as necessary. Feel free to change this number to see what happens to your IC.\nThe rand_seed number has no relation to the number of grains or order parameters. It will affect the location and sizes of all your grains however. Feel free to play around with this number. There is documentation on the Polycrystal Initial Condition system, as well as information on the GrainTracker on this page: https://mooseframework.inl.gov/modules/phase_field/index.html. Specifically you can find some guidance on good settings for grains versus order parameters here: https://mooseframework.inl.gov/source/userobjects/PolycrystalVoronoi.html. Note however, that if you start to add more and more grains, you will need more and more mesh to capture the smooth interfaces between grains.",
                          "url": "https://github.com/idaholab/moose/discussions/16370#discussioncomment-146152",
                          "updatedAt": "2022-07-12T03:28:27Z",
                          "publishedAt": "2020-12-03T15:30:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "OK\uff0cthank you for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/16370#discussioncomment-147699",
                          "updatedAt": "2022-07-12T03:28:28Z",
                          "publishedAt": "2020-12-05T03:45:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "auxvariable and non linear variable",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nI would have a simple (naive) questions: is it possible to add to a non linear variable the value computed from an aux variable? And, if yes, when and where would it be done? One thing to add is that what I would need is actually the coupleGradient of the non linear variable afterwards.\nThanks for any help,\nmauro",
          "url": "https://github.com/idaholab/moose/discussions/16368",
          "updatedAt": "2022-12-15T16:02:32Z",
          "publishedAt": "2020-12-02T09:37:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Yes, that is possible, but it'd be useful to know more details:\n\nare you constructing a new AuxVariable = anotherAux + u ?\nare you doing this in the input file, or in C++ code?\ninstead, are you wanting to modify u, eg, u = u + Aux?   If so, when do you want the modification done?  After every nonlinear iteration, after every timestep, ... ?   Are you doing this in C++ code, or using the input file (I believe it is impossible to do this from the input file)?",
                  "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-145378",
                  "updatedAt": "2022-12-15T16:02:32Z",
                  "publishedAt": "2020-12-02T20:50:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Dear @WilkAndy,\nThanks. Mine would exactly match your last bullet point. I compute a non linear var (u) and I have an aux kernel that provides an aux and would like to have it as a correction to u (u=u+aux) at timestep end (do not need to internally iterate). Indeed, I would only want to make use of the new value (its coupledgradient actually) in the next timestep. All would be in a c++ file on runtime, though I still did not find exactly where and how. As always, any suggestion is greatly appreciated.\nThanks again,\nMauro",
                          "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-145480",
                          "updatedAt": "2022-12-15T16:02:32Z",
                          "publishedAt": "2020-12-02T23:07:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I suggest you attempt to write your DEs so the AuxVariable is included in the DEs, and hence just becomes a coupledVariable in a Kernel.   That will fit nicely into the MOOSE paradigm, and could be more physical too.  Eg, maybe the AuxVariable is some sort of source term.\nIf that just isn't possible, then you could follow the code at\nhttps://github.com/idaholab/moose/blob/next/modules/richards/src/base/RichardsMultiphaseProblem.C\nwhich modifies a nonlinear variable in a similar way to what you'd like.",
                          "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-145528",
                          "updatedAt": "2022-12-15T16:02:32Z",
                          "publishedAt": "2020-12-03T00:36:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@WilkAndy: I had a quick look at the code (above) in the Richards' module. One question: should it only work based on two non linear variables (and not with one non linear and one aux variable)? Just wondering, sorry for posting back...",
                          "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-147161",
                          "updatedAt": "2022-12-15T16:02:32Z",
                          "publishedAt": "2020-12-04T14:23:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Yea, it'll probably work fine.",
                          "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-147642",
                          "updatedAt": "2022-12-15T16:02:46Z",
                          "publishedAt": "2020-12-05T00:40:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "CoupledForce might be what you're looking for.",
                  "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-145544",
                  "updatedAt": "2022-12-15T16:02:48Z",
                  "publishedAt": "2020-12-03T01:07:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "Thanks @WilkAndy and @WilkAndy. I ended up with something similar on CoupleForce. Will nevertheless try to have a deeper look at the original code in the framework.\nmauro",
                  "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-145727",
                  "updatedAt": "2022-12-15T16:02:53Z",
                  "publishedAt": "2020-12-03T09:14:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "tensor rotation",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "Hi all. I wanted to talk about tensor rotations (again) as it pertains to mechanics simulations, but without a discussion on those pesky Euler angles. It seems all you need is a rotation matrix and some clever manipulation to rotate the tensor (easy in python). Now I already know the basis vectors for how my crystal phase is embedded in my matrix phase, so there are really only two rotation matrices possible - the basis vectors are either rows or columns. One takes a vector direction in the matrix (sample) phase and gives me a direction in the crystal phase, and vice versa. After some googling, which one you want depends on the application. So for the case of straining a sample and getting the proper stresses inside of the crystal phase, which way do I go?",
          "url": "https://github.com/idaholab/moose/discussions/16252",
          "updatedAt": "2023-01-13T21:57:23Z",
          "publishedAt": "2020-11-19T14:32:20Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "Where you able to find an answer to this?",
                  "url": "https://github.com/idaholab/moose/discussions/16252#discussioncomment-146872",
                  "updatedAt": "2023-01-13T21:57:27Z",
                  "publishedAt": "2020-12-04T02:16:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "I tried to figure it out myself and ended up submitting #16341. If anybody has any comments I would ask them to post there.",
                          "url": "https://github.com/idaholab/moose/discussions/16252#discussioncomment-146886",
                          "updatedAt": "2023-01-13T21:57:27Z",
                          "publishedAt": "2020-12-04T03:08:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PerfGraph",
          "author": {
            "login": "singhgp4321"
          },
          "bodyText": "I am removing this post since I found the answer.",
          "url": "https://github.com/idaholab/moose/discussions/16374",
          "updatedAt": "2023-04-09T10:23:00Z",
          "publishedAt": "2020-12-02T20:23:38Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "In the future - if you find an answer yourself, it would be beneficial to others to comment on what the solution you discovered was and leave your original question as a resource. We want this new Discussions forum to be a searchable database of user issues and support, much like the old mailing list.\nThank you for submitting a question, and I'm glad you were able to find the answer!",
                  "url": "https://github.com/idaholab/moose/discussions/16374#discussioncomment-146777",
                  "updatedAt": "2023-04-09T10:23:00Z",
                  "publishedAt": "2020-12-03T22:41:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get only the converged solution for a material property?",
          "author": {
            "login": "jaYINGLING"
          },
          "bodyText": "I am writing a material property that updates the elasticity as a function of the highest vonmises_stress in each element.\nIn the computeQpElasticityTensor() method I have the following logic:\nif (_trial_stress[_qp] > _max_trial_stress[_qp])\n     _max_trial_stress[_qp] = _trial_stress[_qp];\n\nAfter which a damage coefficient is calculated to determine the young's modulus and poisson's ratio.  _trial_stress is a coupledVar to vonmises_stress and _max_trial_stress is a declared material property.\nFor some reason using the logic above to specify _max_trial_stress results in some elements getting assigned values of vonmises_stress that were never seen in any previous timestep for a particular element. More specifically, if I use paraview to track the values of vonmises_stress in a particular element, it may never exceed 20MPa. However, the max_trial_stress for that element might be as high as 60MPa.\nI have verified that I can correctly assign  _max_trial_stress[_qp] = _trial_stress[_qp]; to each element by removing the if statement. However, this logic is essential to describing the elasticity of the material upon relaxation.\nIt seems like maybe very large values of vonmises_stress are being stored in _max_trial_stress during the iteration process before a solution for the timestep is found. I'm not sure how to get around this problem. I tried using coupledVarOld to use the previously converged solution, but the problem still occurs.\nAt what point should I assign _max_trial_stress[_qp]=_trial_stress[_qp] so that it only takes the value of the converged solution?\nPerhaps a related question is: How is _qp used to write to material properties. Does each thread iterate through a list of _qps or is the material property accessed all at once as a vector?",
          "url": "https://github.com/idaholab/moose/discussions/16172",
          "updatedAt": "2023-05-01T16:28:48Z",
          "publishedAt": "2020-11-12T23:07:37Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "Material properties are computed on the fly and don't maintain their state like you are expecting. The the _max_trial_stress references memory in the internals of MOOSE that get swapped out at each element before calling the compute methods.\nThis problem might require the use of old material properties (getMaterialPropertyOld) to use for comparison. Hopefully, someone with more experience with this type of calculation will jump in.",
                  "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-128455",
                  "updatedAt": "2023-06-09T14:07:49Z",
                  "publishedAt": "2020-11-13T04:22:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jaYINGLING"
                          },
                          "bodyText": "OK. A solution might be to get the _trial_stress and assign it to a material property _trial_stress_prop. Then use:\nif (_trial_stress_prop_old[_qp] > _max_trial_stress[_qp])\n     _max_trial_stress[_qp] = _trial_stress_prop_old[_qp];\n\nI'll give this a try. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-128926",
                          "updatedAt": "2023-06-09T14:07:49Z",
                          "publishedAt": "2020-11-13T19:40:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jaYINGLING"
                          },
                          "bodyText": "Unfortunately this does not solve the problem. Here you can see my material that gets strained from left to right. The _max_trial_stress is the same for large groups of elements with sudden transitions that I think are related to the number of threads used to do the solve. In effect, using just one thread would result in all mesh elements taking the same value of _max_trial_stress. The correct behavior would be to see a gradient of _max_trial_stress, largest to smallest, from left to right.",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-128944",
                          "updatedAt": "2023-06-09T14:07:49Z",
                          "publishedAt": "2020-11-13T20:14:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jaYINGLING"
                  },
                  "bodyText": "Perhaps I would be better off writing an AuxKernel that computes _max_trial_stress and then use that to calculate the elasticity?",
                  "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-128948",
                  "updatedAt": "2023-06-09T14:07:52Z",
                  "publishedAt": "2020-11-13T20:20:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "I wouldn't recommend this there is potential to get interpolation errors because aux variables are computed at differing locations than the material properties. Additionally, automatic differentiation is not supported.",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-132811",
                          "updatedAt": "2023-06-09T14:07:52Z",
                          "publishedAt": "2020-11-18T16:32:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@sapitts @bwspenc Do you have any ideas for solving this problem?",
                  "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-132828",
                  "updatedAt": "2023-06-09T14:07:52Z",
                  "publishedAt": "2020-11-18T16:43:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "It might be worthwhile to put the _max_trial_stress[_qp] setting/ calculation in a computeStressFinalize method; however, we only have that type of method within the radial return type methods instead of the ComputeElasticityTensor classes.\nYou might instead consider storing the maximum von mises stress value (_vonmises_stress_old) from the previous timestep in the first iteration of the current timestep. With this approach your max_trial_stress value would lag by a timestep, but you would know you were working with the converged von mises stress value from that previous timestep. @dschwen helped me put in logic for a different material calculation, which essentially had the form\nint number_nonlinear_it =\n      _fe_problem.getNonlinearSystemBase().getCurrentNonlinearIterationNumber();\n  if (number_nonlinear_it == 0)\n\nin the jacobianSetup() method of my material class. Perhaps this approach would be helpful for your problem too?",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-133034",
                          "updatedAt": "2023-06-09T14:07:52Z",
                          "publishedAt": "2020-11-18T19:53:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Sorry, I'm super late to this conversation. It sounds like what you want is a damage model. Rather than updating the elasticity tensor, you would want to update a damage index that is computed based on the strain. We have a fully developed system for damage models in TensorMechanics. Look at ComputeDamageStress. That's used together with the actual damage model, which computes the scalar damage material property. I don't think we have a \"real\" damage model in MOOSE, but there is one in BlackBear that derives from the ScalarDamageBase class in MOOSE: https://github.com/idaholab/blackbear/blob/devel/src/materials/MazarsDamage.C",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-144405",
                          "updatedAt": "2023-06-09T14:07:53Z",
                          "publishedAt": "2020-12-02T00:51:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jaYINGLING"
                          },
                          "bodyText": "These are good leads. Thank you for your help. This is a side project for me so I apologize for the delayed responses.",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-146596",
                          "updatedAt": "2023-06-09T14:08:03Z",
                          "publishedAt": "2020-12-03T18:30:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}