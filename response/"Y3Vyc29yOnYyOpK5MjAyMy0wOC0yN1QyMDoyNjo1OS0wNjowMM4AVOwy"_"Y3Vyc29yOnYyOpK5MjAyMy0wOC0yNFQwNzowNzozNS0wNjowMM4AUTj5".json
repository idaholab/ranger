{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wOC0yNFQwNzowNzozNS0wNjowMM4AUTj5"
    },
    "edges": [
      {
        "node": {
          "title": "Terminal crash when compiling",
          "author": {
            "login": "wesleyzzz"
          },
          "bodyText": "Hi all,\nI am testing the MOOSE in Unbuntu 22 LTS in VMware Workstaion, following the instruction. It appears the terminal stops running\nwhen compiling a few steps as shown below, i.e., the compiling process gets stuck. Then several minuts later the terminal shuts down.\nI updated the libmesh, but the problem persist.\nAny comments?\n(moose) wes@wes-virtual-machine:~$ cd ~/projects/moose/test\nmake -j 6\nCompiling C++ (in opt mode) /home/wes/projects/moose/framework/build/unity_src/userobjects_Unity.C...\nCompiling C++ (in opt mode) /home/wes/projects/moose/framework/build/unity_src/postprocessors_Unity.C...\nCompiling C++ (in opt mode) /home/wes/projects/moose/framework/build/unity_src/ics_Unity.C...\nCompiling C++ (in opt mode) /home/wes/projects/moose/framework/build/unity_src/geomsearch_Unity.C...\nCompiling C++ (in opt mode) /home/wes/projects/moose/framework/build/unity_src/auxkernels_Unity.C...\nCompiling C++ (in opt mode) /home/wes/projects/moose/framework/build/unity_src/reporters_Unity.C...",
          "url": "https://github.com/idaholab/moose/discussions/25302",
          "updatedAt": "2023-08-26T19:47:07Z",
          "publishedAt": "2023-08-25T07:46:25Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou\u2019re likely running out of memory.\nTry make -j1 for now. You can increase the number of processes if it worked\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25302#discussioncomment-6823068",
                  "updatedAt": "2023-08-25T13:05:25Z",
                  "publishedAt": "2023-08-25T13:05:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wesleyzzz"
                          },
                          "bodyText": "Thank you Guillaume. You are right, it was due to the low memory. I am able to compile and run.\nRegards.",
                          "url": "https://github.com/idaholab/moose/discussions/25302#discussioncomment-6831620",
                          "updatedAt": "2023-08-26T19:47:08Z",
                          "publishedAt": "2023-08-26T19:47:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error when providing an initial condition to an array variable",
          "author": {
            "login": "nuclearkevin"
          },
          "bodyText": "Hello all,\nI've been working on migrating some multi-group radiation transport code over to array variables and recently stumbled across a bit of an issue. MOOSE seems to throw a _Map_base::at error when an ArrayMooseVariable is initialized with components = 1 and an initial condition is provided. This behaviour is not present when there are more components to the ArrayVariable, and using a dedicated ConstantIC doesn't get around the issue either.\nMy main workaround at the moment is to use non-array variables for the case when components = 1, but this isn't a particularly elegant approach (requires kernels/bcs, etc. for both array and non-array variables) and I was wondering if there would be a better way to go about it.\nHere's a minimal example of the issue itself:\n[Mesh]\n  [Test]\n    type = CartesianMeshGenerator\n    dim = 2\n    dx = '1.0'\n    dy = '1.0'\n    ix = '1'\n    iy = '1'\n  []\n[]\n\n[Variables]\n  [Test]\n    type = ArrayMooseVariable\n    order = FIRST\n    family = LAGRANGE\n    components = 1\n    initial_condition = '0.0'\n  []\n[]\n\n[Problem]\n  type = FEProblem\n  solve = false\n  kernel_coverage_check = false\n  material_coverage_check = false\n[]\n\n[Executioner]\n  type = Steady\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nCheers,\nKevin",
          "url": "https://github.com/idaholab/moose/discussions/25306",
          "updatedAt": "2023-08-25T20:44:06Z",
          "publishedAt": "2023-08-25T18:15:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Have you tried using ArrayConstantIC?",
                  "url": "https://github.com/idaholab/moose/discussions/25306#discussioncomment-6826641",
                  "updatedAt": "2023-08-25T20:26:49Z",
                  "publishedAt": "2023-08-25T20:26:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "nuclearkevin"
                          },
                          "bodyText": "I had not - just gave it a go and it solves the issue. Thank you for the fast response!",
                          "url": "https://github.com/idaholab/moose/discussions/25306#discussioncomment-6826793",
                          "updatedAt": "2023-08-25T20:43:55Z",
                          "publishedAt": "2023-08-25T20:43:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to not output some variables in output file",
          "author": {
            "login": "pshen20127"
          },
          "bodyText": "Hello All\nAfter I submit a job, if it converge at that timestep, it will output the values of variables at the current timestep in output file like below. Since outputing them will take much time, I want to turn it off. Do you know how to do that?\n\nPshen",
          "url": "https://github.com/idaholab/moose/discussions/25291",
          "updatedAt": "2023-08-25T18:31:52Z",
          "publishedAt": "2023-08-23T23:06:30Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can specify an interval for output, for all types of output. From the console, to exodus to CSV\nand you can turn them on/off using the execute_on flag too (execute_on = FINAL only runs at the end for example)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6807546",
                  "updatedAt": "2023-08-23T23:38:04Z",
                  "publishedAt": "2023-08-23T23:38:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "The parameter show or hide could control the variables and postprocessors that should or shoulde NOT be output. For example, in test/tests/auxkernels/divergence_aux/test_fv.i  https://github.com/idaholab/moose/blob/42c6f190d9ea2a13de6f00604e582531b6f580dc/test/tests/auxkernels/divergence_aux/test_fv.i#L156",
                          "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6812140",
                          "updatedAt": "2023-08-24T11:02:50Z",
                          "publishedAt": "2023-08-24T11:01:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "@GiudGiud Which block in input file should I add in 'execute_on = FINAL'?\n@echo1115 Thank you. I tried your suggestion but it doesn't work. It still output variables.",
                          "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6817047",
                          "updatedAt": "2023-08-24T20:47:16Z",
                          "publishedAt": "2023-08-24T20:47:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in your outputs block you can pass the execute_on / hide/ show parameters\n[Outputs]\n  \n  [out]\n    type = Exodus\n    hide = 'this vairable'\n    execute_on = FINAL. OR interval = 100\n []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6817089",
                          "updatedAt": "2023-08-24T20:53:21Z",
                          "publishedAt": "2023-08-24T20:53:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Thank you. the command 'interval' works. But don't know why 'execute_on = FINAL' and 'hide' don't work.",
                          "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6817136",
                          "updatedAt": "2023-08-24T21:00:57Z",
                          "publishedAt": "2023-08-24T21:00:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Should both work or error.\nIf you make a minimal non-working MOOSE-only example I can take a look at it",
                          "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6817152",
                          "updatedAt": "2023-08-24T21:04:00Z",
                          "publishedAt": "2023-08-24T21:03:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "I put test files in the link below. Please take a look.\nhttps://github.com/pshen20127/Test.git",
                          "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6817541",
                          "updatedAt": "2023-08-24T22:27:11Z",
                          "publishedAt": "2023-08-24T22:27:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "there s no interval / particular output parameters there. which variable did you try to hide?",
                          "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6817694",
                          "updatedAt": "2023-08-24T23:04:11Z",
                          "publishedAt": "2023-08-24T23:04:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "the hide should work. For example, when running case in test/tests/auxkernels/divergence_aux/test_fv.i, it shows:\n\nand if you comment the hide command:\n[Outputs]\n  csv = true\n  #hide = 's1 s2 s3 s4'\n[]\n\nThe 's1 s2 s3 s4' will appear in the results:\n\n@pshen20127 Maybe you can show us how you use the hide command in input file.",
                          "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6820985",
                          "updatedAt": "2023-08-25T08:50:05Z",
                          "publishedAt": "2023-08-25T08:50:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "@GiudGiud Sorry, I have updated input file in outputs block as below. You can try runing job with  hide or execute_on = FINAL.\n[Outputs]\n  file_base = test\n  exodus = true\n  csv=true\n  hide = 'euler_angle_2'\n  #execute_on = FINAL\n[]\n\n@echo1115 Yes, it works when I run test/tests/auxkernels/divergence_aux/test_fv.i. But I don't know why it doesn't work in my case. I used hide command as above. But still get 'euler_angle_2' output. You can try files in the link: https://github.com/pshen20127/Test.git",
                          "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6825329",
                          "updatedAt": "2023-08-25T17:26:17Z",
                          "publishedAt": "2023-08-25T17:26:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ykvishal"
                          },
                          "bodyText": "You could try this show_hide.i\ncreate a separate block for csv in the output\n  [./out]\n    type = CSV\n    show = 'elem_56'\n    hide = 'elem_12'\n  [../]",
                          "url": "https://github.com/idaholab/moose/discussions/25291#discussioncomment-6825626",
                          "updatedAt": "2023-08-25T18:10:17Z",
                          "publishedAt": "2023-08-25T18:10:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Get current time step",
          "author": {
            "login": "Wang12123w"
          },
          "bodyText": "Hi,\nI have a simple question. I am writing code that performs an action when the current time step exceeds a certain value. How can I obtain the current time step?\nCheers!\nWang",
          "url": "https://github.com/idaholab/moose/discussions/25304",
          "updatedAt": "2023-08-25T13:51:39Z",
          "publishedAt": "2023-08-25T13:08:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFrom the input file, that would be done using a postprocessor. i dont see one that does it though.\nFrom the code, you can get the current time step from the FEProblem object that moose objects have as a class attribute\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classFEProblemBase.html#a01bc321edf2887a0daf998d7abc49dd3\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25304#discussioncomment-6823460",
                  "updatedAt": "2023-08-25T13:51:40Z",
                  "publishedAt": "2023-08-25T13:51:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Enforce rigid body motion for a block",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "Is there a way to enforce the displacement over a whole block (subdomain) rather than on the boundary?\nI am trying to enforce rigid body motion to an object in a contact simulation",
          "url": "https://github.com/idaholab/moose/discussions/25299",
          "updatedAt": "2023-08-25T12:58:53Z",
          "publishedAt": "2023-08-24T21:07:32Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "So are you still going to solve for the displacement in that object?\nIf not, you could just use an auxiliary variable for the displacement and set it in the volume with for example a ParsedAux\nIf so, I think you could look at:\n\nsplitting displacement into two parts, one being imposed and the other one being solved for. That might be a lot of work\nusing a volumetric initial condition for the velocity (is that a variable?)\n\n@hugary1995 or @recuero will know more about this",
                  "url": "https://github.com/idaholab/moose/discussions/25299#discussioncomment-6817197",
                  "updatedAt": "2023-08-24T21:11:36Z",
                  "publishedAt": "2023-08-24T21:11:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "I don't want to solve it, I want to enforce (preset) the displacements on the whole block\nSo can I use ParsedAux to compute the displacement and just assign it to disp_x?",
                          "url": "https://github.com/idaholab/moose/discussions/25299#discussioncomment-6817233",
                          "updatedAt": "2023-08-24T21:16:33Z",
                          "publishedAt": "2023-08-24T21:16:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I don't know that we can impose displacements directly to entire domains. You can evidently prepare the mesh such that applying Dirichlet BCs on the boundaries presets most of the displacements in the block.\nNow, if you are doing contact with a boundary that has preset displacement conditions, I'd be interested to know the outcome. I don't think we have tested that case for some of our algorithms.",
                          "url": "https://github.com/idaholab/moose/discussions/25299#discussioncomment-6817448",
                          "updatedAt": "2023-08-24T22:06:56Z",
                          "publishedAt": "2023-08-24T22:06:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Using theBoundingBoxNodeSetGenerator you can effectively place dirichlet BCs on an entire block. For contact with that block, I think which block is primary or secondary would be important, but I don't know off the top of my head which would be better for the \"rigid\" block.",
                          "url": "https://github.com/idaholab/moose/discussions/25299#discussioncomment-6818029",
                          "updatedAt": "2023-08-25T00:12:16Z",
                          "publishedAt": "2023-08-25T00:12:16Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "should thought about it first, could just mark it all as a boundary",
                          "url": "https://github.com/idaholab/moose/discussions/25299#discussioncomment-6818709",
                          "updatedAt": "2023-08-25T02:48:55Z",
                          "publishedAt": "2023-08-25T02:48:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "If using a penalty formulation, I think you should make the rigid body the primary block. I am not sure about the other contact methods. Let me know how that works.",
                          "url": "https://github.com/idaholab/moose/discussions/25299#discussioncomment-6822822",
                          "updatedAt": "2023-08-25T12:38:07Z",
                          "publishedAt": "2023-08-25T12:38:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "yea that's what I am doing now, at least for elastodynamics, it works fine",
                          "url": "https://github.com/idaholab/moose/discussions/25299#discussioncomment-6823015",
                          "updatedAt": "2023-08-25T12:58:54Z",
                          "publishedAt": "2023-08-25T12:58:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Hot to get coordinates]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Hi moose users,\nI would like to know how to get the exact coordinates of nodes or elements.\nI tried ParsedFunctions 'x' to get the x coordinate.\nBut, the return values are not what I expected.\nThe following figure is plotted from x = 0 to x = 0.515.\nSo, in the figure, I expected to see a linear graph 0 to 0.515 values.\nHowever, it shows weird results.\n\nIs there any other method to get the exact coordinate?\nIn my model, I call the function in this way (auxkernel):\nReal\nAuxTestRad::computeValue()\n{\n       return _xcoord.value(_t,_q_point[_qp]);\n\n}",
          "url": "https://github.com/idaholab/moose/discussions/25301",
          "updatedAt": "2023-08-28T10:27:32Z",
          "publishedAt": "2023-08-25T07:44:02Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "coskrrb2002"
                  },
                  "bodyText": "Hi moose users,\nI would like to know how to get the exact coordinates of nodes or elements.\nI tried ParsedFunctions 'x' to get the x coordinate.\nBut, the return values are not what I expected.\nThe following figure is plotted from x = 0 to x = 0.515.\nSo, in the figure, I expected to see a linear graph 0 to 0.515 values.\nHowever, it shows weird results.\n\nIs there any other method to get the exact coordinate?\nIn my model, I call the function in this way (auxkernel):\nReal AuxTestRad::computeValue() {\n       return _xcoord.value(_t,_q_point[_qp]);\n\n}\n\nI figured out the problem.\nI set the variable as a nodal value, but it has to be an element value.\nNow it worked.",
                  "url": "https://github.com/idaholab/moose/discussions/25301#discussioncomment-6821159",
                  "updatedAt": "2023-08-25T09:07:27Z",
                  "publishedAt": "2023-08-25T09:07:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A few questions on system-level installation of MOOSE on an HPC vs Single-User installation (i.e following regular Linux installation instructions)",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "I have both options, although the former will take some time to get done. I saw in the documentation that the single-user installation (i.e following the same instructions for installing on Linux) has lower performance. I was wondering if this difference is significant.\nAlso, I wanted to ask about the installation instructions here:\nhttps://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html\nAfter the \"module load\" command, which I guess assumes that a system level installation has been done, there is no need for installing a mamba environment/ \"mamba activate moose\" like I typically need to do? I don't fully understand how the installation works, could you please explain what happens in each one and the differences between the two?\nAlso, I don't have system-level permissions, so if I need to, say \"update\" MOOSE (or any other operation like that) would I need to make a request each time? In short, what are the key differences between each installation type?\nAnd I assume that after cloning the directory\nmkdir -p ~/projects\ncd ~/projects\ngit clone https://github.com/idaholab/moose.git\ncd moose\ngit checkout master\n\neverything else works the same (i.e creating an application, running the application, adding custom kernels/materials, etc)?\nAlso, does the application folder have to be in the same \"projects\" folder as moose or can it be in a different folder (or even a different partition) and just refer to the moose folder?",
          "url": "https://github.com/idaholab/moose/discussions/25286",
          "updatedAt": "2023-08-24T14:47:22Z",
          "publishedAt": "2023-08-23T19:25:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "Specialized HPC MPI vs Conda supplied MPI\nWhen operating on HPC Clusters, it is recommended to use that cluster's approved compilers, especially with MPI enabled binaries. Such is the case with MOOSE applications. Every cluster is differently optimized. And the administrators who built the cluster also (should) provide the compilers/MPI wrappers to properly use it.\nConda is more of a one-size-fits-all solution. It cannot be optimized for the above scenario. It just works. All the time, abet not as fast.\nHowever! Every lab, organization, education institution employs their own crew :) Some admins cut corners, others are high-paid perfectionist. e.g. your mileage may vary when performing benchmarks between HPC supplied compilers v's Conda's. That said, I don't think anyone will be able to tell you precisely the degradation/gains using one or the other.\nThe more cores you use, the less you see performance scaling the way it should, when using Conda compilers. If you don't plan on solving large problems (requiring thousands of cores to solve), the less you are going to notice.\nOthers on my team know more about scaling... I am sure they will voice their own comments.\nHPC Install MOOSE (module load)\n\nAfter the \"module load\" command, which I guess assumes that a system level installation has been done, there is no need for installing a mamba environment/ \"mamba activate moose\" like I typically need to do?\n\nCorrect. If you are following HPC instructions, no use of Conda is involved.\nThe differences stem from MOOSE's requirement to be built using the same compilers used to build its dependencies (PETSc and libMesh). It is therefore the reason why you are required to build these two libraries yourself, using your HPC's compiler stack.\nIf you are using Conda, this is not necessary because we can supply not only PETSc and libMesh, but also the compilers used to create these two libraries.\n\nAlso, I don't have system-level permissions, so if I need to, say \"update\" MOOSE (or any other operation like that) would I need to make a request each time? In short, what are the key differences between each installation type?\n\nYou should be cloning your own copy of the MOOSE repository into a place where only you have write access (your HOME directory somewhere). Meaning, it is your responsibility to update it. When you need to/want to. Some labs have tried to supply a pre-built MOOSE for their customers. In my own opinion this sounds like a nightmare.\nWe don't recommend this.\nWhen developing your MOOSE based application, you are going to need write access into the MOOSE repository (all those .C files during built create object files). In order for this to work in a multi-user fashion, everyone involved would need write access to the MOOSE repository. Clobbering each other previous build while they work. -a nightmare.\nAfter cloning\n\nAnd I assume that after cloning the directory...\n\nAll correct. You can begin MOOSE based development in any directory you have write access in. ~/projects was chosing strictly for documentation purposes. Your application does not need to co-exist next to where you cloned MOOSE. However, if it is not, you will need to set an environment variable explaining to your MOOSE based application where it is:\nexport MOOSE_DIR=/some/path/to/moose\n# e.g. this is equivalent to the following according your demonstrated code block\nexport MOOSE_DIR=~/projects/moose",
                  "url": "https://github.com/idaholab/moose/discussions/25286#discussioncomment-6806543",
                  "updatedAt": "2023-08-23T20:16:21Z",
                  "publishedAt": "2023-08-23T20:16:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "This is incredibly helpful, thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/25286#discussioncomment-6806820",
                          "updatedAt": "2023-08-23T21:00:07Z",
                          "publishedAt": "2023-08-23T21:00:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "Adding a little bit of our own experience of running stuff on shared clusters (in case it is helpful):\n\nIf you build MOOSE with all modules in a location that others can also access, you can create a shared library that others can build against so long as they also enable all modules in their make file. They then don't need write access to that file to build so you can lock it down. This gets around the issue of everyone having to have their own local copy. It does trade off against (as far as I can tell) a small overhead but is worthwhile in my opinion. We have many users developing their apps simultaneously on the same MOOSE build without issue.\nThe above also guarantees that people can use the exact same instance of MOOSE (and libmesh and PETSc) when running apps. We have had issue in the past with different people working with different local versions of MOOSE (even by only a couple of weeks) which can break things or lead to different results. This approach really eradicates that issue.\nRolling back to older versions of MOOSE: this can be difficult as trying to match up the correct versions of build dependencies is not trivial. This approach effectively gives fixed versions that people can roll back to in future with ease. It's helped in the past with working out what changes broke some things. I know that this isn't the intended use of MOOSE but sometimes needs must when you are stuck.\nThese builds are automatable, a good HPC sys admin should be able to do it, so long term it has low overhead.\nConda was not designed for HPC, avoid it if you can. You will get significant speed up if you use the compilers and specialised built libraries your HPC sys admin supplies, don't be surprised if it is a factor of 2 or more. Also try different MPI implementations on your system, you can get very different performance depending on how they were built.\nWhen running on HPC nodes, you may find some performance benefit if you run slightly under max core count (at least in some cases we have). So if you have 10 cores on a node, try running with 9. I think this has something to do with leaving a core free to run the background tasks on the node and minimise context switching.\n\nHope that's useful!",
                          "url": "https://github.com/idaholab/moose/discussions/25286#discussioncomment-6813052",
                          "updatedAt": "2023-08-24T12:54:30Z",
                          "publishedAt": "2023-08-24T12:54:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "It really is! Seems like a system level installation + shared folder development is the way to go. Thank you!!",
                          "url": "https://github.com/idaholab/moose/discussions/25286#discussioncomment-6814236",
                          "updatedAt": "2023-08-24T14:47:23Z",
                          "publishedAt": "2023-08-24T14:47:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Lumped model heat structure maximum temperature too high",
          "author": {
            "login": "asm-fakhrul"
          },
          "bodyText": "After dividing my 1 MW lumped core into three rings, the maximum temperature in each heat structure is too high (between 2300 and 3000 K). Apparently, others have seen similar results in the past. Excerpting from a paper (https://publications.anl.gov/anlpubs/2019/10/156426.pdf) that reports their SAM lumped model results for the 600 MW MHTGR design:\n\"It was quickly found that the simplified ring model did not produce correct solid temperatures, which is too high as the thickness of heat structures are too large. A detailed ring model is then developed.\"\nThe authors then updated their lumped model from having 11 coolant channels and 22 heat structures to having 33 coolant channels and 66 heat structures.\nIs a three-ring lumped model in MOOSE not sufficient to capture the thermal hydraulics reliably? Are there any recommendations as to how many rings should/must be used for a good lumped model assumption?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/25263",
          "updatedAt": "2023-08-24T13:24:39Z",
          "publishedAt": "2023-08-21T23:25:43Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think the best people to comment on this are the authors of this report\n@rhu @lingzou\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25263#discussioncomment-6792097",
                  "updatedAt": "2023-08-22T13:43:34Z",
                  "publishedAt": "2023-08-22T13:43:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "asm-fakhrul"
                          },
                          "bodyText": "Gently trying to bring the thread to the authors' attention.",
                          "url": "https://github.com/idaholab/moose/discussions/25263#discussioncomment-6804771",
                          "updatedAt": "2023-08-23T16:18:34Z",
                          "publishedAt": "2023-08-23T16:18:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lingzou"
                          },
                          "bodyText": "Hi @asm-fakhrul, to answer your question, I may need your help to clarify some context of your question.\nThe ring-model developed in the report you have cited was for prismatic HTGR. Is your reactor design also prismatic HTGR? Are you using MOOSE or SAM?\nIt's difficult to answer your question on number of rings are sufficient without knowing pretty nothing about your problem on hand.",
                          "url": "https://github.com/idaholab/moose/discussions/25263#discussioncomment-6806439",
                          "updatedAt": "2023-08-23T19:59:44Z",
                          "publishedAt": "2023-08-23T19:59:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alfoa"
                          },
                          "bodyText": "@lingzou see below:",
                          "url": "https://github.com/idaholab/moose/discussions/25263#discussioncomment-6807059",
                          "updatedAt": "2023-08-23T21:39:56Z",
                          "publishedAt": "2023-08-23T21:39:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "asm-fakhrul"
                  },
                  "bodyText": "Yes, it's a prismatic HTGR design.\nI am using MOOSE.",
                  "url": "https://github.com/idaholab/moose/discussions/25263#discussioncomment-6806878",
                  "updatedAt": "2023-08-23T21:09:39Z",
                  "publishedAt": "2023-08-23T21:09:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lingzou"
                          },
                          "bodyText": "Thank you @asm-fakhrul. In that case, I am afraid that I may not be able to provide much specific comments, since SAM (although a MOOSE-based application) has its specially built-in components to enable system analysis of reactor systems. When speaking of 'rings,' we may talk about completely different things in SAM compared what you mean in your MOOSE simulations.",
                          "url": "https://github.com/idaholab/moose/discussions/25263#discussioncomment-6807111",
                          "updatedAt": "2023-08-23T21:49:43Z",
                          "publishedAt": "2023-08-23T21:49:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "asm-fakhrul"
                          },
                          "bodyText": "Okay. Thank you for your response. I look forward to insight from others.",
                          "url": "https://github.com/idaholab/moose/discussions/25263#discussioncomment-6807183",
                          "updatedAt": "2023-08-23T22:03:56Z",
                          "publishedAt": "2023-08-23T22:03:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@joshuahansel",
                          "url": "https://github.com/idaholab/moose/discussions/25263#discussioncomment-6807211",
                          "updatedAt": "2023-08-23T22:08:25Z",
                          "publishedAt": "2023-08-23T22:08:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "I'm a bit unclear on the model here. Can you clarify your model geometry/setup here? You're coupling 2D heat structures to flow channels? In this \"ring model\", how are all of the flow channels modeled? I don't know how this works.\nIn any case, this sounds like a question of experience making simplified 2D RZ models of reactor cores. I have never tried this, so I doubt I will be of much help. I can answer questions about how the components work and what is possible.",
                          "url": "https://github.com/idaholab/moose/discussions/25263#discussioncomment-6813318",
                          "updatedAt": "2023-08-24T13:22:01Z",
                          "publishedAt": "2023-08-24T13:22:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@snschune has experience in this I think",
                          "url": "https://github.com/idaholab/moose/discussions/25263#discussioncomment-6813343",
                          "updatedAt": "2023-08-24T13:24:39Z",
                          "publishedAt": "2023-08-24T13:24:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "boundary_id_offset",
          "author": {
            "login": "tctheodosiou"
          },
          "bodyText": "Hello,\nIs it possible to have MOOSE keep track of boundary IDs and create proper numbering (i.e. without conflicts).\nBecause setting manually the boundary_id_offset for every object created, can be the source of many errors especially if the input file is reorganized (e.g. an object is replaced by another one with different number of boundaries etc.).\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/25292",
          "updatedAt": "2023-08-25T05:32:04Z",
          "publishedAt": "2023-08-24T07:21:53Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNot right now for most meshing objects. Many have special accomodations to avoid overriding boundary/block ids (stitching / combiners for examples)\nThe reactor module RGMB workflow makes sure to handle that for the user. But the generality offered by the other general meshing tools does not allow for that automatic setting currently.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25292#discussioncomment-6813332",
                  "updatedAt": "2023-08-24T13:23:54Z",
                  "publishedAt": "2023-08-24T13:23:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ParsedMaterial",
          "author": {
            "login": "selarem"
          },
          "bodyText": "Hi moose developpers,\nwe have implemented a material model that needs to input a  vector variable. Everything is working as expected.\nTo apply the model for more complex situations, we want the vector  a function of (x,y,z, ... and includes random aspects).\nI tried using ParsedMaterial.\n[./define_x]\n   type = ParsedMaterial\n   args= 'x y z'\n   f_name = 'Xvect'\n   function = 'x + y +z'\n  [../]\n\nand wrote :\nplane_normal = 'Xvect Xvect/2  Xvect/3.0'\ncannot convert field 'Materials/Stress/plane_normal' value 'Xvect' to float.\nThanks for any help.\nSab",
          "url": "https://github.com/idaholab/moose/discussions/24758",
          "updatedAt": "2023-08-24T13:07:35Z",
          "publishedAt": "2023-06-21T12:37:11Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou are trying to define a vector material property right?\nif so you ll need to proceed component by component, or create a parsedVectorMaterial\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6242268",
                  "updatedAt": "2023-06-21T13:52:17Z",
                  "publishedAt": "2023-06-21T13:52:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Hello,\nThank you for your reply.\nEven when using the ParsedVectorFunction the error remains the same \"cannot convert field 'Kernels/ACInterfaceCleavageFracture/cleavage_plane_normal' value 'vectorexp' to float\"\nThe input file Function bloc looks as follows :\n[Functions]\n  [vectorexp]\n    type = ParsedVectorFunction\n    expression_x = 'x'\n    expression_y = 'y/2'\n    expression_z = '0'\n  [../]\n[]\n\nAnd the Kernel :\n  [ACInterfaceCleavageFracture]\n    type = ACInterfaceCleavageFracture\n    variable = c\n    beta_penalty = 1\n    cleavage_plane_normal = vectorexp\n  [../]",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6249975",
                          "updatedAt": "2023-06-22T16:00:19Z",
                          "publishedAt": "2023-06-22T08:58:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Hello,\nThe issue is resolved, we managed to fix the problem and the kernel can now read the parsed vector function coordinates. Though we now have another question : while making sure that the coordinates are different for each element of the mesh (by printing out the x and y coordinates) we only got the values for one element, so only 4 values (we assume these are values for each qp of the element) even when our mesh is composed of 2 or 3 or more elements. The question is why does it only print out values for one of the elements, and why is it the last element (almost always).\nOn a related note, I have a question regarding the SetupQuadratureAction (I am attempting to have one quadrature point for each element instead of four), I am unsure about the distinction between the 'order' and 'element order' input parameters  and if you could provide an explanation, it would be greatly appreciated.\nThank you :)\nNour",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6252703",
                          "updatedAt": "2023-06-22T14:13:48Z",
                          "publishedAt": "2023-06-22T14:13:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "order is the general one, then element_order and side_order are for differentiating",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6253865",
                          "updatedAt": "2023-06-22T16:02:06Z",
                          "publishedAt": "2023-06-22T16:02:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so you added prints inside your material and only saw one element?\nAre you using the software in parallel?\nIs the material block restricted? Is it constant per element?",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6255090",
                          "updatedAt": "2023-06-22T18:37:41Z",
                          "publishedAt": "2023-06-22T18:37:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "This is what the input file looks like with a 3 element mesh:\n[Mesh]\n  [mesh]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmax =3\n    nx = 3\n    ny = 1\n    elem_type = quad4\n[]\n[]\n\n[Functions]\n  [vectorexp]\n    type = ParsedVectorFunction\n    expression_x = 'x'\n    expression_y = 'y'\n    expression_z = '0'\n  [../]\n[]\n\n[Kernels]\n[./ACInterfaceCleavageFracture]\n    type = meACInterfaceCleavageFracture\n    variable = c\n    beta_penalty = 1\n    cleavage_plane_normal = vectorexp\n  [../]\n\nwith the meACInterfaceCleavageFracture including the print option here's the excerpt from this file :\nmeACInterfaceCleavageFracture::meACInterfaceCleavageFracture(const InputParameters & parameters)\n  : ACInterface(parameters),\n    _beta_penalty(getParam<Real>(\"beta_penalty\")),\n   _cleavage_plane_normal2(getFunction(\"cleavage_plane_normal\"))\n{\n}\n\nReal\nmeACInterfaceCleavageFracture::betaNablaPsi()\n{\n\nlibMesh::VectorValue<Real> _cleavage_plane_normal ;\n_cleavage_plane_normal(0) = _cleavage_plane_normal2.vectorValue(_t, _q_point[_qp])(0);\n_cleavage_plane_normal(1) = _cleavage_plane_normal2.vectorValue(_t, _q_point[_qp])(1);\n_cleavage_plane_normal(2) = _cleavage_plane_normal2.vectorValue(_t, _q_point[_qp])(2);\n\nstd::cout << \"from K\"<< _cleavage_plane_normal(0) << \" \" << _cleavage_plane_normal(1) << \" \" << _cleavage_plane_normal(2)<< std::endl ;\n\n\nand here's the output where we have a repetitive 4 points coordinates printout :\nTime Step 1, time = 5e-05, dt = 5e-05\nfrom K2.21132 0.211325 0\nfrom K2.78868 0.211325 0\nfrom K2.21132 0.788675 0\nfrom K2.78868 0.788675 0\nfrom K2.21132 0.211325 0\nfrom K2.78868 0.211325 0\nfrom K2.21132 0.788675 0\nfrom K2.78868 0.788675 0\nfrom K2.21132 0.211325 0\nfrom K2.78868 0.211325 0\nfrom K2.21132 0.788675 0\nfrom K2.78868 0.788675 0\nfrom K2.21132 0.211325 0\nfrom K2.78868 0.211325 0\nfrom K2.21132 0.788675 0\nfrom K2.78868 0.788675 0\nfrom K2.21132 0.211325 0\nfrom K2.78868 0.211325 0\nfrom K2.21132 0.788675 0\nfrom K2.78868 0.788675 0\nfrom K2.21132 0.211325 0\nfrom K2.78868 0.211325 0\nfrom K2.21132 0.788675 0\nfrom K2.78868 0.788675 0\nfrom K2.21132 0.211325 0\nfrom K2.78868 0.211325 0\nfrom K2.21132 0.788675 0\nfrom K2.78868 0.788675 0\nfrom K2.21132 0.211325 0\nfrom K2.78868 0.211325 0\nfrom K2.21132 0.788675 0\nfrom K2.78868 0.788675 0\n 0 Nonlinear |R| = ^[[32m0.000000e+00^[[39m\n^[[32m Solve Converged!^[[39m",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6259041",
                          "updatedAt": "2023-06-23T06:53:30Z",
                          "publishedAt": "2023-06-23T06:49:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Our main concern is to check whether we get distinct cleavage plane normals for each qp with this syntax or if it's the same cleavage plane normal for all qps.",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6260554",
                          "updatedAt": "2023-06-23T09:46:20Z",
                          "publishedAt": "2023-06-23T09:46:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Problem solved, we are now able to input a different vector for each gaussian point.\nWe now would like to be able to input random vector components (using ParsedVectorFunction or any equivalent syntax in the input file). In fact, we want this vector to remain unchanged during the entire computation, for each qp.\nRegards,\nNour",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6263047",
                          "updatedAt": "2023-06-23T15:41:29Z",
                          "publishedAt": "2023-06-23T14:43:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou ll want to use the RandomIC on a variable then use that for the random number\nIf it s not quite what you want and you cant find a conversion from the variable to what you need you can make a new object in the category you need and use the RandomInterface\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6271132",
                          "updatedAt": "2023-06-24T22:45:23Z",
                          "publishedAt": "2023-06-24T22:45:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "thank you Guillaume for your reply,\nI thought that RandomIC is for initial conditions like initial temperature or damage, ... to initiate variables we are solving for.\nBut what we want is something like this\n[Functions]\n  [vectorexp]\n    type = ParsedVectorFunction\n    expression_x = 'sin(x)*cos(y)'\n    expression_y = 'cos(x)*sin(2*y)'\n    expression_z = '0'\n  [../]\n[]\n\nwith some random instead of sine or cosine functions. By the way I wanted to know the list of availble functions.\nI know that in C++ we could have random using the standard library, but how to have this possible in input files ?\nregards,",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6280397",
                          "updatedAt": "2023-06-26T14:57:18Z",
                          "publishedAt": "2023-06-26T09:54:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nno you can't call C++ directly from the input file sadly.\nI was thinking the randomIC would give you a field of random values and you could use that later on.\nIn a function, you would not be able to use a variable though. Only in another auxvariable or a material could you use the value of a variable.\nIt seems you will have to code your own object, or look at adding rand() in the operations that the Parsed expressions support\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6283225",
                          "updatedAt": "2023-06-26T14:58:59Z",
                          "publishedAt": "2023-06-26T14:58:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "If coded inside a material, the random property will change at every time\nstep which is not what we want. We want something like  grains orientation\nin CP that could be randomly fixed at the beginning of the computation and\nremains unchanged after.\nRegards\n\nLe mar. 27 juin 2023, 17:55, Guillaume Giudicelli ***@***.***>\na \u00e9crit :\n\u2026\n tbh it would be easier to code a new material with the expression you need\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24758 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AFBUGDH4GVLVZ2HOQEV3U4DXNL7AXANCNFSM6AAAAAAZOV5VZI>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6296381",
                  "updatedAt": "2023-06-27T17:18:40Z",
                  "publishedAt": "2023-06-27T17:18:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no you can fix a material property to its initial value\nset compute = false and compute it only once",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6296469",
                          "updatedAt": "2023-06-27T17:29:26Z",
                          "publishedAt": "2023-06-27T17:29:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "Normally it should not be that complicated. We have been trying with\ninitQpStatefulProperties,  initialSetup and the class constructor and\nobtained undesirable outputs. I wonder what the initialization methods are\nused for and when are they called. Example when (in\ninitQpStatefulProperties) I use _q_point[_qp] in a vector components that I\nwant to vary for each qp, I obtain the same vector for all elements which\nis the one corresponding to the last qp.\nI could provide more example to show that it is not clear for me how things\nwork and interact in moose.\nRegards,\n\n\nLe mar. 27 juin 2023, 19:29, Guillaume Giudicelli ***@***.***>\na \u00e9crit :\n\u2026\n no you can fix a material property to its initial value\n set compute = false and compute it only once\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24758 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AFBUGDFUJTH6WM7L3MBKZNLXNMKABANCNFSM6AAAAAAZOV5VZI>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6313166",
                  "updatedAt": "2023-06-29T08:58:12Z",
                  "publishedAt": "2023-06-29T08:58:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I raised an issue.\nI m not sure you want a stateful material?\nStateful material are meant to be able to retrieve an old value from a material property, to build semi-explicit schemes (explicit in some properties)\nDont you just want a \"constant\" property? Initialized once with a random field and that's it?",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6316183",
                          "updatedAt": "2023-06-29T14:41:45Z",
                          "publishedAt": "2023-06-29T14:41:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "We would like to have  a RealVectorValue which is randomly generated for\neach _qp. Once generated it remains constant during the computation.\nLike if we generate a Young modulus  or a Poisson ratio that depends on the\n_qp initial coordinates.\nregards,\n\n\nLe jeu. 29 juin 2023 \u00e0 16:41, Guillaume Giudicelli ***@***.***>\na \u00e9crit :\n\u2026\n I raised an issue.\n\n I m not sure you want a stateful material?\n Stateful material are meant to be able to retrieve an old value from a\n material property, to build semi-explicit schemes (explicit in some\n properties)\n\n Dont you just want a \"constant\" property? Initialized once with a random\n field and that's it?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24758 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AFBUGDBWPR55IB26X7JOOPTXNWH3HANCNFSM6AAAAAAZOV5VZI>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6316512",
                  "updatedAt": "2023-06-29T15:04:58Z",
                  "publishedAt": "2023-06-29T15:04:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think this was mentioned already but this should work:\nLook at the time step in the material, and only compute the material if the current time step is equal to the first time step",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6317864",
                          "updatedAt": "2023-06-29T17:25:28Z",
                          "publishedAt": "2023-06-29T17:25:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "I have tried this, it generates the same random vector  for all _qp. What we want is one different vector for each _qp.\nif (_t == _dt){\nstd::cout <<\"Element  = :\" <<  _current_elem->id() << std::endl;\nRealVectorValue cp;\ncp(0) = MooseRandom::rand();\ncp(1) = MooseRandom::rand();\ncp(2) = 0.0*MooseRandom::rand();\nstd::cout << \" VectorX0 \"<< cp(0) <<\" VectY0 \"<< cp(1) <<\" VectZ0 \" << cp(2) << \" norm0 \" << cp.norm()  << std::endl;\nReal normeCP = std::sqrt(std::pow(cp(0),2) + std::pow(cp(1),2) + std::pow(cp(2),2) ) ;\ncp(0)/=normeCP;\ncp(1)/=normeCP;\ncp(2)/=normeCP;\nstd::cout << \" VectorX  = \"<< cp(0) <<\" VectY =  \"<< cp(1) <<\" VectZ =  \" << cp(2) << \" norm =  \" << cp.norm()  << std::endl;\n_rand_cleavage_plane_normal[_qp] = cp;\n}\nWhen using one single element (_qp):\nTime Step 1, time = 5e-08, dt = 5e-08\nElement  = :0\nVectorX0 0.548814 VectY0 0.715189 VectZ0 0 norm0 0.901494\nVectorX  = 0.608782 VectY =  0.793338 VectZ =  0 norm =  1\n\nVectorX 0.608782 VectY 0.793338 VectZ 0 norm 1\nElement  = :0\nVectorX0 0.544883 VectY0 0.423655 VectZ0 0 norm0 0.690204\nVectorX  = 0.789453 VectY =  0.613811 VectZ =  0 norm =  1\n\nVectorX 0.789453 VectY 0.613811 VectZ 0 norm 1\nElement  = :0\nVectorX0 0.437587 VectY0 0.891773 VectZ0 0 norm0 0.993349\nVectorX  = 0.440517 VectY =  0.897744 VectZ =  0 norm =  1\n\nVectorX 0.440517 VectY 0.897744 VectZ 0 norm 1\nElement  = :0\nVectorX0 0.383442 VectY0 0.791725 VectZ0 0 norm0 0.879691\nVectorX  = 0.435882 VectY =  0.900004 VectZ =  0 norm =  1\n\nVectorX 0.435882 VectY 0.900004 VectZ 0 norm 1\nElement  = :0\nVectorX0 0.568045 VectY0 0.925597 VectZ0 0 norm0 1.086\nVectorX  = 0.52306 VectY =  0.852296 VectZ =  0 norm =  1\n\nVectorX 0.52306 VectY 0.852296 VectZ 0 norm 1\n^[[32m Solve Converged!^[[39m\nElement  = :0\nVectorX0 0.0871293 VectY0 0.0202184 VectZ0 0 norm0 0.0894444\nVectorX  = 0.974117 VectY =  0.226044 VectZ =  0 norm =  1\n\nVectorX 0.974117 VectY 0.226044 VectZ 0 norm 1\nTime Step 2, time = 1e-07, dt = 5e-08\nElement  = :0\n\nVectorX 0.974117 VectY 0.226044 VectZ 0 norm 1\nElement  = :0\n\nVectorX 0.974117 VectY 0.226044 VectZ 0 norm 1\nElement  = :0\n\nWhen unsing  2 Elements:\nElement  = :0\nVectorX0 0.118274 VectY0 0.639921 VectZ0 0 norm0 0.650759\nVectorX  = 0.181748 VectY =  0.983345 VectZ =  0 norm =  1\n\nVectorX 0.181748 VectY 0.983345 VectZ 0 norm 1\nElement  = :1\nVectorX0 0.944669 VectY0 0.521848 VectZ0 0 norm0 1.07922\nVectorX  = 0.875322 VectY =  0.48354 VectZ =  0 norm =  1\n\nVectorX 0.875322 VectY 0.48354 VectZ 0 norm 1\n^[[32m Solve Converged!^[[39m\nElement  = :0\nVectorX0 0.264556 VectY0 0.774234 VectZ0 0 norm0 0.818185\nVectorX  = 0.323344 VectY =  0.946281 VectZ =  0 norm =  1\n\nVectorX 0.323344 VectY 0.946281 VectZ 0 norm 1\nElement  = :1\nVectorX0 0.568434 VectY0 0.0187898 VectZ0 0 norm0 0.568744\nVectorX  = 0.999454 VectY =  0.0330373 VectZ =  0 norm =  1\n\nVectorX 0.999454 VectY 0.0330373 VectZ 0 norm 1\nTime Step 2, time = 1e-07, dt = 5e-08\nElement  = :0\n\nVectorX 0.999454 VectY 0.0330373 VectZ 0 norm 1\nElement  = :1\n\nVectorX 0.999454 VectY 0.0330373 VectZ 0 norm 1\nElement  = :0\n\nVectorX 0.999454 VectY 0.0330373 VectZ 0 norm 1\nElement  = :1\n\nVectorX 0.999454 VectY 0.0330373 VectZ 0 norm 1",
                  "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6323513",
                  "updatedAt": "2023-06-30T08:57:32Z",
                  "publishedAt": "2023-06-30T08:57:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ah i remember now why we wanted stateful material properties.\nSo once you have that random field on the first time step, you ll want to retrieve it in your code as the \u201cold\u201d material property",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6325452",
                          "updatedAt": "2023-06-30T12:23:28Z",
                          "publishedAt": "2023-06-30T12:23:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "Thank you for your answers and time.\nI can not believe it needs that  much time to properly implement a very common feature.\nThus,  I am going to mimic random behavior by using trigonometric functions with high frequencies.",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6371512",
                          "updatedAt": "2023-07-06T08:31:32Z",
                          "publishedAt": "2023-07-06T08:31:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "The easiest way to solve the problem is  to make random at initQpStatefulProperties and then retrieve it as \"old\" material property.\nregards,",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6813191",
                          "updatedAt": "2023-08-24T13:07:36Z",
                          "publishedAt": "2023-08-24T13:07:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": null,
                  "bodyText": "Hello\nYou ll want to use the RandomIC on a variable then use that for the random number If it s not quite what you want and you cant find a conversion from the variable to what you need you can make a new object in the category you need and use the RandomInterface\nGuillaume\n\nHello,\nWe're still trying to input random vector components using ParsedVectorFunction (we want this vector to remain unchanged during the entire computation, for each qp). We're trying to use RandomIC in the input file as follows :\n[ICs]\n  [vectyy]\n    type = RandomIC\n    min = 0\n    max = 1\n    variable = vecty\n  []\n  [vectxx]\n    type = RandomIC\n    min = 0\n    max = 1\n    variable = vectx\n  []\n[]\n\nTo use in the Function :\n\n[Functions]\n  [vectorexp]\n    type = ParsedVectorFunction\n    expression_x = 'vectx + x'\n    expression_y = 'vecty + y'\n    expression_z = '0'\n  [../]\n[]\n\nWe have defined the AuxVariables :\n[AuxVariables]\n  [./vectx]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[./vecty]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\nBut we get the error message libMesh terminating:\nERROR: FunctionParser is unable to parse expression: vectx + x\nSo how can we fix this ? Thank you.\nRegards,\nNour",
                  "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6793464",
                  "updatedAt": "2023-08-22T15:46:16Z",
                  "publishedAt": "2023-08-22T15:46:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nYou cannot use ParsedVectorFunction with variables.\nVariables are semantically not known at the beginning of a simulation, while a Function should mostly be a known quantity at the beginning of the simulation./\nUse this instead to build an auxvariable with the expression desired\nhttps://mooseframework.inl.gov/source/auxkernels/ParsedVectorAux.html",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6793647",
                          "updatedAt": "2023-08-22T16:07:06Z",
                          "publishedAt": "2023-08-22T16:07:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "We want random !\n\nLe mar. 22 ao\u00fbt 2023, 18:07, Guillaume Giudicelli ***@***.***>\na \u00e9crit :\n\u2026\n hello\n\n You cannot use ParsedVectorFunction with variables.\n Variables are semantically not known at the beginning of a simulation,\n while a Function should mostly be a known quantity at the beginning of the\n simulation./\n\n Use this instead to build an auxvariable with the expression desired\n https://mooseframework.inl.gov/source/auxkernels/ParsedVectorAux.html\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24758 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AFBUGDHWGBUAB7LOLJHQUX3XWTKLJANCNFSM6AAAAAAZOV5VZI>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6794157",
                  "updatedAt": "2023-08-22T16:54:24Z",
                  "publishedAt": "2023-08-22T16:54:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can do randomIC on an auxvariable then use that randomly populated field later in a ParsedVectorAux, that s not a problem",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6794245",
                          "updatedAt": "2023-08-22T17:04:42Z",
                          "publishedAt": "2023-08-22T17:04:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I guess you are trying to convert the auxvariable to a material property next? For that you can use the ParsedMaterial with that randomIC-initialzed auxvariable",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6794252",
                          "updatedAt": "2023-08-22T17:05:27Z",
                          "publishedAt": "2023-08-22T17:05:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Thank you for your reply.\nWe have followed your suggestion and defined our AuxVariables:\n[vectx]\nfamily = MONOMIAL\n[]\n[vecty]\nfamily = MONOMIAL\n[]\n[parsed]\nfamily = MONOMIAL_VEC\n[]\nthen we expressed the parsed variable in the AuxKernels as:\n[parsed]\ntype = ParsedVectorAux\nvariable = parsed\nexpression_x = ' vectx'\nexpression_y = ' vecty'\ncoupled_variables = 'vectx vecty'\nuse_xyzt = true\n[]\nand  IC as:\n[ICs]\n[ppwater]\ntype = RandomIC\nvariable = vectx\nmin = 0\nmax = 10.0\n[]\n[ICvecty]\ntype = RandomIC\nvariable = vecty\nmin = 0\nmax = 10.0\n[]\n[]\nand all this work fine.\nBut our Material models needs to read a vectorValue property\n_cp2(getMaterialProperty <RealVectorValue> (\"MyDirection\")),\nSo in the Material block we wrote :\n[./damage]\ntype = MyDirectionalFracture\nMyDirection = parsed\n[../]\nSince with ParsedMaterial, we could not enter a vector expression.\nWe have also tried with ParsedVectorFunction again and both do not work.\nregards,",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6801091",
                          "updatedAt": "2023-08-23T10:30:33Z",
                          "publishedAt": "2023-08-23T10:28:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I don\u2019t think there s a ParsedVectorMaterial you could use.\nYou d have to make it.\nIs this your code? Can you switch from using a vector material property to specifying each of the components? Then you could take a ParsedMaterial",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6802549",
                          "updatedAt": "2023-08-23T13:02:10Z",
                          "publishedAt": "2023-08-23T13:02:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Do you have a clear idea about what we should do to solve this problem or are you  trying to answer our questions individually ?\nWe are looking for a solution and spent a lot of  time trying.\nWe want to be able to initiate   random vector components. One vector for each qp that does not change during the computation. It should not take two months of back and forth for us to still not be on the same page regarding this question.\nRegarding your last suggestion of specifying each component, we've done that in the .C file as :\n_cp0(getMaterialProperty<Real>(\"vectx\")),\n   _cp1(getMaterialProperty<Real>(\"vecty\")),\n   _cp2(getMaterialProperty<Real>(\"vectz\")),\n\n\nin the input parameter properties. And then in the input file we defined the Material blocks:\n[./vectx1111]\n    type = ParsedMaterial\n    expression = '2*vectx'\n    property_name = vectx\n    material_property_names = 'vectx'\n  [../]\n    [./vecty22222]\n    type = ParsedMaterial\n    expression = 55\n    property_name = vecty\n    material_property_names = 'vecty'\n  [../]\n[./vectz1111]\n    type = ParsedMaterial\n    expression = '0.0'\n    property_name = vectz\n    material_property_names = 'vectz'\n  [../]\n\nWith IC\n[ICs]\n  [vectyy]\n    type = RandomIC\n    min = -1000\n    max = 1000\n    seed = 100\n    variable = vecty\n  []\n  [vectxx]\n    type = RandomIC\n    min = -1000\n    seed = 1000\n    max = 1000\n    variable = vectx\n  []\n[]\n\nAnd AuxVariables\n[vectx]\nfamily = MONOMIAL\n[]\n[vecty]\nfamily = MONOMIAL\n[]\n\nBy printing out the vector coordinates from the C file we get 0, 55, 0 respectively for vectx vecty vectz.\nHow can we proceed from this?",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6803785",
                          "updatedAt": "2023-08-23T14:49:28Z",
                          "publishedAt": "2023-08-23T14:48:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is wrong\n[./vectx1111]\n    type = ParsedMaterial\n    expression = '2*vectx'\n    property_name = vectx\n    material_property_names = 'vectx'\n  [../]\n    [./vecty22222]\n    type = ParsedMaterial\n    expression = 55\n    property_name = vecty\n    material_property_names = 'vecty'\n  [../]\n[./vectz1111]\n    type = ParsedMaterial\n    expression = '0.0'\n    property_name = vectz\n    material_property_names = 'vectz'\n  [../]\n\nit should be\n[./vectx1111]\n    type = ParsedMaterial\n    expression = '2*vectx'\n    property_name = vectx\n    coupled_variables = 'vectx'\n  [../]\n    [./vecty22222]\n    type = ParsedMaterial\n    expression = 55\n    property_name = vecty\n    coupled_variables = 'vecty'\n  [../]\n[./vectz1111]\n    type = ParsedMaterial\n    expression = '0.0'\n    property_name = vectz\n    coupled_variables = 'vectz'\n  [../]\n\nvectxyz as an input is not a material property it s an auxiliary variable.",
                          "url": "https://github.com/idaholab/moose/discussions/24758#discussioncomment-6807772",
                          "updatedAt": "2023-08-24T00:15:20Z",
                          "publishedAt": "2023-08-24T00:15:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}