{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNi0yNFQyMzoxMTozMy0wNjowMM4ANEcF"
    },
    "edges": [
      {
        "node": {
          "title": "Tensor contractions",
          "author": {
            "login": "matthiasneuner"
          },
          "bodyText": "Hi,\nI just saw pull request  #18174  which introduces new higher order tensor contractions.\nI thought it would be useful to promote the existence of Fastor (https://github.com/romeric/Fastor), which is a templated, header only, vectorized Tensor library aiming at similar functionality as MOOSE's 2nd, 3rd and 4th order tensor implementations.\nHowever, its mighty Einstein summation functionality allows to write tensor operations in a  convenient and readable way.\nI make use of Fastor in a lot of projects (including MOOSE applications, e.g.  https://github.com/matthiasneuner/chamois/blob/08ce1819ef6931539b9c2e3a6d1bfa4f32d95e8c/src/materials/ComputeMarmotMaterialGradientEnhancedMicropolar.C#L222)\nBest regards, Matthias",
          "url": "https://github.com/idaholab/moose/discussions/18194",
          "updatedAt": "2022-07-12T16:12:14Z",
          "publishedAt": "2021-06-28T19:07:06Z",
          "category": {
            "name": "Show and tell"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Could you leave a comment in that PR? I'm very supportive of adding an Einstein summation method. Manually adding all the contractions wouldn't be tractable in the long run and is very difficult to maintain.",
                  "url": "https://github.com/idaholab/moose/discussions/18194#discussioncomment-935063",
                  "updatedAt": "2022-07-12T16:12:14Z",
                  "publishedAt": "2021-06-28T20:22:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Thanks Matthias, this is a great pointer. We could probably use TensorMap on our existing data structures.",
                  "url": "https://github.com/idaholab/moose/discussions/18194#discussioncomment-935312",
                  "updatedAt": "2022-07-12T16:12:14Z",
                  "publishedAt": "2021-06-28T21:44:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "An old application isn't working with the new version of MOOSE",
          "author": {
            "login": "ahmad681"
          },
          "bodyText": "Hi, I am new to the MOOSE environment and a senior graduate student in our group has developed a code in tensor mechanics based off of the older version of MOOSE, 3 years older. With the newer version, there seems to be newer classes that have been deleted or altered and we are afraid of rewriting the code again because there might undermining problems as the MOOSE code is huge. Can you please help me with this issue?",
          "url": "https://github.com/idaholab/moose/discussions/18058",
          "updatedAt": "2022-08-23T14:31:48Z",
          "publishedAt": "2021-06-10T20:00:09Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "Can you share the repository with us (if not public, sharing it privately is okay). I can take a quick look to gauge the amount of support needed here.",
                  "url": "https://github.com/idaholab/moose/discussions/18058#discussioncomment-855485",
                  "updatedAt": "2022-08-23T14:31:48Z",
                  "publishedAt": "2021-06-10T20:28:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Any news on this?\nI would just try compiling it and going through the error messages one by one. There's been a lot of changes, but hopefully a lot of APIs were stabilized already by then.",
                  "url": "https://github.com/idaholab/moose/discussions/18058#discussioncomment-899783",
                  "updatedAt": "2022-08-23T14:32:14Z",
                  "publishedAt": "2021-06-21T20:18:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ahmad681"
                  },
                  "bodyText": "Sorry for the late reply Logan and Giud, Yes we figured it out. we went through every single error messege and corrected for it. Thank you",
                  "url": "https://github.com/idaholab/moose/discussions/18058#discussioncomment-934756",
                  "updatedAt": "2022-08-23T14:32:16Z",
                  "publishedAt": "2021-06-28T18:42:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Accessing The Mesh Block IDs From Within A Kernel/Material",
          "author": {
            "login": "pharshaad"
          },
          "bodyText": "Hi All,\nI was wondering how I'd be able to access different mesh block IDs inside a custom kernel or a material. I have a microstructure mesh file (.msh) in which the grains are treated as subdomains/blocks. What I'd like to do is to able to get block IDs and apply the Euler angles to them. Any insight into this is greatly appreciated!\nCheers,\nLeon",
          "url": "https://github.com/idaholab/moose/discussions/18155",
          "updatedAt": "2022-06-28T14:55:51Z",
          "publishedAt": "2021-06-23T19:35:24Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Leon\nYou can get the mesh block id from the element the kernel is currently working on with _current_elem->subdomain_id().\nFor the material it should be the same thing, looking briefly at the source code, though I have never used that.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18155#discussioncomment-911998",
                  "updatedAt": "2022-06-28T14:56:06Z",
                  "publishedAt": "2021-06-23T20:09:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pharshaad"
                          },
                          "bodyText": "Thanks for the help, Guillaume. Much appreciated!",
                          "url": "https://github.com/idaholab/moose/discussions/18155#discussioncomment-928757",
                          "updatedAt": "2022-06-28T14:56:07Z",
                          "publishedAt": "2021-06-27T16:44:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issue about recompiling codes in HPC",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Hello!\nAfter I developed several code for MOOSE, I uploaded the code in HPC.\nWhile I tried to recompile the code, I got errors like below.\n\nSo far, even I got an error about \"gfortran\", but actually compiling itself was done successfully.\nBut, this time, I don't know why this happened.\nIs there any suggestions for me?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/18177",
          "updatedAt": "2021-06-25T20:55:35Z",
          "publishedAt": "2021-06-25T20:38:27Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nLooks like you need to make sure you have MPI wrapped compilers available. Depending on which cluster you are working on, they would be available in modules. You would need to load those.\nIf there are no modules and no one set up moose for you on the cluster, then you can follow these instructions:\nhttps://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18177#discussioncomment-922802",
                  "updatedAt": "2021-06-25T20:53:07Z",
                  "publishedAt": "2021-06-25T20:52:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Because I didn't work in HPC so long, I forgot to load module which I needed in HPC.\nAfter loading modules in HPC, recompiling itself was done successfully.\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/18177#discussioncomment-922806",
                          "updatedAt": "2021-06-25T20:55:26Z",
                          "publishedAt": "2021-06-25T20:55:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "supplied material check",
          "author": {
            "login": "mghkorzani"
          },
          "bodyText": "Hi all,\nI have a question regarding material properties.\nI have a pointer material within a new material class (e.g. MatA class). I would like to see if a property name is declared by another material class  or not (e.g. MatB class). How can I check it? Because if the property is declared in MatB class, I can point my pointer material in MatA class to that property in MatB class. Otherwise, I should locally calculate the required property in my MatA class and make my pointer material null.\nI appreciate your helps.\nCheers,\nMaziar",
          "url": "https://github.com/idaholab/moose/discussions/18170",
          "updatedAt": "2022-11-03T17:24:12Z",
          "publishedAt": "2021-06-25T09:47:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Maziar\nyou can use getMaterialProperty from a material. I would create the material property in the constructor of the material, then check if it is defined in the current block in the compute properties routine.\nIf defined, then use that value\nIf not use the new material s value.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18170#discussioncomment-921007",
                  "updatedAt": "2022-11-03T17:24:20Z",
                  "publishedAt": "2021-06-25T14:10:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mghkorzani"
                  },
                  "bodyText": "Hi Guillaume,\n\n\n\nThanks for your answer.\n\nThe problem is here. I always use getMaterialProperty to read properties that are defined in other classes. However in this case, if it is not defined in another material class, I will receive an error because I tried to initialize my pointer. I tried hasMaterialProperty but did not work since it is looking for properties that are defined in its own class.\n\nMaybe it is better to explain the real problem:\n\nI try to read the strain rate from the tensor mechanics module. In the case of small strain, it is not declared but for incremental cases, it is declared as a ranktwotensor. I would like to see my material realise it by itself which means:\n\n1. In small non-incremental strain (total strain), I calculate it in my material. -> I already did the calculation.\n\n2. In incremental strain, I just get it from the tensor mechanics material property.  -> I know how to get it and I used it but I need to know in my material constructor that I should get this material or calculate it myself.\n\n\n\nCheers,\n\nMaziar\n\n\n\nFrom: Guillaume Giudicelli ***@***.***>\nSent: Friday, June 25, 2021 4:11 PM\nTo: idaholab/moose ***@***.***>\nCc: Maziar Korzani ***@***.***>; Author ***@***.***>\nSubject: Re: [idaholab/moose] supplied material check (#18170)\n\n\n\nHi Maziar\n\nyou can use getMaterialProperty from a material. I would create the material property in the constructor of the material, then check if it is defined in the current block in the compute properties routine.\n\nIf defined, then use that value\nIf not use the new material s value.\n\nGuillaume\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub <#18170 (comment)> , or unsubscribe <https://github.com/notifications/unsubscribe-auth/AHY7CALWDCMEHDYZE73RNYTTUSE7FANCNFSM47JRUWJA> .  <https://github.com/notifications/beacon/AHY7CALGVXKLVJJXR2WHXJLTUSE7FA5CNFSM47JRUWJKYY3PNVWWK3TUL52HS4DFWFCGS43DOVZXG2LPNZBW63LNMVXHJKTDN5WW2ZLOORPWSZGOAAHA3LY.gif>",
                  "url": "https://github.com/idaholab/moose/discussions/18170#discussioncomment-921225",
                  "updatedAt": "2022-11-03T17:24:43Z",
                  "publishedAt": "2021-06-25T14:57:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nOk thanks for the explanation I thought this was a block restriction issue.\nYou could have a boolean in your material. Or equivalently specify the strain model to the material.\nThen at construction you can use _matprop(_need_to_declare_it ? declareMatprop() : getMaterialProperty() )\nOr something more detailed in the body of the constructor with a mooseError or mooseWarning if not enough information is provided by the user to make the selection.\nIf you try to retrieve a material property and it doesnt exist, it will error out. I dont think there is a way around it, but @rwcarlsen would know more about the material system.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18170#discussioncomment-922279",
                  "updatedAt": "2022-11-03T17:24:42Z",
                  "publishedAt": "2021-06-25T17:44:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "rwcarlsen"
                  },
                  "bodyText": "Normally hasMaterialProperty would do what you want - e.g. something like MaterialProperty<Foo> * foo = hasMaterialProperty(...) ? getMaterialProperty(...) : nullptr.  The problem is that you are doing this within a material object's constructor - and so all the materials might not be constructed yet - so you might get an error even though that property will be defined by another material after.  Also, if you call getMaterialProperty in a different function that runs later (e.g. not the constructor) - then you risk moose not seeing the inter-property dependency.  One workaround might be putting your getMaterialProperty call in the material's constructor body - and surround it with a try-catch.  In the catch - you just make the property be a nullptr and then you know you need to calculate it manually.",
                  "url": "https://github.com/idaholab/moose/discussions/18170#discussioncomment-922646",
                  "updatedAt": "2022-11-03T17:24:29Z",
                  "publishedAt": "2021-06-25T19:54:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mghkorzani"
                  },
                  "bodyText": "Thanks for the help.I set a bool input parameter to be supplied by users with the same name of the tensor mechanics equivalent. So I can set it for the both in my global parameter. Or I should use the approach of the dictator uo as per porous flow module.Have a nice weekend.Sent from my Galaxy\n-------- Original message --------From: Robert Carlsen ***@***.***> Date: 25/6/21  21:55  (GMT+01:00) To: idaholab/moose ***@***.***> Cc: Maziar Korzani ***@***.***>, Author ***@***.***> Subject: Re: [idaholab/moose] supplied material check (#18170) \nNormally hasMaterialProperty would do what you want - e.g. something like MaterialProperty<Foo> * foo = hasMaterialProperty(...) ? getMaterialProperty(...) : nullptr.  The problem is that you are doing this within a material object's constructor - and so all the materials might not be constructed yet - so you might get an error even though that property will be defined by another material after.  Also, if you call getMaterialProperty in a different function that runs later (e.g. not the constructor) - then you risk moose not seeing the inter-property dependency.  One workaround might be putting your getMaterialProperty call in the material's constructor body - and surround it with a try-catch.  In the catch - you just make the property be a nullptr and then you know you need to calculate it manually.\n\n\u2014You are receiving this because you authored the thread.Reply to this email directly, view it on GitHub, or unsubscribe.",
                  "url": "https://github.com/idaholab/moose/discussions/18170#discussioncomment-922778",
                  "updatedAt": "2022-11-03T17:24:29Z",
                  "publishedAt": "2021-06-25T20:44:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Adding Material Property to Custom Kernel",
          "author": {
            "login": "alanchavez86"
          },
          "bodyText": "Hi All!\nI was wondering if I can get some help with adding a material property to a custom kernel that can compute the magnetic potential in the following equation:\n\nM is the magnetization saturation with respect to c1, c2, and c3. (Little bit of context here, I'm using the phase-field method to model the spinodal decomposition of FeCrCo.)\nI modified the CoefDiffusion kernel to calculate \u2207^2\u03c6 = x*y and compared the results to a benchmark from COMSOL with accurate results:\n\nMy goal is to customize my custom kernel so that it can take M as a function from the Materials system and then take the gradient with respect to x (assuming that the magnetic direction is going towards the x direction). Here are my .C and .h files for the custom kernel:\n#include \"NewCoefDiffusion.h\"\n\nregisterMooseObject(\"diffusion\", NewCoefDiffusion);\n\nInputParameters\nNewCoefDiffusion::validParams()\n{\n  InputParameters params = Kernel::validParams();\n  params.addParam<Real>(\"coef\", 0.0, \"Diffusion coefficient\");\n  params.addParam<FunctionName>(\"function\",\n                                \"If provided, the diffusion coefficient will be coef + \"\n                                \"this function.  This is useful for temporally or \"\n                                \"spatially varying diffusivities\");\n  params.addClassDescription(\"Kernel for diffusion with diffusivity = coef + function\");\n  params.addRequiredParam<MaterialPropertyName>(\"m\", \"Base name of the Magnetization Saturation defined in a DertivativeParsedMaterial\");\n  return params;\n}\n\nNewCoefDiffusion::NewCoefDiffusion(const InputParameters & parameters)\n  : Kernel(parameters),\n    _coef(getParam<Real>(\"coef\")),\n    _func(parameters.isParamValid(\"function\") ? &getFunction(\"function\") : NULL),\n    _m(getMaterialPropertyDerivative<Real>(\"m\", _var.name()))\n{\n}\n\nReal\nNewCoefDiffusion::computeQpResidual()\n{\n  Real diffusivity = _coef;\n\n  if (_func)\n    diffusivity += _func->value(_t, _q_point[_qp]);\n\n  return _grad_test[_i][_qp] * -_grad_u[_qp] - _m*grad_test[_i][_qp];\n}\n\nReal\nNewCoefDiffusion::computeQpJacobian()\n{\n  Real diffusivity = _coef;\n\n  if (_func)\n    diffusivity += _func->value(_t, _q_point[_qp]);\n\n  return _grad_test[_i][_qp] * -_grad_phi[_j][_qp] - _m*grad_test[_i][_qp];\n}\n\n\n#pragma once\n\n#include \"Kernel.h\"\n#include \"Function.h\"\n#include \"DerivativeMaterialInterface.h\"\n\nclass NewCoefDiffusion : public Kernel\n{\npublic:\n  static InputParameters validParams();\n\n  NewCoefDiffusion(const InputParameters & parameters);\n\nprotected:\n  virtual Real computeQpResidual();\n  virtual Real computeQpJacobian();\n\nprivate:\n  const Real _coef;\n  const Function * const _func;\n  const MaterialProperty<Real> & _m;\n};\n\n\nI thought following SplitCHParsed.C and SplitCHWRes.C and their implementation of Material properties would be straightforward, but it turns out it's not.\nAny help would be appreciated! Thank you!",
          "url": "https://github.com/idaholab/moose/discussions/18157",
          "updatedAt": "2022-06-06T14:39:26Z",
          "publishedAt": "2021-06-23T22:02:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @alanchavez86\nYou can see an example in this kernel in my repository:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/kernels/ConservativeAdvectionCoupled.C\nI get a material property (a vector) in the kernel using:\n_edge_slip_direction(getMaterialProperty<std::vector>(\"edge_slip_direction\")),\nThis material property is declared in this material:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainCrystalPlasticityDislo.C\nas:\n_edge_slip_direction(declareProperty<std::vector>(\"edge_slip_direction\")),\nand it is calculated inside the material object.\nTrust this helps,\nNicol\u00f2 Grilli\nUniversity of Bristol",
                  "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-913629",
                  "updatedAt": "2022-06-06T14:39:37Z",
                  "publishedAt": "2021-06-24T07:33:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Hey Nicolo, some unsolicited comments: in the example you are using a ton of addCoupledVar. Are you aware that we support vector coupling? I.e. the user can specify multiple coupled variable per addCoupledVar parameter. You can access those with the optional component parameter in coupledValue(\"name\", component) and get the number of coupled components with coupledComponents(\"name\"). The slip direction property should be of type std::vector<RealVectorValue> and be sized to _nss rather than _nss * LIBMESH_DIM.",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-916653",
                          "updatedAt": "2022-06-06T14:39:40Z",
                          "publishedAt": "2021-06-24T16:48:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @dschwen\nYour comment is very useful to improve my code.\nI was not aware of the coupled vectors.\nI was actually looking for that some time ago but I am not enough familiar with the framework.\nCould you point me to an example kernel where vector coupling is implemented?\nMy idea is to develop a continuum dislocation dynamics code in which dislocation densities are variables\nbecause I need to introduce the flux terms, dislocation multiplication, et cetera.\nThen I couple the dislocation density variables with the crystal plasticity material\nby implementing Orowan law and calculating dislocation velocity.\nIndeed, if I could do vector variable coupling, I could develop a general code with an arbitrary number of active slip system,\nwhile now the number of slip systems is fixed.\nI am using the slip direction vector to pass the rotated slip directions of all slip systems\nto the Advection kernel, so that I can implement dislocation flux along arbitrary directions on slip plane in 3D\ndepending on the crystal rotation matrix.\nPlease always write these unsolicited comments.\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-916993",
                          "updatedAt": "2022-06-06T14:39:41Z",
                          "publishedAt": "2021-06-24T18:09:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "@ngrilli\nThank you for the suggestion! I went through and followed your kernel from your repository and modified my kernel. Looking into your files, I've noticed that there is a src/materials directory. Would I have to create a new materials directory and possibly add a custom material file?\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-917045",
                          "updatedAt": "2022-06-06T14:39:56Z",
                          "publishedAt": "2021-06-24T18:22:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "@ngrilli , here https://github.com/idaholab/moose/blob/06bc1f73f0d4dfb3d01ce9ba77d6bb97346e07eb/modules/phase_field/src/ics/CoupledValueFunctionIC.C is an example\n\n  \n    \n      moose/modules/phase_field/include/ics/CoupledValueFunctionIC.h\n    \n    \n         Line 28\n      in\n      06bc1f7\n    \n  \n  \n    \n\n        \n          \n           const std::vector<const VariableValue *> _vals; \n        \n    \n  \n\n\n\n  \n    \n      moose/modules/phase_field/src/ics/CoupledValueFunctionIC.C\n    \n    \n        Lines 22 to 24\n      in\n      06bc1f7\n    \n  \n  \n    \n\n        \n          \n           params.addCoupledVar(\"v\", \n        \n\n        \n          \n                                \"List of up to four coupled variables that are substituted for x,y,z, and t \" \n        \n\n        \n          \n                                \"in the coupled function\"); \n        \n    \n  \n\n\n\n  \n    \n      moose/modules/phase_field/src/ics/CoupledValueFunctionIC.C\n    \n    \n         Line 32\n      in\n      06bc1f7\n    \n  \n  \n    \n\n        \n          \n           _vals(coupledValues(\"v\")) \n        \n    \n  \n\n\nInstead of coupledValue(\"name\", component) I'm using the even simpler coupledValues(\"name\") (note the plural) which gets a vector of variable pointers.",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-917765",
                          "updatedAt": "2022-08-18T12:33:28Z",
                          "publishedAt": "2021-06-24T21:40:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @alanchavez86\nI keep the same structure as the MOOSE framework directory system,\ntherefore I include material classes in a /materials/ folder.\nI am not sure if that is compulsory, but I don't see why you should not do that.\nIt's useful for distinguishing material classes from kernel classes.\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-920293",
                          "updatedAt": "2022-08-18T12:34:14Z",
                          "publishedAt": "2021-06-25T11:03:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "@ngrilli\nThank you for the clarification. I wasn't aware that you can create your own material classes. I'm still fairly new at creating custom kernels so I didn't think of this at first. I'll try the parts of your code that you mentioned and let you know how it goes!",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-921615",
                          "updatedAt": "2022-08-18T12:40:23Z",
                          "publishedAt": "2021-06-25T16:34:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "At the very least you need to replace _m with _m[_qp].",
                  "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-916657",
                  "updatedAt": "2022-06-06T14:39:44Z",
                  "publishedAt": "2021-06-24T16:50:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Also you calculate diffusivity and never use it.",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-916659",
                          "updatedAt": "2022-06-06T14:39:57Z",
                          "publishedAt": "2021-06-24T16:51:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "@dschwen\nThank you for catching those. I must have overlooked those mistakes when modifying the CoefDIffusion kernel.",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-917068",
                          "updatedAt": "2022-06-06T14:39:44Z",
                          "publishedAt": "2021-06-24T18:30:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cannot see Variable in output file",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "After simulation was done, I opened the result(*.e) through Paraview.\n\nHowever, as shown at above, I cannot see one of variables (phi_Ni) I assigned for the simulation.\n\nDuring the simulation, I saw messaged like above.\n\"Outlier Variable Residual Norms\".\nIs this related to not seeing the variable in the output file?",
          "url": "https://github.com/idaholab/moose/discussions/18168",
          "updatedAt": "2023-02-13T10:51:05Z",
          "publishedAt": "2021-06-25T07:48:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthe outlier variable residual norm is not related to not seeing the variable.\nthis is very odd. Unless you have hide = \u2018phi_Ni\u2019 in the output block, I do not understand why it s happening.\nCould you please delete the exodus file and try generating it again? You may be opening an old one or something?\nguillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18168#discussioncomment-921014",
                  "updatedAt": "2023-02-13T10:51:19Z",
                  "publishedAt": "2021-06-25T14:12:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "I read my input file thoroughly.\nI just got a point.\n'phi_Ni' existed at [Variables] and [Postprocessors].\nAfter I changed the name in [Postprocessors], then now I can see the variable in output file.",
                          "url": "https://github.com/idaholab/moose/discussions/18168#discussioncomment-921596",
                          "updatedAt": "2023-02-13T10:51:33Z",
                          "publishedAt": "2021-06-25T16:27:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the variable values from other elements\uff1f",
          "author": {
            "login": "xiekai-mc"
          },
          "bodyText": "Hello everyone,\nI want to get the variable values from other elements in indicators. And those elements are within a specified distance from the current element. Now I can only get the variable values from the current element with ElementIndicator.\nPlease help me, thanks.",
          "url": "https://github.com/idaholab/moose/discussions/18150",
          "updatedAt": "2022-08-13T19:23:52Z",
          "publishedAt": "2021-06-23T09:58:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThat's not a very common need. If I may, what are you trying to do with that?\nYou could hack it and re-init at the neighbor element to get the variables there, but there may be a simpler way if you give us more details on what you want to do.\nEDIT:\nActually it's not too bad for variable values. Use a pointer to the variable instead of the coupled interface to work with the variable, then use\n_var->getElementalValue(const Elem * neighbor, unsigned int index(<-for vectors/arrays) )\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18150#discussioncomment-910945",
                  "updatedAt": "2022-08-13T19:23:52Z",
                  "publishedAt": "2021-06-23T15:53:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "Thank you for your reply.  I guess the 'Elem * neighbor' is the element next to the current one.  Is there any way for a pointer to point to an arbitrary element ?",
                          "url": "https://github.com/idaholab/moose/discussions/18150#discussioncomment-920979",
                          "updatedAt": "2022-08-13T19:24:03Z",
                          "publishedAt": "2021-06-25T14:03:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You could have any element as an argument there, the problem is how do you retrieve the pointer in the kernel?\nNeighbor is easy to get to from the attributes of the current element. You could retrieve an arbitrary element pointer from the mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/18150#discussioncomment-920989",
                          "updatedAt": "2022-08-13T19:24:21Z",
                          "publishedAt": "2021-06-25T14:06:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Symbol Lookup Error",
          "author": {
            "login": "ritamcj"
          },
          "bodyText": "Hi everyone,\nI am working with the CoupledGradient API in Moose and attempting to calculate grad(Fp) in the tensor mechanics module where Fp is the plastic deformation gradient. I duplicated the CoupledGradient function and all associated functions in Coupleable.C to try read a double variable instead of a string. I left all original functions unchanged and everything compiled nicely. But when I run my input file, I see a symbol lookup error in the heat conduction module as attached. I checked the error with C++filt and it showed \"non-virtual thunk to SideIntegralPostprocessor::getValue()\". I am unable to understand this error. I would appreciate any guidance to solve this problem.\nThanks and regards,\nRitam Chatterjee",
          "url": "https://github.com/idaholab/moose/discussions/18167",
          "updatedAt": "2022-06-29T12:58:15Z",
          "publishedAt": "2021-06-25T05:49:27Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nfirst thing I would try would be to clean and rebuild just in case something did not get updated from before the modifications. So\n\u2018make clobberall\u2019 then \u2018make\u2019\nthen if that doesn\u2019t work, did you make sure to have an implementation for every single routine you added in coupleable.h ? You did not add any pure virtual ones?\nbest\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18167#discussioncomment-918842",
                  "updatedAt": "2022-06-29T12:58:23Z",
                  "publishedAt": "2021-06-25T06:37:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Guillaume,\nThank you for your response. I tried the clobber make method in both tensor mechanics and heat conduction modules but the error persists. I did not add any pure virtual functions in Coupleable.h but I commented out some statements in my new functions that I felt were not critical to the new approach. Only the old, unaltered functions are being called everywhere in different modules. Can i do something with getValue() in SideIntegralPostProcessor.C that would resolve this?\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/18167#discussioncomment-919158",
                          "updatedAt": "2022-11-16T09:37:52Z",
                          "publishedAt": "2021-06-25T08:14:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Guillaume,\nI tried clobber make in the combined module and it worked! Many thanks for your suggestion.\nBest regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/18167#discussioncomment-920241",
                          "updatedAt": "2022-11-16T09:38:13Z",
                          "publishedAt": "2021-06-25T10:52:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "converting abaqus mesh (.inp) to .e",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nHas anyone ever tried to convert .inp to .e via MOOSE?\nI tried to follow the example in test/tests/mesh/abaqus_input\nHowever, the mesh (.e) I obtained doesn't look correct as some elements are missing (attached - paraview)\nNot too sure what is the problem, .inp looks fine when I view it on Cubit/Abaqus\nPlease let me know if you have any idea.\nNote: I also tried to convert .inp to .e using meshio, also doesn't work as well.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/18147",
          "updatedAt": "2022-06-23T20:26:29Z",
          "publishedAt": "2021-06-23T05:37:11Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I have not. Can you convert it via Paraview instead of via MOOSE?\nThere's got to be some format that is common between Paraview and Abaqus, maybe not inp. Maybe .nas from some quick googling",
                  "url": "https://github.com/idaholab/moose/discussions/18147#discussioncomment-908328",
                  "updatedAt": "2022-07-29T07:18:06Z",
                  "publishedAt": "2021-06-23T06:35:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "unfortunately Paraview doesnt read .inp file",
                          "url": "https://github.com/idaholab/moose/discussions/18147#discussioncomment-918633",
                          "updatedAt": "2022-07-29T07:18:06Z",
                          "publishedAt": "2021-06-25T05:06:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is there another format Abaqus can export that paraview can read?",
                          "url": "https://github.com/idaholab/moose/discussions/18147#discussioncomment-918636",
                          "updatedAt": "2022-07-29T07:18:08Z",
                          "publishedAt": "2021-06-25T05:09:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "@GiudGiud I figured out now, so MOOSE doesn't read some of Abaqus format\nfor example\noriginal .inp file has\n*ELSET, ELSET=DRV_Y2026_M03, GENERATE\n 541205, 541208\n 666835, 666839\n 691109, 691112\n\nit should read from element 541205 to 541208, but instead MOOSE only read 2 elements (541205 and 541208).\nI have to reformat .inp to\n*ELSET, ELSET=DRV_Y2026_M03, GENERATE\n 541205, 541208,1\n 666835, 666839,1\n 691109, 691112,1\n\nso now MOOSE read from element 541205 to 541208",
                  "url": "https://github.com/idaholab/moose/discussions/18147#discussioncomment-918640",
                  "updatedAt": "2022-07-29T07:18:08Z",
                  "publishedAt": "2021-06-25T05:11:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}