{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNS0wOVQwMjoxMDowNC0wNjowMM4ATvhy"
    },
    "edges": [
      {
        "node": {
          "title": "How to separate a cylinder and a sphere in the same [mesh] without touching each other?",
          "author": {
            "login": "Strawberrybrother"
          },
          "bodyText": "I've looked at some examples of squares or cubes, which can be separated by parameters like xmin, xmax, ymax, ymin, zmin, zmax, but how can we separate a sphere and a cylinder?Thank you for your help and answers.",
          "url": "https://github.com/idaholab/moose/discussions/24336",
          "updatedAt": "2023-06-24T22:36:06Z",
          "publishedAt": "2023-05-12T01:30:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou can make those meshes with mesh generators then use a combiner generator to have them in the same simulation without touching.\nUnless you use interface kernels or dedicated user objects, they will not influence each other\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24336#discussioncomment-5880157",
                  "updatedAt": "2023-05-12T03:14:20Z",
                  "publishedAt": "2023-05-12T03:14:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou can translate any of those two meshes using the TransformGenerator\nhttps://mooseframework.inl.gov/docs/PRs/24293/site/source/meshgenerators/TransformGenerator.html\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24336#discussioncomment-5885021",
                          "updatedAt": "2023-05-12T13:19:05Z",
                          "publishedAt": "2023-05-12T13:19:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Strawberrybrother"
                          },
                          "bodyText": "Hello Guillaume,\nThank you for your help. My problem has been solved. I have another question: if I want the ball to fall vertically onto the cylinder, do I need to add [Kernels] or [BCs] or other parts?\nBest regards,\nStrawberrybrother",
                          "url": "https://github.com/idaholab/moose/discussions/24336#discussioncomment-5887252",
                          "updatedAt": "2023-05-12T16:58:52Z",
                          "publishedAt": "2023-05-12T16:58:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so you want the mesh to move?",
                          "url": "https://github.com/idaholab/moose/discussions/24336#discussioncomment-5887345",
                          "updatedAt": "2023-05-12T17:12:50Z",
                          "publishedAt": "2023-05-12T17:12:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Strawberrybrother"
                          },
                          "bodyText": "Yes,I want the ball to impact this cylinder. The bottom of the cylinder is fixed . I want to observe the plastic deformation of the ball",
                          "url": "https://github.com/idaholab/moose/discussions/24336#discussioncomment-5887409",
                          "updatedAt": "2023-05-12T17:21:47Z",
                          "publishedAt": "2023-05-12T17:21:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You should look for examples in the repository, this will be hard to build from scratch.\nI think the contact module will have some",
                          "url": "https://github.com/idaholab/moose/discussions/24336#discussioncomment-5887546",
                          "updatedAt": "2023-05-12T17:39:33Z",
                          "publishedAt": "2023-05-12T17:39:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Strawberrybrother"
                          },
                          "bodyText": "Thank you very much",
                          "url": "https://github.com/idaholab/moose/discussions/24336#discussioncomment-5887605",
                          "updatedAt": "2023-05-12T17:46:54Z",
                          "publishedAt": "2023-05-12T17:46:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Inquiry about using Exodus mesh format for initial grain structure",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nI am writing to seek your advice on how to use an exodus mesh format file as input to create an initial grain structure for phase-field simulation of grain growth. Specifically, I want to utilize the ElementBlockIds information in the mesh file to create the initial grain structure.\nout_test4_01.e.38.05.txt\nAs you can see from the attached figure, the ElementBlockIds in the exodus file are labeled differently for each grain. I want to use this information to assign different grain IDs to each grain and create an initial grain structure.\n\nCould you please guide me on how to achieve this in MOOSE? Any suggestions or examples would be greatly appreciated.\nThank you very much for your time and help.\nBest regards,\nwei",
          "url": "https://github.com/idaholab/moose/discussions/24328",
          "updatedAt": "2023-06-24T22:35:59Z",
          "publishedAt": "2023-05-11T14:16:11Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen @amjokisaari",
                  "url": "https://github.com/idaholab/moose/discussions/24328#discussioncomment-5873918",
                  "updatedAt": "2023-05-11T14:19:06Z",
                  "publishedAt": "2023-05-11T14:19:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Sorry I don't have a good idea off the top of my head",
                  "url": "https://github.com/idaholab/moose/discussions/24328#discussioncomment-5875182",
                  "updatedAt": "2023-05-11T16:04:33Z",
                  "publishedAt": "2023-05-11T16:04:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "How is a grain defined in the code again? You keep track of the boundary with variables right?",
                          "url": "https://github.com/idaholab/moose/discussions/24328#discussioncomment-5875196",
                          "updatedAt": "2023-05-11T16:05:42Z",
                          "publishedAt": "2023-05-11T16:05:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "No each grain is represented with an order parameter, a number that is 1 inside a given grain and 0 outside, with a diffuse interface between 0 and 1 at interfaces. So in the absence of the GrainTracker, if we have 20 grains, we need 20 order parameters. The GrainTracker allows 1 order parameter to represent multiple grains to be represented by 1 OP by monitoring for overlaps and re-assigning grains if necessary. The GrainTracker does keep a unique ID for each grain so maybe this data could be mapped into the unique ID but I'm not sure if you can get the order parameter mapping directly from that.",
                          "url": "https://github.com/idaholab/moose/discussions/24328#discussioncomment-5875286",
                          "updatedAt": "2023-05-11T16:14:07Z",
                          "publishedAt": "2023-05-11T16:14:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is this kept on a per-element basis?",
                          "url": "https://github.com/idaholab/moose/discussions/24328#discussioncomment-5875363",
                          "updatedAt": "2023-05-11T16:19:47Z",
                          "publishedAt": "2023-05-11T16:19:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "I think you can select whether the unique IDs are stored at nodes or elements but I should ask @permcody to confirm this",
                          "url": "https://github.com/idaholab/moose/discussions/24328#discussioncomment-5877845",
                          "updatedAt": "2023-05-11T20:55:49Z",
                          "publishedAt": "2023-05-11T20:55:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "I believe can simplify the problem further. Suppose we have a mesh file (.e/.vtk) that already stores GrainID or ElementBlockIds for each node/element. Can we use this file as the initial microstructure for grain growth simulations with GrainTracker, instead of using built-in methods such as VT algorithm to establish the initial microstructure? Additionally, I believe there may be some insights we can gain from using EBSD as an input file for the simulation.",
                          "url": "https://github.com/idaholab/moose/discussions/24328#discussioncomment-5880038",
                          "updatedAt": "2023-05-12T02:51:45Z",
                          "publishedAt": "2023-05-12T02:51:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you can load them into variables, can the FeatureFloodCount do that?\n@permcody on initializing grains from Exodus/EBSD",
                          "url": "https://github.com/idaholab/moose/discussions/24328#discussioncomment-5885064",
                          "updatedAt": "2023-05-12T13:22:41Z",
                          "publishedAt": "2023-05-12T13:22:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "We do have an ImageFunction object which is pretty close to what you need, but I don't think it's exactly what you'd need for a polycrystal simulation without a little additional development. I've wanted to create an image reader for starting polycrystal simulations for many years, but I just don't have the time. However, the PolycrystalUserObjectBase was designed with exactly this use case in mind:\nEssentially the user interface is to query each element in your domain and your job as the developer of a derived class is supply one or more active grains at that location. That's it! That object will do the proper assignment of those grains to order parameters and your simulation will run. The way I'd approach this task would be to investigate the capabilities of that ImageFunction object and see if you can get unique values for each color in your image, if you can, then you are pretty much done on creating an \"ImageFunctioPolycrystalIC\" class.\nDoes this make sense? Take a look and ask me questions!",
                          "url": "https://github.com/idaholab/moose/discussions/24328#discussioncomment-5886019",
                          "updatedAt": "2023-05-12T14:50:34Z",
                          "publishedAt": "2023-05-12T14:50:34Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using Dirac Kernel to apply values from VectorPostprocessor in 2D",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hello,\nI need to sample along a line/side set in 2D. The sampled values would be applied in another system as a Dirac force. I have been able to do this in 1D by simple transfer, PointValueSampler and using FunctionDiracSource to use the sampled values. How can I do this for a 2D?",
          "url": "https://github.com/idaholab/moose/discussions/24320",
          "updatedAt": "2023-05-11T17:07:36Z",
          "publishedAt": "2023-05-10T16:17:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere's a linevalueSampler vector postprocessor (VPP) to get the values on the line\nThen there is https://mooseframework.inl.gov/source/dirackernels/ReporterPointSource.html\nVPP are Reporters in the backend, you just need to pass the  name_of_object slash name_of_vector to access the Reporter Name of a VPP\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24320#discussioncomment-5864504",
                  "updatedAt": "2023-05-10T18:36:34Z",
                  "publishedAt": "2023-05-10T18:36:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Thank you!\nAlthough I figure out that it might lag one iteration especially when the transfer is done using MultiApps",
                          "url": "https://github.com/idaholab/moose/discussions/24320#discussioncomment-5875907",
                          "updatedAt": "2023-05-11T17:08:26Z",
                          "publishedAt": "2023-05-11T17:07:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fail to run run_tests in latest master (commitID = b3305e18e7adf62db58d8f0dc4b075772201a35c)",
          "author": {
            "login": "one-step-per-week"
          },
          "bodyText": "Error message:\nError! Could not find libmesh_config.h in any of the usual locations!\nI am using a docker with a clean ubuntu 22.04 image following this Conda-way installation: installation Steps. I could be able to run the run_tests yesterday, but 5 of them failed. Today I want to rerun the tests, but the above error occurred.",
          "url": "https://github.com/idaholab/moose/discussions/24323",
          "updatedAt": "2023-05-11T02:04:47Z",
          "publishedAt": "2023-05-10T21:10:56Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you remember to activate the conda environment?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24323#discussioncomment-5866900",
                  "updatedAt": "2023-05-10T23:30:54Z",
                  "publishedAt": "2023-05-10T23:30:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "one-step-per-week"
                          },
                          "bodyText": "Thanks for your reply. There is a \"(moose)\" prefix in front of my terminal prompt, I guess it is the correct conda environment you mentioned?",
                          "url": "https://github.com/idaholab/moose/discussions/24323#discussioncomment-5867608",
                          "updatedAt": "2023-05-11T01:50:30Z",
                          "publishedAt": "2023-05-11T01:50:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "one-step-per-week"
                          },
                          "bodyText": "@GiudGiud My bad... I just found that I didn't execute the \"make -j 6\"... what a silly mistake! Now it can run. Thank you for your time.",
                          "url": "https://github.com/idaholab/moose/discussions/24323#discussioncomment-5867683",
                          "updatedAt": "2023-05-11T02:04:46Z",
                          "publishedAt": "2023-05-11T02:04:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[MultiApps] Setting second sub-application's variable ICs by 'initial_from_file_var' or 'SolutionUserObject' from 1st sub-application's latest results",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear all,\nI use 'type = TimePeriod' setting of [Controls] blocks to allow different sub-applications in [MultiApps] blocks to run in time sequence.\nI want to set the second sub-application's variable ICs by 'initial_from_file_var' or 'SolutionUserObject' from 1st sub-application's latest results. But all the sub-applications set their variables' initialization at the beginning of the whole simulation and just get the initial results from corresponding exodus files.\nI tried the 'global_time_offset' and 'wait_for_first_app_init=true' but I could not get my expected results.\nCould you please help me with this?\nThanks a lot.\nJ",
          "url": "https://github.com/idaholab/moose/discussions/24324",
          "updatedAt": "2023-05-15T22:48:33Z",
          "publishedAt": "2023-05-10T21:36:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can just chain the subapps using the execute_on flags.\nAn app executing on timestep_end of another app will execute after. This lets you stagger the solves and transfer from one app to another before.\nGlobal_time_offset can be used as well to execute a some time steps in one app before starting the other, but you have to turn on catch_up as well iirc to force the two applications to synchronize in time.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24324#discussioncomment-5866894",
                  "updatedAt": "2023-05-10T23:30:15Z",
                  "publishedAt": "2023-05-10T23:30:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow: Fracture aperture evolution",
          "author": {
            "login": "batodon"
          },
          "bodyText": "Hello,\nThis problem might be a bit convoluted, but please bear with me. I\u2019m trying to re-implement the fracture aperture evolution (i.e., equations 6 and 8) of the following publication:  https://doi.org/10.1029/2020WR027213  into my model, but I\u2019m unsure of the routine:\n\n\nI found an input file online (see attached) which treats the aperture evolution as an aux variable. This aux variable then feeds the permeability. However, I have some doubts about this input file. Probably, it is deprecated.\nFirst, I\u2019m guessing it is possible to use an aux variable inside an auxKernel. Correct? It seems like that is what the input file is indicating. The get_aperture_old auxKernel uses an aperture aux variable as a function to compute the aperture_old aux variable. This aperture_old aux variable feeds the change_aperture AuxKernel, which computes the aperture (evolution) as an aux variable. Then this aperture aux variable contributes to the change_permeability auxKernel, which computes the permeability. There seems to be an exchange of the respective aux variables between change_aperture and get_aperture_old AuxKernels. I find it odd because aperture_old is a function of aperture; at the same time, aperture is a function of aperture_old. Perhaps the function used in the get_aperture_old auxKernel is an imported aperture field. I don\u2019t know. Can someone please guide me? I\u2019m unsure why they needed to convert the aperture (evolution) into an aux variable in the first place. I think they could implement it as a material. Then this material feeds the permeability. Any thoughts?\npc_0_N18S_gap000_apert764.txt",
          "url": "https://github.com/idaholab/moose/discussions/24322",
          "updatedAt": "2023-05-10T16:43:38Z",
          "publishedAt": "2023-05-10T16:42:16Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "info on failed solves",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "Is there any info available, or can any be saved, about failed solves during a run? I'm hoping for something systematic that doesn't involve grepping through stdout.",
          "url": "https://github.com/idaholab/moose/discussions/24318",
          "updatedAt": "2023-05-10T15:07:18Z",
          "publishedAt": "2023-05-10T12:56:04Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "There s the troubleshooting failed solve page.\nI m revamping rn it I ll post a link to the page in my PR",
                  "url": "https://github.com/idaholab/moose/discussions/24318#discussioncomment-5861420",
                  "updatedAt": "2023-05-10T14:08:31Z",
                  "publishedAt": "2023-05-10T14:08:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Current page\nhttps://mooseframework.inl.gov/releases/moose/v1.0.0/application_usage/failed_solves.html\nPR page isnt generated yet",
                          "url": "https://github.com/idaholab/moose/discussions/24318#discussioncomment-5861582",
                          "updatedAt": "2023-05-10T14:21:42Z",
                          "publishedAt": "2023-05-10T14:21:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "So far cutting the time step on a failed solve has been sufficient for me\nto get to the end of the run. It's detecting if and when those cutbacks\noccurred that I'm interested in.",
                  "url": "https://github.com/idaholab/moose/discussions/24318#discussioncomment-5861693",
                  "updatedAt": "2023-05-10T14:31:39Z",
                  "publishedAt": "2023-05-10T14:31:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh my bad\nthere s this\nhttps://mooseframework.inl.gov/source/postprocessors/NumFailedTimeSteps.html",
                          "url": "https://github.com/idaholab/moose/discussions/24318#discussioncomment-5861710",
                          "updatedAt": "2023-05-10T14:33:23Z",
                          "publishedAt": "2023-05-10T14:33:22Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this will give you 'if' and 'how often'. It wont give you 'when'. But with a ParsedPostpcoessor and a TimePostprocessor you could detect 'the first time when' or 'the last time when' or the 'number of times when' pretty easily",
                          "url": "https://github.com/idaholab/moose/discussions/24318#discussioncomment-5861718",
                          "updatedAt": "2023-05-10T17:54:10Z",
                          "publishedAt": "2023-05-10T14:34:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "That should do the trick. Thanks. Wasn't aware of that postprocessor (there are so many!).",
                          "url": "https://github.com/idaholab/moose/discussions/24318#discussioncomment-5862152",
                          "updatedAt": "2023-05-10T15:07:09Z",
                          "publishedAt": "2023-05-10T15:07:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cannot update stateful material property with its old value:",
          "author": {
            "login": "steam-simulator"
          },
          "bodyText": "Hello,\nI\u2019m using the computeQpProperties virtual function to update my stateful material property but I keep getting a constant value. It seems my stateful material property is not changing. Please, help.\nmy h file:\nMaterialProperty<Real>& _b;\nconst MaterialProperty<Real>& _b_old;\n\nconst VariableValue& _sat;\n\nconst Real _rm;\n\nmy c file:\nInputParameters\nABC::validParams()\n{\n  InputParameters params = PorousFlowMaterial::validParams();\n  params.addRequiredCoupledVar(\"sat\", \"saturation\");\n  params.addParam<Real>(\"rm\", 0.277, \" coefficient\");\n  \n  return params;\n  }\n\nABC::ABC(const InputParameters & parameters)\n    : PorousFlowMaterial(parameters),\n  _b(_nodal_material\n                   ? declareProperty<Real>(\"initial_fracture_aperture_nodal\")\n                   : declareProperty<Real>(\"initial_fracture_aperture_qp\")),\n  _b_old(_nodal_material\n                   ? getMaterialPropertyOld<Real>(\"initial_fracture_aperture_nodal\")\n                   : getMaterialPropertyOld<Real>(\"initial_fracture_aperture_qp\")),\n  _sat (coupledValue(\"sat\")),\n  _rm(getParam<Real>(\"rm\")) \n  {\n  }\n\n\nvoid\nABC::initQpStatefulProperties()\n{\n _b[_qp] = 1.0;\n}\n\n\nvoid\nABC::computeQpProperties()\n{\n _b[_qp] = _b_old[_qp] - (_dt * _b_old[_qp] * _sat[_qp] *_rm); \n    _console << \"b = \" << _b[_qp]<< std::endl;\n}",
          "url": "https://github.com/idaholab/moose/discussions/24291",
          "updatedAt": "2023-05-09T14:58:48Z",
          "publishedAt": "2023-05-08T00:25:15Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat do you get from this print? And from printing _b_old?\nMaybe you are at a fixed point?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24291#discussioncomment-5838695",
                  "updatedAt": "2023-05-08T14:05:13Z",
                  "publishedAt": "2023-05-08T14:05:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "steam-simulator"
                          },
                          "bodyText": "Hello @GiudGiud, I got 1 for both _b and _b_old (i.e., the initQpStatefulProperties value for _b ). Pls, any idea why I\u2019m getting only this initial value?",
                          "url": "https://github.com/idaholab/moose/discussions/24291#discussioncomment-5839848",
                          "updatedAt": "2023-05-08T15:59:43Z",
                          "publishedAt": "2023-05-08T15:59:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "how much is sat ?\nand _rm ?\nif either is 0, then 1 is expected:\nb = 1 - ... * 0",
                          "url": "https://github.com/idaholab/moose/discussions/24291#discussioncomment-5839873",
                          "updatedAt": "2023-05-08T16:02:28Z",
                          "publishedAt": "2023-05-08T16:02:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "steam-simulator"
                          },
                          "bodyText": "Hi, sat is 0.18 and rm = 0.277.",
                          "url": "https://github.com/idaholab/moose/discussions/24291#discussioncomment-5839965",
                          "updatedAt": "2023-05-08T16:13:54Z",
                          "publishedAt": "2023-05-08T16:11:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "any idea @jiangwen84",
                          "url": "https://github.com/idaholab/moose/discussions/24291#discussioncomment-5840234",
                          "updatedAt": "2023-05-08T16:34:37Z",
                          "publishedAt": "2023-05-08T16:34:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Is this a nodal material? I would not be all that surprised if the nodal material properties that porous flow has implemented do not work with our stateful material property infrastructure in the framework. @cpgr @WilkAndy can you guys comment on that?",
                          "url": "https://github.com/idaholab/moose/discussions/24291#discussioncomment-5840771",
                          "updatedAt": "2023-05-08T17:32:41Z",
                          "publishedAt": "2023-05-08T17:32:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "steam-simulator"
                          },
                          "bodyText": "Hi @GiudGiud @lindsayad.\n    _b[_qp] = _b_old[_qp] - (_dt * _b_old[_qp] * _sat[_qp] *_rm); \n    _console << \"b = \" << _b[_qp]<< std::endl;\n    _console << \"bOld = \" << _b_old[_qp]<< std::endl;\n    _console << \"Timestep = \" << _dt<< std::endl;\n\nIt works now. I found the source of the problem after I printed out _dt. My simulation does not converge. However, it cuts the size of _dt to 0.5, but the actual Time step is still 1; therefore, _b_old doesn\u2019t get updated even though _b changes.\nb = 0.95014\nbOld = 1\nTimestep = 1\nb = 0.95014\nbOld = 1\nTimestep = 1\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 2\n Solve Did NOT Converge!\n  Finished Solving                                                                       [  8.98 s] [    3 MB]\nAborting as solve did not converge\n\nSolve failed, cutting timestep.\n\nTime Step 1, time = 0.5, dt = 0.5\nb = 0.97507\nbOld = 1\nTimestep = 0.5\nb = 0.97507\nbOld = 1\nTimestep = 0.5",
                          "url": "https://github.com/idaholab/moose/discussions/24291#discussioncomment-5841317",
                          "updatedAt": "2023-05-08T18:33:15Z",
                          "publishedAt": "2023-05-08T18:33:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "The nodal materials do work with the stateful property infrastructure and we use it extensively. It's just crazy enough to work!\nIt looks like it will work once your solution converges and the current b gets propagated to bOld.",
                          "url": "https://github.com/idaholab/moose/discussions/24291#discussioncomment-5842572",
                          "updatedAt": "2023-05-08T21:35:06Z",
                          "publishedAt": "2023-05-08T21:35:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Thanks for the info @cpgr !",
                          "url": "https://github.com/idaholab/moose/discussions/24291#discussioncomment-5850441",
                          "updatedAt": "2023-05-09T14:58:48Z",
                          "publishedAt": "2023-05-09T14:58:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multithreading error \"signal 11\" in thermal expansion simulation with gap",
          "author": {
            "login": "nuomi68"
          },
          "bodyText": "Hello!\nMOOSE\nI get an error  showed  that \"signal 11\"  when I added thermal expansion to heat conduction. The run command is mpiexec -n 2 ./app-opt  -i gaptherm.i --n-threads=2 , which is showed as follows:\n\nI have tried three cases without this error:\n\nNot use  multithreading;\nChange the 3D simulation to 2D;\nNot use Tensor Mechanics module in the 3D case\n\nMy input file is\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  incremental = true\n[]\n\n\ngap_size = 0.0001\n\nfuel_outer_radius = 0.005\nclad_width=0.001\nclad_inner_radius = '${fparse fuel_outer_radius + gap_size}'\nclad_outer_radius = '${fparse fuel_outer_radius + gap_size+clad_width}'\n\n[Mesh]\n  parallel_type = distributed\n  use_displaced_mesh = true\n  [fuel_rod]\n    type = ConcentricCircleMeshGenerator\n    num_sectors = 30\n    radii = '${fuel_outer_radius} ${clad_inner_radius} ${clad_outer_radius}'\n    rings = '15 1 5'\n    has_outer_square = false\n    preserve_volumes = true\n    portion = full\n  []\n  [renameblock]\n    type = RenameBlockGenerator\n    input = fuel_rod\n    old_block = '1 2 3'\n    new_block = 'fuel gap cladding'\n  []\n  [renameboundary]\n    type = RenameBoundaryGenerator\n    input = renameblock\n    old_boundary = 'outer'\n    new_boundary = 'cladding_outface'\n  []\n  [rename_fuel_face]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = renameboundary\n    primary_block = fuel\n    paired_block = gap\n    new_boundary = 'fuel_face'\n  []\n  [rename_cladding_inface]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = rename_fuel_face\n    primary_block = cladding\n    paired_block = gap\n    new_boundary = 'cladding_inface'\n  []\n  [2d_mesh]\n    type = BlockDeletionGenerator\n    input = rename_cladding_inface\n    block = gap\n  []\n  [3d_mesh]\n    type = AdvancedExtruderGenerator\n    input = 2d_mesh\n    heights = '0.02'\n    direction = '0 0 1'\n    num_layers = '10'\n  []\n  patch_update_strategy=iteration\n[]\n\n[Problem]\n  coord_type = XYZ\n#    rz_coord_axis = Z\n[]\n\n[GlobalParams]\n  order = FIRST\n[]\n\n[Variables]\n    [./disp_x]\n  [../]\n  [./disp_y]\n  [../]\n  [./disp_z]\n  [../]\n  [temp]\n      order = FIRST\n      family = LAGRANGE\n      initial_condition = 300.0\n  []\n[]\n\n[AuxVariables]\n  [./gap_conductance]\n      order = CONSTANT\n      family = MONOMIAL\n  [../]\n[]\n\n[Kernels]\n  [./heat]\n      type = HeatConduction\n      variable = temp\n  [../]\n  [./heat_source]\n      type = HeatSource\n      value = 6.6E7\n      variable = temp\n      block=fuel\n  [../]\n  [./heat_derivative]\n      type = HeatConductionTimeDerivative\n      variable = temp\n  [../]\n[]\n\n\n[BCs]\n  [temp_clad]\n      type = DirichletBC\n      boundary = cladding_outface\n      variable = temp\n      value = 400.0\n  []\n[]\n\n[Materials]\n  [fuel_elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 2.0e11\n    poissons_ratio = 0.345\n  [../]\n  [./thermal_strain1]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 1.243e-6\n    stress_free_temperature = 10\n    temperature = temp\n    eigenstrain_name = eigenstrain\n  [../]\n  [heat]\n      type = HeatConductionMaterial\n      specific_heat = 299.96\n      thermal_conductivity = 17\n  []\n  [density]\n      type = GenericConstantMaterial\n      prop_names = density\n      prop_values = 6.161E3\n  []\n  [fuel_stress]\n    type = ComputeFiniteStrainElasticStress\n\n  []\n[]\n[Modules/TensorMechanics/Master]\n  [fule]\n    strain = FINITE\n    eigenstrain_names = 'eigenstrain'#swell\n    add_variables = true\n    generate_output = 'stress_xx stress_yy stress_zz stress_xy stress_xz stress_yz\n                      strain_xx strain_yy strain_zz strain_xy strain_xz strain_yz'\n  []\n[]\n[Contact]\n  [interface]\n    primary = cladding_inface\n    secondary = fuel_face\n    model = frictionless\n    formulation = penalty\n    penalty = 1e14\n    normalize_penalty = true\n    normal_smoothing_distance = 0.1\n    # order=SECOND\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  \n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu        superlu_dist'\n\n  start_time = 0.0\n  end_time = 1.0\n  dt = 0.1\n  dtmin = 0.0001\n\n  nl_rel_tol = 1E-12\n  nl_abs_tol = 1E-7\n\n  [./Quadrature]\n      order = fifth\n      side_order = seventh\n  [../]\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24294",
          "updatedAt": "2023-06-24T22:35:10Z",
          "publishedAt": "2023-05-08T14:05:15Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThank you for the bug report.\nWe'll take a look\nFor now, please just use mpirun -n 4 without any threads if it runs well in that configuration\nPerformance should be very similar if not better.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24294#discussioncomment-5838763",
                  "updatedAt": "2023-05-08T14:12:36Z",
                  "publishedAt": "2023-05-08T14:12:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "nuomi68"
                          },
                          "bodyText": "Thank you for your reply.\nI've just made some try again, when I add ModularGapConductanceConstraint module, the error will disappear. But I can't use this module properly, which means I can't set reasonably parameter values.  At the same time, the module needs to add an extra variable, which greatly increases  computation time. So I still hope to run the simulation without using this module. I hope your help.\nLWZ\nMy new input file is\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  incremental = true\n[]\n\ngap_size = 0.0001\nfuel_outer_radius = 0.005\nclad_width=0.001\nclad_inner_radius = '${fparse fuel_outer_radius + gap_size}'\nclad_outer_radius = '${fparse fuel_outer_radius + gap_size+clad_width}'\n\n[Mesh]\n  parallel_type = distributed\n  use_displaced_mesh = true\n  [fuel_rod]\n    type = ConcentricCircleMeshGenerator\n    num_sectors = 30\n    radii = '${fuel_outer_radius} ${clad_inner_radius} ${clad_outer_radius}'\n    rings = '15 1 5'\n    has_outer_square = false\n    preserve_volumes = true\n    portion = full\n  []\n  [renameblock]\n    type = RenameBlockGenerator\n    input = fuel_rod\n    old_block = '1 2 3'\n    new_block = 'fuel gap cladding'\n  []\n  [renameboundary]\n    type = RenameBoundaryGenerator\n    input = renameblock\n    old_boundary = 'outer'\n    new_boundary = 'cladding_outface'\n  []\n  [rename_fuel_face]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = renameboundary\n    primary_block = fuel\n    paired_block = gap\n    new_boundary = 'fuel_face'\n  []\n  [rename_cladding_inface]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = rename_fuel_face\n    primary_block = cladding\n    paired_block = gap\n    new_boundary = 'cladding_inface'\n  []\n  [2d_mesh]\n    type = BlockDeletionGenerator\n    input = rename_cladding_inface\n    block = gap\n  []\n  [3d_mesh]\n    type = AdvancedExtruderGenerator\n    input = 2d_mesh\n    heights = '0.02'\n    direction = '0 0 1'\n    num_layers = '10'\n  []\n  [secondary]\n    type = LowerDBlockFromSidesetGenerator\n    sidesets = 'fuel_face'\n    new_block_id = 10001\n    new_block_name = 'secondary_lower'\n    input = 3d_mesh\n  []\n  [primary]\n    type = LowerDBlockFromSidesetGenerator\n    sidesets = 'cladding_inface'\n    new_block_id = 10000\n    new_block_name = 'primary_lower'\n    input = secondary\n  []\n  patch_update_strategy=iteration\n[]\n\n[Problem]\n  coord_type = XYZ\n[]\n\n[GlobalParams]\n  order = FIRST\n[]\n\n[Variables]\n    [./disp_x]\n  [../]\n  [./disp_y]\n  [../]\n  [./disp_z]\n  [../]\n  [temp]\n      order = FIRST\n      family = LAGRANGE\n      initial_condition = 300.0\n  []\n  [lm]\n    block = 'secondary_lower'\n  []\n\n[]\n\n[AuxVariables]\n  [./gap_conductance]\n      order = CONSTANT\n      family = MONOMIAL\n  [../]\n  [interface_normal_lm]\n    block = 'secondary_lower'\n    initial_condition = 100.0\n  []\n[]\n\n[Kernels]\n  [./heat]\n      type = HeatConduction\n      variable = temp\n  [../]\n  [./heat_source]\n      type = HeatSource\n      value = 6.6E7\n      variable = temp\n      block=fuel\n  [../]\n  [./heat_derivative]\n      type = HeatConductionTimeDerivative\n      variable = temp\n  [../]\n[]\n\n\n[BCs]\n  [temp_clad]\n      type = DirichletBC\n      boundary = cladding_outface\n      variable = temp\n      value = 400.0\n  []\n[]\n\n[Materials]\n  [fuel_elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 2.0e11\n    poissons_ratio = 0.345\n  [../]\n  [./thermal_strain1]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 1.243e-6\n    stress_free_temperature = 10\n    temperature = temp\n    eigenstrain_name = eigenstrain\n  [../]\n  [heat]\n      type = HeatConductionMaterial\n      specific_heat = 299.96\n      thermal_conductivity = 17\n  []\n  [density]\n      type = GenericConstantMaterial\n      prop_names = density\n      prop_values = 6.161E3\n  []\n  [fuel_stress]\n    type = ComputeFiniteStrainElasticStress\n\n  []\n[]\n[Modules/TensorMechanics/Master]\n  [fule]\n    strain = FINITE\n    eigenstrain_names = 'eigenstrain'#swell\n    add_variables = true\n    generate_output = 'stress_xx stress_yy stress_zz stress_xy stress_xz stress_yz\n                      strain_xx strain_yy strain_zz strain_xy strain_xz strain_yz'\n  []\n[]\n\n\n[UserObjects]\n  [radiation]\n    type = GapFluxModelRadiation\n    temperature = temp\n    boundary =  cladding_inface\n    primary_emissivity = 1.0\n    secondary_emissivity = 1.0\n    use_displaced_mesh = true\n  []\n  [closed]\n    type = GapFluxModelPressureDependentConduction\n    temperature = temp\n    contact_pressure = interface_normal_lm\n    primary_hardness = 129\n    secondary_hardness = 15\n    boundary =   cladding_inface\n    primary_conductivity=330\n    secondary_conductivity=330\n  []\n[]\n\n[ThermalContact]\n  [./thermal_contact]\n    type = GapHeatTransfer\n    variable =  temp\n    primary = cladding_inface\n    secondary = fuel_face\n    emissivity_primary = 0\n    emissivity_secondary = 0\n    gap_conductivity = 1\n    quadrature = true\n    gap_geometry_type = CYLINDER\n    cylinder_axis_point_1 = '0 0 0'\n    cylinder_axis_point_2 = '0 0 1'\n  [../]\n[]\n\n[Contact]\n  [interface]\n    primary = cladding_inface\n    secondary = fuel_face\n    model = frictionless\n    formulation = penalty\n    penalty = 1e14\n    normalize_penalty = true\n    normal_smoothing_distance = 0.1\n  []\n[]\n\n[Constraints]\n  [ced]\n    type = ModularGapConductanceConstraint\n    variable = lm\n    secondary_variable = temp\n    primary_boundary =  cladding_inface\n    primary_subdomain = 10000\n    secondary_boundary = fuel_face\n    secondary_subdomain = 10001\n    gap_flux_models = 'closed radiation'\n    # gap_geometry_type = AUTO\n    # sphere_origin = '0 0 0'\n    use_displaced_mesh = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  \n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu        superlu_dist'\n\n  start_time = 0.0\n  end_time = 1.0\n  dt = 0.1\n  dtmin = 0.0001\n\n  nl_rel_tol = 1E-12\n  nl_abs_tol = 1E-7\n\n  [./Quadrature]\n      order = fifth\n      side_order = seventh\n  [../]\n[]\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24294#discussioncomment-5839049",
                          "updatedAt": "2023-05-08T14:38:48Z",
                          "publishedAt": "2023-05-08T14:38:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I get this error in parallel\nError in NearestNodeLocator : The nearest neighbor lies outside the ghosted set of elements. Increase the ghosting_patch_size parameter in the mesh block and try again.\nplease follow these instructions and see if it fixes it",
                  "url": "https://github.com/idaholab/moose/discussions/24294#discussioncomment-5839047",
                  "updatedAt": "2023-05-08T14:38:27Z",
                  "publishedAt": "2023-05-08T14:38:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "nuomi68"
                          },
                          "bodyText": "I also got this error in my attempts, but I do not know how to solve it. I tried to adjust min_gap in GapHeatTransfer, but the problem has not been improved",
                          "url": "https://github.com/idaholab/moose/discussions/24294#discussioncomment-5839089",
                          "updatedAt": "2023-05-08T14:42:14Z",
                          "publishedAt": "2023-05-08T14:42:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It s a mesh parameter. The parameter can be added directly in the Mesh block",
                          "url": "https://github.com/idaholab/moose/discussions/24294#discussioncomment-5839104",
                          "updatedAt": "2023-05-08T14:44:06Z",
                          "publishedAt": "2023-05-08T14:44:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nuomi68"
                          },
                          "bodyText": "I tried to add ghosting_patch_size parameter into the Mesh, but the problem was not solved. NearestNodeLocator error would not appear when  Contact  was not used.\nI am very sorry that I forgot to delete the Contact module in the first input file. If I delete Contact, I will get the multi-threading error I described.",
                          "url": "https://github.com/idaholab/moose/discussions/24294#discussioncomment-5839364",
                          "updatedAt": "2023-05-08T15:13:09Z",
                          "publishedAt": "2023-05-08T15:13:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "nuomi68"
                  },
                  "bodyText": "I've tried a solution to the multithreading error I mentioned above. First I use the--mesh-only command to generate the mesh, and then input files to read the generated mesh so that there will be no multithreading error. I think this error is caused by Libmesh.",
                  "url": "https://github.com/idaholab/moose/discussions/24294#discussioncomment-5846512",
                  "updatedAt": "2023-05-09T08:57:33Z",
                  "publishedAt": "2023-05-09T08:57:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to calculate the Jacobian in [ComputeSimoHughesJ2PlasticityStress]",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hallo MOOSEers,\nI'm trying to use [ComputeSimoHughesJ2PlasticityStress] module, as listed here https://mooseframework.inl.gov/source/materials/lagrangian/ComputeSimoHughesJ2PlasticityStress.html. When I check the source code of it, I cannot figure out how does the jacobian matrix is calculated, specifically the derivatives inside, like 'd_tau_d_F', '_d_be_d_F', '_d_deltaep_d_betr', '_d_n_d_be' , '_d_R_d_betr', '_d_J_d_betr'. I checked to the reference of it (Simo and Hughes (2006), Borden et al. (2016).), but I didn't find these derivatives. So I'm writing to ask how these values are derived, and it would be great if you could refer me to any literatures. Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/24302",
          "updatedAt": "2023-06-24T22:34:43Z",
          "publishedAt": "2023-05-08T21:27:56Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can update the Jacobian iteratively (the one I implemented) like this:\nSimoHughesJ2Jacobian.pdf\nor use the implicit function theorem, which is easier in my opinion.\nI haven't had a chance to publish the above derivation, though it's pretty straightforward IMO.",
                  "url": "https://github.com/idaholab/moose/discussions/24302#discussioncomment-5843244",
                  "updatedAt": "2023-05-09T00:33:42Z",
                  "publishedAt": "2023-05-09T00:33:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thank you! @hugary1995",
                          "url": "https://github.com/idaholab/moose/discussions/24302#discussioncomment-5846113",
                          "updatedAt": "2023-05-09T08:10:04Z",
                          "publishedAt": "2023-05-09T08:10:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}