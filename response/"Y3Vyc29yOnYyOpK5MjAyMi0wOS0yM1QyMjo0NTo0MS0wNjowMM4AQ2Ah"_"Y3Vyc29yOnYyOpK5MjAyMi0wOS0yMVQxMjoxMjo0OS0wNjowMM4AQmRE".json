{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOS0yMVQxMjoxMjo0OS0wNjowMM4AQmRE"
    },
    "edges": [
      {
        "node": {
          "title": "Adding interpolation from file to PiecewiseLinearInterpolationMaterial",
          "author": {
            "login": "AndrewFalkowski"
          },
          "bodyText": "How difficult would it be to add support for pulling x,y values from a file to the PiecewiseLinearInterpolationMaterial object? This seems like a fairly simple and worthwhile addition given how common pulling materials data from files is. From my understanding the only way to currently replicate this is to use a PiecewiseLinear function and then pull that with a CoupledValueFunctionMaterial, which is somewhat cumbersome.",
          "url": "https://github.com/idaholab/moose/discussions/22181",
          "updatedAt": "2022-09-29T17:18:00Z",
          "publishedAt": "2022-09-23T18:00:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Should be GenericFunctionMaterial for the current way to do this*\nThis would not be too hard. It's just x,y values, no time dependence?\nYou could do it through the PropertyReadFile user object or you could duplicate the machinery in the function",
                  "url": "https://github.com/idaholab/moose/discussions/22181#discussioncomment-3721711",
                  "updatedAt": "2022-09-24T04:40:03Z",
                  "publishedAt": "2022-09-24T04:40:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Heterogeneous permeability data file",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear MOOSE developers and users,\nI mesh a vertical 3D block (x:200m;y:5km; z: 5km ) by tetrahedrons using Gmsh. So I don't have regular structured grids.\nI want to create a heterogeneous permeability data file for my model. I learn the Heterogeneous models . It is helpful for me. But I also need the .data file for my model.\nCould you please tell me which open source software/tool can creat such .data file?\nThank you in advance.\nCheer,\nJoseph",
          "url": "https://github.com/idaholab/moose/discussions/22164",
          "updatedAt": "2022-09-23T15:02:15Z",
          "publishedAt": "2022-09-22T12:59:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "The fundamentals of this file usually come from other modelling, eg, statistical modelling of the subsurface, that is based on field experiments and/or lab data.  This gives you some knowledge of the statistics of the permeability distribution (eg mean, standard deviation).   Alternatively, the information could come from field measurements that you want to interpolate, for instance, you know the permeability close to some well-screens, and you need to interpolate that data to other places in the model.\nIn any case, assuming you have some notion of the permeability field that you want to create, you must create the .data file yourself.  I imagine that usually people use python, because it is open-source and pretty universally used (you can publish your software code to generate the permeability field).  Alternatively, there are probably proprietary packages like Leapfrog, Geomodeller, GoCAD, etc, that can output this information.\na",
                  "url": "https://github.com/idaholab/moose/discussions/22164#discussioncomment-3712735",
                  "updatedAt": "2022-09-22T21:10:29Z",
                  "publishedAt": "2022-09-22T21:10:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "Thanks for your guidance. Andy. I am trying to create this data using Python.\nJoseph",
                          "url": "https://github.com/idaholab/moose/discussions/22164#discussioncomment-3718043",
                          "updatedAt": "2022-09-23T15:02:05Z",
                          "publishedAt": "2022-09-23T15:02:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem about compiling the application",
          "author": {
            "login": "K-Komal-98"
          },
          "bodyText": "Earlier, my application got compiled then I updated the conda and moose according to this link \"https://mooseframework.inl.gov/getting_started/installation/update_moose.html\". Now, I am getting error. I repeated the process but the error continues to exist. Kindly help me with this issue. I have attached the screenshots of the error.",
          "url": "https://github.com/idaholab/moose/discussions/22047",
          "updatedAt": "2022-09-29T17:16:13Z",
          "publishedAt": "2022-09-08T05:09:03Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSee this post\n#21936\nYou need to update the packages using mamba.\nMore information on updating (everything, but you dont need to update moose necessarily) there:\nhttps://mooseframework.inl.gov/getting_started/installation/update_moose.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3591118",
                  "updatedAt": "2022-09-08T05:11:50Z",
                  "publishedAt": "2022-09-08T05:11:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "K-Komal-98"
                          },
                          "bodyText": "I updated the packages using mamba but the error is still there. I followed exactly the same instructions given in the link.",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3591270",
                          "updatedAt": "2022-09-08T05:46:00Z",
                          "publishedAt": "2022-09-08T05:46:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I've seen this on Ubuntu (22.04)... Can you provide a mamba list? And also the version of Ubuntu you are using.\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3594190",
                          "updatedAt": "2022-09-08T12:36:37Z",
                          "publishedAt": "2022-09-08T12:36:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Also, if you can refrain from posting pictures of text to these discussions it will help others down the road when performing 'searches' of possibly the same issue you are experiencing.",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3594244",
                          "updatedAt": "2022-09-08T12:43:43Z",
                          "publishedAt": "2022-09-08T12:43:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "K-Komal-98"
                          },
                          "bodyText": "I am working on Ubuntu (22.04). I reinstalled MOOSE and now I am not getting this error but a different one. The error is as follows:\nLinking Executable /home/komal/projects/nucleation_bm/nucleation_bm-opt...\n/home/komal/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/komal/projects/nucleation_bm/lib/libnucleation_bm-opt.so: undefined reference to `InputParameters validParams()'\ncollect2: error: ld returned 1 exit status\nmake: *** [/home/komal/projects/moose/framework/app.mk:416: /home/komal/projects/nucleation_bm/nucleation_bm-opt] Error 1",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3624765",
                          "updatedAt": "2022-09-12T10:47:17Z",
                          "publishedAt": "2022-09-12T10:47:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "K-Komal-98"
                          },
                          "bodyText": "Can you please help me with this error?",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3624846",
                          "updatedAt": "2022-09-12T10:58:15Z",
                          "publishedAt": "2022-09-12T10:58:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ats5662"
                          },
                          "bodyText": "This worked for me\nmamba activate moose\nmamba update --all\nsudo apt-get install lsb-core\ncd ~/projects/moose\nunset LIBMESH_DIR\n./scripts/update_and_rebuild_libmesh.sh",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3626562",
                          "updatedAt": "2022-09-12T14:21:18Z",
                          "publishedAt": "2022-09-12T14:18:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is a conda-based install, you should not run the scripts\nthis error on validParams is likely due to the deprecation of the validParams template. See this post\nhttps://mooseframework.inl.gov/newsletter/2020_04.html#!\nis your app (nuclearion_bm?) open source? So I could try to build it locally\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3627205",
                          "updatedAt": "2022-09-12T15:25:56Z",
                          "publishedAt": "2022-09-12T15:25:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "K-Komal-98"
                  },
                  "bodyText": "I reinstalled many times and now finally the problem is solved. Thankyou!",
                  "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3714369",
                  "updatedAt": "2022-09-23T05:55:06Z",
                  "publishedAt": "2022-09-23T05:55:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about the Function block.",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "I use the method getFunction in Kernel.And I wrote  std::cout<<_ufun.value(_t,_q_point[_qp])<<std::endl; in the precomputeQpResidual() of a ADDiffusion case. _ufun is from _ufun(getFunction(\"function\")).\nThe Function block in input file is like this:\n[Functions]\n[./UFUN]\ntype = PiecewiseLinear\nx = '0 1'\ny = '0 1'\n[../]\n[]\nIt only output 0 in the terminal. It should output the variable's values at quadrature points right? I don't know what went wrong.By the way, the mesh is 1D and xmin = 0 xmax = 1.",
          "url": "https://github.com/idaholab/moose/discussions/22167",
          "updatedAt": "2022-09-23T02:40:08Z",
          "publishedAt": "2022-09-22T13:45:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Ethan-xj"
                  },
                  "bodyText": "It seems like it only output the y value at the first point of x",
                  "url": "https://github.com/idaholab/moose/discussions/22167#discussioncomment-3709690",
                  "updatedAt": "2022-09-22T13:51:35Z",
                  "publishedAt": "2022-09-22T13:51:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Ethan-xj"
                  },
                  "bodyText": "OK. I missed the axis should be x.",
                  "url": "https://github.com/idaholab/moose/discussions/22167#discussioncomment-3713761",
                  "updatedAt": "2022-09-23T02:40:06Z",
                  "publishedAt": "2022-09-23T02:40:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Assembling to Scalar Variable Residual from Mortar Constraint",
          "author": {
            "login": "ttruster"
          },
          "bodyText": "I find myself needing to implement coupling between a scalar variable into a mortar constraint residual and Jacobian and vice versa. I have looked closely over the ScalarLagrangeMultiplier Kernel and the AverageValueConstraint Scalar Kernel for diffusion as well as Homogenization files (Constraint user object, scalar kernel, and off-diagonal Jacobian kernel) for the Tensor Mechanics system. It seems that the \"MOOSE way\" to do this would require a:\n\nMortar Constraint for the off-diagonal Jacobian (I have implemented)\nScalar Kernel to handle the residual and Jacobian of the scalar variable (I have made a hard-coded version)\nA User Object that performs integration over a Mortar lower dimensional boundary object to compute the terms needed in the Scalar Kernel (non-existent in the MOOSE framework or modules; would require some framework expansion)\n\nAs a temporary work-around, I have tried adding direct assembly calls within the Mortar Constraint object for vector-residual and matrix-Jacobian blocks associated with the scalar variable. I'm using calls similar to those in ScalarLagrangeMultiplier and HomogenizedTotalLagrangianStressDivergence, which assembly to the upper and lower blocks of the Jacobian at the same time. They are happening through additional calls (quadrature loops and functions) that I embedded within the ComputeResidual and ComputeOffDiagonalJacobianScalar method calls of the MortarConstraint and MortarConstraintBase files. I have attached a sample of the source code with the loops.\nsrc.txt\nI can confirm from debug-mode that computations are occurring in the Residual Scalar calculation during the time when the Mortar Constraint ComputeResidual method is called. However, it doesn't seem like those values are getting into the global system residual, since the analysis finishes with a zero Nonlinear Residual norm.\nSo, question:  am wondering if it is not possible to assemble residual contributions into other/coupled variables (i.e. the test function rows) different from the primary variable of the object, without modifying the tagging/caching/low-level assembly calls within MOOSE framework that are looping over the objects? The symmetric-block access for the Jacobian within ScalarLagrangeMultiplier gave me hope that would be possible. Of course it is not \"appropriate\" according to MOOSE design, but didn't know if it is technically not feasible.\nThe long term resolution is to make a user-object that has reference to the mortar subdomain mesh and system, to perform the quadrature. I might be able to get that to happen through either a SideUserObject.execute or a DomainUserObject.executeOnBoundary call, if I can get the Two Material System coupled into those. The MortarFrictionalPressureVectorAux AuxKernel gives me hope for doing that, since it also references the mortar mesh and data structure but outside of a Mortar Constraint object. Any clues for going down this route?\nThanks for reading, and suggestions welcome!\nTim",
          "url": "https://github.com/idaholab/moose/discussions/22020",
          "updatedAt": "2022-10-14T03:24:56Z",
          "publishedAt": "2022-09-06T19:34:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "reverendbedford"
                  },
                  "bodyText": "This is exactly analogous to the homogenization constraint stuff in the Lagrangian kernels, right?  So I take it you can't use a ElementUserObject to loop over the lower-dimension mortar blocks?  Shouldn't they just be standard 2D domains (in a 3D problem)?",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3585443",
                  "updatedAt": "2022-09-07T13:56:07Z",
                  "publishedAt": "2022-09-07T13:56:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "The problem is that the \"local\" scalar residual information is not getting incorporated into global data. Here are revised code snippets that should work\nvoid\nVMNTPeriodicBase::::computeResidual()\n{\n  setNormals();\n\n  precalculateResidual();\n\n  if (_compute_primal_residuals)\n  {\n    // Compute the residual for the secondary interior primal dofs\n    computeResidual(Moose::MortarType::Secondary);\n\n    // Compute the residual for the primary interior primal dofs.\n    computeResidual(Moose::MortarType::Primary);\n  }\n\n  if (_compute_lm_residuals)\n    // Compute the residual for the lower dimensional LM dofs (if we even have an LM variable)\n    computeResidual(Moose::MortarType::Lower);\n\n  if (_compute_scalar_residuals)\n    // Compute the residual for the scalar dofs\n    computeResidualScalar();\n}\n\n\n\nvoid\nVMNTPeriodicBase::computeResidualScalar()\n{\n  prepareVectorTag(_assembly, _kappa_var);\n  for (_qp = 0; _qp < _qrule_msm->n_points(); _qp++)\n  {\n    precalculateMaterial();\n    for (_h = 0; _h < _k_order; _h++)\n      _local_re(_h) += _JxW_msm[_qp] * _coord[_qp] * computeQpResidualScalar();\n  }\n\n  accumulateTaggedLocalResidual();\n\n  for (const auto tag_id : _vector_tags)\n  {\n    const auto & vector_tag = _subproblem.getVectorTag(tag_id);\n    _assembly.addResidualScalar(vector_tag);\n  }\n}\nThe call to _assembly.addResidualScalar is the important new piece that takes the local residual and adds it into global residual information",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3585750",
                  "updatedAt": "2022-09-07T14:28:35Z",
                  "publishedAt": "2022-09-07T14:28:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Thanks for suggestions. I've got a summary at the bottom, about the topic of add-Jacobian needs and about user objects.\nI switched the residual assembly to use the tagging system. The compiler complained that\nAssembly::addResidualScalar(const VectorTag&)\u2019 is protected within this context\nAnd so instead I made a call to\n_fe_problem.addResidualScalar();\nThat is in the attached file, with all the other assemblies I am trying to run.\nVMNTPeriodicBase.txt\nI was able to run a test case for heat conduction with mortar periodic conditions and a macro heat flux (analogous to macro stress) imposed, and the analysis solves for the macro thermal gradient as a scalar variable and the temperature field as a Lagrange variable. The analysis converges with the PJFNK solver and gives the correct result for both solution fields.\nHowever, now this issue is that the off-diagonal mortar constraint Jacobian (coupling secondary variable and scalar variable) seem not to be accumulating/adding. When I use the NEWTON solve type, then the residual diverges. When I comment out or otherwise change around the code in the \"computeOffDiagJacobianScalar\" function, the residual normal are identical, which suggests to me that this code isn't getting added to the global Jacobian.\nI've been self-studying on the Problem, System, Loops, and Assembly source files through doxygen to try and learn the ways that local residual/Jacobian blocks get assembled to the global arrays. It seems that each object type (kernel, dgkernel, scalarkernel, ...) get handled at different places; some of them involve caching while the \"ComputeMortarFunctor\" file seems to have less provisions for scalar and off-diagonal variable couplings.\nI've made a couple attempts at getting the local data into the global; those are in the comments of the attached .txt (a .C) file.\nOne thing that mystifies me: the \"ScalarLagrangeMultiplier\" object only contains two lines that give an allocation to a DenseMatrix; there are no calls to an accumulate or an add-Jacobian function below that. My gut says that probably those values need to go into the specially named ken and kne arrays, and that they are swept up by the caching that happens in \"ComputeFullJacobianThread\" and \"NonlinearSystemBase\". But without knowing where to look, I'm not sure what code to copy in order to handle the Secondary-scalar, Primary-Scalar, and Lower-Scalar (and the transposes) assemblies that I need to accumulate.\nIn short, I've been gathering a list of needed assembly and pre-calculate Residual etc. functions that are available for Kernels and are missing in some of the object systems. If it helps, I could be working on the framework to add those and then do a pull request; this would be my first time, so some guidance would help (i.e. I probably need to read this https://mooseframework.inl.gov/framework/contributing.html)\nAbout User Objects: yeah I've been thinking about the minimal integrals needed and I may be able to get by with two single-side integrals rather than having to do a coupled Mortar integral, if I can somehow grab material properties from the opposite element face across the mortar segment pair. It's yet to be seen whether I should try that with an Element user object on 2d blocks (can they be called on the mortar sub-problem?) or if instead needs to happen on the 3d problem Side sets user object.",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3600488",
                  "updatedAt": "2022-09-08T20:52:14Z",
                  "publishedAt": "2022-09-08T20:52:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The problem with\n\n_fe_problem.addResidualScalar();\n\nis that it's not going to honor the vector tags requested by the user for their constraint object. It's going to add to all vectors that are of residual type. A better solution is to make the individual vector tag API that is currently protected public.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3602465",
                          "updatedAt": "2022-09-09T00:22:43Z",
                          "publishedAt": "2022-09-09T00:22:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "About User Objects: yeah I've been thinking about the minimal integrals needed and I may be able to get by with two single-side integrals rather than having to do a coupled Mortar integral, if I can somehow grab material properties from the opposite element face across the mortar segment pair. It's yet to be seen whether I should try that with an Element user object on 2d blocks (can they be called on the mortar sub-problem?) or if instead needs to happen on the 3d problem Side sets user object.\n\nFor fundamental assembly operations I would be hesitant about a design that includes user objects. If user objects are being included, to me that indicates that we don't have friendly enough APIs on our _sys, _assembly, or _subproblem to get your job done, when we really should.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3602478",
                          "updatedAt": "2022-09-09T00:26:22Z",
                          "publishedAt": "2022-09-09T00:26:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "There is definitely some help we need to give you here and at least some framework development that will need to happen. I need to think about this a bit more in order to give you good help (hopefully tomorrow). In the mean time, if you are motivated to do some moose development, please do! We love contributions!",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3602558",
                          "updatedAt": "2022-09-09T00:45:56Z",
                          "publishedAt": "2022-09-09T00:45:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Regarding framework support, I wonder if we can't add an \"integrated\" scalar kernel which loops over the elements to assemble the residual, Jacobian, and off-diagonal Jacobians for a scalar variable. The objects Tim mentioned, e.g. ScalarLagrangeMultiplier, AverageValueConstraint, and HomogenizationConstraintIntegral, will all benefit from having such loop in the framework.\nThe main reason that the Homogenization system in tensor mechanics need to use an ElementUserObject is to retrieve material properties. If we embrace that integrated scalar kernel idea, then we will no longer need such a user object, since we can bring the MaterialInterface into the integrated scalar kernel.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3602881",
                          "updatedAt": "2022-09-09T02:03:11Z",
                          "publishedAt": "2022-09-09T02:03:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "Having \"integrated\" scalar kernels to allow coupling of regular variables and scalar variables would definitely be one way to solve the problems above. They originate from needing to evaluate weak form terms (integrals) have products of variables, scalars, and materials.\nThe \"issue\" is that those integrals would be needed (in the long term) over all the different types of integrals. For my current project goals, I will end up needing integrals for kernels, interfacekernels, and mortar constraint objects to couple with scalar variables. DG-kernels and integrated BCs would be later in the future if cohesive-zone-like damage would be included.\nSo the current approach with the ScalarLagrangeMultiplier, AverageValueConstraint, and HomogenizationConstraintIntegral objects has been instead to use the integration methods that are present within user objects to handle the regular variable and material couplings, and then multiply the integral result onto scalar variable within the kernel; and just make sure the user object gets called on each linear execute.\nSo that seems as a design philosophy question, as to whether enough folks see the utility to have the full coupling ability and put all the scalar integrals as derivatives off of the scalar kernel. Or to just finish expanding the coverage of user objects to handle mortar constraint objects or any other \"missing\" cases.\nThat's where my hiccups have been so far, is needing to figure out which assembly accumulation is missing for various coupling, as well as how to get the integrals done.\nI figured my hack for calling the _fe_problem.addResidualScalar(); might not be great, but I figure that the tagging API is probably protected so that most normal users/developers don't \"mess up\" or call in the tag additions where they shouldn't be.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3602954",
                          "updatedAt": "2022-09-09T02:22:00Z",
                          "publishedAt": "2022-09-09T02:21:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Well, I spent a few hours on Friday night and then did some thinking over the last few days related to the topic of mortar user objects and assembly of scalar variable contributions. I'm going to break the assembly off into another thread to raise an issue there.\nFor the Mortar User Object, I'm pretty sure what needs to happen is to add this object class into computeUserObjectsInternal as well as the initialization locations for user objects, so that this is on the same level as element, side, interface, or domain user objects. Thus, a loop over all mortar user objects would be needed, and so I should emulate what computeMortarFunctor does for looping over MortarConstraintBase objects to collect the residual and/or Jacobian contributions.\nAdding this new type of user object is necessary because:\n\nOnly specialized mortar objects are able to generate the container of material properties and other data needed for the mortar segment calculations, namely loopOverMortarSegments()\nEven for conforming primary/secondary meshes in 3d, for history-dependent or complex material models, the use of quadrature points from a full element side integral are different than the segments, so the accuracy of the computations would degrade compared to using the same quadrature points for both user object and constraint residual integrals\n\nI would like to open an issue with the objective of programming a \"MortarUserObjectBase\" class and the necessary initialization/loops to fit within the user object system. The while the base class would not contain integrals (so you could make other types of mortar objects from it), a derived class with the integration would also be developed.\nThe target application of these developments are:\nProblems involving scalar variables coupled to standard variables along mortar surfaces. An example of this class of problems is: imposition of periodic boundary conditions through surface integration and either penalty, Nitsche, or Lagrange multiplier field methods.\nI've been spending time looking through the framework code, and I have some ideas to get started with, I'll need some discussion/help in the process. This will be my first time working on an issue; I've already forked the main repository and am starting to make commits on the side.",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3645431",
                  "updatedAt": "2022-09-14T14:39:15Z",
                  "publishedAt": "2022-09-14T14:39:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Is there more to this problem than just missing Jacobian accumulations for the scalar variable? That seems like just one missing API call. We are going down what seems like too large a development path if that is the only problem. The missing Jacobian accumulation call is likely very akin to what was the missing residual accumulation call. If that is the only problem, then if you create a branch with a MNWE (minimal non-working example), then I think we could get this solved pretty quickly. (I generally prefer branches over shared text files because then it is much easier to document improvements via commits)",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3648443",
                          "updatedAt": "2022-09-14T21:16:23Z",
                          "publishedAt": "2022-09-14T21:16:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "We can avoid the user object route if we do 3 of the 4 needed Jacobian (scalar to variable, variable to scalar, and scalar to scalar) and 2 of the 2 needed residual (variable and scalar) computations all within one Mortar Constraint. This was the \"hacky\" way I proposed at the top, since it seems to violate the MOOSE goal of 'each object compute and assemble contributions only to the variable it owns', i.e. to one row of the Jacobian and residual (variable to variable handled in another constraint file, and scalar to variable). I'm also wondering if there is potential value to open up user objects and post processors that do loops over mortar segments for some other purposes.\nI terms of a MNWE, I have my forked repo here: https://github.com/Truster-Research-Group/moose-clmi_lab\nAgain, first timer: should I put the test input file in the /test/test directory somewhere, the needed .C and .h files for the code I've created which needs the accumulate commands within /test/src and /test/include respectively, and make a commit saying what file to run, push that commit to my repo, and let you know about it by posting on the forum here? Or can you paste a link to a forum post that has the process I should emulate?",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3649231",
                  "updatedAt": "2022-09-15T00:32:02Z",
                  "publishedAt": "2022-09-15T00:32:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "What is this scalar variable? What does it represent physically? Does it have other residual objects that contribute to its residual/Jacobian? I would say that the MOOSE philosophy is to (loosely) have an object per physics/PDE-term. Mortar constraints themselves can already contribute residuals/Jacobians to three different variables (secondary variable, primary variable, LM variable).\n\nAgain, first timer: should I put the test input file in the /test/test directory somewhere, the needed .C and .h files for the code I've created which needs the accumulate commands within /test/src and /test/include respectively, and make a commit saying what file to run, push that commit to my repo, and let you know about it by posting on the forum here?\n\nI would just keep your code in whatever directories you already have them in. You can also put your input wherever you want. I can see where all your files are located just by running commands like git show --name-only HEAD. Before committing and pushing you might want to checkout a new branch (something like git checkout -b non-working-scalar-in-mortar)",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3649667",
                          "updatedAt": "2022-09-15T02:13:03Z",
                          "publishedAt": "2022-09-15T02:13:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Hit the enter key...\nThere are two scalar variables for this problem: the macro flux-gradient prescribed through an aux-variable, and the macro actual gradient solved for alongside the concentration field. For solid mechanics, these are analogous to macro-stress and macro-strain, respectively, applied to an RVE. Theory for Nitsche method version is described here https://www.sciencedirect.com/science/article/pii/S0045782519305481 and the mortar version is described here https://www.sciencedirect.com/science/article/pii/S0045782514000528.\nThe scalar variable is coupled/integrated along each RVE boundary pair, which likely are doing to be different mortar surfaces. Yet they are pretty much going to involve the same variables each time.\nAs seen in the example, the residual/Jacobian terms of the primary to secondary variable can be handled in a different object than the terms involving products of the primary/secondary with the scalar variable. Or you could put those terms within the same object with the scalar; I split them up here to illustrate the point.\nIn short, the term from the paper above that I've implemented is { [w1-w2] - dxkappa } * tau * { [u1-u2] - dxepsilon } where 1=primary, 2=secondary, epsilon is the scalar unknown (macro gradient [u,x u,y]), u is the variable unknown, dx = [x1-x2, y1-y2] in 2d, and w/kappa are the weighting functions. So if you call this \"one term\", then yes it can all go into one object.\nAbout the performance: right now, the PJFNK method is used so that it will converge. Using Newton doesn't converge because the off diagonal Jacobian Scalar terms aren't getting assembled. I have also left the residual assembly with the _fe_problem object instead of _assembly.addResidualScalar for the time being. But I'm going to be adding some other examples in the next couple days that try that after changing it to a public method.\nLet me know your thoughts, thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3670837",
                  "updatedAt": "2022-09-17T19:35:00Z",
                  "publishedAt": "2022-09-17T19:35:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Is the branch name non-working-scalar-in-mortar?",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3676504",
                          "updatedAt": "2022-09-18T23:38:07Z",
                          "publishedAt": "2022-09-18T23:38:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@jbadger95, Nitsche method (but for periodic boundary constraints as opposed to mechanical contact constraints)",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3676507",
                          "updatedAt": "2022-09-18T23:45:18Z",
                          "publishedAt": "2022-09-18T23:38:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "Yes, that's the branch; others are for other in progress work.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3677257",
                          "updatedAt": "2022-09-19T03:19:19Z",
                          "publishedAt": "2022-09-19T03:19:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "I added another test case of scalar variables using the Kernel this time, into the non-working-scalar-in-mortar. There is a base class KernelScalarBase which expands the Kernel computations to act on a second coupled variable (a scalar). I created it using LowerDIntegratedBC as a model for how to add the contributions from the 2nd variable and reuse the quadrature loops and methods of the underlying class.\nAs a test case, I copied over the ScalarLagrangeMultiplier and AverageValueConstraint contributions to be in the single derived class ScalarLMKernel. I also copied the test case scalar_constraint_kernel.i and modified it to have syntax for this new object.\nThere are some comments in the file about 'temporary' fixes to make it execute. The good news is, the solution converges to the same analytical result that the existing 3 object system (with a post processor integral) does, which means the residual is being assembled; the bad news is that the convergence is slow, so something is off with the Jacobian. I literally copied the Dense Matrix calls from the existing objects, and this is deriving from the same Kernel class; although I am using the Kernel's off diagonal Scalar method for computing one of the contributions.\nThoughts? Again, some Jacobian accumulation/adding seems to be missing.",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3686129",
                  "updatedAt": "2022-09-20T02:43:14Z",
                  "publishedAt": "2022-09-20T02:43:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "I spoke too soon and didn't look closely at the iteration type: in fact, it is doing linear/matrix solver iterations, not Newton iterations.\nI confirmed after adding an off diagonal scalar method using dense matrix assembly, identical to ScalarLagrangeMultiplier, that the linear iterations are identical for the new and old systems. Also, with a new input file scalar_constraint_kernel_LU.i which uses an LU solver and Newton method, that indeed there is just one iteration.\nSo the Dense Matrix approach seems to work for the Kernel objects, but does not work for the Constraint or Interface-Kernel objects (yet). Thoughts on why that is?\nAlso, I've been wondering how either the Dense Matrix or the tagged scalar vectors/matrices will work in parallel (threaded/OpenMP or distributed/MPI) cases? I've been running it with one thread so far. The adding of the residual from multiple threads to the same scalar variable rows probably creates a race condition.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3690121",
                          "updatedAt": "2022-09-20T12:50:14Z",
                          "publishedAt": "2022-09-20T12:50:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "we have mutex locks to ensure no race conditions when attempting to add or insert into the global vector or matrix",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3701863",
                          "updatedAt": "2022-09-21T15:51:48Z",
                          "publishedAt": "2022-09-21T15:51:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "So the Dense Matrix approach seems to work for the Kernel objects, but does not work for the Constraint or Interface-Kernel objects (yet). Thoughts on why that is?\n\nDifferent calls to different assembly methods after the residual object jacobian routines. I hope to run your code soon to verify. Fixing this should just be a couple line addition in framework code",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3701869",
                          "updatedAt": "2022-09-21T15:53:44Z",
                          "publishedAt": "2022-09-21T15:53:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "Thanks. I also made a couple more commits related to the kernel plus scalar coupling. Now that class can act as a pseudo-intermediate class to add coupling to scalars but not require the scalar to be used in the derived classes. This would help for the tensor mechanics homogenization case, where that class derives 3 levels down from the Kernel class. The example test shows the Diffusion Kernel can derive from it instead and not use a scalar.\nMaybe these can point out some things about assembly too.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3711273",
                          "updatedAt": "2022-09-22T17:00:51Z",
                          "publishedAt": "2022-09-22T17:00:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "There are so many routines in TestPeriodicBase it's hard for me to wrap my head around what is adding to what. Can you tell me exactly what routines do these couplings?\n\nfield-scalar\nscalar-field\n\nI assume field-scalar is done solely by computeOffDiagJacobianScalar, but I want to be sure.\nPlease respond within this thread (via 'Reply') while we're on this topic. It's hard for me to keep track of the thread of conversation when there are multiple Answers addressing the same thread of conversation.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3712234",
                          "updatedAt": "2022-09-22T19:31:20Z",
                          "publishedAt": "2022-09-22T19:30:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Actually I've created issue #22174, so let's continue this over there.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3712326",
                          "updatedAt": "2022-09-22T19:45:11Z",
                          "publishedAt": "2022-09-22T19:45:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MetaPhysicL error in ThreadedElementLoopBase",
          "author": {
            "login": "czadeh"
          },
          "bodyText": "Hello,\nI added a new material property to an application I have been working on and now I get an error when I run an input file with the new MP.\nI have 2 AD variables and now 4 MPs. My input file without the new MP runs fine, but now I am getting this error:\n*** ERROR ***\nWe caught a MetaPhysicL error in ThreadedElementLoopBase. This is very likely due to AD not having a sufficiently large derivative container size. Please run MOOSE configure with the '--with-derivative-size=' option\nIs this normal? Should I change the derivative size? If so, how?\nThanks,\nCameron",
          "url": "https://github.com/idaholab/moose/discussions/22033",
          "updatedAt": "2022-09-29T17:15:56Z",
          "publishedAt": "2022-09-07T17:35:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat do you mean by MP?  material property right?\nThis error can happen with AD. You should do what the prompt says. The default is 53 for the container size, you may try like 100 at first.\nIn the moose/ folder, run ./configure --with-derivative-size=100\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3588507",
                  "updatedAt": "2022-09-07T19:53:20Z",
                  "publishedAt": "2022-09-07T19:40:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "Sorry, I meant material property. I will try that and let you know.",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3588650",
                          "updatedAt": "2022-09-07T20:03:54Z",
                          "publishedAt": "2022-09-07T20:03:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "Still getting that error even when I keep increasing the derivative size up to 2000. Perhaps it is an issue with the new files I added?",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3598827",
                          "updatedAt": "2022-09-08T18:50:18Z",
                          "publishedAt": "2022-09-08T18:50:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "weird. Are you recompiling after the configure?",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3599422",
                          "updatedAt": "2022-09-08T19:43:49Z",
                          "publishedAt": "2022-09-08T19:43:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "I recompiled my project I was working on before I tried again.",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3600418",
                          "updatedAt": "2022-09-08T20:39:52Z",
                          "publishedAt": "2022-09-08T20:39:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok good.\nThe error in Metaphysicl is not the error the prompt mentions then.\nPlease follow these instructions here to get us a backtrace\nhttps://mooseframework.inl.gov/application_development/debugging.html\nalso let s consider any floating point operation you have on AD numbers. Do you have exotic tanh2 etc functions?",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3601447",
                          "updatedAt": "2022-09-08T22:04:49Z",
                          "publishedAt": "2022-09-08T22:04:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "Funny you mention that, I use the tanh function on AD Reals in my calculation.",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3601655",
                          "updatedAt": "2022-09-08T22:39:35Z",
                          "publishedAt": "2022-09-08T22:39:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you drop it for testing?\nIt could be that",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3601804",
                          "updatedAt": "2022-09-08T22:44:56Z",
                          "publishedAt": "2022-09-08T22:44:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "I dropped the tanh but still had the issue... but then I broke down my function line by line and I found out this:\n\nwhen log and tanh functions are removed it works fine\nif there are either log or tanh functions it gives that error",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3609445",
                          "updatedAt": "2022-09-09T15:06:43Z",
                          "publishedAt": "2022-09-09T15:06:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you add checks that you are within the range of validity of these functions?\nand the range where the derivative is well defined as well. if the derivative is no longer defined then that could be trouble\nlog is only trouble near 0 I think?",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3610869",
                          "updatedAt": "2022-09-09T18:03:07Z",
                          "publishedAt": "2022-09-09T18:03:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "What METHOD are you compiling with? (Default is opt)",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3613091",
                          "updatedAt": "2022-09-10T05:01:33Z",
                          "publishedAt": "2022-09-10T05:01:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Compiling questions about using fluid properties module",
          "author": {
            "login": "Raven-pro"
          },
          "bodyText": "Hello, everyone.\nI am trying to use MOOSE to simulate two-phase flow based on the basic homogeneous equations, and in the process, I need to calculate void fraction, densities and the saturate temperature and stuffs like that.\nThen I thinke it's a good choice to develop a outside module to calculate the properties, like, creating a C++ file with functions, and  transfer the input variables in then get parameters I want.\nAnd then I decide to look into the FLUID PROPERTIES module (Water97FluidProperties, to be specific), to import the desired properties parameters into the Material Object, identicial to the process presented in the page below.\nhttps://mooseframework.inl.gov/modules/fluid_properties/index.html\nThen I turn the module selection (FP only) in the Makefile to \"yes\". But it says that the Material file I want to use is not registered and the process goes wrong.\nThen I turn all the modules on in the Makefile, and everything goes well.\nSo, does that mean the FP modules can only be used with some other modules imported or something? If I just want to use it as a calculation module, is there anything more I should take care?\nCould you help me with this problem, thanks a lot.",
          "url": "https://github.com/idaholab/moose/discussions/22007",
          "updatedAt": "2022-09-22T13:00:05Z",
          "publishedAt": "2022-09-03T15:42:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou should be able to import just the fluid properties module. Maybe something isn\u2019t set up quite right.\nCould you please try building your application with the Navier Stokes module? That should include the fluid properties module\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22007#discussioncomment-3544392",
                  "updatedAt": "2022-09-03T20:31:24Z",
                  "publishedAt": "2022-09-03T20:31:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Thank you! Sorry for not being able to reply in time.\nI have revised my setting and found what is wrong(mistyping of my code mostly), after the debugging the code could run successfully.\nBut I ran into another problem, the parameters supposed to be calculated in the Material module cannot transfer to the kernels(I tried to use std::cout << to see if  I get parameters wrong, and they were wrong indeed.), causing the disconvergence of the simulation.\nBelow is my input file. Could you help me find out what's wrong? Thanks a lot!\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    nx = 10\n    xmax = 1.0\n    xmin = 0\n[]\n\n[Modules]\n    [FluidProperties]\n        [iapws]\n            type = Water97FluidProperties\n        []\n    []\n[]\n\n[Variables]\n    [P]\n        order = FIRST\n        family = LAGRANGE\n        initial_condition = 15500000.0\n    []\n    [W]\n        order = FIRST\n        family = LAGRANGE\n        initial_condition = 0.3911\n    []\n    [H]\n        order = FIRST\n        family = LAGRANGE\n        initial_condition = 1133820.0\n    []\n[]\n\n[Materials]\n    [fp_mat]\n        type = IAPWS97Material\n        pm = P\n        hm = H\n        fp = iapws\n    []\n[]\n\n[Kernels]\n    [ContinumPressureTime]\n        type = ContinumPressureTime\n        variable = P\n        hm = H\n    []\n    [ContinumMassGrad]\n        type = ContinumMassGrad\n        variable = P\n        grad_w = W\n        velocity = \"1.0 1.0 1.0\"\n    []\n    [MomentumMassTime]\n        type = MomentumMassTime\n        variable = W\n    []\n    [MomentumMassGrad]\n        type = MomentumMassGradCoupled\n        variable = W\n        p = P\n        hm = H\n        velocity = \"1.0 1.0 1.0\"\n    []\n    [MomentumPressureGrad]\n        type = MomentumPressureGradCoupled\n        variable = W\n        p = P\n        hm = H\n        grad_p = P\n        velocity = \"1.0 1.0 1.0\"\n    []\n    [MomentumMassSource]\n        type = MomentumMassSource\n        variable = W\n        p = P\n        hm = H\n    []\n    [MomentumFrictionSource]\n        type = MomentumFrictionSource\n        variable = W\n        p = P\n        hm = H\n    []\n    [EnergyEnthalpyTime]\n        type = EnergyEnthalpyTime\n        variable = H\n        p = P\n    []\n    [EnergyEnthalpyGrad]\n        type = EnergyEnthalpyGrad\n        variable = H\n        w = W\n        velocity = \"1.0 1.0 1.0\"\n    []\n    [EnergyHeatSource]\n        type = EnergyHeatSource\n        variable = H\n    []\n    [EnergyPressureTime]\n        type = EnergyPressureTime\n        variable = H\n        v = P\n    []\n    [EnergyFrictionSource]\n        type = EnergyFrictionSource\n        variable = H\n        w = W\n        p = P\n    []\n[]\n\n[BCs]\n    [bc1]\n        type = DirichletBC\n        variable = H\n        value = 1133820.0\n        boundary = \"left\"\n    []\n    [bc2]\n        type = DirichletBC\n        variable = P\n        value = 15500000.0\n        boundary = \"right\"\n    []\n    [bc3]\n        type = DirichletBC\n        variable = W\n        value = 0.3911\n        boundary = \"left\"\n    []\n[]\n\n#[VectorPostprocessors]\n  #[H]\n    #type = NodalValueSampler\n    #variable = H\n    #boundary = 'bottom'\n    #block = 0\n    #execute_on = 'initial timestep_end' \n    #use_displaced_mesh = true\n    #sort_by = x\n  #[]\n  #[P]\n    #type = NodalValueSampler\n    #variable = P\n    #boundary = 'bottom'\n    #block = 0\n    #execute_on = 'initial timestep_end' \n    #use_displaced_mesh = true\n    #sort_by = x\n  #[]\n#[]\n\n[Problem]\n    type = FEProblem\n    coord_type = XYZ\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n    type = Transient\n    solve_type =  PJFNK\n    automatic_scaling = false\n    scheme = bdf2\n    petsc_options_iname = '-pc_type -pc_hypre_type'\n    petsc_options_value = 'hypre boomeramg'\n    num_steps = 10000\n    #start_time = 0.0\n    dt = 0.00001\n    #end_time = 1.0\n    steady_state_tolerance = 0.1\n    steady_state_detection = true\n[]\n\n[Outputs]\n    exodus = true\n    csv = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/22007#discussioncomment-3682703",
                          "updatedAt": "2022-09-19T16:05:12Z",
                          "publishedAt": "2022-09-19T16:05:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Another thing I want to ask about is, I noticed that all the userobjects files of the module FLUID PROPERTIES are registered to FluidPropertiesApp.\nDoes that mean, when I am compiling, there will be built both my application and the properties application, and I can use the parameters calculated in the FluidPropertiesApp to perform the simulation in my app, some kind of coupling?",
                          "url": "https://github.com/idaholab/moose/discussions/22007#discussioncomment-3682749",
                          "updatedAt": "2022-09-19T16:09:54Z",
                          "publishedAt": "2022-09-19T16:09:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nObjects registered to the fluid properties app will be available in any app that includes the FLUID_PROPERTIES module. You can look at the Makefile to see which modules are included.\nWhat is this IAPWS97 material? It's not part of MOOSE.\nWhy are you not using the materials in MOOSE (such as FluidPropertiesMaterialPT, or GeneralFluidProps) to compute the fluid properties from the iapws object?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22007#discussioncomment-3683544",
                          "updatedAt": "2022-09-19T18:02:47Z",
                          "publishedAt": "2022-09-19T18:02:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Yes, IAPWS97Material is the file I created myself, and I have also added some functions in the Water97FluidProperties file. The material file is in moose/modules/fluid_properties/src/materials/.\nThe codes are as follows.\n#include \"IAPWS97Material.h\"\n#include \"Water97FluidProperties.h\"\n\nregisterMooseObject(\"FluidPropertiesApp\", IAPWS97Material);\n\nInputParameters\nIAPWS97Material::validParams()\n{\n    InputParameters params = Material::validParams();\n    params.addRequiredCoupledVar(\"pm\", \"Pressure mixture\");\n    params.addRequiredCoupledVar(\"hm\", \"Enthalpy mixture\");\n    params.addRequiredParam<UserObjectName>(\"fp\", \"The name of the user object for fluid properties\");\n    params.addClassDescription(\"Compute fluid properties using formulations\");\n    return params;\n}\n\nIAPWS97Material::IAPWS97Material(const InputParameters & parameters): \nMaterial(parameters),\n_Enth(coupledValue(\"hm\")),\n_Pressure(coupledValue(\"pm\")),\n/// Properties to be calculated\n_hg(declareProperty<Real>(\"hg\")),\n_hl(declareProperty<Real>(\"hl\")),\n_vg(declareProperty<Real>(\"vg\")),\n_vl(declareProperty<Real>(\"vl\")),\n_T(declareProperty<Real>(\"temperature\")),\n_alpha(declareProperty<Real>(\"alpha\")),\n_kg(declareProperty<Real>(\"kg\")),\n_kl(declareProperty<Real>(\"kl\")),\n_rhog(declareProperty<Real>(\"rhog\")),\n_rhol(declareProperty<Real>(\"rhol\")),\n_rhom(declareProperty<Real>(\"rhom\")),\n\n_fp(getUserObject<Water97FluidProperties>(\"fp\"))\n{}\n\nIAPWS97Material::~IAPWS97Material(){}\n\nvoid\nIAPWS97Material::computeQpProperties()\n{\n    _T[_qp] = _fp._Tsat_P(_Pressure[_qp]);\n    _hg[_qp] = _fp._hg_sat_P(_Pressure[_qp]);\n    _hl[_qp] = _fp._hl_sat_P(_Pressure[_qp]);\n    _vg[_qp] = _fp._vg_sat_P(_Pressure[_qp]);\n    _vl[_qp] = _fp._vl_sat_P(_Pressure[_qp]);\n    _rhog[_qp] = 1/_vg[_qp];\n    _rhol[_qp] = 1/_vl[_qp];\n    _alpha[_qp] = _fp._hmm_alpha(_Pressure[_qp], _hg[_qp], _hl[_qp], _rhog[_qp], _rhol[_qp]);\n    _rhom[_qp] = _alpha[_qp] * _rhog[_qp] + (1 - _alpha[_qp]) * _rhol[_qp];\n    Real epsilon = 100;\n    _kg[_qp] = ((1/_fp._vg_sa(t_P(_Pressure[_qp] + epsilon)) - (1/_fp._vg_sat_P(_Pressure[_qp])))/epsilon;\n    _kl[_qp] = ((1/_fp._vl_sat_P(_Pressure[_qp] + epsilon)) - (1/_fp._vl_sat_P(_Pressure[_qp])))/epsilon;\n}",
                          "url": "https://github.com/idaholab/moose/discussions/22007#discussioncomment-3685977",
                          "updatedAt": "2022-09-20T02:12:29Z",
                          "publishedAt": "2022-09-20T02:12:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "But the parameters supposed to be transfered to the main App are wrong and constant(like _T[_qp], is always value 25.491, and _kg[_qp] is always 1.15236e-241). I tried changing the expression of the parameters(like setting value _T[_qp] = 1) and it doesn't work.",
                          "url": "https://github.com/idaholab/moose/discussions/22007#discussioncomment-3685994",
                          "updatedAt": "2022-09-20T02:16:08Z",
                          "publishedAt": "2022-09-20T02:15:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "are you storing the material properties as references?\nif not you are making local copies, which is why it doesnt work",
                          "url": "https://github.com/idaholab/moose/discussions/22007#discussioncomment-3686082",
                          "updatedAt": "2022-09-20T02:32:35Z",
                          "publishedAt": "2022-09-20T02:32:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "I recompiled the App and then it worked. Maybe I should use make clean each time I compile the App.\nThanks a lot for your patient replies!",
                          "url": "https://github.com/idaholab/moose/discussions/22007#discussioncomment-3709238",
                          "updatedAt": "2022-09-22T13:00:07Z",
                          "publishedAt": "2022-09-22T13:00:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Transfer two local variables of MasterApp to one global variable of SubApp",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, MOOSE developers.\nI want to couple two input files by MultiApps & Transfers system. In MasterApp, there are two blocks, the temperature of the fluid block is Tf, and the temperature of the solid block is Ts. In the SubApp, the temperature variable for both the fluid and solid regions is defined as T. MasterApp and SubApp share one mesh file.\nI calculated Tf and Ts in MasterApp, and now I want to transfer them to T of the corresponding block. What I mean is to transfer Ts to T of solid block, and transfer Tf to T of fluid block.\nThis is my ideal situation and results:\n\nWhen I use the following syntax, the value of Ts in the fluid block (actually 0, because Ts is not defined in the fluid block in MasterApp) will overwrite the T of fluid block in SubApp passed by Tf.\n[Transfers]\n  [./to_sub_Tf]\n    type = MultiAppProjectionTransfer\n    direction = to_multiapp\n    multi_app = SubApp\n    source_variable = Tf\n    variable = T\n  [../]\n  [./to_sub_Ts]\n    type = MultiAppProjectionTransfer\n    direction = to_multiapp\n    multi_app = SubApp\n    source_variable = Ts\n    variable = T\n  [../]\n[]\n\nThis is the actual situation and results:\n\n\nHow can I make T get the Ts and Tf of the corresponding block?",
          "url": "https://github.com/idaholab/moose/discussions/22155",
          "updatedAt": "2022-09-22T06:54:51Z",
          "publishedAt": "2022-09-21T15:28:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nBasically you need to block-restrict your transfers. The last transfer is overwriting the previous value of T here.\nA few options:\n\nuse a different transfer that supports block restriction\nimplement block restriction (not hard) in your transfer\nuse the transfers in this PR, which have block restriction #17417\nmerge Ts and Tf in T_merged before transfering. You can use the SelfAux to do that or the ParsedAux\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22155#discussioncomment-3703188",
                  "updatedAt": "2022-09-21T18:40:41Z",
                  "publishedAt": "2022-09-21T18:40:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thanks for your useful suggestions. I solved this problem based on your fourth suggestion. I defined an auxvariable named T_merged, then used SelfAux to merge Ts and Tf in T_merged. In Transfers I use T_merged to transfer data to T directly. In order to provide a reference for those who encounter similar problems later, I show the input sentence below:\n[AuxVariables]\n  [./T_merged]\n    family = LAGRANGE\n    order = FIRST\n    block = 'cool clad fuel'\n  [../]\n[]\n\n[AuxKernels]\n  [./Ts_to_T_merged]\n    type = SelfAux\n    variable = T_merged\n    block = 'fuel clad'\n    v = Ts\n  [../]\n  [./Tf_to_T_merged]\n    type = SelfAux\n    variable = T_merged\n    block = 'cool'\n    v = Tf\n  [../]\n[]\n\nBy the way, will you add MultiAppGeneralFieldTransfer to MOOSE's Transfers system in the future? I prefer to use this object after updating MOOSE, rather than using T_merged.",
                          "url": "https://github.com/idaholab/moose/discussions/22155#discussioncomment-3706300",
                          "updatedAt": "2022-09-22T06:55:55Z",
                          "publishedAt": "2022-09-22T06:18:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ll work on it in the coming month",
                          "url": "https://github.com/idaholab/moose/discussions/22155#discussioncomment-3706511",
                          "updatedAt": "2022-09-22T06:54:02Z",
                          "publishedAt": "2022-09-22T06:54:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Looking forward to it!",
                          "url": "https://github.com/idaholab/moose/discussions/22155#discussioncomment-3706524",
                          "updatedAt": "2022-09-22T06:54:49Z",
                          "publishedAt": "2022-09-22T06:54:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How can I get the current element's ID in Kernel?",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "I found the method getElementIDIndex in ElementIDInterface. But how to use it?",
          "url": "https://github.com/idaholab/moose/discussions/22154",
          "updatedAt": "2022-09-22T06:37:24Z",
          "publishedAt": "2022-09-21T14:54:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "The doxygen documents are very useful tools to help you figure out this sort of question.\n\nFor almost everything related to element, you should consult the libmesh doxygen here: https://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1Elem.html. The method you need is probably Elem::id(). There are other IDs of course.\nFor kernel objects, you should consult the MOOSE doxygen here e.g. https://mooseframework.inl.gov/docs/doxygen/moose/classKernel.html where you can find a member called _current_elem of type const Elem *const &.\n\nCombining 1 and 2, you can use _current_elem->id() in any object that derives from Kernel to obtain the ID of the current element.",
                  "url": "https://github.com/idaholab/moose/discussions/22154#discussioncomment-3701489",
                  "updatedAt": "2022-09-21T15:11:09Z",
                  "publishedAt": "2022-09-21T15:11:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Thank you :D",
                          "url": "https://github.com/idaholab/moose/discussions/22154#discussioncomment-3706409",
                          "updatedAt": "2022-09-22T06:37:25Z",
                          "publishedAt": "2022-09-22T06:37:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Best way to couple several apps",
          "author": {
            "login": "aarograh"
          },
          "bodyText": "I'm working on coupling several apps together.  Up to this point We've only been coupling 2 apps, so the approach we took was to have one app's class inherit from the other to have full access to everything in both apps.  However, when adding a third app, this introduces a diamond inheritance that cannot be overcome (without modifying the parent apps, which isn't an option).  I'm aware people have compiled several apps together, so I'm sure the approach I've taken so far must not be the recommended approach.  Could someone point me toward something that would give an example of how I should actually do this?",
          "url": "https://github.com/idaholab/moose/discussions/21980",
          "updatedAt": "2022-09-21T18:12:49Z",
          "publishedAt": "2022-08-31T18:26:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCould you please ask access to BlueCrab on the INL NCRC?\nThat will be a good example of how to combine applications.\nWhile the inner apps are restricted, BC is actually EAR-99 so we should be able to get you to see it very quickly.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3521448",
                  "updatedAt": "2022-08-31T20:35:58Z",
                  "publishedAt": "2022-08-31T20:35:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "please let us know when you have made the request",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3521449",
                          "updatedAt": "2022-08-31T20:36:09Z",
                          "publishedAt": "2022-08-31T20:36:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "Ok, I'll do that.  Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3522103",
                          "updatedAt": "2022-08-31T22:30:46Z",
                          "publishedAt": "2022-08-31T22:30:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Cardinal is an open source example of this otherwise\nhttps://github.com/neams-th-coe/cardinal/blob/devel/src/base/CardinalApp.C\nyou can see every app in there, with all the registering",
                  "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3521619",
                  "updatedAt": "2022-08-31T21:05:24Z",
                  "publishedAt": "2022-08-31T21:05:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the Makefile also has the necessary mods, but it s more complicated because OpenMC and Nek arent moose apps",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3521624",
                          "updatedAt": "2022-08-31T21:05:49Z",
                          "publishedAt": "2022-08-31T21:05:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "Thanks for the info. I'll check that out.  I'll be working with a non-MOOSE app shortly too, so this might be a really helpful example",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3522101",
                          "updatedAt": "2022-08-31T22:30:36Z",
                          "publishedAt": "2022-08-31T22:30:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "@GiudGiud thanks again for this suggestion.  This has helped with sorting out some issues.  I do have a follow-up question.  I wanted to enable coupling between the 2 apps using both MultiApps and \"full coupling\".  Previously we accomplished \"full coupling\" by having moleApp inherit from SamApp.  I'm trying to move away from this approach since I\"m guessing there's a better way of accomplishing that.\nMy current issue is that the \"full coupling\" inputs fail when trying to read the portions of the input related to SAM syntax.  However, if I try calling SAM's SAM::associateSyntaxInner() from moleApp::setupOptions() (SAM calls it from SamApp::setupOptions(), so I'm just mimicking SAM on this one) I just get a segfault.  Here's the backtrace on the segfault.  Any suggestions on the \"proper\" way to accomplish full coupling?  I tried looking around the MOOSE documentation but haven't found the answer yet.\nProgram received signal SIGSEGV, Segmentation fault.\n0x00007ffff786795e in SamApp::setSimulation (this=0x0, sim=0x555555d8a8d0) at /home/ag6/zoo/mole_sam/contrib/SAM/src/base/SamApp.C:47\n47        _sim = sim;\n(gdb) bt\n#0  0x00007ffff786795e in SamApp::setSimulation (this=0x0, sim=0x555555d8a8d0) at /home/ag6/zoo/mole_sam/contrib/SAM/src/base/SamApp.C:47\n#1  0x00007ffff7231d7f in SAMCreateMeshAction::act (this=0x555555b48760) at /home/ag6/zoo/mole_sam/contrib/SAM/src/actions/SAMCreateMeshAction.C:62\n#2  0x00007ffff2e09a8b in Action::timedAct (this=0x555555b48760) at /home/ag6/zoo/mole_sam/moose/framework/src/actions/Action.C:92\n#3  0x00007ffff2e0e402 in ActionWarehouse::executeActionsWithAction (this=0x55555582de20, task=...) at /home/ag6/zoo/mole_sam/moose/framework/src/actions/ActionWarehouse.C:384\n#4  0x00007ffff2e0df2c in ActionWarehouse::executeAllActions (this=0x55555582de20) at /home/ag6/zoo/mole_sam/moose/framework/src/actions/ActionWarehouse.C:344\n#5  0x00007ffff4310546 in MooseApp::runInputFile (this=0x55555582d840) at /home/ag6/zoo/mole_sam/moose/framework/src/base/MooseApp.C:1044\n#6  0x00007ffff4313d4c in MooseApp::run (this=0x55555582d840) at /home/ag6/zoo/mole_sam/moose/framework/src/base/MooseApp.C:1403\n#7  0x00005555555577c7 in main (argc=3, argv=0x7fffffffc2c8) at /home/ag6/zoo/mole_sam/src/main.C:33",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3693303",
                          "updatedAt": "2022-09-20T18:25:33Z",
                          "publishedAt": "2022-09-20T18:25:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Full coupling with SAM is more complicated because SAM replaces some of the moose syntax, notably postprocessors syntax.\nThe SAMApp is null? (this = 0x0) A missing createApp call is likely. I think that's usually done in main.C. What kind of app do you create there?",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3694534",
                          "updatedAt": "2022-09-20T21:19:51Z",
                          "publishedAt": "2022-09-20T21:19:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "Yeah, as I was leaving for the day I noticed that in main.C and wondered if that might be part of the issues.  Here is what was in main.C already:\n  std::shared_ptr<MooseApp> app = AppFactory::createAppShared(\"moleTestApp\", argc, argv);\n  app->run();\n\nI add this line between the two above just on a whim:\n  std::shared_ptr<MooseApp> sam_app = AppFactory::createAppShared(\"SamApp\", argc, argv);)\n\nHowever, that did not work.  I'm assuming the issue is that the setSimulation method on SamApp takes a SAMSimulation * but is being given an FEProblem * or something like that because SamApp is not driving the solve.\nI'm open to ideas you may have to resolve this, but at this point I may just switch these tests to be MultiApps tests instead, and not bother supporting the full coupling.  However, if you have any quick ideas, please let me know and I'll try them out.",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3695599",
                          "updatedAt": "2022-09-21T01:46:59Z",
                          "publishedAt": "2022-09-21T01:46:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You would not create two apps, you would replace what you have with \"moleTestApp\" to \"SamApp\"\nIf there is indeed a cast from MooseApp to SamApp in SAMSimulation that could be the problem. I ll try to get my hands on SAM again and double check.\nAre the simulation domains overlapping between SAM and Mole? Or are they coupled at boundary conditions?",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3696132",
                          "updatedAt": "2022-09-21T03:49:47Z",
                          "publishedAt": "2022-09-21T03:49:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "Using SamApp instead of moleTestApp won't work because then I don't have access to all the mole components I need.\nThe simulation domains are expected to be overlapping for now, yes.  However, I can foresee cases where that may not be the case (either they would be coupled at boundary conditions, or perhaps part of the domain would overlap but each code would have additional domain that the other does not need to model).",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3699425",
                          "updatedAt": "2022-09-21T12:02:27Z",
                          "publishedAt": "2022-09-21T12:02:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok then you need an app that sits on top of both.\nOr if you have this liberty (eg you dont have to keep SAM and mole unmodified), you can register all the objects from the other app to one of the two apps.\nIf they are overlapping there's a stronger case for full coupling for now",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3702006",
                          "updatedAt": "2022-09-21T16:07:39Z",
                          "publishedAt": "2022-09-21T16:07:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "If Mole is the \"top\" app, is it possible to register all of SAM's objects to Mole without modifying SAM?  In either case, where would I make the change?  To be honest, I thought that was already happening since I'm calling SamApp::registerApps() and SamApp::registerAll(f, af, s) from moleApp::registerAll().",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3702319",
                          "updatedAt": "2022-09-21T16:42:00Z",
                          "publishedAt": "2022-09-21T16:41:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yeah so I dont know if you can share this routine, maybe you can email it to me on my INL email\nbut basically it should be like (minus any mistake I made):\nvoid\nmoleApp::registerAll(Factory & f, ActionFactory & af, Syntax & s)\n{\n  Registry::registerObjectsTo(f, {\"moleApp\"});\n  Registry::registerActionsTo(af, {\"moleApp\"});\n\n  ModulesApp::registerAll(f, af, s);\n\n#ifdef SAM_ENABLED\n  SamApp::registerAll(f, af, s);\n  \n  // SamApp::associateSyntax(s, af);\n  // if you do that, you can run Sam input files directly, but might mess up regular input files\n  // if you dont, you have to pass --app SamApp on the command line\n#endif\n}",
                          "url": "https://github.com/idaholab/moose/discussions/21980#discussioncomment-3702444",
                          "updatedAt": "2022-09-21T17:00:12Z",
                          "publishedAt": "2022-09-21T16:57:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}