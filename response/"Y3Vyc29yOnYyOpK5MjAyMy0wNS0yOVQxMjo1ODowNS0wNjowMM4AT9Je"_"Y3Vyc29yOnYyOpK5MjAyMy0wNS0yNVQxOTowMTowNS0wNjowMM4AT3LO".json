{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNS0yNVQxOTowMTowNS0wNjowMM4AT3LO"
    },
    "edges": [
      {
        "node": {
          "title": "Fragmenting a phase field problem leading to divergence",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "I have a perfectly working phase field input script that can run for 100 sec. However, when I fragment this script to run for 20 sec then resume it again to run for 20 sec. I am getting convergence issue.\nSo, my input1.i runs for ----.20 sec\nBut, my input2.i is having convergence issue at (20+1.1) sec\nBoth the files are identical just with change in input2.i as:\n# input2 file.\n[Mesh]\n  file = input1_out.e\n[]\n[Variables]\n  [w]\n    family = LAGRANGE\n    order = FIRST\n    initial_from_file_var = w\n    initial_from_file_timestep = LATEST\n  []\n  [eta]\n    family = LAGRANGE\n    order = FIRST\n    initial_from_file_var = eta\n    initial_from_file_timestep = LATEST\n  []\n  [phi]\n    family = LAGRANGE\n    order = FIRST\n    initial_from_file_var = phi\n    initial_from_file_timestep = LATEST\n  []\n  [pot]\n    family = LAGRANGE\n    order = FIRST\n    initial_from_file_var = pot\n    initial_from_file_timestep = LATEST\n  []\n[]\n\nWhat can be the source of divergence. My solver is PJFNK preconditioned with\n [Preconditioning]\n   [./SMP]\n     type = SMP\n     full = true\n     petsc_options_iname = '-pc_type -ksp_grmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\n     petsc_options_value = 'asm      121                  preonly       lu           8'\n   [../]\n []\n\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/24520",
          "updatedAt": "2023-09-12T17:50:49Z",
          "publishedAt": "2023-05-29T11:58:13Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nCan you add Problem/solve=false and look at the re-initialization to see if everything looks correct.\nDo you need to initialize aux-variables too?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24520#discussioncomment-6029005",
                  "updatedAt": "2023-05-29T12:29:27Z",
                  "publishedAt": "2023-05-29T12:29:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "I haven't initialized aux variables from last run. Is it required?\nThe following total 22 aux variables:\n  FN\n  FNF\n  G\n  P\n  c\n  dFN/deta\n  dFNF/deta\n  dFNF/dphi\n  dG/deta\n  dG/dpot\n  dG/dw\n  d^2FN/deta^2\n  d^2FNF/deta^2\n  d^2FNF/detadphi\n  d^2FNF/dphi^2\n  d^3FN/deta^3\n  d^3FNF/deta^2dphi\n  d^3FNF/deta^3\n  d^3FNF/detadphi^2\n  d^3FNF/dphi^3\n  etaminus\n  times_mat\nare added for automatic output by MaterialOutputAction.\n\n  Initializing\n    Finished Initializing Equation Systems                                               [  0.35 s] [  152 MB]\n  Finished Initializing                                                                  [  0.37 s] [  153 MB]\nFinished Setting Up                                                                      [  2.73 s] [  208 MB]\nFramework Information:\nMOOSE Version:           git commit c1b08368cd on 2023-01-12\nLibMesh Version:\nPETSc Version:           3.16.6\nSLEPc Version:           3.16.2\nCurrent Time:            Mon May 29 18:28:05 2023\nExecutable Timestamp:    Mon Apr 10 21:21:42 2023\n\nParallelism:\n  Num Processors:          1\n  Num Threads:             1\n\nMesh:\n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   40401\n  Elems:                   40000\n  Num Subdomains:          1\n\nNonlinear System:\n  Num DOFs:                161604\n  Num Local DOFs:          161604\n  Variables:               { \"w\" \"eta\" \"phi\" \"pot\" }\n  Finite Element Types:    \"LAGRANGE\"\n  Approximation Orders:    \"FIRST\"\n\nAuxiliary System:\n  Num DOFs:                880000\n  Num Local DOFs:          880000\n  Variables:               { \"FN\" \"FNF\" \"G\" \"P\" \"c\" ... \"d^3FNF/deta^3\" \"d^3FNF/detadphi^2\" \"d^3FNF/dphi^3\"\n                             \"etaminus\" \"times_mat\" }\n  Finite Element Types:    \"MONOMIAL\"\n  Approximation Orders:    \"CONSTANT\"\n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  Solver Mode:             Preconditioned JFNK\n  PETSc Preconditioner:    asm\n  MOOSE Preconditioner:    SMP\n\n\n    Finished Initializing Random Objects                                                 [  0.29 s] [  203 MB]\n  Finished Performing Initial Setup                                                      [  1.63 s] [  220 MB]\n\nTime Step 0, time = 0\n\nTime Step 1, time = 0.02, dt = 0.02\n Solve Skipped!\n\nTime Step 2, time = 0.04, dt = 0.02\n Solve Skipped!\n\nTime Step 3, time = 0.06, dt = 0.02\n Solve Skipped!\n\nTime Step 4, time = 0.08, dt = 0.02\n Solve Skipped!\n\nTime Step 5, time = 0.1, dt = 0.02\n Solve Skipped!\n\nTime Step 6, time = 0.12, dt = 0.02\n Solve Skipped!\n\nTime Step 7, time = 0.14, dt = 0.02\n Solve Skipped!\n\nTime Step 13, time = 0.26, dt = 0.02\n Solve Skipped!\n\nTime Step 14, time = 0.28, dt = 0.02\n Solve Skipped!\n\nTime Step 15, time = 0.3, dt = 0.02\n Solve Skipped!\n\nTime Step 16, time = 0.32, dt = 0.02\n Solve Skipped!\n\nTime Step 17, time = 0.34, dt = 0.02\n Solve Skipped!\n\nTime Step 18, time = 0.36, dt = 0.02\n Solve Skipped!\n\nTime Step 19, time = 0.38, dt = 0.02\n Solve Skipped!\n\nTime Step 20, time = 0.4, dt = 0.02\n Solve Skipped!\n\nTime Step 21, time = 0.42, dt = 0.02\n Solve Skipped!\n\nTime Step 22, time = 0.44, dt = 0.02\n Solve Skipped!\n\nTime Step 23, time = 0.46, dt = 0.02\n Solve Skipped!\n\nTime Step 24, time = 0.48, dt = 0.02\n Solve Skipped!\n\nTime Step 25, time = 0.5, dt = 0.02\n Solve Skipped!\n\nTime Step 26, time = 0.52, dt = 0.02\n Solve Skipped!\n\nTime Step 27, time = 0.54, dt = 0.02\n Solve Skipped!\n\nTime Step 28, time = 0.56, dt = 0.02\n Solve Skipped!\n\nTime Step 29, time = 0.58, dt = 0.02\n Solve Skipped!\n\nTime Step 30, time = 0.6, dt = 0.02\n Solve Skipped!\n\nTime Step 31, time = 0.62, dt = 0.02\n Solve Skipped!\n\nTime Step 32, time = 0.64, dt = 0.02\n Solve Skipped!\n\nTime Step 33, time = 0.66, dt = 0.02\n Solve Skipped!\n\nTime Step 34, time = 0.68, dt = 0.02\n Solve Skipped!\n\nTime Step 35, time = 0.7, dt = 0.02\n Solve Skipped!\n\nTime Step 36, time = 0.72, dt = 0.02\n Solve Skipped!\n\nTime Step 37, time = 0.74, dt = 0.02\n Solve Skipped!\n\nTime Step 38, time = 0.76, dt = 0.02\n Solve Skipped!\n\nTime Step 39, time = 0.78, dt = 0.02\n Solve Skipped!\n\nTime Step 40, time = 0.8, dt = 0.02\n Solve Skipped!\n\nTime Step 41, time = 0.82, dt = 0.02\n Solve Skipped!\n\nTime Step 42, time = 0.84, dt = 0.02\n Solve Skipped!\n\nTime Step 43, time = 0.86, dt = 0.02\n Solve Skipped!\n\nTime Step 44, time = 0.88, dt = 0.02\n Solve Skipped!\n\nTime Step 45, time = 0.9, dt = 0.02\n Solve Skipped!\n\nTime Step 46, time = 0.92, dt = 0.02\n Solve Skipped!\n\nTime Step 47, time = 0.94, dt = 0.02\n Solve Skipped!\n\nTime Step 48, time = 0.96, dt = 0.02\n Solve Skipped!\n\nTime Step 49, time = 0.98, dt = 0.02\n Solve Skipped!\n\nTime Step 50, time = 1, dt = 0.02\n Solve Skipped!\n\nTime Step 51, time = 1.02, dt = 0.02\n Solve Skipped!\n\nTime Step 52, time = 1.04, dt = 0.02\n Solve Skipped!\n\nTime Step 53, time = 1.06, dt = 0.02\n Solve Skipped!\n\nTime Step 54, time = 1.08, dt = 0.02\n Solve Skipped!\n\nTime Step 55, time = 1.1, dt = 0.02\n Solve Skipped!\n\nTime Step 56, time = 1.12, dt = 0.02\n Solve Skipped!\n\nTime Step 57, time = 1.14, dt = 0.02\n Solve Skipped!\n\nTime Step 58, time = 1.16, dt = 0.02\n Solve Skipped!\n\nTime Step 59, time = 1.18, dt = 0.02\n Solve Skipped!\n\nTime Step 60, time = 1.2, dt = 0.02\n Solve Skipped!\n\nTime Step 61, time = 1.22, dt = 0.02\n Solve Skipped!\n\nTime Step 62, time = 1.24, dt = 0.02\n Solve Skipped!\n\nTime Step 63, time = 1.26, dt = 0.02\n Solve Skipped!\n\nTime Step 64, time = 1.28, dt = 0.02\n Solve Skipped!\n\nTime Step 65, time = 1.3, dt = 0.02\n Solve Skipped!\n\nTime Step 66, time = 1.32, dt = 0.02\n Solve Skipped!\n\nTime Step 67, time = 1.34, dt = 0.02\n Solve Skipped!\n\nTime Step 68, time = 1.36, dt = 0.02\n Solve Skipped!\n\nTime Step 69, time = 1.38, dt = 0.02\n Solve Skipped!\n\nTime Step 70, time = 1.4, dt = 0.02\n Solve Skipped!\n\nTime Step 71, time = 1.42, dt = 0.02\n Solve Skipped!\n\nTime Step 72, time = 1.44, dt = 0.02\n Solve Skipped!\n\nTime Step 73, time = 1.46, dt = 0.02\n Solve Skipped!\n\nTime Step 74, time = 1.48, dt = 0.02\n Solve Skipped!\n\nTime Step 75, time = 1.5, dt = 0.02\n Solve Skipped!\n\nTime Step 76, time = 1.52, dt = 0.02\n Solve Skipped!\n\nTime Step 77, time = 1.54, dt = 0.02\n Solve Skipped!\n\nTime Step 78, time = 1.56, dt = 0.02\n Solve Skipped!\n\nTime Step 79, time = 1.58, dt = 0.02\n Solve Skipped!\n\nTime Step 80, time = 1.6, dt = 0.02\n Solve Skipped!",
                          "url": "https://github.com/idaholab/moose/discussions/24520#discussioncomment-6029236",
                          "updatedAt": "2023-05-29T13:02:29Z",
                          "publishedAt": "2023-05-29T13:02:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For the solve=false case I wanted you to check the exodus output to see if the initialization succeeded.\nYou only need to initialize auxvariables if they are used in the calculation, and if the auxkernels that are meant to compute them are not executed early enough",
                          "url": "https://github.com/idaholab/moose/discussions/24520#discussioncomment-6030118",
                          "updatedAt": "2023-05-29T15:00:50Z",
                          "publishedAt": "2023-05-29T15:00:49Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about noise term",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nWhat is the maximum amplitude I can set in LangevinNoise kernel?\nThank you,\nBest",
          "url": "https://github.com/idaholab/moose/discussions/24517",
          "updatedAt": "2023-05-28T15:54:24Z",
          "publishedAt": "2023-05-28T15:54:23Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Why can't my simulation converge",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nMy simulation cannot converge. What is the problem with my code?\nCurrently, I have a square model, and the initial condition of this square model is c=0.0001, the free energy function is shown as below:\n\nSo, phase 0 will decompose to -1 phase and 1 phase. However, after I run the simulation, it always cannot converge.\nThis is the error message:\nerror_message.txt\nThis is my file:\nfile.txt\nHow should I change my code?\nThank you,\nBest",
          "url": "https://github.com/idaholab/moose/discussions/24512",
          "updatedAt": "2023-05-27T13:21:44Z",
          "publishedAt": "2023-05-27T02:04:46Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nTime Step 2, time = 0.00749663, dt = 0.00300763\n 0 Nonlinear |R| = \ufffd[32m8.079562e-16\ufffd[39m\n    |residual|_2 of individual variables:\n                          c: 4.60316e-16\n                          w: 6.64005e-16\n\nthis makes me think you are trying to over-converge things.\nPlease turn on automatic_scaling in the Executioner block.\nIf that does not do it, you ll have to fix the convergence criteria (nl_abs_tol)",
                  "url": "https://github.com/idaholab/moose/discussions/24512#discussioncomment-6018849",
                  "updatedAt": "2023-05-27T13:21:45Z",
                  "publishedAt": "2023-05-27T13:21:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using an existing neural network model.",
          "author": {
            "login": "tttsss-01"
          },
          "bodyText": "I would like to use a neural network model trained on RVE results to replace stress calculations. Are there any existing codes that can assist in implementing this? Or do you have any suggestions in this regard?",
          "url": "https://github.com/idaholab/moose/discussions/24504",
          "updatedAt": "2023-05-27T08:17:44Z",
          "publishedAt": "2023-05-26T16:48:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@grmnptr added an interface to libtorch to MOOSE",
                  "url": "https://github.com/idaholab/moose/discussions/24504#discussioncomment-6013972",
                  "updatedAt": "2023-05-26T16:56:59Z",
                  "publishedAt": "2023-05-26T16:56:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If you have a pytorch model, compile it into a torch script and call it from within moose.\nIf you have a libtorch model then that's trivial...\nHere's an example to call torch script.\n#pragma once\n\n#include <torch/script.h>\n#include \"ComputeLagrangianStressPK1.h\"\n\nclass TorchStress : public ComputeLagrangianStressPK1\n{\npublic:\n  static InputParameters validParams();\n  TorchStress(const InputParameters & parameters);\n\nprotected:\n  virtual void computeQpPK1Stress() override;\n  torch::jit::script::Module module;\n};\n#include \"TorchStress.h\"\n\nregisterMooseObject(\"fooApp\", TorchStress);\n\nInputParameters\nTorchStress::validParams()\n{\n  InputParameters params = ComputeLagrangianStressPK1::validParams();\n  params.addRequiredParam<std::string>(\"script\", \"file name of the torch script\");\n  return params;\n}\n\nTorchStress::TorchStress(const InputParameters & parameters)\n  : ComputeLagrangianStressPK1(parameters)\n{\n  std::string file_name = getParam<std::string>(\"script\");\n  module = torch::jit::load(file_name);\n}\n\nvoid\nTorchStress::computeQpPK1Stress()\n{\n  double F_vals[9] = {_F[_qp](0, 0),\n                      _F[_qp](0, 1),\n                      _F[_qp](0, 2),\n                      _F[_qp](1, 0),\n                      _F[_qp](1, 1),\n                      _F[_qp](1, 2),\n                      _F[_qp](2, 0),\n                      _F[_qp](2, 1),\n                      _F[_qp](2, 2)};\n  torch::Tensor F = torch::from_blob(F_vals, {3, 3}, {torch::kFloat64});\n  torch::Tensor P_vals = module({F}).toTensor();\n  _pk1_stress[_qp] = RankTwoTensor(P_vals.index({0, 0}).item<double>(),\n                                   P_vals.index({1, 0}).item<double>(),\n                                   P_vals.index({2, 0}).item<double>(),\n                                   P_vals.index({0, 1}).item<double>(),\n                                   P_vals.index({1, 1}).item<double>(),\n                                   P_vals.index({2, 1}).item<double>(),\n                                   P_vals.index({0, 2}).item<double>(),\n                                   P_vals.index({1, 2}).item<double>(),\n                                   P_vals.index({2, 2}).item<double>());\n}",
                  "url": "https://github.com/idaholab/moose/discussions/24504#discussioncomment-6016309",
                  "updatedAt": "2023-05-26T23:42:36Z",
                  "publishedAt": "2023-05-26T23:42:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tttsss-01"
                          },
                          "bodyText": "Thank you very much, this is very helpful to me.",
                          "url": "https://github.com/idaholab/moose/discussions/24504#discussioncomment-6017695",
                          "updatedAt": "2023-05-27T08:17:45Z",
                          "publishedAt": "2023-05-27T08:17:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Q: the Global Strain method in simple Applied strain problem instead of applied stress.",
          "author": {
            "login": "Ttw0626"
          },
          "bodyText": "Dear Moose developers,\n1) Reason:\nI totally understand the applied stress simple PBC test [x y z all of periodic property] using Global Strain.\nThere are many tests and instructive examples in \" /moose/test/tests/ \" and \" /TM/test/tests/ \" and \"/combine/example\", Thanks for that.\n2) Q1:\nHowever, I wanna ask how to apply the strain-control on global excepting the calculated eigenstrain in coupled field example ?? For example, I wanna apply the volumetric e00 = 0.001 along X direction and all of directions maintain periodic.\n3) Q2:\nOr I should use Mortar periodic constraint and Lagrangian new system to do that ?\nkind regards,\nTAN",
          "url": "https://github.com/idaholab/moose/discussions/24495",
          "updatedAt": "2023-05-27T05:33:32Z",
          "publishedAt": "2023-05-26T05:58:32Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can use the new homogenization system that comes with the new Lagrangian kernels (new_system = true in the TM action). Examples are inside modules/tensor_mechanics/test/tests/lagrangian/cartesian/total/homogenization. It's a more flexible system than the original global strain system.\nThe key object is the homogenization userobject:\n[UserObjects]\n  [homogenization]\n    type = HomogenizationConstraint\n    constraint_types = 'STRAIN NONE NONE STRESS STRESS NONE STRAIN STRESS STRESS'\n    targets = '0.1 s s e s s'\n    execute_on = 'INITIAL LINEAR NONLINEAR'\n  []\n[]\nThe parameter constrain_types specifies which type of constraint you want to apply for each component. They are ordered column major IIRC. You need to specify 9 components for large deformation and 6 components for small deformation. STRAIN means you want to constrain the homogenized strain, STRESS means you want to constrain the homogenized stress, and NONE means no constraint should be applied for that component.\nAny non-NONE constraint type should correspond to a target value specified by the targets parameter. Each target is a Function. You can also specify a numeric literal. In the above example, 0.1 means you want to constrain the homogenized strain_xx to be 0.1.\nMaking the homogenization system documentation more complete is on my to-do list.",
                  "url": "https://github.com/idaholab/moose/discussions/24495#discussioncomment-6011532",
                  "updatedAt": "2023-05-26T12:56:15Z",
                  "publishedAt": "2023-05-26T12:56:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ttw0626"
                          },
                          "bodyText": "Thanks, gray.\nI got it, I will try.\nTAN",
                          "url": "https://github.com/idaholab/moose/discussions/24495#discussioncomment-6017160",
                          "updatedAt": "2023-05-27T05:33:32Z",
                          "publishedAt": "2023-05-27T05:33:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to access/compute second order derivates",
          "author": {
            "login": "ABallisat"
          },
          "bodyText": "Hello all,\nI am trying to implement a surface tension term within the level set module which requires computing the curvature of the interface. Explicitly, I need to calculate (ignoring constants):\nF = (grad dot grad phi)/|grad phi| * grad phi\nfor the level set variable phi. I believe I cannot get around the grad dot grad phi term when putting it in the weak form, and I cannot work out how to access it or compute it in the kernel. Is there an easy way in MOOSE to access the second order derivates?\nThanks in advance for the help,\nAlex",
          "url": "https://github.com/idaholab/moose/discussions/17183",
          "updatedAt": "2023-05-26T22:26:25Z",
          "publishedAt": "2021-03-02T12:43:32Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If I were you I would first try really hard to see if I can \"shift\" the derivative onto the test function in the weak form. But in case you really can't:\nSee https://github.com/idaholab/moose/blob/next/modules/phase_field/include/kernels/CHInterfaceBase.h for example how to get second spatial derivatives of variable, test and trial functions.\nBut you need higher continuity, e.g. a third order hermite polynomial as your basis.\nAlternatively, you can try splitting up your weak form by introducing a new variable (just like the split form cahn hilliard equation).",
                  "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-427906",
                  "updatedAt": "2022-08-04T08:44:32Z",
                  "publishedAt": "2021-03-04T02:24:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "Thanks for the advice. I will focus for now on trying to shift the derivative onto the test function and if I can't get around it I will go into those suggestions.",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-430091",
                          "updatedAt": "2022-08-04T08:44:36Z",
                          "publishedAt": "2021-03-04T17:11:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Take a look at Elin Olsson et.al, JCP 225 (2007) 785\u2013807 paper where he has a formulation for regularized curvature. I suggest introduce a kernel to compute the curvature variable based on that formulation.\nI have implemented it in our internal MOOSE-based codes, and it works well.",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-431287",
                          "updatedAt": "2022-08-04T08:44:36Z",
                          "publishedAt": "2021-03-05T00:18:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "Thanks for that, I will take a good look and give that approach a go. Just out of interest is there any plan to incorporate that kernel into the general MOOSE distribution?",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-433886",
                          "updatedAt": "2022-08-04T08:44:36Z",
                          "publishedAt": "2021-03-05T17:02:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Yes, those codes will be eventually merged into MOOSE, maybe as a new physical module. However, the timeline is not very clear at this moment.",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-433900",
                          "updatedAt": "2022-08-11T07:53:39Z",
                          "publishedAt": "2021-03-05T17:08:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "I'm having trouble getting this to give sensible answers. For clarity, I am implementing equation 22 of that paper, using three kernels, one for each of the three integral terms and moving them all onto the same side so flipping some of the signs to get the correct residual calculations. Apply Neumann BCs to the curvature variable and level set variable (I am using the smeared heaviside function as per the first paper in that series). At the moment this is giving the following, where kappa is the curvature and k_Magnitude is the magnitude of the of gradient of the level set function (which is simply a stationary circle centred on 0.1 with radius 0.025). I know the gradient is correct but as the curvature should be the gradient of gradient, this does not seem to be correct. Am I missing something obvious or did you have to do anything in particular to get it working? I can't see what I am doing wrong...\nThanks for the help!",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-489939",
                          "updatedAt": "2022-08-11T07:53:39Z",
                          "publishedAt": "2021-03-16T17:32:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Curvature = div (normal) = div (grad_phi / ||grad_phi||)\nfor signed distance function ||grad_phi||=1\nso Curvature = div grad_phi = Lap phi.",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-494207",
                          "updatedAt": "2022-08-11T07:53:41Z",
                          "publishedAt": "2021-03-17T15:15:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "Ah that solved it, I think my understanding of the reinitialisation and the conversion to the smeared heaviside function was incorrect. Thanks again for all the help, it is greatly appreciated!",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-494656",
                          "updatedAt": "2022-08-11T07:53:41Z",
                          "publishedAt": "2021-03-17T17:00:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Curvature = div (normal) = div (grad_phi / ||grad_phi||)\nfor signed distance function ||grad_phi||=1\nso Curvature = div grad_phi = Lap phi.\n\nHello,\nHere as you suggested I used a custom kernel to compute the curvature. Bu this really messed up with the speed and convergence of my model. Is there any Auxkernel that can be used here and get the curvature as an Auxvariable? and curvature is simply the laplacian of phi?\nThanks,",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-5983553",
                          "updatedAt": "2023-05-24T00:16:51Z",
                          "publishedAt": "2023-05-24T00:16:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "curvature as an Auxvariable\nyou cannot use this (without extra work) for computing the residuals though. Auxvariables do NOT carry derivative information for the Jacobian\nBut if you really want to just look at it, in the output, then you ll have to make a new auxkernel, we dont have that one.\nI can make it too if you have a week or two to wait",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-5984329",
                          "updatedAt": "2023-05-24T02:42:13Z",
                          "publishedAt": "2023-05-24T02:42:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "You may get curvatures from FE computation directly in libMesh: get_curvatures. As alluded to by @jiangwen84 it does require pre-requesting get_d2phi",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-5984966",
                          "updatedAt": "2023-05-24T04:54:18Z",
                          "publishedAt": "2023-05-24T04:54:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about free energy function setting in one model",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nI have a question about setting location dependent free energy function in my model.\nI have a square model and I divided it to a 33 grid. I want to assign different free energy function on each small square in the 33 grid. How to realize this?\n\nThe free energy function's expression is shown as below, so for different free energy function, I need to change the 4 coefficients. How to realize this?\n\nThis is how I set free energy function in my file currently,\n\nThank you,\nBest",
          "url": "https://github.com/idaholab/moose/discussions/24492",
          "updatedAt": "2023-05-26T17:29:07Z",
          "publishedAt": "2023-05-26T03:12:34Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think you'll wan to use a ParsedSubdomainGenerator to create the 3x3 grid of subdomains.\nThen you can block restrict material properties. You ll create 9 DerivativeParsedMaterial, one for each subdomain\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6011716",
                  "updatedAt": "2023-05-26T13:14:42Z",
                  "publishedAt": "2023-05-26T13:14:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "Since I don't want to change the other things, for example initial condition and boundary condition, I should just keep them as the same, right? I only need to create more free energy function and apply them to each block I want?",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013130",
                          "updatedAt": "2023-05-26T15:22:21Z",
                          "publishedAt": "2023-05-26T15:22:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Creating more subdomains will not affect BCs or ICs.\nYou can block-restrict ICs though if you wanted.",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013198",
                          "updatedAt": "2023-05-26T15:28:52Z",
                          "publishedAt": "2023-05-26T15:28:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "What is block-restrict?",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013335",
                          "updatedAt": "2023-05-26T15:43:43Z",
                          "publishedAt": "2023-05-26T15:43:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "setting block= on an object restricts it to some subdomains/block\nhttps://mooseframework.inl.gov/source/interfaces/BlockRestrictable.html",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013375",
                          "updatedAt": "2023-05-26T15:47:14Z",
                          "publishedAt": "2023-05-26T15:47:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "I want to subdivide my domain, however, I always got this error message, why is this?\ndf0d8_t_0d4_free_energy_blcok.8388765.txt\nThe following is my file:\nfile.txt\nWhat is the problem with my subdomain setting?",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013958",
                          "updatedAt": "2023-05-26T16:55:12Z",
                          "publishedAt": "2023-05-26T16:55:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You need order mesh generators like a tree with a single final point\n  [./domainx]\n    type = GeneratedMeshGenerator\n    dim = 2\n    elem_type = QUAD4\n    nx = 240\n    ny = 48\n    nz = 0\n    xmin = 0\n    xmax = 4.0\n    ymin = 0\n    ymax = 0.8\n    #zmin = 0\n    #zmax = 0\n    uniform_refine = 2\n    #nemesis = true\n    #skip_partitioning = true\n  []\n\n  [./subdomains1]\n    type = ParsedSubdomainMeshGenerator\n    input = domainx\n    combinatorial_geometry = 'x < 1 & y > 0.4'\n    block_id = 1\n  []\n  [./subdomains2]\n    type = ParsedSubdomainMeshGenerator\n    input = subdomains1\n    combinatorial_geometry = 'x < 1 & y < 0.4'\n    block_id = 2\n  []\n  [./subdomains3]\n    type = ParsedSubdomainMeshGenerator\n    input = subdomains2\n    combinatorial_geometry = 'x > 1'\n    block_id = 3\n  []\n\nsee how there's only one exit point, subdomains3",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013986",
                          "updatedAt": "2023-05-26T16:58:37Z",
                          "publishedAt": "2023-05-26T16:58:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "What is only one exit point?\nI changed the subdomain3 and the following is the changed file.\nfile.txt\nAnd I run it, but I still get that error.\nerror_message.txt\nWhy is this?",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6014117",
                          "updatedAt": "2023-05-26T17:16:35Z",
                          "publishedAt": "2023-05-26T17:16:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you draw a graph of the mesh generators, looking at the inputs, there must be only one final one",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6014213",
                          "updatedAt": "2023-05-26T17:28:11Z",
                          "publishedAt": "2023-05-26T17:28:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can look at this page, at the gneeration / DAG part\nhttps://mooseframework.inl.gov/syntax/Mesh/",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6014226",
                          "updatedAt": "2023-05-26T17:29:07Z",
                          "publishedAt": "2023-05-26T17:29:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "derived class from ComputeElasticityTensorCP",
          "author": {
            "login": "selarem"
          },
          "bodyText": "Hello, I would like to input the square root of the elasticity tensor to avoid its computation for every increment at every material point.\nSo, i derived a class meComputeElasticityTensorCP from ComputeElasticityTensorCP and wrote.\n#include \"meComputeElasticityTensorCP.h\"\n\nregisterMooseObject(\"TensorMechanicsApp\", meComputeElasticityTensorCP);\n\nInputParameters\nmeComputeElasticityTensorCP::validParams()\n{\n  InputParameters params = ComputeElasticityTensorCP::validParams();\n  params.addClassDescription(\"Compute an elasticity tensor for crystal plasticity.\");\n  params.addRequiredParam<std::vector<Real>>(\"sqrtC_ijkl\", \"sqrt Stiffness tensor for material\");\n  return params;\n}\nmeComputeElasticityTensorCP::meComputeElasticityTensorCP(const InputParameters & parameters)\n  : ComputeElasticityTensorCP(parameters),\n         _sqrt_elasticity_tensor_name(_base_name + \"sqrt_elasticity_tensor\"),\n    _sqrt_elasticity_tensor(declareGenericProperty<T, is_ad>(_sqrt_elasticity_tensor_name)),\n        _sqrtCijkl(this->getParam<std::vector<Real>>(\"sqrtC_ijkl\"),\n           (RankFourTensor::FillMethod)(int)this->getParam<MooseEnum>(\"fill_method\"))\n{\n  // the base class guarantees constant in time, but in this derived class the\n  // tensor will rotate over time once plastic deformation sets in\n  // the base class performs a passive rotation, but the crystal plasticity\n  // materials use active rotation: recover unrotated _Cijkl here\n  _sqrtCijkl.rotate(_R.transpose());\n}\n\nvoid\nmeComputeElasticityTensorCP::computeQpElasticityTensor()\n{\n  // Properties assigned at the beginning of every call to material calculation\n  //  \n  // this->ComputeElasticityTensorCP::computeQpElasticityTensor();\nComputeElasticityTensorCP::computeQpElasticityTensor();\n  _sqrt_elasticity_tensor[_qp] = _sqrtCijkl;\n  _sqrt_elasticity_tensor[_qp].rotate(_crysrot[_qp]);\n}\n   \nbut when I compiled, I got:\n\nCompiling C++ (in opt mode) /opt/projects/sea/build/unity_src/materials_Unity.C...\nIn file included from /opt/projects/moose/framework/build/header_symlinks/MooseObject.h:15,\n                 from /opt/projects/moose/framework/build/header_symlinks/MaterialBase.h:13,\n                 from /opt/projects/moose/framework/build/header_symlinks/Material.h:13,\n                 from /opt/projects/moose/modules/tensor_mechanics/build/header_symlinks/ComputeStressBase.h:12,\n                 from /opt/projects/moose/modules/tensor_mechanics/build/header_symlinks/ComputePFFractureStressBase.h:12,\n                 from /opt/projects/moose/modules/tensor_mechanics/build/header_symlinks/ConcreteLinearElasticPFFractureStress.h:12,\n                 from /opt/projects/sea/src/materials/ConcreteLinearElasticPFFractureStress.C:10,\n                 from /opt/projects/sea/build/unity_src/materials_Unity.C:2:\n/opt/projects/moose/framework/build/header_symlinks/Registry.h:42:91: error: no matching function for call to 'Registry::add<meComputeElasticityTensorCP>(<brace-enclosed initializer list>)'\n   42 |           {app, #classname, \"\", \"\", nullptr, nullptr, nullptr, __FILE__, __LINE__, \"\", \"\"})\n      |                                                                                           ^\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:12:1: note: in expansion of macro 'registerMooseObject'\n   12 | registerMooseObject(\"TensorMechanicsApp\", meComputeElasticityTensorCP);\n      | ^~~~~~~~~~~~~~~~~~~\n/opt/projects/moose/framework/build/header_symlinks/Registry.h:162:15: note: candidate: 'template<class T> static char Registry::add(const RegistryEntry&)'\n  162 |   static char add(const RegistryEntry & info)\n      |               ^~~\n/opt/projects/moose/framework/build/header_symlinks/Registry.h:162:15: note:   template argument deduction/substitution failed:\nIn file included from /opt/projects/sea/build/unity_src/materials_Unity.C:3:\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:15:1: error: 'template<bool is_ad, class T> class meComputeElasticityTensorCP' used without template arguments\n   15 | meComputeElasticityTensorCP::validParams()\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:23:28: error: deduced class type 'meComputeElasticityTensorCP' in function return type\n   23 | meComputeElasticityTensorCP::meComputeElasticityTensorCP(const InputParameters & parameters)\n      |                            ^~\nIn file included from /opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:10,\n                 from /opt/projects/sea/build/unity_src/materials_Unity.C:3:\n/opt/projects/sea/build/header_symlinks/meComputeElasticityTensorCP.h:22:7: note: 'template<bool is_ad, class T> class meComputeElasticityTensorCP' declared here\n   22 | class meComputeElasticityTensorCP : public ComputeElasticityTensorCP\n      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /opt/projects/sea/build/unity_src/materials_Unity.C:3:\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:38:1: error: 'template<bool is_ad, class T> class meComputeElasticityTensorCP' used without template arguments\n   38 | meComputeElasticityTensorCP::computeQpElasticityTensor()\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C: In function 'void computeQpElasticityTensor()':\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:42:56: error: cannot call member function 'virtual void ComputeElasticityTensorCP::computeQpElasticityTensor()' without object\n   42 |   ComputeElasticityTensorCP::computeQpElasticityTensor();\n      |                                                        ^\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:43:3: error: '_sqrt_elasticity_tensor' was not declared in this scope\n   43 |   _sqrt_elasticity_tensor[_qp] = _sqrtCijkl;\n      |   ^~~~~~~~~~~~~~~~~~~~~~~\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:43:27: error: '_qp' was not declared in this scope\n   43 |   _sqrt_elasticity_tensor[_qp] = _sqrtCijkl;\n      |                           ^~~\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:43:34: error: '_sqrtCijkl' was not declared in this scope\n   43 |   _sqrt_elasticity_tensor[_qp] = _sqrtCijkl;\n      |                                  ^~~~~~~~~~\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:44:39: error: '_crysrot' was not declared in this scope\n   44 |   _sqrt_elasticity_tensor[_qp].rotate(_crysrot[_qp]);\n\nthanks for any help.\nregards,\nSab",
          "url": "https://github.com/idaholab/moose/discussions/24440",
          "updatedAt": "2023-05-30T07:58:13Z",
          "publishedAt": "2023-05-22T10:14:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you paste the header here as well?\nSomething is wrong with the class which makes the registering macro fail. I m not sure what yet though\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5967467",
                  "updatedAt": "2023-05-22T13:07:59Z",
                  "publishedAt": "2023-05-22T13:07:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "here is the header:\n#include \"ComputeElasticityTensor.h\"\n#include \"PropertyReadFile.h\"\n#include \"RankTwoTensor.h\"\n#include \"RotationTensor.h\"\n#include \"ComputeElasticityTensorCP.h\"\n\n/**\n * meComputeElasticityTensorCP defines an elasticity tensor material object for crystal plasticity.\n */\ntemplate <bool is_ad, typename T = RankFourTensor>\nclass meComputeElasticityTensorCP : public ComputeElasticityTensorCP\n{\npublic:\n  static InputParameters validParams();\n\n  meComputeElasticityTensorCP(const InputParameters & parameters);\n\nprotected:\n  virtual void computeQpElasticityTensor() override;\n RankFourTensor _sqrtCijkl;\n std::string _sqrt_elasticity_tensor_name;\n\n  GenericMaterialProperty<T, is_ad> & _sqrt_elasticity_tensor ;\n\n}\n\nregards,",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5986971",
                          "updatedAt": "2023-05-24T12:22:04Z",
                          "publishedAt": "2023-05-24T08:57:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nHere's your problem\nIn the header you are defining a template for a class (templated on is_ad and T, T having a default)\nand in the source you are not using the template argument.\nYou need to add the templating in the source, if you want an AD and non-AD version of the object\nOR\nremove the templating from the header\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5989281",
                          "updatedAt": "2023-05-24T12:23:42Z",
                          "publishedAt": "2023-05-24T12:23:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "Both of them do not work because I could not make the right modifications.\nIn case I want to remove the template, I would (in the header) declare the _sqrt_elasticity_tensor as a RankfourTensor as:\nRankFourTensor  & _sqrt_elasticity_tensor ;\nor something more complex ?\nand what about the constructor  line :\n_sqrt_elasticity_tensor(declareGenericProperty<T, is_ad>(_sqrt_elasticity_tensor_name)),\nI think I have to change it also, but do not know what to put instead.\nAny example or C++ doc  would be very helpful to me.\nregards,",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5990083",
                          "updatedAt": "2023-05-24T13:40:34Z",
                          "publishedAt": "2023-05-24T13:40:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Everywhere you have T you can write : RankFourTensor\nFor example, this is a valid type;\nGenericMaterialProperty<RankFourTensor, true> & _sqrt_elasticity_tensor ;",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5990165",
                          "updatedAt": "2023-05-24T13:48:06Z",
                          "publishedAt": "2023-05-24T13:48:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "i have put:\n MaterialProperty<RankFourTensor>  & _sqrt_elasticity_tensor ;\nand\n_sqrt_elasticity_tensor(declareProperty<RankFourTensor>(_sqrt_elasticity_tensor_name)),\n\nin the constructor.\nIt compiles. I will test it to see on a simple input file.\nregards,",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5990181",
                          "updatedAt": "2023-05-24T13:49:55Z",
                          "publishedAt": "2023-05-24T13:49:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "Hello,\nIt compiles without any problem.\nThe issue I do have now is that I have differences between:\n_elasticity_tensor and (_sqrt_elasticity_tensor * _sqrt_elasticity_tensor). Our input is :\n[./elasticity_tensor]\n    type = meComputeElasticityTensorCP\n    C_ijkl = '280000. 120000. 120000.      0.      0.      0. 280000. 120000.      0.\n      0.      0. 280000.      0.      0.      0.  80000.      0.      0.\n  80000.      0.  80000.'\n    fill_method = symmetric21\n    sqrtC_ijkl = '507.0367517  107.0367517  107.0367517    0.           0.\n   0.         507.0367517  107.0367517    0.           0.\n   0.         507.0367517    0.           0.           0.\n 282.84271247   0.           0.         282.84271247   0.\n 282.84271247 '    \n  [../]\n\nWith the tensors written in the form of 6X6 Matrices we have  : _elasticity_tensor = _sqrt_elasticity_tensor * _sqrt_elasticity_tensor\nBut not when using the operator * between two RankFourTensor in Moose.\nWe could not find the reason.\nThanks for any help.",
                  "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5999021",
                  "updatedAt": "2023-05-26T14:18:03Z",
                  "publishedAt": "2023-05-25T09:38:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "6x6 ?\nWhile there's a lot of identical coefficients I think they are 3x3x3x3 ?",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-6000454",
                          "updatedAt": "2023-05-25T12:29:33Z",
                          "publishedAt": "2023-05-25T12:29:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "regardless, I see this rotation step for tensors\n  _sqrtCijkl.rotate(_R.transpose());\nshould that be applied to the square root?",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-6000476",
                          "updatedAt": "2023-05-25T12:31:22Z",
                          "publishedAt": "2023-05-25T12:31:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "Of course, the square root should be rotated as the elasticity tensor.\nWe compute the sqrt outside Moose and give it as input (sqrtC_ijkl in the .i file).\nIn our calculus of  sqrtC_ijkl coefficients, we have represented the elasticity tensor as a 6X6 Matrix in Python.\nWhen these coefs entered in Moose, we wanted to check if\n(sqrt of C)^2 == C  (which is what we seek !)\nand found that the equality (between matrices) does not hold once in tensors representation of C and sqrtC.\nthat's our issue now.\nregards",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-6008914",
                          "updatedAt": "2023-05-26T07:56:07Z",
                          "publishedAt": "2023-05-26T07:56:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@jiangwen84 will know more about tensor math and if there's a trick here",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-6011725",
                          "updatedAt": "2023-05-26T13:16:05Z",
                          "publishedAt": "2023-05-26T13:16:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "Solved. To compute the sqrt of C, the algorithm used for 6X6 matrices has\nto be modified to work with rank four tensor representation.\n\nRegards,\nSaber\n\nLe ven. 26 mai 2023, 15:16, Guillaume Giudicelli ***@***.***>\na \u00e9crit :\n\u2026\n @jiangwen84 <https://github.com/jiangwen84> will know more about tensor\n math and if there's a trick here\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24440 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AFBUGDFFXNDC367BE3AST43XICUKBANCNFSM6AAAAAAYKG2U6Q>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-6013527",
                  "updatedAt": "2023-05-26T16:03:06Z",
                  "publishedAt": "2023-05-26T16:03:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Curved mesh generation with second order elements",
          "author": {
            "login": "lindsayad"
          },
          "bodyText": "Do we have any mesh generators that create curved meshes (either 2D or 3D) with second order elements?",
          "url": "https://github.com/idaholab/moose/discussions/24484",
          "updatedAt": "2023-05-26T15:13:09Z",
          "publishedAt": "2023-05-25T18:59:58Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "oanaoana"
                  },
                  "bodyText": "The TransfiniteMeshGenerator can do any curved edge, but I think is only Q1 for now. It can be changed to be Q2.",
                  "url": "https://github.com/idaholab/moose/discussions/24484#discussioncomment-6004495",
                  "updatedAt": "2023-05-25T19:06:32Z",
                  "publishedAt": "2023-05-25T19:06:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Not a mesh generator but Cubit can get us that kind of meshes iirc",
                  "url": "https://github.com/idaholab/moose/discussions/24484#discussioncomment-6004508",
                  "updatedAt": "2023-05-25T19:08:44Z",
                  "publishedAt": "2023-05-25T19:08:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "FileMeshGenerator, for curved inputs.  libMesh build_sphere() will do second-order interpolation on curved surfaces, and it looks like SphereMeshGenerator is calling that.  MoveNodeGenerator ought to get you curves if you're painstaking about it, or ParsedNodeTransformGenerator with more ease.",
                  "url": "https://github.com/idaholab/moose/discussions/24484#discussioncomment-6004510",
                  "updatedAt": "2023-05-25T19:09:05Z",
                  "publishedAt": "2023-05-25T19:09:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aprilnovak"
                  },
                  "bodyText": "We have some curved mesh generators in Cardinal, because Nek uses second order meshes. These are currently tailored to pin bundles by moving existing nodes onto a curved cylindrical surface. Despite the name, this is agnostic of anything special in Nek, we just use it often to make Nek meshes: https://cardinal.cels.anl.gov/source/meshgenerators/NekMeshGenerator.html\nCould potentially move that into the reactor module if it'd be of interest.",
                  "url": "https://github.com/idaholab/moose/discussions/24484#discussioncomment-6006608",
                  "updatedAt": "2023-05-26T00:40:27Z",
                  "publishedAt": "2023-05-26T00:40:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I think there definitely would be interest in getting more second order mesh capability as far upstream as possible. There's questions on Discussions about surface tension, surface curvature, etc. But I would't make this a personal priority of yours. You've got a ton of stuff on your plate haha",
                          "url": "https://github.com/idaholab/moose/discussions/24484#discussioncomment-6013009",
                          "updatedAt": "2023-05-26T15:13:10Z",
                          "publishedAt": "2023-05-26T15:13:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mass loss in simulating multiphase flow",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello,\nI am using coupled Cahn Hilliard Navier Stokes equation to simulate the droplet impact problem. The result that I am getting right now seems to be physically correct.\n\n\nUnfortunately I am witnessing a continuous mass loss. Is it because of the advection term that is added to the Cahn Hilliard equation? If this is the case, what are my options to correct this? (I think this is very similar to the rotating circle problem in level set module)\n\nThanks,",
          "url": "https://github.com/idaholab/moose/discussions/24414",
          "updatedAt": "2023-05-26T01:01:05Z",
          "publishedAt": "2023-05-17T19:39:03Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you remove the CH equations, or just the advection term in the CH equation, do you still observe this mass loss?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5931585",
                  "updatedAt": "2023-05-17T20:06:51Z",
                  "publishedAt": "2023-05-17T20:06:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "I removed the advection term in the CH equation. The area is still decreasing, but the rate of the decrease is much smaller.",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5932002",
                          "updatedAt": "2023-05-17T21:05:41Z",
                          "publishedAt": "2023-05-17T21:05:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Can you elaborate how you compute the total mass?",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5932420",
                          "updatedAt": "2023-05-17T22:23:28Z",
                          "publishedAt": "2023-05-17T22:23:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "[./area]\n    type = LevelSetVolume\n    threshold = 0.5\n    variable = c\n    location = outside\n    execute_on = 'initial timestep_end'\n  [../]\n\nSince this is a 2d axisymmetric model, it is actually the volume.\nThanks,\nAli",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5932496",
                          "updatedAt": "2023-05-17T22:37:48Z",
                          "publishedAt": "2023-05-17T22:37:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Does ElementIntegralVariable report the same behavior?",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5932552",
                          "updatedAt": "2023-05-17T22:46:34Z",
                          "publishedAt": "2023-05-17T22:46:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Yes, I have both of them in the postprocessor.  ElementIntegralVariablePostprocessor also reports some continuous decrease.\n\n[Postprocessors]\n\n\n  # for testing we also monitor the total solute amount, which should be conserved.\n  [./total_solute]\n    type = ElementIntegralVariablePostprocessor\n    variable = c\n  [../]\n\n  [./area]\n    type = LevelSetVolume\n    threshold = 0.5\n    variable = c\n    location = outside\n    execute_on = 'initial timestep_end'\n  [../]\n\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5932574",
                          "updatedAt": "2023-05-17T22:50:18Z",
                          "publishedAt": "2023-05-17T22:50:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@dschwen have you done CH with advection? @alimostafavi24 can you share your phase-field/navier-stokes input file?",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5970030",
                          "updatedAt": "2023-05-22T17:14:03Z",
                          "publishedAt": "2023-05-22T17:14:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Sure.\nThanks,\n[Problem]\n  type = FEProblem\n  coord_type = RZ\n  rz_coord_axis = Y\n[]\n\n\n\n rho_water = 1.000 #g/cm^3\n#rho_water = 0.1 #g/cm^3\n rho_air = 0.0012 #g/cm3\n\n mu_water = 0.0101 #g/(cm s)\n mu_air = 0.000182 #g/(cm s)\n\n U = 0.0#m/s\n R = 125e-4 #m DROPLET DIMATER\n R2 = $fparse{2*R}\n b = $fparse{R^2}\n a = $fparse{(R)^2}\n\n w = 0.25  #well height\n gamma = 72 #g/s^2\n elem=200\n epsilon= ${fparse 0.096/100}\n epsilon2= ${fparse epsilon^2}\n\n\n K = ${fparse (-3*gamma)/(4*((2*w)^0.5)*epsilon)}\n\n M = 1e-3  #cm^2/s\n\n[GlobalParams]\n\n  enable_jit=false\n\n\n # Stabilization parameters\n # Weak form customization\n\n[]\n\n\n\n[Mesh]\n[gen]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 25\n  ny = 30\n  nz = 0\n  xmin = 0.0\n  ymin = 0\n  zmin = 0\n  xmax = 0.5\n  ymax = 0.6\n  zmax = 0\n  elem_type = QUAD4\n[]\n[]\n\n[AuxVariables]\n\n  [./x_coor]\n  [../]\n  [./y_coor]\n  [../]\n\n\n\n\n[]\n\n[Variables]\n# Velocity in radial (r) direction\n  [./vel_x]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n\t      type = FunctionIC\n        function = vel_x_IC\n    [../]\n  [../]\n\n# Velocity in axial (z) direction\n  [./vel_y]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n\t      type = FunctionIC\n        function = vel_y_IC\n    [../]\n [../]\n\n# pressure for the NS module\n  [./p]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n#########\n# phase-field module variables: concentration (c) and chemical potential (w)\n#########\n  [./c]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n\t      type = FunctionIC\n        function = phi_exact\n    [../]\n  [../]\n\n  [./w]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n# setting up 2D axisymmetric calculations\n\n\n[Functions]\n# concentration initial conditions\n  [./phi_exact]\n    type = LevelSetOlssonBubble\n    epsilon = ${epsilon}\n    center = '0 0.15 0'\n    radius = 0.096\n  [../]\n\n\n #velocity in X direction initial condition, in this problem it is zero\n  [./vel_x_IC]\n    type = ParsedFunction\n    expression = 'r:=(((x-0.0)/1)^2+((y-0.15)/1)^2);if(r<=0.009216,0.0,-0.0)'\n  [../]\n \n\n\n\n #velocity in Y direction initial conditions, vertical velocity is applied\n  [./vel_y_IC]\n    type = ParsedFunction\n    expression = 'r:=(((x-0.0)/1)^2+((y-0.15)/1)^2);if(r<=0.009216,-62,0.0)'\n  [../]\n\n[]\n\n\n\n\n  [AuxKernels]\n\n    [./x_coor]\n    type = FunctionAux\n    variable = x_coor\n    function = x\n  [../]\n        [./y_coor]\n      type = FunctionAux\n      variable = y_coor\n      function = y\n    [../]\n[]\n\n[Kernels]\n\n#########\n# 2D axisymmetric Navier-Stokes kernels: mass, momentum time and space\n#########\n  # mass\n  [./mass]\n    type = INSMassRZ\n    variable = p\n    u = vel_x\n    v = vel_y\n    pressure = p\n  pspg = true\n  transient_term = true\n\n  [../]\n\n  # x-momentum, time\n  [./x_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = vel_x\n  [../]\n\n  # x-momentum, space\n  [./x_momentum_space]\n    type = INSMomentumLaplaceFormRZ\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    pressure = p\n    component = 0\n      pspg = true\n      supg = true\n  convective_term = true\n  integrate_p_by_parts = true\n  transient_term = true\n  laplace = true\n    gravity = '0 -981 0'\n  [../]\n\n  # y-momentum, time\n  [./y_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = vel_y\n  [../]\n\n  # y-momentum, space\n  [./y_momentum_space]\n    type = INSMomentumLaplaceFormRZ\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    pressure = p\n    component = 1\n      supg = true\n        pspg = true\n\n  convective_term = true\n  integrate_p_by_parts = true\n  transient_term = true\n  laplace = true\n    gravity = '0 -981 0'\n  [../]\n\n  #coupled force, we need it to pass surface tension from the PFM to the NS module. It is needed for both x and y vel\n  [./force_x]\n   type = SurfaceTension3\n    variable = vel_x\n    coef = ${K}\n    component = 0    \n    c = c\n    w = w\n\n  [../]\n\n  [./force_y]\n    type = SurfaceTension3\n    variable = vel_y\n    coef = ${K}\n    component = 1\n    c = c\n    w = w\n\n  [../]\n\n\n  #########\n  # the PFM kernels\n  #########\n  [./c_res]\n    type = SplitCHParsed\n    variable = c\n    f_name = F\n    kappa_name = kappa_c\n    w = w\n  [../]\n\n  [./w_res]\n    type =  SplitCHWRes #SplitCHWRes\n    variable = w\n    mob_name = M\n  [../]\n  [./time]\n    type = CoupledTimeDerivative\n    variable = w\n    v = c\n  [../]\n\n# the term to add advection velocity to the Cahn-Hilliard eq. u*nabla(C):\n# dC/dt+u*nabla(C)=(1/Pe)*(M nabla(w)), Pe is the Peclet number Pe = L*u/(M*w), L is the characteristic lenght\n  [./MyConvection]\n    type = AdvectionKernel2\n\tu = vel_x\n\tv = vel_y\n  c = c\n  variable = w\n [../]\n\n\n[]\n\n\n[Materials]\n\n#########\n# setting up density and viscosity for the NS module\n#########\n\n  [./rho]\n     type = DerivativeParsedMaterial\n      args = 'c'\n      f_name = 'rho'\n\n\n     #function = '(1+c)^2/4*${rho_water}+(1-c)^2/4*${rho_air}'\n       function = 'c^2*${rho_water}+(1-c)^2*${rho_air}'\n\n      derivative_order = 0\n      outputs = exodus\n      output_properties = 'rho'\n    [../]\n\n    [./mu]\n       type = DerivativeParsedMaterial\n        args = 'c'\n        f_name = 'mu'\n  \n      #function = '(1+c)^2/4*${mu_water}+(1-c)^2/4*${mu_air}'\n             function = 'c^2*${mu_water}+(1-c)^2*${mu_air}'\n\n        #function = '1*((c)^2)^0.5+1*(1-((c)^2)^0.5)*lambda_mu'\n        derivative_order = 0\n        outputs = exodus\n        output_properties = 'mu'\n      [../]\n\n# anisotropic mobility, active only at the interface meaning no bulk mobility\n\n\n# gradient energy coefficient\n\n\n  [./free_energy]\n    type = DerivativeParsedMaterial\n    property_name = F\n\n    coupled_variables = 'c'\n    expression = '${w} * (c)^2 * (1-c)^2'\n\n    outputs = exodus\n   output_properties = F\n  [../]\n\n  [pfmobility]\n    type = GenericConstantMaterial\n    prop_names = 'M    kappa_c '\n    prop_values = '${M}  ${epsilon2}'\n  []\n \n\n\n\n[]\n\n[BCs]\n\n[./u_no_slip]\n  type = DirichletBC\n  boundary = 'bottom top'\n  variable = vel_x\n  value = 0\n[../]\n\n[./v_no_slip]\n  type = DirichletBC\n  boundary = 'bottom top'\n  variable = vel_y\n  value = 0\n[../]\n\n\n#########\n# BC for the PFM\n#########\n\n\n# no flux of c, in this case contact angle is 90 degree, n*M*nabla(C)=0\n  [./c_bottom_CHF_BC]\n    type = WettingBC2D\n    variable = c\n    boundary = bottom\n    cos = -0.22495105434\n  [../]\n\n\n# no flux of chemical potential\n  [./w_bottom_CHF_BC]\n    type = NeumannBC\n    variable = w\n    boundary = 'top bottom left right'\n    value = 0\n  [../]\n   \n\n[]\n\n\n[Preconditioning]\n  active = preferred_but_might_not_be_installed                \n  [basic]\n    type = SMP\n    full = true\n    petsc_options = '-ksp_diagonal_scale -ksp_diagonal_scale_fix'\n    petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap'\n    petsc_options_value = ' asm      lu           NONZERO                   2'\n  []\n  [preferred_but_might_not_be_installed]\n    type = SMP\n    full = true\n #   petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  #  petsc_options_value = ' lu       mumps'\n\n    #petsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -sub_pc_factor_levels -sub_pc_factor_shift_type'\n    #petsc_options_value = 'asm      2               ilu          4                     NONZERO'\n\n    #petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap'\n    #petsc_options_value = ' asm      lu           NONZERO                   2'\n    petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -ksp_type -sub_pc_factor_shift_type'\n    petsc_options_value = 'lu superlu_dist gmres NONZERO   '\n\n#reuse_preconditioner = true\n#reuse_preconditioner_max_linear_its = 20\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = Newton\n# dt = 1e2  \n  end_time = 0.5\n    [./TimeStepper]\n    type = ConstantDT\n    dt = 1e-6\n  [../]\n  nl_abs_tol = 1e-8\n  automatic_scaling = true\n\n#[./TimeIntegrator]\n    # type = ImplicitEuler\n    # type = BDF2\n    #type = CrankNicolson\n    # type = ImplicitMidpoint\n    # type = LStableDirk2\n    # type = LStableDirk3\n    # type = LStableDirk4\n    # type = AStableDirk4\n    #\n    # Explicit methods\n    # type = ExplicitEuler\n    # type = ExplicitMidpoint\n    # type = Heun\n    # type = Ralston\n # [../]\n\n[]\n\n\n[Outputs]\n  exodus = true\n  #  interval = 100\n  csv = true\n\n  [out]\n    type = Checkpoint\n    interval = 500\n    num_files = 2\n  []\n\n[]\n\n\n\n[Adaptivity]\n  initial_steps = 5\n  steps = 1\n  marker = error\n  [Indicators]\n    [jump]\n      type = GradientJumpIndicator\n      variable = c\n    []\n  []\n  [Markers]\n    [error]\n      type = ErrorFractionMarker\n      coarsen = 0.95\n      refine = 0.9\n      indicator = jump\n    []\n  []\n  max_h_level = 5\n[]\n\n\n\n[Postprocessors]\n\n\n  # for testing we also monitor the total solute amount, which should be conserved.\n  [./total_solute]\n    type = ElementIntegralVariablePostprocessor\n    variable = c\n  [../]\n\n  [./area]\n    type = LevelSetVolume\n    threshold = 0.5\n    variable = c\n    location = outside\n    execute_on = 'initial timestep_end'\n  [../]\n\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5983617",
                          "updatedAt": "2023-05-24T00:28:04Z",
                          "publishedAt": "2023-05-24T00:28:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ykvishal"
                  },
                  "bodyText": "Did you find reasons for your mass loss issue? I have another question, which may not be useful. Are you applying mesh adaptivity (and/or time stepper)? If yes, can you share mesh, adaptivity and time-stepper block?",
                  "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5953289",
                  "updatedAt": "2023-05-20T00:59:13Z",
                  "publishedAt": "2023-05-20T00:59:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "I think there are 2 reasons for that.\n\nThe advection term\nThe order parameter is not bounded which leads to mass loss.\n\nYes.\n    [./TimeStepper]\n    type = ConstantDT\n    dt = 1e-6\n  [../]\n\n[Adaptivity]\n  initial_steps = 5\n  steps = 1\n  marker = error\n  [Indicators]\n    [jump]\n      type = GradientJumpIndicator\n      variable = c\n    []\n  []\n  [Markers]\n    [error]\n      type = ErrorFractionMarker\n      coarsen = 0.95\n      refine = 0.9\n      indicator = jump\n    []\n  []\n  max_h_level = 5\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5953471",
                          "updatedAt": "2023-05-20T02:12:56Z",
                          "publishedAt": "2023-05-20T02:12:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ykvishal"
                          },
                          "bodyText": "You could run one identical simulation, but without mesh adaptivity and check mass loss again. Sometimes CH equation does not work well with mesh adaptivity.",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5953601",
                          "updatedAt": "2023-05-20T03:16:05Z",
                          "publishedAt": "2023-05-20T03:16:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "You might be right!",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5983600",
                          "updatedAt": "2023-05-24T00:24:19Z",
                          "publishedAt": "2023-05-24T00:24:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ykvishal"
                          },
                          "bodyText": "This looks interesting. Can you share mesh block for both cases ( with adapvity if any)?",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-5984755",
                          "updatedAt": "2023-05-24T04:08:55Z",
                          "publishedAt": "2023-05-24T04:08:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "alimostafavi24"
                  },
                  "bodyText": "",
                  "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-6006629",
                  "updatedAt": "2023-05-26T00:44:30Z",
                  "publishedAt": "2023-05-26T00:44:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ykvishal"
                          },
                          "bodyText": "Thanks, I wanted to see mesh block from your input files. Can you double nx and ny in your right hand side simulation while keeping everything same? I want to see if there is any improvement.",
                          "url": "https://github.com/idaholab/moose/discussions/24414#discussioncomment-6006696",
                          "updatedAt": "2023-05-26T01:01:06Z",
                          "publishedAt": "2023-05-26T01:01:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}