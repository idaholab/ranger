{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wOC0wNFQxMjo1NTozOC0wNjowMM4ANW1Q"
    },
    "edges": [
      {
        "node": {
          "title": "Coefficient field (material properties) reconstruction through MOOSE - Wave Equation",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nI am working on two types of the inverse problem (reconstruction of the material properties) that involves solving the wave equation in the frequency domain for multiple right-hand sides. This problem is well known in geophysics (seismic inversion) and in biomedical imaging (Ultrasound imaging). Typically, this problem involve thousands of forward solves (FE simulation) as a results of sweeping over all frequency content and all sources (right hand sides) at each iteration to the optimization (reconstruction).\nAlthough I am just starting learning MOOSE and trying to switch to this new mindset, I can imagine how powerful MOOSE is especially for multiphysics simulation. However, I am still have some issues in deciding whether MOOSE is a suitable choice for my problems.\nTo be specific, the optimum framework that I am looking for is preferably have the following:\n1- Can handle complex arithmetics (needed for solving the wave equation in the frequency domain)\n2- Ability to modify the integration rule for specific region/regions of the domain (e.g. mid point integration), this is needed to model a variant of the perfectly matched layer (PMDL) that acts as wave absorber.\n3- Abitility to update material properties after each optimization iteration in runtime without the need for updating the input.i file after each iteration.\nSo, if you could please give some pointers on the previous 3 points and some pointer on how to model an arbitrary, completely heterogenous 3D domain (i.e each finite element in the mesh has different material property).\nI really appreciate your response.",
          "url": "https://github.com/idaholab/moose/discussions/18547",
          "updatedAt": "2022-08-08T18:21:48Z",
          "publishedAt": "2021-08-06T11:18:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe can definitely do 3. this is very routine. People can define material properties that are function of time, space, temperature, you name it. Their values can be different in every element, and can be recomputed as often as you want.\nSo you would want to use a different element type or quadrature rule in parts of the domain for 2? This is also possible, though more involved if this is not part of the ones we have already implemented in the framework. If you have an equation for that we may be able to give more details.\nI ll let people more expert about the wave equation reply about 1.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1140966",
                  "updatedAt": "2022-08-08T18:22:33Z",
                  "publishedAt": "2021-08-06T20:49:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think op wants different time integrators for different subdomains, which is currently not supported.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141052",
                          "updatedAt": "2022-08-08T18:22:53Z",
                          "publishedAt": "2021-08-06T21:35:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ah ok\nYou could do a multiapp approach for this. It would be like a separate calculation that you iterate to convergence.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141087",
                          "updatedAt": "2022-08-08T18:22:53Z",
                          "publishedAt": "2021-08-06T21:50:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Thank you, Guillaume and Gary, for the response.\nWith respect to the integration part (point 2), let's, for example, consider an elasticity problem in 2D, and consider the bilinear Q4 finite element, the full integration requires 4 Gauss Points, this is already there and I have no problem with it.\nNow, for some cases, for instance, when the problem suffers from volumetric locking, we need to do \"selective reduced integration\" where the volumetric strain is evaluated by only integrating at  one Gauss Point in the middle of the Q4 element, whereas the shear strain is evaluated by full integration.\nThis is a very helpful technique when modeling elastic half-spaces and wave absorbers. In addition, it can be used for modeling soft tissues where soft tissues are known to be incompressible.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141217",
                          "updatedAt": "2022-08-08T18:22:53Z",
                          "publishedAt": "2021-08-06T23:12:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "I think op wants different time integrators for different subdomains, which is currently not supported.\n\nI do not think I would need different time integrators. The problem that I solve is in the frequency domain. So, we would have many steady-state problems (corresponds to each frequency in the spectrum) as opposed to marching in time.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141226",
                          "updatedAt": "2022-09-28T23:06:41Z",
                          "publishedAt": "2021-08-06T23:19:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Ah sorry I misunderstood. Yeah, we do volumetric locking correction routinely. Mostly B-bar and F-bar.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141232",
                          "updatedAt": "2022-09-28T23:06:41Z",
                          "publishedAt": "2021-08-06T23:26:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Regarding your point one, I know libMesh definitely is able to solve complex eigenvalue problems, so there's no reason moose can't do that. I haven't done that myself, I think @fdkong or maybe @roystgnr know more about that.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141241",
                          "updatedAt": "2022-09-28T23:06:41Z",
                          "publishedAt": "2021-08-06T23:28:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "The trouble on the libMesh side is that, because PETSc (and thereby SLEPc) always forced users to choose between real and complex PetscScalar at configure time, libMesh never bothered to add runtime-selectable support for real and complex either.  For users who were writing individual complex eigenproblem solver applications this wasn't a hassle, but for frameworks like Moose?  Building a whole copy of Moose against an --enable-complex libMesh is what you'd have to do, and I'm not sure whether people actually can do that or not.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1149714",
                          "updatedAt": "2022-09-28T23:06:41Z",
                          "publishedAt": "2021-08-09T14:28:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Working with ADMaterial",
          "author": {
            "login": "rksin8"
          },
          "bodyText": "Is there any equivalent AD function to the coupledValueOld() and getMaterialPropertyOld<T>()?\nThanks,\nRanjeet",
          "url": "https://github.com/idaholab/moose/discussions/18482",
          "updatedAt": "2022-11-16T23:49:40Z",
          "publishedAt": "2021-07-30T09:47:47Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "rksin8"
                  },
                  "bodyText": "Solved this issue with help of tensor module material.",
                  "url": "https://github.com/idaholab/moose/discussions/18482#discussioncomment-1090974",
                  "updatedAt": "2022-11-16T23:49:41Z",
                  "publishedAt": "2021-07-30T11:01:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Old state properties are always non-dual numbers. The old state of an ADReal property is simply of type Real. That is because the old state does not depend on the current solution state! So the solution is to simply use coupledValueOld() and getMaterialPropertyOld<T>().",
                  "url": "https://github.com/idaholab/moose/discussions/18482#discussioncomment-1091849",
                  "updatedAt": "2022-11-16T23:49:42Z",
                  "publishedAt": "2021-07-30T15:26:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rksin8"
                          },
                          "bodyText": "Thank you for explaining this.\nWould you please explain when to use precomputeQpResidual() instead of computeQpResidual()?\nThank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18482#discussioncomment-1118519",
                          "updatedAt": "2022-11-16T23:49:42Z",
                          "publishedAt": "2021-08-02T05:44:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "You should start a new thread for this question. I assume you are asking something like precalculateQpResidual in IntegratedBC vs computeQpResidual. precalculateQpResidual provides derived objects a function to override where they can put local evaluations independent on shape functions (_i) to avoid repeated operations. You can see this by checking the code in IntegratedBC.C.",
                          "url": "https://github.com/idaholab/moose/discussions/18482#discussioncomment-1119056",
                          "updatedAt": "2022-11-16T23:49:43Z",
                          "publishedAt": "2021-08-02T08:12:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rksin8"
                          },
                          "bodyText": "@YaqiWang Thank you for pointing out some reference codes. I will ask a new question if need further help.",
                          "url": "https://github.com/idaholab/moose/discussions/18482#discussioncomment-1147667",
                          "updatedAt": "2022-11-16T23:49:43Z",
                          "publishedAt": "2021-08-09T07:02:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Postprocessor][Material property][getMaterialProperty]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear moose users,\nHow can I load material property in postprocessors?\nTypically, I want to use NodalVariablePostprocessor to calculate some values by nodal variable and material property.\nBut, when I use getMaterialProperty, it doesn't work and it shows the following error:\n'getMaterialProperty' was not declared in this scope; did you mean 'ADMaterialProperty'?\nI guess I have to add some header file that includes the definition of getMaterialProperty.\nBut I am not sure.\nKind regards",
          "url": "https://github.com/idaholab/moose/discussions/18545",
          "updatedAt": "2022-07-13T19:27:57Z",
          "publishedAt": "2021-08-06T06:17:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes, in general, you have to add the MaterialPropertyInterface to the classes that the postprocessor inherits from in order to use the getMaterialProperty routine. This is done for the user object classes that a lot of postprocessors inherit from.\nHowever, you are using a Nodal postprocessor, and currently NodalUserObject does not inherit from that class. The reason is that this interface is not able to compute nodal values, as material properties are tied to subdomains, so it would not know why one to pick at an interface between two subdomains.\nSo the solution here is to wait for us to implement functor material properties, which is underway in #18395, and will do nodal values of material properties\nOR\nconvert from nodal to elemental variables and use the Elemental postprocessors.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18545#discussioncomment-1141018",
                  "updatedAt": "2022-07-13T19:28:00Z",
                  "publishedAt": "2021-08-06T21:13:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Dear @GiudGiud,\nThank you for your comment!\nIt helps me a lot.\nI will look and follow up #18395 post.\nCheers,\nNakkyu",
                          "url": "https://github.com/idaholab/moose/discussions/18545#discussioncomment-1147298",
                          "updatedAt": "2022-07-13T19:28:05Z",
                          "publishedAt": "2021-08-09T04:55:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "An error when compiling the application executable",
          "author": {
            "login": "xchengood"
          },
          "bodyText": "Hi Moose expert or user,\nI am studying how to creat a Moose application following this page (https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/step01_moose_app.html). An error occurs when I try 'make -j4' in the step of Compile the Application Executable. There is no an executable (binary) file called babbler-opt. Could anyone help me fix this issue? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/18537",
          "updatedAt": "2021-08-08T02:49:57Z",
          "publishedAt": "2021-08-05T20:13:52Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "xchengood"
                  },
                  "bodyText": "I fix this issue by myself. Thank everyone.",
                  "url": "https://github.com/idaholab/moose/discussions/18537#discussioncomment-1143593",
                  "updatedAt": "2021-08-08T02:49:56Z",
                  "publishedAt": "2021-08-08T02:49:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about the \"ComputeSurfaceTensionKKS\"",
          "author": {
            "login": "wenpeng231024"
          },
          "bodyText": "Dear MOOSE group,\nBased on the  Laplace equation, the surface tension is 2\u03b3/R. \u03b3 is the surface energy. 1/R is the curvature. In the \"ComputeSurfaceTensionKKS\" example, the calculated extra_stress in the interface is 2\u03b3/R or \u03b3?\n\nhttps://mooseframework.inl.gov/source/materials/ComputeSurfaceTensionKKS.html\nThanks,\nPeng",
          "url": "https://github.com/idaholab/moose/discussions/18432",
          "updatedAt": "2023-02-26T10:22:05Z",
          "publishedAt": "2021-07-25T16:46:38Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "@laagesen",
                  "url": "https://github.com/idaholab/moose/discussions/18432#discussioncomment-1058573",
                  "updatedAt": "2023-02-26T10:22:05Z",
                  "publishedAt": "2021-07-26T21:58:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "This form will give surface tension 2*gamma/R.",
                          "url": "https://github.com/idaholab/moose/discussions/18432#discussioncomment-1058730",
                          "updatedAt": "2023-05-23T01:14:25Z",
                          "publishedAt": "2021-07-26T23:13:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wenpeng231024"
                          },
                          "bodyText": "Got it! Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/18432#discussioncomment-1059592",
                          "updatedAt": "2023-05-23T01:14:25Z",
                          "publishedAt": "2021-07-27T01:06:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wenpeng231024"
                          },
                          "bodyText": "Can this equation reflect the curvature of the gas bubble? Because when I use this equation to calculate the surface tension for different size bubbles. I found no difference in surface tension for the different radius of the gas bubbles. I use (extra_stress_00+extra_stress_11)/2 to calculate the surface tension in 2D.\nThanks,\nPeng",
                          "url": "https://github.com/idaholab/moose/discussions/18432#discussioncomment-1140515",
                          "updatedAt": "2023-05-23T01:14:24Z",
                          "publishedAt": "2021-08-06T18:09:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "You will find a pressure dependence on the radius.",
                          "url": "https://github.com/idaholab/moose/discussions/18432#discussioncomment-1143500",
                          "updatedAt": "2023-05-23T01:14:38Z",
                          "publishedAt": "2021-08-08T00:33:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Compute and track the ratio of the current timestep to the previous",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "For a time dependent solution of u, I would like to store the previous value of u and compare it to the current value of u. Another method would be to store the current value then compare it to the a subsequent u when the value of the subsequent u is greater than or less than a magnitude of the previously stored u. Is there a simple way to do this in MOOSE without having to create a C++ code using something like a \"do loop\" ?",
          "url": "https://github.com/idaholab/moose/discussions/18550",
          "updatedAt": "2023-06-12T06:00:42Z",
          "publishedAt": "2021-08-06T19:54:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Would any of these work for you:\nhttps://mooseframework.inl.gov/source/postprocessors/ChangeOverTimePostprocessor.html\nhttps://mooseframework.inl.gov/source/postprocessors/ChangeOverTimestepPostprocessor.html",
                  "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1140898",
                  "updatedAt": "2023-06-12T06:00:43Z",
                  "publishedAt": "2021-08-06T20:23:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Looks like it should do the trick. I will test it and provide an update on the result.\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1140989",
                          "updatedAt": "2021-08-06T21:00:40Z",
                          "publishedAt": "2021-08-06T21:00:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "It would appear that using the ChangeOverTime or Timestep would work in conjunction with SolutionFunction. The problem is that when I use solution function as defined:\n[./solution_fcn]\ntype = SolutionFunction\nfrom_variable = u\nsolution = solution_uo\n[../]\nI get the following error: (Functions/solution_fcn/solution):  The requested UserObject with the name \"solution_uo\" was not found.",
                          "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1141059",
                          "updatedAt": "2021-08-06T21:38:52Z",
                          "publishedAt": "2021-08-06T21:38:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "do you have a solution_uo somewhere? If not you need to add it\nBut I don't understand what the solution function is here for",
                          "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1141099",
                          "updatedAt": "2021-08-06T21:54:33Z",
                          "publishedAt": "2021-08-06T21:54:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "I copied this function from an example problem for SolutionFunction. The current site for it is under construction and there was not any real good instructions beyond the examples provided. There was also no other reference to the solution_uo. This function (SolutionFunction)seems to be the only one that I could find that will operate on a kernel variable.",
                          "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1141117",
                          "updatedAt": "2021-08-06T22:04:21Z",
                          "publishedAt": "2021-08-06T22:02:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "SolutionFunction is used to have the result of a previous solve, eg loaded using a solution user object, in a function.\nIt's not really for looking at older values within the same solve.\nThe two post processors I linked do that. What are you trying to get from this comparison of current and previous value? Examine convergence ?",
                          "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1141144",
                          "updatedAt": "2021-08-06T22:19:26Z",
                          "publishedAt": "2021-08-06T22:19:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Yes. I am looking to have a means to measure convergence/divergence of the current timestep solution to a reference timestep. The output would be in the form of the resulting ratio.",
                          "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1143346",
                          "updatedAt": "2021-08-07T22:06:29Z",
                          "publishedAt": "2021-08-07T22:06:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Do you already know the solution at the reference timestep? Or are you computing it during the simulation (is it like the last one?)",
                          "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1143355",
                          "updatedAt": "2022-11-21T17:02:43Z",
                          "publishedAt": "2021-08-07T22:19:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "The reference value is stored in solution during the solve. The first time step solution of u is the initial reference solution. The current solution is compared to the reference u and then becomes the new reference u etc.",
                          "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1143375",
                          "updatedAt": "2022-11-21T17:02:43Z",
                          "publishedAt": "2021-08-07T22:40:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Does it always become the new reference? If so then ChangeOverTimestep compares to the previous one.\nIf not, then I'd write a custom aux kernel based on SelfAux to save the reference value, then compare with a DifferencePostprocessor or a ParsedPostprocessor",
                          "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1143380",
                          "updatedAt": "2022-11-21T17:02:43Z",
                          "publishedAt": "2021-08-07T22:44:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Yes it always become the new reference. Can ChangeOverTimestep be apples directly to a kernel variable u. It seems from the example for use of ChangeOverTimestep that it works only with a defined function. What would be the syntax required to have ChangeOverTimestep operate on the variable u?",
                          "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1143402",
                          "updatedAt": "2023-06-12T06:00:43Z",
                          "publishedAt": "2021-08-07T22:58:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "So I'd recommend:\n\n\na SelfAux to save the variable value at TIMESTEP_BEGIN, to have the old value:\nhttps://mooseframework.inl.gov/source/auxkernels/SelfAux.html\n\n\nThen a ParsedAux to compute the difference, relative difference or whatever you need, and store it in another aux variable, at TIMESTEP_END for example.\n\n\nThen a ElementL1Error comparing the new aux variable to a 0 reference function.\nhttps://mooseframework.inl.gov/source/postprocessors/ElementL1Error.html\n\n\nIf you want an L2 error or something that already exists, you can skip step 2-3 and just use that.\nOr you could write your own postprocessor to do this. In which case, you can get old values of variables directly in the postprocessor using coupledValueOld",
                  "url": "https://github.com/idaholab/moose/discussions/18550#discussioncomment-1143426",
                  "updatedAt": "2023-06-12T06:00:46Z",
                  "publishedAt": "2021-08-07T23:08:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stochastic: Strings in CSV sampler",
          "author": {
            "login": "MatiasAllay"
          },
          "bodyText": "Hi MOOSE,\nI have performed many simulations in steady state and now I would like to restart these simulations in transient state. The transient state simulation differs in many things with the steady simulation.\nI am using FileMeshGenerator to call the steady simulation, but since I have a large amount of files I would like to make this workflow automatic with stochastic. I thought on using  MultiAppCommandLineControl and CSVSampler, but this sampler does not take strings (the names of the transient state result files) as an input.\nIs there a way to go around this?\nThanks!\nMatias",
          "url": "https://github.com/idaholab/moose/discussions/18526",
          "updatedAt": "2022-07-14T19:24:44Z",
          "publishedAt": "2021-08-04T13:16:41Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "MatiasAllay"
                  },
                  "bodyText": "Hi MOOSE,\nI solved this with a Python script. The only downside is that I can't print on the console the simulation status/result. But I guess is okay.\nThanks!",
                  "url": "https://github.com/idaholab/moose/discussions/18526#discussioncomment-1137943",
                  "updatedAt": "2022-07-14T19:24:44Z",
                  "publishedAt": "2021-08-06T07:39:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Output free energy from GrainGrowthAction",
          "author": {
            "login": "KaijieNing"
          },
          "bodyText": "Hi, team,\nI am trying to figure out how to use the GrainGrowthAction in the phase-field module to simulate the polycrystal growth behavior.  I have the problem to output the free energy.\nIn the Materials property part of my input file, I can add constants L, kappa_op, mu, and gama_asymm to run the simulation. If I use the TotalFreeEngery type to output the free energy, it requires me to add the free energy function. But the GrainGrowth action should already have the free energy function. I do not know how can I use it. Is there a way to output the free energy? Attached is my input file.\nThanks very much.\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 50\n  ny = 50\n  nz = 0\n  xmin = 0\n  xmax = 100\n  ymin = 0\n  ymax = 100\n  zmin = 0\n  zmax = 0\n  elem_type = QUAD4\n[]\n\n[GlobalParams]\n  op_num = 3\n  var_name_base = gr\n[]\n\n[Variables]\n  [./PolycrystalVariables]\n  [../]\n[]\n\n[UserObjects]\n  [./voronoi]\n    type = PolycrystalVoronoi\n    rand_seed = 105\n    grain_num = 3\n    coloring_algorithm = bt\n  [../]\n[]\n\n[ICs]\n  [./PolycrystalICs]\n    [./PolycrystalColoringIC]\n      polycrystal_ic_uo = voronoi\n    [../]\n  [../]\n[]\n\n[AuxVariables]\n  [./bnds]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  \n  [./local_free_energy]\n    family = MONOMIAL\n    order = CONSTANT\n  [../]\n  \n[]\n\n\n[Modules]\n  [./PhaseField]\n    [./GrainGrowth]\n      variable_mobility = false\n      kappa = kappa_op\n      mobility = L           \n    [../]\n  [../]\n[]\n\n[AuxKernels]\n  [./BndsCalc]\n    type = BndsCalcAux\n    variable = bnds\n    execute_on = timestep_end\n  [../]\n\n  [./local_free_energy]\n    type = TotalFreeEnergy\n    variable = local_free_energy\n    f_name = F\n    kappa_names = 'kappa_op kappa_op kappa_op'\n    interfacial_vars ='gr0 gr1 gr2'   \n  [../]\n\n[]\n\n#[BCs]\n  #[./Periodic]\n    #[./All]\n     # auto_direction = 'x y'\n    #[../]\n # [../]\n#[]\n\n\n[Materials]\n  [./constant]\n    type = GenericConstantMaterial\n    prop_names  = 'L     kappa_op  mu   gamma_asymm'\n    prop_values = '1.0    2.0       1.0   1.5' \n  [../]  \n  [./free_energy]\n   type = DerivativeParsedMaterial\n   f_name = F                     \n   args = 'gr2 gr1 gr0'           \n   outputs = exodus\n  [../] \n\n[]\n\n[Postprocessors]\n  active = ''\n  [./ngrains]\n    type = FeatureFloodCount\n    variable = bnds\n    threshold = 0.7\n  [../]\n\n  [./total_free_energy]\n    type = ElementIntegralVariablePostprocessor\n    variable = local_free_energy\n  [../]\n  \n  [./total_gr0]\n    type = ElementIntegralVariablePostprocessor\n    variable = gr0\n  [../]\n  \n  [./total_gr1]\n    type = ElementIntegralVariablePostprocessor\n    variable = gr1\n  [../]\n\n  [./total_gr2]\n    type = ElementIntegralVariablePostprocessor\n    variable = gr2\n  [../]  \n[]\n\n[Preconditioning]\n  active = ''\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  scheme = 'bdf2'\n  solve_type = 'NEWTON'\n\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'asm        31    preonly    ilu          1' \n\n  l_tol = 1.0e-4\n  l_max_its = 30\n  nl_max_its = 20\n  nl_rel_tol = 1.0e-9\n  start_time = 0.0\n  num_steps = 3\n  dt = 1\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  perf_graph = true\n  interval = 1\n[]",
          "url": "https://github.com/idaholab/moose/discussions/18518",
          "updatedAt": "2023-06-30T09:19:17Z",
          "publishedAt": "2021-08-03T18:20:39Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "If you set f_name = 0 you will get only the interfacial contributions, which should be all you need.",
                  "url": "https://github.com/idaholab/moose/discussions/18518#discussioncomment-1126892",
                  "updatedAt": "2023-06-30T09:19:32Z",
                  "publishedAt": "2021-08-03T18:31:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Actually, strike that. That definitely will not be enough! You could implement a Material class to compute the local free energy density, according to the equation for floc in https://mooseframework.inl.gov/moose/modules/phase_field/Grain_Growth_Model.html",
                          "url": "https://github.com/idaholab/moose/discussions/18518#discussioncomment-1126946",
                          "updatedAt": "2023-06-30T09:19:32Z",
                          "publishedAt": "2021-08-03T18:47:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Or derive from TotalFreeEnergyBase...",
                          "url": "https://github.com/idaholab/moose/discussions/18518#discussioncomment-1126961",
                          "updatedAt": "2023-06-30T09:19:32Z",
                          "publishedAt": "2021-08-03T18:49:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KaijieNing"
                          },
                          "bodyText": "Thanks very much! I think I got your idea. Total free energy should include floc and fgrd. I wanted to use the existing MOOSE objects, so I added the expression for free energy function F in the Materials object (see below), and kept using the TotalFreeEnergy object.  Now I got the outputs from the .e file and was able to see it from Varaview. But I have a new problem that I could not output the .csv file though I set csv = true. So I have no information on total free energy and grain areas for me to plot out in Excel. Do I still have something else wrong with the input file?\n[./free_energy]\ntype = DerivativeParsedMaterial\nf_name = F\nargs = 'gr2 gr1 gr0'\nfunction = 'mu*((0.25gr2^4-0.5gr2^2)\n+(0.25gr1^4-0.5gr1^2)\n+(0.25gr0^4-0.5gr0^2)\n+gamma_asymm*((gr2^2)(gr1^2)\n+(gr2^2)(gr0^2)\n+(gr1^2)*(gr0^2))+0.25)'\nderivative_order = 2\nmaterial_property_names = 'mu gamma_asymm'\noutputs = exodus\n[../]",
                          "url": "https://github.com/idaholab/moose/discussions/18518#discussioncomment-1135851",
                          "updatedAt": "2023-06-30T09:19:32Z",
                          "publishedAt": "2021-08-05T17:26:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Hm, if you have Postrocessors and Outputs/csv=true, you should definitely get a CSV output file with the PP values in it.",
                          "url": "https://github.com/idaholab/moose/discussions/18518#discussioncomment-1136116",
                          "updatedAt": "2023-10-09T23:20:19Z",
                          "publishedAt": "2021-08-05T18:32:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KaijieNing"
                          },
                          "bodyText": "Problem solved. I checked it again, and I realized that I should not use active = ' ' in the Postprocessors,  or I should set active for the outputs I wanted. Thanks very much.",
                          "url": "https://github.com/idaholab/moose/discussions/18518#discussioncomment-1137469",
                          "updatedAt": "2023-10-09T23:20:19Z",
                          "publishedAt": "2021-08-06T03:42:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unable to find user object",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "Hello,\nIm trying to build and use a user object i defined using the action system but im running into this error when trying to access the object after i build it, Unable to find user object with name spec. I made a previous post about trying to have a user object add variables and was told that i should build the user object and adding the variables in an custom action block. See here #18483. Here is the code im using in my AddSpecies action.\n#include \"AddSpeciesAction.h\"\n#include \"SpeciesDefinition.h\"\n#include \"FEProblemBase.h\"\n#include \"AddVariableAction.h\"\n\nregisterMooseAction(\"moleApp\", AddSpeciesAction, \"add_variable\");\nregisterMooseAction(\"moleApp\", AddSpeciesAction, \"add_species_definition\");\n\nInputParameters\nAddSpeciesAction::validParams()\n{\n  InputParameters params = Action::validParams();\n  params.addRequiredParam<std::vector<std::string>>(\"species_names\", \"The species names\");\n  params.addParam<std::vector<std::string>>(\"phase_names\", \"Phase names for the species\");\n  params.addRequiredParam<std::vector<Real>>(\"molar_masses\", \"The molar masses of species\");\n  params.addClassDescription(\"Adds the species to the problem\");\n  return params;\n}\n\nAddSpeciesAction::AddSpeciesAction(const InputParameters & params)\n  : Action(params)\n{\n}\n\nvoid\nAddSpeciesAction::act()\n{\n  if (_current_task == \"add_species_definition\")\n  {\n    auto params = _factory.getValidParams(\"SpeciesDefinition\");\n    params.set<std::vector<std::string>>(\"species_names\") =\n      getParam<std::vector<std::string>>(\"species_names\");\n    params.set<std::vector<Real>>(\"molar_masses\") =\n      getParam<std::vector<Real>>(\"molar_masses\");\n    if (isParamValid(\"phase_names\"))\n      params.set<std::vector<std::string>>(\"phase_names\") =\n        getParam<std::vector<std::string>>(\"phase_names\");\n    _problem->addUserObject(\"SpeciesDefinition\", \"spec\", params);\n  }\n  else if (_current_task == \"add_variable\")\n  {\n    auto _vars = _problem->getUserObject<SpeciesDefinition>\n      (\"spec\").getSpeciesVarNames();\n    auto fe_type = AddVariableAction::feType(_pars);\n    auto type = AddVariableAction::determineType(fe_type, 1);\n    auto var_params = _factory.getValidParams(type);\n\n    var_params.applySpecificParameters(_pars, {\"family\", \"order\", \"scaling\"});\n\n    for (auto & var : _vars)\n      _problem->addVariable(type, var, var_params);\n  }\n}\n\nI added the following to my mainApp.C\n  registerSyntax(\"ConvectionAction\", \"Convection\");\n  registerSyntax(\"AddSpeciesAction\", \"AddSpecies\");\n  registerMooseObjectTask(\"add_species_definition\", AddSpeciesAction, false);\n  addTaskDependency(\"add_species_definition\", \"add_user_object\");\n\nIm not sure if there is some kinda order to when add_species_definition is being called after add_variable or something. Also, if i call _problem->getUserObject<SpeciesDefinition>(\"spec\") in other actions in my app will it return the correct user object that is created in this action?",
          "url": "https://github.com/idaholab/moose/discussions/18513",
          "updatedAt": "2022-12-02T09:57:08Z",
          "publishedAt": "2021-08-03T17:06:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Change\nregisterMooseObjectTask(\"add_species_definition\", AddSpeciesAction, false);\n\nto\nregisterTask(\"add_species_definition\", false);",
                  "url": "https://github.com/idaholab/moose/discussions/18513#discussioncomment-1127101",
                  "updatedAt": "2023-04-26T02:29:28Z",
                  "publishedAt": "2021-08-03T19:18:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "So this did not fix my issue. It still gives me the same error. On a side note, Im not exactly sure what line addTaskDependency(\"add_species_definition\", \"add_user_object\"); does but if i comment this line out, the code runs and gives me a different error. It seg falts on line _problem->addUserObject(\"SpeciesDefinition\", \"spec\", params);",
                          "url": "https://github.com/idaholab/moose/discussions/18513#discussioncomment-1131094",
                          "updatedAt": "2023-04-27T20:09:54Z",
                          "publishedAt": "2021-08-04T16:37:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Hmm. Can you share your repo?",
                          "url": "https://github.com/idaholab/moose/discussions/18513#discussioncomment-1131726",
                          "updatedAt": "2023-04-27T20:09:59Z",
                          "publishedAt": "2021-08-04T19:40:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "Unfortunately it is hosted on an internal ORNL git repo so I cannot. I can post my main apps C file and the header and C file for the action object, if that would help.",
                          "url": "https://github.com/idaholab/moose/discussions/18513#discussioncomment-1132002",
                          "updatedAt": "2023-04-27T20:10:00Z",
                          "publishedAt": "2021-08-04T21:01:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "I think that your problem is that add_user_object (and hence add_species_definition) gets run after add_variables, see https://github.com/idaholab/moose/blob/next/framework/src/base/Moose.C.\naddTaskDependency(\"add_species_definition\", \"add_user_object\") does what you probably thought it does - it makes sure that the add_user_object task is run before your add_species_definition task runs. So you definitely want that line left in!\nYou could possibly just include the add variable code into the add_species_definition to fix it, or even make another task like add_species_variables to add your variables and make it depend on your add_species_definition task.",
                  "url": "https://github.com/idaholab/moose/discussions/18513#discussioncomment-1132912",
                  "updatedAt": "2023-04-27T20:10:01Z",
                  "publishedAt": "2021-08-05T04:35:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "This work! Thanks for your help. This also helped me understand what the addTaskDependency call means.",
                          "url": "https://github.com/idaholab/moose/discussions/18513#discussioncomment-1134646",
                          "updatedAt": "2023-04-27T20:10:02Z",
                          "publishedAt": "2021-08-05T13:14:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Adding variables in or after the add_user_object task seems a little dangerous, as by that time the setup_variables_complete task, the setup of the quadrature rules (dependent on variable order), and the setup of periodic BCs have already run and wouldn't know anything about the new variables.\nCan you infer the list of variable names to set up with out actually instantiating the user object? E.g. using a static member method?",
                          "url": "https://github.com/idaholab/moose/discussions/18513#discussioncomment-1135184",
                          "updatedAt": "2023-04-27T20:10:04Z",
                          "publishedAt": "2021-08-05T15:07:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "Oh ok i see what you are talking about. Yes i can infer the names, ill try to change the order of the calls making adding the variables dependent on add_variable",
                          "url": "https://github.com/idaholab/moose/discussions/18513#discussioncomment-1136599",
                          "updatedAt": "2023-04-27T20:10:05Z",
                          "publishedAt": "2021-08-05T21:15:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "@dschwen - good point!",
                          "url": "https://github.com/idaholab/moose/discussions/18513#discussioncomment-1136665",
                          "updatedAt": "2023-04-27T20:10:25Z",
                          "publishedAt": "2021-08-05T21:38:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fluid Properties | Failed Compilation",
          "author": {
            "login": "rl3fz"
          },
          "bodyText": "Hello everyone!\nI tried to include the fluid properties module (switched from 'no' to 'yes' in my application's Makefile),\nbut when I tried to compile and test, it failed with the output: FAILED (Application not found)\nDoes anyone know how I can proceed? The application was working fine beforehand, and I updated MOOSE yesterday.\n(Any and all advice appreciated!)",
          "url": "https://github.com/idaholab/moose/discussions/18520",
          "updatedAt": "2024-06-19T22:02:27Z",
          "publishedAt": "2021-08-03T19:42:59Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "That's odd\nDid you run 'make clobberall' before rebuilding?",
                  "url": "https://github.com/idaholab/moose/discussions/18520#discussioncomment-1127283",
                  "updatedAt": "2024-06-19T22:02:31Z",
                  "publishedAt": "2021-08-03T19:59:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "I had not, but I just tried that (along with make -j4 and ./run_tests -j4) and got the same result.",
                          "url": "https://github.com/idaholab/moose/discussions/18520#discussioncomment-1127420",
                          "updatedAt": "2024-06-19T22:02:35Z",
                          "publishedAt": "2021-08-03T20:36:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Might need to git clean -xfd (after committing ALL your changes and saving ALL your work)\nCould you please paste the the error message from the compilation\nThe FAILED error message just means an executable was not created",
                          "url": "https://github.com/idaholab/moose/discussions/18520#discussioncomment-1127642",
                          "updatedAt": "2024-06-19T22:02:35Z",
                          "publishedAt": "2021-08-03T21:31:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "After all of the \"Creating Unity...\" lines, it showed the following:\n/home//miniconda3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/9.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home//miniconda3/envs/moose/lib/libgomp.so.1: undefined reference to clock_gettime@GLIBC_2.17' /home/****/miniconda3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/9.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/****/miniconda3/envs/moose/lib/libgomp.so.1: undefined reference to clock_getres@GLIBC_2.17'\n/home//miniconda3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/9.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home//miniconda3/envs/moose/lib/libgomp.so.1: undefined reference to aligned_alloc@GLIBC_2.16' /home/****/miniconda3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/9.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/****/miniconda3/envs/moose/lib/libgomp.so.1: undefined reference to secure_getenv@GLIBC_2.17'\ncollect2: error: ld returned 1 exit status\nmake: *** [/home//projects/moose/framework/moose.mk:374: /home//projects/moose/framework/contrib/exodiff/exodiff] Error 1\nmake: *** Waiting for unfinished jobs....",
                          "url": "https://github.com/idaholab/moose/discussions/18520#discussioncomment-1130112",
                          "updatedAt": "2024-06-19T22:02:40Z",
                          "publishedAt": "2021-08-04T12:52:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you switch fluid_properties back does it work again?\nCan you compile in moose/framework/ ?\nDid you update Conda?\nThese errors really look like you have previously compiled binaries and updated your Conda environment. Running git clean -xfd in your app and in moose should help.",
                          "url": "https://github.com/idaholab/moose/discussions/18520#discussioncomment-1130871",
                          "updatedAt": "2024-06-19T22:02:50Z",
                          "publishedAt": "2021-08-04T15:42:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "if you switch fluid_properties back does it work again?\n\nNo\n\nCan you compile in moose/framework/ ?\n\nNo\n\nDid you update Conda?\n\nNot since Monday, but after updating today, I was able to compile moose/framework/ , and my application (without fluid properties) compiled, so I tried including fluid properties again, and it worked!\nSeems I should be updating more frequently (or forgetting 'make clobberall' earlier really messed with the system), but I'll keep 'git clean -xfd' in mind for next time. Thank you!!\n(edited for clarity)",
                          "url": "https://github.com/idaholab/moose/discussions/18520#discussioncomment-1131580",
                          "updatedAt": "2024-06-19T22:03:03Z",
                          "publishedAt": "2021-08-04T18:55:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}