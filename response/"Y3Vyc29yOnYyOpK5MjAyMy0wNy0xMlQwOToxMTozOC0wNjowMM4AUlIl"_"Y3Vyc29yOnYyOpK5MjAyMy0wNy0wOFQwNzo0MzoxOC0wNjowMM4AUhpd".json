{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNy0wOFQwNzo0MzoxOC0wNjowMM4AUhpd"
    },
    "edges": [
      {
        "node": {
          "title": "A 'BarrierFunctionMaterial' is not a registered object.",
          "author": {
            "login": "Leiming-123"
          },
          "bodyText": "Hi everyone,\nI try to run a input file by using moose. But it shows\"\n*** ERROR ***\nA 'BarrierFunctionMaterial' is not a registered object.\nIf you are trying to find this object in a dynamically loaded library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\"\n\nCould anyone please tell me how to solve this problem?\nI download the code from the \"https://nanohub.org/resources/tincopperem\". And I select phase-field modules and try to run the \"coarse_eightgrainEM_0_BC_commentless.i\"",
          "url": "https://github.com/idaholab/moose/discussions/24955",
          "updatedAt": "2023-07-12T15:10:21Z",
          "publishedAt": "2023-07-12T07:42:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat ldd <your executable> return ? (only works on linux, let me know if you are on macos)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24955#discussioncomment-6428723",
                  "updatedAt": "2023-07-12T15:10:30Z",
                  "publishedAt": "2023-07-12T15:10:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Rainfall induced stability in porous flow using tensormechanics module",
          "author": {
            "login": "delpierrena"
          },
          "bodyText": "Hello,\nI'm trying to simulate slope instabilities due to rainfalls in the module PorousFlow. To do so, I need to simulate the infiltration of water with the Richards equation and then use the TensorMechanicsPlasticMohrCoulomb plastic model that depends on the degree of saturation. I will have heterogeneous plastic properties (cohesion and friction angle) that vary at each Gauss points.\nBut for the moment, the parameters of the Mohr Coulomb model (cohesion and friction angle) are defined through an User Object in the pattern of TensorMechanicsHardeningModel which only depends on the accumulated plastic strain and the stress level, assuming the same yield function parameters in the whole domain.\nIs there a way to define the value of cohesion and friction at the nodes or cells center and not as constant for the whole material ?\nOr do I need to change the implementation more in depth ?\nThank you !\nNathan",
          "url": "https://github.com/idaholab/moose/discussions/24087",
          "updatedAt": "2023-07-12T14:04:39Z",
          "publishedAt": "2023-04-17T08:23:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Unfortunately, it is not possible to define the value of cohesion and friction at the nodes or cells center, only by Material.  I think you're going to have to do C++ work, boohoo.",
                  "url": "https://github.com/idaholab/moose/discussions/24087#discussioncomment-5682467",
                  "updatedAt": "2023-04-21T06:55:07Z",
                  "publishedAt": "2023-04-21T06:55:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "delpierrena"
                          },
                          "bodyText": "Hello,\nIn order to use the TensorMechanicsPlasticMohrCoulomb UO with heterogeneous mechanical properties, I am trying to build a new UO based on the TensorMechanicsHardeningModel. My initial idea was to give a FunctionAux as a required parameter :\nInputParameters\nTensorMechanicsHardeningHeterogeneous::validParams()\n{\n  InputParameters params = TensorMechanicsHardeningModel::validParams();\n  params.addRequiredParam<FunctionName>(    \"value\",\n                                            \"The value of the parameter for all internal parameter.  \"\n                                            \"The value will decrease linearly with time.\");\n  params.addParam<bool>(\"convert_to_radians\",\n                        false,\n                        \"If true, the value you entered will be \"\n                        \"multiplied by Pi/180 before passing to the \"\n                        \"Plasticity algorithms\");\n  params.addClassDescription(\n      \"No hardening - the parameter only depends on time\");\n  return params;\n}\n\nThen I build my specific UO as follows :\n TensorMechanicsHardeningHeterogeneous::TensorMechanicsHardeningHeterogeneous(\n    const InputParameters & parameters)\n  : TensorMechanicsHardeningModel(parameters),\n    _val(parameters)\n{\n}\n\nAnd this is where my issue starts because I dont understand how to specifically access the value taken at the current quadrature point :\nReal TensorMechanicsHardeningHeterogeneous::value(Real /*intnl*/) const { return _val; }\n\nReal TensorMechanicsHardeningHeterogeneous::derivative(Real /*intnl*/) const { return 0.0; }\n\nstd::string\nTensorMechanicsHardeningHeterogeneous::modelName() const\n{\n  return \"ConstantTime\";\n}\n\nOf course the value function throws back an error when compiling\n error: cannot convert 'const FunctionAux' to 'libMesh::Real' {aka 'double'} in return\n   39 | Real TensorMechanicsHardeningHeterogeneous::value(Real /*intnl*/) const { return _val; }\n\nDo you think of any way to do this  ? Or I am going in the wrong direction?\nThank you very much !\nNathan",
                          "url": "https://github.com/idaholab/moose/discussions/24087#discussioncomment-6427000",
                          "updatedAt": "2023-07-12T12:36:50Z",
                          "publishedAt": "2023-07-12T12:36:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nthis isn\u2019t quite how to retrieve a function\nplease use getFunction in the constructor s initialization list (see GenericFunctionMaterial for an example)\nand same when you want to use a function to get a value you don\u2019t return the function itself (or it\u2019s name) you use the function object and call the value(time, \u2026) routine on it",
                          "url": "https://github.com/idaholab/moose/discussions/24087#discussioncomment-6427831",
                          "updatedAt": "2023-07-12T14:04:39Z",
                          "publishedAt": "2023-07-12T14:04:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to add irradiation growth model",
          "author": {
            "login": "jin0123456"
          },
          "bodyText": "Hello,\nI was wondering how to add irradiation growth model to the simulation. And I have a model of the irradiation growth rate. Which material should I use?\nHope to get some ideas.",
          "url": "https://github.com/idaholab/moose/discussions/24912",
          "updatedAt": "2023-07-12T07:18:34Z",
          "publishedAt": "2023-07-06T07:14:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI don't think this is available in MOOSE.\nYou ll want to ask for access to Bison or marmot, depending on the scale you care about\nhttps://ncrcaims.inl.gov/Identity/Account/Register\n@recuero\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24912#discussioncomment-6375719",
                  "updatedAt": "2023-07-06T15:42:11Z",
                  "publishedAt": "2023-07-06T15:42:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "Here \u03b5_glc is strain in axial direction and \u03b5_grc is strain in radial direction. I'm just trying to add a simple strain model that shows up in anisotropy. I wonder how I can add this eigenstrain model using corresponding material like Compute Thermal Expansion Eigenstrain?\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24912#discussioncomment-6379197",
                          "updatedAt": "2023-07-07T00:37:59Z",
                          "publishedAt": "2023-07-07T00:37:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "You can inherit from (AD)ComputeEigenstrainBase and implement a directional constitutive behavior, which we already have in various places in the MOOSE modules.  If you search for \"anisotropy\" you'll find a few instances of it. Since you can define a thermal eigenstrain in the form of a second order tensor, there is no limitation as to behavior in the radial or axial directions.",
                          "url": "https://github.com/idaholab/moose/discussions/24912#discussioncomment-6386872",
                          "updatedAt": "2023-07-07T17:19:58Z",
                          "publishedAt": "2023-07-07T17:19:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "Thanks for your reply. I wonder if there's an example that could help for my situation cause I didn't find one. Or examples about how can I write the corresponding tensor from this strain model?\nThanks again.",
                          "url": "https://github.com/idaholab/moose/discussions/24912#discussioncomment-6391299",
                          "updatedAt": "2023-07-08T12:55:50Z",
                          "publishedAt": "2023-07-08T12:55:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "If you look at ComputeCrystalPlasticityEigenstrainBase in the tensor mechanics module, you'll find that a RankTwoTensor eigenstrain is being computed.  You can replace that definition of the eigenstrain with your own definition and include it in your mechanics. The example may not fit exactly what you want to do, but, as I understand what you want to do, all the ingredients are there.",
                          "url": "https://github.com/idaholab/moose/discussions/24912#discussioncomment-6392557",
                          "updatedAt": "2023-07-08T17:36:55Z",
                          "publishedAt": "2023-07-08T17:36:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "OK, I will try. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24912#discussioncomment-6400310",
                          "updatedAt": "2023-07-10T05:56:32Z",
                          "publishedAt": "2023-07-10T05:56:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "Here I inherited ComputeEigenstrainBase  for my irradiation growth model and applied it to the input file. But I found that I did not seem to have succeeded in applying this model to my simulations cause the simulation results did not change after adding this part.\nHere is the .h and .C,\n#pragma once\n\n#include \"ComputeEigenstrainBase.h\"\n\n#include \"RankTwoTensor.h\"\n#include \"Function.h\"\n\nclass Function;\ntemplate <bool is_ad>\nclass ComputeIrridiationTempl : public ComputeEigenstrainBaseTempl<is_ad>\n{\npublic:\n  static InputParameters validParams();\n\n  ComputeIrridiationTempl(const InputParameters & parameters);\n\nprotected:\n\n  virtual void computeQpEigenstrain() override;\n  virtual void computeQpProperties() override;\n\n  const Function & _neu;\n  const GenericMaterialProperty<Real, is_ad> & _prefactor;\n\n  GenericMaterialProperty<Real, is_ad> & _strain_glc;\n  GenericMaterialProperty<Real, is_ad> & _strain_grc;\n  GenericMaterialProperty<Real, is_ad> & _strain_cir;\n  GenericMaterialProperty<RankTwoTensor, is_ad> & _eigen_base_tensor;\n\n  using Material::_qp;\n  using Material::_t;\n  using Material::_q_point;\n  using ComputeEigenstrainBaseTempl<is_ad>::_eigenstrain;\n};\n\ntypedef ComputeIrridiationTempl<false> ComputeIrridiation;\ntypedef ComputeIrridiationTempl<true> ADComputeIrridiation;\n\n#include \"ComputeIrridiation.h\"\n\nregisterMooseObject(\"WorkerApp\", ComputeIrridiation);\nregisterMooseObject(\"WorkerApp\", ADComputeIrridiation);\n\ntemplate <bool is_ad>\nInputParameters\nComputeIrridiationTempl<is_ad>::validParams()\n{\n  InputParameters params = ComputeEigenstrainBase::validParams();\n  params.addClassDescription(\"Computes a constant Eigenstrain\");\n  params.addParam<FunctionName>(\"neu\", 0.0, \"Neutron\");\n  params.addParam<MaterialPropertyName>(\n      \"prefactor\", 1.0, \"Name of material property defining the variable dependence\");\n  return params;\n}\n\ntemplate <bool is_ad>\nComputeIrridiationTempl<is_ad>::ComputeIrridiationTempl(const InputParameters & parameters)\n  : ComputeEigenstrainBaseTempl<is_ad>(parameters),\n    _prefactor(this->template getGenericMaterialProperty<Real, is_ad>(\"prefactor\")),\n    _strain_glc(this->template declareGenericProperty<Real, is_ad>(\"strain_glc\")),\n    _strain_grc(this->template declareGenericProperty<Real, is_ad>(\"strain_grc\")),\n    _strain_cir(this->template declareGenericProperty<Real, is_ad>(\"strain_cir\")),\n    _eigen_base_tensor(this->template declareGenericProperty<RankTwoTensor, is_ad>(\"eigen_base_tensor\")),\n    _neu(this->getFunction(\"neu\"))\n{\n  \n}\n\ntemplate <bool is_ad>\nvoid\nComputeIrridiationTempl<is_ad>::computeQpProperties()\n{\n  _strain_glc[_qp] = 2.18e-21 * std::pow(_neu.value(_t, _q_point[_qp]) * _t / 10000., 0.845);\n  //_strain_glc[_qp] = 0.1;\n  _strain_grc[_qp] = std::pow((1. + _strain_glc[_qp]), -0.5) - 1;\n  _strain_cir[_qp] = 0.0;\n  _eigen_base_tensor[_qp].fillFromInputVector({_strain_grc[_qp],_strain_glc[_qp],_strain_cir[_qp]});\n}\n\n\n\ntemplate <bool is_ad>\nvoid\nComputeIrridiationTempl<is_ad>::computeQpEigenstrain()\n{\n  // Define Eigenstrain\n  _eigenstrain[_qp] = _eigen_base_tensor[_qp] * _prefactor[_qp];\n}\n\nHere is part of input,\n[Modules/TensorMechanics/Master]\n  [fuel]\n    strain = FINITE\n    add_variables = true\n    eigenstrain_names = 'thermal_expansion_eigenstrain'\n    generate_output = ' stress_zz vonmises_stress'\n    block = 'fuel'\n  []\n  [clad]\n    strain = FINITE\n    add_variables = true\n    eigenstrain_names = 'thermal_expansion_eigenstrain irridiation_growth_eigenstrain'\n    generate_output = ' stress_zz vonmises_stress creep_strain_xx'\n    block = 'clad'\n  []\n[]\n\n  [CZ_irridiation_growth]\n    type = ComputeIrridiation\n    neu = neu_flux_fun\n    eigenstrain_name = irridiation_growth_eigenstrain\n    block = 'clad'\n  []\n\nWhere did I go wrong about all this? @recuero",
                          "url": "https://github.com/idaholab/moose/discussions/24912#discussioncomment-6411952",
                          "updatedAt": "2023-07-11T05:44:05Z",
                          "publishedAt": "2023-07-11T05:39:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "@GiudGiud any ideas?",
                          "url": "https://github.com/idaholab/moose/discussions/24912#discussioncomment-6423813",
                          "updatedAt": "2023-07-12T07:18:35Z",
                          "publishedAt": "2023-07-12T07:18:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can I modify the number of edges?",
          "author": {
            "login": "bosxered"
          },
          "bodyText": "Hi Moose experts,\nI want to modify the number of edges.\nFollowing is my input file.\n[Mesh]\n  [./poly1]\n    type = PolyLineMeshGenerator\n    points = '0.0 0.0 0.0\n              9.0 0.0 0.0\n              9.0 1.1 0.0'\n    loop = true\n    num_edges_between_points = 9\n  []\n  [./tri]\n    type = XYDelaunayGenerator\n    boundary = 'poly1'\n#    refine_boundary = true\n    desired_area = 0.6\n    output_subdomain_name = 'tri'\n  []\n[]\n\nI used num_edges_between_points = 9 so 10 edges are generated on EVERY side.\nCan I modify (10, 10, 10) edges to (10, 3, 10) edges?\nIn other words, I want to make it\nfrom this\n\nto this\n\nFor your information, the reason why I want to modify is to stitch with another subdomain.\nIf I don't modify it, hanging nodes that cannot calculate physics in the normal FEM method are generated so that I want to avoid this situation.\nThank you.\nBest Regards,\nJeonghwan",
          "url": "https://github.com/idaholab/moose/discussions/24913",
          "updatedAt": "2023-07-12T05:15:23Z",
          "publishedAt": "2023-07-06T08:08:25Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUse two polyline MG, one for the 10 edges part and one for the single edge part, then stitch them\nThen triangulate.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24913#discussioncomment-6375699",
                  "updatedAt": "2023-07-06T15:39:58Z",
                  "publishedAt": "2023-07-06T15:39:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Hello,\nI am so sorry but could you please explain in more detail?\nI tried your suggestion but it failed.\nThings that I tried:\n\ntest/tests/meshgenerators/xy_delaunay_generator/xydelaunay_multiline.i\n\n\nI think the test file has problems, too\n\n\nI added one more line.\n\n  [line3]\n    type = PolyLineMeshGenerator\n    points = '0.0 1.0 0.0\n              0.0 0.0 0.0'\n#    loop = true\n  []\n\n  [outer_bdy]\n    type = StitchedMeshGenerator\n    inputs = \"line1 line2 line3\"\n    stitch_boundaries_pairs = '2 1;\n                               2 1'\n  []\n\nStitching was done successfully, but XYDelaunayG didn't work with this error.\n*** ERROR ***\nTriangulatorInterface does not support overlapping nodes found at (x,y,z)=(       0,        0,        0)\nStack frames: 15\n0: libMesh::print_trace(std::ostream&)\n1: libMesh::MacroFunctions::report_error(char const*, int, char const*, char const*, std::ostream&)\n2: libMesh::TriangulatorInterface::elems_to_segments()\n3: libMesh::Poly2TriTriangulator::triangulate()\n4: XYDelaunayGenerator::generate()\n5: MeshGenerator::generateInternal()\n6: MooseApp::executeMeshGenerators()\n7: Action::timedAct()\n8: ActionWarehouse::executeActionsWithAction(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)\n9: ActionWarehouse::executeAllActions()\n10: MooseApp::runInputFile()\n11: MooseApp::run()\n12: main\n13: __libc_start_main\n14: test9-opt() [0x402b30]\n[0] ../src/mesh/triangulator_interface.C, line 106, compiled Feb 17 2023 at 11:44:58\n\nJeonghwan",
                          "url": "https://github.com/idaholab/moose/discussions/24913#discussioncomment-6403994",
                          "updatedAt": "2023-07-10T12:31:06Z",
                          "publishedAt": "2023-07-10T12:31:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This doesnt work because you only stitch in two locations, but there are 3 connection points.\nYou need only 2 lines.\nOne that does the angle, and one that does the right edge.\nThen you stitch them in a single StitchMeshGenerator at 2 locations (with two stitch pairs)",
                          "url": "https://github.com/idaholab/moose/discussions/24913#discussioncomment-6406637",
                          "updatedAt": "2023-07-10T16:24:15Z",
                          "publishedAt": "2023-07-10T16:24:14Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Thank you so much!!",
                          "url": "https://github.com/idaholab/moose/discussions/24913#discussioncomment-6422864",
                          "updatedAt": "2023-07-12T05:15:22Z",
                          "publishedAt": "2023-07-12T05:15:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Which module should be used for creep calculation under the generalized plane strain assumption?",
          "author": {
            "login": "09liu"
          },
          "bodyText": "@GiudGiud Which module should be used for creep calculation under the generalized plane strain assumption?",
          "url": "https://github.com/idaholab/moose/discussions/24928",
          "updatedAt": "2023-07-12T03:05:52Z",
          "publishedAt": "2023-07-10T08:20:03Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@recuero",
                  "url": "https://github.com/idaholab/moose/discussions/24928#discussioncomment-6406662",
                  "updatedAt": "2023-07-10T16:26:55Z",
                  "publishedAt": "2023-07-10T16:26:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "For engineering scale creep using a traditional finite element approach, the module to use is Tensor Mechanics. There are tests that use generalized plane strain theory which you can augment with your creep modeling approach.\nFYI: I think you can model creep using the peridynamics module too.",
                          "url": "https://github.com/idaholab/moose/discussions/24928#discussioncomment-6406841",
                          "updatedAt": "2023-07-10T16:45:37Z",
                          "publishedAt": "2023-07-10T16:45:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "09liu"
                          },
                          "bodyText": "Thank you. I found that PowerLawCreepStressUpdate can perform creep calculations under generalized plane strain assumptions. I modeled this class and constructed new classes, successfully simulating the creep of the material I studied.",
                          "url": "https://github.com/idaholab/moose/discussions/24928#discussioncomment-6422229",
                          "updatedAt": "2023-07-12T03:05:53Z",
                          "publishedAt": "2023-07-12T03:05:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "June 2023 Newsletter",
          "author": {
            "login": "GiudGiud"
          },
          "bodyText": "The June 2023 MOOSE Newsletter has been released! A (brief) summary of the content is below:\n\nThe 2023 Training video is online! link\nRZ coordinates have been generalized to accept any axis, not just through the origin\nA new heat structure has been developed for 2D-3D coupling\nThe performance of several fluid properties has been improved\nProjections between FE families are now possible using a ProjectionAux\nSeveral libmesh and TIMPI improvements\nSeveral mesh generators are now more resilient to user input errors and can also generate distributed meshes",
          "url": "https://github.com/idaholab/moose/discussions/24952",
          "updatedAt": "2023-07-12T14:15:54Z",
          "publishedAt": "2023-07-12T01:04:08Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "TimePeriod in controls",
          "author": {
            "login": "jin0123456"
          },
          "bodyText": "Hello,\nI want to control the time range of BC active by means of TimePerod. The problem is I have a CavityPressure BC and I dont know how to write the Controls part in input file. Here is the BC part of my input file.\n[BCs]\n  #active = 'CavityPressure inside coolant_pressure pellet_bottom_disp'\n  [coolant_pressure]\n    type = Pressure\n    function = outer_pressure\n    boundary = outer\n    variable = disp_r\n  []\n  [inside]\n    type = Pressure\n    function = init_pressure\n    boundary = 'clad_inside fuel_outer'\n    variable = disp_r\n  []\n\n  [CavityPressure]\n    [cavity_pressure]\n      boundary = 'fuel_outer clad_inside'\n      initial_temperature = ${init_cavity}\n      temperature = ave_temp_clad_inside_top\n      material_input = inputmaterial \n      volume = volume_tol\n      initial_pressure = ${init_pressure} \n      R = 8.314472\n      output = ppress\n    []\n  []\n\n  [pellet_bottom_disp]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'pin_bottom'\n    value = 0.0\n    preset = true\n  []\n[]\n\nHere is the Controls part of my input file.\n[Controls]\n  [bccontrol]\n    type = TimePeriod\n    enable_objects = '::CavityPressure'\n    disable_objects = 'BCs::inside'\n    start_time = '0'\n    end_time = '38528676.0'\n    execute_on = 'initial timestep_begin'\n  []\n[]\n\nI dont know how to input enable_objects parameter. Hope to get some ideas.",
          "url": "https://github.com/idaholab/moose/discussions/24926",
          "updatedAt": "2023-07-11T20:17:24Z",
          "publishedAt": "2023-07-10T06:34:33Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "It could be:\n[Controls]\n  [bccontrol]\n    type = TimePeriod\n    enable_objects = 'CavityPressure::cavity_pressure'\n    disable_objects = 'BCs::inside'\n    start_time = '0'\n    end_time = '38528676.0'\n    execute_on = 'initial timestep_begin'\n  []\n[]\n\nHOWEVER, if the CavityPressure is not controllable, you ll have to work around this.\nYou can use:\n[Debug]\n  show_actions = true\n[]\n\nto see what the CavityPressure is doing, and get the names of the objects it can create, so you can Control them",
                  "url": "https://github.com/idaholab/moose/discussions/24926#discussioncomment-6406579",
                  "updatedAt": "2023-07-10T16:19:48Z",
                  "publishedAt": "2023-07-10T16:19:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "I did it first like you said,\n[Controls]\n  [bccontrol]\n    type = TimePeriod\n    enable_objects = 'CavityPressure::cavity_pressure'\n    disable_objects = 'BCs::inside'\n    start_time = '0'\n    end_time = '38528676.0'\n    execute_on = 'initial timestep_begin'\n  []\n[]\n\nThere was an error,\nsub0: *** ERROR ***\nsub0: The following error occurred in the object \"bccontrol\", of type \"TimePeriod\".\nsub0: \nsub0: The desired parameter 'CavityPressure::cavity_pressure/enable' was not located for the 'bccontrol' object, it either does not exist or has not been declared as controllable.\nsub0: \napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 50\n\nThen I used\n[Debug]\n  show_actions = true\n[]\n\nThe output is\nsub0: [DBG][ACT] TASK (               no_action) TYPE (                     EmptyAction) NAME (  CavityPressure) Memory usage 173MB\nsub0: [DBG][ACT] TASK (finish_input_file_output) TYPE (                     EmptyAction) NAME (  CavityPressure) Memory usage 173MB\nsub0: [DBG][ACT] TASK (             meta_action) TYPE (AddIterationCountPostprocessorsAction) NAME (           Debug) Memory usage 173MB\nsub0: [DBG][ACT] TASK (             meta_action) TYPE (     CommonTensorMechanicsAction) NAME (          Master) Memory usage 173MB\nsub0: [DBG][ACT] TASK (             meta_action) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 173MB\nsub0: [DBG][ACT] TASK (             meta_action) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 173MB\nsub0: [DBG][ACT] TASK (          ns_meta_action) TYPE (                     INSFVAction) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (           common_output) TYPE (              CommonOutputAction) NAME (         Outputs) Memory usage 173MB\nsub0: [DBG][ACT] TASK (       set_global_params) TYPE (              GlobalParamsAction) NAME (    GlobalParams) Memory usage 173MB\nsub0: [DBG][ACT] TASK ( setup_recover_file_base) TYPE (      SetupRecoverFileBaseAction) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (            temp) Memory usage 173MB\nsub0: [DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (      burnup_per) Memory usage 173MB\nsub0: [DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (        porosity) Memory usage 173MB\nsub0: [DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (  input_material) Memory usage 173MB\nsub0: [DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (             q_v) Memory usage 173MB\nsub0: [DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (    fission_rate) Memory usage 173MB\nsub0: [DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (              setup_mesh) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 173MB\nsub0: [DBG][ACT] TASK (        add_geometric_rm) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 173MB\nsub0: [DBG][ACT] TASK (        add_geometric_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (THM:add_relationship_managers) TYPE (THMAddRelationshipManagersAction) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (THM:output_vector_velocity) TYPE (   THMOutputVectorVelocityAction) NAME (         Outputs) Memory usage 173MB\nsub0: [DBG][ACT] TASK (     THM:init_simulation) TYPE (         THMInitSimulationAction) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (          THM:build_mesh) TYPE (              THMBuildMeshAction) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (create_added_mesh_generators) TYPE (       CreateAddedMeshGenerators) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (   append_mesh_generator) TYPE (                   ContactAction) NAME (     gap_contact) Memory usage 173MB\nsub0: [DBG][ACT] TASK (   append_mesh_generator) TYPE (                   ContactAction) NAME (         element) Memory usage 173MB\nsub0: [DBG][ACT] TASK ( execute_mesh_generators) TYPE (           ExecuteMeshGenerators) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (       recover_meta_data) TYPE (      SetupRecoverFileBaseAction) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (           set_mesh_base) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 173MB\nsub0: [DBG][ACT] TASK (     attach_geometric_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 173MB\nsub0: [DBG][ACT] TASK (               init_mesh) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 173MB\nsub0: [DBG][ACT] TASK (            prepare_mesh) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 223MB\nsub0: [DBG][ACT] TASK (     uniform_refine_mesh) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 249MB\nsub0: [DBG][ACT] TASK (     setup_mesh_complete) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 249MB\nsub0: [DBG][ACT] TASK (     setup_mesh_complete) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 249MB\nsub0: [DBG][ACT] TASK (     setup_mesh_complete) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 249MB\nsub0: [DBG][ACT] TASK (   determine_system_type) TYPE (      CreateProblemDefaultAction) NAME (                ) Memory usage 249MB\nsub0: [DBG][ACT] TASK (  create_problem_default) TYPE (      CreateProblemDefaultAction) NAME (                ) Memory usage 249MB\nsub0: [DBG][ACT] TASK (validate_coordinate_systems) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 254MB\nsub0: [DBG][ACT] TASK (validate_coordinate_systems) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 254MB\nsub0: [DBG][ACT] TASK (       setup_executioner) TYPE (         CreateExecutionerAction) NAME (     Executioner) Memory usage 254MB\nsub0: [DBG][ACT] TASK (            add_executor) TYPE (               AddExecutorAction) NAME (                ) Memory usage 254MB\nsub0: [DBG][ACT] TASK (   check_integrity_early) TYPE (            CheckIntegrityAction) NAME (                ) Memory usage 254MB\nsub0: [DBG][ACT] TASK (  init_displaced_problem) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 254MB\nsub0: [DBG][ACT] TASK (          THM:setup_mesh) TYPE (              THMSetupMeshAction) NAME (                ) Memory usage 259MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (           DisplayGhostingAction) NAME (            Mesh) Memory usage 259MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (            AddAuxVariableAction) NAME (            temp) Memory usage 259MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (            AddAuxVariableAction) NAME (      burnup_per) Memory usage 259MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (            AddAuxVariableAction) NAME (        porosity) Memory usage 259MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (            AddAuxVariableAction) NAME (  input_material) Memory usage 259MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (            AddAuxVariableAction) NAME (             q_v) Memory usage 259MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (            AddAuxVariableAction) NAME (    fission_rate) Memory usage 259MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (                   ContactAction) NAME (     gap_contact) Memory usage 260MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (                   ContactAction) NAME (         element) Memory usage 260MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 260MB\nsub0: [DBG][ACT] TASK (        add_aux_variable) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 260MB\nsub0: [DBG][ACT] TASK (            add_variable) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 260MB\nsub0: [DBG][ACT] TASK (            add_variable) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 260MB\nsub0: [DBG][ACT] TASK (add_external_aux_variables) TYPE (    AddExternalAuxVariableAction) NAME (                ) Memory usage 260MB\nsub0: [DBG][ACT] TASK (     add_mortar_variable) TYPE (                   ContactAction) NAME (     gap_contact) Memory usage 260MB\nsub0: [DBG][ACT] TASK (     add_mortar_variable) TYPE (                   ContactAction) NAME (         element) Memory usage 260MB\nsub0: [DBG][ACT] TASK (add_contact_aux_variable) TYPE (                   ContactAction) NAME (     gap_contact) Memory usage 260MB\nsub0: [DBG][ACT] TASK (add_contact_aux_variable) TYPE (                   ContactAction) NAME (         element) Memory usage 261MB\nsub0: [DBG][ACT] TASK (        setup_quadrature) TYPE (           SetupQuadratureAction) NAME (                ) Memory usage 261MB\nsub0: [DBG][ACT] TASK (        setup_quadrature) TYPE (        THMSetupQuadratureAction) NAME (                ) Memory usage 261MB\nsub0: [DBG][ACT] TASK (            add_function) TYPE (               AddFunctionAction) NAME (         q_v_fun) Memory usage 261MB\nsub0: [DBG][ACT] TASK (            add_function) TYPE (               AddFunctionAction) NAME (    neu_flux_fun) Memory usage 261MB\nsub0: [DBG][ACT] TASK (            add_function) TYPE (               AddFunctionAction) NAME (  outer_pressure) Memory usage 261MB\nsub0: [DBG][ACT] TASK (            add_function) TYPE (               AddFunctionAction) NAME (   init_pressure) Memory usage 261MB\nsub0: [DBG][ACT] TASK (     THM:init_components) TYPE (         THMInitComponentsAction) NAME (                ) Memory usage 261MB\nsub0: [DBG][ACT] TASK (      THM:identify_loops) TYPE (             IdentifyLoopsAction) NAME (                ) Memory usage 261MB\nsub0: [DBG][ACT] TASK (        THM:debug_action) TYPE (                  THMDebugAction) NAME (           Debug) Memory usage 261MB\nsub0: [DBG][ACT] TASK (     THM:integrity_check) TYPE (            IntegrityCheckAction) NAME (                ) Memory usage 261MB\nsub0: [DBG][ACT] TASK (       THM:add_variables) TYPE (           THMAddVariablesAction) NAME (                ) Memory usage 261MB\nsub0: [DBG][ACT] TASK (         add_user_object) TYPE (           DisplayGhostingAction) NAME (            Mesh) Memory usage 261MB\nsub0: [DBG][ACT] TASK (         add_user_object) TYPE (                   ContactAction) NAME (     gap_contact) Memory usage 261MB\nsub0: [DBG][ACT] TASK (         add_user_object) TYPE (                   ContactAction) NAME (         element) Memory usage 261MB\nsub0: [DBG][ACT] TASK (         add_user_object) TYPE (          CavityPressureUOAction) NAME ( cavity_pressure) Memory usage 261MB\nsub0: [DBG][ACT] TASK (         add_user_object) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 261MB\nsub0: [DBG][ACT] TASK (         add_user_object) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 261MB\nsub0: [DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (      temp_moose) Memory usage 261MB\nsub0: [DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (burnup_per_moose) Memory usage 261MB\nsub0: [DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (  porosity_moose) Memory usage 261MB\nsub0: [DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (input_material_moose) Memory usage 261MB\nsub0: [DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (       q_v_moose) Memory usage 262MB\nsub0: [DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (fission_rate_moose) Memory usage 262MB\nsub0: [DBG][ACT] TASK (          add_constraint) TYPE (                   ContactAction) NAME (     gap_contact) Memory usage 262MB\nsub0: [DBG][ACT] TASK (          add_constraint) TYPE (                   ContactAction) NAME (         element) Memory usage 271MB\nsub0: [DBG][ACT] TASK (     add_preconditioning) TYPE (       SetupPreconditionerAction) NAME (             smp) Memory usage 272MB\nsub0: [DBG][ACT] TASK (           ready_to_init) TYPE (                     EmptyAction) NAME (  CavityPressure) Memory usage 272MB\nsub0: [DBG][ACT] TASK (           setup_dampers) TYPE (              SetupDampersAction) NAME (                ) Memory usage 272MB\nsub0: [DBG][ACT] TASK (    setup_residual_debug) TYPE (        SetupResidualDebugAction) NAME (           Debug) Memory usage 272MB\nsub0: [DBG][ACT] TASK (         copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (                ) Memory usage 272MB\nsub0: [DBG][ACT] TASK (     copy_nodal_aux_vars) TYPE (             CopyNodalVarsAction) NAME (            temp) Memory usage 272MB\nsub0: [DBG][ACT] TASK (     copy_nodal_aux_vars) TYPE (             CopyNodalVarsAction) NAME (      burnup_per) Memory usage 272MB\nsub0: [DBG][ACT] TASK (     copy_nodal_aux_vars) TYPE (             CopyNodalVarsAction) NAME (        porosity) Memory usage 272MB\nsub0: [DBG][ACT] TASK (     copy_nodal_aux_vars) TYPE (             CopyNodalVarsAction) NAME (  input_material) Memory usage 272MB\nsub0: [DBG][ACT] TASK (     copy_nodal_aux_vars) TYPE (             CopyNodalVarsAction) NAME (             q_v) Memory usage 272MB\nsub0: [DBG][ACT] TASK (     copy_nodal_aux_vars) TYPE (             CopyNodalVarsAction) NAME (    fission_rate) Memory usage 272MB\nsub0: [DBG][ACT] TASK (     copy_nodal_aux_vars) TYPE (             CopyNodalVarsAction) NAME (                ) Memory usage 272MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (     UO2_density) Memory usage 272MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (      CZ_density) Memory usage 272MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (UO2_elasticity_tensor) Memory usage 272MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (UO2_elasticity_material) Memory usage 272MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (Zr4_elasticity_tensor) Memory usage 272MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (Zr4_elasticity_material) Memory usage 272MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (UO2_thermal_expansion) Memory usage 272MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (Zr4_thermal_expansion) Memory usage 273MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (CZ_irridiation_growth) Memory usage 273MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (CZ_radial_return_stress) Memory usage 273MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (CZ_power_law_creep) Memory usage 273MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (    small_stress) Memory usage 273MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 273MB\nsub0: [DBG][ACT] TASK (            add_material) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 274MB\nsub0: [DBG][ACT] TASK (add_master_action_material) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 274MB\nsub0: [DBG][ACT] TASK (add_master_action_material) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 274MB\nsub0: [DBG][ACT] TASK (THM:add_component_moose_objects) TYPE (  AddComponentMooseObjectsAction) NAME (                ) Memory usage 274MB\nsub0: [DBG][ACT] TASK (add_output_aux_variables) TYPE (            MaterialOutputAction) NAME (                ) Memory usage 274MB\nsub0: [DBG][ACT] TASK (              add_output) TYPE (                SetupDebugAction) NAME (           Debug) Memory usage 274MB\nsub0: [DBG][ACT] TASK (              add_output) TYPE (              CommonOutputAction) NAME (         Outputs) Memory usage 275MB\nsub0: [DBG][ACT] TASK (              add_output) TYPE (                 AddOutputAction) NAME (          exodus) Memory usage 275MB\nsub0: [DBG][ACT] TASK (              add_output) TYPE (                 AddOutputAction) NAME (         console) Memory usage 275MB\nsub0: [DBG][ACT] TASK (  auto_checkpoint_action) TYPE (            AutoCheckpointAction) NAME (                ) Memory usage 275MB\nsub0: [DBG][ACT] TASK (output_penetration_info_vars) TYPE (                   ContactAction) NAME (     gap_contact) Memory usage 275MB\nsub0: [DBG][ACT] TASK (output_penetration_info_vars) TYPE (                   ContactAction) NAME (         element) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (          CavityPressurePPAction) NAME ( cavity_pressure) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (          AddPostprocessorAction) NAME (           q_max) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (    PostprocessorAsControlAction) NAME (           q_max) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (          AddPostprocessorAction) NAME (     vol_fission) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (    PostprocessorAsControlAction) NAME (     vol_fission) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (          AddPostprocessorAction) NAME (   inputmaterial) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (    PostprocessorAsControlAction) NAME (   inputmaterial) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (          AddPostprocessorAction) NAME (ave_temp_clad_inside_top) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (    PostprocessorAsControlAction) NAME (ave_temp_clad_inside_top) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (          AddPostprocessorAction) NAME (      volume_tol) Memory usage 275MB\nsub0: [DBG][ACT] TASK (       add_postprocessor) TYPE (    PostprocessorAsControlAction) NAME (      volume_tol) Memory usage 275MB\nsub0: [DBG][ACT] TASK (              add_kernel) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 275MB\nsub0: [DBG][ACT] TASK (              add_kernel) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 276MB\nsub0: [DBG][ACT] TASK (        THM:setup_output) TYPE (            THMSetupOutputAction) NAME (         Outputs) Memory usage 276MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (           DisplayGhostingAction) NAME (            Mesh) Memory usage 276MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (           ElementIDOutputAction) NAME (            Mesh) Memory usage 276MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (                 AddKernelAction) NAME (  burnup_per_aux) Memory usage 276MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (                 AddKernelAction) NAME (        porosity) Memory usage 276MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (                 AddKernelAction) NAME ( gas_release_aux) Memory usage 276MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (                 AddKernelAction) NAME (         q_v_aux) Memory usage 276MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (                 AddKernelAction) NAME (fission_rate_aux) Memory usage 276MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (                   ContactAction) NAME (     gap_contact) Memory usage 276MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (                   ContactAction) NAME (         element) Memory usage 276MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 277MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 277MB\nsub0: [DBG][ACT] TASK (          add_aux_kernel) TYPE (            MaterialOutputAction) NAME (                ) Memory usage 277MB\nsub0: [DBG][ACT] TASK (                  add_bc) TYPE (                     AddBCAction) NAME (coolant_pressure) Memory usage 277MB\nsub0: [DBG][ACT] TASK (                  add_bc) TYPE (            CavityPressureAction) NAME ( cavity_pressure) Memory usage 277MB\nsub0: [DBG][ACT] TASK (                  add_bc) TYPE (                     AddBCAction) NAME (pellet_bottom_disp) Memory usage 277MB\nsub0: [DBG][ACT] TASK (       add_scalar_kernel) TYPE (           TensorMechanicsAction) NAME (            fuel) Memory usage 277MB\nsub0: [DBG][ACT] TASK (       add_scalar_kernel) TYPE (           TensorMechanicsAction) NAME (            clad) Memory usage 277MB\nsub0: [DBG][ACT] TASK (resolve_optional_materials) TYPE (ResolveOptionalMaterialPropertiesAction) NAME (                ) Memory usage 277MB\nsub0: [DBG][ACT] TASK (        add_algebraic_rm) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 277MB\nsub0: [DBG][ACT] TASK (        add_algebraic_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 277MB\nsub0: [DBG][ACT] TASK (         add_coupling_rm) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 277MB\nsub0: [DBG][ACT] TASK (         add_coupling_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 277MB\nsub0: [DBG][ACT] TASK (attach_geometric_rm_final) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 277MB\nsub0: [DBG][ACT] TASK (     attach_algebraic_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 277MB\nsub0: [DBG][ACT] TASK (      attach_coupling_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 277MB\nsub0: [DBG][ACT] TASK (  coupling_functor_check) TYPE (      CouplingFunctorCheckAction) NAME (coupling_functor_check) Memory usage 277MB\nsub0: [DBG][ACT] TASK (delete_remote_elements_after_late_geometric_ghosting) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 277MB\nsub0: [DBG][ACT] TASK (            init_problem) TYPE (               InitProblemAction) NAME (                ) Memory usage 277MB\nsub0: [DBG][ACT] TASK (            check_output) TYPE (               CheckOutputAction) NAME (                ) Memory usage 348MB\nsub0: [DBG][ACT] TASK (         check_integrity) TYPE (            CheckIntegrityAction) NAME (                ) Memory usage 348MB\nsub0: [DBG][ACT] TASK (THM:preconditioning_integrity_check) TYPE (THMPreconditioningIntegrityCheckAction) NAME (                ) Memory usage 348MB\nsub0: [DBG][ACT] TASK (THM:control_data_integrity_check) TYPE ( ControlDataIntegrityCheckAction) NAME (                ) Memory usage 348MB\nsub0: [DBG][ACT] TASK (THM:print_component_loops) TYPE (    THMPrintComponentLoopsAction) NAME (           Debug) Memory usage 348MB\nsub0: [DBG][ACT] Finished executing all actions with memory usage 348MB\n\nSo is the CavityPressure controllable? Can I use this method to change BC by time in the simulation? Or is there other way to get what I want?",
                          "url": "https://github.com/idaholab/moose/discussions/24926#discussioncomment-6413481",
                          "updatedAt": "2023-07-11T08:32:16Z",
                          "publishedAt": "2023-07-11T08:32:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no CavityPressure does not seem controllable\nhowever, the BC it creates is.\nTwo ways around:\n\nyou find the name of the CavityPressure created BC by looking at the code\nyou dont use CavityPressure and define everything manually (it s just a UO, a BC and a PP created by the action, I looked at it very fast though)",
                          "url": "https://github.com/idaholab/moose/discussions/24926#discussioncomment-6420239",
                          "updatedAt": "2023-07-11T20:17:25Z",
                          "publishedAt": "2023-07-11T20:17:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mesh Adaptivity and J2 Plasticity",
          "author": {
            "login": "patelrohan008"
          },
          "bodyText": "I stumbled across some discussions, link1 and link2 from 2021 which suggest an incompatibility between mesh adaptivity and plasticity. Is this still the case, and if so are there any recommendations for handling directed energy deposition problems which require plasticity in the material model?",
          "url": "https://github.com/idaholab/moose/discussions/24943",
          "updatedAt": "2023-07-10T23:52:59Z",
          "publishedAt": "2023-07-10T23:52:58Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "gcc optimization",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "Hi,\nSorry for asking a stupid question, but what is the default optimization flag for gnu9 gcc compiler? Is it -O or -O3 or -Ofast? And what is the reason for the particular default setting?\nThanks,\nOlle",
          "url": "https://github.com/idaholab/moose/discussions/24937",
          "updatedAt": "2023-07-10T22:11:23Z",
          "publishedAt": "2023-07-10T20:27:50Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "-O2\nThe main reason is legacy\nIt will take some libmesh work to get that upgraded and it's not clear how impactful it would be",
                  "url": "https://github.com/idaholab/moose/discussions/24937#discussioncomment-6409415",
                  "updatedAt": "2023-07-10T20:42:11Z",
                  "publishedAt": "2023-07-10T20:42:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "heinono1"
                          },
                          "bodyText": "OK. Thanks, Guillaume.",
                          "url": "https://github.com/idaholab/moose/discussions/24937#discussioncomment-6409940",
                          "updatedAt": "2023-07-10T22:11:24Z",
                          "publishedAt": "2023-07-10T22:11:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "is there the possibility of Arc_length method in moose ?",
          "author": {
            "login": "Ttw0626"
          },
          "bodyText": "Dear Moose's developers,\nI thought I am not deep familiar with moose,\n\nI wanna ask a short question, is there a specific module for Arc_length method instead of disp-control solver?\n\nif yes, could I study some examples ?\nIt is important for unloading process in damage.\nThanks,\nTAN",
          "url": "https://github.com/idaholab/moose/discussions/24924",
          "updatedAt": "2023-07-08T13:43:19Z",
          "publishedAt": "2023-07-08T13:43:18Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": []
          }
        }
      }
    ]
  }
}