{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNi0xOFQwMDo1NTozNS0wNjowMM4AUPqN"
    },
    "edges": [
      {
        "node": {
          "title": "Domain names lost with CombinerGenerator",
          "author": {
            "login": "adigc"
          },
          "bodyText": "Hello everyone,\nI have a similar problem with CombinerGenerator as described here: #20823\nSince the discussion is a year old, I am making a new one.\nI am trying to combine two meshes.\n\nMesh 1 : Read in from a .e file (block name : neck)\nMesh 2 : Generated from a GeneratedMeshGenerator (block id: 50)\n\nNow when I am trying to combine these two using CombinerGenerator, the block names and side set names of the second mesh in the inputs are lost.\nCase 1: neck, line\n  [cmbn]\n      type = CombinerGenerator\n      inputs = 'neck line'\n  [] \n\nOutput when running with --mesh-only option\n\nSince neck comes before the line, we can see from the output, the block name neck is preserved.\nCase 2: line, neck\n  [cmbn]\n      type = CombinerGenerator\n      inputs = 'line neck'\n  []\n\nOutput when running with --mesh-only option\n\nSince line comes before neck, we can see from the output, the block name neck is lost.  Similarly, node set names are also lost.\nI am attaching the above mentioned example here :\ncombiner_mesh_example.zip\nAny pointers on how to solve this will be helpful.\nThank you in advance.",
          "url": "https://github.com/idaholab/moose/discussions/24577",
          "updatedAt": "2023-06-24T19:48:01Z",
          "publishedAt": "2023-06-02T13:22:10Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you trying to stitch the meshes?\nOr just have them disconnected in the same simulation?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6071981",
                  "updatedAt": "2023-06-02T13:28:13Z",
                  "publishedAt": "2023-06-02T13:28:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "adigc"
                          },
                          "bodyText": "Hi @GiudGiud\nfor now disconnected, but in my upcoming investigations, I will have to connect their nodes with MPCs probably.",
                          "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6072020",
                          "updatedAt": "2023-06-02T13:31:24Z",
                          "publishedAt": "2023-06-02T13:31:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adigc"
                          },
                          "bodyText": "In the example I provided above, the two mehes overlap. But in a general case they do not.",
                          "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6072178",
                          "updatedAt": "2023-06-02T13:42:56Z",
                          "publishedAt": "2023-06-02T13:42:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We're not going to be able to patch this over the next 2 weeks because of the upcoming training.\nI would recommend you re-create the subdomains you need using other mesh generators, like the ParsedSubdomainGenerator",
                          "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6072786",
                          "updatedAt": "2023-06-02T14:31:14Z",
                          "publishedAt": "2023-06-02T14:31:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adigc"
                          },
                          "bodyText": "@GiudGiud thank you for the reply. I believe that I have found necessary changes to the code for this issue. Is it ok if I make a PR with these changes ?",
                          "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6163407",
                          "updatedAt": "2023-06-13T12:57:41Z",
                          "publishedAt": "2023-06-13T12:57:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "That\u2019s a good idea. We can take a look in a PR",
                          "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6163739",
                          "updatedAt": "2023-06-13T13:29:21Z",
                          "publishedAt": "2023-06-13T13:29:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MengnanLi91"
                  },
                  "bodyText": "I think this issue has already been fixed in #22838.  In your input file [line] doesn't have a proper block name, you will need to use another RenameBlockGenerator to provide a name for \"line\". Then the both subdomains should have names in the end.",
                  "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6256096",
                  "updatedAt": "2023-06-22T20:47:05Z",
                  "publishedAt": "2023-06-22T20:47:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "1D MESH subdomain/block creation",
          "author": {
            "login": "ananthanarasimhanj"
          },
          "bodyText": "I want to perform 1D heat conduction, and it involves two materials. I am now trying to create a mesh, and assign them as made of 2 blocks, to define material properties, and BC. I am not finding relevant guidance to assigning \"type\" for the 1D subdomains to create. Below is the incomplete code for MESH.\n[Mesh]\n  [generated]\n    type = GeneratedMeshGenerator\n    dim = 1\n    nx = 10\n    xmax = 1\n  []\n\n  [air_block]\n    type = \n    input = generated\n    block_id = 1\n    left = 0\n    right = 0.5\n  []\n\n  [water_block]\n    type = \n    input = generated\n    block_id = 2\n    left = 0.5\n    right = 1\n  []\n\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24791",
          "updatedAt": "2023-06-24T19:47:49Z",
          "publishedAt": "2023-06-22T02:17:14Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "You probably want type = SubdomainBoundingBoxGenerator",
                  "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6254578",
                  "updatedAt": "2023-06-22T17:27:05Z",
                  "publishedAt": "2023-06-22T17:27:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ananthanarasimhanj"
                          },
                          "bodyText": "I tried that and it shows error. I am attaching the input file, and the error too.\n[Mesh]\n[generated]\ntype = GeneratedMeshGenerator\ndim = 1\nnx = 10\nxmax = 1\nblock_id = 0\n[]\n[air_block]\ntype = SubdomainBoundingBoxGenerator\ninput = generated\nblock_id = 1\nbottom_left = '0 0 0'\ntop_right = '0.5 0 0'\n[]\n[water_block]\ntype = SubdomainBoundingBoxGenerator\ninput = generated\nblock_id = 2\nbottom_left = '0.5 0 0'\ntop_right = '1 0 0'\n[]\n[]\n[Variables]\n[T]\ninitial_condition = 300.0\n[]\n[]\n[Kernels]\n[heat_conduction]\ntype = HeatConduction\nvariable = T\n[]\n[time_derivative]\ntype = HeatConductionTimeDerivative\nvariable = T\n[]\n[]\n[Materials]\n[thermal1]\ntype = HeatConductionMaterial\nthermal_conductivity = 0.02587 # 20 degree Celcius, W/mK\nspecific_heat = 1006 # Cp, 20 degree Celcius, J/kgK\nblock = 1\n[]\n[thermal2]\ntype = HeatConductionMaterial\nthermal_conductivity = 0.598 # 20 degree Celcius, W/mK\nspecific_heat = 4150 # Cv, 20 degree Celcius, J/kgK\nblock = 2\n[]\n[density1]\ntype = GenericConstantMaterial\nprop_names = 'density'\nprop_values = 1.204 # 20 degree Celcius kg/m3\nblock = 1\n[]\n[density2]\ntype = GenericConstantMaterial\nprop_names = 'density'\nprop_values = 998.19 # 20 degree Celcius kg/m3\nblock = 2\n[]\n[]\n[BCs]\n[t_left]\ntype = DirichletBC\nvariable = T\nvalue = 373.15\nboundary = 'left'\nblock = 1\n[]\n[t_right]\ntype = FunctionNeumannBC\nvariable = T\nfunction = 0\nboundary = 'right'\nblock = 2\n[]\n[]\n[Executioner]\ntype = Transient\nend_time = 4\ndt = 1e-3\n[]\n[VectorPostprocessors]\n[t_sampler]\ntype = LineValueSampler\nvariable = T\nstart_point = '0 0 0'\nend_point = '1 0 0'\nnum_points = 20\nsort_by = x\n[]\n[]\n[Outputs]\nexodus = true\n[csv]\ntype = CSV\nfile_base = hc3_out\nexecute_on = final\n[]\n[]\n*** ERROR ***\nYour MeshGenerator tree contains multiple possible generator outputs :\n\"water_block and one or more of the following from an independent set: \"air_block\"\nThis may be due to a missing dependency or may be intentional. Please either\n\ncheck that all the mesh generators are connected as a tree and culminate in a single final mesh. Having one wrong 'input=mg' parameter is the most common error\nadd additional dependencies to remove the ambiguity if you are using a user-built MeshGenerator\nif you intend to execute a subset of the defined generators (uncommon), select the final MeshGenerator in the [Mesh] block with the \"final_generator\" parameter.",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6254993",
                          "updatedAt": "2023-06-22T18:24:39Z",
                          "publishedAt": "2023-06-22T18:24:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "try\n[water_block]\ntype = SubdomainBoundingBoxGenerator\ninput = air_block\nblock_id = 2\nbottom_left = '0.5 0 0'\ntop_right = '1 0 0'\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6255024",
                          "updatedAt": "2023-06-22T18:29:31Z",
                          "publishedAt": "2023-06-22T18:29:31Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ananthanarasimhanj"
                          },
                          "bodyText": "If the input is air_block, then the coordinates I have mentioned for water_block are outside air_block. Is that fine? I tried this, and I am getting the following error.\n*** ERROR ***\n/home/ananth/projects/hc/hc1/hc3.i:12: unused parameter 'Mesh/generated/block_id'\n/home/ananth/projects/hc/hc1/hc3.i:90: unused parameter 'BCs/t_left/block'\n/home/ananth/projects/hc/hc1/hc3.i:98: unused parameter 'BCs/t_right/block'\nbelow snapshot shows what I want to do.",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6255088",
                          "updatedAt": "2023-06-22T18:37:37Z",
                          "publishedAt": "2023-06-22T18:37:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "These unused parameter errors must be addressed.\nBoundary conditioons apply on boundaries not blocks.\nAnd one of the mesh parameters is wrong too. Please check the object documentation",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6255108",
                          "updatedAt": "2023-06-22T18:40:01Z",
                          "publishedAt": "2023-06-22T18:40:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ananthanarasimhanj"
                          },
                          "bodyText": "Sure. Thanks for the help.",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6255144",
                          "updatedAt": "2023-06-22T18:44:07Z",
                          "publishedAt": "2023-06-22T18:44:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ananthanarasimhanj"
                          },
                          "bodyText": "I tried below code, and it seems working.\n[Mesh]\n  [air_block]\n    type = GeneratedMeshGenerator\n    dim = 1\n    nx = 10\n    xmax = 1\n  []\n\n  [water_block]\n    type = SubdomainBoundingBoxGenerator\n    input = air_block\n    block_id = 1\n    bottom_left = '0.5 0 0'\n    top_right = '1 0 0'\n  []\n[]\n\n[Variables]\n  [T]\n    initial_condition = 300.0\n  []\n[]\n\n[Kernels]\n  [heat_conduction]\n    type = HeatConduction\n    variable = T\n  []\n\n  [time_derivative]\n    type = HeatConductionTimeDerivative\n    variable = T\n  []\n\n[]\n\n[Materials]\n  [thermal1]\n    type = HeatConductionMaterial\n    thermal_conductivity = 0.02587 # 20 degree Celcius, W/mK\n    specific_heat = 1006 # Cp, 20 degree Celcius, J/kgK\n    block = 0\n  []\n\n  [thermal2]\n    type = HeatConductionMaterial\n    thermal_conductivity = 0.598 # 20 degree Celcius, W/mK\n    specific_heat = 4150 # Cv, 20 degree Celcius, J/kgK\n    block = 1\n  []\n\n\n  [density1]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = 1.204 # 20 degree Celcius kg/m3\n    block = 0\n  []\n\n  [density2]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = 998.19 # 20 degree Celcius kg/m3\n    block = 1\n  []\n\n\n[]\n\n[BCs]\n  [t_left]\n    type = DirichletBC\n    variable = T\n    value = 373.15\n    boundary = 'left'\n  []\n\n  [t_right]\n    type = FunctionNeumannBC\n    variable = T\n    function = 0\n    boundary = 'right'\n  []\n\n\n \n[]\n\n[Executioner]\n  type = Transient\n  end_time = 4\n  dt = 1e-3\n[]\n\n[VectorPostprocessors]\n  [t_sampler]\n    type = LineValueSampler\n    variable = T\n    start_point = '0 0 0'\n    end_point = '1 0 0'\n    num_points = 20\n    sort_by = x\n  []\n[]\n\n[Outputs]\n  exodus = true\n  [csv]\n    type = CSV\n    file_base = hc3_out\n    execute_on = final\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6255205",
                          "updatedAt": "2023-06-22T18:52:24Z",
                          "publishedAt": "2023-06-22T18:51:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Has stitched mesh syntax changed?  Is it compatible with increase AD container size?",
          "author": {
            "login": "EdSheltonUKAEA"
          },
          "bodyText": "I'm sure that a few weeks ago I was running models OK with the stitched mesh given below:\n\n[Mesh]\n[01] # Regular mesh at surface\ntype = GeneratedMeshGenerator\ndim = 1\nxmin = 0 # m\nxmax = 5e-8 # m\nbias_x = 1\nnx = 100 # Element size = 5e-10 m\n[]\n[02] # Biased mesh (for implantation and diffusion)\ntype = GeneratedMeshGenerator\ndim = 1\nxmin = 5e-8 # m\nxmax = 1e-5 # m\nbias_x = 1.111676\nnx = 73 # First element 4.9e-10 m, last element = 1e-6 m\n[]\n[03] # Regular mesh to 0.2 mm\ntype = GeneratedMeshGenerator\ndim = 1\nxmin = 1e-5 # m\nxmax = 2e-4 # m\nbias_x = 1 # m\nnx = 190 # Element size = 1e-6 m\n[]\n[Mesh_stitcher]\ntype = StitchedMeshGenerator\ninputs = '01 02 03'\nstitch_boundaries_pairs = 'right left; right left'\n[]\n[]\n\nI'm trying to run it again now, but get error messages:\n\nIn UnstructuredMesh::stitch_meshes:\nThis mesh has 1 nodes on boundary 1.\nOther mesh has 2 nodes on boundary 2.\nMinimum edge length on both surfaces is 5e-10.\nIn UnstructuredMesh::stitch_meshes:\nFound 1 matching nodes.\n*** ERROR ***\n/home/eshelton/projects/red-kite/problems/HD_3tr_oc616_Ph1Imp_Model.i:38: (Mesh/Mesh_stitcher/stitch_boundaries_pairs):\nBoundary right doesn't exist on the first mesh in Mesh_stitcher\nBoundary names that do exist:\nID : Name\n0 : left\n2 : left\n\nI ran a MOOSE update yesterday.  Has something changed with the StitchedMeshGenerator syntax in the last few weeks which means my old code doesn't work any more.\nThe other thing that might be different is that in the update I needed to increase AD container size to resolve another error message cause by an increase in number of variables.  I ran this line of code before compiling MOOSE.\n\n./configure --with-derivative-size=600 --with-ad-indexing-type=global\n\nCould this have upset the mesh stitcher?",
          "url": "https://github.com/idaholab/moose/discussions/24744",
          "updatedAt": "2023-06-21T14:57:31Z",
          "publishedAt": "2023-06-20T14:31:04Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes it has changed.\nIt used to merge sidesets with the same ids. It does not do it anymore.\nIf you want the previous behavior, please pass as an additional parameter\nprevent_boundary_ids_overlap = false\nThe AD derivative size is a separate topic\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24744#discussioncomment-6231647",
                  "updatedAt": "2023-06-20T14:54:46Z",
                  "publishedAt": "2023-06-20T14:54:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "That's worked great thanks!\nBut has this also changed something with how the mesh is saved in the an ExodusII ouput file?\nWhen I try to apply the mesh and variable values from the final time step in a subsequent phase of analysis, I get this error:\n\nTime Step 0, time = 0\nlibMesh terminating:\nError creating ExodusII/Nemesis mesh file.\n[0] ../src/mesh/exodusII_io_helper.C, line 2299, compiled May 15 2023 at 22:49:10\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n\nIs there a workaround for this?  Or is it some other problem?\nThis is how I import the mesh from the previous model phases.  It used to work before I did the recent MOOSE update.\n\n[Mesh]\ntype = FileMesh\nfile = Ph1Imp_out.e\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24744#discussioncomment-6242366",
                          "updatedAt": "2023-06-21T14:11:00Z",
                          "publishedAt": "2023-06-21T14:01:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nNo that part has not changed.\nIt seems the error is coming from the \"creation\" of a new output exodus file.\nCan you try silencing the Outputs to exodus for now?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24744#discussioncomment-6242840",
                          "updatedAt": "2023-06-21T14:45:23Z",
                          "publishedAt": "2023-06-21T14:45:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Ah - looking at that has fixed it.  Because of some updates to my code I was trying to output to an Exodus file with the same name as I was importing from.  Now I've fixed that - it's working!\nCompletely my error!\nMany thanks for this and the fix to original query.",
                          "url": "https://github.com/idaholab/moose/discussions/24744#discussioncomment-6242891",
                          "updatedAt": "2023-06-21T14:50:28Z",
                          "publishedAt": "2023-06-21T14:50:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Query related to heat conduction time derivative",
          "author": {
            "login": "deepakbiitk"
          },
          "bodyText": "Hi all,\nI am solving a transient heat equation, looking through the warning of HeatConductionTimeDerivative (https://mooseframework.inl.gov/source/kernels/HeatConductionTimeDerivative.html). Do it mean it creates a lumped matrix?\nThanks,\nDeepak",
          "url": "https://github.com/idaholab/moose/discussions/24746",
          "updatedAt": "2023-06-20T23:16:48Z",
          "publishedAt": "2023-06-20T18:14:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The warning is because this kernel is missing off-diagonal terms for the Jacobian",
                  "url": "https://github.com/idaholab/moose/discussions/24746#discussioncomment-6235802",
                  "updatedAt": "2023-06-20T22:46:19Z",
                  "publishedAt": "2023-06-20T22:46:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "add a tangential force BC",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "so I have a inclined boundary and I want to enforce both normal and tangential force on that boundary, there is Pressure to enforece normal one, but the tangential need some extra work.\n\nI would expect I just need to modifiy some code in Pressure BC",
          "url": "https://github.com/idaholab/moose/discussions/24726",
          "updatedAt": "2023-06-20T20:40:21Z",
          "publishedAt": "2023-06-18T12:47:09Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lyyc199586"
                  },
                  "bodyText": "@GiudGiud",
                  "url": "https://github.com/idaholab/moose/discussions/24726#discussioncomment-6209322",
                  "updatedAt": "2023-06-18T12:47:32Z",
                  "publishedAt": "2023-06-18T12:47:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@hugary1995  do you want to add to what you explained here to another OP on a related topic\n#23377 (comment)\nI dont know if there's been additional developments on this over the last 4 months",
                          "url": "https://github.com/idaholab/moose/discussions/24726#discussioncomment-6210360",
                          "updatedAt": "2023-06-18T15:19:22Z",
                          "publishedAt": "2023-06-18T15:19:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Can you be more specific about what issue you are running into while implementing this BC? If you are just requesting a new feature, please open an issue.",
                          "url": "https://github.com/idaholab/moose/discussions/24726#discussioncomment-6212856",
                          "updatedAt": "2023-06-18T22:30:51Z",
                          "publishedAt": "2023-06-18T22:30:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lyyc199586"
                  },
                  "bodyText": "I opend an issue about it #24743",
                  "url": "https://github.com/idaholab/moose/discussions/24726#discussioncomment-6235043",
                  "updatedAt": "2023-06-20T20:40:22Z",
                  "publishedAt": "2023-06-20T20:40:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Operand Error in Custom BC computeQpResidual",
          "author": {
            "login": "smpeyres"
          },
          "bodyText": "I am trying to write a custom boundary condition for Zapdos that allows a user-prescribed flux in SI or similar units and is acceptable with the log-molar format used by the application.\nFrom my work trying to move from strong to weak form, here's what I came up with mathematically (may not show up well in light mode):\n\nI tried to implement this in a .C and .h file, respectively. However, when I try to compile, it doesn't seem to like my usuage of the - sign between the diffusion term and the flux term:\n/home/smpeyres_linux/projects/sean-zapdos/src/bcs/LogDiffusionFluxBC.C: In member function 'virtual ADReal LogDiffusionFluxBC::computeQpResidual()':\n/home/smpeyres_linux/projects/sean-zapdos/src/bcs/LogDiffusionFluxBC.C:47:50: error: no match for 'operator-' (operand types are 'libMesh::CompareTypes<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>'} and 'libMesh::boostcopy::enable_if_c<true, libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> > >::type' {aka 'libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >'})\n\n   47 |          6.022e23 * _normals[_qp] * _grad_u[_qp] - _normals[_qp] * _value;\n      |                                         `\n\nI attached the .C, .h, and full error message in single zipped file.\nOperandError_BC_Zapdos.zip\nAny advice or suggestions? Thank you!\nTagging the Zapdos experts: @cticenhour and @lindsayad",
          "url": "https://github.com/idaholab/moose/discussions/24576",
          "updatedAt": "2023-06-20T04:22:44Z",
          "publishedAt": "2023-06-02T13:18:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nfor 'operator-' (\n\noperand types are 'libMesh::CompareTypes<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>'} and \n\n'libMesh::boostcopy::enable_if_c<true, libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> > >::type' {aka 'libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >'})\n\nThis means you are trying to substract a scalar (first one) from a vector\n_normals[_qp] * _grad_u[_qp] is a scalar because of the dot product\n_normals[_qp] * _value is a vector as the product of a vector times a scalar\nwhat are you really trying to compute?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6072039",
                  "updatedAt": "2023-06-02T13:35:26Z",
                  "publishedAt": "2023-06-02T13:32:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Since Gamma is a vector it seems like what you want is for _value to be a vector",
                  "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6092125",
                  "updatedAt": "2023-06-05T15:55:36Z",
                  "publishedAt": "2023-06-05T15:55:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "smpeyres"
                          },
                          "bodyText": "That's what I am thinking too. From the MOOSE framework I see \"ADVectorFunctionDirichletBC\" and \"ADVectorFunctionNeumannBC\". Should I try implementing something like this, and have a \"flux\" function prescribed later in the input file? Or is there something potentially simpler?",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6154782",
                          "updatedAt": "2023-06-12T16:58:13Z",
                          "publishedAt": "2023-06-12T16:58:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Can you just directly use ADVectorFunctionNeumannBC?",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6155427",
                          "updatedAt": "2023-06-12T18:12:58Z",
                          "publishedAt": "2023-06-12T18:12:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpeyres"
                          },
                          "bodyText": "I would, but I am not confident that it would be compatible with the log densities, which have both the scalar value and gradient of the density in the weak form...",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6155876",
                          "updatedAt": "2023-06-12T19:05:23Z",
                          "publishedAt": "2023-06-12T19:05:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "then it sounds like you should write your own object",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6156003",
                          "updatedAt": "2023-06-12T19:22:20Z",
                          "publishedAt": "2023-06-12T19:22:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpeyres"
                          },
                          "bodyText": "Should I write it with  \"ADVectorFunctionDirichletBC\" and \"ADVectorFunctionNeumannBC\" as templates, or is there another BC in some module that would be more fitting?",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6156225",
                          "updatedAt": "2023-06-12T19:54:37Z",
                          "publishedAt": "2023-06-12T19:54:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Seems like Neumann is a pretty good fit as you want to prescribe a flux",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6156358",
                          "updatedAt": "2023-06-12T20:12:27Z",
                          "publishedAt": "2023-06-12T20:12:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpeyres"
                          },
                          "bodyText": "Error2_LogDiffusionFluxBC.zip\nI attempted to follow what the Neumann BC was doing, but I got two(?) errors. The first one, regarding '{' might be a consequence of the other error; I don't see anything immediately wrong with my brackets. The other error is again pointing to my computeQpResidual, and doesn't seem to like my exponential function. Any advice? Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6164102",
                          "updatedAt": "2023-06-13T14:02:42Z",
                          "publishedAt": "2023-06-13T14:02:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "has a quick look:\n    _function_z(getFunction(\"function_z\")),\n{ \n\nneeds to become\n    _function_z(getFunction(\"function_z\"))\n{",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6164278",
                          "updatedAt": "2023-06-13T14:20:30Z",
                          "publishedAt": "2023-06-13T14:20:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m not so sure about your computeQpResidual either, shouldnt the function be multiplied by the test function?",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6164302",
                          "updatedAt": "2023-06-13T14:23:08Z",
                          "publishedAt": "2023-06-13T14:23:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Yea your second term is a vector and needs to wind up being a scalar, e.g. just as @GiudGiud suggested you need to multiply by the test function.\nI am a little concerned about the boundary condition you're imposing. When integrating by parts and looking at the result, it seems like you are imposing for your boundary condition:\nflux = some-implicit-diffusive-flux + user-provided-flux",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6165280",
                          "updatedAt": "2023-06-13T15:49:09Z",
                          "publishedAt": "2023-06-13T15:49:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stress interpolation",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "What methods are available in MOOSE to interpolate stress (or any qp quantity) over the element? Interested in on-the-fly evaluation and saving to the mesh file for postprocessing.",
          "url": "https://github.com/idaholab/moose/discussions/24713",
          "updatedAt": "2023-06-24T19:48:22Z",
          "publishedAt": "2023-06-15T22:49:43Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@jessecarterMOOSE  you could use postprocessors such as the ElementAverageValue, that can average the stress over qp\nsee example here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/CPDamage/damage_growth.i\npostprocessors are evaluated on the fly and can be used to change, for example, the behavior of a material.",
                  "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6209707",
                  "updatedAt": "2023-06-18T13:17:37Z",
                  "publishedAt": "2023-06-18T13:17:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Need to keep a little more fidelity than that.",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6211696",
                          "updatedAt": "2023-06-18T18:48:36Z",
                          "publishedAt": "2023-06-18T18:48:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "by interpret, are you ok with just outputting?\nYou can output element averages with the https://mooseframework.inl.gov/docs//site/source/auxkernels/MaterialRealAux.html\nif you select a different FE family (still elemental) or order, you can get a closer projection",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6211741",
                          "updatedAt": "2023-06-18T18:56:32Z",
                          "publishedAt": "2023-06-18T18:56:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "Guess that should have said \"interpolate\" across the element. Monomials are only approximate, right? Is it least squares fitting? Can the nonlinear variable shape functions be used somehow?\nThen what happens when these discontinuous elemental variables get written to the Exodus file? Is there a different mesh format that will save the raw qp values?\nJust outputting for each element would be useful too for debugging (something like an Abaqus report file)",
                  "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6212171",
                  "updatedAt": "2023-06-18T20:13:34Z",
                  "publishedAt": "2023-06-18T20:13:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm not sure it will let you but if you use the MaterialXXXAux with a different shape function it will do a projection in the backend which amounts to least square fitting. You can look in AuxKernel.C at AuxKernelTempl<ComputeValueType>::compute() to see what it does.\nIt calculates the value of the auxkernel at each qp then tries to fit the auxvariable to those values.\nIt wont save Qp values.\nI dont think we ever save Qp values. We save DOF values.\nIf you want Qp values your best bet is to modify this VPP to do Qps instead of elements, and for tensor material properties instead of Real ones\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/MaterialVectorPostprocessor.html",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6212714",
                          "updatedAt": "2023-06-18T21:59:14Z",
                          "publishedAt": "2023-06-18T21:59:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "How does it reconcile the different nodal values computed by neighboring elements?",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6224177",
                          "updatedAt": "2023-06-19T23:12:56Z",
                          "publishedAt": "2023-06-19T23:12:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "We have this nodal patch recovery system for this exact purpose. It \"interpolates\" over the element (more precisely over a patch of neighboring elements). I am again responsible for the lack of documentation on this :/",
                  "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6212875",
                  "updatedAt": "2023-06-18T22:34:19Z",
                  "publishedAt": "2023-06-18T22:34:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "@hugary1995 this? https://mooseframework.inl.gov/help/finite_element_concepts/nodal_patch_recovery.html",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6213008",
                          "updatedAt": "2023-06-18T23:10:03Z",
                          "publishedAt": "2023-06-18T23:10:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "That's the theory, yes. The new system consists of two types of objects:\n\nNodalPatchRecoveryBase derived userobjects, e.g., NodalPatchRecoveryMaterialProperty, which construct the patch for least squares fitting.\nA \"driver\" object that actually solves the least squares problem and performs the interpolation. See for example NodalPatchRecoveryAux. More specifically, the interpolation happens on this line: https://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/src/auxkernels/NodalPatchRecoveryAux.C#L57, note that *_current_node can be replaced with any point inside the patch (the current element and its point neighbors) to interpolate the property.",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6213083",
                          "updatedAt": "2023-06-18T23:26:45Z",
                          "publishedAt": "2023-06-18T23:26:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Radiation and Convection Losses",
          "author": {
            "login": "nourriahi"
          },
          "bodyText": "Hello everyone,\nI am trying to model heat conduction using a laser source at the top, as far this is working, I wanted to include convection and radiation losses on the top to account for laser energy losses. I was wondering if moose has developed something to take this into account since I did not find anything so far?\nThanks\nNour",
          "url": "https://github.com/idaholab/moose/discussions/24729",
          "updatedAt": "2023-06-24T19:47:22Z",
          "publishedAt": "2023-06-19T14:29:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can look at adding terms to the boundary condition on top. See\nhttps://mooseframework.inl.gov/source/bcs/ADRadiativeHeatFluxBC.html\nhttps://mooseframework.inl.gov/source/bcs/ADConvectiveHeatFluxBC.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24729#discussioncomment-6220993",
                  "updatedAt": "2023-06-19T15:38:20Z",
                  "publishedAt": "2023-06-19T15:38:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Applying Force/Pressure parallel to boundary",
          "author": {
            "login": "TheBEllis"
          },
          "bodyText": "Apologies, I'm sure this question must have been asked before but I can't seem to find it on the discussions page. I am trying to do a really simple beam bending problem in 3D. This problem is shown in the picture below. The blue end is fixed, and the red end has a load applied parallel to the surface, pulling the end of the beam down in the negative Z direction. I can't seem to identify the correct boundary condition to use for the force. I have tried using the Pressure BC, but as the Z component of the normal is initially 0, I don't think it will work? I have tried using it having set the component/displacements manually and I can't seem to model the correct behavior. Below is my input file, it's just a simple linear mechanics problem. Any help is much appreciated:)\n\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh]\n  file = ../myBeam_3.e\n  boundary_id = '1 2 3'\n[]\n\n[Modules/TensorMechanics/Master]\n  [./block1]\n    strain = SMALL\n    add_variables = true\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    lambda = 50\n    shear_modulus = 50\n  [../]\n  [./stress]\n    type = ComputeLinearElasticStress\n  [../]\n[]\n\n[BCs]\n  [./zero_disp_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 1\n    value = 0.0\n  [../]\n\n  [./zero_disp_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 1\n    value = 0.0\n  [../]\n\n  [./zero_disp_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 1\n    value = 0.0\n  [../]\n\n# here lies the confusion\n  [Pressure]\n    [Push]\n      factor = 0.1\n      boundary = 2\n    []\n  []\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Steady\n\n  solve_type = 'NEWTON'\n\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart'\n  petsc_options_value = 'asm lu 1 101'\n[]\n\n[Outputs]\n  exodus = true\n  #perf_graph = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23377",
          "updatedAt": "2023-06-24T19:48:55Z",
          "publishedAt": "2023-02-08T10:47:34Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Let's start from the simple case. If the deformation is small enough (or equivalently the shear traction is a conservative force in the sense that it does not follow the deformation of the beam), the shear traction will always be in the (-y) direction, so all you need is a NeumannBC or its variants.\nIf the deformation is large enough such that the \"the shear traction is always in the (-y) direction\" assumption is no longer good, things get a little more complicated, but not too bad. You'll first need to figure out the tangential direction along the side of the beam, call it (t), then apply the traction as tau = f t, where tau is the traction vector, f is the magnitude of the force, and (t) is the unit vector pointing in the tangential direction. In the input file, you will then need several (2 in 2D, 3 in 3D) instances of the BC to account for contributions from different components of the traction vector tau.\nHowever, the more complicated case requires some code development, and I don't see an existing object in the tensor mechanics module that can do it for you. If you decide to write a pull request to MOOSE, I'm happy to guide you along the way.",
                  "url": "https://github.com/idaholab/moose/discussions/23377#discussioncomment-4905519",
                  "updatedAt": "2023-02-08T14:03:29Z",
                  "publishedAt": "2023-02-08T14:03:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "I am in a similar situation... should I look at the code for Pressure BC?",
                          "url": "https://github.com/idaholab/moose/discussions/23377#discussioncomment-6201123",
                          "updatedAt": "2023-06-16T21:06:15Z",
                          "publishedAt": "2023-06-16T21:06:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It won't hurt.\nWhich case is your simulation in?\nYou may want to open your own discussions topic btw, it will have greater visibility",
                          "url": "https://github.com/idaholab/moose/discussions/23377#discussioncomment-6207425",
                          "updatedAt": "2023-06-18T04:45:50Z",
                          "publishedAt": "2023-06-18T04:45:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "LOL, you'are right, let me open another discussion",
                          "url": "https://github.com/idaholab/moose/discussions/23377#discussioncomment-6209052",
                          "updatedAt": "2023-06-18T12:17:03Z",
                          "publishedAt": "2023-06-18T12:17:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A random integer used in all poins",
          "author": {
            "login": "liang-tech"
          },
          "bodyText": "I want to create a new material that genterate a random integer in every time step. And this integer can be used in all points (_q_point[_qp]). Can anyone give me suggestion\uff1f\nFor example, I try to rewrite the DiscreteNucleation material. As shown in the folllowing codes, 'eta_i' is the generated random integer. However, it is found that 'eta_i ' is not  the same constant for all points (_q_point[_qp]) in one time step .\nMy codes in the .C file:\n#include \"NisosDiscreteNucleationEta.h\"\n#include \"DiscreteNucleationMap.h\"\n\n#include \"libmesh/quadrature.h\"\n\nregisterMooseObject(\"nisosApp\", NisosDiscreteNucleationEta);\n\nInputParameters\nNisosDiscreteNucleationEta::validParams()\n{\n  InputParameters params = DerivativeFunctionMaterialBase::validParams();\n  params.addClassDescription(\"Free energy contribution for nucleating discrete particles\");\n  params.addRequiredCoupledVar(\"op_names\",\n                               \"List of variables to force to a target concentration value\");\n  params.addRequiredParam<UserObjectName>(\"map\", \"DiscreteNucleationMap user object\");\n  params.addRequiredParam<std::vector<Real>>(\"op_values\", \"List of target concentration values\");\n  params.addParam<Real>(\"threshold\", 0.1, \"The threshold to dertermine the grain order parameter of nuclei\");\n  params.addParam<Real>(\"penalty\", 20.0, \"Penalty factor for enforcing the target concentrations\");\n  MooseEnum penalty_mode(\"MATCH MIN MAX\", \"MATCH\");\n  params.addParam<MooseEnum>(\n      \"penalty_mode\",\n      penalty_mode,\n      \"Match the target concentration or take it as a minimum or maximum concentration target\");\n  return params;\n}\n\nNisosDiscreteNucleationEta::NisosDiscreteNucleationEta(const InputParameters & params)\n  : DerivativeFunctionMaterialBase(params),\n    _nvar(coupledComponents(\"op_names\")),\n    _op_index(_nvar),\n    _op_values(getParam<std::vector<Real>>(\"op_values\")),\n    _threshold(getParam<Real>(\"threshold\")),\n    _penalty(getParam<Real>(\"penalty\")),\n    _penalty_mode(getParam<MooseEnum>(\"penalty_mode\")),\n    _map(getUserObject<DiscreteNucleationMap>(\"map\"))\n{\n  // get libMesh variable numbers\n  for (unsigned int i = 0; i < _nvar; ++i)\n    _op_index[i] = argIndex(coupled(\"op_names\", i));\n}\n\nvoid\nNisosDiscreteNucleationEta::computeProperties()\n{\n  // check if a nucleation event list is available for the current element\n  const std::vector<Real> & nucleus = _map.nuclei(_current_elem);\n\n  Real eta_i = rand()%(_nvar);\n\n  // calculate penalty\n  for (_qp = 0; _qp < _qrule->n_points(); ++_qp)\n  {\n\n    //eta_i = 0;\n    // clear penalty value\n    if (_prop_F)\n      (*_prop_F)[_qp] = 0.0;\n\n    for (unsigned int i = 0; i < _nvar; ++i)\n    {\n      const unsigned ii = _op_index[i];\n\n      // modify the penalty magnitude with the nucleus mask\n      const Real penalty = _penalty * nucleus[_qp];\n\n      // deviation from the target concentration\n      Real dc = 0;\n      Real dd = 0;\n      if (eta_i == i)\n      {  dc = (*_args[ii])[_qp] - _op_values[i];\n         dd = 1;\n      }\n\n      // ignore above/below target values for min/max modes respectively\n      if ((_penalty_mode == 1 && dc > 0.0) || (_penalty_mode == 2 && dc < 0.0))\n        dc = 0.0;\n\n      // build free energy correction\n      if (_prop_F)\n        (*_prop_F)[_qp] += dc * dc * penalty;\n\n      // first derivative\n      if (_prop_dF[ii])\n        (*_prop_dF[ii])[_qp] = 2.0 * dc * penalty;\n      for (unsigned int jj = ii; jj < _nvar; ++jj)\n      {\n        if (_prop_d2F[ii][jj])\n          (*_prop_d2F[ii][jj])[_qp] = 2.0 * dd * penalty;\n      }\n    }\n  }\n}",
          "url": "https://github.com/idaholab/moose/discussions/24722",
          "updatedAt": "2023-06-24T19:47:17Z",
          "publishedAt": "2023-06-17T03:39:50Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou could keep an attribute like : _t_last_generated that is the time step you last generated the integer and\nanother attribute that is _random_integer that you only update once per timestep\nSo something like, in computeQpProperties:\nif (_t != _t_last_generated)\n{\n  _random_integer = rand()%(_nvar);\n  _t = _t_last_generated;\n}\n\nthen use _random_integer everywhere, it will only get updated once per timestep",
                  "url": "https://github.com/idaholab/moose/discussions/24722#discussioncomment-6207414",
                  "updatedAt": "2023-06-18T04:43:02Z",
                  "publishedAt": "2023-06-18T04:43:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "liang-tech"
                          },
                          "bodyText": "Thank you very much",
                          "url": "https://github.com/idaholab/moose/discussions/24722#discussioncomment-6207718",
                          "updatedAt": "2023-06-18T06:55:35Z",
                          "publishedAt": "2023-06-18T06:55:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}