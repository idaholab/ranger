{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wMS0wNVQwMTozOTozMC0wNzowMM4ASBAb"
    },
    "edges": [
      {
        "node": {
          "title": "Looking for a module to simulate fracture propagation",
          "author": {
            "login": "miraboreasumr"
          },
          "bodyText": "Hello, sorry for posting a similar question. Here is what I need for the module\n\nI have coordinates for the Naturally Fractures which I need to input\nI inject water into the fractures, then it propagates (so maybe no need for flow in porous media)\nMaybe no need for poroelastic, just elastic.\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/23096",
          "updatedAt": "2023-02-03T05:19:32Z",
          "publishedAt": "2023-01-06T22:56:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "There is no single module for hydraulic fracture in porous media. You can develop your own application leveraging one or multiple existing modules: porous flow, tensor mechanics and possibly phase field/XFEM.",
                  "url": "https://github.com/idaholab/moose/discussions/23096#discussioncomment-4633649",
                  "updatedAt": "2023-01-09T13:46:57Z",
                  "publishedAt": "2023-01-09T13:46:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Phase field coupled mechanical stress",
          "author": {
            "login": "biaogxb"
          },
          "bodyText": "I want to use the phase field method and coupling the mechanical stress to simulate the growth of dendrites. When the mechanical stress is not added, everything looks normal, but the following errors occur after coupling the mechanical stress\n*** ERROR ***\nThe following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\nMaterial property 'mechanical_strain', requested by 'stress' is not defined on block 0\nMaterial property 'mechanical_strain', requested by 'stress_face' is not defined on block 0\nMaterial property 'mechanical_strain', requested by 'stress_neighbor' is not defined on block 0\nI will calculate the elastic energy as follows.\n\nThe added code is as follows:\nkernel part\n  [./AC_bulk]\ntype = AllenCahn\n   variable = eta\n    f_name = FA\n  [../]\nmaterial part\n   # Energy of the barrier\n[./Free]\n   type = DerivativeParsedMaterial\n  f_name = FF\n material_property_names = 'B'\n args='eta'\n function = 'B*eta*eta*(1-eta)*(1-eta)'\nderivative_order = 1\n [../]\n#Mechanics parameeters\n [./Stiffness_matrix]\n  type = ComputeElasticityTensor\n C_ijkl = '3294.1 1852.9 1852.9 3294.1 1852.9 3294.1 720.6 720.6 720.6'\n fill_method = symmetric9\n [../]\n  [./stress]\n type = ComputeLinearElasticStress\n [../]\n [./eigen_strain]\n type = ComputeVariableEigenstrain\neigen_base = '-0.3464 0 0 -0.3092 0 -0.2116'\n prefactor = h\nargs = eta\n eigenstrain_name = 'eigenstrain'\n[../]\n [./elastic_free_energy_p]\ntype = ElasticEnergyMaterial\nf_name = FE\n args = 'eta'\n derivative_order = 2\n [../]\n#all free_Energy\n [./free_energy]\ntype = DerivativeSumMaterial\n  f_name = FA\n  sum_materials = 'FF FE'\n  args = 'eta'\nderivative_order = 2\n  [../]\nHow can I adjust my code?",
          "url": "https://github.com/idaholab/moose/discussions/21355",
          "updatedAt": "2023-01-08T20:28:49Z",
          "publishedAt": "2022-06-20T04:02:06Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Krystalfang"
                  },
                  "bodyText": "Hello, I have encountered the same problem, did you solve your problem?",
                  "url": "https://github.com/idaholab/moose/discussions/21355#discussioncomment-3044693",
                  "updatedAt": "2022-06-29T02:23:32Z",
                  "publishedAt": "2022-06-29T02:23:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dschwen @jiangwen84  is there some incompatible strain/stress materials in this list?",
                  "url": "https://github.com/idaholab/moose/discussions/21355#discussioncomment-3088748",
                  "updatedAt": "2022-07-06T01:30:53Z",
                  "publishedAt": "2022-07-06T01:30:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "I guess it's because I didn't add displacement\uff08disp_x \\disp_y\uff09,When I add the displacement term, the error report disappears, but there are some problems in the calculation result.\nThe results and input files without coupled mechanical stress are as follows,The result looks good.\n\ninput1.txt\nWhen I coupled the mechanical stress, there were some problems in the result:(I don't know whether it is the problem of mechanical stress related parameters or the problem of mechanical stress coupling process)\n\ninput2.txt\nCould you give me some advice on coupling mechanical stress? I will be very grateful!",
                          "url": "https://github.com/idaholab/moose/discussions/21355#discussioncomment-3088796",
                          "updatedAt": "2022-07-06T01:48:50Z",
                          "publishedAt": "2022-07-06T01:48:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m not very knowledgable about this.\nThis looks like unconverged results. Make sure nl_abs_tol and nl_rel_tol are both very low. They should both be several orders of magnitude below what seems acceptable in terms of convergence",
                          "url": "https://github.com/idaholab/moose/discussions/21355#discussioncomment-3088827",
                          "updatedAt": "2022-07-06T01:56:35Z",
                          "publishedAt": "2022-07-06T01:56:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "galibubc"
                          },
                          "bodyText": "Hello @biaogxb,\nDid you solve the problem? Can you please share how you solved it?\nMusanna",
                          "url": "https://github.com/idaholab/moose/discussions/21355#discussioncomment-4627453",
                          "updatedAt": "2023-01-08T20:28:49Z",
                          "publishedAt": "2023-01-08T20:28:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "time step",
          "author": {
            "login": "Oops-Qiao"
          },
          "bodyText": "Dear expert,\nIf I want to use time step dt in kernels, how can I call the value of dt?\nThanks a lot.\nBest\nQia",
          "url": "https://github.com/idaholab/moose/discussions/23107",
          "updatedAt": "2023-01-14T22:56:00Z",
          "publishedAt": "2023-01-08T11:46:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "_dt\nLook at the doxygen for kernels you ll see all the class attributes",
                  "url": "https://github.com/idaholab/moose/discussions/23107#discussioncomment-4625437",
                  "updatedAt": "2023-01-08T13:49:54Z",
                  "publishedAt": "2023-01-08T13:49:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the average value of a variable at a certain boundary?",
          "author": {
            "login": "xiaojbing"
          },
          "bodyText": "hello,\nI need to get average value of a variable at a certain boudary at every time step? Is there any postprocessor or auxkernel could achieve this?",
          "url": "https://github.com/idaholab/moose/discussions/23106",
          "updatedAt": "2023-02-03T05:19:39Z",
          "publishedAt": "2023-01-08T01:39:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthere s a SideAverageValue postprocessor that does this\nhttps://mooseframework.inl.gov/moose/source/postprocessors/SideAverageValue.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23106#discussioncomment-4622910",
                  "updatedAt": "2023-01-08T01:42:32Z",
                  "publishedAt": "2023-01-08T01:42:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "thank you, I will try",
                          "url": "https://github.com/idaholab/moose/discussions/23106#discussioncomment-4622911",
                          "updatedAt": "2023-01-08T01:43:11Z",
                          "publishedAt": "2023-01-08T01:43:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to set supporting constraint and spring constraint?",
          "author": {
            "login": "DYLDYLDYL"
          },
          "bodyText": "Hi!\nI want to set an axial supporting constraint at the bottom and an axial spring constraints at the top.\nThanks in advance for your help!",
          "url": "https://github.com/idaholab/moose/discussions/22903",
          "updatedAt": "2023-02-04T15:46:29Z",
          "publishedAt": "2022-12-07T13:47:24Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSupporting constraint is likely just a dirichlet BC on the displacement variable\nA spring constraint will be a neumann BC in the momentum equation I think, but there's definitely something in the tensor mechanics module for that\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22903#discussioncomment-4586635",
                  "updatedAt": "2023-01-03T23:50:25Z",
                  "publishedAt": "2023-01-03T23:50:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "right, fixture support -> Dirichlet BC, spring support -> Robin BC.",
                          "url": "https://github.com/idaholab/moose/discussions/22903#discussioncomment-4596841",
                          "updatedAt": "2023-01-05T01:00:55Z",
                          "publishedAt": "2023-01-05T01:00:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "DYLDYLDYL"
                          },
                          "bodyText": "Thanks a lot \uff01",
                          "url": "https://github.com/idaholab/moose/discussions/22903#discussioncomment-4618668",
                          "updatedAt": "2023-01-07T10:51:15Z",
                          "publishedAt": "2023-01-07T10:51:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to achieve flow distribution with MOOSE framework.",
          "author": {
            "login": "Raven-pro"
          },
          "bodyText": "Hello, everyone!\nI am using THM module and MultiApp to simulate parallel flow channels.\nIn the parallel flow channels, the pressure drops should be equal in all the channels, which means I need to adjust the mass flow rate of each channel in each time step.\nLike, in each time step, the program calculates the pressure drop of each channel and adjusts the inlet mass flow of each channel, then iterates, until the pressure drop of each channel is equal, then we go to the next time step.\nSo I need to add an iteration at each time step with all the inlet variables and solutions needed, then change the inlets of all the channels to execute the next time step. Are there any possible ways to achieve this?",
          "url": "https://github.com/idaholab/moose/discussions/23084",
          "updatedAt": "2023-02-03T05:22:04Z",
          "publishedAt": "2023-01-05T18:07:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Raven-pro"
                  },
                  "bodyText": "I have also noticed that THM module tutorial doesn't mention something like parallel follow.\nBut I think the module is capable of solving such a problem.\nAre there any existing components that can achieve this?",
                  "url": "https://github.com/idaholab/moose/discussions/23084#discussioncomment-4604349",
                  "updatedAt": "2023-01-05T18:09:38Z",
                  "publishedAt": "2023-01-05T18:09:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@joshuahansel @licharlot\nI can see two ways of doing this:\n\nset an inlet and outlet pressure boundary condition. This will make sure the mass flow rate in each channel does lead to the same pressure drop\nuse the optimization module to set up an optimization problem for the mass flow rates to match the pressure drops wanted. This is much more work",
                  "url": "https://github.com/idaholab/moose/discussions/23084#discussioncomment-4611340",
                  "updatedAt": "2023-01-06T14:12:28Z",
                  "publishedAt": "2023-01-06T11:51:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "That's an interesting idea. I'm not sure what would happen, since the characteristics aren't specified completely at the inlet. It's very easy to try though, so @89018580 you can see what happens.\nThis does sound hard.",
                          "url": "https://github.com/idaholab/moose/discussions/23084#discussioncomment-4612930",
                          "updatedAt": "2023-01-06T14:30:37Z",
                          "publishedAt": "2023-01-06T14:30:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For option 1, can you specify temperature at the inlet for example? Or does it have to be an energy flow.\nI d also be worried about computing density(T) at the inlet without a temperature BC.",
                          "url": "https://github.com/idaholab/moose/discussions/23084#discussioncomment-4613045",
                          "updatedAt": "2023-01-06T14:44:42Z",
                          "publishedAt": "2023-01-06T14:44:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "There's InletStagnationPressureTemperature1Phase that might be worth a try (with Outlet1Phase at the outlet), but I'm not sure how much the static pressure at the inlet will vary from the stagnation pressure.",
                          "url": "https://github.com/idaholab/moose/discussions/23084#discussioncomment-4613167",
                          "updatedAt": "2023-01-06T14:59:16Z",
                          "publishedAt": "2023-01-06T14:59:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "I need to know more about the problem you're solving. Are the parallel channels connected in any way, i.e., do you have THM junctions connecting them? (Or some other method of \"connecting\" them?) Or are they all being treated independently?\nDo the pressure drops need to be exactly the same for some numerical reason? Or do you just know that they should physically be the same given different paths between the same two end points? The latter reasoning has the requirement that these channels actually be connected somehow. If you have some kind of junction connecting these channels, equal pressure drops result automatically. However, note that this is dependent on the junction formulation, and note that the pressures at the inlet and outlet boundaries may not be in agreement with the corresponding cell-center pressures of the boundary cells. This discrepancy is a function of the spatial discretization error - use slope reconstruction to minimize it.\nIf you're not using junctions of any kind, one idea is that you can use PID controllers to control the inlet mass flow rate based on a pressure drop target, but you probably don't know what this target is beforehand.",
                  "url": "https://github.com/idaholab/moose/discussions/23084#discussioncomment-4613046",
                  "updatedAt": "2023-01-06T14:44:51Z",
                  "publishedAt": "2023-01-06T14:44:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "But I want to stress that the best solution, in my opinion, is to have some kind of junction connecting the channels that naturally produces the desired condition. Try JunctionParallelChannels1Phase for example.",
                          "url": "https://github.com/idaholab/moose/discussions/23084#discussioncomment-4613118",
                          "updatedAt": "2023-01-06T14:53:17Z",
                          "publishedAt": "2023-01-06T14:53:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "licharlot"
                          },
                          "bodyText": "I agree we need to know more. This sounds like a plenum to plenum calculation where the total mass flow rate is known and needs to be split between the parallel channels. In that case, the easiest is indeed to use JunctionParallelChannels1Phase but this will require to have all the parallel channels in one input file.",
                          "url": "https://github.com/idaholab/moose/discussions/23084#discussioncomment-4615885",
                          "updatedAt": "2023-01-06T21:16:08Z",
                          "publishedAt": "2023-01-06T21:16:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "I can't find the problem...",
          "author": {
            "login": "MScKarl"
          },
          "bodyText": "Hi!\nI have a small problem with my code. I expect the results seen in the included figure. But the code jumps to the last step.\n\nThe code is as followed:\n[Mesh]\n    type = GeneratedMesh\n    dim = 2\n    nx = 100\n    ny = 100\n    xmin = -3\n    xmax = 3\n    ymin = -3\n    ymax = 3\n    elem_type = QUAD4\n[]\n\n[AuxVariables]\n\n  [./beta]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n  [./gamma]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n  [./alpha]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n  [./L]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n[]\n\n[Variables]\n\n  [./eta]\n     order = FIRST\n     family = LAGRANGE\n    [./InitialCondition]\n       type = RandomIC\n       min = -5e-5\n       max = 5e-3\n    [../]\n  [../]\n\n []\n\n[Functions]\n  [./alpha_fun] \n    type = ParsedFunction \n    value = abs(alpha_0)*(sgn_0-sqrt(r_0/(x^2+y^2))*cos(atan2(x,y)/2))\n    vars = 'alpha_0 sgn_0 r_0'\n    vals = '1.0 1.0 1.0'\n  [../]\n[]\n\n[BCs]\n\n  [./left]\n    type = NeumannBC\n    variable = 'eta'\n    boundary = 'left'\n    value = 0.0\n  [../]\n\n  [./right]\n    type = NeumannBC\n    variable = 'eta'\n    boundary = 'right'\n    value = 0.0\n  [../]\n\n  [./top]\n    type = NeumannBC\n    variable = 'eta'\n    boundary = 'top'\n    value = 0.0\n  [../]\n\n  [./bottom]\n    type = NeumannBC\n    variable = 'eta'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n[]\n\n[AuxKernels]\n  [./fill_alpha]\n    type = FunctionAux\n    variable = alpha\n    function = alpha_fun\n  [../]\n[]\n\n[Kernels]\n\n  #Kernels for Allen-Cahn equation\n  #Time Dependencies        \n  [./deta_dt]\n    type = TimeDerivative\n    variable = eta\n  [../]\n\n  #Interface\n  [./ACInterface]\n    type = ACInterface\n    variable = eta\n    kappa_name = g # (prova med [1 5 7 10 50 70]*10^-3)\n    mob_name = L \n  [../]\n\n  [./ACbulk_eta]\n    type = AllenCahn\n    variable = eta\n    f_name = f_eta\n    mob_name = L\n  [../]\n\n[]\n\n[Materials]\n\n  [./constants]\n    type = GenericConstantMaterial\n    prop_names = 'beta gamma L g'\n    prop_values = '-1.0 1.0 1.0 0.01'\n  [../]\n\n  [./f_eta]\n    type = DerivativeParsedMaterial\n    f_name = f_eta # Name of the function\n    args = 'beta gamma eta alpha' #the coefficients\n    function = 'alpha*eta+beta*eta^3+gamma*eta^5'\n  [../]\n\n[]\n\n[Executioner]\n\n    type = Transient\n    solve_type = NEWTON \n \n    num_steps = 200\n    dt = 0.1\n[]\n\n[Outputs]\n    exodus = true\n[]\n\nBest Regards\nKarl",
          "url": "https://github.com/idaholab/moose/discussions/23074",
          "updatedAt": "2023-01-07T17:43:07Z",
          "publishedAt": "2023-01-04T23:33:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUsually if the code jumps to the steady state it means either:\n\na time derivative is missing (seems fine here)\nthe time step is too large compared to the time scale of the physics involved\na coefficient on the time derivative or ruling the physics involved has been written improperly, and the physical phenomena is happening much faster than it should\n\nI would think the last item is happening, all your coefficients are unity instead of having their true dimensionality. The mesh is similarly sized arbitrarily.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23074#discussioncomment-4612869",
                  "updatedAt": "2023-01-06T14:48:57Z",
                  "publishedAt": "2023-01-06T14:25:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "wrong result and convergence issues for single-phase 1D flow",
          "author": {
            "login": "Raven-pro"
          },
          "bodyText": "Hi, I am opening a new topic from the previous thread [#22648]. The previous problem is about implementing AD to the fp coefficients so that the jacobian shall be formed properly, and I tried, but it turned out not so many differences were made on my issues.\nI am trying to build a single-phase 1D 3Eqns flow application based on MOOSE, the governing equations are as follows.\nAnd transforming the equations to the weak forms, with the divergence theorem, I have\n\nThen I wrote kernels and BCS based on the above weak-formed equations, with ICs and BCs, set as in the input file below.\n\n    p_init = 15.5e6       # Pa\n    h_init = 1133820    # J/kg \n    v_init = 1                 # m/s\n    De = 0.025             # m\n    U = 0.0785398      # m\n    A = 0.00049087    # m2\n    q = 1273239.545   # W/m2\n\n\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    nx = 50\n    # ny = 12\n    # ymax = 0.012\n    # ymin = 0\n    xmax = 1.0\n    xmin = 0\n    elem_type = EDGE\n[]\n\n[Modules]\n    [FluidProperties]\n        [water]\n            type = Water97FluidProperties\n        []\n    []\n[]\n\n[Materials]\n    [fp_mat]\n        type = Water97\n        p = P\n        h = H\n        fluid = water\n    []\n[]\n\n[Variables]\n    [P]\n        order = FIRST\n        family = LAGRANGE\n        scaling = 1\n        initial_condition = ${p_init}\n    []\n    [V]\n        order = FIRST\n        family = LAGRANGE\n        scaling = 1e-3\n        initial_condition = ${v_init}\n    []\n    [H]\n        order = FIRST\n        family = LAGRANGE\n        scaling = 1e-6\n        initial_condition = ${h_init}\n    []\n[]\n\n\n[Kernels]\n    [MassTime]\n        type = MassTime\n        variable = P\n        dot_h = H\n    []\n    [MassAdvection]\n        type = MassAdvection\n        variable = P\n        v = V\n    []\n    [MassPSPG]\n        type = MassPSPG\n        variable = P\n        dot_h = H\n        v = V\n        grad_v = V\n        De = ${De}\n    []\n    [MomentumTime]\n        type = MomentumTime\n        variable = V\n        dot_p = P\n        dot_h = H\n    []\n    [MomentumAdvection]\n        type = MomentumAdvection\n        variable = V\n    []\n    [MomentumSource]\n        type = MomentumSource\n        variable = V\n        grad_p = P\n        De = ${De}\n    []\n    [MomentumSUPG]\n        type = MomentumSUPG\n        variable = V\n        grad_p = P\n        De = ${De}\n    []\n    [EnergyTime]\n        type = EnergyTime\n        variable = H\n        dot_p = P\n    []\n    [EnergyAdvection]\n        type = EnergyAdvection\n        variable = H\n        v = V\n    []\n    [EnergySource]\n        type = EnergySource\n        variable = H\n        U = ${U}\n        A = ${A}\n        q = ${q}\n    []\n    [EnergySUPG]\n        type = EnergySUPG\n        variable = H\n        v = V\n        U = ${U}\n        A = ${A}\n        q = ${q}\n    []\n[]\n\n[BCs]\n    [bc1]\n        type = DirichletBC\n        variable = H\n        value = ${h_init}\n        boundary = \"left\"\n    []\n    [bc2]\n        type = DirichletBC\n        variable = P\n        value = ${p_init}\n        boundary = \"right\"\n    []\n    [bc3]\n        type = DirichletBC\n        variable = V\n        value = ${v_init}\n        boundary = \"left\"\n    []\n    [bc4]\n        type = MassBC\n        variable = P\n        v = V\n        boundary = \"right\"\n    []\n    [bc5]\n        type = MomentumBC\n        variable = V\n        boundary = \"right\"\n    []\n    [bc6]\n        type = EnergyBC\n        variable = H\n        v = V\n        boundary = \"right\"\n    []\n[]\n\n#[VectorPostprocessors]\n  #[H]\n    #type = NodalValueSampler\n    #variable = H\n    #boundary = 'bottom'\n    #block = 0\n    #execute_on = 'initial timestep_end' \n    #use_displaced_mesh = true\n    #sort_by = x\n  #[]\n  #[P]\n    #type = NodalValueSampler\n    #variable = P\n    #boundary = 'bottom'\n    #block = 0\n    #execute_on = 'initial timestep_end' \n    #use_displaced_mesh = true\n    #sort_by = x\n  #[]\n#[]\n\n[Problem]\n    type = FEProblem\n    coord_type = XYZ\n[]\n\n[Preconditioning]\n    [./SMP]\n        type = SMP\n        full = true\n        solve_type = 'PJFNK'\n        petsc_options_iname = '-pc_type'\n        petsc_options_value = 'lu'\n    [../]\n[]\n\n[Executioner]\n    type = Transient\n    solve_type =  'PJFNK'\n    # compute_scaling_once = false\n    automatic_scaling = true\n    scheme = bdf2\n    dt = 1e-5\n    dtmin = 1e-5\n    petsc_options_iname = '-ksp_gmres_restart'\n    petsc_options_value = '100'\n    nl_rel_tol = 1e-7\n    nl_abs_tol = 1e-6\n    nl_max_its = 20\n\n    l_tol = 1e-4\n    l_max_its = 100\n\n    start_time = 0.0\n    num_steps = 200\n    end_time = 1e-3\n\n    [./Quadrature]\n        type = TRAP\n        order = FIRST\n    [../]\n[]\n\n[Outputs]\n    exodus = true\n    csv = true\n[]\n\nBut the results are wrong in the ParaView. If the code runs longer, it will not converge, the results are like that, we have negative velocity values intermittently, and the enthalpy oscillated, which is obviously wrong.\n\nI tried adding the PSPG term and SUPG term, but it didn't work. Can anybody knows how to make it converge? I will really appreciate it.\nThe code of my application is uploaded below (Mostly several kernels and three IntegratedBCs), can anybody check it a little? THX!\nSF",
          "url": "https://github.com/idaholab/moose/discussions/22682",
          "updatedAt": "2023-01-05T16:40:53Z",
          "publishedAt": "2022-11-13T06:08:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Raven-pro"
                  },
                  "bodyText": "I have just tested the use of stabilization and it turned out useful in stabilizing the oscillation of pressure. But oscillations of enthalpy and velocity are still unsolved.\nWhat's more, if I set the inlet pressure boundary condition instead of the outlet, the pressure will oscillate as well.\nSo how to get rid of this kind of abnormal oscillation?",
                  "url": "https://github.com/idaholab/moose/discussions/22682#discussioncomment-4127762",
                  "updatedAt": "2022-11-13T10:45:20Z",
                  "publishedAt": "2022-11-13T10:45:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nso the nonlinear solves are converging but the result is oscillating unphysically?\nif you are hitting convergence issues, you will want to check the Jacobian for accuracy\nhttps://mooseframework.inl.gov/help/development/analyze_jacobian.html\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22682#discussioncomment-4140639",
                          "updatedAt": "2022-11-14T20:59:45Z",
                          "publishedAt": "2022-11-14T20:59:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Yes, when I set d_t to be 1e-5 or lower. running for like 200 steps, the nonlinear solves converge with oscillating results.\nIf the code runs longer for like 300 steps, the solves will not converge.  I don't know if it truly is a converging issues since the code can converge at first several hundreds of steps.",
                          "url": "https://github.com/idaholab/moose/discussions/22682#discussioncomment-4142325",
                          "updatedAt": "2022-11-15T02:24:56Z",
                          "publishedAt": "2022-11-15T02:24:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Raven-pro"
                  },
                  "bodyText": "I don't know if it's because I have missed something about MOOSE.\nI have read papers about SAM, which is also based on MOOSE and can solve single-phase compressible problems, and it implements the same three governing equations in the applications, which runs well.\nSo I think this kind of problem maybe is because of my limited knowledge of MOOSE.\nI am just thinking, If it's really about jacobian, is it better to hand-code jaboian than AD?",
                  "url": "https://github.com/idaholab/moose/discussions/22682#discussioncomment-4144420",
                  "updatedAt": "2022-11-15T09:12:47Z",
                  "publishedAt": "2022-11-15T09:12:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It's not better to hand code the Jacobian. The AD Jacobian is numerically perfect. If you are using AD the script I linked to should have reported a perfect Jacobian\nHowever, you are using PJFNK which does not fully leverage the potential of AD. I recommend you try Newton's method instead, which will benefit from these accurate Jacobians from AD.\nYou may want to tighten the linear tolerances and increase the order of the quadrature as well, I m not sure",
                          "url": "https://github.com/idaholab/moose/discussions/22682#discussioncomment-4147355",
                          "updatedAt": "2022-11-15T14:46:23Z",
                          "publishedAt": "2022-11-15T14:46:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Thank you, I will try your suggestions!",
                          "url": "https://github.com/idaholab/moose/discussions/22682#discussioncomment-4148149",
                          "updatedAt": "2022-11-15T16:00:09Z",
                          "publishedAt": "2022-11-15T16:00:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nwhere do we stand on this?\nwhere you able to get a non-oscillating profile?\nwhich numerical scheme are you using now?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22682#discussioncomment-4586468",
                          "updatedAt": "2023-01-03T23:14:43Z",
                          "publishedAt": "2023-01-03T23:14:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Hello GiudGiud\nYes, I've worked out the problems using SUPG method. The calculation can get the right solution now.",
                          "url": "https://github.com/idaholab/moose/discussions/22682#discussioncomment-4603469",
                          "updatedAt": "2023-01-05T16:40:40Z",
                          "publishedAt": "2023-01-05T16:40:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "THM Elbows",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi Folks\nQuick one, the documentation for Elbow1Phase seems to be incorrect, or at the very least confusing. Direction - Direction of axis from start position to end position (no need to normalize). Maybe I'm not clear about the co-ordinate system, usually I've seen tori referred to as the direction being the vector orthogonal to broadest part of the ring, i.e.\n\nThe image above would be a torus with a direction of [0,0,1] or equally [0,0,-1]. For the system that I've built, see the image below, I have two pipes connected to the elbow (with VolumeJunction1Phase)\n\nAs can be seen, the elbows are in the y-z plane, and thus (I would) described as a x-torus or a torus with a direction of [1,0,0], however when I input that into MOOSE, the network looks as thus;\n\nWhich clearly isn't right, the values are fine, the geometry is clearly wrong, if I change instead the direction to be that of a z torus, i.e. [0,0,1], then all is well;\n\nSo, I guess I'm confused why the direction should be what it is, what is the underlying coordinate system that makes this make sense?\nAlso, why can't I use regular connections between straight pipes and elbow bends, given that they are indeed parallel where they meet? Am I confused as what parallel means in this context?",
          "url": "https://github.com/idaholab/moose/discussions/22787",
          "updatedAt": "2023-01-05T15:10:50Z",
          "publishedAt": "2022-11-24T10:22:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@licharlot @joshuahansel",
                  "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4228911",
                  "updatedAt": "2022-11-24T16:44:58Z",
                  "publishedAt": "2022-11-24T16:44:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "licharlot"
                  },
                  "bodyText": "Hi,\nI don't know the exact reason for direction being defined as it is. direction describes the direction at the start of the elbow.\nWith the current logic that is implemented in THM, you cannot use the OneToOneJunction1Phase or JunctionParallelChannels1Phase to connect the elbows to a straight pipe because of the discretization of the elbow. The first element is not exactly parallel to that direction.  So you need to use the VolumeJunction1Phase component.",
                  "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4233749",
                  "updatedAt": "2022-11-25T03:56:38Z",
                  "publishedAt": "2022-11-25T03:51:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Perfect, thanks that makes at least some sense - one suggestion is to update the documentation to reflect that, along with a note that position in this context means the origin of the circle that would make the elbow.",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4248532",
                          "updatedAt": "2022-11-27T20:43:11Z",
                          "publishedAt": "2022-11-27T20:43:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "We use the direction definition that we do because it could be used universally. It sounds like the definition you mention only pertains to tori. I agree that we should clarify the description - it makes perfect sense for straight pipes, but for curved pipes, it's wrong. I propose \"Direction of axis from start position to end position (no need to normalize). For curved channels, it is the inward tangent vector at the start position.\" Does that sound clear?\nWe should also at least add an option to make those first elements straight.",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4253221",
                          "updatedAt": "2022-11-28T13:04:00Z",
                          "publishedAt": "2022-11-28T13:04:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Yeah much more clear",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4337472",
                          "updatedAt": "2022-12-07T21:35:55Z",
                          "publishedAt": "2022-12-07T21:35:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "Sorry to re-invigorate this one, I'm still quite confused about elbows and the 'inward directed tangent at the start position' - consider the below diagram\n\nI've drawn in red, what I consider given our discussions about what the inward directed tangent from the start position. Thus I would say following the flow direction, the directions for the elbows would be [0 -1 0], [0 0 1], [0 1 0], and [0 0 1]. However MOOSE does not agree, it wants them to be Z directed. What key piece of information am I missing? @joshuahansel",
                  "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4567267",
                  "updatedAt": "2023-01-01T21:25:54Z",
                  "publishedAt": "2023-01-01T21:25:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Your red arrows are not tangent - they are orthogonal to your curve. The black arrow is the correct vector for your first segment.",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4581792",
                          "updatedAt": "2023-01-03T13:37:55Z",
                          "publishedAt": "2023-01-03T13:37:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "So these would be right?\n\nMOOSE still wants them to be all [0,0,1] though, that's what I'm really not getting.\nI've build half the network in MOOSE;\n\nBut it needs those tori to be both z-directed, which is inconsistent with above.",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4584184",
                          "updatedAt": "2023-01-03T17:36:43Z",
                          "publishedAt": "2023-01-03T17:36:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Your red arrows are correct. What do you mean by \"MOOSE wants/needs\"? What is requiring the z direction?",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4584315",
                          "updatedAt": "2023-01-03T17:50:07Z",
                          "publishedAt": "2023-01-03T17:50:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Well to properly create the pipe network shown above (red-white-green-blue) I have to use the following (shortened) components with directions\n[Components]\n[pipe_1]\n....\ntype=FlowChannel1Phase\norientation=\"0.0 0.0 1.0\"\n...\n[]\n[pipe_2]\n...\ntype=ElbowPipe1Phase\norientation=\"0.0 0.0 1.0\"\n...\n[]\n[pipe_3]\n...\ntype=FlowChannel1Phase\norientation=\"0.0 -1.0 0.0\"\n...\n[]\n[pipe_4]\n...\ntype=ElbowPipe1Phase\norientation=\"0.0 0.0 1.0\"\n....\n[]\n[]\n\nSee the second elbow needs to be [0,0,1] rather than [0,1,0] in order to get the view shown in the Paraview plot above. See the input here - https://drive.google.com/file/d/1eLtEVeUawnikdwAKmP7dP1YgnTWN9-Au/view?usp=sharing\nSo if for input consistency the elbows should follow my second diagram, then I think there must be a bug somewhere, because if I use the direction as I should, the exodus file out is incorrect.",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4585491",
                          "updatedAt": "2023-01-03T20:34:37Z",
                          "publishedAt": "2023-01-03T20:34:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Do you follow @joshuahansel ?",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4595508",
                          "updatedAt": "2023-01-04T20:47:30Z",
                          "publishedAt": "2023-01-04T20:40:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Ok, interesting, that sounds like a meshing bug in ElbowPipe1Phase. I'll look into this and get back to you.",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4596082",
                          "updatedAt": "2023-01-04T22:25:34Z",
                          "publishedAt": "2023-01-04T22:25:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "I've looked into this. It's very confusing. From what I can tell, here's how the points are generated for the elbow:\n\nGenerate an arc in the XY plane (at z=0) about the origin, from start_angle to end_angle with radius radius.\nApply rotation about the x-axis using rotation\nApply directional transformation using orientation\nApply translation using position\n\nIf you're really interested, see ElbowPipe1Phase::buildMeshNodes() for step 1 and DiscreteLineSegmentInterface::computeRealPointFromReferencePoint() for steps 2-4.\nBut I assume you want a solution :)\nI think what this needs is a refactor to make the curve specification much more clear... I'll think about a good way to do this.\nI apologize for all of the confusion. This is a component that we admittedly have not used very much, so we probably only tested it for a more restricted setup (like oriented in the x-direction maybe).",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4596337",
                          "updatedAt": "2023-01-04T23:20:32Z",
                          "publishedAt": "2023-01-04T23:20:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "I don't have any quick solution to this. I think this needs some refactoring to do right. I'm not sure if I'll get to it soon. If you want to make your own version of ElbowPipe1Phase that fixes it for your case, you can do that. There's not much to that class.\nHere's what I'm dreaming up here: the user only specifies the ends of the flow channels to connect to, and then a smooth transition is found between these two points such that the directions at the connection points match. For example, I'm wondering if I can use Bezier curves or something to accomplish this.",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4596497",
                          "updatedAt": "2023-01-04T23:58:36Z",
                          "publishedAt": "2023-01-04T23:58:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "On second thought, I'd probably start with something very simple: the user specifies\n\nposition: the start position\nperpindicular_clockwise_direction: the direction that is perpindicular to the arc, for which the arc goes in a clockwise direction from the start position\nradius: the radius of the arc\ndegrees: the degrees of the arc",
                          "url": "https://github.com/idaholab/moose/discussions/22787#discussioncomment-4602491",
                          "updatedAt": "2023-01-05T15:10:50Z",
                          "publishedAt": "2023-01-05T15:10:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Is it possible to select outputs for the vtk file ?",
          "author": {
            "login": "AlexSacMorane"
          },
          "bodyText": "Dear all,\nI am working with the phase-field module of Moose. I need to work on specific data from the output file. I have a python script to automatize the file reading, so I use a VTK file.\nThe file is large, and I do not use most of it. In fact, I need only etai, c, Ed_mec and Ed_prec. Is there a way to filter the VTK file writing to reduce the size?\nI know I can reduce the size by commenting lines about the [GlobalParams] part. But Ed_mec and Ed_prec are not some variables, that is why I print all the data.\nMy .i file and some vtk outputs are in the attachments.\nI stay available\nThanks in advance\nAlexandre SM\nSelect_Outputs.zip",
          "url": "https://github.com/idaholab/moose/discussions/23067",
          "updatedAt": "2023-01-05T08:39:30Z",
          "publishedAt": "2023-01-04T16:48:36Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIn the Outputs block you can specify which fields you want to include or hide using the hide and show parameters\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23067#discussioncomment-4593720",
                  "updatedAt": "2023-01-04T16:52:24Z",
                  "publishedAt": "2023-01-04T16:52:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AlexSacMorane"
                          },
                          "bodyText": "Thank for your answer",
                          "url": "https://github.com/idaholab/moose/discussions/23067#discussioncomment-4599258",
                          "updatedAt": "2023-01-05T08:39:30Z",
                          "publishedAt": "2023-01-05T08:39:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}