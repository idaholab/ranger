{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNi0xM1QxMToyMzoxNS0wNjowMM4AUJnS"
    },
    "edges": [
      {
        "node": {
          "title": "Material property and initial Aux variable values from an input (ASCII) file",
          "author": {
            "login": "chakra34"
          },
          "bodyText": "Hi Moose community,\nI wanted to ask if there is a way to provide the value of material properties as an input file. For example I have a cylindrical geometry where I want to provide the temperature field, Young's modulus and Poisson's ratio from an input file that has the mesh coordinates and the corresponding values of these material properties and temperature (treated as an aux variable for this purpose).\nIs there already something in MOOSE which allows to do this?\nThanks,\nBest,\nAritra",
          "url": "https://github.com/idaholab/moose/discussions/24679",
          "updatedAt": "2023-06-24T22:18:10Z",
          "publishedAt": "2023-06-13T20:46:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo those properties are solely a function of space?\nIf so:\nThis Function\nhttps://mooseframework.inl.gov/source/functions/PiecewiseConstantFromCSV.html\nthen this material\nhttps://mooseframework.inl.gov/source/materials/GenericFunctionMaterial.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6167717",
                  "updatedAt": "2023-06-13T21:02:39Z",
                  "publishedAt": "2023-06-13T21:02:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Thanks for the reply! I guess I am a bit confused on how we are incorporating this information. As an example I had a csv file with x,y,z coordinates and the temperature and I wanted to use this as the function value for the temperature aux variable.\nSo first few rows of my csv file looks like:\n\n\n\n\n\n\n<style>\n\n</style>\n\n\n\n\n\n5.00E-02\n5.22E-02\n5.22E-02\n10.439\n\n\n\n\n0.1\n5.22E-02\n5.22E-02\n10.439\n\n\n0.15\n5.22E-02\n5.22E-02\n10.439\n\n\n0.2\n5.22E-02\n5.22E-02\n10.439\n\n\n0.25\n5.22E-02\n5.22E-02\n10.439\n\n\n0.3\n5.22E-02\n5.22E-02\n10.439\n\n\n0.35\n5.22E-02\n5.22E-02\n10.439\n\n\n0.4\n5.22E-02\n5.22E-02\n10.439\n\n\n0.45\n5.22E-02\n5.22E-02\n10.439\n\n\n0.5\n5.22E-02\n5.22E-02\n10.439\n\n\n0.55\n5.22E-02\n5.22E-02\n10.439\n\n\n0.6\n5.22E-02\n5.22E-02\n10.439\n\n\n0.65\n5.22E-02\n5.22E-02\n10.439\n\n\n0.7\n5.22E-02\n5.22E-02\n10.439\n\n\n0.75\n5.22E-02\n5.22E-02\n10.439\n\n\n0.8\n5.22E-02\n5.22E-02\n10.439\n\n\n0.85\n5.22E-02\n5.22E-02\n10.439\n\n\n0.9\n5.22E-02\n5.22E-02\n10.439\n\n\n0.95\n5.22E-02\n5.22E-02\n10.439\n\n\n5.00E-02\n5.21E-02\n0.10439\n20.878\n\n\n0.1\n5.21E-02\n0.10439\n20.878\n\n\n\n\n\nthe first 3 are the X,Y,Z coordinates and the last column is the temperature of a box geometry with coordinates ranging from [0,1]m in all X,Y, and Z direction.\nSo to do this I used the \"nearest\" and used the following:\n[UserObjects]\n[reader_nearest]\ntype = PropertyReadFile\nprop_file_name = 'temperature_ansys_modified.csv'\nread_type = 'voronoi'\nnprop = 1\nnvoronoi = 1\n[]\n[]\n[Functions]\n[temp_nearest]\ntype = PiecewiseConstantFromCSV\nread_prop_user_object = 'reader_nearest'\nread_type = 'voronoi'\ncolumn_number = '3'\n[]\n[]\nAnd added in the temperature aux variable:\n[AuxKernels]\n[set_temp]\nvariable = temp\ntype = FunctionAux\nfunction = temp_nearest #temp_function\n[]\n[]\nBut I don't see the temperature getting input.\nMeanwhile, I was also looking at the PropertyReadFile.C but and saw some \"voronoi\" options which I am not sure what to do when I don't have a polygonized grain structure but rather a simple block geometry.",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6178853",
                          "updatedAt": "2023-06-14T20:09:30Z",
                          "publishedAt": "2023-06-14T20:09:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is wrong\nnvoronoi = 1\n\nyou have plenty of nearest point regions, you need to have the number of CSV rows as the nvoronoi",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6178889",
                          "updatedAt": "2023-06-14T20:14:49Z",
                          "publishedAt": "2023-06-14T20:14:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Tried but it did not work. I am attaching the full input file:\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 20\n  ny = 20\n  nz = 20\n  xmin = 0.0\n  xmax = 1.0\n  ymin = 0.0\n  ymax = 1.0\n  zmin = 0.0\n  zmax = 1.0\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[UserObjects]\n  [reader_nearest]\n    type = PropertyReadFile\n    prop_file_name = 'temperature_ansys_modified.csv'\n    read_type = 'voronoi'\n    nprop = 1\n    nvoronoi = 9261\n  []\n[]\n\n[Functions]\n  [./topfunc]\n    type = ParsedFunction\n    value = '1e-4*t' # ramped displacement BC\n  [../]\n\n  [temp_nearest]\n    type = PiecewiseConstantFromCSV\n    read_prop_user_object = 'reader_nearest'\n    read_type = 'voronoi'\n    column_number = '3'\n  []\n  \n[]\n\n[BCs]\n\n  [./bot_fix_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0\n  [../]\n\n  [./top_disp_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'top'\n    function = topfunc\n  [../]\n\n  [./left_fix_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left'\n    value = 0\n  [../]\n\n  [./front_fix_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'front'\n    value = 0\n  [../]\n\n[]\n\n[Modules/TensorMechanics/Master/All]\n  strain = FINITE\n  incremental = true\n  add_variables = true\n  temperature = temp\n  eigenstrain_names = eigenstrain  \n  generate_output = 'stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx'\n  use_automatic_differentiation = false\n[]\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 150e9\n    poissons_ratio = 0.3\n  []\n\n  [./stress]\n    type = ComputeFiniteStrainElasticStress\n  [../]\n\n  [./thermal_expansion_strain]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 1.0e-4\n    stress_free_temperature = 100.0\n    temperature = temp\n    eigenstrain_name = eigenstrain\n  [../]\n\n[]\n\n\n[AuxVariables]\n  [temp]\n    order  = FIRST\n    family = LAGRANGE\n  []\n\n[]\n\n[AuxKernels]\n  [set_temp]\n     variable = temp\n     type = FunctionAux\n     function = temp_nearest \n  []\n[]\n\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = 'Newton'\n\n  start_time = 0.0\n  dt    = 0.1\n  dtmax = 1.0\n  dtmin = 1e-31\n  nl_abs_tol = 1e-6\n  end_time = 0.1\n []\n\n[Outputs]\n  print_linear_residuals = true\n  perf_graph = true\n  csv = true\n  [./out]\n    type = Exodus\n    elemental_as_nodal = true\n  [../]\n  [./console]\n    type = Console\n    max_rows = 100\n  [../]\n[]\n\nAnd my csv file has 9261 rows which are the total number of nodes in my block.",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6179106",
                          "updatedAt": "2023-06-14T21:16:30Z",
                          "publishedAt": "2023-06-14T20:44:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does it look like now?",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6179342",
                          "updatedAt": "2023-06-14T21:16:21Z",
                          "publishedAt": "2023-06-14T21:16:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "The temperature is still zero",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6179383",
                          "updatedAt": "2023-06-14T21:22:16Z",
                          "publishedAt": "2023-06-14T21:22:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "variable = temp\n     type = FunctionAux\n     function = temp_nearest \n     execute_on = INITIAL\n  []\n\nor even better, use a FunctionIC",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6179424",
                          "updatedAt": "2023-06-14T21:30:38Z",
                          "publishedAt": "2023-06-14T21:30:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "the execute_on = Initial did not work (still getting zero temp); will try FunctionIC next",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6179454",
                          "updatedAt": "2023-06-14T21:36:22Z",
                          "publishedAt": "2023-06-14T21:36:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Hi @GiudGiud I tried IC, but it seems it is not even reading anything from the input file, and I am still getting zero temperatures. I am attaching the input file and the csv, could you please see if there is something wrong with the csv format ?\ntemperature_ansys_modified.csv\nThe corresponding MOOSE input:\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 20\n  ny = 20\n  nz = 20\n  xmin = 0.0\n  xmax = 1.0\n  ymin = 0.0\n  ymax = 1.0\n  zmin = 0.0\n  zmax = 1.0\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[UserObjects]\n  [reader_nearest]\n    type = PropertyReadFile\n    prop_file_name = 'temperature_ansys_modified.csv'\n    read_type = 'voronoi'\n    nprop = 1\n    nvoronoi = 9261\n  []\n[]\n\n[Functions]\n  [./topfunc]\n    type = ParsedFunction\n    value = '1e-4*t' # ramped displacement BC\n  [../]\n\n  [temp_nearest]\n    type = PiecewiseConstantFromCSV\n    read_prop_user_object = 'reader_nearest'\n    read_type = 'voronoi'\n    column_number = '3'\n  []\n  \n[]\n\n[BCs]\n\n  [./bot_fix_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0\n  [../]\n\n  [./top_disp_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'top'\n    function = topfunc\n  [../]\n\n  [./left_fix_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left'\n    value = 0\n  [../]\n\n  [./front_fix_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'front'\n    value = 0\n  [../]\n\n[]\n\n[ICs]\n  [nearest]\n    type = FunctionIC\n    variable = 'temp'\n    function = 'temp_nearest'\n  []\n\n[]\n\n\n[Modules/TensorMechanics/Master/All]\n  strain = FINITE\n  incremental = true\n  add_variables = true\n  temperature = temp\n  eigenstrain_names = eigenstrain  \n  generate_output = 'stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx'\n  use_automatic_differentiation = false\n[]\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 150e9\n    poissons_ratio = 0.3\n  []\n\n  [./stress]\n    type = ComputeFiniteStrainElasticStress\n  [../]\n\n  [./thermal_expansion_strain]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 1.0e-4\n    stress_free_temperature = 100.0\n    temperature = temp\n    eigenstrain_name = eigenstrain\n  [../]\n\n[]\n\n\n[AuxVariables]\n  [temp]\n    order  = FIRST\n    family = LAGRANGE\n  []\n\n[]\n\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = 'Newton'\n\n  start_time = 0.0\n  dt    = 0.1\n  dtmax = 1.0\n  dtmin = 1e-31\n  nl_abs_tol = 1e-6\n  end_time = 0.1\n []\n\n[Outputs]\n  print_linear_residuals = true\n  perf_graph = true\n  csv = true\n  [./out]\n    type = Exodus\n    elemental_as_nodal = true\n  [../]\n  [./console]\n    type = Console\n    max_rows = 100\n  [../]\n[]\n\n\nDoes something seem off ?",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6186126",
                          "updatedAt": "2023-06-15T16:35:01Z",
                          "publishedAt": "2023-06-15T13:01:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nSorry for the delay.\nSomething is off indeed, only the first column is being read.\nI ll try to fix this\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6190313",
                          "updatedAt": "2023-06-15T20:23:21Z",
                          "publishedAt": "2023-06-15T20:23:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "No worries at all @GiudGiud ! Thank you so much for looking into it!! Really appreciate it!\n-Aritra",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6190566",
                          "updatedAt": "2023-06-15T21:00:53Z",
                          "publishedAt": "2023-06-15T21:00:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Changing boundary condition",
          "author": {
            "login": "deepakbiitk"
          },
          "bodyText": "Hello MOOSE users,\nI am solving heat equation in a rectangular domain, In my left, bottom and top boundary I have insulated bc and in the right boundary I have convection bc for few time steps after which I would like to change it to DirichletBC for the rest of my simulation. Is it possible to achieve in a single input file or do I need to use the restart feature?\nThanks,\nDeepak",
          "url": "https://github.com/idaholab/moose/discussions/24715",
          "updatedAt": "2023-06-16T01:23:29Z",
          "publishedAt": "2023-06-15T23:58:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPlease see this thread\n#24596\nYou ll want to use the Control system to try to do this.\nIf it doesnt work, then restart will be the way\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24715#discussioncomment-6191524",
                  "updatedAt": "2023-06-16T00:07:37Z",
                  "publishedAt": "2023-06-16T00:07:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "deepakbiitk"
                          },
                          "bodyText": "Hi Guillaume,\nUse of control system worked  in this case. I appreciate your suggestion.\nDeepak",
                          "url": "https://github.com/idaholab/moose/discussions/24715#discussioncomment-6191856",
                          "updatedAt": "2023-06-16T01:23:27Z",
                          "publishedAt": "2023-06-16T01:23:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "An advection simulation problem",
          "author": {
            "login": "Wolke926"
          },
          "bodyText": "I'm a new MOOSE user currently trying to use an advection kernel to simulate a simple rigid body motion process for a sphere. The result I expect is that the ball does not change its shape and moves to the right, but the result is that the shape of the sphere changes and it appears to diffuse. Thank you very much for someone who can answer my question.\nThe source code has been put here.\n[Mesh]\n  [gen_mesh]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 20\n    ymin = 0\n    ymax = 20\n    nx = 40\n    ny = 40\n  []\n[]\n\n[Variables]\n  [c]\n  []\n[]\n\n[ICs]\n\n  [./c]\n    type = SpecifiedSmoothCircleIC           \n    invalue = 1.0\n    outvalue = 0.0\n    int_width = 2.0\n    x_positions = '4 '\n    y_positions = '4 '\n    z_positions = '0.0 '\n    radii       = '2' \n    variable = c\n    [../]\n  \n[]\n\n[Kernels]\n  [advection]\n    type = ConservativeAdvection\n    variable = c\n    velocity = '2 0 0'\n    upwinding_type = full\n  []\n\n  [time]\n    type = TimeDerivative\n    variable = c\n  []\n[]\n\n[BCs]\n [./allow_mass_out]\n  type = OutflowBC\n  boundary = right\n  variable = c\n  velocity = '2 0 0'\n[../]\n   [./injection_left]\n    type = InflowBC\n    boundary = left\n    variable = c\n    velocity = '2 0 0'\n    inlet_conc = 0\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  petsc_options = '-snes_converged_reason'\n  num_steps = 30\n  dt = 0.2\n  nl_rel_tol = 1e-12\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24451",
          "updatedAt": "2023-06-24T19:48:40Z",
          "publishedAt": "2023-05-23T15:45:06Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is probably just some numerical diffusivity from the upwinding scheme.\nCould you please try to refine the mesh to quantify the effect on the shape of the advected object?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5980390",
                  "updatedAt": "2023-05-23T16:22:37Z",
                  "publishedAt": "2023-05-23T16:22:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "Thanks for your reply, I just tried to refine the mesh, but the result doesn't change. Do you think it is related to the boundary condition I am using?",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5981180",
                          "updatedAt": "2023-05-23T17:49:11Z",
                          "publishedAt": "2023-05-23T17:49:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "maybe from the coarse time scheme then?\ncan you try bdf2 for the scheme and/or a finer time grid",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5981338",
                          "updatedAt": "2023-05-23T18:08:43Z",
                          "publishedAt": "2023-05-23T18:08:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "I modified the time step to be smaller (dt = 0.05) and added TimeIntegrator bdf2. This time the result has been improved, but there is still a tendency to diffuse. Should I delete the unwinding term to avoid the numerical diffusivity? Is Full upwinding necessary for advection/convection problems?",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5981816",
                          "updatedAt": "2023-05-23T19:07:45Z",
                          "publishedAt": "2023-05-23T19:07:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If the solution is sufficiently smooth then upwinding is not necessary. TVD schemes are meant to provide upwinding when necessary and fall back to second order central differencing/averaging when the solution is sufficiently smooth",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5982076",
                          "updatedAt": "2023-05-23T19:42:20Z",
                          "publishedAt": "2023-05-23T19:42:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "You could try with upwinding_type = none and see whether you experience any oscillations",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5982081",
                          "updatedAt": "2023-05-23T19:43:13Z",
                          "publishedAt": "2023-05-23T19:43:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "I tried, the illustration looks even better, the diffusion almost disappears, although one side of the sphere shape shows some oscillations.",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5982357",
                          "updatedAt": "2023-05-23T20:26:11Z",
                          "publishedAt": "2023-05-23T20:26:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "that's the trade-off. You could try to introduce something like min-mod or van Leer into that class if you wanted to see whether you could get a better blend",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5982368",
                          "updatedAt": "2023-05-23T20:28:16Z",
                          "publishedAt": "2023-05-23T20:28:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "You can also check some capabilities in Level set module which deals with pure advection equations.\nSee https://mooseframework.inl.gov/modules/level_set/example_circle.html",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5982399",
                          "updatedAt": "2023-05-23T20:33:11Z",
                          "publishedAt": "2023-05-23T20:33:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "It sounds like you are trying to advect a sharp interface (the edge of the sphere) which is a notoriously difficult problem. As @jiangwen84 pointed out Level Set is a good bet, and probably your best bet if you just want to advect an interface. You will have to accept the trade off cost of doing some reinitialisation (either PDE based or fast marching, I have done both in MOOSE). You could also look at a Volume of Fluid/Solid approach and then you will need some stabilisation scheme, for example look at KT stabilisation in the Porous Flow module (not sure if that can be used outside of porous flow easily), there are lots of other methods but no golden bullet. Do you need to couple the rigid body motion with other physics?\nIf you want something that works straight out of the box for pure advection, the level set module is the best place to start.",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5986508",
                          "updatedAt": "2023-05-24T08:11:10Z",
                          "publishedAt": "2023-05-24T08:11:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We also have pure scalar advection implemented using finite-volume/rDG through the FVAdvection finite volume kernel. I am adding more interpolation types in #24468 (previously only upwind and weighted averaging)",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5992360",
                          "updatedAt": "2023-05-24T16:52:42Z",
                          "publishedAt": "2023-05-24T16:52:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Broken mesh from xda files",
          "author": {
            "login": "favinom"
          },
          "bodyText": "Hi all,\nI am trying to do the following:\n\ncall BreakMeshByBlockGenerator on a mesh\nsave the mesh in an xda file\nread the mesh from the xda file in another script\n\nThe problem is that the mesh read from xda does not \"see\" the interfaces.\nI think this is due to the fact that the neighboring map has been lost in the xda file.\nIs there a way to read a broken mesh with the correct interfaces?\nThanks\nMarco",
          "url": "https://github.com/idaholab/moose/discussions/24700",
          "updatedAt": "2023-06-24T22:09:45Z",
          "publishedAt": "2023-06-15T07:34:03Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nxda might be losing some information\nLet's check by trying with another mesh format type : exodus for example\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24700#discussioncomment-6188217",
                  "updatedAt": "2023-06-19T17:43:49Z",
                  "publishedAt": "2023-06-15T16:14:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Moving Heat Source",
          "author": {
            "login": "nourriahi"
          },
          "bodyText": "Hello everyone,\nI am using 3d heat conduction module with ellipsoid path function to generate a moving heat source that moves along my y axis in function of time, unfortunately the heat source is stable and fixed only in one position. any suggestions how to make the heat source mobile in the y direction?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/24704",
          "updatedAt": "2023-06-15T15:31:43Z",
          "publishedAt": "2023-06-15T14:53:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "nourriahi"
                  },
                  "bodyText": "it works now, I needed to increase the speed of the heat source",
                  "url": "https://github.com/idaholab/moose/discussions/24704#discussioncomment-6187770",
                  "updatedAt": "2023-06-15T15:31:10Z",
                  "publishedAt": "2023-06-15T15:31:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "moose not stop at the last step",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Today i use a timestep like this\n[Executioner]\n   type = Transient\n   slove_type = 'PJFNK'\n   dt = 0.01\n   end_time = 200\n[]\n\nthe slove Converage.show bellow\nbut, the weird thing happend\n\nwhat is the reason?\nThanks for you help.",
          "url": "https://github.com/idaholab/moose/discussions/24701",
          "updatedAt": "2023-06-15T12:45:05Z",
          "publishedAt": "2023-06-15T12:16:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can slightly increase the timestep_tolerance. See https://mooseframework.inl.gov/source/executioners/Transient.html",
                  "url": "https://github.com/idaholab/moose/discussions/24701#discussioncomment-6185827",
                  "updatedAt": "2023-06-15T12:32:12Z",
                  "publishedAt": "2023-06-15T12:32:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "wangzhaohao"
                  },
                  "bodyText": "I increase the timstep_tolerance  it works. Thanks!",
                  "url": "https://github.com/idaholab/moose/discussions/24701#discussioncomment-6185969",
                  "updatedAt": "2023-06-15T12:45:06Z",
                  "publishedAt": "2023-06-15T12:45:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Array kernel with coupled array variable",
          "author": {
            "login": "gabburgio"
          },
          "bodyText": "Hello everybody,\nAs the title says, I've been trying to implement an array kernel with coupled array variable (this would describe the production of delayed neutrons in radiation transport, the coupled array variable containing the concentration of the various precursor groups, and the array variable being the multigroup neutron flux).\nI am encountering some difficulties with adding the dependency to the coupled array variable.\nThis is what my class looks like:\n\n#include \"PrecursorDecay.h\"\n\nregisterMooseObject(\"pertApp\", PrecursorDecay);\n\nInputParameters\nPrecursorDecay::validParams()\n{\n  InputParameters params = ArrayKernel::validParams();\n  params.addRequiredParam<MaterialPropertyName>(\n      \"decay_constants\",\n      \"The array containing the values of the decay constants of the various groups.\");\n  params.addRequiredParam<MaterialPropertyName>(\n      \"delayed_spectrum\",\n      \"The array containing the average (multigroup) energy spectrum of delayed neutrons.\");\n\n  params.addRequiredCoupledVar(\"concentrations\",\n                               \"The array variable holding the concentrations of the precursors\");\n  \n  return params;\n}\n\nPrecursorDecay::PrecursorDecay(const InputParameters & parameters)\n  : ArrayKernel(parameters),\n    _decay_constants(&getMaterialProperty<RealEigenVector>(\"decay_constants\")),\n    _delayed_spectrum(&getMaterialProperty<RealEigenVector>(\"delayed_spectrum\")),\n    MooseVariableInterface<RealEigenVector>(\n        this, false, \"concentrations\", Moose::VarKindType::VAR_ANY, Moose::VarFieldType::VAR_FIELD_ARRAY),\n    _concentrations(coupledArrayValue(\"concentrations\"))    \n\n{\n  addMooseVariableDependency(\"The mooseVariableField associated with the _concentrations variable\" );\n}\n\n\nvoid\nPrecursorDecay::computeQpResidual(RealEigenVector & residual)\n{\nresidual.noalias() = ((*_decay_constants)[_qp].dot(_concentrations[_qp]) * (*_delayed_spectrum)[_qp])\n* _test[_i][_qp];\n}\n\n\n\n\nI don't really understand how to reference the mooseVariableField associated with the _concentrations variable, and my attemps to do so enounter an error:\nwarning: direct base 'MooseVariableInterface<Eigen::Matrix<double, -1, 1> >' inaccessible in 'PrecursorDecay' due to ambiguity [-Winaccessible-base]\n    9 | class PrecursorDecay : public ArrayKernel,\n      |       ^~~~~~~~~~~~~~\nIn file included from /u/halle/burgio/home_at/projects/pert/build/unity_src/kernels_Unity.C:2:\n/u/halle/burgio/home_at/projects/pert/src/kernels/PrecursorDecay.C: In constructor 'PrecursorDecay::PrecursorDecay(const InputParameters&)':\n/u/halle/burgio/home_at/projects/pert/src/kernels/PrecursorDecay.C:31:91: error: 'MooseVariableInterface<Eigen::Matrix<double, -1, 1> >' is an ambiguous base of 'PrecursorDecay'\n\n\n\n\nWhich should be due to the fact that there already is a MooseVariableInterface for the array variable that is naturally associated with the array kernel I'm trying to extend.\nAny advice on how to fix this?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/24685",
          "updatedAt": "2023-06-14T17:00:49Z",
          "publishedAt": "2023-06-14T14:59:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you please paste your header as well?\nI wonder if \"ambiguous base\" is just pointing to a diamond inheritance issue\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6176439",
                  "updatedAt": "2023-06-14T15:29:14Z",
                  "publishedAt": "2023-06-14T15:29:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "gabburgio"
                  },
                  "bodyText": "Of course, here it is:\n#pragma once\n\n#include \"ArrayKernel.h\"\n#include \"MooseVariableInterface.h\"\n\n\n\nclass PrecursorDecay : public ArrayKernel,\n                      public MooseVariableInterface<RealEigenVector>\n{\npublic:\n  static InputParameters validParams();\n\n  PrecursorDecay(const InputParameters & parameters);\n\nprotected:\n  virtual void computeQpResidual(RealEigenVector & residual) override;\n  \n  const MaterialProperty<RealEigenVector> * const _decay_constants;\n  const MaterialProperty<RealEigenVector> * const _delayed_spectrum;\n  \n\n  const ArrayVariableValue & _concentrations;\n\n  \n};",
                  "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6176488",
                  "updatedAt": "2023-06-14T15:33:23Z",
                  "publishedAt": "2023-06-14T15:33:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so if you look at the Array kernel header you can see this:\nclass ArrayKernel : public KernelBase, public MooseVariableInterface<RealEigenVector>\n\nso your PrecursorDecay is inheriting the MooseVariableInterface<RealEigenVector> twice, and that's disallowed (called diamond inheritance)\njust do:\nclass PrecursorDecay : public ArrayKernel",
                          "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6176579",
                          "updatedAt": "2023-06-14T15:41:08Z",
                          "publishedAt": "2023-06-14T15:41:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gabburgio"
                          },
                          "bodyText": "Thanks for the pointer.\nBy doing that, I get the error:\n\nerror: type 'MooseVariableInterface<Eigen::Matrix<double, -1, 1> >' is not a direct base of 'PrecursorDecay'\n   26 |     MooseVariableInterface<RealEigenVector>(\n\n\nWhich is why I had added it in the first place.\nI now understand why it shouldn't be there, but not why I still get this error (I assume I should be able to instantiate an object of a class simply by including the header).\nDoes it have anything to do with the fact that I'm not assigning the MooseVariableInterface to some class attribute?\nThanks for your time",
                          "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6177354",
                          "updatedAt": "2023-06-14T16:50:01Z",
                          "publishedAt": "2023-06-14T16:50:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "PrecursorDecay::PrecursorDecay(const InputParameters & parameters)\n  : ArrayKernel(parameters),\n    _decay_constants(&getMaterialProperty<RealEigenVector>(\"decay_constants\")),\n    _delayed_spectrum(&getMaterialProperty<RealEigenVector>(\"delayed_spectrum\")),\n    _concentrations(coupledArrayValue(\"concentrations\"))    \n\n\nyou need to remove it from the constructor like this too",
                          "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6177369",
                          "updatedAt": "2023-06-14T16:51:29Z",
                          "publishedAt": "2023-06-14T16:51:29Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gabburgio"
                          },
                          "bodyText": "Of course, thanks a lot!",
                          "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6177437",
                          "updatedAt": "2023-06-14T17:00:50Z",
                          "publishedAt": "2023-06-14T17:00:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to apply a LineLoad on a line or at a boundary",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hello,\nI know there is a way of applying a point load as a Dirac force in MOOSE. But is there a way of applying a line load that can or can not be applied on nodes?",
          "url": "https://github.com/idaholab/moose/discussions/24669",
          "updatedAt": "2023-06-23T16:11:20Z",
          "publishedAt": "2023-06-13T16:05:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhich dimension is the mesh/system?\nIs the line on the boundary or inside the domain?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6166068",
                  "updatedAt": "2023-06-13T17:10:21Z",
                  "publishedAt": "2023-06-13T17:10:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I need it for any dimension. I would be needing it for both inside the domain, and on a boundary",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6166194",
                          "updatedAt": "2023-06-13T17:22:13Z",
                          "publishedAt": "2023-06-13T17:22:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So 2D and 3D?\nFor a boundary, then you can use boundary conditions to apply a load on a line in 2D",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6166204",
                          "updatedAt": "2023-06-13T17:24:00Z",
                          "publishedAt": "2023-06-13T17:23:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Thank you.\nHow about inside a domain?",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6166621",
                          "updatedAt": "2023-06-13T18:19:03Z",
                          "publishedAt": "2023-06-13T18:19:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "good question\n@cpgr @rpodgorney do you ever do that for porous flow?",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6167351",
                          "updatedAt": "2023-06-13T20:05:33Z",
                          "publishedAt": "2023-06-13T20:05:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Can you make an internal 'boundary' using ExtraNodesetGenerator and then apply a BC internally? I've done that before.",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6168173",
                          "updatedAt": "2023-06-13T22:27:45Z",
                          "publishedAt": "2023-06-13T22:27:43Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rpodgorney"
                          },
                          "bodyText": "I\u2019ve never used a line, tagging @lynnmunday as he may have other approaches for this",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6175421",
                          "updatedAt": "2023-06-14T13:58:34Z",
                          "publishedAt": "2023-06-14T13:58:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "You can specify a series of load points as coordinates in a reporter and then use the https://mooseframework.inl.gov/source/dirackernels/ReporterPointSource.html\nYou can read the points into the reporterPointSource from a csv file.",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6176348",
                          "updatedAt": "2023-06-14T15:20:52Z",
                          "publishedAt": "2023-06-14T15:20:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Can you distribute the line load into a series of load points? If so, you can either use @lynnmunday 's Reporter approach, or directly provide a vector of points in the DiracKernel.",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6176483",
                          "updatedAt": "2023-06-14T15:33:00Z",
                          "publishedAt": "2023-06-14T15:33:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unknown output, possibly an error",
          "author": {
            "login": "Nabiel-Abuyazid"
          },
          "bodyText": "Could someone help me understand whether there is an error or not? I am unsure of whether this should be an output when running a calculation.\nStack frames: 11\n0: 0   libmesh_opt.0.dylib                 0x0000000107c1b718 libMesh::print_trace(std::__1::basic_ostream<char, std::__1::char_traits<char>>&) + 1044\n1: 1   libmoose-opt.0.dylib                0x0000000104854c30 moose::internal::mooseErrorRaw(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>) + 680\n2: 2   libmoose-opt.0.dylib                0x00000001047d12a0 callMooseErrorRaw(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>&, MooseApp*) + 100\n3: 3   libmoose-opt.0.dylib                0x00000001040062e0 void MooseObject::mooseError<char const (&) [61]>(char const (&) [61]) const + 328\n4: 4   libmoose-opt.0.dylib                0x00000001042f6740 IterationAdaptiveDT::computeFailedDT() + 496\n5: 5   libmoose-opt.0.dylib                0x00000001042efd04 TimeStepper::computeStep() + 152\n6: 6   libmoose-opt.0.dylib                0x0000000103bd2cf4 Transient::execute() + 120\n7: 7   libmoose-opt.0.dylib                0x000000010482c578 MooseApp::executeExecutioner() + 268\n8: 8   libmoose-opt.0.dylib                0x00000001048287f8 MooseApp::run() + 1428\n9: 9   combined-opt                        0x00000001004a7b4c main + 164\n10: 10  dyld                                0x000000018b783f28 start + 2236\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor",
          "url": "https://github.com/idaholab/moose/discussions/24670",
          "updatedAt": "2023-06-24T22:14:58Z",
          "publishedAt": "2023-06-13T16:13:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthis looks like an error that is thrown when the solves failed too many times and time step is almost zero.\nplease post the entire console log so we can confirm\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24670#discussioncomment-6166058",
                  "updatedAt": "2023-06-13T17:08:56Z",
                  "publishedAt": "2023-06-13T17:08:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Nabiel-Abuyazid"
                          },
                          "bodyText": "Hi Guillaume,\nHere it is:\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 150\n 1 Nonlinear |R| = 1.141181e+42\nNonlinear solve did not converge due to DIVERGED_DTOL iterations 1\n Solve Did NOT Converge!\nAborting as solve did not converge\n\n\n*** ERROR ***\nThe following error occurred in the object \"ConstantDT\", of type \"ConstantDT\".\n\nSolve failed and timestep already at or below dtmin, cannot continue!\n\nStack frames: 11\n0: 0   libmesh_opt.0.dylib                 0x000000010802b718 libMesh::print_trace(std::__1::basic_ostream<char, std::__1::char_traits<char>>&) + 1044\n1: 1   libmoose-opt.0.dylib                0x0000000104c64c30 moose::internal::mooseErrorRaw(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>) + 680\n2: 2   libmoose-opt.0.dylib                0x0000000104be12a0 callMooseErrorRaw(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>&, MooseApp*) + 100\n3: 3   libmoose-opt.0.dylib                0x0000000103ea212c void MooseObject::mooseError<char const (&) [70]>(char const (&) [70]) const + 328\n4: 4   libmoose-opt.0.dylib                0x0000000104703b2c AB2PredictorCorrector::~AB2PredictorCorrector() + 0\n5: 5   libmoose-opt.0.dylib                0x00000001046ffd04 TimeStepper::computeStep() + 152\n6: 6   libmoose-opt.0.dylib                0x0000000103fe2cf4 Transient::execute() + 120\n7: 7   libmoose-opt.0.dylib                0x0000000104c3c578 MooseApp::executeExecutioner() + 268\n8: 8   libmoose-opt.0.dylib                0x0000000104c387f8 MooseApp::run() + 1428\n9: 9   combined-opt                        0x00000001008b7b4c main + 164\n10: 10  dyld                                0x000000018b783f28 start + 2236\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor",
                          "url": "https://github.com/idaholab/moose/discussions/24670#discussioncomment-6166506",
                          "updatedAt": "2023-06-13T18:04:44Z",
                          "publishedAt": "2023-06-13T18:04:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The message is explicit.\nYou need to fix your solve.\nPlease follow this documentation page\nhttps://mooseframework.inl.gov/application_usage/failed_solves.html",
                          "url": "https://github.com/idaholab/moose/discussions/24670#discussioncomment-6166836",
                          "updatedAt": "2023-06-13T18:50:20Z",
                          "publishedAt": "2023-06-13T18:50:19Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Looking for some Moose classes",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hello,\nPlease where can I get the following Moose classes:\nVariableComponent, VariableTestComponent, and VariablePhiGradient  with objects _grad_u, _grad_v, and _grad_v_phi  respectively. This is because  I would like to see how the shape functions of their respective objects are computed. If I can see that, I can probably modify it to what I what. In addition, I would be needing that of MooseArray too to understand how the object _q_point is computed.\nI have used things like git grep VariableGradient, git grep VariableTestGradient, and git grep VariablePhiGradient and I still can't find it",
          "url": "https://github.com/idaholab/moose/discussions/24647",
          "updatedAt": "2023-06-24T22:09:36Z",
          "publishedAt": "2023-06-09T16:49:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont think they are input file objects (MooseObjects). They are just part of the code.\nYou need to look at the doxygen to understand there things I think.\nHere's the link for MooseArray\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classMooseArray.html\nYou can search for any class there\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24647#discussioncomment-6136543",
                  "updatedAt": "2023-06-09T20:13:10Z",
                  "publishedAt": "2023-06-09T20:13:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I got the following in the elem.C file:\n  const FEType fe_type(this->default_order(), mapping_family);\n\n  // Build FE and attach quadrature rule.  The default quadrature rule\n  // integrates the mass matrix exactly, thus it is overkill to\n  // integrate the basis functions, but this is convenient.\n  std::unique_ptr<FEBase> fe = FEBase::build(this->dim(), fe_type);\n  QGauss qrule (this->dim(), fe_type.default_quadrature_order());\n  fe->attach_quadrature_rule(&qrule);\n\n  // Pre-request required data\n  const auto & JxW = fe->get_JxW();\n  const auto & phi = fe->get_phi();\n\n  // Re-compute element-specific values\n  fe->reinit(this);\n\n  // Number of basis functions\n  auto N = phi.size();\n  libmesh_assert_equal_to(N, this->n_nodes());\n\nAnd the following from the fe.C file:\n  // Most of the hard work happens when we have an actual element\n  if (elem)\n    {\n      // Initialize the shape functions at the user-specified\n      // points\n      if (pts != nullptr)\n        {\n          // Set the type and p level for this element\n          this->elem_type = elem->type();\n          this->_p_level = elem->p_level();\n\n          // Initialize the shape functions\n          this->_fe_map->template init_reference_to_physical_map<Dim>\n            (*pts, elem);\n          this->init_shape_functions (*pts, elem);\n\n          // The shape functions do not correspond to the qrule\n          this->shapes_on_quadrature = false;\n        }\n\n      // If there are no user specified points, we use the\n      // quadrature rule\n\n      // update the type in accordance to the current cell\n      // and reinit if the cell type has changed or (as in\n      // the case of the hierarchics) the shape functions need\n\n...\n\nNow, how do I get to where the shape functions are ACTUALLY computed/implemented?",
                          "url": "https://github.com/idaholab/moose/discussions/24647#discussioncomment-6154941",
                          "updatedAt": "2023-06-12T17:17:16Z",
                          "publishedAt": "2023-06-12T17:17:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You should keep digging in libmesh.\nA lot of the shapes are here I think:\nhttps://mooseframework.inl.gov/docs/doxygen/libmesh/fe__bernstein__shape__1D_8C_source.html#l00193",
                          "url": "https://github.com/idaholab/moose/discussions/24647#discussioncomment-6156047",
                          "updatedAt": "2023-06-12T19:28:35Z",
                          "publishedAt": "2023-06-12T19:28:35Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "So I was trying to dig even more deeper in the libmesh and I found how the Jacobian is multiplied by the weights in the Assembly.C, as given below:\n // references to the quadrature points and weights\n  const std::vector<Real> & JxW = fe->get_JxW();\n  const std::vector<Point> & q_points = fe->get_xyz();\n\nI tried git grep get_JxW, to track where exactly the function is implemented, but all I see is a bunch of pointers\nframework/src/base/Assembly.C:    (*_holder_fe_helper[dim])->get_JxW();\nframework/src/base/Assembly.C:    (*_holder_fe_face_helper[dim])->get_JxW();\nframework/src/base/Assembly.C:    (*_holder_fe_face_neighbor_helper[dim])->get_JxW();\nframework/src/base/Assembly.C:    (*_holder_fe_neighbor_helper[dim])->get_JxW();\nframework/src/base/Assembly.C:    (*_holder_fe_lower_helper[dim])->get_JxW();\nframework/src/base/Assembly.C:  _JxW_msm = &_fe_msm->get_JxW();\nframework/src/base/Assembly.C:  _current_JxW.shallowCopy(const_cast<std::vector<Real> &>((*_holder_fe_helper[dim])->get_JxW()));\nframework/src/base/Assembly.C:      const_cast<std::vector<Real> &>((*_holder_fe_face_helper[dim])->get_JxW()));\nframework/src/base/Assembly.C:    const std::vector<Real> & JxW = fe.get_JxW();\n...\n\nHow do I see this get_JxW function?",
                          "url": "https://github.com/idaholab/moose/discussions/24647#discussioncomment-6166156",
                          "updatedAt": "2023-06-13T17:17:50Z",
                          "publishedAt": "2023-06-13T17:17:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "https://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1FEAbstract.html#afb4de89b31f40d5532ed85da806e2d2e\ndigging around the fdoxygen is the way to go",
                          "url": "https://github.com/idaholab/moose/discussions/24647#discussioncomment-6166199",
                          "updatedAt": "2023-06-13T17:23:16Z",
                          "publishedAt": "2023-06-13T17:23:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}