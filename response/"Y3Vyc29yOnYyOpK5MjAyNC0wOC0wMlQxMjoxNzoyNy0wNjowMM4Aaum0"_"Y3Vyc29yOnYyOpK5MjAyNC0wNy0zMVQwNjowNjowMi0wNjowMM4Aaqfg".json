{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wNy0zMVQwNjowNjowMi0wNjowMM4Aaqfg"
    },
    "edges": [
      {
        "node": {
          "title": "< MPI_COMM_WORLD with errorcode 1>",
          "author": {
            "login": "dongcongcong606"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nDear friends, I have a question to consult.\nWhen I was learning according to the official MOOSE case, I could not run \u2018 the step01.i \u2019 file in the directory I customized, and the following error would be reported after running it.\nHowever, I was able to successfully run the \u2018step01.i\u2019 file in the original directory with the following results.\n(Optional) code in question / simulation log / errors\n(moose) paracs123@DESKTOP-ICLNLQV:~/projects/myfile/file009/solid_mechanics/step1$ ./solid_mechanics-opt -i mech_step01.i\n[DESKTOP-ICLNLQV:04197] mca_base_component_repository_open: unable to open mca_btl_openib: librdmacm.so.1: cannot open shared object file: No such file or directory (ignored)\n\n\n*** ERROR ***\n/home/paracs123/projects/myfile/file009/solid_mechanics/step1/mech_step01.i contains Windows(DOS) line endings which are not supported.\n\nStack frames: 10\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&)\n3: MooseUtils::checkFileReadable(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, bool, bool)\n4: Parser::parse()\n5: Moose::createMooseApp(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int, char**)\n6: ./solid_mechanics-opt(+0x20e0) [0x7f957b5f10e0]\n7: main\n8: __libc_start_main\n9: ./solid_mechanics-opt(+0x238b) [0x7f957b5f138b]\n--------------------------------------------------------------------------\nMPI_ABORT was invoked on rank 0 in communicator MPI_COMM_WORLD\nwith errorcode 1.\n\nNOTE: invoking MPI_ABORT causes Open MPI to kill all MPI processes.\nYou may or may not see output from other processes, depending on\nexactly when Open MPI kills them.\n--------------------------------------------------------------------------\n\n\n\n\n(moose) paracs123@DESKTOP-ICLNLQV:~/projects/moose/modules/solid_mechanics/tutorials/introduction$ ./solid_mechanics-opt -i mech_step01.i\n[DESKTOP-ICLNLQV:04078] mca_base_component_repository_open: unable to open mca_btl_openib: librdmacm.so.1: cannot open shared object file: No such file or directory (ignored)\n\n\n*** Info ***\nSolidMechanics Action: selecting 'total small strain' formulation. Use `incremental = true` to select 'incremental small strain' instead.\nFramework Information:\nMOOSE Version:           git commit 5fd5cc99b0 on 2024-07-27\nLibMesh Version:\nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1\nCurrent Time:            Thu Aug  1 16:59:40 2024\nExecutable Timestamp:    Thu Aug  1 16:42:53 2024\n\nCheckpoint:\n  Wall Time Interval:      Every 3600.000000 s\n  User Checkpoint:         Disabled\n  # Checkpoints Kept:      2\n  Execute On:              TIMESTEP_END\n\nParallelism:\n  Num Processors:          1\n  Num Threads:             1\n\nMesh:\n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   121\n  Elems:                   100\n  Num Subdomains:          1\n\nNonlinear System:\n  Num DOFs:                242\n  Num Local DOFs:          242\n  Variables:               { \"disp_x\" \"disp_y\" }\n  Finite Element Types:    \"LAGRANGE\"\n  Approximation Orders:    \"FIRST\"\n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  TimeIntegrator:          ImplicitEuler\n  Solver Mode:             Preconditioned JFNK\n\n\nTime Step 0, time = 0\n\nTime Step 1, time = 1, dt = 1\n 0 Nonlinear |R| = 0.000000e+00\n Solve Converged!\n\nTime Step 2, time = 2, dt = 1\n 0 Nonlinear |R| = 0.000000e+00\n Solve Converged!\n\nTime Step 3, time = 3, dt = 1\n 0 Nonlinear |R| = 0.000000e+00\n Solve Converged!\n\nTime Step 4, time = 4, dt = 1\n 0 Nonlinear |R| = 0.000000e+00\n Solve Converged!\n\nTime Step 5, time = 5, dt = 1\n 0 Nonlinear |R| = 0.000000e+00\n Solve Converged!\nWARNING! There are options you set that were not used!\nWARNING! could be spelling mistake, etc!\nThere is one unused database option. It is:\nOption left: name:-ksp_converged_reason value: ::failed source: code\nEncountering Errors? Please include diagnostic output\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/28278",
          "updatedAt": "2024-08-02T12:52:14Z",
          "publishedAt": "2024-08-01T09:22:40Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "You can see the difference between two files like so:\ndiff ~/projects/moose/modules/solid_mechanics/tutorials/introduction/mech_step01.i \\\n~/projects/myfile/file009/solid_mechanics/step1/mech_step01.i\nThe results on the screen will highlight the differences. Allowing you to understand why the first file is working, while the other file is not.",
                  "url": "https://github.com/idaholab/moose/discussions/28278#discussioncomment-10212188",
                  "updatedAt": "2024-08-01T12:41:13Z",
                  "publishedAt": "2024-08-01T12:41:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "/home/paracs123/projects/myfile/file009/solid_mechanics/step1/mech_step01.i contains Windows(DOS) line endings which are not supported.\n\nIf you use VSCode, you can ctrl+shift+P and convert the line endings.\nIf on linux you use dos2unix to change the line endings",
                          "url": "https://github.com/idaholab/moose/discussions/28278#discussioncomment-10223513",
                          "updatedAt": "2024-08-02T12:52:15Z",
                          "publishedAt": "2024-08-02T12:52:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to obtain the gradient matrix of the element, perform operations, and assemble the matrices?",
          "author": {
            "login": "tttsss-01"
          },
          "bodyText": "I want to calculate the $\\bar{\\mathbb{C}}$ as mentioned in the literature equation 31 and save its components in postprocessors.\n$\\bar{\\mathbb{C}}$ is the overall tangent modulus tensor, a four order tensor.\nI think I should follow equation 23 first, perform operations on the gradient matrices $\\boldsymbol{B}$ and $\\mathbb{C}$ of each element, and then assemble them to obtain $\\boldsymbol{K}$ and $\\boldsymbol{L}$.\nI am uncertain about how to do the following:\n\nHow to obtain the gradient matrix $\\boldsymbol{B}$ for each element, and what methods can be used to call $\\boldsymbol{B}$?\nHow to assemble the results calculated for each element.\nWhich class do these matrices belong to, and what existing methods do they have for operations?\n\nThank you very much for any assistance or guidance!",
          "url": "https://github.com/idaholab/moose/discussions/28243",
          "updatedAt": "2024-08-02T12:27:35Z",
          "publishedAt": "2024-07-27T21:37:53Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nwe do not form B currently afaik,  but kernels can access _test and its gradient for the currently considered test function.\nYou can look at Assembly.h for all the finite element arrays (shape, test functions, gradients etc) you can have access to\n\nHow to assemble the results calculated for each element.\n\nyou will want to unroll the loop essentially, so the residual is assembled in a moose-like manner for a given test function\n(see the section of the tutorial on kernels)",
                  "url": "https://github.com/idaholab/moose/discussions/28243#discussioncomment-10184470",
                  "updatedAt": "2024-07-31T09:27:20Z",
                  "publishedAt": "2024-07-29T22:41:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tttsss-01"
                          },
                          "bodyText": "Thank you for your help. I reviewed how things are done in the kernel. I noticed that in StressDivergenceTensors and TotalLagrangianStressDivergenceBase, $\\boldsymbol{B}^T \\mathbb{C} \\boldsymbol{B}$  is computed at each quadrature point. For example, in TotalLagrangianStressDivergenceBase, I think this function returns the $\\boldsymbol{B}^T \\mathbb{C} \\boldsymbol{B}$ at the quadrature points:\ntemplate <class G>\nReal\nTotalLagrangianStressDivergenceBase<G>::computeQpJacobianDisplacement(unsigned int alpha,\n                                                                      unsigned int beta)\n{\n  // J_{alpha beta} = phi^alpha_{i, J} T_{iJkL} G^beta_{kL}\n  return gradTest(alpha).doubleContraction(_dpk1[_qp] * gradTrial(beta));\n}\nThen, in Kernel::computeJacobian and Kernel::computeOffDiagJacobian, these values are assembled into K (the specified component).\nvoid\nKernel::computeJacobian()\n{\n  prepareMatrixTag(_assembly, _var.number(), _var.number());\n\n  precalculateJacobian();\n  for (_i = 0; _i < _test.size(); _i++)\n    for (_j = 0; _j < _phi.size(); _j++)\n      for (_qp = 0; _qp < _qrule->n_points(); _qp++)\n        _local_ke(_i, _j) += _JxW[_qp] * _coord[_qp] * computeQpJacobian(); \n\n  accumulateTaggedLocalMatrix();\n\n  if (_has_diag_save_in && !_sys.computingScalingJacobian())\n  {\n    DenseVector<Number> diag = _assembly.getJacobianDiagonal(_local_ke);\n    Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n    for (const auto & var : _diag_save_in)\n      var->sys().solution().add_vector(diag, var->dofIndices());\n  }\n}\nI'm not entirely clear on what prepareMatrixTag and accumulateTaggedLocalMatrix do specifically. However, since we have already computed and assembled K, I assume there should be a way to access this K through some tag.\nSimilarly, I need to compute $\\boldsymbol L$ (compute $\\boldsymbol{B}^T \\mathbb{C}$ and assemble) . Is it feasible to perform such calculations within a postprocessor?\nAdditionally, I need to compute $K^{-1}$. Does there exist a method to compute the inverse of K?",
                          "url": "https://github.com/idaholab/moose/discussions/28243#discussioncomment-10193882",
                          "updatedAt": "2024-07-30T18:44:03Z",
                          "publishedAt": "2024-07-30T18:44:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "accumulateTaggedLocalMatrix moves values from the local_ke threaded matrix to the global shared-between-threads matrix\n\nHowever, since we have already computed and assembled K, I assume there should be a way to access this K through some tag.\n\nadd a matrix tag to all the kernels that contribute to K then you can retrieve it using that tag\nhttps://mooseframework.inl.gov/source/interfaces/TaggingInterface.html",
                          "url": "https://github.com/idaholab/moose/discussions/28243#discussioncomment-10199388",
                          "updatedAt": "2024-07-31T09:29:31Z",
                          "publishedAt": "2024-07-31T09:29:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tttsss-01"
                          },
                          "bodyText": "I'm still not entirely sure how MOOSE assembles the Jacobian and off-diagonal Jacobian values into a global Jacobian matrix and then computes its inverse.\nI guess that the overall Jacobian is a block matrix composed of component * component sub-matrices, each of size N * N. Is  this correct?\nI guess that during the Newton iteration process, the inverse of the Jacobian ($K^{-1}$) should have been calculated. Is there a way to access it directly?\nIf we were to recompute $K^{-1}$, do you have any suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/28243#discussioncomment-10219202",
                          "updatedAt": "2024-08-02T04:12:36Z",
                          "publishedAt": "2024-08-02T04:12:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It does not compute its inverse directly. It solves the numerical system for the Newton update equation\nWhat do you mean by N here?\nYou can have petsc compute the inverse in a user object if you want. This will only work well for tiny problems.",
                          "url": "https://github.com/idaholab/moose/discussions/28243#discussioncomment-10219836",
                          "updatedAt": "2024-08-02T06:10:18Z",
                          "publishedAt": "2024-08-02T06:10:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tttsss-01"
                          },
                          "bodyText": "N is the number of nodes",
                          "url": "https://github.com/idaholab/moose/discussions/28243#discussioncomment-10223095",
                          "updatedAt": "2024-08-02T12:02:12Z",
                          "publishedAt": "2024-08-02T12:02:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I guess that the overall Jacobian is a block matrix composed of component * component sub-matrices, each of size N * N. Is this correct?\n\nN should be the number of DoFs here, not the number of nodes. If you are using 1st order Lagrange then for a single variable that is the case.\nFor the block-matrices, are you asking about the DoFs are ordered for multiple variables?",
                          "url": "https://github.com/idaholab/moose/discussions/28243#discussioncomment-10223245",
                          "updatedAt": "2024-08-02T12:19:50Z",
                          "publishedAt": "2024-08-02T12:19:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tttsss-01"
                          },
                          "bodyText": "Yes, this is what I wanted to ask.",
                          "url": "https://github.com/idaholab/moose/discussions/28243#discussioncomment-10223264",
                          "updatedAt": "2024-08-02T12:22:41Z",
                          "publishedAt": "2024-08-02T12:22:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "DoF ordering should be by default: rank/variable group/dof object/variable\nthis can be changed by the user so be careful coding for a given ordering",
                          "url": "https://github.com/idaholab/moose/discussions/28243#discussioncomment-10223301",
                          "updatedAt": "2024-08-02T12:27:36Z",
                          "publishedAt": "2024-08-02T12:27:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the displacement of the node of the current element?",
          "author": {
            "login": "Yasunaoka"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello Moose community!\nI want to implement hourglass resistance in my app, I'm going to add a new residual to each node in computeResidualAdditional(), in this process I need to get the displacement_old and displacement_older of the four nodes of the current element, I've looked at the other code and all I found was the displacement at the qp point, and all I need is the displacement on the nodes.\nIt occurred to me that maybe I could get it directly from the solution vector:\n  auto & olderglo = _sys.solutionOlder();\n  auto & oldglo = _sys.solutionOld();\n\n  std::vector<Number> old;\n  std::vector<Number> older;\n\n  oldglo.localize(old);\n  olderglo.localize(older);\n\n  // Real dx1 = old[(_current_elem->node_id(0)) * 2] - older[(_current_elem->node_id(0)) * 2];\n  // Real dy1 = old[_current_elem->node_id(0) * 2 + 1] - older[_current_elem->node_id(0) * 2 + 1];\n  // Real dx2 = old[(_current_elem->node_id(1)) * 2] - older[(_current_elem->node_id(1)) * 2];\n  // Real dy2 = old[_current_elem->node_id(1) * 2 + 1] - older[_current_elem->node_id(1) * 2 + 1];\n  // Real dx3 = old[(_current_elem->node_id(2)) * 2] - older[(_current_elem->node_id(2)) * 2];\n  // Real dy3 = old[_current_elem->node_id(2) * 2 + 1] - older[_current_elem->node_id(2) * 2 + 1];\n  // Real dx4 = old[(_current_elem->node_id(3)) * 2] - older[(_current_elem->node_id(3)) * 2];\n  // Real dy4 = old[_current_elem->node_id(3) * 2 + 1] - older[_current_elem->node_id(3) * 2 + 1];\n\nThis would work with a single thread, but not with multiple threads, and I'm thinking that maybe what is returned is not the global solution vector? Do you have a better way to do this? Thanks a lot!",
          "url": "https://github.com/idaholab/moose/discussions/28279",
          "updatedAt": "2024-08-02T09:28:56Z",
          "publishedAt": "2024-08-01T10:05:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhy dont you use a nodalKernel to add a residual on each node?\nDoes it need to be integrated over each element?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28279#discussioncomment-10214101",
                  "updatedAt": "2024-08-01T15:27:00Z",
                  "publishedAt": "2024-08-01T15:27:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Yasunaoka"
                          },
                          "bodyText": "Hello!\n1.I did check some of the official nodalkernel code, and it looks like there are no shape functions involved in it (from what I've seen of the code). Also, there's _qp in there, and I don't quite understand where the _qp is the integration point here (e.g. some low-order cells, where the integration point only exists inside the cell, so which cell's integration point does this _qp actually refer to?) . I'm not familiar with nodalkernel, so I didn't use nodalkernel.\n2.Yes, the calculation of hourglass resistance is based on the deformed modes of the element, and according to the formula, I need: node coordinates of the current element, node displacement, node displacement_old, and the shape function (and it's gradient)\n\n\n\nUnder solidmechanics, can we get the node displacement in kernel? Or can this problem be solved in nodalkernel? Thank you very much for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/28279#discussioncomment-10214412",
                          "updatedAt": "2024-08-01T16:00:41Z",
                          "publishedAt": "2024-08-01T16:00:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "_qp is the node index in nodal kernels. The notation is abused",
                          "url": "https://github.com/idaholab/moose/discussions/28279#discussioncomment-10214877",
                          "updatedAt": "2024-08-01T16:52:38Z",
                          "publishedAt": "2024-08-01T16:52:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Yasunaoka"
                          },
                          "bodyText": "Hi,thanks for your help!\nSo here is the problem:\nIn kernel,I can't get the node variable like displacement.\nThen in nodalkernel, I can't get the element variable like the test function,although I can get the node variable.\nIs there any way to solve this problem? Much appreciated!",
                          "url": "https://github.com/idaholab/moose/discussions/28279#discussioncomment-10218355",
                          "updatedAt": "2024-08-02T02:11:18Z",
                          "publishedAt": "2024-08-02T02:11:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok so for both cases, you could use the Functor APIs in variables.\nYou can see those APIs in the doxygen for variables, or you can see them in MooseFunctor.h, which has the definition of the base functor class that variables inherit\nSee MooseFunctorArgument.h for all the potential arguments you can use. There's nodal arguments, there s elemental arguments etc",
                          "url": "https://github.com/idaholab/moose/discussions/28279#discussioncomment-10220248",
                          "updatedAt": "2024-08-02T07:02:56Z",
                          "publishedAt": "2024-08-02T07:02:55Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Yasunaoka"
                  },
                  "bodyText": "Hi\n  auto du0 = _var.getNodalValue(_current_elem->node_ref(0)) -\n             _var.getNodalValueOld(_current_elem->node_ref(0));\n\nproblem solved! Thanks!",
                  "url": "https://github.com/idaholab/moose/discussions/28279#discussioncomment-10221779",
                  "updatedAt": "2024-08-02T09:28:38Z",
                  "publishedAt": "2024-08-02T09:28:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Control which Auxvariable to be saved in exodus file",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi all,\nSo, in general case all Auxvariables will be saved into .e file during outputting step.\nI just wondering is there a way to control which Auxvariable to be saved in exodus file ?\nfor example, I want some of the Auxvariables to be saved every 10 timestep, but the rest to be saved at every timestep? is it possible to do this?\nor just choose which Auxvariables to be saved?\nThank you guys!\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/28286",
          "updatedAt": "2024-08-06T03:22:13Z",
          "publishedAt": "2024-08-02T04:10:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can't choose the frequency for each auxvariable currently in a single exodus file\nYou can choose which variables using hide/show in the Outputs block\nAnd you can choose the output frequency using the interval parameters.\nYou could have two exodus output for the two different output frequency groups of variables\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28286#discussioncomment-10220106",
                  "updatedAt": "2024-08-02T06:46:10Z",
                  "publishedAt": "2024-08-02T06:46:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud,\nthank you! I will try to work around this\na quick question: for hide/show, if I only input some variable under hide, will it still show the rest of the auxvariable OR if I choose to do hide, I will also need to mention all the show?\nI will get back to you RE: interval parameters soon.\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/28286#discussioncomment-10220374",
                          "updatedAt": "2024-08-02T07:16:29Z",
                          "publishedAt": "2024-08-02T07:16:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you use hide you don't need to use show. And vice versa",
                          "url": "https://github.com/idaholab/moose/discussions/28286#discussioncomment-10220387",
                          "updatedAt": "2024-08-02T07:18:17Z",
                          "publishedAt": "2024-08-02T07:18:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to compile and run an external program in MOOSE?",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello, everyone.\nI want to know how can I compile and run an external program in MOOSE? The code is using fortran. Should I put the codes in the folder src and compile directly?\nEthan",
          "url": "https://github.com/idaholab/moose/discussions/28249",
          "updatedAt": "2024-08-02T01:54:55Z",
          "publishedAt": "2024-07-29T08:19:58Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou could try to do that but it's not very tidy.\nWe usually drop external codes in a contrib folder then modify the Makefile to compile it there\nYou can see examples of this with Cardinal on the neams-th-coe GitHub\nThere are also examples of compiling Fortran in the solid mechanics module for the UMAT",
                  "url": "https://github.com/idaholab/moose/discussions/28249#discussioncomment-10177838",
                  "updatedAt": "2024-07-29T09:34:36Z",
                  "publishedAt": "2024-07-29T09:34:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Thank you Giud. I'll check the Cardinal code.",
                          "url": "https://github.com/idaholab/moose/discussions/28249#discussioncomment-10218239",
                          "updatedAt": "2024-08-02T01:54:56Z",
                          "publishedAt": "2024-08-02T01:54:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Potential ambiguity in the definition of Flow channel area when combined with num_rods",
          "author": {
            "login": "Jake-HW-Miles"
          },
          "bodyText": "Hi there,\nThis may be a bit of a silly questions. However I want to make sure I am not barking up the wrong tree.\nSo I am constructing a Heat exchanger using components and am unsure which area to use. If I have a heat exchanger which has N tubes, each with an area of A, should be flow channel area be N*A or simply A? (I have seen examples of both)",
          "url": "https://github.com/idaholab/moose/discussions/28263",
          "updatedAt": "2024-08-01T17:27:11Z",
          "publishedAt": "2024-07-30T08:52:40Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI could see it coded either way, but it's likely expecting a single channel area. The parameter should say\nwhich object is it so we can update the parameter description?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10192194",
                  "updatedAt": "2024-07-30T15:23:04Z",
                  "publishedAt": "2024-07-30T15:23:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "I have been using HeatStructureCylindrical which is why I mention \"num_rods\", however I assume that all HS are the same. Thank you for clearing this up!",
                          "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10192224",
                          "updatedAt": "2024-07-30T15:25:43Z",
                          "publishedAt": "2024-07-30T15:25:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "But the Area (A) is stemming from the required input for FlowChannel1Phase",
                          "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10192226",
                          "updatedAt": "2024-07-30T15:26:24Z",
                          "publishedAt": "2024-07-30T15:26:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So you have a component that is both a FlowChannel1Phase and a HeatstructureCylindrical? That does not seem right?\nThe volume in HSCylindrical is\n      _volume.push_back(_num_rods * M_PI * (r[i + 1] * r[i + 1] - r[i] * r[i]) * _length);\n\nso the number of rods is multiplying the single-rod design for that class",
                          "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10192267",
                          "updatedAt": "2024-07-30T15:29:29Z",
                          "publishedAt": "2024-07-30T15:29:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "Apologies for not being clear, this is my heat exchanger group (reduced input):\n    [hx]\n        [pipe]\n            type = FlowChannel1Phase\n            position = '${pri_x_core} ${pri_y_core} 0.'\n            orientation = ${right}\n            length = ${hx_length}\n            n_elems = ${n_hx_elements}\n            A = '${fparse **tube_N** * pi * hx_dia_pri * hx_dia_pri * 0.25}'\n            D_h = ${hx_dia_pri}\n      \n            fp = coolant\n            initial_p = ${pri_press}\n            initial_vel = ${vel_ini_pri}\n            initial_T = ${initial_T_hx}\n        []\n        [wall]\n            type = HeatStructureCylindrical\n            orientation = ${right}\n            position = '${pri_x_core} ${pri_y_core} 0.'\n            length = ${hx_length}\n\n            n_elems = ${n_hx_elements}\n            \n            names = 'hx_wall'\n            widths = '${hx_wall_thickness}'\n            n_part_elems = 1\n            solid_properties = 'alloy625'\n            solid_properties_T_ref = '${units 600 degC -> K}'\n        \n            initial_T = ${initial_T_hx}\n            inner_radius = '${fparse hx_dia_pri / 2}'\n            num_rods = ${**tube_N**}\n        []\n    []\n\nI have tried to highlight references to the number of hx tubes, but based on the previous answer, it seems I should remove it from the flow channel",
                          "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10192302",
                          "updatedAt": "2024-07-30T15:33:04Z",
                          "publishedAt": "2024-07-30T15:33:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think so.\n@joshuahansel to check",
                          "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10214038",
                          "updatedAt": "2024-08-01T15:20:37Z",
                          "publishedAt": "2024-08-01T15:20:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "Good question, documentation is lacking on this topic.\nYour flow channel should represent the total flow area. Make sure to set the heated perimeter parameter P_hf in your HeatTransferFromHeatStructure1Phase component to correspond to the total as well. D_h should be the same for individual and total.",
                  "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10215134",
                  "updatedAt": "2024-08-01T17:27:11Z",
                  "publishedAt": "2024-08-01T17:27:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can I use Moose to calculate resonance modes?",
          "author": {
            "login": "ghmechamania"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi all,\nI'm new to FEM and I'm investigating if I can use Moose for my new project.\nFor this project I would like to calculate the resonance frequencies and modes of 2D an 3D objects.\nThis to be able to synthesize the sound an object would make when hitting it at some position.\nSo can I use Moose to calculate these modes? If so, can you give me some hints how to tackle this?\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/28280",
          "updatedAt": "2024-08-01T13:57:41Z",
          "publishedAt": "2024-08-01T13:20:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "This may be what you are looking for https://mooseframework.inl.gov/modules/solid_mechanics/1d_elastic_waves.html\nThere are two ways to do this, but the modal analysis way would get you more modes at once without needing to sweep.",
                  "url": "https://github.com/idaholab/moose/discussions/28280#discussioncomment-10213173",
                  "updatedAt": "2024-08-01T13:57:41Z",
                  "publishedAt": "2024-08-01T13:57:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Refinement (custom initial MOOSE mesh)",
          "author": {
            "login": "mangerij"
          },
          "bodyText": "Hi,\nIs this AMR scheme possible (attached)?\nNote that the dashed blue line separates two blocks.\nAt t = 0, the mesh needs to look like c)\nHow would I make a) with MOOSE mesh? is it possible to do a uniform refinement in the top block only to get to c) and still preserve the coarsening levels?\nas the simulation evolves, we would like to be able to move between the four levels.\nthanks",
          "url": "https://github.com/idaholab/moose/discussions/28272",
          "updatedAt": "2024-07-31T15:17:59Z",
          "publishedAt": "2024-07-31T13:24:40Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt's not possible with all discretizations. There are more than two levels of refinement  difference between two neighboring cells\nWe support one level of refinement. Beyond that you will need to add an interface kernel and implement a special treatment\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10201625",
                  "updatedAt": "2024-07-31T13:29:43Z",
                  "publishedAt": "2024-07-31T13:29:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "I was very careful to ensure there is only one level of refinement between neighboring cells here.",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10201826",
                          "updatedAt": "2024-07-31T13:46:03Z",
                          "publishedAt": "2024-07-31T13:46:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I must not have zoomed enough on d)\nThis would be supported then",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10201886",
                          "updatedAt": "2024-07-31T13:51:14Z",
                          "publishedAt": "2024-07-31T13:51:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Though it is only supported when libmesh performs this refinement.\nIf this is done in an external mesher and imported in exodus, it s not natively supported",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10201899",
                          "updatedAt": "2024-07-31T13:52:14Z",
                          "publishedAt": "2024-07-31T13:52:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We would need to add the refinement flags to each element when it's read and possibly create the parent elements too",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10201950",
                          "updatedAt": "2024-07-31T13:55:27Z",
                          "publishedAt": "2024-07-31T13:55:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "yeah I only want to do this with the MOOSE mesh but confused on how to make initially a)\nand then if uniform_refine is block restrictable",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10202070",
                          "updatedAt": "2024-07-31T14:04:03Z",
                          "publishedAt": "2024-07-31T14:04:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can make initial a) with the RefineSidesetGenerator though you may want to modify it a bit to get single sided refinement\nThen for block restricted refinement use the RefineBlockGenerator\nThey can be chained in the Mesh block",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10202106",
                          "updatedAt": "2024-07-31T14:07:59Z",
                          "publishedAt": "2024-07-31T14:07:57Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "Beautiful! thanks @GiudGiud  working example:\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 2\n    ny = 2\n    nz = 3\n    xmin = -10.0\n    xmax = 10.0\n    ymin = -10.0\n    ymax = 10.0\n    zmin = -10.0\n    zmax = 10.0\n    elem_type = HEX8\n  []\n  [subdomains]\n    type = SubdomainBoundingBoxGenerator\n    input = gen\n    bottom_left = '-10.0 -10.0 -20.0'\n    block_id = '1'\n    top_right = '10.0 10.0 0.0'\n    location = INSIDE\n  []\n  [film_interface]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = subdomains\n    primary_block = 0\n    paired_block = 1\n    new_boundary = 52\n  []\n  [refine_block0]\n    type = RefineBlockGenerator\n    input = film_interface\n    block = '0'\n    refinement = 1\n  []\n  [refine_sub]\n    type = RefineSidesetGenerator\n    input = refine_block0\n    boundaries = '52'\n    refinement = 2\n    boundary_side = 'secondary'\n    enable_neighbor_refinement = false\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10202478",
                          "updatedAt": "2024-07-31T14:44:04Z",
                          "publishedAt": "2024-07-31T14:42:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "@GiudGiud one more question: will RefineBlockGenerator rewrite the min h_level for AMR?",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10202789",
                          "updatedAt": "2024-07-31T15:15:08Z",
                          "publishedAt": "2024-07-31T15:15:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No you can recover the refined elements with mesh coarsening if needed\nAnd they can be refined further by AMR as well",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10202821",
                          "updatedAt": "2024-07-31T15:18:00Z",
                          "publishedAt": "2024-07-31T15:17:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "An inquiry about the availability of Arbitrary-Lagrangian-Eulerian (ALE) function",
          "author": {
            "login": "NINGYURICHARD"
          },
          "bodyText": "I am a beginner for MOOSE. Recently, I read the paper \"An arbitrary Lagrangian-Eulerian finite element method for finite strain plasticity\"\nNumerical Meth Engineering - 2003 - Armero - An arbitrary Lagrangian Eulerian finite element method for finite strain.pdf\n(attached), and I want to reproduce some benchmarks using direct ALE methods from this paper. This paper uses ALE method to solve finite strain plasticity, and the ALE contains 3 phases:\n\nLagrangian phase e.g. total Lagrangian formulation solved on reference configuration (a always fixed mesh configuration)\nSmoothing phase\nAdvection phase\n\nTherefore, could anyone tell me whether MOOSE supports the ALE implementation described above? If not, I think the difficult part may be the calculation of integrals on reference configuration, because we need to change the Jacobian inside the integral. Another difficult part may be how to restart the iteration after the advection phase (after re-assigning internal variables on reference configuration). Could anyone give me some help or advice on how to implement the ALE algorithm above using MOOSE? Thank you very much!\nRegards,\nRichard",
          "url": "https://github.com/idaholab/moose/discussions/28245",
          "updatedAt": "2024-07-31T12:06:51Z",
          "publishedAt": "2024-07-28T13:54:06Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "We support ALE in the Navier Stokes module. The laser meltpool example (under modules/nnavier_stokes/examples) and the kernels involved in that input show how to implement ALE in MOOSE\nWe have not built training material for this yet\n@lindsayad for awareness",
                  "url": "https://github.com/idaholab/moose/discussions/28245#discussioncomment-10184424",
                  "updatedAt": "2024-07-29T22:31:02Z",
                  "publishedAt": "2024-07-29T22:31:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "NINGYURICHARD"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/28245#discussioncomment-10200773",
                          "updatedAt": "2024-07-31T12:06:53Z",
                          "publishedAt": "2024-07-31T12:06:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "An inquiry about the total Lagrangian formulation of ComputeMultipleCrystalPlasticityStress class",
          "author": {
            "login": "NINGYURICHARD"
          },
          "bodyText": "Hello everyone!\nCould anyone tell me whether the ComputeMultipleCrystalPlasticityStress class contains the total Lagrangian formulation? I noticed that the updated Lagrangian incremental form is used in this class on\nhttps://mooseframework.inl.gov/source/materials/crystal_plasticity/ComputeMultipleCrystalPlasticityStress.html\nThank you very much!\nRegards,\nRichard",
          "url": "https://github.com/idaholab/moose/discussions/28248",
          "updatedAt": "2024-07-31T12:06:06Z",
          "publishedAt": "2024-07-29T06:45:32Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dewenyushu",
                  "url": "https://github.com/idaholab/moose/discussions/28248#discussioncomment-10184412",
                  "updatedAt": "2024-07-29T22:27:39Z",
                  "publishedAt": "2024-07-29T22:27:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dewenyushu"
                  },
                  "bodyText": "No, we only have this form in this class. As far as I know, this is the only form available in MOOSE.",
                  "url": "https://github.com/idaholab/moose/discussions/28248#discussioncomment-10192273",
                  "updatedAt": "2024-07-30T15:29:58Z",
                  "publishedAt": "2024-07-30T15:29:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "NINGYURICHARD"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/28248#discussioncomment-10200762",
                          "updatedAt": "2024-07-31T12:06:03Z",
                          "publishedAt": "2024-07-31T12:06:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}