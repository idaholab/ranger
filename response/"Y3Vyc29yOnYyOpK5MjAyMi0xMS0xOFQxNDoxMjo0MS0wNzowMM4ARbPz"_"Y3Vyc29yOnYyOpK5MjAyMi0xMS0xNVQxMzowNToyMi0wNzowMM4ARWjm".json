{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMS0xNVQxMzowNToyMi0wNzowMM4ARWjm"
    },
    "edges": [
      {
        "node": {
          "title": "LinearNodalConstraint support for distributed mesh",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "Hello,\nWhen using LinerNodalConstraint with --distributed-mesh flag, it result in an error:\n[bell-a323:116589:0:116589] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x30)\n[bell-a323:116591:0:116591] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x30)\n==== backtrace (tid: 116589) ====\n 0 0x000000000004cb95 ucs_debug_print_backtrace()  ???:0\n 1 0x0000000000036400 killpg()  ???:0\n 2 0x0000000000f85d4c LinearNodalConstraint::LinearNodalConstraint()  ???:0\n 3 0x0000000000fa9159 Registry::build<LinearNodalConstraint, MooseObject>()  ???:0\n 4 0x000000000197a1ff Factory::create()  ???:0\n 5 0x0000000000ce895d Factory::create<Constraint>()  ???:0\n 6 0x0000000000c851c3 NonlinearSystemBase::addConstraint()  ???:0\n 7 0x0000000001124e4d Action::timedAct()  ???:0\n 8 0x000000000112ec99 ActionWarehouse::executeActionsWithAction()  ???:0\n 9 0x00000000011310e1 ActionWarehouse::executeAllActions()  ???:0\n10 0x0000000001988882 MooseApp::runInputFile()  ???:0\n11 0x000000000198a2be MooseApp::run()  ???:0\n12 0x000000000040e3c9 main()  ???:0\n13 0x0000000000022555 __libc_start_main()  ???:0\n14 0x000000000040e60b _start()  ???:0\n=================================\n==== backtrace (tid: 116591) ====\n 0 0x000000000004cb95 ucs_debug_print_backtrace()  ???:0\n 1 0x0000000000036400 killpg()  ???:0\n 2 0x0000000000f85d4c LinearNodalConstraint::LinearNodalConstraint()  ???:0\n 3 0x0000000000fa9159 Registry::build<LinearNodalConstraint, MooseObject>()  ???:0\n 4 0x000000000197a1ff Factory::create()  ???:0\n 5 0x0000000000ce895d Factory::create<Constraint>()  ???:0\n 6 0x0000000000c851c3 NonlinearSystemBase::addConstraint()  ???:0\n 7 0x0000000001124e4d Action::timedAct()  ???:0\n 8 0x000000000112ec99 ActionWarehouse::executeActionsWithAction()  ???:0\n 9 0x00000000011310e1 ActionWarehouse::executeAllActions()  ???:0\n10 0x0000000001988882 MooseApp::runInputFile()  ???:0\n11 0x000000000198a2be MooseApp::run()  ???:0\n12 0x000000000040e3c9 main()  ???:0\n13 0x0000000000022555 __libc_start_main()  ???:0\n14 0x000000000040e60b _start()  ???:0\n=================================\n--------------------------------------------------------------------------\nPrimary job  terminated normally, but 1 process returned\na non-zero exit code. Per user-direction, the job has been aborted.\n--------------------------------------------------------------------------\n------------------------------------------------------------\nA process or daemon was unable to complete a TCP connection\nto another process:\n  Local host:    bell-a323\n  Remote host:   bell-a324\nThis is usually caused by a firewall on the remote host. Please\ncheck that any firewall (e.g., iptables) has been disabled and\ntry again.\n------------------------------------------------------------\n--------------------------------------------------------------------------\nmpiexec noticed that process rank 2 with PID 0 on node bell-a323 exited on signal 11 (Segmentation fault).\n\nYou can recreate this error by running moose/modules/tensor_mechanics/test/tests/dynamics/linear_constraint/disp_mid.i in distributed mesh, you'll just have to edit the mesh block with allow_renumbering = false then running it using 3 or more processes (I guess because then those nodes wont be allocated to the same processor)\nis there a quick fix for this?\nThanks in advance!\nKhaled",
          "url": "https://github.com/idaholab/moose/discussions/20782",
          "updatedAt": "2022-11-18T17:38:51Z",
          "publishedAt": "2022-04-13T14:19:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere's only 2 elements in that test.\nSo yeah it crashes with 3 processes, I've noticed this happen for some applications.\nThis is really not a big concern. We recommend 20,000 elements per process at minimum.\nIf you have a real case where you get a crash, please let us know though.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2564103",
                  "updatedAt": "2022-06-07T04:22:31Z",
                  "publishedAt": "2022-04-14T03:42:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "Thanks Guillaume for your reply!\nI used this example so you can replicate it on your end since I am actually running into this during normal runs, it just refuses to run on even 2 processors for 300k element mesh.\nand to make sure that the problem is indeed in this constraint, I took it out and it runs perfectly fine using distributed mesh without it.\nhere's the terminal error that I get when running my app\n[bell-b004:104102:0:104102] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x5a)\n[bell-b004:104104:0:104104] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x5a)\n==== backtrace (tid: 104102) ====\n 0 0x000000000004cb95 ucs_debug_print_backtrace()  ???:0\n 1 0x0000000000036400 killpg()  ???:0\n 2 0x0000000000c8f0e5 SystemBase::augmentSendList()  ???:0\n 3 0x0000000000444a82 libMesh::DofMap::prepare_send_list()  ???:0\n 4 0x0000000000d90e62 libMesh::System::init_data()  ???:0\n 5 0x0000000000d91436 libMesh::System::init()  ???:0\n 6 0x0000000000d4bd2d libMesh::EquationSystems::init()  ???:0\n 7 0x0000000000b3104d FEProblemBase::init()  ???:0\n 8 0x0000000001124e4d Action::timedAct()  ???:0\n 9 0x000000000112ec99 ActionWarehouse::executeActionsWithAction()  ???:0\n10 0x00000000011310e1 ActionWarehouse::executeAllActions()  ???:0\n11 0x0000000001988882 MooseApp::runInputFile()  ???:0\n12 0x000000000198a2be MooseApp::run()  ???:0\n13 0x000000000040e3c9 main()  ???:0\n14 0x0000000000022555 __libc_start_main()  ???:0\n15 0x000000000040e60b _start()  ???:0\n=================================\n==== backtrace (tid: 104104) ====\n 0 0x000000000004cb95 ucs_debug_print_backtrace()  ???:0\n 1 0x0000000000036400 killpg()  ???:0\n 2 0x0000000000c8f0e5 SystemBase::augmentSendList()  ???:0\n 3 0x0000000000444a82 libMesh::DofMap::prepare_send_list()  ???:0\n 4 0x0000000000d90e62 libMesh::System::init_data()  ???:0\n 5 0x0000000000d91436 libMesh::System::init()  ???:0\n 6 0x0000000000d4bd2d libMesh::EquationSystems::init()  ???:0\n 7 0x0000000000b3104d FEProblemBase::init()  ???:0\n 8 0x0000000001124e4d Action::timedAct()  ???:0\n 9 0x000000000112ec99 ActionWarehouse::executeActionsWithAction()  ???:0\n10 0x00000000011310e1 ActionWarehouse::executeAllActions()  ???:0\n11 0x0000000001988882 MooseApp::runInputFile()  ???:0\n12 0x000000000198a2be MooseApp::run()  ???:0\n13 0x000000000040e3c9 main()  ???:0\n14 0x0000000000022555 __libc_start_main()  ???:0\n15 0x000000000040e60b _start()  ???:0\n=================================\n--------------------------------------------------------------------------\nPrimary job  terminated normally, but 1 process returned\na non-zero exit code. Per user-direction, the job has been aborted.\n--------------------------------------------------------------------------\n--------------------------------------------------------------------------\nmpiexec noticed that process rank 0 with PID 104102 on node bell-b004 exited on signal 11 (Segmentation fault).\n--------------------------------------------------------------------------\n\nI'm setting up these constraints in an action, that might be why the error is slightly different.\nThanks again!\nKhaled",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2594569",
                          "updatedAt": "2022-06-07T04:22:32Z",
                          "publishedAt": "2022-04-19T16:16:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@sveerara @jwpeterson who wrote this object\nIs this supposed to work in parallel?\nIs there another nodal constraint you'd recommend to try here?",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2595466",
                          "updatedAt": "2022-06-07T04:22:38Z",
                          "publishedAt": "2022-04-19T18:37:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "I'm having the same problem with my constraints action > taking so much memory + only can run in replicated mesh version of parallel (which take so much memory), ~15Gb per rank for 4.6 million elements problem.\nI suspect that it's because there might be some node-pairs that are on the different meshes (after splitting).\nRegards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2597436",
                          "updatedAt": "2022-06-07T04:22:38Z",
                          "publishedAt": "2022-04-20T01:15:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The fix might be simple though, it might just be needing more ghosting.",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2597842",
                          "updatedAt": "2022-06-07T04:23:12Z",
                          "publishedAt": "2022-04-20T03:15:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "It seems to be doing something along this line,\n\n  \n    \n      moose/framework/src/constraints/LinearNodalConstraint.C\n    \n    \n        Lines 69 to 81\n      in\n      40ea18c\n    \n  \n  \n    \n\n        \n          \n           // Add elements connected to primary node to Ghosted Elements \n        \n\n        \n          \n           for (const auto & dof : _primary_node_ids) \n        \n\n        \n          \n           { \n        \n\n        \n          \n             // defining primary nodes in base class \n        \n\n        \n          \n             _primary_node_vector.push_back(dof); \n        \n\n        \n          \n            \n        \n\n        \n          \n             auto node_to_elem_pair = node_to_elem_map.find(dof); \n        \n\n        \n          \n             mooseAssert(node_to_elem_pair != node_to_elem_map.end(), \"Missing entry in node to elem map\"); \n        \n\n        \n          \n             const std::vector<dof_id_type> & elems = node_to_elem_pair->second; \n        \n\n        \n          \n            \n        \n\n        \n          \n             for (const auto & elem_id : elems) \n        \n\n        \n          \n               _subproblem.addGhostedElem(elem_id); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nI don't know if _mesh.getNodeList(_mesh.getBoundaryID(_secondary_node_set_id)); on line 51 would work for parallel or not.",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2600276",
                          "updatedAt": "2022-06-07T04:23:12Z",
                          "publishedAt": "2022-04-20T10:53:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "did you run this in debug? Does it crash there?",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2602676",
                          "updatedAt": "2022-06-10T07:37:34Z",
                          "publishedAt": "2022-04-20T16:15:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@lindsayad do you mind taking a look at LinearNodalConstraint ? We have two users who seek to use it in parallel. I think the testing for this was insufficient so it lost that capability",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2606378",
                          "updatedAt": "2022-06-10T07:37:34Z",
                          "publishedAt": "2022-04-21T06:04:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "don't want to hijack this thread, but this is my problem: I make LinearNodalConstraint into an action, so I can easily work with 200k+ pairs of nodes.\nit is basically just a loop feeding each node-pair into LinearNodalConstraint\n\nregisterMooseAction(\"traiApp\", MPCbe, \"add_constraint\");\n\nInputParameters\nMPCbe::validParams()\n{\n  InputParameters params = Action::validParams();\n  params.addParam<std::vector<unsigned int>>(\"primary_node_ids\", \"The primary node IDs.\");\n  params.addParam<std::vector<unsigned int>>(\"secondary_node_ids\",\n                                           \"The list of secondary node ids\");\n  return params;\n}\nMPCbe::MPCbe(const InputParameters & params)\n  : Action(params),\nprimary_node_ids(getParam<std::vector<unsigned int>>(\"primary_node_ids\")),\nsecondary_node_ids(getParam<std::vector<unsigned int>>(\"secondary_node_ids\"))\n\n{\n}\nvoid\nMPCbe::act()\n\n{\nfor (unsigned cur_num = 0; cur_num<primary_node_ids.size() ; cur_num++)\n{\n\n  std::vector<Real> weights_in (1);\n  std::vector<unsigned int> primary_node_ids_in (1);\n  std::vector<unsigned int> secondary_node_ids_in (1);\n\n  weights_in.at(0) = 1;\n  primary_node_ids_in.at(0) = primary_node_ids[cur_num];\n  secondary_node_ids_in.at(0) = secondary_node_ids[cur_num];\n\n  InputParameters params = _factory.getValidParams(\"LinearNodalConstraint\");\n  params.set<NonlinearVariableName>(\"variable\") = \"porepressure\";\n  params.set<std::vector<Real>>(\"weights\")= weights_in;\n  params.set<std::vector<unsigned int>>(\"primary\") = primary_node_ids_in;\n  params.set<std::vector<unsigned int>>(\"secondary_node_ids\") = secondary_node_ids_in;\n  params.set<Real>(\"penalty\") = 1e10;\n  _problem->addConstraint(\"LinearNodalConstraint\", \"MPCbe\" + Moose::stringify(cur_num), params);\n\n}\n}",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2606405",
                          "updatedAt": "2022-06-10T07:37:34Z",
                          "publishedAt": "2022-04-21T06:11:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The problem in a simulation is usually peak memory usage. We could probably add a ghosting functor/relationship manager to keep the elements/nodes around that you need but note that we probably wouldn't end up deleting the remote elements you don't need until the end of all of our MOOSE action execution. So the question is whether your peak memory usage occurs after that point (e.g. during the solve step). If it occurs before that point, then helping you would be more difficult.\nAs it is, it would take time to write the ghosting functor/relationship manager that would support this constraint, which I'm not sure I have. You are welcome to take a look at some of our existing RelationshipManagers and see if there is some inspiration there to help you write your own. If you wanted to take a stab at writing your own, I could help you when you have questions",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2611000",
                          "updatedAt": "2022-06-10T07:37:58Z",
                          "publishedAt": "2022-04-21T18:58:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Related to #16258 (another constraint), needing the same kind of work",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2612006",
                          "updatedAt": "2022-06-10T07:37:58Z",
                          "publishedAt": "2022-04-21T23:09:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jwpeterson"
                  },
                  "bodyText": "Sorry, I don't think I can take any of the credit (or blame) for LinearNodalConstraint.\ngit log --author=Peterson framework/src/constraints/LinearNodalConstraint.C\n\nare all just simple refactoring commits.",
                  "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2595631",
                  "updatedAt": "2022-06-07T04:22:38Z",
                  "publishedAt": "2022-04-19T19:09:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "difference",
          "author": {
            "login": "Oops-Qiao"
          },
          "bodyText": "Hello,\nThere is a question in the kernel,\nDoes the following two play the same role in the kernel? Do they have difference or not? Thank you.\nADTimeDerivative::precomputeQpResidual();\n_u_dot[_qp]",
          "url": "https://github.com/idaholab/moose/discussions/22249",
          "updatedAt": "2022-11-17T16:27:32Z",
          "publishedAt": "2022-09-28T12:02:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe are the same\nADReal\nADTimeDerivative::precomputeQpResidual()\n{\n  return _u_dot[_qp];\n}\n\nHowever, this is a precomputeQpResidual routine. So it must be defined alongside a computeQpResidual routine that uses it.\nBe careful with this, it's an optimization and if you dont use it properly you will miss the test function multiplication\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3757362",
                  "updatedAt": "2022-09-28T22:39:50Z",
                  "publishedAt": "2022-09-28T22:39:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Ok\uff0c thank you Guillaume, one question, here\nADTimeDerivative::precomputeQpResidual() is defined as ADReal type. Can I still use it if I have vector like velocity?",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3762353",
                          "updatedAt": "2022-09-29T12:37:52Z",
                          "publishedAt": "2022-09-29T12:37:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No you ll have to use the corresponding type for an ADvectorKernel.\nIt is likely ADRealVectorValue",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3762418",
                          "updatedAt": "2022-09-29T12:46:17Z",
                          "publishedAt": "2022-09-29T12:46:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "No you ll have to use the corresponding type for an ADvectorKernel. It is likely ADRealVectorValue\n\nSo it is better use  _u_dot[_qp] in the kernel instead of ADTimeDerivative::precomputeQpResidual(), right?",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3762443",
                          "updatedAt": "2022-09-29T12:48:17Z",
                          "publishedAt": "2022-09-29T12:48:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes but don\u2019t forget the test function that\u2019s it",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3762471",
                          "updatedAt": "2022-09-29T12:50:31Z",
                          "publishedAt": "2022-09-29T12:50:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Yes but don\u2019t forget the test function that\u2019s it\n\n\nYes but don\u2019t forget the test function that\u2019s it\n\nSure, since I inherit ADKernelValue, test function will be automatically applied.",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3762489",
                          "updatedAt": "2022-09-29T12:53:23Z",
                          "publishedAt": "2022-09-29T12:53:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Hello\nThe are the same\nADReal\nADTimeDerivative::precomputeQpResidual()\n{\n  return _u_dot[_qp];\n}\n\nHowever, this is a precomputeQpResidual routine. So it must be defined alongside a computeQpResidual routine that uses it. Be careful with this, it's an optimization and if you dont use it properly you will miss the test function multiplication\nGuillaume\n\nHi Guillaume,\nToday just a question came to my mind regarding your answer above.\nFor example the code below in your moose,\n\nADReal\nADTimeDerivative::precomputeQpResidual()\n{\nreturn _u_dot[_qp];\n\nADHeatConductionTimeDerivative.C\n\nADReal\nADHeatConductionTimeDerivative::precomputeQpResidual()\n{\nreturn _specific_heat[_qp] * _density[_qp] * ADTimeDerivative::precomputeQpResidual();\n}\nI am wondering that if the two bold precomputeQpResidual() plays the same role to multiply the test function, if that is the case, it looks a little bit messed up since we only need to multply once the test function.\nWhat do you suggest to understand it?\nThank you so much.\nQiao",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-4161275",
                          "updatedAt": "2022-11-16T21:15:03Z",
                          "publishedAt": "2022-11-16T21:14:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "This has to do with you modifying precomputeQPResidual. If using precomputeQPResidual then you do not multiply the test function. The link explains it more in-depth https://mooseframework.inl.gov/magpie/syntax/Kernels/ under Optimized Kernel Objects.",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-4161776",
                          "updatedAt": "2022-11-16T22:39:58Z",
                          "publishedAt": "2022-11-16T22:39:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "This has to do with you modifying precomputeQPResidual. If using precomputeQPResidual then you do not multiply the test function. The link explains it more in-depth https://mooseframework.inl.gov/magpie/syntax/Kernels/ under Optimized Kernel Objects.\n\nThanks, that is also my understanding. However, if you see below, it has two times of precomputeQPResidual which means it will then multiply the test function two times. Is it right? This makes me confused.\n@GiudGiud\nADReal\nADHeatConductionTimeDerivative::precomputeQpResidual()\n{\nreturn _specific_heat[_qp] * _density[_qp] * ADTimeDerivative::precomputeQpResidual();\n}",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-4162123",
                          "updatedAt": "2022-11-16T23:48:56Z",
                          "publishedAt": "2022-11-16T23:48:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "I don't think so. Only the \"final\" precomputeQpResidual() gets multiplied by the test functions. IIRC this is an example of overriding a virtual function so only the ADHeatConductionTimeDerivative::precomputeQpResidual() gets called and multiplied by the test functions. Even though ADTimeDerivative::precomputeQpResidual() is called also by ADHeatConductionTimeDerivative , only the _u_dot[_qp] is incorporated with the ADHeatConductionTimeDerivative. This explanation may be confusing, so sorry for that!",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-4162189",
                          "updatedAt": "2022-11-16T23:59:11Z",
                          "publishedAt": "2022-11-16T23:59:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "ADReal\nADTimeDerivative::precomputeQpResidual()\n{\nreturn _u_dot[_qp];\n\nI really appreciate your patient reply. Just one more question here. if you say \u201conly the _u_dot[_qp] is incorporated \u201d .\nIf we now take look at the ADTimeDerivative document, they have used the following definition with  \"precomputeQpResidual()\" in below.\nDo we have test function multiplied in the code below? If Yes, how to understand your current explanation then. Thanks again.\nADReal\nADTimeDerivative::precomputeQpResidual()\n{\nreturn _u_dot[_qp];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-4162356",
                          "updatedAt": "2022-11-17T00:11:32Z",
                          "publishedAt": "2022-11-17T00:10:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Does AD support operations except for the four rules?",
          "author": {
            "login": "Raven-pro"
          },
          "bodyText": "Hello, everyone!\nI know AD is based on the chain rule, and using AD variables and kernels can make automatically building jacobian a lot more convenient.\nBut I am wondering if AD support other operations like Exponential operations and Logarithmic operations and many other operations.\nFor now I think exponential operations can be achieved using Utility:pow<> method (I dont know if I am right about that), but how about logarithmic operations and many others. Like, if just use std::log on an AD variable, can the derivative also be calculated correctly?\nI am using MOOSE to develop an APP to solve single-phase flow problem, and the EOS requires operations mentioned above(IAPWS97 formulaitons). The properties are associated with main variables and I think the calculation process may affect the forming of jacobian(like setting them to be constants), increasing the errors, and leding to not convergening.\nSo is there any way to best implement proper operations like Exponential and Logarithmic?\nThank you very much!",
          "url": "https://github.com/idaholab/moose/discussions/22648",
          "updatedAt": "2022-11-17T03:03:15Z",
          "publishedAt": "2022-11-10T06:04:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Raven-pro"
                  },
                  "bodyText": "I just noticed that in the functions, if return type was set to ADReal, no error warning would show up when I use MathUtils:pow or Utility::pow to carry out Exponential operations.\nDoes that mean the derivative can also be properly computed by the both two ways?",
                  "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4105233",
                  "updatedAt": "2022-11-10T08:30:14Z",
                  "publishedAt": "2022-11-10T08:30:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes AD is supported by most operators. I think atan2 or something similar might be the only one that got reported as not working.\nWill you be re-writing IAWPS properties? You need to have them written with ADReal inputs and return types (or DualReal, an AD number with less derivatives used in fluid properties)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4107444",
                  "updatedAt": "2022-11-10T13:21:42Z",
                  "publishedAt": "2022-11-10T13:21:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Thanks for your reply!\nYes, I am considering adding some functions to the IAPWS properties right now.\nI also have another question, is the derivative of an ADReal variable also an AD?\nIf that's so, when I want to compute some derivatives, I can just use .derivative()[...] to get that, am I right?\nThanks :)",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4113533",
                          "updatedAt": "2022-11-11T03:32:22Z",
                          "publishedAt": "2022-11-11T03:32:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Which IAWPS properties? Do you have your own library?\nYou can get the derivatives through .derivative(), but they dont carry derivatives themselves.\nThey rarely need to?",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4113639",
                          "updatedAt": "2022-11-11T03:57:05Z",
                          "publishedAt": "2022-11-11T03:57:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Can I ask what is missing in IAPWS-IF97 (called Water97FluidProperties) that you need? It was a while since I wrote it, but I though that I had implemented everything in the IAPWS-IF97 paper.",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4113902",
                          "updatedAt": "2022-11-11T05:03:50Z",
                          "publishedAt": "2022-11-11T05:03:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "In fact,  I cannot find formulations of Region4 in Water97FluidProperties, like computing saturation values based on pressure and x, so I added related formulations in it. Except for that, almost all the variables are written in a non-AD manner.\nI am trying to develop a single-phase water flow application, but the result is always wrong, so I am trying to find out the reason, like should I use AD on all the parameters like properties coefficients? I have no idea yet.\nIs there any open-source single-phase MOOSE code available? I think maybe I need more references. :)",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4126363",
                          "updatedAt": "2022-11-13T03:34:02Z",
                          "publishedAt": "2022-11-13T03:34:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Can I ask what is missing in IAPWS-IF97 (called Water97FluidProperties) that you need? It was a while since I wrote it, but I though that I had implemented everything in the IAPWS-IF97 paper.\n\nHello, may I ask you about some convergence issues concerning single-phase 1D flow? I have opened another thread [#22682]. Could you please help me check if there is anything wrong with my code?  I just really cannot find out how to solve it alone, Thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4126655",
                          "updatedAt": "2022-11-13T06:12:24Z",
                          "publishedAt": "2022-11-13T06:12:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Region 4 is the saturation curve - both saturation pressure as a function of temperature and saturation temperature as a function of pressure are implemented. There is a related IAPWS supplementary release for backward equations in Region 4 - is this what is missing?",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4130223",
                          "updatedAt": "2022-11-13T21:22:45Z",
                          "publishedAt": "2022-11-13T21:22:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Yes, I didn't find related formulations in Water97FluidProperties, perhaps that's because I am using the old version MOOSE?\nBut the main problem I am facing is the convergence problem (that's why I tried to implement AD in fp), I am starting to think both AD and non-AD are okay concerning fluid properties as closures (Since my efforts have failed).\nCould you please give me some suggestions about my convergence problem? THX!",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4131484",
                          "updatedAt": "2022-11-14T03:24:41Z",
                          "publishedAt": "2022-11-14T03:24:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Yeah, it sounds like it could be something else",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4131861",
                          "updatedAt": "2022-11-14T05:30:43Z",
                          "publishedAt": "2022-11-14T05:30:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@89018580 do you get convergence with constant fluid properties?\nIf there are some missing properties in Water97FluidProperties we would be very interested in that contribution",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4137148",
                          "updatedAt": "2022-11-14T14:18:51Z",
                          "publishedAt": "2022-11-14T14:18:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Yeah, it sounds like it could be something else\n\nOops, I just checked the Water97FluidProperties.h file, which I have not looked through carefully enough before.\nThe saturation temperature as the function of pressure is achieved in the vaporTemperature function. I thought there weren't formulations of Region4 because I didn't find \"Region4\" in inRegion() function, how careless I am.\nThe Water97FluidProperties does have everything in it.",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4137792",
                          "updatedAt": "2022-11-14T15:14:54Z",
                          "publishedAt": "2022-11-14T15:14:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "error report in the constructor",
          "author": {
            "login": "Oops-Qiao"
          },
          "bodyText": "Hi expert,\ncould you please help to see how to solve the following problems.\nI have 3 velocity component but in the construtor it generates an error.\nPerhaps I forgot to include some h file? Thank you so much.\nI have following in my constructor:\n_u_x_l(adCoupledValue(\"u_x_l\")),\n_u_y_l(_mesh.dimension() >= 2.0 ? adCoupledValue(\"u_y_l\") : _zero),\nThe reported error is\n_error: operands to '?:' have different types 'const ADVariableValue' {aka 'const MooseArray<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >'} and 'const VariableValue' {aka 'const MooseArray'}\n_u_y_l(_mesh.dimension() >= 2.0 ? adCoupledValue(\"u_y_l\") : _zero),\nBest regards,\nQiao",
          "url": "https://github.com/idaholab/moose/discussions/22709",
          "updatedAt": "2022-11-16T21:15:33Z",
          "publishedAt": "2022-11-15T18:21:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n_zero isnt the right value for ad variable values\nyou want to use _ad_zero\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22709#discussioncomment-4149445",
                  "updatedAt": "2022-11-15T18:23:28Z",
                  "publishedAt": "2022-11-15T18:23:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Hello\n_zero isnt the right value for ad variable values\nyou want to use _ad_zero\nGuillaume\n\nThanks very much my dear friend!!!",
                          "url": "https://github.com/idaholab/moose/discussions/22709#discussioncomment-4149531",
                          "updatedAt": "2022-11-15T18:35:07Z",
                          "publishedAt": "2022-11-15T18:35:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Hello\n_zero isnt the right value for ad variable values\nyou want to use _ad_zero\nGuillaume\n\nHello Guillaume, I have a quick question,\nin the AD version I saw two different ways to define the parameters, what are their differences? Thank you.\n\n\nReal _ambient_convection_alpha;\nhttps://github.com/idaholab/moose/blob/next/modules/navier_stokes/include/materials/INSAD3Eqn.h\n\n\nADReal _hmax;\nhttps://github.com/idaholab/moose/blob/next/modules/navier_stokes/include/materials/INSADTauMaterial.h\n\n\nQiao",
                          "url": "https://github.com/idaholab/moose/discussions/22709#discussioncomment-4150860",
                          "updatedAt": "2022-11-15T21:48:24Z",
                          "publishedAt": "2022-11-15T21:48:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The difference is whether the number carries derivative information or not.\nA constant should pretty much always be a Real not an ADReal, though it s often inconsequential to have it be an ADReal",
                          "url": "https://github.com/idaholab/moose/discussions/22709#discussioncomment-4158921",
                          "updatedAt": "2022-11-16T16:28:36Z",
                          "publishedAt": "2022-11-16T16:28:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "ok, thanks very much.",
                          "url": "https://github.com/idaholab/moose/discussions/22709#discussioncomment-4161279",
                          "updatedAt": "2022-11-16T21:15:33Z",
                          "publishedAt": "2022-11-16T21:15:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "can the preconditioner be dynamically changed during a simulation?",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hi everyone,\nSometimes my simulations run nicely until a certain time when they slow down due to some physical occurrence, like applying a new load or flux to the system.  In these cases, it may be advantageous to use a different preconditioner, just for those few timesteps around the physical occurrence.  For instance, usually i could use a \"weak/cheap\" preconditioner like ILU, but around the difficult times, I'd like to use LU.\nIs it possible to instruct MOOSE to use different preconditioners at different nonlinear steps (or time steps), depending on some criterion?   Something like:\nif previous_linear_iterations < 999:\n  preconditioner = ilu\nelse:\n  preconditioner = lu",
          "url": "https://github.com/idaholab/moose/discussions/22692",
          "updatedAt": "2022-11-16T16:52:35Z",
          "publishedAt": "2022-11-14T20:18:07Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "As far as I know we do not support that.\nEven setting the convergence criterion to be time dependent would be super helpful in my mind.\nTagging @friedmud and @lindsayad for awareness and comments.",
                  "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4140441",
                  "updatedAt": "2022-11-14T20:31:25Z",
                  "publishedAt": "2022-11-14T20:31:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thanks @GiudGiud .   An alternative could be something like:\ntry:\n  ilu\nexcept SolveFailed:\n  try:\n    hypre\n  except SolveFailed:\n    try:\n      lu",
                          "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4140519",
                          "updatedAt": "2022-11-14T20:41:53Z",
                          "publishedAt": "2022-11-14T20:41:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "that could be an alternative strategy to provide more resilience, though you often have to pass options in addition to this, so maybe you d want multiple Preconditioning blocks in the input file.\nI think cutting the time step is a more reasonable choice in the work I do, but I can see that for others.",
                          "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4140550",
                          "updatedAt": "2022-11-14T20:45:29Z",
                          "publishedAt": "2022-11-14T20:45:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Yea, i agree about cutting the timestep - it often works.  However, i would bet the changing the preconditioner also works in many cases, but we haven't had the flexibility to experiment with that approach.  Cutting the timestep usually helps make the problem more linear, but that doesn't necessarily mean easier for the linear solver.",
                          "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4140823",
                          "updatedAt": "2022-11-14T21:29:06Z",
                          "publishedAt": "2022-11-14T21:29:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "To me it also reduces the distance the nonlinear solver has to travel as well.\nfor flow in the NS module there s very few PC that would work without expert settings.",
                          "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4141149",
                          "updatedAt": "2022-11-14T22:22:03Z",
                          "publishedAt": "2022-11-14T22:22:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Strictly speaking you could do this in a custom Executioner but yea we do not have the ability to do this easily from, say, an input file. However, with @reverendbedford's recent changes to allow keeping around the SNES context between timesteps, I think implementing something like this would not be all that difficult. @WilkAndy feel free to create an issue for this if we don't have one already. I don't know when someone from the MOOSE team would be able to take it on, but maybe an external developer would",
                          "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4159187",
                          "updatedAt": "2022-11-16T16:52:35Z",
                          "publishedAt": "2022-11-16T16:52:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Ansys mesh file input to moose",
          "author": {
            "login": "nishant1785"
          },
          "bodyText": "Hi,\nFor first time I have tried using ansys mesh (.msh format) file as an input to a simple diffusion code.  But i get following error in moose:\n*** ERROR ***\nInvalid dimension dim = 4\n\nNote:Actually geometry was generated in abaqus and then imported in ansys to make *.msh mesh file which was later used in MOOSE as mentioned above.\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/22531",
          "updatedAt": "2022-12-10T07:29:59Z",
          "publishedAt": "2022-10-28T14:06:42Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@jortensi @permcody do you know anyone who has been doing ANSYS->ABAQUS->MOOSE ?",
                  "url": "https://github.com/idaholab/moose/discussions/22531#discussioncomment-3995264",
                  "updatedAt": "2022-10-28T16:49:26Z",
                  "publishedAt": "2022-10-28T16:49:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "I don't believe we've ever tried to read Ansys meshes. We do have an Abaqus reader though, but it may not be full featured. libMesh (our I/O library) supports many formats, gmsh, exodus, and even Ascii formats (XDA). You might also consider using our  MeshGenerator system, where you can programmatically build up parameterizeable meshes.",
                          "url": "https://github.com/idaholab/moose/discussions/22531#discussioncomment-3996096",
                          "updatedAt": "2022-10-28T18:09:42Z",
                          "publishedAt": "2022-10-28T18:09:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "nishant1785"
                  },
                  "bodyText": "Okk thank you I will see that.\n\nNishant Gaikwad-7972836355\nM. Tech student\nMaterials Department\nDIAT, DRDO,Girinagar\n411025-Pune\n\u2026\nOn Fri, 28 Oct, 2022, 11:39 pm Cody Permann, ***@***.***> wrote:\n I don't believe we've ever tried to read Ansys meshes. We do have an\n Abaqus reader though, but it may not be full featured. libMesh (our I/O\n library) supports many formats, gmsh, exodus, and even Ascii formats (XDA).\n You might also consider using our MeshGenerator system, where you can\n programmatically build up parameterizeable meshes.\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#22531 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/A3ER5T2G2SHNASQLSQSGP3DWFQJHBANCNFSM6AAAAAARRDM5GI>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/22531#discussioncomment-4000383",
                  "updatedAt": "2022-10-29T03:22:41Z",
                  "publishedAt": "2022-10-29T03:22:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Wang-Yihu"
                  },
                  "bodyText": "Haha, MOOSE Multiphysics cannot read ANSYS mesh (*.msh) in the current version.\nI suggest you:\n\nexport ANSYS Workbench mesh in FLUENT input mesh (*.msh)\nread the *.msh with ICEM CFD\nset the Exodus format, set the boundary conditions, and export it (*.exo)\nThis really works!!!! I use this method!!!!!!",
                  "url": "https://github.com/idaholab/moose/discussions/22531#discussioncomment-4152626",
                  "updatedAt": "2022-11-16T02:52:21Z",
                  "publishedAt": "2022-11-16T02:52:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error occurs when CZM used no-AD TensorMechanics object with Eigenstrain",
          "author": {
            "login": "echo1115"
          },
          "bodyText": "Hi everyone,\nI run the case in https://github.com/idaholab/moose/blob/dfa17cdbb0/modules/tensor_mechanics/test/tests/cohesive_zone_model/bilinear_mixed.i , but I used no-AD TensorMechanics object, and applied a ThermalExpansionEigenstrain. However, the case failed with the following message :\n*** Info ***\nTensorMechanics Action: selecting 'incremental finite strain' formulation.\ufffd[39m\n\n===================================================================================\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 42920 RUNNING AT ga0408\n=   EXIT CODE: 11\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\n===================================================================================\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions\n\nHere is the modified input:\n[Mesh]\n  [msh]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmax = 1\n    ymax = 2\n    nx = 1\n    ny = 2\n  []\n  [block1]\n    type = SubdomainBoundingBoxGenerator\n    input = 'msh'\n    bottom_left = '0 0 0'\n    top_right = '1 1 0'\n    block_id = 1\n    block_name = 'block1'\n  []\n  [block2]\n    type = SubdomainBoundingBoxGenerator\n    input = 'block1'\n    bottom_left = '0 1 0'\n    top_right = '1 2 0'\n    block_id = 2\n    block_name = 'block2'\n  []\n  [split]\n    type = BreakMeshByBlockGenerator\n    input = block2\n  []\n  [top_node]\n    type = ExtraNodesetGenerator\n    coord = '0 2 0'\n    input = split\n    new_boundary = top_node\n  []\n  [bottom_node]\n    type = ExtraNodesetGenerator\n    coord = '0 0 0'\n    input = top_node\n    new_boundary = bottom_node\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Modules]\n  [TensorMechanics]\n    [Master]\n      generate_output = 'stress_yy'\n      [all]\n        strain = FINITE\n        add_variables = true\n        #use_automatic_differentiation = true\n        decomposition_method = TaylorExpansion\n\n        eigenstrain_names = 'thermal_eigen'\n      []\n    []\n  []\n[]\n\n[BCs]\n  [fix_x]\n    type = DirichletBC\n    preset = true\n    value = 0.0\n    boundary = bottom_node\n    variable = disp_x\n  []\n\n  [fix_top]\n    type = DirichletBC\n    preset = true\n    boundary = top\n    variable = disp_x\n    value = 0\n  []\n\n  [top]\n    type = FunctionDirichletBC\n    boundary = top\n    variable = disp_y\n    function = 'if(t<=0.3,t,if(t<=0.6,0.3-(t-0.3),0.6-t))'\n    preset = true\n  []\n\n  [bottom]\n    type = DirichletBC\n    boundary = bottom\n    variable = disp_y\n    value = 0\n    preset = true\n  []\n[]\n\n[Modules/TensorMechanics/CohesiveZoneMaster]\n  [czm_ik]\n    boundary = 'interface'\n  []\n[]\n\n[Materials]\n  [stress]\n    #type = ADComputeFiniteStrainElasticStress\n    type = ComputeFiniteStrainElasticStress\n  []\n  [elasticity_tensor]\n  #  type = ADComputeElasticityTensor\n    type = ComputeElasticityTensor\n    fill_method = symmetric9\n    C_ijkl = '1.684e5 0.176e5 0.176e5 1.684e5 0.176e5 1.684e5 0.754e5 0.754e5 0.754e5'\n  []\n  [./thermal_expansion_strain]\n    #type = ADComputeThermalExpansionEigenstrain\n    type = ComputeThermalExpansionEigenstrain\n    stress_free_temperature = 800\n    thermal_expansion_coeff = 4.9e-6\n    temperature = 800\n    eigenstrain_name = 'thermal_eigen'\n  [../]\n  [czm]\n    type = BiLinearMixedModeTraction\n    boundary = 'interface'\n    penalty_stiffness = 1e6\n    GI_c = 1e3\n    GII_c = 1e2\n    normal_strength = 1e4\n    shear_strength = 1e3\n    displacements = 'disp_x disp_y'\n    eta = 2.2\n    viscosity = 1e-3\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = 'NEWTON'\n  line_search = none\n\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  automatic_scaling = true\n\n  l_max_its = 2\n  l_tol = 1e-14\n  nl_max_its = 30\n  nl_rel_tol = 1e-50\n  nl_abs_tol = 1e-15\n  start_time = 0.0\n  dt = 0.1\n  end_time = 1.0\n  dtmin = 0.1\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n\nActurally the ThermalExpansionEigenstrain is zero because the temperature  equals to  the stress_free_temperature.\nThe error message is the same in debug mode. Could anyone give me some help? Maybe @hugary1995 @jiangwen84 can give me some suggestions. Thanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/22576",
          "updatedAt": "2022-11-25T09:48:47Z",
          "publishedAt": "2022-11-03T03:17:04Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is because you are using a number for temperature instead of a variable, and the code expects a variable later on\nPlease use an auxiliary variable for now and I ll make a PR to fix this in the repo today.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4049790",
                  "updatedAt": "2022-11-03T17:43:00Z",
                  "publishedAt": "2022-11-03T17:42:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@GiudGiud  yes, when i change the temperature in ComputeThermalExpansionEigenstrain into an aux variable, it could run successfully.\nHowever, when i used the FunctionIsotropicEigenstrain  to replace the ComputeThermalExpansionEigenstrain  in the input file, the case failed with message: Segmentation fault (core dumped)\nhere is the FunctionIsotropicEigenstrain  and its corresponding function :\n  [thermal_expansion_strain]\n    type = FunctionIsotropicEigenstrain\n    function = eigfunc\n    eigenstrain_name = 'thermal_eigen'\n  []\n\n[Functions]\n  [eigfunc]\n    type = ParsedFunction\n    value = 0.0\n  []\n[]\n\nThen I run it in debug mode, it shows\nTime Step 0, time = 0\nTime Step 1, time = 0.1, dt = 0.1\nThread 1 \"my-dbg\" received signal SIGSEGV, Segmentation fault.\n0x00007ffff3b8c2e6 in __gnu_cxx::__normal_iterator<libMesh::Point const*, std::vector<libMesh::Point, std::allocator<libMesh::Point> > >::__normal_iterator (this=0x7fffffff9df0, \n    __i=<error reading variable>) at /home/ddd/mambaforge3/envs/moose/x86_64-conda-linux-gnu/include/c++/10.3.0/bits/stl_iterator.h:976\n976\t      : _M_current(__i) { }\n\nThe  FunctionIsotropicEigenstrain  comes from https://github.com/idaholab/moose/blob/7df3b095f66fb205a46d4afc6aa4a23e4b394a95/modules/tensor_mechanics/test/src/materials/FunctionIsotropicEigenstrain.C\nI test it because my Eigenstrain class is similar, both inherited the class ComputeEigenstrainBase.C , and using my Eigenstrain class failed with the same error.",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4057496",
                          "updatedAt": "2022-11-04T14:33:57Z",
                          "publishedAt": "2022-11-04T14:33:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not sure.\nCould you please post a full backtrace as well?",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4057762",
                          "updatedAt": "2022-11-04T15:01:29Z",
                          "publishedAt": "2022-11-04T15:00:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "Here is the backtrace :\n(gdb) bt\n#0  0x00007ffff3b8c2e6 in __gnu_cxx::__normal_iterator<libMesh::Point const*, std::vector<libMesh::Point, std::allocator<libMesh::Point> > >::__normal_iterator (\n    this=0x7fffffff9e30, __i=<error reading variable>) at /home/ddd/mambaforge3/envs/moose/x86_64-conda-linux-gnu/include/c++/10.3.0/bits/stl_iterator.h:976\n#1  0x00007ffff3b75fd0 in std::vector<libMesh::Point, std::allocator<libMesh::Point> >::end (this=0x32)\n    at /home/ddd/mambaforge3/envs/moose/x86_64-conda-linux-gnu/include/c++/10.3.0/bits/stl_vector.h:839\n#2  0x00007ffff3b636d7 in std::vector<libMesh::Point, std::allocator<libMesh::Point> >::empty (this=0x32)\n    at /home/ddd/mambaforge3/envs/moose/x86_64-conda-linux-gnu/include/c++/10.3.0/bits/stl_vector.h:1008\n#3  0x00007ffff3b27fa3 in libMesh::QBase::n_points (this=0x12) at /home/ddd/mambaforge3/envs/moose/libmesh/include/libmesh/quadrature.h:128\n#4  0x00007ffff4c211da in Material::computeProperties (this=0x555555c5d5a0) at /home/ddd/projects/moose/framework/src/materials/Material.C:131\n#5  0x00007ffff4b0f353 in MaterialData::reinit<std::vector<std::shared_ptr<MaterialBase>, std::allocator<std::shared_ptr<MaterialBase> > > > (this=0x555555b02ff0, mats=...)\n    at /home/ddd/projects/moose/framework/build/header_symlinks/MaterialData.h:454\n#6  0x00007ffff4ac96c4 in FEProblemBase::reinitMaterialsFace (this=0x555555ae8110, blk_id=1, tid=0, swap_stateful=true, reinit_mats=0x0)\n    at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:3348\n#7  0x00007ffff463b32f in NonlinearThread::onInterface (this=0x7fffffffa560, elem=0x5555559fddc0, side=2, bnd_id=4)\n    at /home/ddd/projects/moose/framework/src/loops/NonlinearThread.C:174\n#8  0x00007ffff4678a85 in ThreadedElementLoopBase<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> >::operator() (this=0x7fffffffa560, \n    range=..., bypass_threading=false) at /home/ddd/projects/moose/framework/build/header_symlinks/ThreadedElementLoopBase.h:266\n#9  0x00007ffff3e5f04a in libMesh::Threads::parallel_reduce<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*>, ComputeResidualThread> (\n    range=..., body=...) at /home/ddd/mambaforge3/envs/moose/libmesh/include/libmesh/threads_pthread.h:380\n#10 0x00007ffff3e2a996 in NonlinearSystemBase::computeResidualInternal (this=0x555555b03510, tags=...) at /home/ddd/projects/moose/framework/src/systems/NonlinearSystemBase.C:1520\n#11 0x00007ffff3e24c25 in NonlinearSystemBase::computeResidualTags (this=0x555555b03510, tags=...) at /home/ddd/projects/moose/framework/src/systems/NonlinearSystemBase.C:743\n#12 0x00007ffff4ae1bc7 in FEProblemBase::computeResidualTags (this=0x555555ae8110, tags=...) at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:5859\n#13 0x00007ffff4ae05d0 in FEProblemBase::computeResidualInternal (this=0x555555ae8110, soln=..., residual=..., tags=...)\n    at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:5697\n#14 0x00007ffff4adf14c in FEProblemBase::computeResidual (this=0x555555ae8110, soln=..., residual=...) at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:5486\n#15 0x00007ffff4adeefc in FEProblemBase::computeResidualSys (this=0x555555ae8110, soln=..., residual=...) at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:5461\n#16 0x00007ffff3e1d6df in NonlinearSystem::solve (this=0x555555b03510) at /home/ddd/projects/moose/framework/src/systems/NonlinearSystem.C:145\n#17 0x00007ffff4adb33c in FEProblemBase::solve (this=0x555555ae8110) at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:5198\n#18 0x00007ffff47950d5 in FEProblemSolve::solve (this=0x555555b3a2b8) at /home/ddd/projects/moose/framework/src/executioners/FEProblemSolve.C:260\n#19 0x00007ffff4799513 in FixedPointSolve::solveStep (this=0x555555a501e0, begin_norm=@0x555556025df0: 0, end_norm=@0x555555f41f00: 0, transformed_dofs=...)\n    at /home/ddd/projects/moose/framework/src/executioners/FixedPointSolve.C:393\n#20 0x00007ffff4798912 in FixedPointSolve::solve (this=0x555555a501e0) at /home/ddd/projects/moose/framework/src/executioners/FixedPointSolve.C:274\n#21 0x00007ffff499087c in TimeStepper::step (this=0x555555d92630) at /home/ddd/projects/moose/framework/src/timesteppers/TimeStepper.C:161\n#22 0x00007ffff47a7e96 in Transient::takeStep (this=0x555555b39fc0, input_dt=-1) at /home/ddd/projects/moose/framework/src/executioners/Transient.C:444\n#23 0x00007ffff47a71c6 in Transient::execute (this=0x555555b39fc0) at /home/ddd/projects/moose/framework/src/executioners/Transient.C:329\n#24 0x00007ffff4fde2fa in MooseApp::executeExecutioner (this=0x5555557362b0) at /home/ddd/projects/moose/framework/src/base/MooseApp.C:1101\n#25 0x00007ffff4fe130c in MooseApp::run (this=0x5555557362b0) at /home/ddd/projects/moose/framework/src/base/MooseApp.C:1415\n#26 0x0000555555557739 in main (argc=3, argv=0x7fffffffc378) at /home/ddd/projects/bees_new/src/main.C:33",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4057893",
                          "updatedAt": "2022-11-04T15:14:24Z",
                          "publishedAt": "2022-11-04T15:14:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "nothing obvious to me.\nSeems it needs more digging, and we need to figure out if it s a related problem or not",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4058646",
                          "updatedAt": "2022-11-04T16:20:41Z",
                          "publishedAt": "2022-11-04T16:20:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@hugary1995 do you know who is in charge of CZM?\nGit blame says @arovinelli",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4058657",
                          "updatedAt": "2022-11-04T16:22:07Z",
                          "publishedAt": "2022-11-04T16:22:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@hugary1995 do you know who is in charge of CZM? Git blame says @arovinelli\n\nYes I did developed it at the beginning and the master PR was mine. But I'm not working on it since I moved. @hugary1995 What's the question?",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4058692",
                          "updatedAt": "2022-11-04T16:26:37Z",
                          "publishedAt": "2022-11-04T16:26:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "We need a MFE. @echo1115 can you try adding use_displaced_mesh = false in the FunctionIsotropicEigenstrain object?",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4058783",
                          "updatedAt": "2022-11-04T16:37:05Z",
                          "publishedAt": "2022-11-04T16:37:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@hugary1995  thanks. I followed your suggestion:\n\ntry adding use_displaced_mesh = false in the FunctionIsotropicEigenstrain object\n\nand the case can run now!\nBut I felt it odd, why the calculating is not on displaced mesh\uff1fDoes that means i should set use_displaced_mesh = false in all Eigenstain calculating objects when CZM used?",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4059616",
                          "updatedAt": "2022-11-04T18:15:24Z",
                          "publishedAt": "2022-11-04T18:15:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Does that means i should set use_displaced_mesh = false in all Eigenstain calculating objects when CZM used?\n\nYes. More radically speaking, I'd recommend always defining eigenstrain on the undisplaced mesh. Unless @bwspenc can help me understand why he did it the other way around in FunctionIsotropicEigenstrain.",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4060252",
                          "updatedAt": "2022-11-04T19:31:25Z",
                          "publishedAt": "2022-11-04T19:31:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@hugary1995 Could you tell me why the strain should be applied on undisplaced mesh? To my understanding, the mesh is deformed during  the simulation. Thanks a lot!",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4063476",
                          "updatedAt": "2022-11-05T12:33:26Z",
                          "publishedAt": "2022-11-05T12:33:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some questions about Materials and Executioner",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, experts. I have some questions.\n\n\nIn a transient simulation, can I substitute the material properties used at a certain time? My material properties are obtained from a txt file. For example, at 10s, I want to replace the material properties with another txt file, can MOOSE do this?\n\n\nThere are several physics involved in my transient simulation, let's call them A, B, C. Different physics can achieve different convergence tolerances. I mean, nl_rel_tol = 1e-4 might be small enough for A, but nl_rel_tol = 1e-10 for B physics to meet our requirements. However A, B, C are all solved in one input file. So I wonder if MOOSE can set different convergence criteria for different variable groups.\n\n\nDoes MOOSE judge as Solving Converged as long as one of the convergence criteria is met? For example, if I set nl_abs_tol=1e-8 and nl_rel_tol=1e-8 in Executioner, as long as the nonlinear iteration residual meets one of these two criteria, will it be judged as Solving Converged?",
          "url": "https://github.com/idaholab/moose/discussions/22708",
          "updatedAt": "2022-11-16T02:04:24Z",
          "publishedAt": "2022-11-15T15:48:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\n\n\nThere's a few ways to do this.\nOne way is to use the Control system to substitute one material by another. You disable the old one, enable the new one using one to the ConditionalEnableControl objects\nAnother way is to write a checkpoint and reload from that checkpoint in another input file with the updated material\n\n\n\nWe can do this using manual scaling. Scale each variables corresponding to each physics using the scaling_factor parameter in the variables block.\nThe residual is then scaled by this factor. see this porous flow example\nhttps://mooseframework.inl.gov/modules/porous_flow/convergence.html\n\n\n\nYes. As soon as you meet one of the criteria we consider the simulation converged.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22708#discussioncomment-4148196",
                  "updatedAt": "2022-11-15T16:04:40Z",
                  "publishedAt": "2022-11-15T16:04:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thank you, Guillaume. Your suggestions are very helpful.",
                          "url": "https://github.com/idaholab/moose/discussions/22708#discussioncomment-4152363",
                          "updatedAt": "2022-11-16T02:04:25Z",
                          "publishedAt": "2022-11-16T02:04:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Time stepper for very stiff systems",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "John Mangeri and I have been working on a micromagnetic module ('ferret') for MOOSE. Because the norm of the magnetization vector field is conserved at each point in space, we were trying to implement spherical coordinates, as this will automatically eliminate a problem of renormalizing the vector field at each time step (and reduces the DOFs). It turns out, however, that the governing equations, the Landau-Lifshitz-Gilbert equations, are very stiff, in particular in spherical coordinates. We have scoured through different time-integrators and time stepper in MOOSE, but the result always ends up being the same: the solutions become unstable after some time and start to diverge. A particularly sensitive test of solving the equations of motion is to turn the damping, 'alpha', to zero, in which case total energy should be strictly conserved. It is not in spherical coordinates - even with tiny time steps, the energy starts to diverge (increase) after some number of timesteps. It appears that the main cause of these problems is the magnetic exchange coupling. In simple test systems without exchange ('macrospins'), we can make the energy strictly conserved in the absence of damping, but the timesteps have to be tiny, otherwise the energy oscillates (but does not diverge).\nWe are interested in reaching out to the MOOSE community to hear if others have had similar or analogous problems, and what they did to address it. One potential path is to use more timestepper options that are available in PETSc, or other more complicated implicit steppers, but such pathways are beyond my comfort zone to implement in MOOSE.\nI suspect part of why this is a problem may have to do with the nature of weak formulations. In strong formulations I can make (in my own codes as well as others') energy conservation be respected. I am guessing that the elemental form of the nonlinear variables in weak formulation causes the problem: the delicate and precise solutions that you need to preserve norm and energy are possible in strong formulations but get washed out in weak formulation.\nI would be really interested in hearing comments and suggestions from the MOOSE community!",
          "url": "https://github.com/idaholab/moose/discussions/21879",
          "updatedAt": "2022-11-15T21:03:28Z",
          "publishedAt": "2022-08-18T15:06:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cticenhour",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3424273",
                  "updatedAt": "2022-08-18T15:55:04Z",
                  "publishedAt": "2022-08-18T15:55:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@idaholab/moose-team\n@hugary1995 @sapitts",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3424439",
                          "updatedAt": "2022-08-18T16:17:26Z",
                          "publishedAt": "2022-08-18T16:17:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "Pardon my ignorant questions; I don't think I can help but there's a slim chance I could elicit information that might be enough for someone else to help.\nCan you post the weak formulation you're using and the FE space you've chosen?  Also, is there a particular mode you're seeing in the diverging solutions?\nAlso, by spherical coordinates, do you mean that instead of solving for the evolution of M_x,M_y,M_z, you're trying to solve for M_theta and M_phi?  If so ... is there even an upper bound on the stiffness you get from that?  As the polar angle goes to zero, the sensitivity of the azimuthal angle to the actual vector position goes to infinity.  The problem is like gimbal lock, but the solutions I've heard of for gimbal lock (rotation matrices, quaternions) involve exactly the sort of \"extra DoFs + renormalization\" that you're trying to avoid!",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3426896",
                  "updatedAt": "2022-08-18T21:41:35Z",
                  "publishedAt": "2022-08-18T21:41:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hello,\n\nYou are correct that we are trying to solve for m_theta and m_phi instead\nof for the Cartesian components. What I have been using for test problems\nvery carefully avoid getting theta close to either pole in order to avoid\nissues with approaching singularities at the poles.\n\nI am not sure that there is a particular mode that diverges - I have not\ndone a careful instability analysis. Heuristically, in these small test\nsystems, a few spins start to get unstable and just take off to stupid\nvalues.\n\nThe weak formulation is just a standard weak formulation of the\nLandau-Lifshitz-Gilbert equations, with appropriate partial integrations on\nthe contribution to residuals from the exchange field to move one\nderivative order from the magnetization vector field to the test functions.\nI can send you more details if you want.\n\nCheers,\nOlle\n\u2026\nOn Thu, Aug 18, 2022 at 4:41 PM roystgnr ***@***.***> wrote:\n Pardon my ignorant questions; I don't think I can help but there's a slim\n chance I could elicit information that might be enough for someone else to\n help.\n\n Can you post the weak formulation you're using and the FE space you've\n chosen? Also, is there a particular mode you're seeing in the diverging\n solutions?\n\n Also, by spherical coordinates, do you mean that instead of solving for\n the evolution of M_x,M_y,M_z, you're trying to solve for M_theta and M_phi?\n If so ... is there even an upper bound on the stiffness you get from that?\n As the polar angle goes to zero, the sensitivity of the azimuthal angle to\n the actual vector position goes to infinity. The problem is like gimbal\n lock, but the solutions I've heard of for gimbal lock (rotation matrices,\n quaternions) involve exactly the sort of \"extra DoFs + renormalization\"\n that you're trying to avoid!\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF7TWE3WXOKEXPCTZXDVZ2UZRANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3426931",
                  "updatedAt": "2022-08-18T21:48:04Z",
                  "publishedAt": "2022-08-18T21:48:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "What time integration scheme is typically used in the literature for these problems?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3429452",
                          "updatedAt": "2022-08-19T08:23:17Z",
                          "publishedAt": "2022-08-19T08:23:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Good question. In Cartesian coordinates usually higher-order (explicit)\nRunge-Kutta. I use an implicit Bulirch-Stoer method. For spherical\ncoordinates, the literature is pretty quiet as far as I know. There is an\nold code, MagPar (you can find it on gitHub), that uses spherical\ncoordinates and BDF stepper from SUNDIAL but apparently that does not\nwork so well for a lot of problems.\n\u2026\nOn Fri, Aug 19, 2022 at 3:23 AM Alex Lindsay ***@***.***> wrote:\n What time integration scheme is typically used in the literature for these\n problems?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF22ZZMEFICPHIKDBUDVZ5AABANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3431430",
                  "updatedAt": "2022-08-19T13:15:49Z",
                  "publishedAt": "2022-08-19T13:15:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Have you tried BDF2 in MOOSE? It sounds like maybe you have? When the energy starts to diverge, is that with a constant time step?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3455526",
                          "updatedAt": "2022-08-23T10:59:13Z",
                          "publishedAt": "2022-08-23T10:59:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "That's surprising.  I know a change of variables can screw up your discrete stability, but if your solution is staying well away from the pole singularities I don't see how the stability could easily go from \"fits in the small bounded stability region promised by RK\" to \"unstable even with an implicit method\".  I'm not familiar with Bulirch-Stoer ... but it's in the explicit volume of Hairer & Wanner, and the examples I can find online look explicit too.  You're using a version that's built around the implicit midpoint method instead of the explicit midpoint method?  Any idea what the stability domain looks like?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3460162",
                          "updatedAt": "2022-08-23T20:45:30Z",
                          "publishedAt": "2022-08-23T20:45:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hi Guillaume,\n\nYes, I have tried BDF2 with adaptive steps. But I have also set the dtmax\nto some ridiculously small time step - system still goes nuts. The problems\nstart not with difficulties diverging but with some number of spins\nbecoming unstable (exchange coupling should keep the spin texture smooth\nbut some spins start to deviate from the smoothness).\n\u2026\n-Olle\nOn Tue, Aug 23, 2022 at 5:59 AM Alex Lindsay ***@***.***> wrote:\n Have you tried BDF2 in MOOSE? It sounds like maybe you have? When the\n energy starts to diverge, is that with a constant time step?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF4GSTMGLBWBG2YCY7LV2SVIXANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3456588",
                  "updatedAt": "2022-08-23T13:15:08Z",
                  "publishedAt": "2022-08-23T13:15:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "linsdayad is actually Alex, I'm Guillaume\nIs there some literature about stabilizing those solves?\nCould you add some sort of diffusive term to those equations?\nWe also have Runge Kunta schemes at various orders btw.\nWhen you say some spins become unstable, how do you diagnose that? Are they a separate variable?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3457092",
                          "updatedAt": "2022-08-23T14:08:51Z",
                          "publishedAt": "2022-08-23T14:08:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hi,\n\nThe spins are the nonlinear variables. We monitor the instability in\ndifferent ways. Typically, the exchange starts to grow (some neighboring\nspins start to become misaligned) and visually we confirm that misalignment\nof neighboring spins starts. I have tried a variety of steppers. Typically,\nthe Newmarkbeta works the best for when we use a Cartesian representation\nbut that one too becomes unstable in spherical representation.\n\nI am not aware of any particular literature on how to stabilize the solvers\nfor spherical coordinates. It is perhaps possible to add a diffusive term\nto stabilize the equations but it has to be done such that the equations of\nmotion (the physics) are not made unphysical.\n\u2026\nOn Tue, Aug 23, 2022 at 9:09 AM Guillaume Giudicelli < ***@***.***> wrote:\n linsdayad is actually Alex, I'm Guillaume\n\n Is there some literature about stabilizing those solves?\n Could you add some sort of diffusive term to those equations?\n\n We also have Runge Kunta schemes at various orders btw.\n\n When you say some spins become unstable, how do you diagnose that? Are\n they a separate variable?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF3I6QQSTGTZ7DLQWJDV2TLP5ANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3458007",
                  "updatedAt": "2022-08-23T15:52:47Z",
                  "publishedAt": "2022-08-23T15:52:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "how big are the numerical systems btw?\nAnd the linear and nonlinear solves are fine, you never just accept an insufficiently converged solution, this is only a time stepping issue?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3458266",
                          "updatedAt": "2022-08-23T16:14:34Z",
                          "publishedAt": "2022-08-23T16:14:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "The numerical systems range from some 10k DOFs to many (many) millions of\nDOFs. Yes, the linear and nonlinear solvers are fine, it seems to be\nprimarily a time-stepping issue. Of course, as some spin DOFs start to get\nwonky it becomes difficult for the linear and nonlinear solvers to\nconverge, but I believe that is a secondary problem.\n\u2026\nOn Tue, Aug 23, 2022 at 11:14 AM Guillaume Giudicelli < ***@***.***> wrote:\n how big are the numerical systems btw?\n And the linear and nonlinear solves are fine, you never just accept an\n insufficiently converged solution, this is only a time stepping issue?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF7MSJ75CW7WJOZ4TBLV2T2HLANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3459268",
                  "updatedAt": "2022-08-23T18:27:41Z",
                  "publishedAt": "2022-08-23T18:27:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "at 10k DOFs, with some patience, we may be able to use the svd_monitor to check that the problems are actually well conditioned\nIf this is strictly a time-stepping issue, I think we should look at a fourier analysis of the system, then look at which schemes should be stable and why they are not.",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3459424",
                          "updatedAt": "2022-08-23T18:50:45Z",
                          "publishedAt": "2022-08-23T18:50:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I am not familiar with this particular physics you are looking at. But like you said, it sounds like the literature is scarce in this direction. So treating this as a research question, I would first sit down and go through the stability analysis for this discretization. It may very well be the case that the inf-sup condition is okay in cartesian but not in other coordinates.",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3459435",
                          "updatedAt": "2022-08-23T18:52:16Z",
                          "publishedAt": "2022-08-23T18:52:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hi Gary and Roy,\n\nThanks for your comments. The Bulirch-Stoer stepper I built (for\nfinite-difference and FFT methods) is an implicit one, pretty much straight\nout of Numerical Recipes - for Cartesian coordinates. I have not tried it\nfor spherical coordinates.\n\nI have no idea about stability regions - I have not done any stability\nanalyses.\n\nCheers,\nOlle\n\u2026\nOn Tue, Aug 23, 2022 at 3:45 PM roystgnr ***@***.***> wrote:\n That's surprising. I know a change of variables can screw up your discrete\n stability, but if your solution is staying well away from the pole\n singularities I don't see how the stability could easily go from \"fits in\n the small bounded stability region promised by RK\" to \"unstable even with\n an implicit method\". I'm not familiar with Bulirch-Stoer ... but it's in\n the explicit volume of Hairer & Wanner, and the examples I can find online\n look explicit too. You're using a version that's built around the implicit\n midpoint method instead of the explicit midpoint method? Any idea what the\n stability domain looks like?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF3DRCKFGEDE3ISQ4A3V2UZ7LANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3467754",
                  "updatedAt": "2022-08-24T17:13:59Z",
                  "publishedAt": "2022-08-24T17:13:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mangerij"
                  },
                  "bodyText": "I like the idea of using svd-monitor.\n\nI will try this for a small problem with Cartesian (working just doesn't scale the dof that Olle and company need) and also the spherical formulation (doesn't work/converge at any scale).\n\nGet Outlook for Android<https://aka.ms/AAb9ysg>\n\u2026\n________________________________\nFrom: Olle Heinonen ***@***.***>\nSent: Wednesday, August 24, 2022 8:14:12 PM\nTo: idaholab/moose ***@***.***>\nCc: Subscribed ***@***.***>\nSubject: Re: [idaholab/moose] Time stepper for very stiff systems (Discussion #21879)\n\n\n*Message sent from a system outside of UConn.*\n\n\nHi Gary and Roy,\n\nThanks for your comments. The Bulirch-Stoer stepper I built (for\nfinite-difference and FFT methods) is an implicit one, pretty much straight\nout of Numerical Recipes - for Cartesian coordinates. I have not tried it\nfor spherical coordinates.\n\nI have no idea about stability regions - I have not done any stability\nanalyses.\n\nCheers,\nOlle\nOn Tue, Aug 23, 2022 at 3:45 PM roystgnr ***@***.***> wrote:\n That's surprising. I know a change of variables can screw up your discrete\n stability, but if your solution is staying well away from the pole\n singularities I don't see how the stability could easily go from \"fits in\n the small bounded stability region promised by RK\" to \"unstable even with\n an implicit method\". I'm not familiar with Bulirch-Stoer ... but it's in\n the explicit volume of Hairer & Wanner, and the examples I can find online\n look explicit too. You're using a version that's built around the implicit\n midpoint method instead of the explicit midpoint method? Any idea what the\n stability domain looks like?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF3DRCKFGEDE3ISQ4A3V2UZ7LANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n--\nOlle Heinonen\n***@***.***\n\n\u2014\nReply to this email directly, view it on GitHub<https://nam10.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fidaholab%2Fmoose%2Fdiscussions%2F21879%23discussioncomment-3467754&data=05%7C01%7C%7Ce381b6528ef146675cdb08da85f4115d%7C17f1a87e2a254eaab9df9d439034b080%7C0%7C0%7C637969580556339427%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=MduqIX1xn6jo2cLDIY9mwe%2FvExe%2FxV6hNqnV8T0P5Nk%3D&reserved=0>, or unsubscribe<https://nam10.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FABZ65FBNSAJKCIU6VUNVKCDV2ZJ6JANCNFSM565RIRGA&data=05%7C01%7C%7Ce381b6528ef146675cdb08da85f4115d%7C17f1a87e2a254eaab9df9d439034b080%7C0%7C0%7C637969580556495676%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=fkfQaO8%2Fm9e13xfhxxBGEg1HohEs8Uwbgv%2F2gwuOqBU%3D&reserved=0>.\nYou are receiving this because you are subscribed to this thread.Message ID: ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3468024",
                  "updatedAt": "2022-08-24T17:53:00Z",
                  "publishedAt": "2022-08-24T17:52:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "please let us know how it goes.\nI've seen a lot of time-stepping give insufficiently accurate answers but not with a refined timestep, hence the idea to have a look at other parts of the solve",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3539795",
                          "updatedAt": "2022-09-02T19:55:46Z",
                          "publishedAt": "2022-09-02T19:55:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any update on this?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3764457",
                          "updatedAt": "2022-09-29T16:29:38Z",
                          "publishedAt": "2022-09-29T16:29:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hi Guillaume,\n\nNo, have not had time to look into this more - have worked on the\nCartiesian version (which seems to be chugging along pretty nicely now).\n\nCHeers,\nOlle\n\u2026\nOn Thu, Sep 29, 2022 at 11:29 AM Guillaume Giudicelli < ***@***.***> wrote:\n Any update on this?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEFYLXQLRWQKI63QXUQTWAW7X3ANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3767624",
                  "updatedAt": "2022-09-30T01:40:40Z",
                  "publishedAt": "2022-09-30T01:40:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Found a mistake on EigenProblem.h",
          "author": {
            "login": "doquang"
          },
          "bodyText": "In the rev 6ff6864, @lindsayad added a new method getNonlinearEigenSystem(unsigned int nl_sys_num = 0) into framework/include/problems/EigenProblem.h.\nThe new method is inside a condition #ifdef LIBMESH_HAVE_SLEPC, but its implementation is outside this condition. It prevents to compile on a system that do not have SLEPC.",
          "url": "https://github.com/idaholab/moose/discussions/22622",
          "updatedAt": "2022-11-15T20:05:22Z",
          "publishedAt": "2022-11-08T14:42:34Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Thank you for the report @doquang . I will create an issue for this",
                  "url": "https://github.com/idaholab/moose/discussions/22622#discussioncomment-4090262",
                  "updatedAt": "2022-11-08T19:30:48Z",
                  "publishedAt": "2022-11-08T19:30:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Opened #22628",
                          "url": "https://github.com/idaholab/moose/discussions/22622#discussioncomment-4090306",
                          "updatedAt": "2022-11-08T19:36:08Z",
                          "publishedAt": "2022-11-08T19:36:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Issue is fixed",
                          "url": "https://github.com/idaholab/moose/discussions/22622#discussioncomment-4150176",
                          "updatedAt": "2022-11-15T20:05:23Z",
                          "publishedAt": "2022-11-15T20:05:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}