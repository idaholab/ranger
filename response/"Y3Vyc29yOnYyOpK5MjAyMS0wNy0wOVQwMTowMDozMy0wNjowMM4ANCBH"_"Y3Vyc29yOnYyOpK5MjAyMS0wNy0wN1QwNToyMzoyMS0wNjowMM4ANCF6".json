{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNy0wN1QwNToyMzoyMS0wNjowMM4ANCF6"
    },
    "edges": [
      {
        "node": {
          "title": "3D Finite volume flow around a sphere",
          "author": {
            "login": "adfboyd"
          },
          "bodyText": "Hello, as a new user, I'm trying to work out how to simulate flow moving around a sphere, using finite volume incompressible flow in 3D.  I have looked at the examples for finite volume (channel flow especially), but how to convert to 3D and add the sphere object in is proving difficult. Any advice on where to look/what to do would be much appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/17470",
          "updatedAt": "2022-07-26T02:26:31Z",
          "publishedAt": "2021-03-31T12:37:55Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou will need meshing software to create your geometry as moose cant mesh the outside of a 3D sphere as far as I know.\nIf you are a student / in academia you can use the student version of cubit.\nOnce you have a mesh, setting up the problem in finite volume INS should not be too bad and we can help you with that too.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-554723",
                  "updatedAt": "2022-07-26T02:26:31Z",
                  "publishedAt": "2021-03-31T20:52:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "I believe @dschwen has done this. He can probably provide a few pointers.",
                          "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-560219",
                          "updatedAt": "2022-07-26T02:26:31Z",
                          "publishedAt": "2021-04-01T21:18:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Here it is:\nhttps://mooseframework.inl.gov/source/meshgenerators/SphereSurfaceMeshGenerator.html\nI don't see a sample input file, but from the source it looks like the inputs are straightforward:\n\n  \n    \n      moose/modules/phase_field/src/meshgenerators/SphereSurfaceMeshGenerator.C\n    \n    \n        Lines 29 to 32\n      in\n      f6e5d67\n    \n  \n  \n    \n\n        \n          \n           params.addParam<Real>(\"radius\", 1.0, \"Sphere radius\"); \n        \n\n        \n          \n           params.addParam<Point>(\"center\", Point(0, 0, 0), \"Center of the sphere\"); \n        \n\n        \n          \n           params.addParam<unsigned int>( \n        \n\n        \n          \n               \"depth\", 3, \"Iteration steps in the triangle bisection construction\");",
                          "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-560321",
                          "updatedAt": "2022-07-26T02:26:32Z",
                          "publishedAt": "2021-04-01T21:46:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adfboyd"
                          },
                          "bodyText": "Thank you very much! I am a student, and this is very helpful! I may come back to ask about setting up the flow once I've tried it.",
                          "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-561999",
                          "updatedAt": "2022-07-26T02:26:36Z",
                          "publishedAt": "2021-04-02T10:51:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adfboyd"
                          },
                          "bodyText": "Now that the sphere can be generated, I'm afraid I'm still not sure how to set up a 3D flow and insert the sphere into it, are there any 3D examples for finite volume that I could look at? Thanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-576411",
                          "updatedAt": "2022-07-26T02:29:13Z",
                          "publishedAt": "2021-04-06T18:42:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are you using the SphereSurfaceMeshGenerator? Can you post a picture of the mesh?\nThere's no 3D examples but it should be very straightforward to extend 2D cases to 3D. Just add a w variable and use the same kernels.",
                          "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-576476",
                          "updatedAt": "2022-07-26T02:29:13Z",
                          "publishedAt": "2021-04-06T19:02:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adfboyd"
                          },
                          "bodyText": "I'm not sure how to use the SphereSurfaceMeshGenerator in order to actually generate an object, I'm afraid. I guess I'm also asking where I'm meant to do that. Is it done in the same application as the flow sim, or should it be used beforehand to make a file?\nThank you for your help again!",
                          "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-576511",
                          "updatedAt": "2022-07-26T02:29:13Z",
                          "publishedAt": "2021-04-06T19:09:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It's a mesh generator. So you would use it in the mesh block, in the same input file as the flow sim.\nI'm not convinced this is what you need though, but we ll see.\nHow about you start by creating a 3D channel with no sphere in it and we can advise you again once you have that working.",
                          "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-576531",
                          "updatedAt": "2022-07-26T02:29:13Z",
                          "publishedAt": "2021-04-06T19:14:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adfboyd"
                          },
                          "bodyText": "Thank you, that makes sense. I'll get that going.",
                          "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-576621",
                          "updatedAt": "2022-07-26T02:29:16Z",
                          "publishedAt": "2021-04-06T19:32:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adfboyd"
                          },
                          "bodyText": "I've edited the .i file for channel flow so that it should be suitable for 3D, however I'm afraid I'm not sure which kernels I should be linking to in order to run it. (I will test that the 2D example case runs first once I have this before seeking more help). Any help is much appreciated. Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-631143",
                          "updatedAt": "2022-07-26T02:29:16Z",
                          "publishedAt": "2021-04-19T16:14:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm adding a 3D test to INSFV. It wont be merged very soon but you'll find it in #17088 in like an hour",
                          "url": "https://github.com/idaholab/moose/discussions/17470#discussioncomment-638161",
                          "updatedAt": "2022-07-26T02:29:21Z",
                          "publishedAt": "2021-04-21T05:03:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Which code can we refer to if  phase field simulation of selective laser melting",
          "author": {
            "login": "mikejwg"
          },
          "bodyText": "Dear everyone,\nAnyone can share me the example similar to phase field simulation of selective laser melting, in which cooling rate and temperature gradient should be considered.\nI found  the examples in the phase field directory can not consider  cooling rate and temperature gradient.\nthanks.\nWG",
          "url": "https://github.com/idaholab/moose/discussions/16554",
          "updatedAt": "2022-06-17T08:04:09Z",
          "publishedAt": "2020-12-21T12:44:23Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hi, we currently don't have an example in the repository for directional solidification. We are doing some work in this area and are hoping to add an input file as an example in the next few months.",
                  "url": "https://github.com/idaholab/moose/discussions/16554#discussioncomment-231497",
                  "updatedAt": "2022-06-17T08:04:09Z",
                  "publishedAt": "2020-12-21T21:01:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mikejwg"
                          },
                          "bodyText": "Thanks for your reply.  Look forward to the work.  Hope the input file can consider rapid solidification because the cooling rate is  greater than 1e5 K/s and the temperature gradient is greater than  1e5 K/m during SLM process.",
                          "url": "https://github.com/idaholab/moose/discussions/16554#discussioncomment-232687",
                          "updatedAt": "2022-06-17T08:04:12Z",
                          "publishedAt": "2020-12-22T00:01:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "@mikejwg The following could be a starting point for what you need,\nhttps://github.com/idaholab/moose/blob/next/modules/phase_field/examples/anisotropic_interfaces/GrandPotentialPlanarGrowth.i",
                          "url": "https://github.com/idaholab/moose/discussions/16554#discussioncomment-238646",
                          "updatedAt": "2022-06-17T08:04:13Z",
                          "publishedAt": "2020-12-23T22:20:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mikejwg"
                          },
                          "bodyText": "Thanks. Could you show me which keywords respect to temperature gradient and cooling rate we should revise in this example for our purpose?",
                          "url": "https://github.com/idaholab/moose/discussions/16554#discussioncomment-240920",
                          "updatedAt": "2022-06-17T08:04:13Z",
                          "publishedAt": "2020-12-25T06:31:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "You will have to modify the following line for the temperature function, https://github.com/idaholab/moose/blob/next/modules/phase_field/examples/anisotropic_interfaces/GrandPotentialPlanarGrowth.i#L46",
                          "url": "https://github.com/idaholab/moose/discussions/16554#discussioncomment-253328",
                          "updatedAt": "2022-06-17T08:04:33Z",
                          "publishedAt": "2020-12-30T20:22:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "Hello, I hope it's okay if I ask a follow-up here:\n@SudiptaBiswas, could you please tell me why you recommend GrandPotentialPlanarGrowth.i here, as opposed to GrandPotentialSolidification.i?\nI am trying to simulate solidification from powder bed fusion, a type of selective laser melting, and saw that you recommended these examples in a related issue (#17689), but I chose to use the Solidification model file based only on its name.",
                          "url": "https://github.com/idaholab/moose/discussions/16554#discussioncomment-907500",
                          "updatedAt": "2022-06-17T08:04:32Z",
                          "publishedAt": "2021-06-22T23:32:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "GrandPotentialPlanarGrowth.i is for directional solidification whereas GrandPotentialSolidification.i is for isothermal solidification. Both use the same kernels and materials, only the initial condition and thermal field are different.",
                          "url": "https://github.com/idaholab/moose/discussions/16554#discussioncomment-953229",
                          "updatedAt": "2022-06-17T08:04:33Z",
                          "publishedAt": "2021-07-01T20:32:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "That makes sense, thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/16554#discussioncomment-980178",
                          "updatedAt": "2022-06-17T08:04:37Z",
                          "publishedAt": "2021-07-08T15:28:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@mikejwg\nI am not working on phase field, but just simulating the selecting laser melting\ncoupled with crystal plasticity model.\nYou can find some code and examples here:\nhttps://github.com/ngrilli/c_pfor_am\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/16554#discussioncomment-256171",
                  "updatedAt": "2022-06-17T08:04:19Z",
                  "publishedAt": "2021-01-02T02:44:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mikejwg"
                          },
                          "bodyText": "Thanks very much for your kindness.  Could you share me one completed SLM example (input file)?  Anyway, thanks  a  lot for the codes.\nBest regards,\njiangwugui@gmail.com",
                          "url": "https://github.com/idaholab/moose/discussions/16554#discussioncomment-258149",
                          "updatedAt": "2022-06-17T08:05:05Z",
                          "publishedAt": "2021-01-03T12:39:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Temperature Variable in Solidification",
          "author": {
            "login": "rl3fz"
          },
          "bodyText": "Hello everyone,\nIs there a way to incorporate both undercooling and a thermal gradient in solidification modeling? I'm tinkering with GrandPotentialPlanarGrowth.i and GrandPotentialSolidification.i as a start, but I'm not sure which is more appropriate.\nAny advice would be greatly appreciated!\n(Edit: For reference https://github.com/idaholab/moose/tree/next/modules/phase_field/examples/anisotropic_interfaces)",
          "url": "https://github.com/idaholab/moose/discussions/18159",
          "updatedAt": "2022-06-17T08:08:51Z",
          "publishedAt": "2021-06-23T22:34:00Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hi there, it sounds like you are interested in alloy solidification rather than pure material solidification. In alloy solidification, typically solute diffuses much more slowly than heat, so temperature can be considered fixed by constraints external to the system and the latent heat of solidification can be neglected.\nIn that case, a fixed amount of undercooling (solidification at a constant temperature) can be accounted by setting the free energies for the solid and liquid phases to the appropriate values based on the system temperature. A temperature gradient can be included by making the free energies of the solid and liquid phases a function of position along the solidification direction- so the thermal gradient determines the temperature profile, which we do not solve for as a field variable. Instead we take that temperature as a function of position and modify the free energy of the solid and liquid phases as a function of temperature. To implement this, you could create an AuxVariable for temperature, and use a Function to set the temperature as a function of position. Then you could use a DerivativeParsedMaterial to make the solid and liquid phase free energies a function of the temperature (and if you are using one of the grand potential models, you'll need to convert from free energy density to grand potential density).",
                  "url": "https://github.com/idaholab/moose/discussions/18159#discussioncomment-940230",
                  "updatedAt": "2022-06-17T08:08:51Z",
                  "publishedAt": "2021-06-29T20:46:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "I'll try this, thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18159#discussioncomment-980168",
                          "updatedAt": "2022-06-17T08:09:02Z",
                          "publishedAt": "2021-07-08T15:26:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Help with Update",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "Dear MOOSE Group,\nI am trying to update and got an error message as:\n% conda activate moose\n% conda update --all\nCollecting package metadata (current_repodata.json): failed\nCondaHTTPError: HTTP 000 CONNECTION FAILED for url https://conda.anaconda.org/idaholab/osx-64/current_repodata.json\nElapsed: -\nAn HTTP error occurred when trying to retrieve this URL.\nHTTP errors are often intermittent, and a simple retry will get you on your way.\n'https://conda.anaconda.org/idaholab/osx-64'\nPlease help.\nThomas",
          "url": "https://github.com/idaholab/moose/discussions/17918",
          "updatedAt": "2023-08-29T18:37:46Z",
          "publishedAt": "2021-05-24T21:16:51Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "As the error message states, these errors are intermittent. I am positive if you try again, it will work. Normally, you can try again immediately after seeing an error like this, and it will work.",
                  "url": "https://github.com/idaholab/moose/discussions/17918#discussioncomment-780971",
                  "updatedAt": "2023-08-29T18:37:46Z",
                  "publishedAt": "2021-05-25T12:56:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "It is still not working. If it is not intermittent, what would you recommend me to do?\nPlease let me know.\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17918#discussioncomment-783350",
                          "updatedAt": "2023-08-29T18:37:46Z",
                          "publishedAt": "2021-05-25T21:17:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I wonder if Anaconda broke our stuff? The following URL does not work:\nhttps://conda.anaconda.org/idaholab/osx-64/current_repodata.json\nbut all the packages are available:\nhttps://conda.anaconda.org/idaholab/osx-64\nWe don't really have access to build the current_repodata.json file. Anaconda does this for you when you upload a package. Very strange. I'll look into it.",
                          "url": "https://github.com/idaholab/moose/discussions/17918#discussioncomment-783481",
                          "updatedAt": "2023-08-29T18:37:46Z",
                          "publishedAt": "2021-05-25T21:51:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rks171"
                          },
                          "bodyText": "I had this same issue and what worked for me was to disable ssl verirification by typing the following and then trying again.\nconda config --set ssl_verify False",
                          "url": "https://github.com/idaholab/moose/discussions/17918#discussioncomment-979417",
                          "updatedAt": "2023-08-29T18:37:46Z",
                          "publishedAt": "2021-07-08T13:01:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the variable value in the former and next nodes?",
          "author": {
            "login": "YuhangNIU"
          },
          "bodyText": "Hi all,\nAs we all know, the current variable value can be described as u(i) = _u[_qp]. Could anyone kindly tell me how to get the variable value in the former and next nodes? I want to calculate the formula, just like:\nAu(i-1) + Bu(i+1)\nThank you!\nYuhang",
          "url": "https://github.com/idaholab/moose/discussions/18274",
          "updatedAt": "2023-04-25T22:33:22Z",
          "publishedAt": "2021-07-07T02:40:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "You'll have to be more precise about what you mean by \"former and next nodes\".   Do you mean the next node in the list of nodes of the particular element.  Or nodes in a neighbouring element.  Or something else?",
                  "url": "https://github.com/idaholab/moose/discussions/18274#discussioncomment-972935",
                  "updatedAt": "2023-04-25T22:33:22Z",
                  "publishedAt": "2021-07-07T04:10:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "YuhangNIU"
                          },
                          "bodyText": "If we use the 1D GeneratedMesh setting nx=100, there are 100 nodes in this mesh.\nSupposing the current variable value in the fifth node is described as u(i) = _u[_qp], \"the former\" represents variable value in the fourth node, and \"the next\" represents variable value in the sixth node.",
                          "url": "https://github.com/idaholab/moose/discussions/18274#discussioncomment-973380",
                          "updatedAt": "2023-04-25T22:33:22Z",
                          "publishedAt": "2021-07-07T07:09:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "What are you actually trying to do?  Form a spatial derivative?  MOOSE has that sort of functionality inbuilt.  Or are you doing some numerical stabilization involving values at lots of nodes?  That's more complicated, but has been done in MOOSE too, so we can help you.\nThe chances are that MOOSE has an elegant way of doing what you want.  BUT, if you just want all raw nodal values, you can use a NodalValueSampler VectorPostprocessor to record all the nodal values.",
                          "url": "https://github.com/idaholab/moose/discussions/18274#discussioncomment-973994",
                          "updatedAt": "2023-04-25T22:33:22Z",
                          "publishedAt": "2021-07-07T09:42:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YuhangNIU"
                          },
                          "bodyText": "Thanks for the help. I'll try to use the NodalValueSampler! Much appreciated.",
                          "url": "https://github.com/idaholab/moose/discussions/18274#discussioncomment-977208",
                          "updatedAt": "2023-04-25T22:34:03Z",
                          "publishedAt": "2021-07-08T01:36:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @YuhangNIU\nInside a kernel, you can access the value of the variable at the nodes using:\n_u_nodal(_var.dofValues()),\nthis is a vector that contains the nodal values. You can see an example code here:\nhttps://github.com/idaholab/moose/blob/next/framework/src/kernels/ConservativeAdvection.C\nBest Regards,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18274#discussioncomment-978854",
                          "updatedAt": "2023-04-25T22:34:03Z",
                          "publishedAt": "2021-07-08T10:26:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "What is the water-phase pressure P_w in the capillary pressure",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "(This message was posted on behalf of samuel171228 who posted the original question on the defunct google-groups.)\nHello all MOOSE user\nI'm using a porous flow module to make single-phase, unsaturated flow in porous media.\nTo calculate saturation and relative permeability.\nBut I have some problem with the definition of the capillary pressure\nI think When we calculate capillary pressure(P_c), the P_c is the difference between water-phase pressure and gas-phase pressure\n-> P_c = - P_w\n(because of single-phase & unsaturated flow)\nIn here, what is the P_w?\nIs it pore-pressure or not?\n(In my input file, the pore-pressure can be calculated as hydrostatic pressure)",
          "url": "https://github.com/idaholab/moose/discussions/17519",
          "updatedAt": "2022-07-26T13:15:06Z",
          "publishedAt": "2021-04-06T09:40:53Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Hi Samuel,\nWelcome to MOOSE and PorousFlow.  You are correct that P_c = -P_w, and that P_w is porepressure (in your single-phase case).  Note that if P_w >= 0 then the system is fully saturated (S_w = 1) and so P_c has no physical meaning (in your single-phase case).  When P_w < 0 then the system is unsaturated (S_w < 1) and P_c > 0, and P_c has a physical meaning.\na",
                  "url": "https://github.com/idaholab/moose/discussions/17519#discussioncomment-574039",
                  "updatedAt": "2022-07-26T13:16:25Z",
                  "publishedAt": "2021-04-06T09:44:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Without further input from Samuel, i'm marking this as \"answered\".",
                          "url": "https://github.com/idaholab/moose/discussions/17519#discussioncomment-582892",
                          "updatedAt": "2022-07-26T13:16:26Z",
                          "publishedAt": "2021-04-08T05:07:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "samuel171748"
                          },
                          "bodyText": "Oh Andy, Thank you for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/17519#discussioncomment-978269",
                          "updatedAt": "2022-07-26T13:17:35Z",
                          "publishedAt": "2021-07-08T08:07:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "problem to define a parameter",
          "author": {
            "login": "sSajjad90"
          },
          "bodyText": "Hi,\nI am working on a numerical code to develop the material solution and have to define many variables that read and write data. I have got a problem defining this kind of parameter that did not provide the proper results. Would you please let me what is wrong in defining the code?\nA simple part of code and the results are in the following:\nfor example, a simple parameter like \"_count\"  is defined  in a part of the code which must be started from \"0\" and growth with \"1\" for each iteration, but it provides the wrong data\nI defined a public class of material in the *.h file\n#pragma once\n#include \"Material.h\"\nclass last : public Material\n{\npublic:\nstatic InputParameters validParams();\nlast(const InputParameters & parameters);\nprotected:\nvirtual void computeQpProperties() override;\nvirtual void initQpStatefulProperties() override;\nMaterialProperty & _C_star;\nReal _count;\nthe relevant parts of *.C file :\n_count++;\n_C_star[_qp] = _count;\n\nResult:\n----------------+----------------+\n| time           | C_star         |\n+----------------+----------------\n|   5.000000e-01 |    2.305000e+02 |\n|   1.000000e+00 |   4.905000e+02 |\n|   1.500000e+00 |   7.505000e+02 |\n|   2.000000e+00 |   1.010500e+03 |\n|   2.500000e+00 |   1.270500e+03 |\n|   3.000000e+00 |   1.530500e+03 |\n|   3.500000e+00 |   1.790500e+03 |\n|   4.000000e+00 |   2.050500e+03 |\n|   4.500000e+00 |   2.310500e+03 |\n|   5.000000e+00 |   2.570500e+03 |\n|   5.500000e+00 |   2.830500e+03 |\n|   6.000000e+00 |   3.090500e+03 |\n|   6.500000e+00 |   3.350500e+03 |\n|   7.000000e+00 |   3.610500e+03 |\n|   7.500000e+00 |   3.870500e+03 |\nI suppose I have to add a \"GenericConstantMaterial\" class to define these types of variables. Could you let me know how can I do it in *.h and *.C files?\nThanks in advance,\nSajjad",
          "url": "https://github.com/idaholab/moose/discussions/17858",
          "updatedAt": "2023-02-16T22:48:32Z",
          "publishedAt": "2021-05-17T18:07:36Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Sajjad\nI think one problem is that those lines are executed more than once per time step. The material properties are evaluated many times, at initialization, at every non-linear iteration, for residuals, for jacobians etc.\nYou could add a check based on the current time step and the last time step _count was incremented. This would limit the number of times _count is incremented\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17858#discussioncomment-750364",
                  "updatedAt": "2023-03-07T23:57:06Z",
                  "publishedAt": "2021-05-17T23:20:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sSajjad90"
                          },
                          "bodyText": "Hi,\nMany thanks,\nWould you please let me know how can add the check based on the current time step and the last time step _count?\nI used the \"ElementAverageValue\" posts processor that may cause the problem. I checked the different types of executes but they did not work properly.\nAny suggestion?",
                          "url": "https://github.com/idaholab/moose/discussions/17858#discussioncomment-753484",
                          "updatedAt": "2023-03-07T23:57:06Z",
                          "publishedAt": "2021-05-18T15:16:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You could add a parameter like _current_timestep and have an if condition :\nif (_t != _current_timestep)\n{\n  // do the increment\n  \n  _current_timestep = _t;\n}\n\nIs _C_star going to be constant across the domain?\nIf not you ll need _current_timestep to be a field not just a single value",
                          "url": "https://github.com/idaholab/moose/discussions/17858#discussioncomment-753523",
                          "updatedAt": "2023-03-08T18:42:11Z",
                          "publishedAt": "2021-05-18T15:22:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sSajjad90"
                          },
                          "bodyText": "Dear Guillaume,\nwould you please add the command you already told me to the below code? I have got stock to control the number of iteration. In the following, there is a very simple code test just to evaluate _count++ and you could see *.C, *.h and the *.i files.\ntest.h file:\n#pragma once\n\n#include \"Material.h\"\n\n/**\n *\n */\nclass test : public Material\n{\npublic:\n  static InputParameters validParams();\n\n  test(const InputParameters & parameters);\n\nprotected:\n  // virtual void initQpStatefulProperties() override;\n  void computeQpProperties();\n\n\n  int _count;\n  MaterialProperty<Real> & _C_star;\n\n};\n\n\ntest.C file:\n#include \"test.h\"\n\nregisterMooseObject(\"precipitationApp\", test);\n\nInputParameters\ntest::validParams()\n{\n  InputParameters params = Material::validParams();\n  params.addRequiredParam<std::string>(\"f_name_Cstar\", \"name of the ac function.\");\n\n  return params;\n}\n\ntest::test(const InputParameters & parameters)\n  : Material(parameters),\n  _C_star(declareProperty<Real>(getParam<std::string>(\"f_name_Cstar\"))),\n  _count(0)\n{\n}\n// void\n// test::initQpStatefulProperties()\n// {\n//\n// }\nvoid\ntest::computeQpProperties()\n{\n  _count++;\n  _C_star[_qp]= _count;\n}\n\n\ntest.i file:\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  xmin = 0\n  xmax = 1\n  nx = 10\n[]\n[Problem]\n  kernel_coverage_check = false\n  solve = false\n[]\n\n[AuxVariables]\n  [./prop1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n[AuxKernels]\n  [./prop1_output]\n    type = MaterialRealAux\n    variable = prop1\n    property = C_star\n    execute_on = 'TIMESTEP_END'\n  [../]\n[]\n[Materials]\n  [./MixedModeFiniteSystem]\n    type = test\n    f_name_Cstar = 'C_star'\n    f_name_2Cstar = 'C_2star'\n  [../]\n[]\n[Postprocessors]\n  [./C_star]\n    type = ElementAverageValue\n    variable = prop1\n    execute_on = 'TIMESTEP_END'\n  [../]\n  [./C_star2]\n    type = ElementAverageMaterialProperty\n    mat_prop = 'C_star'\n    execute_on = 'TIMESTEP_END'\n  [../]\n\n\n[]\n[Executioner]\n  type = Transient\n  solve_type = PJFNK\n  start_time = 0\n  end_time = 5\n  dt = 1\n\n[]\n\n[Outputs]\nexodus = true\ncsv = true\n[]\n\n\ntest.zip",
                          "url": "https://github.com/idaholab/moose/discussions/17858#discussioncomment-755833",
                          "updatedAt": "2023-03-08T18:41:56Z",
                          "publishedAt": "2021-05-19T02:02:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Closing this. Hope you managed to implement the pseudo code yourself",
                          "url": "https://github.com/idaholab/moose/discussions/17858#discussioncomment-977127",
                          "updatedAt": "2023-03-08T18:42:03Z",
                          "publishedAt": "2021-07-08T00:45:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Apply boundary conditions to different parts of stitched mesh",
          "author": {
            "login": "pratyushpotu"
          },
          "bodyText": "Hi, I am trying to apply boundary conditions to certain boundaries on a mesh comprised of three boxes stitched together horizontally (left, middle, and right). In particular, I'm trying to assign an id to the top part of the left box for instance, but whenever I try applying a boundary condition it applies to the top of the whole mesh instead of just one component. Thus, I was wondering how to apply boundary conditions to different boundaries like the top part of the left box and the bottom part of the right box.",
          "url": "https://github.com/idaholab/moose/discussions/18282",
          "updatedAt": "2022-08-16T02:09:44Z",
          "publishedAt": "2021-07-07T21:09:49Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou could try to use\nhttps://mooseframework.inl.gov/source/meshgenerators/BreakBoundaryOnSubdomainGenerator.html\nOR\nhttps://mooseframework.inl.gov/source/meshgenerators/BoundingBoxNodeSetGenerator.html\nThe first will require the boxes to be different blocks. The last one will require you to be a little mindful of floating point evaluations for the node at the corner of two stitched boxes\nto split up the top sideset in multiple parts.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-976701",
                  "updatedAt": "2022-08-16T02:09:44Z",
                  "publishedAt": "2021-07-07T21:22:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pratyushpotu"
                          },
                          "bodyText": "Hi,\nThanks for your help. I was able to produce the boundaries I wanted, but the meshgenerator system needs a single end point, so when trying to apply boundary conditions to the boundaries, I can only apply a boundary condition to one produced boundary. If I try to apply another boundary condition to a boundary that is not the final generator, I get that the node set id does not exist. How would I go about adding the node set id to a boundary without specifying it to be the final generator?\nThanks,\nPratyush",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-976961",
                          "updatedAt": "2022-08-16T02:09:45Z",
                          "publishedAt": "2021-07-07T23:08:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nI m not sure I understand the problem. Could you please paste the meshgenerators you are using here?\nYou should make a linear chain of mesh generators, if that helps\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-977010",
                          "updatedAt": "2022-08-16T02:10:15Z",
                          "publishedAt": "2021-07-07T23:38:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh you are saying the boundaries created by the middle mesh generators are overwritten by the final ones?\nSo if you add show_info = true to the last mesh generator or if you open the resulting mesh in paraview, you should be able to see the final names of the boundaries after all the generation. You can then use the final names in your boundary conditions",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-977013",
                          "updatedAt": "2022-08-16T02:10:16Z",
                          "publishedAt": "2021-07-07T23:40:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pratyushpotu"
                          },
                          "bodyText": "Here are the mesh generators I am using\n[Mesh]\n  [./generated_mesh]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 10\n    ymin = 0\n    ymax = 1\n    nx = 100\n    ny = 10\n  [../]\n  [./nodes1]\n    type = BoundingBoxNodeSetGenerator\n    new_boundary = 'AB'\n    input = 'generated_mesh'\n    top_right = '2 1 0'\n    bottom_left = '2 0 0'\n  [../]\n  [./nodes2]\n    type = BoundingBoxNodeSetGenerator\n    new_boundary = 'BC'\n    input = 'generated_mesh'\n    top_right = '8 1 0'\n    bottom_left = '8 0 0'\n  [../]\n  final_generator = nodes1\n  show_info = true\n[]\n\nAnd here are the boundary conditions:\n[BCs]\n  [AB_temperature]\n    type = DirichletBC\n    boundary = 'AB'\n    variable = temperature\n    value = 500\n  []\n    [BC_temperature]\n    type = DirichletBC\n    boundary = 'BC'\n    variable = temperature\n    value = 500\n  []\n[]\n\nBox A is from x = 0 to x = 2, Box B is from x=2 to x=8, and Box C is from x=8 to x=10. Because I have my final_generator set to nodes1, the AB boundary condition works, but the BC boundary condition does not work. I want to have more boundaries later such as the top of box A and the bottom of box C, but for now I am testing with the interfaces between the three boxes. Therefore, I am wondering how to apply boundary conditions to multiple node sets that are not the default top, bottom etc... . Thanks for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-977044",
                          "updatedAt": "2022-08-16T02:10:31Z",
                          "publishedAt": "2021-07-07T23:54:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok the problem is that the input of nodes2 needs to be nodes1 not generated_mesh. Otherwise, there are two final meshes and the simulation does not know which one to use.\nor as you did, you selected one as the final generator, and the other one got ignored, so that does not work for you",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-977084",
                          "updatedAt": "2022-08-16T02:11:01Z",
                          "publishedAt": "2021-07-08T00:18:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pratyushpotu"
                          },
                          "bodyText": "Oh I see, I thought the input was what part of the mesh the node set was a part of, but its actually just how the mesh generator chains from each generator. Changing the input got me exactly what I needed. Thanks so much for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-977096",
                          "updatedAt": "2022-08-16T02:11:01Z",
                          "publishedAt": "2021-07-08T00:25:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Setting ADVectorVariableValues from individual coupled variable components",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "Hello,\nI have a coupled 1D  Thermal hydraulics MOOSE app that solves for, among other things, velocity. I would like to use this code in MultiApps to transfer its velocity to my MOOSE app and use this velocity to transport material. But this code returns velocity as a scalar and not a vector. I have written an advection kernel shown below with the header file:\nclass MoleAdvection : public ADKernelValue\n{\npublic:\n  static InputParameters validParams();\n  MoleAdvection(const InputParameters & parameters);\n  virtual ~MoleAdvection();\n\nprotected:\n  virtual ADReal precomputeQpResidual() override;\n\n  // x velocity\n  const ADVariableValue & _x_velocity;\n  // y velocity\n  const ADVariableValue & _y_velocity;\n  // z velocity\n  const ADVariableValue & _z_velocity;\n  // Velocity vector\n  const ADVectorVariableValue & _vector_velocity;\n};\n\nand the C file\n#include \"MoleAdvection.h\"\n\nregisterADMooseObject(\"moleApp\", MoleAdvection);\n\nInputParameters\nMoleAdvection::validParams()\n{\n  InputParameters params = ADKernelValue::validParams();\n  params.addClassDescription(\"Applies non-conservative advection\");\n  params.addCoupledVar(\"x_velocity\", 0., \"Coupled x velocity\");\n  params.addCoupledVar(\"y_velocity\", 0., \"Coupled y velocity\");\n  params.addCoupledVar(\"z_velocity\", 0., \"Coupled z velocity\");\n  params.addCoupledVar(\"vector_velocity\", {0., 0., 0.}, \"Coupled vector velocity\");\n  return params;\n}\n\nMoleAdvection::MoleAdvection(const InputParameters & parameters)\n  : ADKernelValue(parameters),\n  _x_velocity(adCoupledValue(\"x_velocity\")),\n  _y_velocity(adCoupledValue(\"y_velocity\")),\n  _z_velocity(adCoupledValue(\"z_velocity\")),\n  _vector_velocity(adCoupledVectorValue(\"vector_velocity\"))\n{\n}\n\nMoleAdvection::~MoleAdvection() {}\n\nADReal\nMoleAdvection::precomputeQpResidual()\n{\n  if (_vector_velocity[_qp].norm() < 1.e-8)\n  {\n    ADVectorVariableValue _velocity = {_x_velocity, _y_velocity, _z_velocity};\n    return _velocity[_qp] * _grad_u[_qp];\n  }\n  else\n  {\n    return _vector_velocity[_qp] * _grad_u[_qp];\n  }\n}\n\nWhich does not compile. I have looked at the Doxygen for MOOSE and libMesh to try to figure out how to create a way to create a velocity vector from x_velocity, y_velocity and z_velocity. But i have come up short with trying to figure out how to do it. I would like the kernel to be able to use either a coupled velocity already in vector form (see variable _vector_velocity ) or create a velocity vector from the individual components. I am having trouble coming up with a way to do this and could use some help.",
          "url": "https://github.com/idaholab/moose/discussions/18278",
          "updatedAt": "2022-10-18T18:36:29Z",
          "publishedAt": "2021-07-07T18:07:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nTo create a velocity vector from individual components, you can use:\nADRealVectorValue V = {_x_velocity[_qp], _y_velocity[_qp], _w_velocity[_qp]};\nI dont think you need to instantiate the destructor btw.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18278#discussioncomment-976171",
                  "updatedAt": "2022-10-18T18:36:30Z",
                  "publishedAt": "2021-07-07T18:24:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "I kept having <brace-enclosed initializer list> error but this worked:\nADRealVectorValue V;\nV =  {_x_velocity[_qp], _y_velocity[_qp], _w_velocity[_qp]};",
                          "url": "https://github.com/idaholab/moose/discussions/18278#discussioncomment-976196",
                          "updatedAt": "2022-10-18T18:36:30Z",
                          "publishedAt": "2021-07-07T18:33:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "Actually i need to do this for it to converge.\n    ADRealVectorValue _velocity(_x_velocity[_qp], _y_velocity[_qp], _z_velocity[_qp]);\n    return _velocity * _grad_u[_qp];",
                          "url": "https://github.com/idaholab/moose/discussions/18278#discussioncomment-976397",
                          "updatedAt": "2022-10-18T18:36:30Z",
                          "publishedAt": "2021-07-07T19:26:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Setting required coupled variables through actions.",
          "author": {
            "login": "leanderVS"
          },
          "bodyText": "Hi everyone\nAn issue/question concerning the KKSMultiACBulkF kernel.\nWithin this kernel, the variable that the kernel operates on has to be provided through the usual \u2018variable = \u2026\u2019. The kernel also requires the user to specify a coupled variable \u2018eta_i = \u2026\u2019 which defines the order parameter that derivatives are taken with respect to. However, within my (limited) experience, both of these variables are always the same, which makes the introduction of eta_i kind of redundant. Is there a reason the kernel does not simply use \"variable\" to define the derivatives?\nOf more importance to my own research is the actual definition of eta_i as a coupled variable. I modified the KKSMultiACBulkF kernel to generate a bulk free energy expression Sum_j[h(eta_j)F_j]. The F_j\u2019s are constant (but different) at the moment, while the h(eta_j) were defined through SwitchingFunctionMultiPhaseMaterial.\nI am modelling an electrolyte in contact with a polycrystalline metal sample, which requires multiple of these adapted kernels to be called (each grain was assigned a different order parameter). When introduced manually into the inputfile, these give the expected results. However, altering the number of grains also requires quite some adaptations to the inputfile to introduce the correct bulk free energy expression as discussed above. To simply this, I tried to write an action. Whereas \u201cvariable\u201d can easily be set through for example:\nparams.set(\"variable\") = var_name;\nThe issue here is that I have not found a way to add/set the InputParameter object of the coupledVariable eta_j within that action since the coupledVar eta_j does not have the same definition within MOOSE as a simple NonlinearVariableName. CoupledVariableName and quite some other constructions I tried did not work unfortunately.\nI guess there are two options:\nEither I have to rewrite KKSMultiACBulkF to avoid the use of eta_j entirely or I need a way to set eta_j through an action. Preferably the latter if anyone has a solution.\nHope I formulated this clearly, any help would be appreciated, thanks!\nKind regards\nLeander",
          "url": "https://github.com/idaholab/moose/discussions/18110",
          "updatedAt": "2022-06-29T07:38:12Z",
          "publishedAt": "2021-06-17T13:41:56Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dschwen @laagesen @amjokisaari if any of you could please answer this phase field question",
                  "url": "https://github.com/idaholab/moose/discussions/18110#discussioncomment-899038",
                  "updatedAt": "2022-10-13T17:04:37Z",
                  "publishedAt": "2021-06-21T16:37:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "The variables are not always the same. This Kernel appears on the equation for the lagrange multiplier that enforces the sum of all switching functions to be 1 in the case of many (>2) phases.",
                  "url": "https://github.com/idaholab/moose/discussions/18110#discussioncomment-940295",
                  "updatedAt": "2022-10-13T17:04:46Z",
                  "publishedAt": "2021-06-29T20:58:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "As for\n\nThe issue here is that I have not found a way to add/set the InputParameter object of the coupledVariable eta_j within that action since the coupledVar eta_j does not have the same definition within MOOSE as a simple NonlinearVariableName. CoupledVariableName and quite some other constructions I tried did not work unfortunately\n\ntry params.set<std::vector<VariableName>>(\"variable\") = {var_name};\nA coupled variable can be an AuxVariable or a non linear Variable (hence the general VariableName rather than NonlinearVariableName (which you forgot in your example) or AuxVariableName), and MOOSE allows you to couple an arbitrary number of variables for each parameter (hence the std::vector).",
                          "url": "https://github.com/idaholab/moose/discussions/18110#discussioncomment-940315",
                          "updatedAt": "2022-10-13T17:04:54Z",
                          "publishedAt": "2021-06-29T21:01:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "See here for an example of both uses:\n\n  \n    \n      moose/modules/phase_field/src/action/ConservedAction.C\n    \n    \n        Lines 173 to 174\n      in\n      06bc1f7\n    \n  \n  \n    \n\n        \n          \n           params.set<NonlinearVariableName>(\"variable\") = _chempot_name; \n        \n\n        \n          \n           params.set<std::vector<VariableName>>(\"v\") = {_var_name};",
                          "url": "https://github.com/idaholab/moose/discussions/18110#discussioncomment-940335",
                          "updatedAt": "2022-10-13T17:04:55Z",
                          "publishedAt": "2021-06-29T21:03:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "leanderVS"
                          },
                          "bodyText": "@dschwen , thank you for your reply!\nI already had a look at ConservedAction.C but must have missed that particular part, thanks for pointing this out. The code now perfectly compiles and the simulation even converges, but it appears that it somehow still ignores the extra kernel I tried to add.\nThis is now the addition I made to PolycrystalKernelAction (now called CorrosionPolycrystalKernelAction for my purposes) to implement the bulk free energy terms (using the kernel CorrosionFb_I) (since I believe that in my case both variable and eta_i should refer to the same variable that the kernel operates on.\n{\n  InputParameters params = _factory.getValidParams(\"CorrosionFb_I\");\n  params.set<NonlinearVariableName>(\"variable\") = var_name;\n  params.set<std::vector<VariableName>>(\"args\") = v;\n\n  params.set<std::vector<VariableName>>(\"eta_i\") = {var_name};\n\n  params.set<std::vector<MaterialPropertyName>>(\"Fj_names\") = _Fj_names;\n  params.set<std::vector<MaterialPropertyName>>(\"hj_names\") = _hj_names;\n  params.applyParameters(parameters());\n\n  std::string kernel_name = \"CorrosionFb_I_\" + var_name;\n  _problem->addKernel(\"CorrosionFb_I\", kernel_name, params);\n}\n\nIn addition, the typical\nparams.addParam<std::vector>(\"Fj_names\",\"...\")\nparams.addParam<std::vector>(\"hj_names\",\"...\")\nwere added to the validParams() function of the action. Otherwise I think nothing changed for this action (apart from the declaration of Fj_names and hj_names in the .h file).\nThe action is then called in the Inputfile using:\n[Kernels]\n[./CorrosionPolycrystalKernel]\n// All different grain orientations have the same constant bulk free energy, the electrolyte (eta9) has a lower bulk free energy\nop_num = 10  \nvar_name_base = eta \nFj_names = 'F_metal   F_metal   F_metal   F_metal   F_metal   F_metal   F_metal   F_metal   F_metal   F_elec'\nhj_names = 'h_metal_0 h_metal_1 h_metal_2 h_metal_3 h_metal_4 h_metal_5 h_metal_6 h_metal_7 h_metal_8 h_elec'\n\n[../]\n[]\nThis implementation, however, appears to ignore the addition of the extra kernel. It thus gives the same results as if I wouldn't have implemented the extra kernel (although I did not overlap the two simulations to compare them one-to-one).\nAs mentioned, the kernel does work on its own, when it is introduced as such:\n`\n[Kernels]\n[./PolycrystalKernel]\nop_num = 10  \nvar_name_base = eta  \n\n[../]\n//Kernels for bulk free energy introduction\n[./F_bulk_metal_0]\ntype = CorrosionFb_I\nFj_names = 'f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_elec'\neta_i = 'eta0'\nhj_names = 'h_metal_0 h_metal_1 h_metal_2 h_metal_3 h_metal_4 h_metal_5 h_metal_6 h_metal_7 h_metal_8 h_elec'\nvariable = eta0\nargs = 'eta1 eta2 eta3 eta4 eta5 eta6 eta7 eta8 eta9'\n\n[]\n[./F_bulk_metal_1]\n//Notice that all the metallic grain have the same constant free energy contribution.\ntype = CorrosionFb_I\nFj_names = 'f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_elec'\neta_i = 'eta1'\nhj_names = 'h_metal_0 h_metal_1 h_metal_2 h_metal_3 h_metal_4 h_metal_5 h_metal_6 h_metal_7 h_metal_8 h_elec'\nvariable = eta1\nargs = 'eta0 eta2 eta3 eta4 eta5 eta6 eta7 eta8 eta9'\n\n[]\n//and a lot more of the same stuff for all the other order parameters.\n[]\n`\nI suppose the issue still lies in the action, but since the eta_i seems to be fine thanks to your fix, I ran out of ideas of where the issue could be.\nBest regards\nLeander",
                          "url": "https://github.com/idaholab/moose/discussions/18110#discussioncomment-974394",
                          "updatedAt": "2022-10-13T17:04:56Z",
                          "publishedAt": "2021-07-07T11:23:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}