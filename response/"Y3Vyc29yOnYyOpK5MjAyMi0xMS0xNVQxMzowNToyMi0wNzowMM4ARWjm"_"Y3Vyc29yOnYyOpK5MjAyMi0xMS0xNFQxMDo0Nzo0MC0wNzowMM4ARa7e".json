{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMS0xNFQxMDo0Nzo0MC0wNzowMM4ARa7e"
    },
    "edges": [
      {
        "node": {
          "title": "Pass subdomain_id as input file into \"ElementSubdomainIDGenerator\"",
          "author": {
            "login": "chunhuizhao478"
          },
          "bodyText": "Hi, I would like assign different element-wise subdomain_id to different portion of mesh. So far I would like to use \"ElementSubdomainIDGenerator\" which allows users to re-assign the subdomain_id. But I don't know how to pass the modified subdomain_id as a .txt file to be read by MOOSE subdomain_id (If I have many elements). Do I need to write a custom object somehow to read file and transfer the data to \"std::vector\" type? Thanks for any suggestions.",
          "url": "https://github.com/idaholab/moose/discussions/22523",
          "updatedAt": "2022-11-15T20:10:26Z",
          "publishedAt": "2022-10-27T22:16:12Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWould there happen to be an easier definition of the subdomains than a CSV file list?\nSomething like x>1 -> subdomain 2, otherwise subdomain 1 for example\nWe support parsed expressions\nhttps://mooseframework.inl.gov/source/meshgenerators/ElementSubdomainIDGenerator.html\nElementSubdomainId will read a really long vector, the size of the number of elements, and assign those subdomain ids to each element in the order of their element ID\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-3986791",
                  "updatedAt": "2022-10-27T22:27:29Z",
                  "publishedAt": "2022-10-27T22:27:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi Guillaume, thanks for your reply. I noticed the parsed expression, however, we would like to create multiple embedded cracks and use CZM for each crack, that means I need to identify the elements just above and below the crack surfaces and assign different subdomain_ids to them and use \"BreakMeshByBlockGenerator\" to create interfaces. Parsed expression may not handle this properly I think.",
                          "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-3986809",
                          "updatedAt": "2022-10-27T22:32:40Z",
                          "publishedAt": "2022-10-27T22:32:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok that s fair.\nWhat are you using to generate the mesh?",
                          "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-3986820",
                          "updatedAt": "2022-10-27T22:35:07Z",
                          "publishedAt": "2022-10-27T22:35:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Currently I try to use Gmsh and read MSH file in MOOSE, then create interface. For the multiple cracks, probably I need to write scripts to get the information I want and seems not going to be easy, then may be I could just copy/paste all the ids to MOOSE, but it's gonna be messy.",
                          "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-3986844",
                          "updatedAt": "2022-10-27T22:42:15Z",
                          "publishedAt": "2022-10-27T22:42:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The solution here could be to write a new object that reads the CSV and does the block assigning. We have a gap in capability on this right now.\nAdding this kind of utility in MOOSE is fairly easy due to existing classes like the DelimitedFileReader",
                          "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-4149415",
                          "updatedAt": "2022-11-15T18:19:06Z",
                          "publishedAt": "2022-11-15T18:19:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks, I could check that. Currently I use MESHIO to extract cracks information and just do copy/paste the modified sudmain ID/element ID, it works for the current need.",
                          "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-4149998",
                          "updatedAt": "2022-11-15T19:38:15Z",
                          "publishedAt": "2022-11-15T19:38:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to input the temperature field from FLOW3D into MOOSE to simulate grain evolution",
          "author": {
            "login": "zsren"
          },
          "bodyText": "Hi,\nI am new to MOOSE. I am trying to simulate the grain growth of laser powder bed fusion by utilizing the phase field module in MOOSE. I plan to input the temperature field, which is calculated within a thermal-hydrodynamic simulation from another software FLOW3D, into MOOSE. Is there by any chance an interface to make this coupling possible? Or is there a specific data format, with which FLOW3D should be output, such that MOOSE can recognize? Some existing examples would be super helpful!\nIt would be greatly appreciated for your efforts in making any comments or suggestions!\nZR",
          "url": "https://github.com/idaholab/moose/discussions/22511",
          "updatedAt": "2022-12-10T07:33:16Z",
          "publishedAt": "2022-10-27T06:23:15Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat are all the formats in which you can output data from FLOW3D?\nWhat kind of data is it going to be? A xyz field with a time dependence?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22511#discussioncomment-3982052",
                  "updatedAt": "2022-10-27T13:49:34Z",
                  "publishedAt": "2022-10-27T13:49:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zsren"
                          },
                          "bodyText": "Hi Guillaume,\nThanks so much for your prompt response. As far as I know, FLOW3D can export the X, Y, and Z coordinates with temperature values at a particular timestep in a CSV file.\nZR",
                          "url": "https://github.com/idaholab/moose/discussions/22511#discussioncomment-3990577",
                          "updatedAt": "2022-10-28T08:44:45Z",
                          "publishedAt": "2022-10-28T08:44:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sorry for the delay.\nPiecewiseConstantFromCSV is the function you will want to use",
                          "url": "https://github.com/idaholab/moose/discussions/22511#discussioncomment-4149818",
                          "updatedAt": "2022-11-15T19:16:51Z",
                          "publishedAt": "2022-11-15T19:16:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to set the value of kappa as a function of X and Y",
          "author": {
            "login": "biaogxb"
          },
          "bodyText": "Hello, I want to define the value of kappa as a function, as shown below\n[Kernels]\n  [./AC_int]\n    type = ACInterface\n    variable = eta\n    kappa_name = kappa_op\n  [../]\n[Materials]\n [./kappa_op]\n    type = ParsedMaterial\n    f_name = kappa_op \n    args = 'x y' \n    function = '2.4+0.12*cos(4*atan2(y,x))'\n  [../]\n\nHowever, the following error occurred:\n*** ERROR ***\nThe following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\nMaterial property 'kappa_op', requested by 'AC_int' is not defined on block 0\nI would like to ask how to correctly set kappa as a function about X and Y. thank you\uff01\uff01\uff01",
          "url": "https://github.com/idaholab/moose/discussions/22013",
          "updatedAt": "2022-11-15T18:20:35Z",
          "publishedAt": "2022-09-06T09:39:18Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont think you need to specify x and y in args, you can just leave them in function\nThe name should have been properly set though. Can you please attach your input file?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3572030",
                  "updatedAt": "2022-09-06T14:40:18Z",
                  "publishedAt": "2022-09-06T14:40:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Thank you for your reply! I want to implement kappa as a function about X and Y. I have added a series of # annotations to the involved parts in the input file so that you can find it more quickly.\nI'm not sure if I can set kappa as a function and operate successfully through my current operation. I tried it. At present, the convergence is not very good. Do you agree with the way I modify this code or do you have a simpler and more correct way to realize the functionalization of kappa?\nI want to set kappa = 2.4 (1 + 0.05 * cos (4* \u03b8\uff09\uff09\nAccording to the following formula:\n\n\n\nthis \u03b8 It is an angle that can be represented by 'x' and 'y', which will change at any time. Therefore, setting kappa as a constant does not satisfy the condition.\nI'm looking forward to your reply. Thank you\uff01\uff1a\uff09",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3580818",
                          "updatedAt": "2022-11-09T07:48:18Z",
                          "publishedAt": "2022-09-07T02:27:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "why do you say x and y will change during time? is the mesh going to displace?\nyou could probably avoid the auxvariable here, and define it directly in the parsed material.",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3581591",
                          "updatedAt": "2022-09-07T05:49:54Z",
                          "publishedAt": "2022-09-07T05:49:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "\u03b8 is the angle between the surface normal vector and the crystallographic orientation.So I modified the code according to my own idea. I want to express this through the coordinates (x, y) of the interface position \u03b8 Angle that changes as the surface grows. but obviously I was wrong. How can I express this \u03b8 ?",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3582150",
                          "updatedAt": "2022-09-07T07:27:03Z",
                          "publishedAt": "2022-09-07T07:26:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So are you modeling the surface explicitly? Is theta a variable then? Or does it never change at a given x,y during the simulation",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3588817",
                          "updatedAt": "2022-09-07T20:32:21Z",
                          "publishedAt": "2022-09-07T20:32:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@laagesen for helping on phase field",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3588823",
                          "updatedAt": "2022-09-07T20:32:44Z",
                          "publishedAt": "2022-09-07T20:32:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "The angle of the surface normal vector is not the same as the way you have drawn theta here. To see this, just draw a normal vector to the surface at the end of one of your arrows and you will see it doesn't point in the same direction as the arrow. (If it did, the outer surface that the arrows point to would be a circle instead of the more complex wavy shape).\nBecause of this, you can't calculate kappa as a function of x and y in your domain. The process is unfortunately more tricky, you will need to calculate the interfacial normal as a function of the gradients of the order parameter. To see an example of how this is done, you can look at  the code in moose/modules/phase_field/src/materials/InterfaceOrientationMaterial.C. You can see how this material is used in a dendritic growth example by running moose/modules/phase_field/examples/anisotropic_interfaces/snow.i.",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3595405",
                          "updatedAt": "2022-09-08T14:28:04Z",
                          "publishedAt": "2022-09-08T14:27:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Thank you for your answer. I will study this example!",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3603052",
                          "updatedAt": "2022-09-09T02:47:36Z",
                          "publishedAt": "2022-09-09T02:47:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "The angle of the surface normal vector is not the same as the way you have drawn theta here. To see this, just draw a normal vector to the surface at the end of one of your arrows and you will see it doesn't point in the same direction as the arrow. (If it did, the outer surface that the arrows point to would be a circle instead of the more complex wavy shape).\nBecause of this, you can't calculate kappa as a function of x and y in your domain. The process is unfortunately more tricky, you will need to calculate the interfacial normal as a function of the gradients of the order parameter. To see an example of how this is done, you can look at the code in moose/modules/phase_field/src/materials/InterfaceOrientationMaterial.C. You can see how this material is used in a dendritic growth example by running moose/modules/phase_field/examples/anisotropic_interfaces/snow.i.\n\nI carefully read the snowflake example and found that the \u2018InterfaceOrientationMaterial\u2019 is used to calculate the kappa\uff08eps in that article\uff09 value I need, so I changed the code for calculating the interface as follows\n[./anisoACinterface] type = ACInterface variable = eta mob_name = M0 kappa_name=eps [../]\n[./material] type = InterfaceOrientationMaterial op = eta [../]\nI don't know why my calculation is not convergent. Can't I directly fill \u2018eps\u2019 into ACInterface as \u2018kappa\u2019\uff1f\nHere is my input file\uff1a\ninput.txt",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-4096882",
                          "updatedAt": "2022-11-09T13:05:19Z",
                          "publishedAt": "2022-11-09T13:05:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "I see you are using some logarithmic terms in your free energy expressions. Those are often problematic in terms of convergence. I would suggest first removing the anisotropy and make sure your model works without it first. If you still have problems without the anisotropy I would be suspicious of the logarithmic terms. You can try using the plog function instead, which substitutes a polynomial function below a user-specified tolerance, or try a parabolic approximation to the logarithmic expression.",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-4149427",
                          "updatedAt": "2022-11-15T18:20:35Z",
                          "publishedAt": "2022-11-15T18:20:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "ParsedMaterial cannot use x and y. Use GenericFunctionMaterial instead.",
                  "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3603060",
                  "updatedAt": "2022-09-09T02:50:02Z",
                  "publishedAt": "2022-09-09T02:50:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Thank you for your answer\uff01",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3603102",
                          "updatedAt": "2022-09-09T02:58:56Z",
                          "publishedAt": "2022-09-09T02:58:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some questions about the KDTree.C",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "KDTree.C\nvoid\nKDTree::neighborSearch(Point & query_point,\n                       unsigned int patch_size,\n                       std::vector<std::size_t> & return_index,\n                       std::vector<Real> & return_dist_sqr)\n{\n  return_index.resize(patch_size);\n\n  std::size_t n_result =\n      _kd_tree->knnSearch(&query_point(0), patch_size, return_index.data(), return_dist_sqr.data());\n\n  if (n_result == 0)\n    mooseError(\"Unable to find closest node!\");\n\n  return_index.resize(n_result);\n  return_dist_sqr.resize(n_result);\n}\n\n\nI want to ask where can I find some info about the knnSearch? I didn't find it anywhere else.\nOr can somebody tell me what does the neighborSearch do? How?",
          "url": "https://github.com/idaholab/moose/discussions/22707",
          "updatedAt": "2022-11-15T15:24:28Z",
          "publishedAt": "2022-11-15T14:01:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo a good research to get more information about code is the doxygen\nUnfortunately the moose doxygen doesnt have comments, but you can refer to the nanoflann one for the routines called here\nhttps://jlblancoc.github.io/nanoflann/classnanoflann_1_1KDTreeSingleIndexAdaptor.html#ad16aad67165bce42ecdb742bc5536173\nneighborSearch searches for the closest neighbors of a queried point\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22707#discussioncomment-4147176",
                  "updatedAt": "2022-11-15T14:31:55Z",
                  "publishedAt": "2022-11-15T14:31:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "for the patch_size closest neighbors*",
                          "url": "https://github.com/idaholab/moose/discussions/22707#discussioncomment-4147190",
                          "updatedAt": "2022-11-15T14:33:28Z",
                          "publishedAt": "2022-11-15T14:33:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Oh I got it.  patch_size is the number of the closest neighbors right?\nI have another question, is the concept 'neighbors' blockrestrictable? I mean, a queried point's neighbor can be another point in other block or not?",
                          "url": "https://github.com/idaholab/moose/discussions/22707#discussioncomment-4147433",
                          "updatedAt": "2022-11-15T14:53:57Z",
                          "publishedAt": "2022-11-15T14:53:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "And thank you for telling me about the nanoflann, I haven't browsed this labrary.",
                          "url": "https://github.com/idaholab/moose/discussions/22707#discussioncomment-4147447",
                          "updatedAt": "2022-11-15T14:55:19Z",
                          "publishedAt": "2022-11-15T14:55:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes it is the number of closest neighbors the KDTree search will return.\nThe KDTree can be block-restricted by creating it only with the points from the desired block.",
                          "url": "https://github.com/idaholab/moose/discussions/22707#discussioncomment-4147738",
                          "updatedAt": "2022-11-15T15:24:28Z",
                          "publishedAt": "2022-11-15T15:24:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "FluidProperties doesn't work",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nAfter I updated my moose version, the mistake occurred in my previous case of my application:\n\nI noticed that MOOSE has changed /Modules/FluidProperties/* to /FluidProperties/*, but why does the app in the Modules using FluidProperties not report an error, but my own app does?\nCould anyone kindly help me to figure it out?\nBest regards!\nSomnus",
          "url": "https://github.com/idaholab/moose/discussions/22705",
          "updatedAt": "2023-01-03T23:13:38Z",
          "publishedAt": "2022-11-15T13:03:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you recompile the app as well after updating or is it the old executable?\nThe new syntax is indeed [FluidProperties] instead of [Modules/FluidProperties]\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22705#discussioncomment-4147297",
                  "updatedAt": "2022-11-15T14:41:17Z",
                  "publishedAt": "2022-11-15T14:41:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Yes, I have recompiled the app. I know that the new syntax is [FluidProperties], which is also used in my input file. Should I uninstall the MOOSE and then reinstall it?",
                          "url": "https://github.com/idaholab/moose/discussions/22705#discussioncomment-4147529",
                          "updatedAt": "2022-11-15T15:02:35Z",
                          "publishedAt": "2022-11-15T15:02:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You could git clean -xfd in the moose folder then re-make\nBe careful that will delete ALL files that are not saved!! So please make sure to commit them first if you have modified MOOSE",
                          "url": "https://github.com/idaholab/moose/discussions/22705#discussioncomment-4147650",
                          "updatedAt": "2022-11-15T15:15:35Z",
                          "publishedAt": "2022-11-15T15:15:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Ok, I will try it. Thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/22705#discussioncomment-4147686",
                          "updatedAt": "2022-11-15T15:19:10Z",
                          "publishedAt": "2022-11-15T15:19:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "What's the difference between nodal variable and elemental variable in Kernel?",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "I didn't find a page about this question. I remember that computeQpResidual() is executed on each each quadrature point and the node value is calculated by the qp point value. So what is the specific difference between nodal and elemental variable?",
          "url": "https://github.com/idaholab/moose/discussions/22686",
          "updatedAt": "2022-11-15T15:08:51Z",
          "publishedAt": "2022-11-14T14:10:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe difference between a nodal and an elemental variable is where the degrees of freedoms (dofs) reside. Both elements and nodes are DoFObject in libmesh, so they can \"hold\" (simplifying) Qp values of a variable.\nA nodal variable may be uniquely defined by its values on nodes (think about a Lagrange variable).\nAn elemental variable is uniquely defined by its values in various places on each element. This allows for discontinuity from one element to another.\nThere are mixed nodal - elemental variables that hold dofs on both elements and nodes.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4137136",
                  "updatedAt": "2022-11-14T14:17:25Z",
                  "publishedAt": "2022-11-14T14:17:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "\"A nodal variable may be uniquely defined by its values on nodes (think about a Lagrange variable).\"\nDoes the \"nodes\" include quadrature point?\nIf doesn't, why we should add [_qp] behind the variable in computeQpResidual()?",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4137315",
                          "updatedAt": "2022-11-14T14:35:44Z",
                          "publishedAt": "2022-11-14T14:35:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Does the \"nodes\" include quadrature point?\nThis depend on the quadrature. Typically not\nIf doesn't, why we should add [_qp] behind the variable in computeQpResidual()?\nIf you want to write a kernel that is valid for more than nodal variabless one reason.",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4137543",
                          "updatedAt": "2022-11-14T14:55:40Z",
                          "publishedAt": "2022-11-14T14:55:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "But when I set the variable first lagrange and I add the code which can output the qp value of variable like\uff1astd<<cout<<_vel\uff3b_qp\uff3d<<endl\uff1b in kernel\uff0cit outputs some values indeed\uff0cI wanna know where does that \u201cqp value\u201d come from\uff1f\nWhen I set 6 nodes in a 1D mesh and set the variable first lagrange\uff0cit outputs 10 values\uff08I think FISRT stands that there are two qp point between two nodes\uff0cand plus the number of the element\uff086-1=5\uff09\uff09.\nI cant understand Orz",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4137802",
                          "updatedAt": "2022-11-14T15:16:24Z",
                          "publishedAt": "2022-11-14T15:16:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "6 nodes -> 5 elements\nIf there's 2 qps per element, then that's how you got 10 values\nThe quadrature point value can be computed by evaluating the shape functions at the quadrature points.",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4138957",
                          "updatedAt": "2022-11-14T17:00:26Z",
                          "publishedAt": "2022-11-14T17:00:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "So when I set a nodal variable, it actually is computed at each node, not quadrature point. The value of quadrature point is computed by evaluating, but can't decide the value of node. And my previous understanding is the way of elemental variable's calculation\n, am I right?\nSo nodal variable: node value decides quadrature point value;\nelemental variable: quadrature point value decides node value.\nCan I simplify it this way?",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4141996",
                          "updatedAt": "2022-11-15T01:19:47Z",
                          "publishedAt": "2022-11-15T01:19:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The values are stored at each node (they are stored in an array, mapped to nodes, we dont store value directly on the mesh objects)\nThe variable values are computed at quadrature points when we evaluate the residual or the Jacobian.\nnodal variable: yes\nelemental variable: no. The node value of an elemental variable may be undefined, because a node is shared by multiple elements and the variable is discontinuous for example\nAlso, the Qp value is not used to compute values. The Qp value is computed by evaluating the shape function(s). The dofs of an elemental variables may relate to arbitrary points on an element, determined by the finite element family and its order\nThis documentation should be helpful\nhttps://mooseframework.inl.gov/help/finite_element_concepts/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4147489",
                          "updatedAt": "2022-11-15T15:14:15Z",
                          "publishedAt": "2022-11-15T14:59:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Thank you a lot! I will check the documentation with your answer :D",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4147603",
                          "updatedAt": "2022-11-15T15:08:51Z",
                          "publishedAt": "2022-11-15T15:08:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "petsc_options_iname and petsc_options_value",
          "author": {
            "login": "wowodejiajia"
          },
          "bodyText": "Dear MOOSE experts,\nI saw them in other programs\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\nand\n  petsc_options_iname = '-pc_type -ksp_grmres_restart -sub_ksp_type\n                         -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'asm      121                  preonly\n                         lu          8'\n\nI wrote a new input, but I don't know how to write them. Is there a detailed introduction to the above petsc_options_iname and petsc_options_value?\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/22704",
          "updatedAt": "2022-11-15T09:26:30Z",
          "publishedAt": "2022-11-15T04:50:58Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\npetsc_options_iname / value are options that get passed to petsc. They map to petsc options directly so the relevant documentation is the PETSc manual\nhttps://petsc.org/release/docs/manual/\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22704#discussioncomment-4144416",
                  "updatedAt": "2022-11-15T09:12:30Z",
                  "publishedAt": "2022-11-15T09:12:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wowodejiajia"
                          },
                          "bodyText": "I'll see it. Thank you very much",
                          "url": "https://github.com/idaholab/moose/discussions/22704#discussioncomment-4144540",
                          "updatedAt": "2022-11-15T09:26:30Z",
                          "publishedAt": "2022-11-15T09:26:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A problem about exodus",
          "author": {
            "login": "wowodejiajia"
          },
          "bodyText": "Dear MOOSE experts,,\n[Outputs]\n  exodus = flase\n  csv = true\n  execute_on = 'TIMESTEP_END'\n  [./other]\n     type = Exodus\n     interval = 50\n  [../]\n[]\n\nThe .e documentse of each step is too big, so I only want to record 50 steps once. If I put exodus = flase, I will report an error.",
          "url": "https://github.com/idaholab/moose/discussions/22701",
          "updatedAt": "2022-11-15T09:25:28Z",
          "publishedAt": "2022-11-15T04:18:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou dont need to specify both exodus = true/false and the [other] block of an exodus type.\nThe syntaxes are not meant to be combined (though they can), just create exodus blocks with the interval you need as you did\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22701#discussioncomment-4144402",
                  "updatedAt": "2022-11-15T09:10:30Z",
                  "publishedAt": "2022-11-15T09:10:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wowodejiajia"
                          },
                          "bodyText": "I see. Thank you very much",
                          "url": "https://github.com/idaholab/moose/discussions/22701#discussioncomment-4144531",
                          "updatedAt": "2022-11-15T09:25:29Z",
                          "publishedAt": "2022-11-15T09:25:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "moose phase field",
          "author": {
            "login": "Adairle"
          },
          "bodyText": "Holle everyone\nExcuse me, the old phase field model program reported an error on the new server\nHow to solve\uff1f thanks",
          "url": "https://github.com/idaholab/moose/discussions/22666",
          "updatedAt": "2022-11-16T03:16:38Z",
          "publishedAt": "2022-11-11T07:37:36Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt's as the error message says, the program you are using is using deprecated constructs and can no longer build.\nSee this post for more details\nhttps://mooseframework.inl.gov/newsletter/2021_11.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22666#discussioncomment-4118088",
                  "updatedAt": "2022-11-11T14:25:37Z",
                  "publishedAt": "2022-11-11T14:25:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Adairle"
                          },
                          "bodyText": "Thank you for your help. I'll operate it now",
                          "url": "https://github.com/idaholab/moose/discussions/22666#discussioncomment-4132823",
                          "updatedAt": "2023-06-05T14:43:10Z",
                          "publishedAt": "2022-11-14T07:45:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Adairle"
                          },
                          "bodyText": "Hello\nHow can the source file and header file of the old version apply to the new version of moose\uff1f\nOr is there any way to download the old version of Moose?\nthanks\uff01",
                          "url": "https://github.com/idaholab/moose/discussions/22666#discussioncomment-4142241",
                          "updatedAt": "2023-06-05T14:43:10Z",
                          "publishedAt": "2022-11-15T02:08:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You need to remove the old validParams logic and use the new syntax, as the newsletter says",
                          "url": "https://github.com/idaholab/moose/discussions/22666#discussioncomment-4144380",
                          "updatedAt": "2022-11-15T09:07:42Z",
                          "publishedAt": "2022-11-15T09:07:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We would rather you update the app you are using (which one is it?) than use an old version of MOOSE",
                          "url": "https://github.com/idaholab/moose/discussions/22666#discussioncomment-4144381",
                          "updatedAt": "2022-11-15T09:08:11Z",
                          "publishedAt": "2022-11-15T09:08:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Adairle"
                          },
                          "bodyText": "The latest system in use today\nThanks again for your reply\uff01",
                          "url": "https://github.com/idaholab/moose/discussions/22666#discussioncomment-4144429",
                          "updatedAt": "2023-06-05T14:43:10Z",
                          "publishedAt": "2022-11-15T09:14:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MooseMesh::getBoundariesToElems is deprecated",
          "author": {
            "login": "aiskhak"
          },
          "bodyText": "Hello,\nI am using FV Navier-Stokes kernels. The solver seems to work fine, but I am getting the warning:\n*** Warning, This code is deprecated and will be removed in future versions:\nMooseMesh::getBoundariesToElems is deprecated, use MooseMesh::getBoundariesToActiveSemiLocalElemIds\n\nand following info:\nStack frames: 27\n0: libMesh::print_trace(std::ostream&)\n1: void moose::internal::mooseDeprecatedStream<ConsoleStream const, char const (&) [100]>(ConsoleStream const&, bool, char const (&) [100])\n2: MooseMesh::getBoundariesToElems() const\n3: WallDistanceMixingLengthAux::computeValue()\n4: AuxKernelTempl<double>::compute()\n5: ComputeElemAuxVarsThread<AuxKernelTempl<double> >::onElement(libMesh::Elem const*)\n6: ThreadedElementLoopBase<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> >::operator()(libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> const&, bool)\n7: void libMesh::Threads::parallel_reduce<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*>, ComputeElemAuxVarsThread<AuxKernelTempl<double> > >(libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> const&, ComputeElemAuxVarsThread<AuxKernelTempl<double> >&)\n8: void AuxiliarySystem::computeElementalVarsHelper<AuxKernelTempl<double> >(MooseObjectWarehouse<AuxKernelTempl<double> > const&, std::vector<std::vector<MooseVariableFieldBase*, std::allocator<MooseVariableFieldBase*> >, std::allocator<std::vector<MooseVariableFieldBase*, std::allocator<MooseVariableFieldBase*> > > > const&)\n9: AuxiliarySystem::computeElementalVars(MooseEnumItem)\n10: AuxiliarySystem::compute(MooseEnumItem)\n11: FEProblemBase::computeResidualTags(std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n12: FEProblemBase::computeResidualInternal(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n13: FEProblemBase::computeResidualSys(libMesh::NonlinearImplicitSystem&, libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&)\n14: NonlinearSystem::solve()\n15: FEProblemBase::solve(unsigned int)\n16: FEProblemSolve::solve()\n17: FixedPointSolve::solveStep(double&, double&, std::set<unsigned long, std::less<unsigned long>, std::allocator<unsigned long> > const&)\n18: FixedPointSolve::solve()\n19: TimeStepper::step()\n20: Transient::takeStep(double)\n21: Transient::execute()\n22: MooseApp::executeExecutioner()\n23: MooseApp::run()\n24: main\n25: __libc_start_main\n26: ./fv_app-opt(+0x350a) [0x55c0bec2350a]\n\nwhat does it mean how to fix this?",
          "url": "https://github.com/idaholab/moose/discussions/22688",
          "updatedAt": "2022-12-10T07:35:35Z",
          "publishedAt": "2022-11-14T17:45:49Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe should fix this soon.\nPlease ignore it for now\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22688#discussioncomment-4139358",
                  "updatedAt": "2022-11-14T17:47:41Z",
                  "publishedAt": "2022-11-14T17:47:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}