{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMS0xNFQxMTowNzowOS0wNzowMM4AciP6"
    },
    "edges": [
      {
        "node": {
          "title": "Issue with HexagonMeshTrimmer After Using BlockDeletionGenerator",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Hello,\nI encountered an issue when using HexagonMeshTrimmer in MOOSE after applying BlockDeletionGenerator to delete the dummy blocks. The following error message is displayed:\nThe input mesh is not compatible with HexagonMeshTrimmer because the trimmability mesh meta data are absent.\nHere is the sequence of steps I followed to generate the mesh:\n\nUsed PolygonConcentricCircleMeshGenerator to create pins.\nUsed PatternedHexMeshGenerator to create assemblies.\nApplied PatternedHexPeripheralModifier to adjust assemblies.\nUsed HexagonConcentricCircleAdaptiveBoundaryMeshGenerator to generate dummies.\n\nWhen I use HexagonMeshTrimmer on this mesh without applying BlockDeletionGenerator, everything works as expected. However, when I use BlockDeletionGenerator before HexagonMeshTrimmer (with everything else remaining the same), the error above occurs.\nI\u2019ve reviewed the documentation for HexagonMeshTrimmer and meshing tutorials, and it seems like my usage should be correct. Could you help me understand why this happens and how to resolve it?\nThank you for your assistance!",
          "url": "https://github.com/idaholab/moose/discussions/29089",
          "updatedAt": "2024-11-18T14:46:40Z",
          "publishedAt": "2024-11-18T12:56:15Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe HexagonMeshTrimmer requires a boolean metadata to be sure that the mesh is trimmable.\nUsing a BlockDeletionGenerator removes the metadata because we can no longer guarantee that the mesh is trimmable if you use custom operations on it.\nIf you wish to re-instate this metadata you can use:\nhttps://mooseframework.inl.gov/source/meshgenerators/AddMetaDataGenerator.html\nto set the hexagon_peripheral_trimmability and hexagon_center_trimmability booleans yourself. Center trimmability means you can cut some sectors off without breaking elements in the mesh, and similarly for peripheral trimmability, it means the periphery of the mesh can be removed. If the mesh is not truly trimmable, then your output mesh will have jagged edges.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/29089#discussioncomment-11292178",
                  "updatedAt": "2024-11-18T13:40:28Z",
                  "publishedAt": "2024-11-18T13:40:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "using the BlockDeletionGenerator after the HexTrimmer is the better solution here",
                          "url": "https://github.com/idaholab/moose/discussions/29089#discussioncomment-11292182",
                          "updatedAt": "2024-11-18T13:40:44Z",
                          "publishedAt": "2024-11-18T13:40:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you very much for your help! I\u2019ll try your suggestion to use AddMetaDataGenerator to address the issue.\nIn my case, I need to first delete the dummy assemblies and then use PeripheralRingMeshGenerator to add a cylindrical peripheral to the mesh. Finally, I apply HexagonMeshTrimmer. This sequence is essential because changing the order of HexagonMeshTrimmer and BlockDeletionGenerator would leave a hole in the middle of the mesh, which is not acceptable for my use case.\nThanks again for your guidance!",
                          "url": "https://github.com/idaholab/moose/discussions/29089#discussioncomment-11292509",
                          "updatedAt": "2024-11-18T14:11:55Z",
                          "publishedAt": "2024-11-18T14:11:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "how to set different fixed time steps for different time periods",
          "author": {
            "login": "SunJianhang678"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello, I would like to set different fixed time steps for different time periods in one transient simulation. Can I set it directly in the [Executioner] of the input file?\nIf I use the TimeStepper method, it seems that I need to get the current time to segment the time, is there a way to get the current time in the Timestepper? I tried to use _t and _current_time/getCurrentTime but no help. Thanks for your help!",
          "url": "https://github.com/idaholab/moose/discussions/29087",
          "updatedAt": "2024-11-26T02:50:05Z",
          "publishedAt": "2024-11-18T04:08:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDifferent time step cannot be done directly in the Executioner block. You can only do the \"ConstantDT\" behavior there.\nYou can use the TimeStepper or the TimeSteppers block.\n\nI need to get the current time to segment the time, is there a way to get the current time in the Timestepper? I tried to use _t and _current_time/getCurrentTime but no help. Thanks for your help!\n\nThe current time is accessible when coding a time stepper using the _time attribute. The time is retrieved from the problem.\n    _time(_fe_problem.time()),\n\n\ndifferent fixed time steps for different time period\n\nIf you already know the size of the fixed time step and the start and end time of the periods, you could use a FunctionDT with a PiecewiseConstant function",
                  "url": "https://github.com/idaholab/moose/discussions/29087#discussioncomment-11292307",
                  "updatedAt": "2024-11-18T13:54:18Z",
                  "publishedAt": "2024-11-18T13:54:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Questions about meshing on a irregular shape(MegaPower, Special Purpose Nuclear, SPR)",
          "author": {
            "login": "Wang-Yihu"
          },
          "bodyText": "Question: How to mesh with MOOSE in this irregular shape?(It can be divided into a regular hexagon in the middle and six trimmed irregular hexagon)\n\nRecent days, I'm trying to mesh on MegaPower(https://www.osti.gov/biblio/1410224). Its shape is\n\nIt can be seen as the duplication for the small units of the first figure in most areas.\nI'm trying to mesh with MOOSE after I see this. It seems that PolygonConcentricCircleMeshGenerator, PatternedHexMeshGenerator, and  HexagonMeshTrimmer can solve my problem plausibly.\nhttps://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial04_meshing/step06_common_ops.html\nHowever, there is a big difference between the example of this web page and my object. In the model in the first figure, in the corner region, the hexagon is not a regular hexagon, that is, the sides of the hexagon are not equal, which I've marked in the first figure.\nSo can MOOSE mesh can solve this problem?\nP.S, this can be solved by struct block mesh. I finish this mesh by ANSYS Workbench Mesh and ICEM CFD.",
          "url": "https://github.com/idaholab/moose/discussions/29076",
          "updatedAt": "2024-11-18T02:52:56Z",
          "publishedAt": "2024-11-14T15:38:04Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I'm trying to mesh with MOOSE after I see this. It seems that PolygonConcentricCircleMeshGenerator, PatternedHexMeshGenerator, and HexagonMeshTrimmer can solve my problem plausibly.\n\nYes this is exactly what you need to do for the very first shape. Did you get it working?\nTHe HexagonMeshTrimmer could be replaced by 6 CutMeshByPlane generator if it does not perform as expected.\nAre you trying to mesh the second one too?",
                  "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11256395",
                  "updatedAt": "2024-11-14T15:50:15Z",
                  "publishedAt": "2024-11-14T15:50:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Wang-Yihu"
                          },
                          "bodyText": "Dear Giud, thanks for your reply! However, maybe my words are not clear. Now I draw the geometry again:\n\nAnd I put the figure of the example in url https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial04_meshing/step06_common_ops.html\nwith PolygonConcentricCircleMeshGenerator, PatternedHexMeshGenerator, and HexagonMeshTrimmer.\n\nYou may have noticed that there is a very big difference between these two figures: All the hexagons in the MOOSE example(the second figure) are regular hexagons. However, in my example(the first figure), only the center hexagon is regular hexagon. The other six trimmed hexagon are not regular hexagons - their edges lengths are not equal - I have marked their values in the figure.\nIt seems that the class PolygonConcentricCircleMeshGenerator can only mesh regular hexagon, for its required parameter polygon_size is only one number... It seems that it cannot solve this problem...\nI'm looking forward to your reply...",
                          "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11266493",
                          "updatedAt": "2024-11-15T12:32:42Z",
                          "publishedAt": "2024-11-15T12:31:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Oh interesting.\nOk this can be done too but it will take more work.\nFor the center hexagon, no change.\nFor the side hexagons, use another PCCMG with the smaller dimensions.\nThen use a FlexiblePattern generator to place all 7 hexagons, using the custom placement option (not hexagonal, not Cartesian) since your lattice is not regular.\nhttps://mooseframework.inl.gov/source/meshgenerators/FlexiblePatternGenerator.html\nThen use the trimmer the same way since the trim dimensions are the ones for the center hexagon",
                          "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11267245",
                          "updatedAt": "2024-11-15T14:07:32Z",
                          "publishedAt": "2024-11-15T13:28:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wang-Yihu"
                          },
                          "bodyText": "Dear GiudGiud, thanks for your suggestion. Now I input PolygonConcentricCircleMeshGenerator - FlexiblePatternGenerator\n[Mesh]\nfinal_generator = 'fpg'\n  [hex_1]\n    type = PolygonConcentricCircleMeshGenerator\n    # General parameters\n    num_sides = 6\n    num_sectors_per_side = '4 4 4 4 4 4'\n    polygon_size = 0.008375\n    # Ring regions parameters\n    ring_radii = '0.0065 0.0070 0.007875'\n    ring_intervals = '2 2 2'\n    ring_block_ids = '10 15 20 25'\n    ring_block_names = 'vapor_tri vapor wick clad'\n    preserve_volumes = on\n    # Background region parameters\n    background_intervals = 2\n    background_block_ids = 30\n    background_block_names = background\n  []\n  [hex_2]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '4 4 4 4 4 4'\n    polygon_size = 0.007625\n    ring_radii = '0.00706 0.007125'\n    ring_intervals = '2 1'\n    ring_block_ids = '100 150 200'\n    ring_block_names = 'fuel_tri fuel gap'\n    preserve_volumes = on\n    background_intervals = 2\n    background_block_ids = 250\n    background_block_names = background\n  []\n  #The following error occurred in the object \"pattern_assm\", \n  #of type \"PatternedHexMeshGenerator\".\n  #In PatternedHexMeshGenerator pattern_assm: \n  #pitch metadata values of all input mesh generators must be identical.\n#  [pattern_assm_error]\n#    type = PatternedHexMeshGenerator\n#    inputs = 'hex_1 hex_2'\n#    pattern =  '1 1;\n#               1 0 1;\n#                1 1'\n#    hexagon_size = 0.024\n#    background_intervals = 2\n#    background_block_id = 1000\n#    background_block_name = background\n#  []\n  [fpg]\n    type = FlexiblePatternGenerator\n    inputs = 'hex_1 hex_2'\n    boundary_type = HEXAGON\n    boundary_sectors = 10\n    boundary_size = 0.048\n    hex_patterns = '1 1;\n                   1 0 1;\n                    1 1'\n    hex_pitches = 0.016\n  []\n  #The input mesh is not compatible with HexagonMeshTrimmer \n  # because the trimmability mesh meta data are absent.\n#  [hmt_err]\n#    type = HexagonMeshTrimmer\n#    input = fpg\n#    trim_peripheral_region = '1 1 1 1 1 1'\n#  []\n[]\n\nIt will return (I mark trimming line I want with yellow )\n\nHowever, HexagonMeshTrimmer does not work in this problem. It seems that it can only handle mesh from  PatternedHexMeshGenerator, not FlexiblePatternGenerator in my problem...",
                          "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11277483",
                          "updatedAt": "2024-11-16T13:53:06Z",
                          "publishedAt": "2024-11-16T13:16:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok so that s ok. The mesh trimmer is just 6 CutMeshByPlaneGenerator",
                          "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11277996",
                          "updatedAt": "2024-11-16T14:48:50Z",
                          "publishedAt": "2024-11-16T14:48:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can replace it by chaining these plane cutting operations. The CutMeshByPlaneGenerator should be preferred over the PlaneDeletion Generator because it will cut the boundary without creating dents in the mesh",
                          "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11278001",
                          "updatedAt": "2024-11-16T14:50:10Z",
                          "publishedAt": "2024-11-16T14:50:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wang-Yihu"
                          },
                          "bodyText": "In fact, CutMeshByPlaneGenerator cannot be applied for my 2D problem, it can only be applied for 3D problem... I use XYMeshLineCutter.\nHere is my *.i file:\n[Mesh]\nfinal_generator =  'rename'\n  [hex_1]\n    type = PolygonConcentricCircleMeshGenerator\n    # General parameters\n    num_sides = 6\n    num_sectors_per_side = '4 4 4 4 4 4'\n    polygon_size = 0.008375\n    # Ring regions parameters\n    ring_radii = '0.0065 0.0070 0.007875'\n    ring_intervals = '2 2 2'\n    ring_block_ids = '10 15 20 25'\n    ring_block_names = 'vapor_tri vapor wick clad'\n    preserve_volumes = on\n    # Background region parameters\n    background_intervals = 2\n    background_block_ids = 30\n    background_block_names = background\n  []\n  [hex_2]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '4 4 4 4 4 4'\n#    polygon_size = 0.007625\n    polygon_size = 0.007250\n    ring_radii = '0.00706 0.007125'\n    ring_intervals = '2 1'\n    ring_block_ids = '100 150 200'\n    ring_block_names = 'fuel_tri fuel gap'\n    preserve_volumes = on\n    background_intervals = 2\n    background_block_ids = 250\n    background_block_names = background\n  []\n  #The following error occurred in the object \"pattern_assm\", \n  #of type \"PatternedHexMeshGenerator\".\n  #In PatternedHexMeshGenerator pattern_assm: \n  #pitch metadata values of all input mesh generators must be identical.\n  [pattern_assm_error]\n    type = PatternedHexMeshGenerator\n    inputs = 'hex_1 hex_2'\n    pattern =  '1 1;\n               1 0 1;\n                1 1'\n    hexagon_size = 0.024\n    background_intervals = 2\n    background_block_id = 1000\n    background_block_name = background\n  []\n  [fpg]\n    type = FlexiblePatternGenerator\n    inputs = 'hex_1 hex_2'\n    boundary_type = HEXAGON\n    boundary_sectors = 10\n    boundary_size = 0.048\n    hex_patterns = '1 1;\n                   1 0 1;\n                    1 1'\n    hex_pitches = 0.016\n    background_subdomain_id = 1\n    background_subdomain_name = monolith_quad\n  []\n  #The input mesh is not compatible with HexagonMeshTrimmer \n  # because the trimmability mesh meta data are absent.\n  [hmt_err]\n    type = HexagonMeshTrimmer\n    input = rename\n    trim_peripheral_region = '1 1 1 1 1 1'\n  []\n  #Only 3D meshes are supported. \n  #Use XYMeshLineCutter for 2D meshes. \n  #Mixed dimensional meshes are not supported at the moment.\n  [cmbpg_err]\n    type = CutMeshByPlaneGenerator\n    input = fpg\n    plane_point = '0.0 0.013856 0.0'\n    plane_normal = '0.0 1.0 0.0'\n  []\n  [xymlc_1]\n    type = XYMeshLineCutter\n    input = fpg\n    cut_line_params = '-1.732 1.0 -0.027712'\n    new_boundary_id = 1111\n    tri_elem_subdomain_name_suffix = 111\n  []\n  [xymlc_2]\n    type = XYMeshLineCutter\n    input = xymlc_1\n    cut_line_params = '0.0 1.0 -0.013856'\n    new_boundary_id = 2222\n    tri_elem_subdomain_name_suffix = 222\n  []\n  [xymlc_3]\n    type = XYMeshLineCutter\n    input = xymlc_2\n    cut_line_params = '1.732 1.0 -0.027712'\n    new_boundary_id = 3333\n    tri_elem_subdomain_name_suffix = 333\n  []\n  [xymlc_4]\n    type = XYMeshLineCutter\n    input = xymlc_3\n    cut_line_params = '1.732 -1.0 -0.027712'\n    new_boundary_id = 4444\n    tri_elem_subdomain_name_suffix = 444\n  []\n  [xymlc_5]\n    type = XYMeshLineCutter\n    input = xymlc_4\n    cut_line_params = '0.0 -1.0 -0.013856'\n    new_boundary_id = 5555\n    tri_elem_subdomain_name_suffix = 555\n  []\n  [xymlc_6]\n    type = XYMeshLineCutter\n    input = xymlc_5\n    cut_line_params = '-1.732 -1.0 -0.027712'\n    new_boundary_id = 6666\n    tri_elem_subdomain_name_suffix = 666\n  []\n  #It seems that all classes above cannot name block easily...\n  [rename]\n    type = RenameBlockGenerator \n    input = xymlc_6\n    old_block = '0            10        15         20   25   30            \n                 100      150       200 250'\n    new_block = 'monolith_tri vapor_tri vapor_quad wick clad monolith_quad \n                 fuel_tri fuel_quad gap monolith_quad'\n  []\n[]\n\nAnd here is my result:\n\nAnd you maybe have noticed that there is a strange block named_with 150_222 with very very small volume. It might be generated by XYMeshLineCutter with creating dents in the mesh as you said...\nSo how to solve this defect? Just use BlockDeletionGenerator to delete it?\nP.S. the class CutMeshByPlaneGenerator is not in my MOOSE version . I have to download CutMeshByPlaneGenerator.C/h and MooseMeshElementConversionUtils.C/h.",
                          "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11282292",
                          "updatedAt": "2024-11-17T09:03:19Z",
                          "publishedAt": "2024-11-17T09:03:18Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would either delete it or try to play with the directions (introducing a slight error in the direction that removes the block) for XY mesh line cutting to remove it.\nIt's due to numerical precision errors in the cutting process. Deleting it should be safe",
                          "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11283325",
                          "updatedAt": "2024-11-17T13:31:00Z",
                          "publishedAt": "2024-11-17T13:30:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wang-Yihu"
                          },
                          "bodyText": "Ok, very glad to see your reply! I might spend weeks or even months to solve it without your precious help!\nBut I still want to generate this mesh by block structured method. This geometry is so regular (even with small defect). Here I show my block structured layout and mesh by ANSYS Workbench mesh\n\nDo you have some ideas about realizing this type mesh by MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11283587",
                          "updatedAt": "2024-11-17T14:28:18Z",
                          "publishedAt": "2024-11-17T14:28:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nWe don't have this block structured algorithm in moose. Do you just mean you want to use quadrilateral elements?\nWhy don't you use your ansys mesh? If you look at the FileMeshGenerator documentation you can see all the formats we support\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11283642",
                          "updatedAt": "2024-11-17T14:36:38Z",
                          "publishedAt": "2024-11-17T14:36:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you want a quad mesh it s possible but it will take some patience. You ll have to figure out if you can the peripheral pins when they use quadrilateral center elements (a parameter of the PCCMG). If that works we can figure out how to mesh the background region with quads",
                          "url": "https://github.com/idaholab/moose/discussions/29076#discussioncomment-11283650",
                          "updatedAt": "2024-11-17T14:37:59Z",
                          "publishedAt": "2024-11-17T14:37:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "some errors with /run_tests -j 6",
          "author": {
            "login": "JOOsna"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nhello\nive got some errors with /run_tests -j 6 after build moose(make -j 6)\nThe code below is the corresponding error code\nplz help me :(\n(Optional) code in question / simulation log / errors\ncontrols/web_server_control.control/bool ................................................. FAILED (CRASH)\ncontrols/web_server_control.control/real ................................................. FAILED (CRASH)\ncontrols/web_server_control.control/int .................................................. FAILED (CRASH)\ncontrols/web_server_control.control/string ............................................... FAILED (CRASH)\ncontrols/web_server_control.control/vec_real ............................................. FAILED (CRASH)\ncontrols/web_server_control.control/vec_int .............................................. FAILED (CRASH)\ncontrols/web_server_control.control/vec_string ........................................... FAILED (CRASH)\ncontrols/web_server_control.get_postprocessor ............................................ FAILED (CRASH)\ncontrols/web_server_control.parallel_consistent ............................. [min_cpus=2] FAILED (CRASH)\ncontrols/web_server_control.errors/set_controllable_no_exist ............ FAILED (EXPECTED ERROR MISSING)\ncontrols/web_server_control.errors/postprocessor_no_exist ............... FAILED (EXPECTED ERROR MISSING)\ncontrols/web_server_control.errors/set_controllable_unregistered_type ... FAILED (EXPECTED ERROR MISSING)\ncontrols/web_server_control.errors/set_controllable_bad_convert_json .... FAILED (EXPECTED ERROR MISSING)\ncontrols/web_server_control.errors/set_controllable_vector_non_array .... FAILED (EXPECTED ERROR MISSING)\nEncountering Errors? Please include diagnostic output\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/29086",
          "updatedAt": "2024-11-17T17:01:27Z",
          "publishedAt": "2024-11-17T07:35:40Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can ignore these for now. It just means on object in moose in the Controls system won't work for you.\nIf you paste the log above this summary of the errors we can try to diagnose why they occurred.",
                  "url": "https://github.com/idaholab/moose/discussions/29086#discussioncomment-11283300",
                  "updatedAt": "2024-11-17T13:27:50Z",
                  "publishedAt": "2024-11-17T13:27:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "JOOsna"
                          },
                          "bodyText": "Thank u :)\nYour answer is very helpful",
                          "url": "https://github.com/idaholab/moose/discussions/29086#discussioncomment-11284317",
                          "updatedAt": "2024-11-17T17:01:28Z",
                          "publishedAt": "2024-11-17T17:01:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Make failure",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI am trying to compile my application and I got this feedback. Is it an error? Was the compilation successful?\n(python-stack) [emmanuel324@tinkercliffs1 belson]$ make -j8\nCreating Unity /home/emmanuel324/projects/moose/modules/solid_mechanics/build/unity_src/materials_Unity.C\nCreating Unity /home/emmanuel324/projects/belson/build/unity_src/materials_Unity.C\nCompiling C++ (in opt mode) /home/emmanuel324/projects/moose/modules/solid_mechanics/build/unity_src/materials_Unity.C...\nCompiling C++ (in opt mode) /home/emmanuel324/projects/belson/build/unity_src/materials_Unity.C...\nLinking Library /home/emmanuel324/projects/moose/modules/solid_mechanics/lib/libsolid_mechanics-opt.la...\nLinking Library /home/emmanuel324/projects/moose/modules/contact/lib/libcontact-opt.la...\nLinking Library /home/emmanuel324/projects/moose/modules/fsi/lib/libfsi-opt.la...\nLinking Library /home/emmanuel324/projects/moose/modules/peridynamics/lib/libperidynamics-opt.la...\nLinking Library /home/emmanuel324/projects/moose/modules/phase_field/lib/libphase_field-opt.la...\nLinking Library /home/emmanuel324/projects/moose/modules/porous_flow/lib/libporous_flow-opt.la...\nLinking Library /home/emmanuel324/projects/moose/modules/xfem/lib/libxfem-opt.la...\nLinking Library /home/emmanuel324/projects/moose/modules/combined/lib/libcombined-opt.la...\nLinking Library /home/emmanuel324/projects/moose/modules/module_loader/lib/libmodule_loader_with_cr_em_eps_fp_fet_gc_ls_ray_rdg_rct_rich_st_ht_sp_sm_ns_con_fsi_misc_opt_pd_pf_pflow_th_st_xfe\nm_comb-opt.la...\nLinking Library /home/emmanuel324/projects/belson/lib/libbelson-opt.la...\nLinking Test Library /home/emmanuel324/projects/belson/test/lib/libbelson_test-opt.la...\nLinking Executable /home/emmanuel324/projects/belson/belson-opt...\n/apps/easybuild/software/tinkercliffs-rome/binutils/2.40-GCCcore-13.2.0/bin/ld: skipping incompatible /lib/libutil.so when searching for -lutil\n/apps/easybuild/software/tinkercliffs-rome/binutils/2.40-GCCcore-13.2.0/bin/ld: skipping incompatible /lib/libpthread.so when searching for -lpthread\n/apps/easybuild/software/tinkercliffs-rome/binutils/2.40-GCCcore-13.2.0/bin/ld: skipping incompatible /lib/librt.so when searching for -lrt\n/apps/easybuild/software/tinkercliffs-rome/binutils/2.40-GCCcore-13.2.0/bin/ld: skipping incompatible /lib/libdl.so when searching for -ldl\n/apps/easybuild/software/tinkercliffs-rome/binutils/2.40-GCCcore-13.2.0/bin/ld: skipping incompatible /lib/libm.so when searching for -lm\n/apps/easybuild/software/tinkercliffs-rome/binutils/2.40-GCCcore-13.2.0/bin/ld: skipping incompatible /lib/libpthread.so when searching for -lpthread\n/apps/easybuild/software/tinkercliffs-rome/binutils/2.40-GCCcore-13.2.0/bin/ld: skipping incompatible /lib/libc.so when searching for -lc\n/apps/easybuild/software/tinkercliffs-rome/binutils/2.40-GCCcore-13.2.0/bin/ld: /home/emmanuel324/projects/belson/lib/libbelson-opt.so: undefined reference to `InputParameters validParams<Or\nderParameterFunctionMaterial>()'\n/apps/easybuild/software/tinkercliffs-rome/binutils/2.40-GCCcore-13.2.0/bin/ld: /home/emmanuel324/projects/belson/lib/libbelson-opt.so: undefined reference to `InputParameters validParams<Ke\nrnel>()'\ncollect2: error: ld returned 1 exit status\nmake: *** [/home/emmanuel324/projects/belson/belson-opt] Error 1\n(python-stack) [emmanuel324@tinkercliffs1 belson]$",
          "url": "https://github.com/idaholab/moose/discussions/28724",
          "updatedAt": "2024-11-17T16:26:59Z",
          "publishedAt": "2024-09-27T19:15:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "This syntax for parameters has been deprecated for a while.\nYou need to update those two objects to the new syntax, git clean and recompile",
                  "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-10779350",
                  "updatedAt": "2024-09-27T19:32:06Z",
                  "publishedAt": "2024-09-27T19:32:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "Can you give a little bit of detail on what I  need to do resolve this. I just added two source codes and header files in my application, that caused this issue.",
                          "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-10779588",
                          "updatedAt": "2024-09-27T20:13:43Z",
                          "publishedAt": "2024-09-27T20:13:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "see this announcement\nhttps://mooseframework.inl.gov/docs/PRs/28672/site/newsletter/2021/2021_11.html#legacy-input-parameter-deprecation",
                          "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-10779671",
                          "updatedAt": "2024-09-27T20:27:32Z",
                          "publishedAt": "2024-09-27T20:27:31Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "Thanks, issues resolved!",
                          "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-10780135",
                          "updatedAt": "2024-09-27T21:39:42Z",
                          "publishedAt": "2024-09-27T21:39:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "My app compiled successfully but I still get the error with my script\nA 'BarrierFunctionMaterial_abs' is not a registered object.check_inp(moose_srv)\nIf you are trying to find this object in a dynamically loaded library, make sure thatcheck_inp(moose_srv)\nthe library can be found either in your \"Problem/library_path\" parameter or in thecheck_inp(moose_srv)\nMOOSE_LIBRARY_PATH environment variable\n\nHow do I fix it?",
                          "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-10780217",
                          "updatedAt": "2024-09-27T21:57:26Z",
                          "publishedAt": "2024-09-27T21:57:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "how did you register your material? can you paste the beginning of the source file for this material?",
                          "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-10780247",
                          "updatedAt": "2024-09-27T22:04:29Z",
                          "publishedAt": "2024-09-27T22:04:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"BarrierFunctionMaterial_abs.h\"\n\nregisterMooseObject(\"belson\", BarrierFunctionMaterial_abs);\n\n\nInputParameters\nBarrierFunctionMaterial_abs::validParams()\n{\n  InputParameters params = OrderParameterFunctionMaterial::validParams();\n  params.addClassDescription(\"Helper material to provide g(eta) and its derivative in a \"\n                             \"polynomial.\\nSIMPLE: eta^2*(1-eta)^2\\nLOW: eta*(1-eta)\"\n                             \"\\nHIGH: eta^2*(1-eta^2)^2\");\n  MooseEnum g_order(\"SIMPLE=0 LOW HIGH\", \"SIMPLE\");\n  params.addParam<MooseEnum>(\"g_order\", g_order, \"Polynomial order of the barrier function g(eta)\");\n  params.addParam<bool>(\"well_only\",\n                        false,\n                        \"Make the g zero in [0:1] so it only contributes to \"\n                        \"enforcing the eta range and not to the phase \"\n                        \"transformation berrier.\");\n  params.set<std::string>(\"function_name\") = std::string(\"g\");\n  return params;\n}",
                          "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-10780252",
                          "updatedAt": "2024-09-27T22:05:55Z",
                          "publishedAt": "2024-09-27T22:05:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it should probably be\nregisterMooseObject(\"belsonApp\", BarrierFunctionMaterial_abs);\n\nif that does not work, try\nregisterMooseObject(\"MooseApp\", BarrierFunctionMaterial_abs);",
                          "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-10780297",
                          "updatedAt": "2024-09-27T22:13:32Z",
                          "publishedAt": "2024-09-27T22:13:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "Thanks the first suggestion worked",
                          "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-10780355",
                          "updatedAt": "2024-09-27T22:30:52Z",
                          "publishedAt": "2024-09-27T22:30:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ColinMG2"
                          },
                          "bodyText": "Hello! I have run into the same error when trying to run make for the solid mechanics module. I tried clicking on the link you posted but I get a 404 not found error. How can I resolve this issue. My output is similar:\n(moose) colinmoose@ColinG14:~/projects/moose/modules/solid_mechanics$ make -j 16\nLinking Executable /home/colinmoose/projects/moose/modules/solid_mechanics/solid_mechanics-opt...\n/home/colinmoose/miniforge/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/12.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/colinmoose/projects/moose/modules/solid_mechanics/lib/libsolid_mechanics-opt.so: undefined reference to `non-virtual thunk to ExplicitTimeIntegrator::meshChanged()'\ncollect2: error: ld returned 1 exit status\nmake: *** [/home/colinmoose/projects/moose/framework/app.mk:466: /home/colinmoose/projects/moose/modules/solid_mechanics/solid_mechanics-opt] Error 1",
                          "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-11281686",
                          "updatedAt": "2024-11-17T05:30:32Z",
                          "publishedAt": "2024-11-17T05:30:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Weird error. Is this a fresh build? It could be some leftover compiles objects from before that object was modified (in which case you would to save your work using git commit then use git clean -Xfd in the moose/ folder to delete them, then compile again",
                          "url": "https://github.com/idaholab/moose/discussions/28724#discussioncomment-11281697",
                          "updatedAt": "2024-11-17T05:36:05Z",
                          "publishedAt": "2024-11-17T05:35:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "<Use a descriptive title here> About MOOSE test fail after install",
          "author": {
            "login": "SunghyunO"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nHello, I installed MOOSE, then I did test as projects/moose/test ./run_tests -j 6.\nBut there is only one fail message so I tried to fix, but I failed. The error message is as below:\nminimal_app.minimal: Working Directory: /home/sunghyunoh/projects/moose/test/tests/minimal_app\nminimal_app.minimal: Running command: /home/sunghyunoh/projects/moose/test/moose_test-opt   --minimal --list-constructed-objects --error --error-override --libtorch-device cpu\nminimal_app.minimal: \nminimal_app.minimal: ################################################################################\nminimal_app.minimal: Begin runner_run output\nminimal_app.minimal: \nminimal_app.minimal: **START OBJECT DATA**\nminimal_app.minimal: Checkpoint\nminimal_app.minimal: ConstantDT\nminimal_app.minimal: DefaultNonlinearConvergence\nminimal_app.minimal: FEProblem\nminimal_app.minimal: GeneratedMesh\nminimal_app.minimal: ImplicitEuler\nminimal_app.minimal: Transient\nminimal_app.minimal: **END OBJECT DATA**\nminimal_app.minimal: \nminimal_app.minimal: ################################################################################\nminimal_app.minimal: End runner_run output\nminimal_app.minimal: \nminimal_app.minimal: ################################################################################\nminimal_app.minimal: Begin tester output\nminimal_app.minimal: \nminimal_app.minimal: ################################################################################\nminimal_app.minimal: \nminimal_app.minimal: Unable to match the following pattern against the program's output:\nminimal_app.minimal: \nminimal_app.minimal: FEProblem\\nDefaultNonlinearConvergence\\nGeneratedMesh\nminimal_app.minimal: \nminimal_app.minimal: Tester failed, reason: EXPECTED OUTPUT MISSING\nminimal_app.minimal: \nminimal_app.minimal: ################################################################################\nminimal_app.minimal: End tester output\nminimal_app.minimal: \nminimal_app.minimal ................. FAILED (EXPECTED OUTPUT MISSING)\n\nminimal_app.minimal ................. FAILED (EXPECTED OUTPUT MISSING)\n----------------------------------------------------------------------\nRan 4528 tests in 294.9 seconds. Average test time 0.5 seconds, maximum test time 213.0 seconds.\n4527 passed, 99 skipped, 1 FAILED\n\n\nI don't know why, how can I fix this error?\n\nThank you\n\n### (Optional) code in question / simulation log / errors\n\n```shell\nminimal_app.minimal: Working Directory: /home/sunghyunoh/projects/moose/test/tests/minimal_app\nminimal_app.minimal: Running command: /home/sunghyunoh/projects/moose/test/moose_test-opt   --minimal --list-constructed-objects --error --error-override --libtorch-device cpu\nminimal_app.minimal: \nminimal_app.minimal: ################################################################################\nminimal_app.minimal: Begin runner_run output\nminimal_app.minimal: \nminimal_app.minimal: **START OBJECT DATA**\nminimal_app.minimal: Checkpoint\nminimal_app.minimal: ConstantDT\nminimal_app.minimal: DefaultNonlinearConvergence\nminimal_app.minimal: FEProblem\nminimal_app.minimal: GeneratedMesh\nminimal_app.minimal: ImplicitEuler\nminimal_app.minimal: Transient\nminimal_app.minimal: **END OBJECT DATA**\nminimal_app.minimal: \nminimal_app.minimal: ################################################################################\nminimal_app.minimal: End runner_run output\nminimal_app.minimal: \nminimal_app.minimal: ################################################################################\nminimal_app.minimal: Begin tester output\nminimal_app.minimal: \nminimal_app.minimal: ################################################################################\nminimal_app.minimal: \nminimal_app.minimal: Unable to match the following pattern against the program's output:\nminimal_app.minimal: \nminimal_app.minimal: FEProblem\\nDefaultNonlinearConvergence\\nGeneratedMesh\nminimal_app.minimal: \nminimal_app.minimal: Tester failed, reason: EXPECTED OUTPUT MISSING\nminimal_app.minimal: \nminimal_app.minimal: ################################################################################\nminimal_app.minimal: End tester output\nminimal_app.minimal: \nminimal_app.minimal ................. FAILED (EXPECTED OUTPUT MISSING)\n\nminimal_app.minimal ................. FAILED (EXPECTED OUTPUT MISSING)\n----------------------------------------------------------------------\nRan 4528 tests in 294.9 seconds. Average test time 0.5 seconds, maximum test time 213.0 seconds.\n4527 passed, 99 skipped, 1 FAILED\n\nEncountering Errors? Please include diagnostic output\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/29084",
          "updatedAt": "2024-11-15T17:43:40Z",
          "publishedAt": "2024-11-15T17:09:37Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou don't need to fix this error. We'll update MOOSE to not encounter it.\nThanks for reporting\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/29084#discussioncomment-11271420",
                  "updatedAt": "2024-11-15T17:43:40Z",
                  "publishedAt": "2024-11-15T17:43:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issue with coupledDiv for Hydrogen Embrittlement Governing Equation",
          "author": {
            "login": "AlejandroRiano2023"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello, I hope you are doing great!\nHello,\nI hope you are doing well!\nI am trying to implement the following governing equation for Hydrogen Embrittlement:\n\nThe equation involves the use of divergence. I am attempting to use coupledDiv as suggested in the MOOSE documentation, but I encounter the following error when compiling my application:\n/home/lriaomol/projects/otter/src/kernel/KernelEq1.C:51:19: error: 'coupledDiv' was not declared in this scope; did you mean 'coupledDot'?\n51 |     Real term2 = -coupledDiv((1.0 - _d[_qp]) * (1.0 - _d[_qp]) * _D_L * _grad_C_L[_qp]);\n|                   ^~~~~~~~~~\n|                   coupledDot\nCould you please assist in resolving this issue? Additionally, I am using the article \u201cPhase Field Modeling of Hydrogen Embrittlement\u201d by Huang (2020) as the basis for my model, which you can find here.\nHere is the kernelEq1.c\n#include \"KernelEq1.h\"\n#include \"MooseVariable.h\"\nregisterMooseObject(\"otterApp\", KernelEq1);\nInputParameters\nKernelEq1::validParams()\n{\nInputParameters params = Kernel::validParams();\nparams.addRequiredCoupledVar(\"C_L\", \"Concentration C_L.\");\nparams.addRequiredCoupledVar(\"C_T\", \"Concentration C_T.\");\nparams.addRequiredCoupledVar(\"theta_T\", \"Theta_T variable.\");\nparams.addRequiredCoupledVar(\"d\", \"d variable.\");\nparams.addRequiredCoupledVar(\"hidrostatic_stress\", \"Hydrostatic stress variable.\");\nparams.addRequiredCoupledVar(\"N_T\", \"N_T variable.\");\nparams.addRequiredCoupledVar(\"effective_plastic_strain\", \"Effective plastic strain.\");\nparams.addParam(\"D_L\", 12700.0, \"Diffusion coefficient D_L (micrometers squared per second).\");\nparams.addParam(\"V_H\", 2e12, \"Volume or velocity V_H (micrometers cubed per mole).\");\nparams.addParam(\"R\", 4.1240, \"R value.\");\nparams.addParam(\"Theta\", 554.25, \"Theta value.\");\nreturn params;\n}\nKernelEq1::KernelEq1(const InputParameters & parameters) :\nKernel(parameters),\n_C_L(coupledValue(\"C_L\")),\n_grad_C_L(coupledGradient(\"C_L\")),\n_der_C_L(coupledDot(\"C_L\")),\n_C_T(coupledValue(\"C_T\")),\n_theta_T(coupledValue(\"theta_T\")),\n_d(coupledValue(\"d\")),\n_D_L(getParam(\"D_L\")),  // Get D_L from the parameters\n_V_H(getParam(\"V_H\")),  // Get V_H from the parameters\n_hidrostatic_stress(coupledValue(\"hidrostatic_stress\")),\n_grad_hidrostatic_stress(coupledGradient(\"hidrostatic_stress\")),\n_N_T(coupledValue(\"N_T\")),\n_effective_plastic_strain(coupledValue(\"effective_plastic_strain\")),\n_der_effective_plastic_strain(coupledDot(\"effective_plastic_strain\")),\n_R(getParam(\"R\")),\n_Theta(getParam(\"Theta\"))\n{\n}\nReal\nKernelEq1::computeQpResidual()\n{\n// Term 1: Temporal derivative of C_L multiplied by a factor\nReal term1 = ((_C_L[_qp] + _C_T[_qp] * (1.0 - _theta_T[_qp])) / _C_L[_qp]) * _der_C_L[_qp];\n// Term 2: Divergence of the diffusion term\nReal term2 = -coupledDiv((1.0 - _d[_qp]) * (1.0 - _d[_qp]) * _D_L * _grad_C_L[_qp]);\n\n// Term 3: Divergence of the additional term with concentration, velocity, and gradient of sigma_H\nReal term3 = coupledDiv((1.0 - _d[_qp]) * (1.0 - _d[_qp]) * _D_L * _C_L[_qp] * _V_H * _grad_hidrostatic_stress[_qp] / (_R * _Theta));\n\n// Term 4: Temporal derivative of epsilon multiplied by the derivative of N_T with respect to epsilon\nReal derivative_N_T = 2.30258 * _N_T[_qp] * 12.815 * std::exp(-5.5 * _effective_plastic_strain[_qp]);  // Derivative of N_T with respect to epsilon\nReal term4 = _theta_T[_qp] * derivative_N_T * _der_effective_plastic_strain[_qp];\n\nreturn term1 + term2 + term3 + term4;\n\n}\nReal\nKernelEq1::computeQpJacobian()\n{\n// Here you can calculate the derivative with respect to the variables if necessary\nreturn 1.0; // Simplified Jacobian\n}",
          "url": "https://github.com/idaholab/moose/discussions/29038",
          "updatedAt": "2024-11-15T17:25:33Z",
          "publishedAt": "2024-11-08T22:42:56Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\ncoupledDiv should be used the same way that coupledValue is used, in the constructor intializer's list, and you have to specify the name of a variable, you cannot just specify an entire expression to take the divergence of",
                  "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11193802",
                  "updatedAt": "2024-11-08T22:56:03Z",
                  "publishedAt": "2024-11-08T22:47:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AlejandroRiano2023"
                          },
                          "bodyText": "Hello,\nI hope you're doing well. I followed your advice and created a new kernel to store the value of an entire expression. This will allow me to call the new variable and use coupleDiv. However, when I compile the new kernel, I encounter the following error:\n\nFrom my perception the error means that _grad_hidrostatic_stress[_qp] returns a vector (of type libMesh::TypeVector) and not a scalar value (double), which causes the conversion error. What could I do in this case, is there a way to store a typeVector?\nHere is the new kernel https://drive.google.com/drive/folders/1aox0WKZ9rwITmT6EFYwgvDwzhVbZFhEe?usp=sharing",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11232798",
                          "updatedAt": "2024-11-12T21:50:33Z",
                          "publishedAt": "2024-11-12T21:50:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes exactly.\nIf term3 should be a vector, then use this:\nRealVectorValue term3 = ....\n\nelse you are likely missing a dot-product or a \"take the component of this vector\" operation in the code",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11233220",
                          "updatedAt": "2024-11-12T22:58:49Z",
                          "publishedAt": "2024-11-12T22:58:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AlejandroRiano2023"
                          },
                          "bodyText": "Thank you so much for your response, GiudGiud! It worked perfectly.\nI also have a question regarding the correct way to register the divergence of a variable when working with kernel.h. I was initially tempted to use VariableDiv, but it didn't work as expected.\nHere is the relevant code:\n{\npublic:\nstatic InputParameters validParams();\nCLCalc(const InputParameters & parameters);\nprotected:\n/// ADKernel objects must override precomputeQpResidual\nvirtual ADRealVectorValue precomputeQpResidual() override;\nprivate:\nconst VariableValue & _C_L;                 // Concentration C_L\nconst VariableGradient & _grad_C_L;         // Gradient of C_L\nconst VariableDiv & _div_CLCalc_3;          // Divergence of C_L (Issue here)\n};\nCould you help clarify the correct approach for registering the divergence of a variable?",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11245288",
                          "updatedAt": "2024-11-13T19:19:26Z",
                          "publishedAt": "2024-11-13T19:19:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you look at Coupleable.h you should see the expected type is VectorVariableDivergence\n  /**\n   * Returns divergence of a coupled variable\n   * @param var_name Name of coupled variable\n   * @param comp Component number for vector of coupled variables\n   * @return Reference to a VectorVariableDivergence containing the divergence of the coupled\n   * variable\n   * @see Kernel::_div_u\n   */\n  virtual const VectorVariableDivergence & coupledDiv(const std::string & var_name,\n                                                      unsigned int comp = 0) const;",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11245330",
                          "updatedAt": "2024-11-13T19:22:28Z",
                          "publishedAt": "2024-11-13T19:22:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AlejandroRiano2023"
                          },
                          "bodyText": "Hello GiudGiud, I reviewed the MOOSE documentation for Coupleable.h (https://mooseframework.inl.gov/releases/moose/v1.0.0/doxygen/moose/Coupleable_8h_source.html), but I couldn\u2019t locate the expected type for VectorVariableDivergence. I don\u2019t know if maybe I am overlooking something. Could you please share the link to the Coupleable.h file where this type is defined?",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11270247",
                          "updatedAt": "2024-11-15T16:39:14Z",
                          "publishedAt": "2024-11-15T16:39:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you used the old doco from a release. Use the current one\nhttps://mooseframework.inl.gov/docs/doxygen/moose/Coupleable_8h_source.html",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11271110",
                          "updatedAt": "2024-11-15T17:25:34Z",
                          "publishedAt": "2024-11-15T17:25:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "AlejandroRiano2023"
                  },
                  "bodyText": "Thank you so much for your response, @GiudGiud, I really appreciate it! I just have a quick clarification: In my system of equations, I have 4 unknowns and 4 equations, and I am creating one kernel for each unknown. When I compile the app, will it automatically solve for all 4 unknowns? Is this the correct approach?",
                  "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11193874",
                  "updatedAt": "2024-11-08T23:05:49Z",
                  "publishedAt": "2024-11-08T23:05:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "once you form all 4 equations in the input file, whether using a single kernel per equation or multiple kernels (one per term in the equation). you will be able to run the input file using the app executable.\nNote that time derivative terms need to be separated from the rest of the equation, in their own kernel",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11193889",
                          "updatedAt": "2024-11-08T23:09:08Z",
                          "publishedAt": "2024-11-08T23:09:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AlejandroRiano2023"
                          },
                          "bodyText": "Thank you for the clarification!\nRegarding this, would it be okay to have some terms as auxiliary kernels and others as main kernels, or would that pose any issues? I'm wondering if this would affect the solution process or cause any unintended problems.",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11193916",
                          "updatedAt": "2024-11-08T23:15:43Z",
                          "publishedAt": "2024-11-08T23:15:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it's ok to compute some terms with auxiliary kernels, but very often you end up needing the derivatives of these terms (either using AD or manual Jacobian). And at that point, it's better to use material properties for them",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11193952",
                          "updatedAt": "2024-11-08T23:24:07Z",
                          "publishedAt": "2024-11-08T23:24:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AlejandroRiano2023"
                          },
                          "bodyText": "Thank you so much for all your help, I appreciate it.",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11194568",
                          "updatedAt": "2024-11-09T02:36:33Z",
                          "publishedAt": "2024-11-09T02:36:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Output or view the variable value at the quadrature point",
          "author": {
            "login": "keassyguang"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi everyone,\nI'd like to know if it's possible to output or view a variable value at the quadrature point through Paraview? Just like in ABAQUS, we can choose where we want to view, for example the element, node, integration point.\nMany thanks.",
          "url": "https://github.com/idaholab/moose/discussions/28912",
          "updatedAt": "2024-11-15T02:19:51Z",
          "publishedAt": "2024-10-23T09:24:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes you need to use the Positions system to pick the locations to compute at.\nThen use this VPP\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/PositionsFunctorValueSampler.html\nA functor can be a variable or a function or a functor material property",
                  "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11027314",
                  "updatedAt": "2024-10-23T09:49:05Z",
                  "publishedAt": "2024-10-23T09:49:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Thanks a lot, I will have try later.",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11027452",
                          "updatedAt": "2024-10-23T10:01:36Z",
                          "publishedAt": "2024-10-23T10:01:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "keassyguang"
                  },
                  "bodyText": "I might find an issue, if the specified output block is \"growing\" over the time during the simulation (element activated with CoupledVarThresholdElementSubdomainModifier method), the output quadrature points are as the initial defined block rather than the updated block.",
                  "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11161172",
                  "updatedAt": "2024-11-06T01:36:20Z",
                  "publishedAt": "2024-11-06T01:36:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "to update positions, specify an \"execute_on\" parameter",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11161291",
                          "updatedAt": "2024-11-06T01:50:25Z",
                          "publishedAt": "2024-11-06T01:50:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "keassyguang"
                  },
                  "bodyText": "to update positions, specify an \"execute_on\" parameter\n\nI specified execute_on = 'TIMESTEP_END', and it works now, thanks a lot",
                  "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11161360",
                  "updatedAt": "2024-11-06T02:03:25Z",
                  "publishedAt": "2024-11-06T02:03:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "It seems that the variable values at the quadrature point are correct. However, I have some problems when viewing the results in Paraview. Here, I defined the light intensity to decay exponentially from the top surface to the bottom inherited from Material class. The top boundary is defined using the CoupledVarThresholdElementSubdomainModifier and moves upwards every 4 seconds with a layer thickness of 1. I got three problems:\n\nThe moving boundary (sideset_top) moves correctly when I set expression = 'y-ceil(t/4.0001)' for the AuxVariable layerY, but it doesn't move correctly when I set expression = 'y-ceil(t/4)'. I know it is a numerical error problem, and that is why I choose 4.0001 instead of 4. However, for the LightIntensityMaterial.C, I also tried to avoid this numerical error problem. As it is implemented below, shen the time comes to 4s, the height of the top surface (domain_height) should be 1, however in the calculation the domain_height is 2. Any good solution to avoid these numerical error issues in the coding?\nThe light intensity on the top surface seems to be wrong except for the last layer. Since we define light_intensity = 100*exp(-(domain_height - y)/Dp), the light intensity for the top surface should always be 100. In the figure below, the light intensity on the upper surface is half of what it should be, even for the one (Time=4s) equals to 30.3 (60.6 = 100*exp(-(2-1)/2)). How can I show the correct value in paraview?\n\n\nheader file\n#pragma once\n\n#include \"ADMaterial.h\"\n\nclass LightIntensityMaterial : public ADMaterial\n{\npublic:\n  static InputParameters validParams();\n  LightIntensityMaterial(const InputParameters & parameters);\n\n  virtual void computeQpProperties() override;\n\nprotected:\n  const Real _I0;\n  const Real _Dp;\n  const Real _period;\n  const Real _I0_on_duration;\n  const Real _layer_thickness;\n  const Real _x_start;\n  const Real _x_end;\n\n  // Light intensity I(x, t)\n  ADMaterialProperty<Real> & _I;                  \n};\n\nsource file\n#include \"LightIntensityMaterial.h\"\n\nregisterMooseObject(\"elementActivationTestApp\", LightIntensityMaterial);\n\nInputParameters\nLightIntensityMaterial::validParams()\n{\n  InputParameters params = ADMaterial::validParams();\n  params.addRequiredParam<Real>(\"I0\", \"Initial light intensity\");\n  params.addRequiredParam<Real>(\"Dp\", \"Penetration depth\");\n  params.addRequiredParam<Real>(\"period\", \"Period over which domain height increases\");\n  params.addRequiredParam<Real>(\"I0_on_duration\", \"Duration during which I0 is on in each period\");\n  params.addRequiredParam<Real>(\"layer_thickness\", \"Domain height increment every period\");\n  params.addRequiredParam<Real>(\"x_start\", \"x_start position\");\n  params.addRequiredParam<Real>(\"x_end\", \"x_end position\");\n  params.addClassDescription(\"Kernel to compute monomer light intensity\");\n\n  return params;\n}\n\nLightIntensityMaterial::LightIntensityMaterial(const InputParameters & parameters)\n  : ADMaterial(parameters),\n    _I0(getParam<Real>(\"I0\")),\n    _Dp(getParam<Real>(\"Dp\")),\n    _period(getParam<Real>(\"period\")),\n    _I0_on_duration(getParam<Real>(\"I0_on_duration\")),\n    _layer_thickness(getParam<Real>(\"layer_thickness\")),\n    _x_start(getParam<Real>(\"x_start\")),\n    _x_end(getParam<Real>(\"x_end\")),\n    _I(declareADProperty<Real>(\"I\"))\n{\n}\n\nvoid LightIntensityMaterial::computeQpProperties()\n{\n  if (_q_point[_qp](0) >= _x_start && _q_point[_qp](0) <= _x_end)\n  {\n    Real n_periods = 0;\n    if (_t == 0){\n      n_periods = 1;\n    }\n    else{\n      // Calculate the number of completed height periods\n      n_periods = std::ceil(_t / _period);\n    }\n    \n    // Calculate the current domain height\n    Real domain_height = n_periods * _layer_thickness;\n\n    // Calculate depth\n    Real depth = domain_height - _q_point[_qp](1); // Assuming y is the vertical coordinate (2D case)\n\n    Real t_mod_period = std::fmod(_t, _period);\n    ADReal I0_t = (t_mod_period < _I0_on_duration) ? _I0 : 0.0;\n    \n    _I[_qp] =  I0_t * std::exp(-depth / _Dp);\n\n    // output for debug\n    if (1.9<_t && _t<2.1 && _q_point[_qp](0) >= 2.9 && _q_point[_qp](0) <= 3.1 && _q_point[_qp](1) >= 0.9){\n      std::cout << \"time = \" << _t<< std::endl;\n      std::cout << \"x = \" << _q_point[_qp](0) << std::endl;\n      std::cout << \"y = \" << _q_point[_qp](1) << std::endl;\n      std::cout << \"domain_height = \" << domain_height << std::endl;\n      std::cout << \"depth = \" << depth << std::endl;\n      std::cout << \"I0_t = \" << I0_t << std::endl;\n      std::cout << \"light intensity = \" << _I[_qp] << \"\\n\" << std::endl;\n    }\n  }\n  else \n  {\n    _I[_qp] = 0.0;\n  }\n}\n\ninput file\n[Problem]\n  kernel_coverage_check = false\n  boundary_restricted_node_integrity_check = false\n  boundary_restricted_elem_integrity_check = false\n  type = FEProblem\n[]\n  \n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 30\n    ny = 20\n    xmax = 6\n    ymax = 4\n  []\n  [active_domain] #the initially active domain\n    type = SubdomainBoundingBoxGenerator\n    input = 'gen'\n    block_id = 1\n    bottom_left = '0 0 0'\n    top_right = '6 1 0'\n  []\n  [inactive_domain] #the initially inactive domain\n    type = SubdomainBoundingBoxGenerator\n    input = 'active_domain'\n    block_id = 2\n    bottom_left = '0 1 0'\n    top_right = '6 4 0'\n  []\n  [sideset_top]\n    type = SideSetsAroundSubdomainGenerator\n    input = inactive_domain\n    normal = '0 1 0'\n    block = 1\n    new_boundary = 'sideset_top' # top boundary of active domain\n  []\n[]\n  \n[Variables]\n  [T]\n    initial_condition = 400 #Kelvin\n    block = 1\n  []\n[]\n\n[AuxVariables]\n  [layerY]\n    [AuxKernel]\n    type = ParsedAux\n    expression = 'y-ceil(t/4.0001)'\n    # expression = 'y-ceil(t/4)'\n    use_xyzt = true\n    execute_on = 'INITIAL TIMESTEP_BEGIN'\n    []\n  []\n  [I_aux]\n    block = 1\n    order = FIRST\n    family = MONOMIAL\n  []\n[] \n  \n[Kernels]\n  [conduction]\n    block = 1\n    type = ADHeatConduction\n    variable = T\n  []\n[]\n\n[AuxKernels]\n  [I_aux]\n    type = ADMaterialRealAux\n    block = 1\n    variable = I_aux\n    property = I\n    execute_on = 'initial timestep_end'\n  []\n[]\n\n[MeshModifiers]\n  [addLayer] \n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = 'layerY'\n    criterion_type = BELOW\n    threshold = 0\n    subdomain_id = 1\n    moving_boundaries = 'sideset_top'\n    moving_boundary_subdomain_pairs = '1 2'\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n[]\n\n[Materials]\n  [thermal]\n    type = ADHeatConductionMaterial\n    block = 1\n    specific_heat = 1e-2\n    thermal_conductivity = 1.0e-3\n  []\n  [density]\n    type = ADGenericConstantMaterial\n    block = 1\n    prop_names = 'density'\n    prop_values = '1'\n  []\n  [dummy_mat_inactive]\n    type = GenericConstantMaterial\n    block = 2\n    prop_names = 'dummy_mat'\n    prop_values = '0.0'\n  []\n  [Light_Intensity_Material]\n    type = LightIntensityMaterial\n    block = 1\n    I0 = 100                      \n    Dp = 2              \n    period = 4                   \n    layer_thickness = 1         \n    I0_on_duration = 3           \n    x_start = 0                \n    x_end = 6                             \n  []\n[]\n\n[BCs]\n  # In 2D, bottom = 0, right = 1, top = 2, left = 3 \n  [bottom_BC]\n    type = ADDirichletBC\n    variable = T\n    boundary = 0\n    value = 400\n  []\n  [side_top_BC]\n    type = ADConvectiveHeatFluxBC\n    variable = T\n    boundary = sideset_top\n    T_infinity = 300.0\n    heat_transfer_coefficient = 10\n  []\n\n  [right_BC]\n    type = ADConvectiveHeatFluxBC\n    variable = T\n    boundary = 'right'\n    T_infinity = 300.0\n    heat_transfer_coefficient = 20\n  []\n\n  [left_BC]\n    type = ADConvectiveHeatFluxBC\n    variable = T\n    boundary = left\n    T_infinity = 300.0\n    heat_transfer_coefficient = 20\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = PJFNK\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '201                hypre    boomeramg      8'\n  end_time = 16\n  dt = 0.1\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-12\n[]\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11239028",
                          "updatedAt": "2024-11-13T11:37:29Z",
                          "publishedAt": "2024-11-13T11:36:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThere's a lot here. I think you should boil this down to a very simple input so it s more understandable what you want and how it differs from what you get.\nKeep in mind\n  [I_aux]\n    block = 1\n    order = FIRST\n    family = MONOMIAL\n  []\n\nis not output in the expected manner to Exodus. So what you may be looking at could just be visualization artefact.\nThere's a thread on the forum somewhere about how it differs.\nI recommend you switch this one to a constant monomial which are output as expected, to make sure the visualization is not the problem\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11245640",
                          "updatedAt": "2024-11-13T19:58:46Z",
                          "publishedAt": "2024-11-13T19:58:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Sorry for the lack of clarity.\nI have tried setting the variable to order=CONSTANT and family = MONOMIAL. The results seem to be correct, but we lose the gradient inside the element.\nI have two problems:\n\n\nIn my code, I need to use time (_t in the source file and t in the input file) to define the movement of the top surface to simulate the addition of material in additive manufacturing. For example, I've defined an auxiliary variable, layerY, whose value is set to expression = 'y-ceil(t/4)' as I want to move this top boundary every 4 seconds. Based on the current results, it seems that the time (t) sometimes has a numerical error, e.g. if the time is 4s, the value of t is slightly greater (or smaller) than 4, something like 4.0001s (or 3.9999s). It seems difficult to get the exact integer time.\n\n\nI have defined a material property, light intensity, which decreases exponentially from top surface to bottom. The expression is light_intensity = I_0*exp(-(domain_height - y)/Dp), domain_height is the y-coordinate of the top surface (layY), and Dp is a constant. For each period (4 seconds) I_0=100 for 0s<time<3s and I_0=0 for 3s<time<4s. For the nodes (or points) on the top surface, the light intensity should be 100. However, from the figure above, the light intensity of the top surface equal to 50 (half of 100) for t=1.9s, t=4.1s, and t=8.1s while the result for t=12.1s is correct. Since the nodes on the top surface are shared with the inactive elements when time < 12s, the light intensity values on the top surface are always half of what they should be. I am not sure if the MOOSE averages the values of these shared nodes at the interface of the active and inactive domains.",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11252106",
                          "updatedAt": "2024-11-14T09:41:33Z",
                          "publishedAt": "2024-11-14T09:41:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I have tried setting the variable to order=CONSTANT and family = MONOMIAL. The results seem to be correct, but we lose the gradient inside the element.\n\nYes but the visualization works as expected and that seems to be your problem with first order monomials.\n\n, it seems that the time (t) sometimes has a numerical error, e.g. if the time is 4s, the value of t is slightly greater (or smaller) than 4, something like 4.0001s (or 3.9999s). It seems difficult to get the exact integer time.\n\nThat is expected. t is the sum of dts, which are floating point numbers. If you want to hit t = 4s exactly, use 4s as a sync time (in any Outputs object). This will force the time stepper to hit it.\nOR\nuse multiple time steppers, including a TimeSequenceStepper with 4s as a time to hit.\n\nSince the nodes on the top surface are shared with the inactive elements when time < 12s, the light intensity values on the top surface are always half of what they should be. I am not sure if the MOOSE averages the values of these shared nodes at the interface of the active and inactive domains.\n\nIs the light intensity a first order monomial?\nDid you check the variable value or are you just reporting what you saw in paraview?",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11255623",
                          "updatedAt": "2024-11-14T15:01:06Z",
                          "publishedAt": "2024-11-14T15:01:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "That is expected. t is the sum of dts, which are floating point numbers. If you want to hit t = 4s exactly, use 4s as a sync time (in any Outputs object). This will force the time stepper to hit it.\nOR\nuse multiple time steppers, including a TimeSequenceStepper with 4s as a time to hit.\n\nThank you very much. I will try it later.\n\nIs the light intensity a first order monomial?\n\nLight intensity (I) is defined as material property, and I use a auxVariable I_aux for output.\n\nDid you check the variable value or are you just reporting what you saw in paraview?\n\nI didn't check the value, just based on the result shown in the paraview. I think this is the visualization artefact in the paraview as I output the sampled values, they are correct. The picture below shows the result at time=1.9s, all values are correct. The top row is based on FIRST and the second on CONSTANT.\nDo we have any ideas to avoid the paraview visualization artefacts except using the CONSTANT MONOMIAL?\n\n[AuxVariables]\n  [I_aux]\n    block = 1\n    order = FIRST\n    # order = CONSTANT\n    family = MONOMIAL\n  []\n[] \n\n[AuxKernels]\n  [I_aux]\n    type = ADMaterialRealAux\n    block = 1\n    variable = I_aux\n    property = I\n    execute_on = 'initial timestep_end'\n  []\n[]\n\n[Materials]\n  [Light_Intensity_Material]\n    type = LightIntensityMaterial\n    block = 1\n    I0 = 100                      \n    Dp = 2              \n    period = 4                   \n    layer_thickness = 1         \n    I0_on_duration = 3           \n    x_start = 0                \n    x_end = 6                             \n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11261739",
                          "updatedAt": "2024-11-15T02:00:07Z",
                          "publishedAt": "2024-11-15T01:58:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Do we have any ideas to avoid the paraview visualization artefacts except using the CONSTANT MONOMIAL?\n\nYou could use the VTK output to plot it in python, bypassing paraview",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11261803",
                          "updatedAt": "2024-11-15T02:10:25Z",
                          "publishedAt": "2024-11-15T02:10:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11261863",
                          "updatedAt": "2024-11-15T02:19:52Z",
                          "publishedAt": "2024-11-15T02:19:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Discrete Nucleation Module inserting nuclei with negative value order parameter in grand potential model",
          "author": {
            "login": "aclin4"
          },
          "bodyText": "Hi all,\nI'm working on a grand potential phase field model to simulate the formation of gas bubbles in a fuel matrix. In my model there are four variables: the matrix phase order parameter, the bubble phase order parameter, chemical potential of gas, and chemical potential of vacancies. The full input file is included at the end of this post.\nI'm inserting the nuclei using the DiscreteNucleationForce kernel acting on the bubble order parameter:\n[nucleation_b]\n    type = DiscreteNucleationForce\n    variable = etab0\n    map = B_map\n    nucleus_value = 100\n    no_nucleus_value = 0\n[]\n\nwhere the nucleation probability is based on the supersaturation of the gas and vacancies in the matrix:\n[G_nuc]\n   type = DerivativeParsedMaterial\n   property_name = G_nuc\n   material_property_names = 'km cveq_m cgeq_m cgeq_b cv(wv) cg(wg)'\n   expression = '(cv - cveq_m) + (cg-cgeq_m)'\n   outputs = exodus\n   output_properties = G_nuc\n []\n [nucl_matl]\n   type = ParsedMaterial\n   property_name = nucl_matl\n   coupled_variables = 'etab0'\n   material_property_names = 'cg(wg) T G_nuc'\n   constant_names = 'k1star k2'\n   constant_expressions = '1e-6 \t10'\n   expression = 'if(cg>1.5e-6,if(etab0<0.0001, k1star * exp(-k2/G_nuc/T), 0),0)'\n   outputs = exodus\n []\n[../]\n\nThe UserObjects for the Discrete Nucleation Module are set up like so:\n[UserObjects]\n  [B_inserter]\n    type = DiscreteNucleationInserter\n    hold_time = 1000\n    probability = nucl_matl\n    radius = 2\n  []\n  [B_map]\n    type = DiscreteNucleationMap\n    periodic = etab0\n    inserter = B_inserter\n    int_width = 0.5\n  []\n[]\n\nHowever, when I run my simulation and a nuclei is inserted, the order parameter for the bubble phase takes a negative value. (case A)\nIn certain instances, if I modify the nucleation rate to be higher at a lower supersaturation, the nuclei will be inserted initially with a positive value, but in the subsequent timestep, the value becomes negative. (case B)\nDoes anyone have any insight as to why this is happening?\nUpdate\nI managed to get a positive value inserted for the nuclei by using the DiscreteNucleationTimeStep to limit the timestep near the nuclei insertion, however, now I get a strange propagating numerical error surrounding the nuclei (see Case C figures below). I'm unsure if this is related to the above issue or is a completely different numerical problem. Any insight into this would be greatly appreciated!\nThanks,\nAlbert\nCase A:\n\nCase B:\n\n\n\nCase C:\n\n\nFull Input File:\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    elem_type = QUAD4\n    nx = 80\n    ny = 80\n    nz = 0\n    xmin = -20\n    xmax = 20\n    ymin = -20\n    ymax = 20\n    zmin = 0\n    zmax = 0\n    #uniform_refine = 2\n  []\n[]\n[GlobalParams]\n  file_base = 'just_nuc'\n[]\n\n[Variables]\n  [./wv]\n  [../]\n  [./wg]\n  [../]\n  [./etam0]\n  [../]\n  [./etab0]\n  [../]\n[]\n\n[AuxVariables]\n  [./n]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n[AuxKernels]\n  [./nucc]\n    type = DiscreteNucleationAux\n    map = B_map\n    variable = n\n    no_nucleus_value = 0\n    nucleus_value = 10\n    execute_on = TIMESTEP_END\n  [../]\n[]\n\n[BCs]\n  [./Periodic]\n    [./all]\n      variable = 'etam0 etab0 wv wg'\n      auto_direction = 'x y'\n    [../]\n  [../]\n\n[]\n\n[ICs]\n  [./IC_etam0]\n    type = SpecifiedSmoothCircleIC\n    variable = etam0\n    invalue = 1\n    outvalue = 1\n    x_positions = '  -8.0   7.0 -10.0   7.0'\n    y_positions = '  -8.0   8.0   6.0  -8.0'\n    z_positions = '   0.0   0.0   0.0   0.0'\n    radii = '   1.0   1.0   1.0   1.0'\n  []\n  [./IC_etab0]\n    type = SpecifiedSmoothCircleIC\n    variable = etab0\n    invalue = 0\n    outvalue = 0\n    x_positions = '  -8.0   7.0 -10.0   7.0'\n    y_positions = '  -8.0   8.0   6.0  -8.0'\n    z_positions = '   0.0   0.0   0.0   0.0'\n    radii = '   1.0   1.0   1.0   1.0'\n  []\n  [./IC_wv]\n    type = RandomIC\n    variable = wv\n    min  = 5\n    max  = 6\n    seed = 349\n  [../]\n  [./IC_wg]\n    type = RandomIC\n    variable = wg\n    min = 5\n    max = 6\n    seed = 234\n  [../]\n[]\n\n[Kernels]\n# Order parameter eta_m0\n  [./em0_dot]\n    type = TimeDerivative\n    variable = etam0\n  [../]\n  [./ACm0_bulk]\n    type = ACGrGrMulti\n    variable = etam0\n    v =           'etab0'\n    gamma_names = 'gmb'\n    mob_name = L\n  [../]\n  [./ACm0_int]\n    type = ACInterface\n    variable = etam0\n    kappa_name = kappa\n  [../]\n  [./ACm0_sw]\n    type = ACSwitching\n    variable = etam0\n    Fj_names  = 'omegam omegab'\n    hj_names  = 'hm     hb'\n    coupled_variables = 'etab0 wv wg'\n  [../]\n  # [nucleation_m]\n  #   type = DiscreteNucleationForce\n  #   variable = etam0\n  #   map = B_map\n  #   nucleus_value = -5\n  #   no_nucleus_value = 0\n  # []\n # Order parameter eta_b0\n  [./eb0_dot]\n    type = TimeDerivative\n    variable = etab0\n  [../]\n  [./ACb0_bulk]\n    type = ACGrGrMulti\n    variable = etab0\n    v =           'etam0'\n    gamma_names = 'gmb'\n    mob_name = L\n  [../]\n  [./ACb0_int]\n    type = ACInterface\n    variable = etab0\n    kappa_name = kappa\n  [../]\n  [./ACb0_sw]\n    type = ACSwitching\n    variable = etab0\n    Fj_names  = 'omegam omegab'\n    hj_names  = 'hm     hb'\n    coupled_variables = 'etam0 wv wg'\n  [../]\n  [nucleation_b]\n    type = DiscreteNucleationForce\n    variable = etab0\n    map = B_map\n    nucleus_value = 100\n    no_nucleus_value = 0\n  []\n#Chemical potential vacancies\n  [./wv_dot]\n    type = SusceptibilityTimeDerivative\n    variable = wv\n    f_name = chiv\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [./wvDiffusion]\n    type = MatDiffusion\n    variable = wv\n    diffusivity = Dchiv\n    args = ''\n  [../]\n  [./wvcoupled_etam0dot]\n    type = CoupledSwitchingTimeDerivative\n    variable = wv\n    v = etam0\n    Fj_names = 'rhovm rhovb'\n    hj_names = 'hm   hb'\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [./wvcoupled_etab0dot]\n    type = CoupledSwitchingTimeDerivative\n    variable = wv\n    v = etab0\n    Fj_names = 'rhovm rhovb'\n    hj_names = 'hm   hb'\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [vac_prod]\n    type = MaskedBodyForce\n    variable = wv\n    mask = prod\n    value = 0.2156\n  []\n#Chemical potential gas\n  [./wg_dot]\n    type = SusceptibilityTimeDerivative\n    variable = wg\n    f_name = chig\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [./wgDiffusion]\n    type = MatDiffusion\n    variable = wg\n    diffusivity = Dchig\n    args = ''\n  [../]\n  [./wgcoupled_etam0dot]\n    type = CoupledSwitchingTimeDerivative\n    variable = wg\n    v = etam0\n    Fj_names = 'rhogm rhogb'\n    hj_names = 'hm   hb'\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [./wgcoupled_etab0dot]\n    type = CoupledSwitchingTimeDerivative\n    variable = wg\n    v = etab0\n    Fj_names = 'rhogm rhogb'\n    hj_names = 'hm   hb'\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [gas_prod]\n    type = MaskedBodyForce\n    variable = wg\n    mask = prod\n    value = 0.2716\n  []\n[]\n\n[Materials]\n[prod]\n  type = ParsedMaterial\n  property_name = prod\n  coupled_variables = 'etab0'\n  material_property_names = 'h_psi F_dot'\n  expression = '(etab0<0.5)*F_dot'\n  outputs = exodus\n  output_properties = prod\n[]\n[./const]\n  type = GenericConstantMaterial\n  prop_names =  'L  kappa_p    mu_p     gmb Vm        Va         Egf Evf   cveq_b cgeq_b T    kbz       F_dot  cv0   l_star t_star E_star'\n  prop_values = '10 1.5e-10    3e10     1.5 2.462e22  4.090e-2    5.6 3.27  0.4425 0.5575 1200 8.617e-5  1e-8   0.005 1e-9   1      1e9'\n[../]\n[hvk_m]\n  type = DerivativeParsedMaterial\n  property_name = hvk_m\n  material_property_names = 'hm(etam0,etab0) Va km'\n  coupled_variables = 'etam0 etab0'\n  expression = 'hm/Va/km'\n[../]\n[hvk_b]\n  type = DerivativeParsedMaterial\n  property_name = hvk_b\n  material_property_names = 'hb(etam0,etab0) Va kb'\n  coupled_variables = 'etam0 etab0'\n  expression = 'hb/Va/kb'\n[../]\n# Switching Functions\n  [./ha_test]\n    type = SwitchingFunctionMultiPhaseMaterial\n    h_name = hm\n    all_etas = 'etam0 etab0'\n    phase_etas = 'etam0'\n  [../]\n  [./hb_test]\n    type = SwitchingFunctionMultiPhaseMaterial\n    h_name = hb\n    all_etas = 'etam0 etab0'\n    phase_etas = 'etab0'\n  [../]\n # Chemical Densities\n  [./rhovm]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wv'\n    property_name = rhovm\n    material_property_names = 'Va km cveq_m'\n    expression = 'wv/Va^2/km + cveq_m/Va'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhovm\n  [../]\n  [./rhovb]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wv'\n    property_name = rhovb\n    material_property_names = 'Va kb cveq_b'\n    expression = 'wv/Va^2/kb + cveq_b/Va'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhovb\n  [../]\n  [./rhogm]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wg'\n    property_name = rhogm\n    material_property_names = 'Va km cgeq_m'\n    expression = 'wg/Va^2/km + cgeq_m/Va'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhogm\n  [../]\n  [./rhogb]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wg'\n    property_name = rhogb\n    material_property_names = 'Va kb cgeq_b'\n    expression = 'wg/Va^2/kb + cgeq_b/Va'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhogb\n  [../]\n  [./rhog]\n    type = DerivativeParsedMaterial\n    property_name = rhog\n    material_property_names = 'rhogm(wg) rhogb(wg) hm(etam0,etab0) hb(etam0,etab0)'\n    expression = 'rhogm*hm + rhogb*hb'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhog\n  [../]\n  [./rhov]\n    type = DerivativeParsedMaterial\n    property_name = rhov\n    material_property_names = 'rhovm(wv) rhovb(wv) hm(etam0,etab0) hb(etam0,etab0)'\n    expression = 'rhovm*hm + rhovb*hb'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhov\n  [../]\n  [./cv]\n    type = DerivativeParsedMaterial\n    material_property_names = 'Va rhovm(wv) rhovb(wv) hm(etam0,etab0) hb(etam0,etab0) l_star'\n    expression = 'Va * (hm * rhovm + hb * rhovb)'\n    property_name = cv\n    outputs = exodus\n    output_properties = cv\n  [../]\n  [./cg]\n    type = DerivativeParsedMaterial\n    material_property_names = 'Va rhogm(wg) rhogb(wg) hm(etam0,etab0) hb(etam0,etab0) l_star'\n    expression = 'Va * (hm * rhogm + hb * rhogb)'\n    property_name = cg\n    outputs = exodus\n    output_properties = cg\n  [../]\n  [./cveq_m]\n    property_name = cveq_m\n    type = DerivativeParsedMaterial\n    material_property_names = 'Evf T kbz'\n    expression = '1e-6'#'exp(-Evf/kbz/T)'\n    outputs = exodus\n    output_properties = cveq_m\n  [../]\n  [./cgeq_m]\n    property_name = cgeq_m\n    type = DerivativeParsedMaterial\n    material_property_names = 'Egf T kbz'\n    expression = '1e-6'#'exp(-Egf/kbz/T)'\n    outputs = exodus\n    output_properties = cgeq_m\n  [../]\n\n  [./kappa_nondim]\n    type = DerivativeParsedMaterial\n    property_name = kappa\n    material_property_names = 'kappa_p l_star E_star'\n    expression = 'kappa_p/E_star/(l_star^2)'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = kappa\n  [../]\n  [./mu_nondim]\n    type = DerivativeParsedMaterial\n    property_name = mu\n    material_property_names = 'mu_p E_star'\n    expression = 'mu_p/E_star'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = mu\n  [../]\n # Diffusivity\n  [./vMobility]\n    type = DerivativeParsedMaterial\n    property_name = Dchiv\n    material_property_names = 'Dv chiv'\n    expression = 'Dv*chiv'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = Dchiv\n  [../]\n  [./vchi] #Non-dim\n    type = DerivativeParsedMaterial\n    property_name = chiv\n    material_property_names = 'Va hm(etam0,etab0) km hb(etam0,etab0) kb'\n    expression = '(hm/km + hb/kb) / Va^2'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = chiv\n  [../]\n  [./Dv] #Non-dim\n    type = DerivativeParsedMaterial\n    property_name = Dv\n    material_property_names = 'T kbz F_dot cv0'\n    expression = 10#'8.24e-10*exp(-4.96/kbz/T) + 1.27e-27*exp(-1.73/kbz/T)*sqrt(F_dot) + 4.5e-44*F_dot'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = Dv\n  [../]\n  [./gMobility]\n    type = DerivativeParsedMaterial\n    property_name = Dchig\n    material_property_names = 'Dg chig'\n    expression = 'Dg*chig'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = Dchig\n  [../]\n  [./gchi] #Non-dim\n    type = DerivativeParsedMaterial\n    property_name = chig\n    material_property_names = 'Va hm km hb kb'\n    expression = '(hm/km + hb/kb) / Va^2'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = chig\n  [../]\n  [./Dg]\n    type = DerivativeParsedMaterial\n    property_name = Dg\n    material_property_names = 'T kbz F_dot t_star l_star'\n    expression = 10 #'(1.288e-3*exp(-5.842/kbz/T) + 2.2837e-79*exp(-(1.32271/kbz/T)^2 - (28.425/kbz/T))*sqrt(F_dot) + 2.623e-35*exp(-1.588/kbz/T)*F_dot)'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = Dg\n  [../]\n# Grand Potential Densities\n  [./omegam]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wv wg'\n    property_name = omegam\n    material_property_names = 'Va km cveq_m cgeq_m'\n    expression = '-0.5*wv^2/Va^2/km-wv/Va*cveq_m - 0.5*wg^2/Va^2/km-wg/Va*cgeq_m'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = omegam\n  [../]\n  [./km] #nondim\n    type = ParsedMaterial\n    property_name = km\n    material_property_names = 'cv0 kbz Evf T E_star'\n    constant_names =       'k1        k2'\n    constant_expressions = '-1.787e6  1.287e10'\n    expression = '100*((k1*T + k2)/(cv0 - exp(-Evf/kbz/T))) / E_star'\n    outputs = exodus\n    output_properties = km\n  [../]\n  [./omegab]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wv wg'\n    property_name = omegab\n    material_property_names = 'Va kb f_0'\n    constant_names = 'cveq_b cgeq_b'\n    constant_expressions = '0.5575 0.4425'\n    expression = '-0.5*wv^2/Va^2/kb - wv/Va*cveq_b - 0.5*wg^2/Va^2/kb - wg/Va*cgeq_b + f_0'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = omegab\n  [../]\n  [./kb]\n    type = ParsedMaterial\n    property_name = kb\n    material_property_names = 'T E_star'\n    expression = '(2.320e8*T + 8.6e7)/E_star'\n    outputs = exodus\n    output_properties = kb\n  [../]\n  [./f_0]\n    type = ParsedMaterial\n    property_name = f_0\n    material_property_names = 'T E_star'\n    expression = '(-6.28976e3*T + 1.28704e8)/E_star'\n  [../]\n  [isbubble]\n    type = ParsedMaterial\n    property_name = isbubble\n    coupled_variables = 'etab0'\n    expression = '(etab0>0.5)'\n  []\n  [f_chem]\n    type = ParsedMaterial\n    property_name = f_chem\n    material_property_names = 'hb hm omegab omegam'\n    expression = 'hb*omegab + hm*omegam'\n    outputs = exodus\n    output_properties = f_chem\n  []\n\n  ##############################################################################\n  # Nucleation Parameters                        ###############################\n  ##############################################################################\n  [G_nuc]\n    type = DerivativeParsedMaterial\n    property_name = G_nuc\n    material_property_names = 'km cveq_m cgeq_m cgeq_b cv(wv) cg(wg)'\n    expression = '(cv - cveq_m) + (cg-cgeq_m)'\n    outputs = exodus\n    output_properties = G_nuc\n  []\n  [nucl_matl]\n    type = ParsedMaterial\n    property_name = nucl_matl\n    coupled_variables = 'etab0'\n    material_property_names = 'cg(wg) T G_nuc'\n    constant_names = 'k1star k2'\n    constant_expressions = '1e-6 \t0.005'\n    expression = 'if(cg>1.5e-6,if(etab0<0.0001, k1star * exp(-k2/G_nuc/T), 0),0)'\n    outputs = exodus\n  []\n[../]\n[UserObjects]\n  [B_inserter]\n    type = DiscreteNucleationInserter\n    hold_time = 1000\n    probability = nucl_matl\n    radius = 2\n  []\n  [B_map]\n    type = DiscreteNucleationMap\n    periodic = etab0\n    inserter = B_inserter\n    int_width = 0.5\n  []\n[]\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Postprocessors]\n  [./dt]\n    type = TimestepSize\n  [../]\n  [./DOF]\n    type = NumDOFs\n  [../]\n  [./rhov_total]\n    type = ElementIntegralMaterialProperty\n    mat_prop = rhov\n    execute_on = 'initial timestep_end'\n  [../]\n  [./rhog_total]\n    type = ElementIntegralMaterialProperty\n    mat_prop = rhog\n    execute_on = 'initial timestep_end'\n  [../]\n  [./cgtotal]\n    type = ElementIntegralMaterialProperty\n    mat_prop = cg\n  [../]\n  [./cvtotal]\n    type = ElementIntegralMaterialProperty\n    mat_prop = cv\n  [../]\n  [bubblearea]\n    type = ElementIntegralMaterialProperty\n    mat_prop = isbubble\n  []\n  [bubblepresence]\n    type = ElementIntegralVariablePostprocessor\n    variable = etab0\n  []\n  [num_bubbles]\n    type = FeatureFloodCount\n    variable = etab0\n    threshold = 0.9\n  []\n  [nuc_rate]\n    type = DiscreteNucleationData\n    inserter = B_inserter\n    value = RATE\n  []\n  [nuc_insertions]\n    type = DiscreteNucleationData\n    inserter = B_inserter\n    value = INSERTIONS\n  []\n  [nuc_count]\n    type = DiscreteNucleationData\n    inserter = B_inserter\n    value = COUNT\n  []\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'#'-pc_type -ksp_gmres_restart -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'lu       superlu_dist'#'asm      31                 lu           1'\n  line_search = 'none'\n  automatic_scaling = true\n  nl_max_its = 15\n  l_max_its = 50\n  l_tol = 1e-3\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-12\n  end_time = 1e7\n  dtmin = 2e-20\n  dtmax = 50\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 0.1\n    cutback_factor = 0.5\n    growth_factor = 1.5\n    optimal_iterations = 15\n  [../]\n[]\n\n[Adaptivity]\n  marker = combo\n  max_h_level = 3\n  [Indicators]\n    [etaind]\n      type = GradientJumpIndicator\n      variable = etab0\n    []\n  []\n  [Markers]\n    [combo]\n      type = ComboMarker\n      markers = 'etaerror nuc'\n    []\n    [etaerror]\n      type = ErrorFractionMarker\n      coarsen = 0.2\n      indicator = etaind\n      refine = 0.7\n    []\n    [nuc]\n      type = DiscreteNucleationMarker\n      map = B_map\n    []\n  []\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\n[Outputs]\n  [./exodus]\n    type = Exodus\n    execute_on = 'initial timestep_end final'\n    min_simulation_time_interval = 0\n  [../]\n  [./csv]\n    type = CSV\n  [../]\n  print_linear_residuals = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/29081",
          "updatedAt": "2024-11-15T00:27:54Z",
          "publishedAt": "2024-11-14T20:01:45Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe results seem very oscillatory. Is the mesh sufficiently discretized? Are the time steps small enough?\nI think you are supposed to resolve the interface of the grain with the mesh size, which is not happening here. I think adaptivity is trying to address it but it's not clear to me that it is doing enough",
                  "url": "https://github.com/idaholab/moose/discussions/29081#discussioncomment-11261248",
                  "updatedAt": "2024-11-15T00:27:54Z",
                  "publishedAt": "2024-11-15T00:27:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Modified smeared cracking model but damage variable exceeds range",
          "author": {
            "login": "chunhuizhao478"
          },
          "bodyText": "Hi all, I wrote a modified nonlocal damage model based on ComputeSmearedCrackingStress, inside it updates crack_damage and constrain its value between 0 and 1. And it modifies the elasticity tensor accordingly. I allow the RadialAverage  to execute LINEAR at each iteration, take in a local equivalent strain and compute the nonlocal equivalent strain eqstrain_nonlocal to be fed in this material to guide the damage evolution. However, the crack_damage in the simulation could be greater than 1 or less than 0, I wonder what causes the issue since I update it in the material object only and constrain its value, thanks!\nvoid\nElkComputeSmearedCrackingStressModifiedMazars::computeQpStress()\n{\n  bool force_elasticity_rotation = false;\n\n  //get nonlocal equivalent strain\n  Real eqstrain_nonlocal = 0.0; \n\n  //Switch between local or nonlocal model\n  switch (_model_type)\n  {\n    case ModelType::LOCAL:\n      eqstrain_nonlocal = _eqstrain_local_old[_qp];\n      break;\n\n    case ModelType::NONLOCAL:\n      eqstrain_nonlocal = _eqstrain_nonlocal[_qp];\n      break;\n  }\n\n  // Ensure nonlocal equivalent strain is non-negative\n  eqstrain_nonlocal = std::max(eqstrain_nonlocal, 0.0);\n\n  //get strain at onset of strength criterion\n  const Real youngs_modulus =\n  ElasticityTensorTools::getIsotropicYoungsModulus(_elasticity_tensor[_qp]);\n  Real cracking_strain = _cracking_stress[_qp] / youngs_modulus;\n\n  //get flag: meet criterion\n  const bool meet_criterion = (eqstrain_nonlocal > cracking_strain);\n\n  //get flag: keep loading\n  const bool loading_existing_crack = (eqstrain_nonlocal > _eqstrain_max_old[_qp]);\n\n  //get flag: pre-existing crack\n  const bool pre_existing_crack = (_crack_damage_old[_qp] > 0.0);\n\n  //if (new crack) or (loading on pre-existing)\n  if ((meet_criterion && !pre_existing_crack) || (loading_existing_crack && pre_existing_crack)){\n\n    // const Real exp_term = std::exp(_paramB * (eqstrain_nonlocal - cracking_strain));\n\n    //update damage variable\n    // Real crack_damage = 1.0\n    //                   - cracking_strain * ( 1.0 - _paramA ) / eqstrain_nonlocal \n    //                   - _paramA / exp_term;\n\n    Real crack_damage = 1.0 - cracking_strain / eqstrain_nonlocal * std::exp(-(eqstrain_nonlocal - cracking_strain)/(0.25*cracking_strain));\n    \n    // Ensure damage stays within [0,1]\n    crack_damage = std::min(std::max(crack_damage, 0.0), 1.0);\n    \n    // Enforce non-decreasing damage\n    _crack_damage[_qp] = std::max(_crack_damage_old[_qp], crack_damage);\n\n  }\n  //else\n  else{\n\n    //keep damage variable as it is\n    _crack_damage[_qp] = _crack_damage_old[_qp];\n\n  }\n\n  //constrain damage variable ScalarDamageBase.C\n  _crack_damage[_qp] = std::min(std::max(_crack_damage[_qp], 0.0), 1.0);\n\n  if (MooseUtils::absoluteFuzzyLessThan(_crack_damage[_qp], 0.0) ||\n        MooseUtils::absoluteFuzzyGreaterThan(_crack_damage[_qp], 1.0))\n      mooseError(_base_name + \"damage_index \",\n                \"must be between 0 and 1. Current value is: \",\n                _crack_damage[_qp]);  \n\n  //update elasticity tensor\n  updateLocalElasticityTensor();\n\n  //update strain tensor\n  _elastic_strain[_qp] = _elastic_strain_old[_qp] + _strain_increment[_qp];\n\n  //update stress tensor\n  // if (_crack_damage[_qp] == 1.0){\n  //   _stress[_qp] = 1e-8 * _elastic_strain[_qp];\n  // }\n  // else{\n    _stress[_qp] = _local_elasticity_tensor * _elastic_strain[_qp];\n  // }\n\n  //update maximum equivalent strain\n  Real eqstrain_max = std::max(_eqstrain_max_old[_qp], eqstrain_nonlocal);\n  _eqstrain_max[_qp] = eqstrain_max;\n\n  //update equivalent strain \n  RealVectorValue strain_in_crack_dir;\n  computeCrackStrainAndOrientation(strain_in_crack_dir);\n  Real strain_dir0_positive = std::max(strain_in_crack_dir(0), 0.0);\n  Real strain_dir1_positive = std::max(strain_in_crack_dir(1), 0.0);\n  Real strain_dir2_positive = std::max(strain_in_crack_dir(2), 0.0);\n  Real eqstrain_local = std::sqrt(strain_dir0_positive*strain_dir0_positive+strain_dir1_positive*strain_dir1_positive+strain_dir2_positive*strain_dir2_positive);\n  _eqstrain_local[_qp] = eqstrain_local;\n\n  //update jacobian\n  _Jacobian_mult[_qp] = _local_elasticity_tensor;\n  force_elasticity_rotation = true;\n\n  if (_perform_finite_strain_rotations)\n  {\n    finiteStrainRotation(force_elasticity_rotation);\n    _crack_rotation[_qp] = _rotation_increment[_qp] * _crack_rotation[_qp];\n  }\n}",
          "url": "https://github.com/idaholab/moose/discussions/29073",
          "updatedAt": "2024-11-14T18:07:09Z",
          "publishedAt": "2024-11-14T04:56:30Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "However, the crack_damage in the simulation could be greater than 1 or less than 0\n\nAre you seeing that from the material property output? Or from min/max postprocessors?",
                  "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11254292",
                  "updatedAt": "2024-11-14T13:23:07Z",
                  "publishedAt": "2024-11-14T13:23:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi @GiudGiud, previously I'm visualizing the damage in paraview (material property output), I checked the postprocesser, it appears to have the same value (less than 0), I had a hard time trying a lot of options but no luck so far.\nPostprocessor Values:\n+----------------+----------------+----------------+\n| time           | max_damage     | min_damage     |\n+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n|   2.000000e-07 |   0.000000e+00 |   0.000000e+00 |\n|   4.000000e-07 |   8.596478e-01 |   0.000000e+00 |\n|   6.000000e-07 |   9.938583e-01 |   0.000000e+00 |\n|   8.000000e-07 |   9.998492e-01 |  -9.171160e-03 |\n|   1.000000e-06 |   9.999994e-01 |   0.000000e+00 |\n|   1.200000e-06 |   1.000000e+00 |  -8.715458e-02 |\n|   1.400000e-06 |   1.000000e+00 |  -8.715458e-02 |\n|   1.600000e-06 |   1.000000e+00 |  -7.931467e-01 |\n|   1.800000e-06 |   1.000000e+00 |  -7.999849e-01 |\n|   2.000000e-06 |   1.070128e+00 |  -7.999849e-01 |\n|   2.200000e-06 |   1.091257e+00 |  -7.999849e-01 |\n|   2.400000e-06 |   1.008070e+00 |  -7.999849e-01 |\n|   2.600000e-06 |   1.008070e+00 |  -7.999849e-01 |\n|   2.800000e-06 |   1.008070e+00 |  -8.000000e-01 |\n+----------------+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11256424",
                          "updatedAt": "2024-11-14T15:54:37Z",
                          "publishedAt": "2024-11-14T15:53:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "I also attach the input file here:\n[Mesh]\n    [./msh]\n        type = FileMeshGenerator\n        file =  '../../mesh/uniform_mesh/cylinder_uniform_short.msh'\n    []\n    displacements = 'disp_x disp_y disp_z'\n[]\n\n[GlobalParams]\n    displacements = 'disp_x disp_y disp_z'\n[]\n\n[Variables]\n    [disp_x]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [disp_y]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [disp_z]\n        order = FIRST\n        family = LAGRANGE\n    []\n[]\n\n[AuxVariables]\n    [vel_x]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [accel_x]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [vel_y]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [accel_y]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [vel_z]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [accel_z]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [./strength]\n        order = CONSTANT\n        family = MONOMIAL\n    [../]\n[]\n\n[Functions]\n    [func_tri_pulse]\n        type = ElkPulseLoadExp\n        peak_magnitude = 30e6\n        single_pulse_duration = 10\n        number_of_pulses = 5\n    []\n[]\n\n[Kernels]\n    [dispkernel_x]\n        type = DynamicStressDivergenceTensors\n        displacements = 'disp_x disp_y disp_z'\n        variable = disp_x\n        component = 0\n        use_displaced_mesh = true\n    []\n    [dispkernel_y]\n        type = DynamicStressDivergenceTensors\n        displacements = 'disp_x disp_y disp_z'\n        variable = disp_y\n        component = 1\n        use_displaced_mesh = true\n    []\n    [dispkernel_z]\n        type = DynamicStressDivergenceTensors\n        displacements = 'disp_x disp_y disp_z'\n        variable = disp_z\n        component = 2\n        use_displaced_mesh = true\n    []\n    [inertia_x]\n        type = InertialForce\n        variable = disp_x\n        velocity = vel_x\n        acceleration = accel_x\n        beta = 0.25\n        gamma = 0.5\n        use_displaced_mesh = true\n    []\n    [inertia_y]\n        type = InertialForce\n        variable = disp_y\n        velocity = vel_y\n        acceleration = accel_y\n        beta = 0.25\n        gamma = 0.5\n        use_displaced_mesh = true\n    []\n    [inertia_z]\n        type = InertialForce\n        variable = disp_z\n        velocity = vel_z\n        acceleration = accel_z\n        beta = 0.25\n        gamma = 0.5\n        use_displaced_mesh = true\n    []\n[]\n\n[AuxKernels]\n    [accel_x]\n        type = NewmarkAccelAux\n        variable = accel_x\n        displacement = disp_x\n        velocity = vel_x\n        beta = 0.25\n        execute_on = timestep_end\n    []\n    [vel_x]\n        type = NewmarkVelAux\n        variable = vel_x\n        acceleration = accel_x\n        gamma = 0.5\n        execute_on = timestep_end\n    []\n    [accel_y]\n        type = NewmarkAccelAux\n        variable = accel_y\n        displacement = disp_y\n        velocity = vel_y\n        beta = 0.25\n        execute_on = timestep_end\n    []\n    [vel_y]\n        type = NewmarkVelAux\n        variable = vel_y\n        acceleration = accel_y\n        gamma = 0.5\n        execute_on = timestep_end\n    []\n    [accel_z]\n        type = NewmarkAccelAux\n        variable = accel_z\n        displacement = disp_z\n        velocity = vel_z\n        beta = 0.25\n        execute_on = timestep_end\n    []\n    [vel_z]\n        type = NewmarkVelAux\n        variable = vel_z\n        acceleration = accel_z\n        gamma = 0.5\n        execute_on = timestep_end\n    []\n[]\n\n[BCs]\n    [./Pressure]\n        [pulsepower_load]\n            boundary = 4\n            function = func_tri_pulse\n            displacements = 'disp_x disp_y'\n        []\n    []\n[]\n\n#this user object must contain for porous flow\n[UserObjects]\n    #length_scale = 0.027 #2.7 times maximum aggregate size for granite\n    #radius = 2 * length_scale\n    [eqstrain_averaging]\n        type = ElkRadialAverage\n        length_scale = 0.0005\n        prop_name = eqstrain_local\n        radius = 0.0005\n        weights = BAZANT\n        execute_on = LINEAR\n        # force_preaux = true\n    []\n[]\n\n[Materials]\n    [./elasticity_tensor]\n        type = ComputeIsotropicElasticityTensor\n        youngs_modulus = 40e9\n        poissons_ratio = 0.25\n    [../]\n    [./elastic_stress]\n        type = ElkComputeSmearedCrackingStressModifiedMazars\n        cracking_stress = strength\n        # paramA = 0.99\n        # paramB = 10000\n        model = 'NONLOCAL'\n        output_properties = 'crack_damage stress eqstrain_local'\n        outputs = nemesis\n    [../]\n    [strain]\n        type = ComputeFiniteStrain\n        displacements = 'disp_x disp_y disp_z'\n    []\n    [density]\n        type = GenericConstantMaterial\n        prop_names = 'density'\n        prop_values = '2600'\n    []\n    [nonlocal_eqstrain]\n        type = ElkNonlocalEqstrain\n        average_UO = eqstrain_averaging\n        output_properties = 'eqstrain_nonlocal'\n        outputs = nemesis\n    []\n[]\n\n[Preconditioning]\n    [smp]\n    type = SMP\n    full = true\n    []\n[]\n\n[Distributions]\n    #typically for granite\n    #Shape Parameter (k): 5 to 15, commonly around 8 to 12.\n    #Scale Parameter (\u03bb): 5 to 30 MPa, commonly around 10 to 20 MPa.\n    [weibull]\n      type = Weibull\n      shape = 12.0 #k\n      scale = 20e6 #lambda\n      location = 0 \n    []\n  [] \n\n[ICs]\n    # [./strength]\n    #   type = VolumeWeightedWeibull\n    #   variable = strength\n    #   reference_volume = 1e-7\n    #   weibull_modulus = 12.0\n    #   median = 30e6\n    # [../]\n    [./strength]\n        type =  RandomIC\n        variable = strength\n        distribution = weibull\n    []\n[]\n\n[Postprocessors]\n    [./max_damage]\n        type = ElementExtremeValue\n        variable = crack_damage\n        value_type = max\n    []\n    [./min_damage]\n        type = ElementExtremeValue\n        variable = crack_damage\n        value_type = min\n    []    \n[]\n\n[Executioner]\n    type = Transient\n    solve_type = Newton\n    petsc_options_iname = '-ksp_gmres_restart -pc_type -sub_pc_type'\n    petsc_options_value = '101                asm      lu'\n\n    line_search = 'none'\n    # num_steps = 1\n    l_max_its = 100\n    nl_max_its = 10\n    nl_rel_tol = 1e-8\n    nl_abs_tol = 1e-8\n    l_tol = 1e-5\n    start_time = 0.0\n    end_time = 30e-6\n    dt = 1e-8\n    [./TimeIntegrator]\n        type = NewmarkBeta\n        beta = 0.25\n        gamma = 0.5\n    [../]\n[]\n\n[Outputs]\n    exodus = false\n    nemesis = true\n    time_step_interval = 20\n    csv = true\n[]\n\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#pragma once\n\n#include \"ColumnMajorMatrix.h\"\n#include \"ComputeMultipleInelasticStress.h\"\n#include \"SmearedCrackSofteningBase.h\"\n#include \"Function.h\"\n\n/*\nElk Compute Smeared Cracking Stress Model\nCreated by Chunhui Zhao, Oct 15th, 2024\nRewrite the smeared crack model, add energy regularization\nRegularization takes place on equivalent strain\n\n- Pure Solid Mechanics\n- Take regularizated equivalent strain as input\n\n*/\n\n/**\n * ElkComputeSmearedCrackingStressModifiedMazars computes the stress for a finite strain\n * material with smeared cracking\n */\nclass ElkComputeSmearedCrackingStressModifiedMazars : public ComputeMultipleInelasticStress\n{\npublic:\n  static InputParameters validParams();\n\n  ElkComputeSmearedCrackingStressModifiedMazars(const InputParameters & parameters);\n\n  virtual void initQpStatefulProperties() override;\n  virtual void computeQpStress() override;\n\nprotected:\n\n  /**\n   * Compute the crack strain in the crack coordinate system. Also\n   * computes the crack orientations, and stores in _crack_rotation.\n   * @param strain_in_crack_dir Computed strains in crack directions\n   */\n  void computeCrackStrainAndOrientation(RealVectorValue & strain_in_crack_dir);\n\n  /**\n   * Update the local elasticity tensor (_local_elasticity_tensor)\n   * due to the effects of cracking.\n   */\n  void updateLocalElasticityTensor();\n\n  ///@{ Input parameters for smeared crack models\n\n  /// Threshold at which cracking initiates if tensile stress exceeds it\n  const VariableValue & _cracking_stress;\n\n  //@{ Damage (goes from 0 to 1) in crack directions\n  //Damage is treated as a scalar variable\n  MaterialProperty<Real> & _crack_damage;\n  const MaterialProperty<Real> & _crack_damage_old;\n  ///@}\n\n  /// Nonlocal equivalent strain value\n  const MaterialProperty<Real> & _eqstrain_nonlocal;\n\n  ///@{local equivalent strain value\n  MaterialProperty<Real> & _eqstrain_local;\n  const MaterialProperty<Real> & _eqstrain_local_old;\n  ///@}\n\n  ///@{maximum equivalent strain value\n  MaterialProperty<Real> & _eqstrain_max;\n  const MaterialProperty<Real> & _eqstrain_max_old;\n  ///@}\n\n  //@{ Rotation tensor used to rotate tensors into crack local coordinates\n  MaterialProperty<RankTwoTensor> & _crack_rotation;\n  const MaterialProperty<RankTwoTensor> & _crack_rotation_old;\n  ///@}\n\n  ///@{parameters for damage evolution law\n  Real _paramA;\n  Real _paramB;\n  ///@}\n\n  //@{ Variables used by multiple methods within the calculation for a single material point\n  RankFourTensor _local_elasticity_tensor;\n  /// Vector helper to update local elasticity tensor\n  std::vector<Real> _local_elastic_vector;\n  ///@}\n\n  /// the model type\n  enum class ModelType\n  {\n    LOCAL,\n    NONLOCAL\n  } _model_type;\n\n};\n\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n/*\nElk Compute Smeared Cracking Stress Model\nCreated by Chunhui Zhao, Oct 15th, 2024\nRewrite the smeared crack model, add energy regularization\nRegularization takes place on equvalent strain\n\n- Pure Solid Mechanics\n- Take regularizated equvalent strain as input\n\n*/\n\n#include \"ElkComputeSmearedCrackingStressModifiedMazars.h\"\n#include \"ElasticityTensorTools.h\"\n#include \"StressUpdateBase.h\"\n#include \"Conversion.h\"\n\nregisterMooseObject(\"elkApp\", ElkComputeSmearedCrackingStressModifiedMazars);\n\nInputParameters\nElkComputeSmearedCrackingStressModifiedMazars::validParams()\n{\n  InputParameters params = ComputeMultipleInelasticStress::validParams();\n  params.addClassDescription(\"Compute stress using a fixed smeared cracking model\");\n  params.addRequiredCoupledVar(\n      \"cracking_stress\",\n      \"The stress threshold beyond which cracking occurs. Negative values prevent cracking.\");\n  params.addRequiredParam<Real>(\"paramA\", \"parameter used in the damage evolution law\");\n  params.addRequiredParam<Real>(\"paramB\", \"parameter used in the damage evolution law\");\n  params.set<std::vector<MaterialName>>(\"inelastic_models\") = {};\n  MooseEnum model_type(\"local nonlocal\");\n  params.addRequiredParam<MooseEnum>(\"model\", model_type, \"Model type: LOCAL or NONLOCAL\");\n  return params;\n}\n\nElkComputeSmearedCrackingStressModifiedMazars::ElkComputeSmearedCrackingStressModifiedMazars(const InputParameters & parameters)\n  : ComputeMultipleInelasticStress(parameters),\n    _cracking_stress(coupledValue(\"cracking_stress\")),\n    _crack_damage(declareProperty<Real>(_base_name + \"crack_damage\")),\n    _crack_damage_old(getMaterialPropertyOld<Real>(_base_name + \"crack_damage\")),\n    _eqstrain_nonlocal(getMaterialProperty<Real>(\"eqstrain_nonlocal\")),\n    _eqstrain_local(declareProperty<Real>(\"eqstrain_local\")),\n    _eqstrain_local_old(getMaterialPropertyOld<Real>(\"eqstrain_local\")),\n    _eqstrain_max(declareProperty<Real>(\"eqstrain_max\")),\n    _eqstrain_max_old(getMaterialPropertyOld<Real>(\"eqstrain_max\")),\n    _crack_rotation(declareProperty<RankTwoTensor>(_base_name + \"crack_rotation\")),\n    _crack_rotation_old(getMaterialPropertyOld<RankTwoTensor>(_base_name + \"crack_rotation\")),\n    _paramA(getParam<Real>(\"paramA\")),\n    _paramB(getParam<Real>(\"paramB\")),\n    _model_type(getParam<MooseEnum>(\"model\").getEnum<ModelType>())\n{\n}\n\nvoid\nElkComputeSmearedCrackingStressModifiedMazars::initQpStatefulProperties()\n{\n  _crack_damage[_qp] = 0.0;\n  _eqstrain_local[_qp] = 0.0;\n  _eqstrain_max[_qp] = 0.0;\n  _crack_rotation[_qp] = RankTwoTensor::Identity();\n}\n\nvoid\nElkComputeSmearedCrackingStressModifiedMazars::computeQpStress()\n{\n  bool force_elasticity_rotation = false;\n\n  //get nonlocal equivalent strain\n  Real eqstrain_nonlocal = 0.0; \n\n  //Switch between local or nonlocal model\n  switch (_model_type)\n  {\n    case ModelType::LOCAL:\n      eqstrain_nonlocal = _eqstrain_local_old[_qp];\n      break;\n\n    case ModelType::NONLOCAL:\n      eqstrain_nonlocal = _eqstrain_nonlocal[_qp];\n      break;\n  }\n\n  // Ensure nonlocal equivalent strain is non-negative\n  eqstrain_nonlocal = std::max(eqstrain_nonlocal, 0.0);\n\n  //get strain at onset of strength criterion\n  const Real youngs_modulus =\n  ElasticityTensorTools::getIsotropicYoungsModulus(_elasticity_tensor[_qp]);\n  Real cracking_strain = _cracking_stress[_qp] / youngs_modulus;\n\n  //get flag: meet criterion\n  const bool meet_criterion = (eqstrain_nonlocal > cracking_strain);\n\n  //get flag: keep loading\n  const bool loading_existing_crack = (eqstrain_nonlocal > _eqstrain_max_old[_qp]);\n\n  //get flag: pre-existing crack\n  const bool pre_existing_crack = (_crack_damage_old[_qp] > 0.0);\n\n  //if (new crack) or (loading on pre-existing)\n  if ((meet_criterion && !pre_existing_crack) || (loading_existing_crack && pre_existing_crack)){\n\n    // const Real exp_term = std::exp(_paramB * (eqstrain_nonlocal - cracking_strain));\n\n    //update damage variable\n    // Real crack_damage = 1.0\n    //                   - cracking_strain * ( 1.0 - _paramA ) / eqstrain_nonlocal \n    //                   - _paramA / exp_term;\n\n    Real crack_damage = 1.0 - cracking_strain / eqstrain_nonlocal * std::exp(-(eqstrain_nonlocal - cracking_strain)/(0.25*cracking_strain));\n    \n    // Ensure damage stays within [0,1]\n    crack_damage = std::min(std::max(crack_damage, 0.0), 1.0);\n    \n    // Enforce non-decreasing damage\n    _crack_damage[_qp] = std::max(_crack_damage_old[_qp], crack_damage);\n\n  }\n  //else\n  else{\n\n    //keep damage variable as it is\n    _crack_damage[_qp] = _crack_damage_old[_qp];\n\n  }\n\n  //constrain damage variable ScalarDamageBase.C\n  _crack_damage[_qp] = std::min(std::max(_crack_damage[_qp], 0.0), 1.0);\n\n  if (MooseUtils::absoluteFuzzyLessThan(_crack_damage[_qp], 0.0) ||\n        MooseUtils::absoluteFuzzyGreaterThan(_crack_damage[_qp], 1.0))\n      mooseError(_base_name + \"damage_index \",\n                \"must be between 0 and 1. Current value is: \",\n                _crack_damage[_qp]);  \n\n  //update elasticity tensor\n  updateLocalElasticityTensor();\n\n  //update strain tensor\n  _elastic_strain[_qp] = _elastic_strain_old[_qp] + _strain_increment[_qp];\n\n  //update stress tensor\n  // if (_crack_damage[_qp] == 1.0){\n  //   _stress[_qp] = 1e-8 * _elastic_strain[_qp];\n  // }\n  // else{\n    _stress[_qp] = _local_elasticity_tensor * _elastic_strain[_qp];\n  // }\n\n  //update maximum equivalent strain\n  Real eqstrain_max = std::max(_eqstrain_max_old[_qp], eqstrain_nonlocal);\n  _eqstrain_max[_qp] = eqstrain_max;\n\n  //update equivalent strain \n  RealVectorValue strain_in_crack_dir;\n  computeCrackStrainAndOrientation(strain_in_crack_dir);\n  Real strain_dir0_positive = std::max(strain_in_crack_dir(0), 0.0);\n  Real strain_dir1_positive = std::max(strain_in_crack_dir(1), 0.0);\n  Real strain_dir2_positive = std::max(strain_in_crack_dir(2), 0.0);\n  Real eqstrain_local = std::sqrt(strain_dir0_positive*strain_dir0_positive+strain_dir1_positive*strain_dir1_positive+strain_dir2_positive*strain_dir2_positive);\n  _eqstrain_local[_qp] = eqstrain_local;\n\n  //update jacobian\n  _Jacobian_mult[_qp] = _local_elasticity_tensor;\n  force_elasticity_rotation = true;\n\n  if (_perform_finite_strain_rotations)\n  {\n    finiteStrainRotation(force_elasticity_rotation);\n    _crack_rotation[_qp] = _rotation_increment[_qp] * _crack_rotation[_qp];\n  }\n}\n\nvoid\nElkComputeSmearedCrackingStressModifiedMazars::computeCrackStrainAndOrientation(\n    RealVectorValue & strain_in_crack_dir)\n{\n  // The rotation tensor is ordered such that directions for pre-existing cracks appear first\n  // in the list of columns.  For example, if there is one existing crack, its direction is in the\n  // first column in the rotation tensor.\n\n  std::vector<Real> eigval(3, 0.0);\n  RankTwoTensor eigvec;\n\n  _elastic_strain[_qp].symmetricEigenvaluesEigenvectors(eigval, eigvec);\n\n  // If the elastic strain is beyond the cracking strain, save the eigen vectors as\n  // the rotation tensor. Reverse their order so that the third principal strain\n  // (most tensile) will correspond to the first crack.\n  _crack_rotation[_qp].fillColumn(0, eigvec.column(2));\n  _crack_rotation[_qp].fillColumn(1, eigvec.column(1));\n  _crack_rotation[_qp].fillColumn(2, eigvec.column(0));\n\n  strain_in_crack_dir(0) = eigval[2];\n  strain_in_crack_dir(1) = eigval[1];\n  strain_in_crack_dir(2) = eigval[0];\n}\n\nvoid\nElkComputeSmearedCrackingStressModifiedMazars::updateLocalElasticityTensor()\n{\n  RealVectorValue stiffness_ratio_local(1.0, 1.0, 1.0);\n  _local_elastic_vector.resize(9);\n  const RankTwoTensor & R = _crack_rotation_old[_qp];\n  RankTwoTensor ePrime(_elastic_strain_old[_qp]);\n  ePrime.rotate(R.transpose());\n\n  /*\n  ePrime: pricipal elastic strain \n  stiffness_ratio_local: a stiffness reduction factor that is used to modify _elasticity_tensor\n  _cracking_neg_fraction: The fraction of the cracking strain at which a transition begins during decreasing strain to the original stiffness.\n  */\n  for (unsigned int i = 0; i < 3; ++i)\n  {\n    /*\n    absoluteFuzzyLessThan: Function to check whether a variable is less than another variable within an absolute tolerance\n    return true if var1 < var2 and var1 != var2 within tol\n    absoluteFuzzyLessThan(ePrime(i, i), 0.0): compare whether ePrime(i, i) < 0.0\n    This criterion represents all prinicipal strains are compressive, restore the elasticity\n    */\n    if (MooseUtils::absoluteFuzzyLessThan(ePrime(i, i), 0.0)){\n      stiffness_ratio_local(i) = 1.0;\n    }\n    else\n    {\n      if ( ePrime(i, i) > 0 ){ //the degradation of stiffness along this direction only active if the principal strain along this direction is positive\n        Real crack_damage_along_this_dir = _crack_damage_old[_qp] * ePrime(i, i) / _eqstrain_local_old[_qp];\n        stiffness_ratio_local(i) = (1.0 - crack_damage_along_this_dir);\n      }\n      else{ //else, restore the stiffness considering crack closure effect\n        stiffness_ratio_local(i) = 1.0;\n      }\n    }\n\n    //add a bound on stiffness ratio local\n    stiffness_ratio_local(i) = std::max(1e-8, stiffness_ratio_local(i));\n\n  }\n\n    \n  const Real & c0 = stiffness_ratio_local(0);\n  const Real & c1 = stiffness_ratio_local(1);\n  const Real & c2 = stiffness_ratio_local(2);\n\n  const Real c01 = c0 * c1;\n  const Real c02 = c0 * c2;\n  const Real c12 = c1 * c2;\n\n  const Real c01_shear_retention = std::max(c01, 0.0);\n  const Real c02_shear_retention = std::max(c02, 0.0);\n  const Real c12_shear_retention = std::max(c12, 0.0);\n\n  _local_elastic_vector[0] = _elasticity_tensor[_qp](0, 0, 0, 0) * c0;\n  _local_elastic_vector[1] = _elasticity_tensor[_qp](0, 0, 1, 1) * c01;\n  _local_elastic_vector[2] = _elasticity_tensor[_qp](0, 0, 2, 2) * c02;\n  _local_elastic_vector[3] = _elasticity_tensor[_qp](1, 1, 1, 1) * c1;\n  _local_elastic_vector[4] = _elasticity_tensor[_qp](1, 1, 2, 2) * c12;\n  _local_elastic_vector[5] = _elasticity_tensor[_qp](2, 2, 2, 2) * c2;\n  _local_elastic_vector[6] = _elasticity_tensor[_qp](1, 2, 1, 2) * c12_shear_retention;\n  _local_elastic_vector[7] = _elasticity_tensor[_qp](0, 2, 0, 2) * c02_shear_retention;\n  _local_elastic_vector[8] = _elasticity_tensor[_qp](0, 1, 0, 1) * c01_shear_retention;\n\n  // Filling with 9 components is sufficient because these are the only nonzero entries\n  // for isotropic or orthotropic materials.\n  _local_elasticity_tensor.fillFromInputVector(_local_elastic_vector,\n                                                RankFourTensor::symmetric9);\n\n  // Rotate the modified elasticity tensor back into global coordinates\n  _local_elasticity_tensor.rotate(R);\n\n}",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11256471",
                          "updatedAt": "2024-11-14T15:58:03Z",
                          "publishedAt": "2024-11-14T15:58:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "do you ever see this warning?\n  if (MooseUtils::absoluteFuzzyLessThan(_crack_damage[_qp], 0.0) ||\n        MooseUtils::absoluteFuzzyGreaterThan(_crack_damage[_qp], 1.0))\n      mooseError(_base_name + \"damage_index \",\n                \"must be between 0 and 1. Current value is: \",\n                _crack_damage[_qp]); \n\nyou are looking the variable (which imo should be within the bounds of the property, but maybe not?), not the material property",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11256633",
                          "updatedAt": "2024-11-14T16:11:22Z",
                          "publishedAt": "2024-11-14T16:11:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi @GiudGiud, no I didn't see this warning at all (mooseError should stop the simulation), which makes me confused as well, I wonder is there a way to debug such issue",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11256690",
                          "updatedAt": "2024-11-14T16:16:22Z",
                          "publishedAt": "2024-11-14T16:16:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Very odd indeed then.\nI m going to blame it on the projection to the variable then.\nIf you can reduce the problem to a simpler case still showing the issue, let's create an issue and investigate the reduced case",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11256877",
                          "updatedAt": "2024-11-14T16:36:14Z",
                          "publishedAt": "2024-11-14T16:36:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi @GiudGiud, thanks for your help! Yes I was able to reproduce the issue in a mini-example, I have created the issue ticket #29080, it should be able to reproduce the same error within minute. I will be really appreciated if you or other experts from material system group could take a look at it, it is a fairly simple and commonly used technique in continuum damage model community, thanks a lot!",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11258118",
                          "updatedAt": "2024-11-14T18:07:41Z",
                          "publishedAt": "2024-11-14T18:07:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}