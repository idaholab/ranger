{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wMy0xN1QwOTozMDoxNy0wNjowMM4AS-hB"
    },
    "edges": [
      {
        "node": {
          "title": "Physics-based preconditioner (PBP)  parameter settings",
          "author": {
            "login": "Richard-happy"
          },
          "bodyText": "Which options does the parameter about preconditioner have?",
          "url": "https://github.com/idaholab/moose/discussions/23779",
          "updatedAt": "2023-03-20T01:36:06Z",
          "publishedAt": "2023-03-19T15:33:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nit will take other pre conditioners defined in your Preconditioning block.\nThe idea is to create a different preconditioner each variable or groups of variables\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23779#discussioncomment-5360213",
                  "updatedAt": "2023-03-19T15:37:23Z",
                  "publishedAt": "2023-03-19T15:37:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Richard-happy"
                          },
                          "bodyText": "So far I know it has options such as AMG LU ILU ASM.Are there some other options I could choose?Or any codes I could refer to?",
                          "url": "https://github.com/idaholab/moose/discussions/23779#discussioncomment-5362962",
                          "updatedAt": "2023-03-20T01:05:05Z",
                          "publishedAt": "2023-03-20T01:05:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "https://mooseframework.inl.gov/source/executioners/Steady.html\nThere s a list of options there for preconditioning\nHowever this page does not use the Preconditioning syntax so you ll have to look at that page to see those",
                          "url": "https://github.com/idaholab/moose/discussions/23779#discussioncomment-5363067",
                          "updatedAt": "2023-03-20T01:27:01Z",
                          "publishedAt": "2023-03-20T01:26:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Richard-happy"
                          },
                          "bodyText": "Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/23779#discussioncomment-5363125",
                          "updatedAt": "2023-03-20T01:36:03Z",
                          "publishedAt": "2023-03-20T01:36:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Dirackernel oscillation",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear all,\nI am using the dirackernel 'ConstantPointSource' in our moose-based app to simulate the injected fluid at one point on a 1D line. But the oscillation occurs. If the mesh is refined from 1m to 0.5, the oscillation will be weakened but not relatively smooth as shown in the Numerical diffusion example of the Porosflow module. Numerical stabilization matters here.\nAre there any boundary conditions or other settings that can solve this kind of oscillation problem or replace the function of the dirackernels\uff1fThanks a lot.\nJ\n[DiracKernels]\n[./out_pp]\ntype = ConstantPointSource\npoint = '-1998 0 0'\nvariable = poressure\nvalue = -400\n[../]\n[]\nInitial oscillation\n\nWeakened oscillation after refinement",
          "url": "https://github.com/idaholab/moose/discussions/23777",
          "updatedAt": "2023-04-29T03:41:49Z",
          "publishedAt": "2023-03-18T18:00:03Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Joseph-0123"
                  },
                  "bodyText": "Hello @GiudGiud , could you please help me with this? Thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/23777#discussioncomment-5355182",
                  "updatedAt": "2023-03-18T19:37:42Z",
                  "publishedAt": "2023-03-18T19:37:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Dirac kernels introduce a discontinuous term, it s not all that surprising to see oscillations.\nYou can refine or smooth the source term with a volumetric source\nif this is for porous flow we should re classify this in the porous flow QNA so the developers pitch in",
                          "url": "https://github.com/idaholab/moose/discussions/23777#discussioncomment-5360419",
                          "updatedAt": "2023-03-19T16:23:22Z",
                          "publishedAt": "2023-03-19T16:23:22Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Questions about default time derivative",
          "author": {
            "login": "Richard-happy"
          },
          "bodyText": "thermomech_step01.txt\nFor the input file (modules/combined/tutorials/introduction/thermal_mechanical/thermomech_step01.i),the default type about the first derivative of time is ImplicitEuler. What's type about the second derivative of time   ?",
          "url": "https://github.com/idaholab/moose/discussions/23753",
          "updatedAt": "2023-04-29T03:41:59Z",
          "publishedAt": "2023-03-16T03:05:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Second derivative of time I m not sure.\nI could track down an implementation for the CentralDifference time integrator and the NewmarkBeta time integrator.\n@recuero @cticenhour",
                  "url": "https://github.com/idaholab/moose/discussions/23753#discussioncomment-5329145",
                  "updatedAt": "2023-03-16T04:13:01Z",
                  "publishedAt": "2023-03-16T04:13:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "@GiudGiud is correct - both the CentralDifference and NewmarkBeta time integrators contain a second derivative calculation. While I don't see any guided examples that use these, the \"Input Files\" section on both of those pages contain test input files that might be used as an example. The Contact, Tensor Mechanics, FSI, and Electromagnetics modules all use this in some of their inputs.",
                  "url": "https://github.com/idaholab/moose/discussions/23753#discussioncomment-5335422",
                  "updatedAt": "2023-03-16T14:47:16Z",
                  "publishedAt": "2023-03-16T14:47:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Richard-happy"
                          },
                          "bodyText": "Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/23753#discussioncomment-5360094",
                          "updatedAt": "2023-03-19T15:13:28Z",
                          "publishedAt": "2023-03-19T15:13:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "So I played with this a little. If you try to retrieve a 2nd order time derivative with a time integrator object that does not implement them (currently, someone could come and implement them for every time integrator), then you get an error.\nThis PR can help you look at this\n#23771",
                  "url": "https://github.com/idaholab/moose/discussions/23753#discussioncomment-5340901",
                  "updatedAt": "2023-03-17T02:53:21Z",
                  "publishedAt": "2023-03-17T02:53:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Richard-happy"
                          },
                          "bodyText": "Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/23753#discussioncomment-5360093",
                          "updatedAt": "2023-03-19T15:13:25Z",
                          "publishedAt": "2023-03-19T15:13:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Plot variable over line vs. PointValue PostProcessor",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "Hi. I am running micromagnetic simulations using the Ferret modules. As I work in industry designing magnetic writers for magnetic disk drives, it is imperative that I collect accurate values of quantities such as magnetostatic fields generated from volume and surface magnetic charges. As part of the simulations, I solve the Poisson equation for the magnetostatic potential, and use an AuxKernel (really just computing the negative gradient of the potential) to obtain the magnetostatic field from the potential. The simulations of course dump the magnetostatic potential and the magnetostatic field in the Nemesis files, but I also use a PointValue PostProcessor to dump the magnetostatic field at some particularly important points. I noticed that the field values that are output by the PostProcessor are larger by 3%-4% than an old code (Magpar) that we are thinking of retiring. That was a little odd since John Mangeri and I have gone through great pains to ensure that Ferret calculates the magnetostatic field correctly. But then I compared the values of the Aux variables for the magnetostatic field as output in the Nemesis files with those output by the PointValue postprocessor, and they are not the same: the PointValue postprocessor values are larger in magnitude by 3%-4%! This is odd. Is there some complicated reason why this might occur? The nonlinear variable on which the Aux kernel acts is a LAGRANGE variable so the Aux variables are nodal.\nThanks,\nOlle",
          "url": "https://github.com/idaholab/moose/discussions/23679",
          "updatedAt": "2023-03-18T14:51:24Z",
          "publishedAt": "2023-03-09T15:37:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPointValue relies on this routine\nhttps://libmesh.github.io/doxygen/classlibMesh_1_1System.html#afbcbcceb6ee4f02272c69d5292394603\nto get the value, which relies on the one below that evaluates the shape functions.\nAre you using displaced meshes?\n@roystgnr I m not sure why they would differ but you have more experience in how our exodus output works\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23679#discussioncomment-5256362",
                  "updatedAt": "2023-03-09T16:07:37Z",
                  "publishedAt": "2023-03-09T16:07:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "heinono1"
                          },
                          "bodyText": "Thanks, Guillaume. I am not using displaced mesh. Interesting to see that the PointValue is expensive (the search algorithm for the element). Maybe better just to use Paraview or other postprocessing of the Nemesis/Exodus files by creating a small mesh block for the region of interest?\nCheers,\nOlle",
                          "url": "https://github.com/idaholab/moose/discussions/23679#discussioncomment-5256622",
                          "updatedAt": "2023-03-09T16:28:45Z",
                          "publishedAt": "2023-03-09T16:28:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It s expensive mostly the first time, when the point locator gets created if it has not been already",
                          "url": "https://github.com/idaholab/moose/discussions/23679#discussioncomment-5256740",
                          "updatedAt": "2023-03-09T16:40:22Z",
                          "publishedAt": "2023-03-09T16:40:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "heinono1"
                          },
                          "bodyText": "Thanks - that makes sense. But I am still puzzling over the difference between the PointValue and the Exodus Plot over line value....",
                          "url": "https://github.com/idaholab/moose/discussions/23679#discussioncomment-5256804",
                          "updatedAt": "2023-03-09T16:46:58Z",
                          "publishedAt": "2023-03-09T16:46:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "heinono1"
                          },
                          "bodyText": "I am going to mark this answered (thanks, Guillaume). I believe the discrepancy just has to do with the fact that the output in the Exodus file is a bit noisy (nodal values and and finite mesh resolution) and how the postprocessor evaluates the variables at the specified points - it seems really just to boil down to spatial noise because of the finite mesh resolution. I believe I can filter the results using custom postprocessing outside of MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/23679#discussioncomment-5269013",
                          "updatedAt": "2023-03-10T15:39:07Z",
                          "publishedAt": "2023-03-10T15:39:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Roy is on vacation and he knows a lot more than me btw",
                          "url": "https://github.com/idaholab/moose/discussions/23679#discussioncomment-5269847",
                          "updatedAt": "2023-03-10T16:43:49Z",
                          "publishedAt": "2023-03-10T16:43:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "The point locator creation is something like O(N log N), but even point locator use is O(log N) with IIRC an ugly constant, not something you'd want to use unnecessarily.  It's as good as you can get asymptotically if you don't already know what element you're on, but it's bad enough that we have a bunch of code which looks like \"try a good guess about what element you're on, then fall back on the point locator if we guessed wrong\".\nIf you're using LAGRANGE, that rules out my first hypothesis for the discrepancy, about how we have to decimate higher-order solutions to fit onto the second-order elements in Exodus.  Exodus output of linear and quadratic Lagrange elements is pretty much one-to-one.  Although ... in my experience Paraview will further decimate second-order to piecewise-first-order when displaying a solution; is it possible they do the same when postprocessing a solution as well??\nMaybe you're hitting a loose tolerance on the point locator if you're near an element boundary, getting an evaluation from a neighboring element?  But the default relative tolerance is like 1e-6, and that times your flux jump (plus some even-higher-order terms) shouldn't be anywhere near 3e-2.\nI'd love to see an example of the failure.  If there's a MOOSE/libMesh bug then we ought to be fixing it; if there's a Paraview issue we ought to be letting users know about it.  There's a level at which I too throw up my hands up and say \"floating point, noise, whatcha gonna do\", but it's at more like 1e-10, not 3e-2.",
                          "url": "https://github.com/idaholab/moose/discussions/23679#discussioncomment-5350210",
                          "updatedAt": "2023-03-17T21:47:54Z",
                          "publishedAt": "2023-03-17T21:47:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "heinono1"
                          },
                          "bodyText": "Thanks, Roy. I am using LAGRANGE. I dug in a little bit more and compared the MOOSE postprocessor output (PointValue) with Paraview's rendering from the Exodus file, and also using Paraview to calculate the gradient of the potential in the Exodus file. It turns out that the potential in Exodus that Paraview renders is very smooth, and the Paraview-calculated gradient is too - smoother than the Moose postprocessor output, for some reason. The Paraview rendering of the Exodus field is rather choppy. It may also be that the particular point at which I want the field has some pathology associated with it (like being at an element boundary) - at that point, the PointValue postprocessor field is always some 3%-4% larger than it \"should\" be (based, for example, on the Paraview-calculated gradient of the potential). I should probably re-mesh that particular block to see if changes the output field values at that particular point.",
                          "url": "https://github.com/idaholab/moose/discussions/23679#discussioncomment-5353744",
                          "updatedAt": "2023-03-18T14:51:24Z",
                          "publishedAt": "2023-03-18T14:51:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to use two different kinds of time scheme",
          "author": {
            "login": "nuomi68"
          },
          "bodyText": "Helo,everyone.\nI want to run a thermal expansion simulation using two different time scheme by emperature and displacement.So I am uising  MultiApps.\nThe equation I'm going to solve\n\nThis is obviously loose coupling, and we can solve for temperature, plug it into the displacement equation\nBut, encounter a problem during the simulation of thermal expansion, MultiApps solution  result  for temperature is greataet than single app.\nThis result by  MultiApps\n\nThis result by single Apps\n\nthis single_nodal_x  is disp_x\nThe sub of  MultiApps is solving temperature,the parent receive the temperature and then solve the displacement.\nI have a guess that the temperature can't sense the change in displacement, so there is an error in the result,but I don't know how to transfer the displacement to sub apps.\nOf course we can accept this error, but I still want to know how to get the subapplication to get the displacement, because I want to put the displacement in the heat conduction, to get a Fully-Coupled.Or if there is a better solution, such as using two different time scheme in single app.\nFor example,replace the heat conduction equation with this\n\nThanks!\nHere is my input file.\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  incremental = true\n  eigenstrain_name = eigenstrain\n  temperature = temperature\n[]\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 10\n  ny = 10\n  nz = 10\n  xmax = 0.06\n  ymax = 0.06\n  zmax = 0.06 \n[]\n[Functions]\n  [source]\n    type = ParsedFunction\n    expression = 400\n    symbol_names = 'alpha'\n    symbol_values = '16'\n  [../]\n[]\n\n\n[Variables]\n\n  [./disp_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_z]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n[Kernels]\n  [./TensorMechanics]\n    use_automatic_differentiation =false  \n  [../]\n[]\n\n[BCs]\n  [confinex]\n    type = DirichletBC\n    variable = disp_x\n    value = 0\n    boundary = 0\n  []\n  [confiney]\n    type = DirichletBC\n    variable = disp_y\n    value = 0\n    boundary = 0\n  []\n  [confinez]\n    type = DirichletBC\n    variable = disp_z\n    value = 0\n    boundary = 0\n  []\n[]\n\n[AuxVariables]\n  [./temperature]\n    [../]\n[]\n\n[Materials]\n   [fuel_elasticity_tensor]\n      type = ComputeIsotropicElasticityTensor\n      youngs_modulus = 7.77e10\n      poissons_ratio = 0.323\n    [../]\n    [./thermal_strain1]\n      type = ComputeThermalExpansionEigenstrain\n      thermal_expansion_coeff = 1.243e-5\n      stress_free_temperature = 230\n      temperature = temperature\n    [../]\n    [fuel_stress]\n      type = ComputeFiniteStrainElasticStress\n    []\n    [strain]\n      type = ComputeFiniteStrain\n      eigenstrain_names = eigenstrain\n    []\n      [density]\n        type = GenericConstantMaterial\n        prop_names = 'density specific_heat  thermal_conductivity'\n        prop_values = '3900 595 400'\n      []\n[]\n\n[Preconditioning]\n  active=SMP_full\n   [SMP_full]\n   type = SMP\n   full = true\n   solve_type = 'PJFNK'\n   []\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  end_time= 10\n  dt=1\n  solve_type =PJFNK\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu superlu_dist '\n[]\n[Outputs]\n  interval = 1\n  csv = true\n  exodus = true\n  [console]\n    type = Console\n    output_linear = true\n    output_nonlinear = true\n  []\n[]\n[Postprocessors]\n  [single_nodal_temperature]\n    type = PointValue\n    point = '0.01 0.01 0.01'\n    variable = \"temperature\"\n  []\n  [single_nodal_x]\n    type = PointValue\n    point = '0.01 0.01 0.01'\n    variable = \"disp_x\"\n  []\n[]\n[MultiApps]\n  [TransferApp]\n    type = TransientMultiApp\n    input_files = heatconduct.i\n    sub_cycling = true\n  []\n[]\n[Transfers]\n  [./get_heat]\n    type = MultiAppNearestNodeTransfer\n    source_variable = temperature\n    variable = temperature\n    from_multi_app = TransferApp\n    displaced_target_mesh=true\n    displaced_source_mesh=true\n    use_displaced_mesh=true\n  [../]\n  # [./to_x]\n  #   type = MultiAppCopyTransfer\n  #   source_variable = disp_x\n  #   variable = disp_x\n  #   to_multi_app = TransferApp\n  #   displaced_target_mesh=true\n  #   displaced_source_mesh=true\n  #   use_displaced_mesh=true\n  # [../]\n  # [./to_y]\n  #   type = MultiAppCopyTransfer\n  #   source_variable = disp_x\n  #   variable = disp_x\n  #   to_multi_app = TransferApp\n  #   displaced_target_mesh=true\n  #   displaced_source_mesh=true\n  #   use_displaced_mesh=true\n  # [../]\n  # [./to_z]\n  #   type = MultiAppCopyTransfer\n  #   source_variable = disp_x\n  #   variable = disp_x\n  #   to_multi_app = TransferApp\n  #   displaced_target_mesh=true\n  #   displaced_source_mesh=true\n  #   use_displaced_mesh=true\n  # [../]\n[]\n\nthe sub apps\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 10\n  ny = 10\n  nz = 10\n  xmax = 0.06\n  ymax = 0.06\n  zmax = 0.06 \n[]\n[Functions]\n  [source]\n    type = ParsedFunction\n    expression = 400\n    symbol_names = 'alpha'\n    symbol_values = '16'\n  [../]\n[]\n\n[Variables]\n  [./temperature]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 295.0 # K\n  [../]\n[]\n\n[Kernels]\n  [heat_conduction]\n    type = HeatConduction\n    variable = temperature\n  []\n  [T_source]\n    type = HeatSource\n    variable =  temperature\n    function = source\n  []\n  [heat_conduction_time_derivative]\n    type = HeatConductionTimeDerivative\n    variable = temperature\n  []\n[]\n\n[BCs]\n  [./templ]\n    type = DirichletBC\n    variable = temperature\n    value =600\n    boundary = 'back'\n  []\n[]\n\n[Materials]\n  [density]\n    type = GenericConstantMaterial\n    prop_names = 'density specific_heat  thermal_conductivity'\n    prop_values = '3900 595 400'\n  []\n[]\n\n[Preconditioning]\n  active=\"SMP_full\"\n   [./SMP_full]\n   type = SMP\n   full = true\n   solve_type = 'PJFNK'\n   [../]\n[]\n\n[Postprocessors]\n  [single_nodal_temperature1]\n    type = PointValue\n    point = '0.01 0.01 0.01'\n    variable = \"temperature\"\n  []\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  end_time= 10\n  dt=1\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu superlu_dist '\n[]\n[Outputs]\n  interval = 1\n  csv = true\n  exodus = true\n  [./console]\n    type = Console\n    output_linear = true\n    output_nonlinear = true\n  [../]\n[]\n\n\nthe single app\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  incremental = true\n  eigenstrain_name = eigenstrain\n  temperature = temperature\n[]\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 10\n  ny = 10\n  nz = 10\n  xmax = 0.06\n  ymax = 0.06\n  zmax = 0.06 \n[]\n[Functions]\n  [source]\n    type = ParsedFunction\n    expression = 400\n    symbol_names = 'alpha'\n    symbol_values = '16'\n  [../]\n[]\n\n[Variables]\n  [./temperature]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 295.0 # K\n  [../]\n  [./disp_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_z]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n[Kernels]\n  [./TensorMechanics]\n    use_automatic_differentiation = false  \n    displacements = 'disp_x disp_y disp_z'\n  [../]\n  [heat_conduction]\n    type = HeatConduction\n    variable = temperature\n  []\n  [T_source]\n    type = HeatSource\n    variable =  temperature\n    function = source\n  []\n  [heat_conduction_time_derivative]\n    type = HeatConductionTimeDerivative\n    variable = temperature\n  []\n[]\n\n[BCs]\n  [confinex]\n    type = DirichletBC\n    variable = disp_x\n    value = 0\n    boundary = 0\n  []\n  [confiney]\n    type = DirichletBC\n    variable = disp_y\n    value = 0\n    boundary = 0\n  []\n  [confinez]\n    type = DirichletBC\n    variable = disp_z\n    value = 0\n    boundary = 0\n  []\n  [./templ]\n    type = DirichletBC\n    variable = temperature\n    value =600\n    boundary = 'back'\n[]\n\n[Materials]\n   [fuel_elasticity_tensor]\n      type = ComputeIsotropicElasticityTensor\n      youngs_modulus = 7.77e10\n      poissons_ratio = 0.323\n    [../]\n    [./thermal_strain1]\n      type = ComputeThermalExpansionEigenstrain\n      thermal_expansion_coeff = 1.243e-5\n      stress_free_temperature = 230\n      temperature = temperature\n    [../]\n    [fuel_stress]\n      type = ComputeFiniteStrainElasticStress\n    []\n    [./strain]\n      type = ComputeFiniteStrain\n      eigenstrain_names = eigenstrain\n\n    [../]\n    [density]\n      type = GenericConstantMaterial\n      prop_names = 'density specific_heat  thermal_conductivity'\n      prop_values = '3900 595 400'\n    []\n[]\n\n[Preconditioning]\n  active=\"SMP_full\"\n   [./SMP_full]\n   type = SMP\n   full = true\n   [../]\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  end_time= 10\n  dt=1\n  solve_type =PJFNK\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu superlu_dist '\n[]\n[Outputs]\n  interval = 1\n  csv = true\n  exodus = true\n  [./console]\n    type = Console\n    output_linear = true\n    output_nonlinear = true\n  [../]\n[]\n[Postprocessors]\n  [single_nodal_temperature]\n    type = PointValue\n    point = '0.01 0.01 0.01 '\n    variable = \"temperature\"\n  []\n  [single_nodal_x]\n    type = PointValue\n    point = '0.01 0.01 0.01'\n    variable = \"disp_x\"\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23755",
          "updatedAt": "2023-03-18T13:23:13Z",
          "publishedAt": "2023-03-16T06:16:14Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFirst, you should be able to use CopyTransfer on the displacements if the meshes are exactly the same AND if displacement is turned on in both meshes (add the displacements to the Mesh block)\nSecond the results will only match if you use fixed point iterations between the main and child app. For that, in the Main app executioner block you need to add fixed_point_min_its = 2 at least then maybe some convergence parameters\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23755#discussioncomment-5335930",
                  "updatedAt": "2023-03-16T15:34:09Z",
                  "publishedAt": "2023-03-16T15:34:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "nuomi68"
                          },
                          "bodyText": "thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/23755#discussioncomment-5353354",
                          "updatedAt": "2023-03-18T13:23:13Z",
                          "publishedAt": "2023-03-18T13:23:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to apply a constraint over an immersed boundary?",
          "author": {
            "login": "doquang"
          },
          "bodyText": "Hi,\nI would like to know is there any ways in Moose/Libmesh that I can use to apply a constraint into an immersed boundary?\nThanks a lot,\n/ Minh",
          "url": "https://github.com/idaholab/moose/discussions/23624",
          "updatedAt": "2023-04-29T03:42:24Z",
          "publishedAt": "2023-03-06T21:31:39Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIn which context is this? Which physics?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23624#discussioncomment-5220796",
                  "updatedAt": "2023-03-06T21:50:57Z",
                  "publishedAt": "2023-03-06T21:50:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "doquang"
                          },
                          "bodyText": "We would like to apply a wall boundary for fluid flow and a fixed temperature on grid points that do not conform to the shape of the boundaries.",
                          "url": "https://github.com/idaholab/moose/discussions/23624#discussioncomment-5224342",
                          "updatedAt": "2023-03-07T07:09:23Z",
                          "publishedAt": "2023-03-07T07:09:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We may be able to do that with the constraints system by evaluating the shape functions of the variables at an arbitrary location rather than on the boundary.\nWe may be able to leverage the functor system to do that, with an ElemPoint argument (evaluates the variable at a point in an element)\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classMoose_1_1FunctorBase.html#adf3479c9e85154a9d81b59cd77926b5b\nor a generic projector but it's likely more complicated here\n@roystgnr @lindsayad for ideas",
                          "url": "https://github.com/idaholab/moose/discussions/23624#discussioncomment-5229965",
                          "updatedAt": "2023-03-07T15:17:35Z",
                          "publishedAt": "2023-03-07T15:17:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We can't currently do this with the MOOSE constraint system. I'll leave @roystgnr to comment on the libMesh side of things although I believe he's currently on personal leave",
                          "url": "https://github.com/idaholab/moose/discussions/23624#discussioncomment-5231982",
                          "updatedAt": "2023-03-07T18:20:26Z",
                          "publishedAt": "2023-03-07T18:20:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "How do you want to represent the immersed boundary?",
                          "url": "https://github.com/idaholab/moose/discussions/23624#discussioncomment-5291317",
                          "updatedAt": "2023-03-13T13:05:22Z",
                          "publishedAt": "2023-03-13T13:05:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "libMesh will let you apply an arbitrary linear (homogeneous or heterogeneous) constraint equation to any DoF you want, for as many DoFs as you want, but it won't let you apply multiple constraints to the same DoF and you always have to choose which DoF is \"the\" constrained one, which makes that trick hard to reuse in complex codes, making it a last-resort feature to use in practice.  In your case the \"choose which DoF\" would be the tricky part.\nPenalty methods, Nitsche-type methods, lagrange multiplier methods, etc. might be more flexible.  Even in the super-simple case of \"pressure pinning\", where you have a constant-pressure kernel to constrain away, I've always preferred adding a penalty term to the residual (see example fem_system_ex1 in libMesh) and others prefer a Lagrange multiplier (see example systems_of_equations_ex3 there).",
                          "url": "https://github.com/idaholab/moose/discussions/23624#discussioncomment-5350267",
                          "updatedAt": "2023-03-17T21:57:56Z",
                          "publishedAt": "2023-03-17T21:57:55Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to visualize higher order elemental variable, how transfer them through SolutionUserObjects?",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nAs indicated on MOOSE webpage, see this link the exodus format does not support higher than CONSTANT elemental variable. Now, I want to transfer higher order elemental variable, say First) to another simulation using the SolutionUserObject, How can I achieve this? only through XDA format?\nif that is the case, how can I visualize them? currently, I am using Paraview for visualization.",
          "url": "https://github.com/idaholab/moose/discussions/23768",
          "updatedAt": "2023-03-21T02:01:19Z",
          "publishedAt": "2023-03-17T00:55:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou can visualize with Exodus still, before saving to XDA and after loading from XDA.\nI think we can represent a first order elemental variable fine, just maybe not load them.\n@roystgnr knows more about our exodus output\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23768#discussioncomment-5340359",
                  "updatedAt": "2023-03-17T01:10:12Z",
                  "publishedAt": "2023-03-17T01:10:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "IIRC we decimate before writing to Exodus - so you can have a MONOMIAL variable of any order, but when you write it to Exodus only the CONSTANT component (e.g. the value that would be at the center node of a QUAD9 or the zeroth vertex of a TRI) gets written.\nThis isn't just an issue with elemental variables; e.g. if we have a CUBIC variable on a QUAD9 it'll be interpolated at those 9 points (and you're down to p=2), and then if you use Paraview IIRC it adds insult to injury by interpolating those 9 points via 8 linear triangles rather than a single biquadratic (at which point you're down to p=1 at h:=h/2).\nExodus (including Nemesis) is our best option for visualization, but make sure you're doing any restarts from XDA/XDR/Checkpoint, and any postprocessing from MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/23768#discussioncomment-5349586",
                          "updatedAt": "2023-03-17T20:12:07Z",
                          "publishedAt": "2023-03-17T20:12:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Bad Termination (segmentation fault) when splitting the mesh",
          "author": {
            "login": "morsi95"
          },
          "bodyText": "Dear all,\nI receive a segmentation fault error after running the following command on my input file. The mesh block in the input file looks like this:\n[Mesh]\n  [./file_mesh]\n    type = FileMeshGenerator\n    file = mesh_test.e\n  []\n[]\n\nThe command is:\nmpiexec moose-app-opt  --n-threads=7--split-mesh 7 -i PT_th1.i\nFirstly, I received this  error:\nOutput mesh file name must be specified (with --split-file) when splitting non-file-based meshes\nThen when I added the --split-file flag I received the BAD TERMINATION (segmentation fault) error when it started to write the splitted files.\nCould someone help?",
          "url": "https://github.com/idaholab/moose/discussions/23713",
          "updatedAt": "2023-04-29T03:42:37Z",
          "publishedAt": "2023-03-14T11:38:55Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Does it work with\nmpiexec -n 7 moose-app-opt  --split-mesh 7 -i PT_th1.i --split-file my_split\n\nI m not sure the splitting mesh supports threading\nAlso,\ndoes this installation of MOOSE pass the test suite (run_tests in moose/test)?",
                  "url": "https://github.com/idaholab/moose/discussions/23713#discussioncomment-5308322",
                  "updatedAt": "2023-03-14T14:45:23Z",
                  "publishedAt": "2023-03-14T14:45:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "morsi95"
                  },
                  "bodyText": "I tried --split-file but still didn't work.\nHere is the error log that I receive when I run:\n./run_tests -j --failed-tests\nfailed_tests.txt",
                  "url": "https://github.com/idaholab/moose/discussions/23713#discussioncomment-5332249",
                  "updatedAt": "2023-03-16T10:37:55Z",
                  "publishedAt": "2023-03-16T10:37:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "These diffs are problematic but they also all pertain to some of the more numerically challenging problems so we can let it slide for now.\nI need an error message. Or your mesh so I can try to split it locally",
                          "url": "https://github.com/idaholab/moose/discussions/23713#discussioncomment-5335856",
                          "updatedAt": "2023-03-16T15:26:47Z",
                          "publishedAt": "2023-03-16T15:26:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "morsi95"
                          },
                          "bodyText": "I tried the command on a different moose installation on my local machine but I received the following error:\nSetting Up............\n  Setting Up Undisplaced Mesh\n    Preparing Mesh\n      Updating Mesh...                                                                   [ 20.79 s] [    0 MB]\n    Finished Preparing Mesh                                                              [ 21.37 s] [    0 MB]\n  Finished Setting Up Undisplaced Mesh                                                   [ 21.37 s] [    0 MB]\nSplitting 42 ways...\nStill Setting Up...............    - writing 42 files per process...\n..\n===================================================================================\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 8619 RUNNING AT mo\n=   EXIT CODE: 139\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\n===================================================================================\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions",
                          "url": "https://github.com/idaholab/moose/discussions/23713#discussioncomment-5338217",
                          "updatedAt": "2023-03-16T19:38:37Z",
                          "publishedAt": "2023-03-16T19:30:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "How big is the file? How many elements?\nAre you running out of memory by any chance?",
                          "url": "https://github.com/idaholab/moose/discussions/23713#discussioncomment-5339141",
                          "updatedAt": "2023-03-16T21:47:23Z",
                          "publishedAt": "2023-03-16T21:47:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m still unsure why you are using split mesh btw.\nWhat is the problem with replicated meshes?",
                          "url": "https://github.com/idaholab/moose/discussions/23713#discussioncomment-5339144",
                          "updatedAt": "2023-03-16T21:47:51Z",
                          "publishedAt": "2023-03-16T21:47:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "morsi95"
                          },
                          "bodyText": "My mesh is 9 million elements so in order to optimize the running time on a hpc cluster I need to be able to use distributed mesh. But with --distributed-mesh it looks like the RAM is overloaded so a pre splitting is probably needed.",
                          "url": "https://github.com/idaholab/moose/discussions/23713#discussioncomment-5342787",
                          "updatedAt": "2023-03-17T08:21:21Z",
                          "publishedAt": "2023-03-17T08:21:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok that's the right reason for this.\nWhat is the split going to be?\nI see 42 splits per process, times 7?",
                          "url": "https://github.com/idaholab/moose/discussions/23713#discussioncomment-5347696",
                          "updatedAt": "2023-03-17T16:21:58Z",
                          "publishedAt": "2023-03-17T16:21:58Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiple input files for single sub-app",
          "author": {
            "login": "maxposchmann"
          },
          "bodyText": "Sometimes it is handy to collect common inputs in one input file, then add on some other stuff in another input file. On the command line, I frequently use syntax like\n./moose-opt -i common_input.i additional_input.i\n\nI'd like to be able to use similar syntax to run a sub-app (in particular using stochastic tools with SamplerFullSolveMultiApp), but entering multiple input files in the input_files parameter does something else entirely.\nI thought maybe I could use cli_args to do what I wanted like:\n[MultiApps]\n  [sub]\n    type = SamplerFullSolveMultiApp\n    sampler = sampler\n    input_files = 'common_input.i'\n    cli_args = '-i additional_input.i'\n  []\n[]\n\nHowever, that doesn't get parsed the way I want, and MOOSE complains: The number of items supplied must be 1 or equal to the number of sub apps.\nAm I missing something that will make one of these options work? Is there another option?",
          "url": "https://github.com/idaholab/moose/discussions/23762",
          "updatedAt": "2023-04-29T03:42:49Z",
          "publishedAt": "2023-03-16T18:30:29Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont think we've made that work inside MultiApps. But can you try this? without the -i\n[MultiApps]\n  [sub]\n    type = SamplerFullSolveMultiApp\n    sampler = sampler\n    input_files = 'common_input.i'\n    cli_args = 'additional_input.i'\n  []\n[]\n\nWe'd be interested in the contribution if not\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23762#discussioncomment-5339507",
                  "updatedAt": "2023-03-16T22:51:15Z",
                  "publishedAt": "2023-03-16T22:51:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxposchmann"
                          },
                          "bodyText": "Thanks for the suggestion. When I tried that, I got Number of command line arguments does not match number of sampler columns.",
                          "url": "https://github.com/idaholab/moose/discussions/23762#discussioncomment-5345250",
                          "updatedAt": "2023-03-17T12:12:17Z",
                          "publishedAt": "2023-03-17T12:12:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxposchmann"
                          },
                          "bodyText": "I'm not sure what to suggest as the \"correct\" way to handle this. Maybe input_files could support some sort of grouping (either like {} or separated by ;). This can easily get messy since it is already a vector.\nAnother thought is that a way to achieve equivalent (but not identical) behavior would be to use input file include directives as mentioned in #20125 and #9755. Looking at those threads, it's not clear if that will eventually be implemented or not.",
                          "url": "https://github.com/idaholab/moose/discussions/23762#discussioncomment-5345707",
                          "updatedAt": "2023-03-17T13:03:12Z",
                          "publishedAt": "2023-03-17T13:03:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxposchmann"
                          },
                          "bodyText": "For other readers, in MooseApp.C there is a comment:\nfor now we only permit single input to be set for multiapps",
                          "url": "https://github.com/idaholab/moose/discussions/23762#discussioncomment-5345948",
                          "updatedAt": "2023-03-17T13:27:45Z",
                          "publishedAt": "2023-03-17T13:27:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The logic handling this parameter just needs to be adapted\n    input_files = 'common_input.i'\n\nRight now we consider 1 input per app, but we'd need some sort of vector syntax indeed",
                          "url": "https://github.com/idaholab/moose/discussions/23762#discussioncomment-5347202",
                          "updatedAt": "2023-03-17T15:32:13Z",
                          "publishedAt": "2023-03-17T15:32:12Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to generate a cylinder and gridding?",
          "author": {
            "login": "lipxisi"
          },
          "bodyText": "I want to generate a simple cylinder using mesh generators, but haven't find the specialized generator.\nWhich generator should I use and  what`s the code?\nThanks for your answer!",
          "url": "https://github.com/idaholab/moose/discussions/23773",
          "updatedAt": "2023-03-20T15:32:52Z",
          "publishedAt": "2023-03-17T15:04:00Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou ll want to use this one\nhttps://mooseframework.inl.gov/docs/site/source/meshgenerators/ConcentricCircleMeshGenerator.html\nthen this one\nhttps://mooseframework.inl.gov/docs/site/source/meshgenerators/MeshExtruderGenerator.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23773#discussioncomment-5347175",
                  "updatedAt": "2023-03-17T15:30:18Z",
                  "publishedAt": "2023-03-17T15:30:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}