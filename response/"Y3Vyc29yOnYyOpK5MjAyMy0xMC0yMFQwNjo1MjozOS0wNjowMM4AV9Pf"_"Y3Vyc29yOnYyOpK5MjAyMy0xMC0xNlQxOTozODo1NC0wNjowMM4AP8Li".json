{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMC0xNlQxOTozODo1NC0wNjowMM4AP8Li"
    },
    "edges": [
      {
        "node": {
          "title": "Cohesive zone on edge",
          "author": {
            "login": "sidharthsarmah"
          },
          "bodyText": "Hi @arovinelli  @jiangwen84 ,\nI am trying to implement the CZM for the first time. The problem is a symmetric loading problem, on which I want to add the cohesive nodes (red line), can you suggest if it is possible or do I need to have nodes on both sides?",
          "url": "https://github.com/idaholab/moose/discussions/23955",
          "updatedAt": "2023-11-15T15:57:52Z",
          "publishedAt": "2023-04-04T02:38:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "You need both sides. Current CZM in MOOSE cannot be applied on the symmetric plane.",
                  "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5516302",
                  "updatedAt": "2023-04-04T03:00:51Z",
                  "publishedAt": "2023-04-04T03:00:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi, thanks @jiangwen84,\nI will try to use a new model now then, will get back to you on this, thanks again)",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5516313",
                          "updatedAt": "2023-04-04T03:03:15Z",
                          "publishedAt": "2023-04-04T03:03:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @jiangwen84.\nI want to now implement CZM to this notch problem (say), which has a partition along which the fracture will occur:\n\n\nSo the box represent the area using BoundingBoxNodeSetGenerator, from which the nodes of the cohesive model will be extracted right?\nThen assign it to create a set using BreakMeshByBlockGenerator for the interface for the CZM?\n\n[Mesh]\n\n  [./mesh]\n   type = FileMesh\n   file = notch.inp\n  [../]\n\n  [./block1]\n    type = BoundingBoxNodeSetGenerator\n    input = 'mesh'\n    bottom_left = '0 0'\n    top_right = '1 1'\n  [../]\n\n  [./split]\n    type = BreakMeshByBlockGenerator\n    input = block1\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5516573",
                          "updatedAt": "2023-04-04T03:59:36Z",
                          "publishedAt": "2023-04-04T03:59:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no BreakMeshByBlockGenerator will tear the mesh apart along blocks.\nYou need BreakBoundaryOnSubdomainGenerator",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5520368",
                          "updatedAt": "2023-04-04T12:12:19Z",
                          "publishedAt": "2023-04-04T12:12:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud , thanks as always)\nIs it correct?\n[Mesh]\n  \n  [./mesh]\n    type = FileMesh\n    file =Part.inp\n  [../]\n\n  [./block1]\n    type = SubdomainBoundingBoxGenerator\n    input = 'mesh'\n    bottom_left = '-0.001, -0.001'\n    top_right = '0.001, 6.5'\n  [../]\n\n  [./block2]\n    input = 'block1'\n    type = BreakBoundaryOnSubdomainGenerator\n  [../]  \n\n  [./split]\n    type = BreakMeshByBlockGenerator\n    input = block2\n  [../]\n  \n[]",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5522827",
                          "updatedAt": "2023-04-04T15:49:15Z",
                          "publishedAt": "2023-04-04T15:49:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what are you trying to do? create a new sideset or split the mesh? You have both here",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5522867",
                          "updatedAt": "2023-04-04T15:53:31Z",
                          "publishedAt": "2023-04-04T15:53:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "I want to implement the cohesive model along the partition line, I went through some examples which state the steps:\n\nDefine the nodes on which the CZM will be impleemnted\nDefine CZM object\nDefine the Material Model of a type.\n\nGoing in line, the first steps needs me to define the nodes right?",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5522902",
                          "updatedAt": "2023-04-04T15:57:15Z",
                          "publishedAt": "2023-04-04T15:56:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok that would be making the sideset then.\nAre you going to delete block 1?\nOr are you trying to split it in two and have the crack at the center?",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5522918",
                          "updatedAt": "2023-04-04T15:58:11Z",
                          "publishedAt": "2023-04-04T15:58:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Split into two and have the crack at the center",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5522950",
                          "updatedAt": "2023-04-04T16:02:00Z",
                          "publishedAt": "2023-04-04T16:01:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok then make block 1 the left, block 2 the right, the use BreakMeshByBlockGenerator with the optional parameters (block_pair)",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5522966",
                          "updatedAt": "2023-04-04T16:03:34Z",
                          "publishedAt": "2023-04-04T16:03:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "[Mesh]\n  \n  [./mesh]\n    type = FileMesh\n    file =Part.inp\n  [../]\n\n  [./block1]\n    type = SubdomainBoundingBoxGenerator\n    input = 'mesh'\n    bottom_left = '-0.001, -0.001'\n    top_right = '0.001, 6.5'\n  [../]\n\n  [./split]\n    type = BreakMeshByBlockGenerator\n  [../]\n  \n[]\n\nDoes this work?",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5523033",
                          "updatedAt": "2023-04-04T16:10:07Z",
                          "publishedAt": "2023-04-04T16:10:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sidharthsarmah"
                  },
                  "bodyText": "Hi @GiudGiud, I updated using these two steps:\n1.\nmamba update --all\n\n\n\n\nexport MOOSE_JOBS=4 METHODS=opt\ncd ~/projects/moose\n./scripts/update_and_rebuild_libmesh.sh\n\nThen compile METHOD=oprof make -j 4 to obtain error:\nlibtool:   error: '/Users/sidharthsarmah/MOOSE/projects/moose/scripts/../libmesh/installed/lib/libmesh_oprof.la' is not a valid libtool archive\nmake: *** [/Users/sidharthsarmah/MOOSE/projects/moose/framework/moose.mk:368: /Users/sidharthsarmah/MOOSE/projects/moose/framework/libmoose-oprof.la] Error 1\nmake: *** Waiting for unfinished jobs....",
                  "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5667547",
                  "updatedAt": "2023-04-20T00:05:28Z",
                  "publishedAt": "2023-04-20T00:00:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "why are you running\n./scripts/update_and_rebuild_libmesh.sh\nif you are installing libmesh with mamba?\nalso why are you still using a profilng build? i thought we had cleared that performance issue",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5667642",
                          "updatedAt": "2023-04-20T00:14:11Z",
                          "publishedAt": "2023-04-20T00:14:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud ,\nDon't we need to update both as you mentioned.\nI used:\nmamba activate moose\nexport METHOD=opt METHODS=opt MOOSE_JOBS=4\ncd ~/moose/projects/moose\n./scripts/update_and_rebuild_petsc.sh --CFLAGS=-fno-omit-frame-pointer --CXX_CXXFLAGS=-fno-omit-frame-pointer\n./scripts/update_and_rebuild_libmesh.sh\ncd modules/tensor_mechanics\nMETHOD=opt make -j 4",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5667647",
                          "updatedAt": "2023-11-15T16:05:06Z",
                          "publishedAt": "2023-04-20T00:14:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no you do not need to update libmesh with both mamba and the manual script",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5668470",
                          "updatedAt": "2023-04-20T02:58:35Z",
                          "publishedAt": "2023-04-20T02:58:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does mamba list | grep moose return",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5668485",
                          "updatedAt": "2023-04-20T03:03:36Z",
                          "publishedAt": "2023-04-20T03:03:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud ,\n# packages in environment at /Users/sidharthsarmah/mambaforge3/envs/moose:\nmoose-mpich               4.0.2                   build_7    https://conda.software.inl.gov/public\nmoose-pprof               2022.12.05              build_0    https://conda.software.inl.gov/public\n(moose) sidharthsarmah@Sidharths-MacBook-Air ~ %",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5668509",
                          "updatedAt": "2023-04-20T03:10:21Z",
                          "publishedAt": "2023-04-20T03:10:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok this is good.\nDid this code used to compile?? It s complaining that you are trying to divide two vectors by each other, which you cant do\n_interface_displacement_jump[_qp]/(0.01*_delta_u0)",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5668794",
                          "updatedAt": "2023-04-20T04:11:55Z",
                          "publishedAt": "2023-04-20T04:11:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud, yes this is a new material object that I am trying to make as a CZM model.\nPlease note, here is what goes in:",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5675948",
                          "updatedAt": "2023-11-15T16:04:16Z",
                          "publishedAt": "2023-04-20T16:27:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We use && instead of & in the MOOSE code base btw\n_delta_u0 is a vector (you initialize it with { getParam }\nso you have to either:\n\nuse a for loop to do the division\nindex at the position desired like this _delta_u0[0]",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5676100",
                          "updatedAt": "2023-04-20T16:44:51Z",
                          "publishedAt": "2023-04-20T16:44:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "hi @GiudGiud thanks, is there a way not to declare delta_0 as a vector and just as a variable?",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5676116",
                          "updatedAt": "2023-04-20T16:45:52Z",
                          "publishedAt": "2023-04-20T16:45:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes, modify the header file to make it a Real\nAND\nmodify the initialization to be just _delta_0(getParam...) instead of _delta_0({getParam...})",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5676123",
                          "updatedAt": "2023-04-20T16:46:49Z",
                          "publishedAt": "2023-04-20T16:46:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "arovinelli"
                  },
                  "bodyText": "Hi @sidharthsarmah\n\nI'm not sure it might be both.  Also we don't know which boundary conditions you are using so we can't help. I susggest using a uniaxial displacemnt controlled bc set to jsut porbe the normal traction.\n\nThen:\n\nFirst thing try to use the finite difference preconditioner to check the residual is correct and you can converge.\n\nIf you can convergence and with quadratic convergence then your jacobian is wrong.\n\nIf you cannot converge at all then try loading with a very small time step to avoid going in the second regime where you have the zero Jacobian.\n\nIf you can converge for the first regime but not for the second then it means you have to modify the second regime to have some slope, not a constant traction.\n\nHope this help\n\u2026\n________________________________\nFrom: sidharthsarmah ***@***.***>\nSent: Wednesday, April 26, 2023 5:30:18 PM\nTo: idaholab/moose\nCc: Rovinelli, Andrea; Mention\nSubject: [EXTERNAL] Re: [idaholab/moose] Cohesive zone on edge (Discussion #23955)\n\n\nHi @arovinelli<https://urldefense.com/v3/__https://github.com/arovinelli__;!!Bt8fGhp8LhKGRg!GKtSfymSOrorborrCLrX7ngmP76dUck9xYTphJ0IsXKE1pLDPttw4Gu6B0TXpYdfojRmp8nq-3quw5cBK4AtZwI4_kM$> , I tried to code the CZM as follows:\n\n\n![](https://user-images.githubusercontent.com/110927986/233438367-431a6b79-657e-4d33-aa0c-2b8cf042d406.png<https://urldefense.com/v3/__https://user-images.githubusercontent.com/110927986/233438367-431a6b79-657e-4d33-aa0c-2b8cf042d406.png__;!!Bt8fGhp8LhKGRg!GKtSfymSOrorborrCLrX7ngmP76dUck9xYTphJ0IsXKE1pLDPttw4Gu6B0TXpYdfojRmp8nq-3quw5cBK4AtssEtgBU$>)\n\n\nThere is an issue with the convergence, do you think it is to do with something wrong with the code or what you mentioned about the derivative of the constant?\n\n#include \"ScheiderTraction.h\"\n\nregisterMooseObject(\"TensorMechanicsApp\", ScheiderTraction);\n\nInputParameters\nScheiderTraction::validParams()\n{\n  InputParameters params = CZMComputeLocalTractionTotalBase::validParams();\n  params.addClassDescription(\"Scheider cohesive law\");\n  params.addRequiredParam<Real>(\n      \"normal_gap_at_maximum_normal_traction\",\n      \"The value of normal gap at which maximum normal traction is achieved\");\n  params.addRequiredParam<Real>(\n      \"tangential_gap_at_maximum_shear_traction\",\n      \"The value of tangential gap at which maximum shear traction is achieved\");\n  params.addRequiredParam<Real>(\"maximum_normal_traction\",\n                                \"The maximum normal traction the interface can sustain\");\n  params.addRequiredParam<Real>(\"maximum_shear_traction\",\n                                \"The maximum shear traction the interface can sustain\");\n  return params;\n}\n\nScheiderTraction::ScheiderTraction(const InputParameters & parameters)\n  : CZMComputeLocalTractionTotalBase(parameters),\n    _delta_u0({getParam<Real>(\"normal_gap_at_maximum_normal_traction\"),\n               getParam<Real>(\"tangential_gap_at_maximum_shear_traction\"),\n               getParam<Real>(\"tangential_gap_at_maximum_shear_traction\")}),\n    _max_allowable_traction({getParam<Real>(\"maximum_normal_traction\"),\n                             getParam<Real>(\"maximum_shear_traction\"),\n                             getParam<Real>(\"maximum_shear_traction\")})\n{\n}\n\nvoid\nScheiderTraction::computeInterfaceTractionAndDerivatives()\n{\n  _interface_traction[_qp] = computeTraction();\n  _dinterface_traction_djump[_qp] = computeTractionDerivatives();\n}\n\nRealVectorValue\nScheiderTraction::computeTraction()\n{\n\n  RealVectorValue traction_local;\n\n  Real f, n, T0;\n\n  unsigned int i;\n\n    f = 0;\n    n = 0;\n\n\n  for (i = 0; i < 3; i++)\n  {\n      T0 = _max_allowable_traction(i);\n      n = _interface_displacement_jump[_qp](i)/_delta_u0(i);\n\n        if (n < 0.05)\n        {\n            f = 2 * (_interface_displacement_jump[_qp](i)/(0.05*_delta_u0(i))) - std::pow(_interface_displacement_jump[_qp](i)/(0.05*_delta_u0(i)), 2) ;\n        }\n\n        else if (n >= 0.05 && n <= 0.75)\n            f = 1;\n\n        else if (n > 0.75 && n <= 1.0)\n        {\n            f = 2 * std::pow((_interface_displacement_jump[_qp](i) - 0.75*_delta_u0(i))/(_delta_u0(i) - 0.75*_delta_u0(i)), 3) - 3 * std::pow((_interface_displacement_jump[_qp](i) - 0.75*_delta_u0(i))/(_delta_u0(i) - 0.75*_delta_u0(i)), 2) + 1;\n        }\n\n      traction_local(i) = T0 * f;\n  }\n\n  return traction_local;\n}\n\nRankTwoTensor\nScheiderTraction::computeTractionDerivatives()\n{\n  RankTwoTensor traction_jump_derivatives_local;\n  Real k, n, T0;\n\n    k = 0;\n    n = 0;\n\n  unsigned int i, j;\n\n    for (i = 0; i < 3; i++)\n    {\n        T0 = _max_allowable_traction(i);\n        n = _interface_displacement_jump[_qp](i)/_delta_u0(i);\n\n        for (j = 0; j < 3; j++)\n        {\n            if (i == j)\n            {\n                if (n < 0.05)\n                {\n                    k = 2/(0.05*_delta_u0(j)) - 2*(_interface_displacement_jump[_qp](j)/std::pow(0.05*_delta_u0(j),2));\n                }\n\n                else if (n >= 0.05 && n <= 0.75)\n                    k = 0.0;\n\n                else if (n > 0.75 && n <= 1.0)\n                {\n                    k = 6 * pow(_interface_displacement_jump[_qp](j) - 0.75*_delta_u0(j), 2)/(std::pow(_delta_u0(j) - 0.75*_delta_u0(j), 3)) - 6 * (_interface_displacement_jump[_qp](j) - 0.75*_delta_u0(j))/(std::pow(_delta_u0(j) - 0.75*_delta_u0(j), 2));\n                }\n            }\n            else\n                k = 0;\n\n            traction_jump_derivatives_local(i, j) = k;\n        }\n    }\n\n      return traction_jump_derivatives_local;\n}\n\n\nHi there, I just want to give my two cents.\nFirst I would kindly ask to @sidharthsarmah<https://urldefense.com/v3/__https://github.com/sidharthsarmah__;!!Bt8fGhp8LhKGRg!GKtSfymSOrorborrCLrX7ngmP76dUck9xYTphJ0IsXKE1pLDPttw4Gu6B0TXpYdfojRmp8nq-3quw5cBK4At6oMFafY$> to give a look at this page cohesive zone modeling<https://urldefense.com/v3/__https://mooseframework.inl.gov/syntax/Modules/TensorMechanics/CohesiveZoneMaster/index.html__;!!Bt8fGhp8LhKGRg!GKtSfymSOrorborrCLrX7ngmP76dUck9xYTphJ0IsXKE1pLDPttw4Gu6B0TXpYdfojRmp8nq-3quw5cBK4AtrlC03jc$> which should give you some insights about how to build a cohesive model.\nSecond when you build a traction separation model, you have to implement it always as if it is a 3D model, otherwise the Moose will not converge.\nThis means the local traction will have 3 components T_i, and the traction derivative will have 9 components (dTraction_i/dJump_j)\nIn the equation I only see the normal component of the traction separation low. Hence you can fill only the first component of the traction and the 1,1 component of the derivatives.\nI suggest you start from scratch by modifying the PureElasticTractionSeparation<https://urldefense.com/v3/__https://mooseframework.inl.gov/source/materials/cohesive_zone_model/PureElasticTractionSeparation.html__;!!Bt8fGhp8LhKGRg!GKtSfymSOrorborrCLrX7ngmP76dUck9xYTphJ0IsXKE1pLDPttw4Gu6B0TXpYdfojRmp8nq-3quw5cBK4At-e7WHZs$> traction separation law and modify only the normal component with your equations.\nFurthermore I already foresee a convergence problem with the model you want to implement because in the second regime you have a fixed traction for multiple jump values. I suggest adding a very small slope in that regime\n\nHi @arovinelli<https://urldefense.com/v3/__https://github.com/arovinelli__;!!Bt8fGhp8LhKGRg!GKtSfymSOrorborrCLrX7ngmP76dUck9xYTphJ0IsXKE1pLDPttw4Gu6B0TXpYdfojRmp8nq-3quw5cBK4AtZwI4_kM$> , I tried to code the CZM as follows:\n\n\n![](https://user-images.githubusercontent.com/110927986/233438367-431a6b79-657e-4d33-aa0c-2b8cf042d406.png<https://urldefense.com/v3/__https://user-images.githubusercontent.com/110927986/233438367-431a6b79-657e-4d33-aa0c-2b8cf042d406.png__;!!Bt8fGhp8LhKGRg!GKtSfymSOrorborrCLrX7ngmP76dUck9xYTphJ0IsXKE1pLDPttw4Gu6B0TXpYdfojRmp8nq-3quw5cBK4AtssEtgBU$>)\n\n\nThere is an issue with the convergence, do you think it is to do with something wrong with the code or what you mentioned about the derivative of the constant?\n\n#include \"ScheiderTraction.h\"\n\nregisterMooseObject(\"TensorMechanicsApp\", ScheiderTraction);\n\nInputParameters\nScheiderTraction::validParams()\n{\n  InputParameters params = CZMComputeLocalTractionTotalBase::validParams();\n  params.addClassDescription(\"Scheider cohesive law\");\n  params.addRequiredParam<Real>(\n      \"normal_gap_at_maximum_normal_traction\",\n      \"The value of normal gap at which maximum normal traction is achieved\");\n  params.addRequiredParam<Real>(\n      \"tangential_gap_at_maximum_shear_traction\",\n      \"The value of tangential gap at which maximum shear traction is achieved\");\n  params.addRequiredParam<Real>(\"maximum_normal_traction\",\n                                \"The maximum normal traction the interface can sustain\");\n  params.addRequiredParam<Real>(\"maximum_shear_traction\",\n                                \"The maximum shear traction the interface can sustain\");\n  return params;\n}\n\nScheiderTraction::ScheiderTraction(const InputParameters & parameters)\n  : CZMComputeLocalTractionTotalBase(parameters),\n    _delta_u0({getParam<Real>(\"normal_gap_at_maximum_normal_traction\"),\n               getParam<Real>(\"tangential_gap_at_maximum_shear_traction\"),\n               getParam<Real>(\"tangential_gap_at_maximum_shear_traction\")}),\n    _max_allowable_traction({getParam<Real>(\"maximum_normal_traction\"),\n                             getParam<Real>(\"maximum_shear_traction\"),\n                             getParam<Real>(\"maximum_shear_traction\")})\n{\n}\n\nvoid\nScheiderTraction::computeInterfaceTractionAndDerivatives()\n{\n  _interface_traction[_qp] = computeTraction();\n  _dinterface_traction_djump[_qp] = computeTractionDerivatives();\n}\n\nRealVectorValue\nScheiderTraction::computeTraction()\n{\n\n  RealVectorValue traction_local;\n\n  Real f, n, T0;\n\n  unsigned int i;\n\n    f = 0;\n    n = 0;\n\n\n  for (i = 0; i < 3; i++)\n  {\n      T0 = _max_allowable_traction(i);\n      n = _interface_displacement_jump[_qp](i)/_delta_u0(i);\n\n        if (n < 0.05)\n        {\n            f = 2 * (_interface_displacement_jump[_qp](i)/(0.05*_delta_u0(i))) - std::pow(_interface_displacement_jump[_qp](i)/(0.05*_delta_u0(i)), 2) ;\n        }\n\n        else if (n >= 0.05 && n <= 0.75)\n            f = 1;\n\n        else if (n > 0.75 && n <= 1.0)\n        {\n            f = 2 * std::pow((_interface_displacement_jump[_qp](i) - 0.75*_delta_u0(i))/(_delta_u0(i) - 0.75*_delta_u0(i)), 3) - 3 * std::pow((_interface_displacement_jump[_qp](i) - 0.75*_delta_u0(i))/(_delta_u0(i) - 0.75*_delta_u0(i)), 2) + 1;\n        }\n\n      traction_local(i) = T0 * f;\n  }\n\n  return traction_local;\n}\n\nRankTwoTensor\nScheiderTraction::computeTractionDerivatives()\n{\n  RankTwoTensor traction_jump_derivatives_local;\n  Real k, n, T0;\n\n    k = 0;\n    n = 0;\n\n  unsigned int i, j;\n\n    for (i = 0; i < 3; i++)\n    {\n        T0 = _max_allowable_traction(i);\n        n = _interface_displacement_jump[_qp](i)/_delta_u0(i);\n\n        for (j = 0; j < 3; j++)\n        {\n            if (i == j)\n            {\n                if (n < 0.05)\n                {\n                    k = 2/(0.05*_delta_u0(j)) - 2*(_interface_displacement_jump[_qp](j)/std::pow(0.05*_delta_u0(j),2));\n                }\n\n                else if (n >= 0.05 && n <= 0.75)\n                    k = 0.0;\n\n                else if (n > 0.75 && n <= 1.0)\n                {\n                    k = 6 * pow(_interface_displacement_jump[_qp](j) - 0.75*_delta_u0(j), 2)/(std::pow(_delta_u0(j) - 0.75*_delta_u0(j), 3)) - 6 * (_interface_displacement_jump[_qp](j) - 0.75*_delta_u0(j))/(std::pow(_delta_u0(j) - 0.75*_delta_u0(j), 2));\n                }\n            }\n            else\n                k = 0;\n\n            traction_jump_derivatives_local(i, j) = k;\n        }\n    }\n\n      return traction_jump_derivatives_local;\n}\n\n\n\u2014\nReply to this email directly, view it on GitHub<https://urldefense.com/v3/__https://github.com/idaholab/moose/discussions/23955*discussioncomment-5736854__;Iw!!Bt8fGhp8LhKGRg!GKtSfymSOrorborrCLrX7ngmP76dUck9xYTphJ0IsXKE1pLDPttw4Gu6B0TXpYdfojRmp8nq-3quw5cBK4AtFfCy-i8$>, or unsubscribe<https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/AIIMUUZKBWTYLUW66HLDDCDXDGVYVANCNFSM6AAAAAAWSCXILA__;!!Bt8fGhp8LhKGRg!GKtSfymSOrorborrCLrX7ngmP76dUck9xYTphJ0IsXKE1pLDPttw4Gu6B0TXpYdfojRmp8nq-3quw5cBK4AtDOCCwwU$>.\nYou are receiving this because you were mentioned.Message ID: ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5743290",
                  "updatedAt": "2023-04-27T13:46:57Z",
                  "publishedAt": "2023-04-27T13:46:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @arovinelli @GiudGiud @jiangwen84,\nI tried using a simple tension problem, and it converges, but the cracking thing is something confusing to me:\nBased on the left bottom and top right corners the fracture occur differently (fig 1 and 2), plus one can see a transverse crack in addition to normal which is not desired.\nBreakmyMesh breaks the model into 3 region as indicated in the figures instead of 2 as it should be. Could you please suggest how do I incorporate a break mesh to divide the region along in interface which is the cohesive zone?\n\n  [./czm]\n    type = ScheiderDuctile\n    boundary = 'interface'\n    normal_gap_at_maximum_normal_traction = 1.5\n    tangential_gap_at_maximum_shear_traction = 1.5\n    maximum_normal_traction = 500\n    maximum_shear_traction = 300\n  [../]",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5759879",
                          "updatedAt": "2023-04-29T06:04:03Z",
                          "publishedAt": "2023-04-29T04:16:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nBreakMeah takes additional arguments to limit which blocks it breaks off\nright now you have it in its default configuration that breaks between all blocks\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5761532",
                          "updatedAt": "2023-04-29T12:45:38Z",
                          "publishedAt": "2023-04-29T12:45:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud, thanks. is this correct? please suggest, thanks.\nI form an interface between block 1 and 2 for implementing the CZM indicated by this black box using SubdomainBoundingBoxGenerator, which I think worked.\n\n  [./split]\n    type = BreakMeshByBlockGenerator\n    input = block2\n    block_pairs = '1 2'\n  [../]",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5763652",
                          "updatedAt": "2023-04-29T22:06:11Z",
                          "publishedAt": "2023-04-29T21:19:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m not sure.\nShould the mesh be disjoint for CZM between 2 & 1 ?? Or only between 3 & 1 ?",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5764534",
                          "updatedAt": "2023-04-30T04:07:07Z",
                          "publishedAt": "2023-04-30T04:07:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud , if you look at this its just between block 1 and 2 right, its where the interface should be?\nPS: Those circle represent left bottom and top right cords.\n\n  [./split]\n    type = BreakMeshByBlockGenerator\n    input = block2\n    block_pairs = '1 2'\n  [../]\n  \n[]",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5764562",
                          "updatedAt": "2023-05-02T00:13:09Z",
                          "publishedAt": "2023-04-30T04:19:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@sidharthsarmah\nI'm not sure what you are trying to do.\nIf you are trying to test your implementation of the TSL please use a 2 blocks, 2 elements mesh, same as its done in testing (see a 2 block 2 elemnt input file here PureElasticTractionSeparation)\nIf you already checked your implementation sufficiently and now you want to solve a real problem, that is another story.\nYour mesh with 3 blocks I think is not appropriate. You are most likely hitting one of the corner, but know behavior documented here BreakMeshByBlockGenerator .\nWhich is one of the nodes belongs to all 3 domains, thus you split 1 and 2 but a connection to 3 between all of them remains.",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5771781",
                          "updatedAt": "2023-05-01T13:51:21Z",
                          "publishedAt": "2023-05-01T13:51:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "HI @arovinelli , @GiudGiud, thanks.\nAs of now, I will just try to implement a CZM that look something like this using a simple two block and then check later:\nNow, I am a bit confuse on how to plot it, in ABAQUS as shown, the traction and separation is extracted from the cohesive element (in red rectangle) defined in ABAQUS as an additional layer, while in MOOSE, we do not define such layer, should we look at the element adjacent to the interface shown (in red rectangle). Please suggest, thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5774358",
                          "updatedAt": "2023-05-02T00:12:44Z",
                          "publishedAt": "2023-05-01T18:53:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "In MOOSE, the traction-separation law is defined on the \"interface\" boundary. Most of those properties are defined as material properties, so you should be able to output them to aux variables. Take a look at moose/modules/tensor_mechanics/test/tests/cohesive_zone_model/czm_traction_separation_base.i",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5774930",
                          "updatedAt": "2023-05-01T20:23:54Z",
                          "publishedAt": "2023-05-01T20:23:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "@sidharthsarmah I'm not sure what you are trying to do. If you are trying to test your implementation of the TSL please use a 2 blocks, 2 elements mesh, same as its done in testing (see a 2 block 2 elemnt input file here PureElasticTractionSeparation)\nIf you already checked your implementation sufficiently and now you want to solve a real problem, that is another story. Your mesh with 3 blocks I think is not appropriate. You are most likely hitting one of the corner, but know behavior documented here BreakMeshByBlockGenerator . Which is one of the nodes belongs to all 3 domains, thus you split 1 and 2 but a connection to 3 between all of them remains.\n\nHi @arovinelli, I am still a bit confuse with the way I can implement the CZM in a real problem.\nCan I just divide my region into 2 blocks (dashed lines with dots) encompassing it as follows? Please suggest.",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5785991",
                          "updatedAt": "2023-11-15T15:58:55Z",
                          "publishedAt": "2023-05-02T23:11:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@sidharthsarmah\nLooks good to me, it should work",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-5791420",
                          "updatedAt": "2023-05-03T13:29:14Z",
                          "publishedAt": "2023-05-03T13:29:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sidharthsarmah"
                  },
                  "bodyText": "@sidharthsarmah you last plot (T vs time) is showing an almost vertical traction variation, thus it make sense you see a jump in the Traction vs separation plot. You should have 4 branches in your TSL: 1 loading, -inf<d<d0 2 flat response d0<d<d1, 3 damage accumulation (descending branch) d1<d<d2, 4 very small residual traction (the one I suggested before) d2<d<inf,\nyour plot (separation vs time) suggests that damage accumulation is very fast i.e. d1 is too close to d2. you might try to increase d2 while keeping d1 fixed, in this way damage accumulation will be slower and should not see such an abrupt failure.\nHope this help",
                  "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7171068",
                  "updatedAt": "2023-10-03T02:46:59Z",
                  "publishedAt": "2023-10-03T02:46:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @arovinelli @GiudGiud  , I need your help in this.\nSir, I am a bit confused on why I cannot obtain the full curve,\n.\nI tried to make d2 = 0.5d0 from 0.75d0, so to obtain a longer time for the decreasing curve, but still gradient at that point shoots up, is there any way to obtain the full curve?\nCan you help me with the timestep? There is convergence issue from end_time = 252002",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7171075",
                          "updatedAt": "2023-11-15T15:58:11Z",
                          "publishedAt": "2023-10-03T02:47:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@sidharthsarmah With all we said I think we need to take a step back on figure out what's going on.\nFirst question, is your TSL defined between normal and tangential jumps of -infinity to +inifinty. If not this is a problem for sure",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7176902",
                          "updatedAt": "2023-10-03T15:01:31Z",
                          "publishedAt": "2023-10-03T14:58:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Let's try to be more specific in addressing @arovinelli 's question.",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7177879",
                          "updatedAt": "2023-10-03T16:30:52Z",
                          "publishedAt": "2023-10-03T16:30:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud , @arovinelli: here is the condition where I have defined it from - to + infinity:\n- infinity to d0:\n        if (_interface_displacement_jump[_qp](i) < 0.01*_delta_u0(i))\n...      \n        else if (_interface_displacement_jump[_qp](i) >= 0.5*_delta_u0(i) && _interface_displacement_jump[_qp](i) <= 1*_delta_u0(i))\n...    \n\nd0 to +infinity:\n        else            \n        {\n            traction_local(i) = 0.0000001*_interface_displacement_jump[_qp](i);\n        }",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7177921",
                          "updatedAt": "2023-10-03T16:35:34Z",
                          "publishedAt": "2023-10-03T16:35:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@sidharthsarmah the conditions seems right but there must be some inconsistency somewhere in the formulation.\nI used to be able to run this kind of problems.\ncan you put your code on a branch on git. That would help a lot in trying helping you and understanding what's going on",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7186951",
                          "updatedAt": "2023-10-04T13:15:10Z",
                          "publishedAt": "2023-10-04T13:15:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@sidharthsarmah\nOne problem that you have for sure is the definition of the shear traction.\nPhysically the shear traction should be symmetric, it shouldn't matter if you are sliding left or right. Instead in your formulation they experience softening for positive shear jumps and non softening for negative shear jumps. This also explains why your simple case work while the complex one does not.\nMy suggestion is the following:\nfor now assume the shear traction are just elastic. i.e Ts_i = DeltaU_i * G_i (G is the shear modulus) we will add damage later.\nhence if you should have if i == 0 (normal direction) then ScheiderTraction\nif i > 0 shear, Ts_i = DeltaU_i *G_i\ntry this change and report back.",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7187827",
                          "updatedAt": "2023-10-04T14:28:53Z",
                          "publishedAt": "2023-10-04T14:23:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @arovinelli , I just made correction to the traction part (I==0 conditions), not derivative traction part:\nBut Ts_i = DeltaU_i *G_i, units mismatch here (MPa = MPa * mm)\nI can try: Ts_i = |DeltaU_i /Delta^0_i|*T^0_i, and corresponding derivate changes.",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7188012",
                          "updatedAt": "2023-10-04T15:36:41Z",
                          "publishedAt": "2023-10-04T14:40:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@sidharthsarmah please do not post code here, it clutter the post without providing any better insight than git.\njust update your git branch and tell us when you did it.\nSure, instead of G used a normalized G0: G/delta0 with delta0 =1mm ... it doesn't really matter for testing purposes as long as you get something comparable to the normal traction.\nAlso you must update the jacobian routine.",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7188188",
                          "updatedAt": "2023-10-04T15:03:16Z",
                          "publishedAt": "2023-10-04T14:55:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "arovinelli"
                  },
                  "bodyText": "Hi @sidharthsarmah\n\nHi @arovinelli , here it is:\n1. For the shear component to be symmetric, does `delta_i` need to be with `abs()`. I have used: Ts_(i!=0) = 72656 * d(I!=0), is this is correct, please check.\n   [ce3c2bf](https://github.com/idaholab/moose/commit/ce3c2bfef3754d36236658494b6b60464f264ffc)\n\n\nNo it does not, actually the value should positive for positive shear jumps and negative for negative jumps.\nHowever, when I say symmetric I mean the shear traction separation law needs to produce equal and opposite values for plus an minus jumps (see Figure 1 this paper )\n\n2. Say my maximum normal traction is 1400, does the shear traction needs have similar values? \n\n\nsay you 1400 MPA at 0.1 delta_n then shear you can do 1400/3 at 0.1delta_si\n\ncan't I just the same TSL with abs() in the displacements?\nTechnically you can use the absolute,  but we want to check everything works with simpler formulation where the chance of mistakes is null.\n\nMy suggestion is to keep the shear traction linear for now and once the normal traction works for the complex case. We will add back what you need for the shear component.",
                  "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7199888",
                  "updatedAt": "2023-10-05T15:18:14Z",
                  "publishedAt": "2023-10-05T15:18:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "I think you posted the wrong code, I can't find a switch/if for the normal vs shear traction calculation, i.e. i==0 and i>0",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7234060",
                          "updatedAt": "2023-10-09T20:08:58Z",
                          "publishedAt": "2023-10-09T20:08:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "arovinelli"
                  },
                  "bodyText": "Hi @arovinelli @GiudGiud , considering the symmetry problem that arises with the shear traction, I tried incorporating a new traction law, could you please check if it correct. next...sidharthsarmah:moose:patch-3\n\n\n\nwant to note based on the previous TSL that I was using:\n1. If you look at\n\n\n\n\ns it is increasing a\n\n\n\nHi @arovinelli , there are two things I want to note based on the previous TSL that I was using:\n1. If you look at the end tail of the separation and traction, it shows a separation increase and then decreases, which should never lead to T=0, as it is increasing again (sketch a rough idea).\n\n\nThis might be an indication the problem you are trying to solve it's bad posed, because the interface can self heal. This behavior is the result of a memory-less TSL and so unloading reduce damage, while this should not happen (your damage should always increase or be equal to the accumulated damage it should never decrease.\nThe solution to this problem is to use a rate formulation (see ComputeLocalTractionIncrementalBase in moose). Also see as an example a damage dependent TSL  EQ. 11.16, 11.17, and figure 11.12(unload path should be different from loading path) here\nalso look at section 11.5 as it has some nice mix mode example (which are the one one you should prefer implementing in a FE setting)\n\n\nDoes this can because of the BCs, or some behavior which the material is showing on increase deformation, or because of the unsymmetrical shear traction you mentioned?\n2. The complex problem which I am solving have just a mode 1 opening, with no shearing to occur, so why the shear traction part is important in MOOSE code?\n\n\nNumerically it will never be just opening, there will be numeric noise requiring you to add proper TSL for a 3D case\n\n\nThanks.\n\nHope this helps",
                  "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7234232",
                  "updatedAt": "2023-10-09T20:35:22Z",
                  "publishedAt": "2023-10-09T20:35:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud , can you help me understand this:\nI tried to refine the mesh beneath the area where load is being applied, but now I have having huge convergence issue, why does it occur? Is mesh so much dependent on the problem?",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7254735",
                          "updatedAt": "2023-10-11T16:19:42Z",
                          "publishedAt": "2023-10-11T16:19:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The mesh looks fine but it also looks less regular.\nI would restart from a cartesian-like mesh. This geometry is very regular, it does not need to be so unstructured\nThen the refined version will look a lot better",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7254763",
                          "updatedAt": "2023-10-11T16:31:40Z",
                          "publishedAt": "2023-10-11T16:22:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud , I tried using just structured mesh just to check if the CZM works, but it is showing me convergence issue again, do you think the mesh is the reason, it could be for not being able to get a full TSL?",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7256411",
                          "updatedAt": "2023-10-11T19:45:00Z",
                          "publishedAt": "2023-10-11T19:45:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not sure but the mesh does look better.\nWhat s the convergence log looking like?",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7256656",
                          "updatedAt": "2023-10-11T20:19:15Z",
                          "publishedAt": "2023-10-11T20:19:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The error message is explicit. They dont exist in the mesh with the type wanted.\nDo you have a nodeset or a side set for top_left and top_right?",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7297053",
                          "updatedAt": "2023-10-16T20:25:18Z",
                          "publishedAt": "2023-10-16T20:25:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud , my top parts are the nodes on either side of the element:\n*Nset, nset=top_left, instance=Part-1-1\n5, 14094\n*Nset, nset=top_right, instance=Part-1-1\n12, 13077",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7297141",
                          "updatedAt": "2023-10-16T21:13:28Z",
                          "publishedAt": "2023-10-16T20:37:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "That object wants a sideset not a nodeset. You ll need to have 2 nodes to form a side",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7297178",
                          "updatedAt": "2023-10-16T20:42:54Z",
                          "publishedAt": "2023-10-16T20:42:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you need to trigger a conversion to a sideset then\nyou can use this\nhttps://mooseframework.inl.gov/source/meshgenerators/SideSetsFromNodeSetsGenerator.html",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7297282",
                          "updatedAt": "2023-10-16T20:54:15Z",
                          "publishedAt": "2023-10-16T20:54:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sidharthsarmah"
                  },
                  "bodyText": "Hi @GiudGiud thanks but if I do a   construct_side_list_from_node_list = true or SideSetsFromNodeSetsGenerator , it still shows me the same error;\n*** ERROR ***\n/Users/sidharthsarmah/MOOSE/projects/moose/modules/tensor_mechanics/CZM/N5/pressure.i:141: (BCs/top_load/boundary):\n    the following side sets (ids) do not exist on the mesh: top_left (2), top_right (3)\n    \n    MOOSE distinguishes between \"node sets\" and \"side sets\" depending on whether \n    you are using \"Nodal\" or \"Integrated\" BCs respectively. Node sets corresponding \n    to your side sets are constructed for you by default.\n    \n    Try setting \"Mesh/construct_side_list_from_node_list=true\" if you see this error.\n    Note: If you are running with adaptivity you should prefer using side sets.\n\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\n(moose) sidharthsarmah@Sidharths-MacBook-Air tensor_mechanics %",
                  "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7297302",
                  "updatedAt": "2023-10-16T21:13:44Z",
                  "publishedAt": "2023-10-16T20:56:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "are the nodes actually at the location you show then?\nThe sideset is not created if the nodes are further away.\nYou can always recreate this 1 face sideset using a ParsedGenerateSideset",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7297382",
                          "updatedAt": "2023-10-16T21:07:56Z",
                          "publishedAt": "2023-10-16T21:07:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This seems fine but it s not recognizing them\nIf you open the exodus file you similarly dont see the sidesets?\nI would just re-create the sidesets with ParsedGenerateSideset and keep going",
                          "url": "https://github.com/idaholab/moose/discussions/23955#discussioncomment-7298696",
                          "updatedAt": "2023-10-17T01:28:17Z",
                          "publishedAt": "2023-10-17T01:28:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mesh refinement",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "All,\nI know \"uniform_refine\" refines a mesh in both horizonal and vertical directions in the 2D mesh but I would like to refine a mesh in the only vertical direction.\nPlease let me know if this is possible on MOOSE.\nS. Thomas",
          "url": "https://github.com/idaholab/moose/discussions/25774",
          "updatedAt": "2023-10-19T13:57:27Z",
          "publishedAt": "2023-10-18T23:58:41Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNot possible afaik.\nYou ll have to bias your mesh in one direction when you generate it if you want to get this non-uniformity\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25774#discussioncomment-7320956",
                  "updatedAt": "2023-10-19T00:13:10Z",
                  "publishedAt": "2023-10-19T00:13:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you, Guillaume",
                          "url": "https://github.com/idaholab/moose/discussions/25774#discussioncomment-7320974",
                          "updatedAt": "2023-10-19T00:17:44Z",
                          "publishedAt": "2023-10-19T00:17:43Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Anisotropic refinement has been a wish list item for @roystgnr for a long time in libMesh. Just hasn\u2019t happened yet!",
                          "url": "https://github.com/idaholab/moose/discussions/25774#discussioncomment-7321696",
                          "updatedAt": "2023-10-19T02:44:09Z",
                          "publishedAt": "2023-10-19T02:44:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Worse: this isn't one of the \"hasn't happened yet because I haven't gotten around to it\" wishlist items, this is a \"hasn't happened yet because the very concept would break other library code's assumptions in a hundred places\" wishlist item.  (Not hyperbole - I counted 100+ trouble spots when first looking into this long ago, and I'm sure it's gone up since.)\nIf someone held a gun to my head and demanded anisotropic adaptive refinement next month, I'd start working on metric-tensor-based triangle/tet mesh regeneration, I wouldn't even bother trying to anisotropic get quad/hex division working.  I've run simulations on loads of very anisotropic meshes for flows with thin boundary layers, but the way to get them is via the initial mesh generation, I'm afraid.",
                          "url": "https://github.com/idaholab/moose/discussions/25774#discussioncomment-7328649",
                          "updatedAt": "2023-10-19T13:57:28Z",
                          "publishedAt": "2023-10-19T13:57:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issues with Jacobian incorporating second time derivative",
          "author": {
            "login": "NateAM"
          },
          "bodyText": "I have a kernel where the residual is defined as\nReal linearMomentumInertia::computeQpResidual( ){\n\n    Real result = 0;\n\n    assembleRequiredTerms( );\n\n    result -= _test[ _i ][ _qp ] * ( _density_dot[ _qp ] * _velocity[ _index ] + _density[ _qp ] * _acceleration[ _index ] );\n\n    return result;\n\n}\n\nwhere\nvoid linearMomentumInertia::assembleRequiredTerms( ){\n    /*!\n     * Assemble the required terms for computation of the residual and Jacobians\n     */\n\n    if ( _is_displacement ){\n\n        _velocity[ 0 ] = _v1_dot[ _qp ];\n        _velocity[ 1 ] = _v2_dot[ _qp ];\n        _velocity[ 2 ] = _v3_dot[ _qp ];\n\n        _velocity_factors[ 0 ] = _dv1_dot_dv1[ _qp ];\n        _velocity_factors[ 1 ] = _dv2_dot_dv2[ _qp ];\n        _velocity_factors[ 2 ] = _dv3_dot_dv3[ _qp ];\n\n        _acceleration[ 0 ] = _v1_dotdot[ _qp ];\n        _acceleration[ 1 ] = _v2_dotdot[ _qp ];\n        _acceleration[ 2 ] = _v3_dotdot[ _qp ];\n\n        _acceleration_factors[ 0 ] = _dv1_dotdot_dv1[ _qp ];\n        _acceleration_factors[ 1 ] = _dv2_dotdot_dv2[ _qp ];\n        _acceleration_factors[ 2 ] = _dv3_dotdot_dv3[ _qp ];\n\n    }\n    else{\n\n        _velocity[ 0 ] = _v1[ _qp ];\n        _velocity[ 1 ] = _v2[ _qp ];\n        _velocity[ 2 ] = _v3[ _qp ];\n\n        _velocity_factors[ 0 ] = 1;\n        _velocity_factors[ 1 ] = 1;\n        _velocity_factors[ 2 ] = 1;\n\n        _acceleration[ 0 ] = _v1_dot[ _qp ];\n        _acceleration[ 1 ] = _v2_dot[ _qp ];\n        _acceleration[ 2 ] = _v3_dot[ _qp ];\n\n        _acceleration_factors[ 0 ] = _dv1_dot_dv1[ _qp ];\n        _acceleration_factors[ 1 ] = _dv2_dot_dv2[ _qp ];\n        _acceleration_factors[ 2 ] = _dv3_dot_dv3[ _qp ];\n\n    }\n\n}\n\nand I define the jacobians via\nReal linearMomentumInertia::computeQpJacobian( ){\n\n    // Add the velocity terms\n    Real result = 0;\n\n    assembleRequiredTerms( );\n\n    result -= _test[ _i ][ _qp ] * ( _density_dot[ _qp ] * _velocity_factors[ _index ] + _density[ _qp ] * _acceleration_factors[ _index ] ) * _phi[ _j ][ _qp ];\n\n    return result + computeQpOffDiagJacobian( _var.number( ) );\n\n}\n\nReal linearMomentumInertia::computeQpOffDiagJacobian( unsigned int jvar ){\n\n    Real result = 0;\n\n    assembleRequiredTerms( );\n\n    // Add the Jacobians w.r.t. the density\n    if ( _density_ind == jvar ){\n\n        result -= _test[ _i ][ _qp ] * ( _ddensity_dot_ddensity[ _qp ] * _velocity[ _index ] + _acceleration[ _index ] ) * _phi[ _j ][ _qp ];\n\n    }\n\n    if ( _use_displaced_mesh ){\n\n        // Add the Jacobians w.r.t. the mesh displacement\n        if ( ( _displacements.size( ) > 0 ) && ( jvar == _displacements[ 0 ] ) ){\n\n            result += computeQpResidual( ) * _grad_phi[ _j ][ _qp ]( 0 );\n\n        }\n\n        else if ( ( _displacements.size( ) > 1 ) && ( jvar == _displacements[ 1 ] ) ){\n\n            result += computeQpResidual( ) * _grad_phi[ _j ][ _qp ]( 1 );\n\n        }\n\n        else if ( ( _displacements.size( ) > 2 ) && ( jvar == _displacements[ 2 ] ) ){\n\n            result += computeQpResidual( ) * _grad_phi[ _j ][ _qp ]( 2 );\n\n        }\n\n    }\n\n    return result;\n\n}\n\nI am getting access to coupledDotDot by requring the use of the Newmark Beta timestepper rather than using setUDotDotRequested locally because I was having trouble getting the answer in #25300 to work.\nIf I hard code _acceleration so that it is a constant, and set the _dv1_dot_dv1, _dv2_dot_dv2, and _dv3_dot_dv3 terms to zero and run with use_displaced_mesh = true, a 1D run with the PETSc options -snes_test_jacobian -snes_test_jacobian_view shows no issue with the Jacobian. If I run with the accelerations turned on but with use_displaced_mesh = false then I get a similarly good Jacobian. However, if I use the solved for acceleration and use the displaced mesh, I get noticeable errors (relative error of order 7e-7) in the Jacobian.\nIs there something obviously wrong with my Jacobian? If PETSc is only using forward difference can I force it to use central differences for a higher quality check of the Jacobian?",
          "url": "https://github.com/idaholab/moose/discussions/25768",
          "updatedAt": "2023-10-19T02:09:29Z",
          "publishedAt": "2023-10-18T16:20:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I would not call 7e-7 significant error. Have you tried comparing nonlinear iteration counts with solve_type = NEWTON vs. solve_type = PJFNK? I would only really be concerned about the Jacobian quality if you're seeing more nonlinear iterations with NEWTON than with PJFNK",
                  "url": "https://github.com/idaholab/moose/discussions/25768#discussioncomment-7317923",
                  "updatedAt": "2023-10-18T17:02:47Z",
                  "publishedAt": "2023-10-18T17:02:35Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "NateAM"
                          },
                          "bodyText": "I would not call 7e-7 significant error.\n\nOkay, that's good to know! I had seen some comments about relative magnitudes greater than 1e-7 being an issue\n\nHave you tried comparing nonlinear iteration counts with solve_type = NEWTON vs. solve_type = PJFNK? I would only really be concerned about the Jacobian quality if you're seeing more nonlinear iterations with NEWTON than with PJFNK\n\nI have looked at that NEWTON with a LU preconditioner seems to be really good so I think I was probably making a mountain out of a molehill.",
                          "url": "https://github.com/idaholab/moose/discussions/25768#discussioncomment-7318441",
                          "updatedAt": "2023-10-18T17:45:13Z",
                          "publishedAt": "2023-10-18T17:45:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I'm usually pretty happy up into the 1e-6 to 1e-5 range. If you have a \"noisy\" residual, then sometimes you can get better matching with PETSc if you pass the -snes_test_err option which controls the finite difference size. The default is ~1e-8. Sometimes I get better with tighter (e.g. -snes_test_err 1e-9), sometimes with looser (e.g. -snes_test_err 1e-6)",
                          "url": "https://github.com/idaholab/moose/discussions/25768#discussioncomment-7318865",
                          "updatedAt": "2023-10-18T18:31:27Z",
                          "publishedAt": "2023-10-18T18:31:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Debug print in AppFactory.h",
          "author": {
            "login": "joe61vette"
          },
          "bodyText": "Hello:\nThis one should be very simple.  I am tracking down a segfault caused when building an AuxKernel.  It would help if I could print out some of the parameters.  But, if I use \"Moose::out << ...\", I get the following error message:\nIn file included from /Users/joe/projects/SAM/moose/modules/fluid_properties/src/base/FluidPropertiesApp.C:12:\n/Users/joe/projects/SAM/moose/framework/build/header_symlinks/AppFactory.h:42:10: error: no type named 'out' in namespace 'Moose'\nMoose::out << \"AppFactoryBuildInfoBase\" << std::endl;\nThis is a first.  So, I tried \"std::out << ....\" and included \nThe compile error is:\nIn file included from /Users/joe/projects/SAM/moose/modules/fluid_properties/src/base/FluidPropertiesApp.C:12:\n/Users/joe/projects/SAM/moose/framework/build/header_symlinks/AppFactory.h:42:8: error: no type named 'cout' in namespace 'std'\nstd::cout << \"AppFactoryBuildInfoBase\" << std::endl;\n\nHow can I put a debug print statement inside this template:\n\ntemplate <typename T>\nstruct AppFactoryBuildInfo : public AppFactoryBuildInfoBase\n{\nstd::cout << \"AppFactoryBuildInfoBase\" << std::endl;\nvirtual MooseAppPtr build(const InputParameters & params) override\n{\n  return std::make_shared<T>(params);\n}\nvirtual InputParameters buildParameters() override { return T::validParams(); }\n};\n\nThanks,\nJoe Kelly",
          "url": "https://github.com/idaholab/moose/discussions/25767",
          "updatedAt": "2023-10-18T16:03:32Z",
          "publishedAt": "2023-10-18T15:49:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hi Joe\ncan you do this\ntemplate <typename T>\nstruct AppFactoryBuildInfo : public AppFactoryBuildInfoBase\n{\nvirtual MooseAppPtr build(const InputParameters & params) override\n{\n  std::cout << \"AppFactoryBuildInfoBase\" << std::endl;\n  return std::make_shared<T>(params);\n}\n\nwe cant put a print statement inside the definition for the template, it s a place for declaring code not executing it",
                  "url": "https://github.com/idaholab/moose/discussions/25767#discussioncomment-7317212",
                  "updatedAt": "2023-10-18T15:53:33Z",
                  "publishedAt": "2023-10-18T15:53:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Thanks Guillaume.  When I put it inside the {}, Moose::out works.  THANKS!",
                          "url": "https://github.com/idaholab/moose/discussions/25767#discussioncomment-7317319",
                          "updatedAt": "2023-10-18T16:03:31Z",
                          "publishedAt": "2023-10-18T16:03:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The difference of ADShaftConnectedPump1PhaseUserObject and ADPump1PhaseUserObject",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nI understand the process and target of ADShaftConnectedPump1PhaseUserObject and ADPump1PhaseUserObject, but I'm really confused about the momentum and energy residual terms in computeFluxesAndResiduals function:\n\nwhy do the momentum and energy source residual terms in ADPump1PhaseUserObject need to multiply 0.5 but these terms in ADShaftConnectedPump1PhaseUserObject don't?\nwhy the energy source term in  ADShaftConnectedPump1PhaseUserObject does not include the pump head term, just like in ADPump1PhaseUserObject?\n\nIn ADPump1PhaseUserObject:\n\nIn ADShaftConnectedPump1PhaseUserObject\n\nCould anyone kindly tell me?\nThank you very much!",
          "url": "https://github.com/idaholab/moose/discussions/25750",
          "updatedAt": "2023-10-18T14:11:20Z",
          "publishedAt": "2023-10-16T13:58:46Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@joshuahansel @licharlot",
                  "url": "https://github.com/idaholab/moose/discussions/25750#discussioncomment-7297541",
                  "updatedAt": "2023-10-16T21:34:41Z",
                  "publishedAt": "2023-10-16T21:34:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "Hi,\n\nThe shaft-connected one is enclosed in an if (c == 0) block, so it only gets added for the first connection, so this is the same as adding that term twice with the 0.5 factor in the other UO. Confusing.\nThe shaft-connected pump is just having an entirely different formulation for the energy term because it has all of the information from the pump curves. The other pump just makes a very generic approximation of this term because it doesn't have anything else. The former is preferred if you have the curves.",
                  "url": "https://github.com/idaholab/moose/discussions/25750#discussioncomment-7297773",
                  "updatedAt": "2023-10-16T22:18:30Z",
                  "publishedAt": "2023-10-16T22:18:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "I got it. Thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/25750#discussioncomment-7300418",
                          "updatedAt": "2023-10-17T06:48:20Z",
                          "publishedAt": "2023-10-17T06:48:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "By the way, can you show me the figures of head and torque data used in the shaft_connected_pump_1phase teat file? I can not find the data figure in the offering references:\nSemiscale Program, summarized in NUREG/CR-4945.\nLOFT Systems Tests, described in NUREG/CR-0247.",
                          "url": "https://github.com/idaholab/moose/discussions/25750#discussioncomment-7300495",
                          "updatedAt": "2023-10-17T06:59:22Z",
                          "publishedAt": "2023-10-17T06:59:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "@licharlot do you know where they might have come from? If not in the references, then I don't know.",
                          "url": "https://github.com/idaholab/moose/discussions/25750#discussioncomment-7303234",
                          "updatedAt": "2023-10-17T11:59:30Z",
                          "publishedAt": "2023-10-17T11:59:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "licharlot"
                          },
                          "bodyText": "The conventional homologous curves are in the references,  page 177 of https://www.osti.gov/servlets/purl/6302855 (NUREG/CR-4945) and page 161 of https://www.nrc.gov/docs/ML0702/ML070250396.pdf (NUREG/CR-0247).\nThey must have been used as a basis to develop the polar homologous curves that are used by this component. The process is described in the component documentation.",
                          "url": "https://github.com/idaholab/moose/discussions/25750#discussioncomment-7306923",
                          "updatedAt": "2023-10-17T17:53:49Z",
                          "publishedAt": "2023-10-17T17:53:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thank you very much!!",
                          "url": "https://github.com/idaholab/moose/discussions/25750#discussioncomment-7307299",
                          "updatedAt": "2023-10-17T18:37:33Z",
                          "publishedAt": "2023-10-17T18:37:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Hi @joshuahansel and @licharlot,\nI still have a question: why does the homologous_torque need to multiply -1, which is different from the description in component documentation?\ndocumentation:\n\n\ncode:",
                          "url": "https://github.com/idaholab/moose/discussions/25750#discussioncomment-7315595",
                          "updatedAt": "2023-10-18T13:47:37Z",
                          "publishedAt": "2023-10-18T13:47:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "licharlot"
                          },
                          "bodyText": "This is simply a convention. The hydraulic torque if later on multiplied by -1 to be used as a source in the energy equation, and is negative to be applied on the shaft speed equation.",
                          "url": "https://github.com/idaholab/moose/discussions/25750#discussioncomment-7315814",
                          "updatedAt": "2023-10-18T14:07:42Z",
                          "publishedAt": "2023-10-18T14:07:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "I understand. Thank you\uff01",
                          "url": "https://github.com/idaholab/moose/discussions/25750#discussioncomment-7315856",
                          "updatedAt": "2023-10-18T14:11:21Z",
                          "publishedAt": "2023-10-18T14:11:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Configuration for VSCode with MOOSE",
          "author": {
            "login": "bielsnohr"
          },
          "bodyText": "Does anyone have experience using VSCode to develop MOOSE apps? I have been using Vim with YouCompleteMe to provide autocompletion via a compile_commands.json file, which is in turn created by a program compiledb. Too many links in the chain, and it falls down too often. The big problem is that compiledb does something strange with the makefile and touches file timestamps such that anytime I compile, is does a complete compilation of the whole MOOSE framework... time consuming to say the least.\nSo, I have been looking at moving to VSCode in the hopes that it would handle this sort of thing better, but it is not obvious how to get it set up with GNU Make projects. There is an extension called \"Makefile Tools\" but it is in preview (i.e. some sort of post beta) and hasn't worked out of the box for me. Suggestions?",
          "url": "https://github.com/idaholab/moose/discussions/18307",
          "updatedAt": "2023-10-18T11:43:47Z",
          "publishedAt": "2021-07-12T15:26:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ajacquey"
                  },
                  "bodyText": "Hi,\nHere are the files I used for my MOOSE-Apps:\n\n.vscode/task.json: to build your app based on the Makefile. You can setup a keybinding for building the default build task (make test), I think by default it's ctrl + shift + b.\n\n{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"Makefike\",\n            \"type\": \"shell\",\n            \"command\": \"make\",\n            // start the build without prompting for task selection, use \"group\": \"build\" otherwise\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            },\n            \"options\": {\"shell\": {\"args\": [\"-ic\"]}},\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"always\",\n                \"focus\": false,\n                \"panel\": \"shared\"\n            },\n            // arg passing example: in this case is executed with 4 processors\n            \"args\": [\"test\", \"-j4\"],\n            // Use the standard less compilation problem matcher.\n            \"problemMatcher\": {\n                \"owner\": \"cpp\",\n                \"fileLocation\": [\"absolute\"],\n                \"pattern\": {\n                    \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",\n                    \"file\": 1,\n                    \"line\": 2,\n                    \"column\": 3,\n                    \"severity\": 4,\n                    \"message\": 5\n                }\n            }\n        },\n        {\n            \"label\": \"Makefike debug\",\n            \"type\": \"shell\",\n            \"command\": \"make\",\n            // start the build without prompting for task selection, use \"group\": \"build\" otherwise\n            \"group\": \"none\",\n            \"options\": {\"shell\": {\"args\": [\"-ic\"]}},\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"always\",\n                \"focus\": false,\n                \"panel\": \"shared\"\n            },\n            // arg passing example: in this case is executed in DEBUG mode with 4 processors\n            \"args\": [\"METHOD=dbg\", \"-j4\"],\n            // Use the standard less compilation problem matcher.\n            \"problemMatcher\": {\n                \"owner\": \"cpp\",\n                \"fileLocation\": [\"absolute\"],\n                \"pattern\": {\n                    \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",\n                    \"file\": 1,\n                    \"line\": 2,\n                    \"column\": 3,\n                    \"severity\": 4,\n                    \"message\": 5\n                }\n            }\n        },\n        {\n            \"label\": \"Makefike clean\",\n            \"type\": \"shell\",\n            \"command\": \"make\",\n            // start the build without prompting for task selection, use \"group\": \"build\" otherwise\n            \"group\": \"none\",\n            \"options\": {\"shell\": {\"args\": [\"-ic\"]}},\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"always\",\n                \"focus\": false,\n                \"panel\": \"shared\"\n            },\n            // arg passing example: in this case is executed for clean\n            \"args\": [\"clean\"],\n            // Use the standard less compilation problem matcher.\n            \"problemMatcher\": {\n                \"owner\": \"cpp\",\n                \"fileLocation\": [\"absolute\"],\n                \"pattern\": {\n                    \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",\n                    \"file\": 1,\n                    \"line\": 2,\n                    \"column\": 3,\n                    \"severity\": 4,\n                    \"message\": 5\n                }\n            }\n        },\n        {\n            \"label\": \"Test\",\n            \"type\": \"shell\",\n            \"command\": \"./run_tests\",\n            // start the build without prompting for task selection, use \"group\": \"build\" otherwise\n            \"group\": {\n                \"kind\": \"test\",\n                \"isDefault\": true\n            },\n            \"options\": {\"shell\": {\"args\": [\"-ic\"]}},\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"always\",\n                \"focus\": false,\n                \"panel\": \"shared\"\n            },\n            // arg passing example: in this case is executed with 4 processors\n            \"args\": [\"-j4\"]\n        }\n    ]\n}\n\n\n.vscode/launch.json: to configure the debugger\n\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Python: Current File\",\n            \"type\": \"python\",\n            \"request\": \"launch\",\n            \"program\": \"${file}\",\n            \"console\": \"integratedTerminal\"\n        },\n        {\n            \"name\": \"(lldb) Launch\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/yourapp-dbg\",\n            \"args\": [\n                \"-i\",\n                \"test/tests/simple_diffusion/simple_diffusion.i\"\n            ],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": true,\n            \"MIMode\": \"lldb\",\n            \"logging\": {\n                \"trace\": true,\n                \"traceResponse\": true,\n                \"engineLogging\": true\n            }\n        }\n    ]\n}\n\n\n.vscode/c_cpp_properties.json for being able to navigate the C++ code. This is a working file for Linux. It assumes your app and moose folders are in the same directory and that you installed MOOSE using miniconda. You might have to change some paths depending on your configuration.\n\n{\n    \"configurations\": [\n        {\n            \"name\": \"Linux\",\n            \"includePath\": [\n                \"${workspaceFolder}\",\n                \"${workspaceFolder}/build/header_symlinks\",\n                \"${workspaceFolder}/../moose/framework/build/header_symlinks\",\n                \"${workspaceFolder}/../moose/modules/module_loader/build/header_symlinks\",\n                \"${workspaceFolder}/../moose/framework/contrib/boost/include\",\n                \"${workspaceFolder}/../moose/framework/contrib/hit\",\n                \"${HOME}/miniconda3/envs/moose/include\",\n                \"${HOME}/miniconda3/envs/moose/libmesh/include\",\n                \"${workspaceFolder}/../moose/framework/contrib/json/include\"\n            ],\n            \"defines\": [],\n            // \"macFrameworkPath\": [\n            //     \"/System/Library/Frameworks\",\n            //     \"/Library/Frameworks\"\n            // ],\n            \"compilerPath\": \"${HOME}/miniconda3/envs/moose/bin/mpicxx\",\n            \"cStandard\": \"c11\",\n            \"cppStandard\": \"c++17\",\n            \"intelliSenseMode\": \"clang-x64\",\n            \"compileCommands\": \"${workspaceFolder}/compile_commands.json\",\n            \"browse\": {\n                \"path\": [\n                    \"${workspaceFolder}\",\n                    \"${workspaceFolder}/build/header_symlinks\",\n                    \"${workspaceFolder}/../moose/framework/build/header_symlinks\",\n                    \"${workspaceFolder}/../moose/modules/module_loader/build/header_symlinks\",\n                    \"${workspaceFolder}/../moose/framework/contrib/boost/include\",\n                    \"${workspaceFolder}/../moose/framework/contrib/hit\",\n                    \"${HOME}/miniconda3/envs/moose/include\",\n                    \"${HOME}/miniconda3/envs/moose/libmesh/include\"\n                ]\n            }\n        }\n    ],\n    \"version\": 4\n}\n\n\nFor autocompletion of the input files, there is this VSCode extension by Chris Sewell. It relies on the syntax files (.json and .yaml) you can generate from your executable. I do not have much experience with this extension though but may be someone else can comment on that.\n\nHope this helps.\nCheers,\nAntoine",
                  "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-995419",
                  "updatedAt": "2022-06-13T00:27:59Z",
                  "publishedAt": "2021-07-12T19:24:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bielsnohr"
                          },
                          "bodyText": "Thanks for this! Really helpful. A minor addendum for those that might use this in the future: my IntelliSense didn't work until I specified that all .h files should be associated with C++ rather than C. Stick this in your directory settings.json if you encounter the same problem:\n{\n    \"files.associations\": {\n        \"*.C\": \"cpp\",\n        \"*.h\": \"cpp\"\n    }\n}",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-1003012",
                          "updatedAt": "2022-06-13T22:20:52Z",
                          "publishedAt": "2021-07-14T09:36:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "Has anyone used this configuration recently? The files I got from a colleague stopped working after certain modifications and upgrade in MOOSE.",
                  "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-6263903",
                  "updatedAt": "2023-06-23T16:07:04Z",
                  "publishedAt": "2023-06-23T16:07:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "use the one on the moose website\nhttps://mooseframework.inl.gov/help/development/VSCode.html",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-6263925",
                          "updatedAt": "2023-06-23T16:10:00Z",
                          "publishedAt": "2023-06-23T16:09:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Thank you!\nI actually need something that can allow me to debug the input files (by stepping into the MOOSE codes) to know the order of execution. I would like to see the order of execution of the Shape functions and the Jacobians, and where they are computed, using the debug mode from the input file.",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-6264023",
                          "updatedAt": "2023-06-23T16:22:09Z",
                          "publishedAt": "2023-06-23T16:20:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "see this page and use show_execution_order\nhttps://mooseframework.inl.gov/syntax/Debug/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-6264055",
                          "updatedAt": "2023-06-23T16:25:22Z",
                          "publishedAt": "2023-06-23T16:25:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "[Debug]\n  show_execution_order = 'FORWARD'\n  show_actions = true\n[]\n\nshow_execution_order = 'FORWARD' gives /testing.i:81: unused parameter 'Debug/show_execution_order' error",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-6264191",
                          "updatedAt": "2023-06-23T16:39:05Z",
                          "publishedAt": "2023-06-23T16:39:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "use ALWAYS\nhow old is your MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-6264681",
                          "updatedAt": "2023-06-23T17:43:25Z",
                          "publishedAt": "2023-06-23T17:43:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I used 'ALWAYS', same error. Pretty much all the options give the same error.\nMy MOOSE is very very recent.\nFramework Information:\nMOOSE Version:           git commit 430275f180 on 2023-06-19\nLibMesh Version:         \nPETSc Version:           3.16.6\nSLEPc Version:           3.16.2\nCurrent Time:            Fri Jun 23 13:43:56 2023\nExecutable Timestamp:    Tue Jun 20 18:55:39 2023",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-6264692",
                          "updatedAt": "2023-06-23T17:45:41Z",
                          "publishedAt": "2023-06-23T17:45:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "parameter must be misspelled then",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-6264698",
                          "updatedAt": "2023-06-23T17:45:46Z",
                          "publishedAt": "2023-06-23T17:45:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "My Debug block in the input file is as given above, I don't think there's a spelling error in the show_execution_order based on what's on this page: https://mooseframework.inl.gov/syntax/Debug/index.html#debug-params",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-6264735",
                          "updatedAt": "2023-06-23T17:50:38Z",
                          "publishedAt": "2023-06-23T17:50:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Hello. I try the similar c_cpp_properties.json. But i can't find compile_commands.json in my workspace folder.\nHow do i deal with this?",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-7294751",
                          "updatedAt": "2023-10-16T16:04:47Z",
                          "publishedAt": "2023-10-16T16:04:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you'll need to create that file yourself",
                          "url": "https://github.com/idaholab/moose/discussions/18307#discussioncomment-7294786",
                          "updatedAt": "2023-10-16T16:09:00Z",
                          "publishedAt": "2023-10-16T16:08:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "\"Make clobberall\" will delete the dynamic library with so suffix in wasp install dir",
          "author": {
            "login": "Ttw0626"
          },
          "bodyText": "Dear moose-developer,\ngood afternoon, here is a small problem about the usual operation \"Make clobberall\".\n1) the new installation need the update_recompile for wasp\nThe installation on redhat 9 server following the new installation documentation is smooth\n2) make new application\nthis usual operation is needed by the path env for library of wasp, the \"update_recompile for wasp\" will create the links \"*.so\".\n3) make clobberall seems it will delete these links \"*.so\"\nthis is to say, before the new application compile, I have to re-run the \"update_recompile for wasp\" to create the link \"*.so\" everytime once The \"Make clobberall\" did ?\n4) I did not try the conda env ever, maybe it will be work\nbest regards,\nTianwen",
          "url": "https://github.com/idaholab/moose/discussions/25710",
          "updatedAt": "2023-10-17T19:29:45Z",
          "publishedAt": "2023-10-11T05:11:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "If you are referring to these instructions: Create an Application I think you are correct. I don't really see how one would know what to do. Either installing the Conda environment, or running any of the update_and_rebuild_$$$$ scripts. I'll begin addressing this in: #25711\nIf you are referring to another set of instructions, can you supply a link?\nAs for make clobberall, deleting .so files is the desired effect. Having those lying around when attempting to build anew can cause linking errors. Basically, make clobberall is supposed to perform something similar as to: git clean -xfd (in each submodule). Unless I am misunderstanding you?",
                  "url": "https://github.com/idaholab/moose/discussions/25710#discussioncomment-7249677",
                  "updatedAt": "2023-10-11T08:00:22Z",
                  "publishedAt": "2023-10-11T08:00:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "I think this is actually a valid issue. We don't clean up dependencies (libmesh, petsc) with make clobberall, so we shouldn't be doing it for wasp.",
                  "url": "https://github.com/idaholab/moose/discussions/25710#discussioncomment-7252703",
                  "updatedAt": "2023-10-11T13:18:14Z",
                  "publishedAt": "2023-10-11T13:18:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Oh I see. Yeah I suppose that does make sense. Re running the update_and_rebuild scripts clears those out.",
                          "url": "https://github.com/idaholab/moose/discussions/25710#discussioncomment-7254697",
                          "updatedAt": "2023-10-11T16:15:34Z",
                          "publishedAt": "2023-10-11T16:15:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "Created issue #25717.\n@permcody will address this soon. Thanks for the report @Ttw0626.",
                  "url": "https://github.com/idaholab/moose/discussions/25710#discussioncomment-7253900",
                  "updatedAt": "2023-10-11T14:55:58Z",
                  "publishedAt": "2023-10-11T14:55:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ttw0626"
                          },
                          "bodyText": "@milljm @loganharbour Thanks for this response,\nyeah, I was following the official installation documentation of moose.\nlogan pointed it out what I wanna say, sorry for this misunderstanding.\nAfter \"Make clobberall\"\n\nbest regards,\ntianwen",
                          "url": "https://github.com/idaholab/moose/discussions/25710#discussioncomment-7258163",
                          "updatedAt": "2023-10-12T00:58:51Z",
                          "publishedAt": "2023-10-12T00:58:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "I looked into this and it looks like the current behavior is consistent with existing dependencies. That is, we are clobbering libMesh, PETSc, and WASP if they are built locally with clobber. To see this behavior, one just needs to inspect the clobber.py script. We use a os.walk and remove a few select directories (notably repository meta directories) but walk everything else.\nIf you don't like the behavior of clobberall, I would recommend using clean or cleanall instead, which is usually good enough unless you've changed deeper dependencies in your change, which may interfere with stale object suffix names. Another way is to use git clean which doesn't traverse into git submodules by default.",
                          "url": "https://github.com/idaholab/moose/discussions/25710#discussioncomment-7307617",
                          "updatedAt": "2023-10-17T19:29:45Z",
                          "publishedAt": "2023-10-17T19:29:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE Action: Setting Default Values",
          "author": {
            "login": "Vandenbg"
          },
          "bodyText": "I am simplifying a heavily used input using actions. I am adding a generic material constant.\n::validParams()\n{\n  params.addParam<std::string>(\"characteristic_strength\", \"characteristic_strength\", \"The characteristic_strength name\");\n  return params;\n}\n...\n::addMaterial()\n  {\n    auto type = _ad_prepend + \"GenericConstantMaterial\";\n    auto params = _factory.getValidParams(type);\n    params.set<std::vector<SubdomainName>>(\"block\") = {_block};\n    params.set<Real>(\"prop_values\") = 9640000;\n    params.set<std::vector<std::string>>(\"prop_names\") = {\"characteristic_strength\"};\n    _problem->addMaterial(type, \"characteristic_strength\", params);\n  }\n\nEverything is working besides the params.set<std::vector<std::string>>(\"prop_names\") = {\"characteristic_strength\"};. I would like to put a default name here so that I don't need to specify it in the input. Above is my most current attempt. MOOSE will compile, but when I call the action in the input, I get the following error.\n*** ERROR ***\nAttempting to set parameter \"prop_values\" with type (double)\nbut the parameter already exists as type (std::__1::vector<double, std::__1::allocator<double>>)\n\nI am attempting to copy this.\n  [characteristic_strength]\n    type = GenericConstantMaterial\n    prop_values = '9640000'\n    block = 100\n    prop_names = 'characteristic_strength'\n  []",
          "url": "https://github.com/idaholab/moose/discussions/25760",
          "updatedAt": "2023-10-17T15:58:58Z",
          "publishedAt": "2023-10-17T15:15:21Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think you want to do:\n    params.set<std::vector<std::string>>(\"prop_names\") = {getParam<std::string>(\"characteristic_strength\")};\n\nthe default is specified in the addParams already",
                  "url": "https://github.com/idaholab/moose/discussions/25760#discussioncomment-7305617",
                  "updatedAt": "2023-10-17T15:41:00Z",
                  "publishedAt": "2023-10-17T15:40:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Vandenbg"
                          },
                          "bodyText": "This method works when I use it on both prop_values and prop_names.\nparams.addParam<Real>(\"characteristic_strength_value\", 9640000, \"The value for characteristic strength\");\nparams.addParam<std::string>(\"characteristic_strength\", \"characteristic_strength\", \"The characteristic_strength name\");\n\n    auto type = _ad_prepend + \"GenericConstantMaterial\";\n    auto params = _factory.getValidParams(type);\n    params.set<std::vector<SubdomainName>>(\"block\") = {_block};\n    params.set<std::vector<Real>>(\"prop_values\") = {getParam<Real>(\"characteristic_strength_value\")};\n    params.set<std::vector<std::string>>(\"prop_names\") = {getParam<std::string>(\"characteristic_strength\")};\n    _problem->addMaterial(type, \"characteristic_strength\", params);\n\nThank you!",
                          "url": "https://github.com/idaholab/moose/discussions/25760#discussioncomment-7305814",
                          "updatedAt": "2023-10-17T15:58:33Z",
                          "publishedAt": "2023-10-17T15:58:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to write to a vector aux variable and access the gradient of a vector aux variable?",
          "author": {
            "login": "andrisfreimanis"
          },
          "bodyText": "Dear All,\nI need to write a crystal plasticity material model that depends on the gradients of vectors defined for each slip system. Assuming 12 slip systems, a user would need to define 36 standard variables or 12 vector variables. Due to the smaller number I would like to use vector variables.\nFrom what I understand from Moose's documentation I could define vector variables and gradients in the header file as\nstd::vector<VectorMooseVariable *> _g_vector_var;\nstd::vector<const VectorVariableGradient *> _g_vector_grad;\n\nThe Coupleable class documentation mentions and there are several examples in Moose using Coupleable::writableVariable. That returns a reference to MooseWritableVariable and I don't see an equivalent for MooseVectorVariable. What is the intended way of writing to vector variables?\nAlso, I can get the gradient pointer in the constructor with\nfor (auto const slipId : make_range(_number_slip_systems))\n    _g_vector_grad[slipId] = &coupledVectorGradient(\"g_vector_variables\", slipId);\n\nIs this the intended way to access coupled vector gradients?\nBest regards\nAndris",
          "url": "https://github.com/idaholab/moose/discussions/25751",
          "updatedAt": "2023-10-17T05:37:37Z",
          "publishedAt": "2023-10-16T14:41:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou are not supposed to write to variables using the Coupleable interface. This writable reference was a hack introduced to work with an external library.\nTo write to a variable, you should get the solution from the system, get the dof index, then write that way.\nThe transfers do it for variable and array variables for an example.\nFor a vector variable it's pretty similar.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25751#discussioncomment-7294583",
                  "updatedAt": "2023-10-16T15:50:03Z",
                  "publishedAt": "2023-10-16T15:50:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "like this for example, in the projection transfer:\n  for (const auto & node : to_mesh.local_node_ptr_range())\n  {\n    for (unsigned int comp = 0; comp < node->n_comp(to_sys.number(), to_var.number()); comp++)\n    {\n      const dof_id_type to_index = node->dof_number(to_sys.number(), to_var.number(), comp);\n      to_solution->set(to_index, the value );\n    }",
                          "url": "https://github.com/idaholab/moose/discussions/25751#discussioncomment-7294616",
                          "updatedAt": "2023-10-16T15:53:03Z",
                          "publishedAt": "2023-10-16T15:53:02Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "andrisfreimanis"
                  },
                  "bodyText": "Thanks, that's the answer I was looking for.\nAndris",
                  "url": "https://github.com/idaholab/moose/discussions/25751#discussioncomment-7299966",
                  "updatedAt": "2023-10-17T05:37:37Z",
                  "publishedAt": "2023-10-17T05:37:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Second derivatives of FIRST LAGRANGE",
          "author": {
            "login": "mangerij"
          },
          "bodyText": "Hi, I want to be able to compute second derivatives of a variable in a postprocessor. This is an energy with a corresponding Kernel. For the Kernel we got around this by integrating by parts and putting one of the spatial derivatives on the test function. However, for accurate analysis of the energy we need the second derivatives of our variables.\nI am aware that second derivatives of FIRST LAGRANGE just return 0.0 because they are not stored but is there an easy way to track them?\nedit: apologies if this was already asked in here, I tried search and couldn't find anything",
          "url": "https://github.com/idaholab/moose/discussions/21442",
          "updatedAt": "2023-10-17T01:38:54Z",
          "publishedAt": "2022-06-28T11:33:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "The issue is that piecewise multilinear basis has zero second derivative. You'd want to project that variable onto a second order basis.",
                  "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-3039642",
                  "updatedAt": "2022-06-28T12:18:09Z",
                  "publishedAt": "2022-06-28T12:18:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "Is the procedure to let an AuxVariable be SECOND MONOMIAL and then use an AuxKernel to computeValue to store the value of the FIRST LAGRANGE\nIf so, I suppose that worked but I find the derivatives to be much much smaller than I expected.",
                          "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-3039674",
                          "updatedAt": "2022-06-28T12:23:07Z",
                          "publishedAt": "2022-06-28T12:23:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Right, this won't work. By projecting something of first order onto a second order basis, you are essentially \"adding information\", and that additional information comes from nowhere. Think about the case where you want to make a line with constant slope (first order) become second order by adding an additional dof, that dof can be anywhere. For most conservative projections, you'll end up recovering the exact same straight line, hence the second derivative is very small.\nDepending on your physics, you need to first figure out where that \"additional information\" may come from. Then there will be different ways of doing the projection. It's probably no longer appropriate calling it a projection, as projection typically loses information...",
                          "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-3040066",
                          "updatedAt": "2022-06-28T13:12:13Z",
                          "publishedAt": "2022-06-28T13:12:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You would need the variables that are used to compute the energy, likely the nonlinear variables, to be second order. Then you may compute a second order derivative.\nOtherwise you could build a stencil with more than one element to compute the second derivative. It's what we do in finite volume. It might not be super easy with the native coupleable (coupledValue etc) interface",
                          "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-3041130",
                          "updatedAt": "2022-06-28T15:18:18Z",
                          "publishedAt": "2022-06-28T15:18:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@mangerij You can try something like this:\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 20\n  second_order = true\n[]\n\n[Variables]\n  [u]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [v]\n    order = SECOND\n    family = LAGRANGE\n    [AuxKernel]\n      type = NodalPatchRecoveryAux\n      nodal_patch_recovery_uo = patch\n      execute_on = 'TIMESTEP_END'\n    []\n  []\n[]\n\n[Kernels]\n  [react]\n    type = Reaction\n    variable = u\n  []\n  [source]\n    type = BodyForce\n    variable = u\n    function = 'sin(100*x)'\n  []\n[]\n\n[Materials]\n  [u]\n    type = ParsedMaterial\n    f_name = u\n    args = u\n    function = u\n  []\n[]\n\n[UserObjects]\n  [patch]\n    type = NodalPatchRecoveryMaterialProperty\n    patch_polynomial_order = SECOND\n    property = u\n    execute_on = 'TIMESTEP_END'\n  []\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 1\n[]\n\n[Outputs]\n  exodus = true\n[]\nThis reconstructs a second order variable using a first order variable using the Zienkiewicz-Zhu patch recovery algorithm",
                          "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-3042963",
                          "updatedAt": "2022-06-28T19:55:55Z",
                          "publishedAt": "2022-06-28T19:55:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The output looks like this:",
                          "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-3043004",
                          "updatedAt": "2022-06-28T19:57:02Z",
                          "publishedAt": "2022-06-28T19:57:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "alimostafavi24"
                  },
                  "bodyText": "I am also trying to do the same. Let's say I want to calculate the volume integral of d2u/dx2+d2u/dy2. Is it the right way to call it in the postprocessor kernel (indexing should be (0,0) and (1,1))?\nreturn _mu * (_u[_qp]) * (_second_u[_qp](0,0) + _second_u[_qp](1,1)  );\nRight now I am using a first order element for u. I might be able to use the second order element for my variable. If I do this, can the post processor return the integral correctly? It would be great if I can correctly integrate the second order derivative.\nThanks.",
                  "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-7278214",
                  "updatedAt": "2023-10-14T00:30:15Z",
                  "publishedAt": "2023-10-14T00:30:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If first order lagrange that will just be 0\nare you using coupledSecond ? From the coupleable interface",
                          "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-7278224",
                          "updatedAt": "2023-10-14T00:35:50Z",
                          "publishedAt": "2023-10-14T00:35:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "alimostafavi24"
                  },
                  "bodyText": "All right. What is my best option here? Would using second order for variables be accurate or not? (here are the .h and .C files)\n#pragma once\n\n#include \"ElementIntegralPostprocessor.h\"\n#include \"MooseVariableInterface.h\"\n\n/**\n * This postprocessor computes a volume integral of the specified variable.\n *\n * Note that specializations of this integral are possible by deriving from this\n * class and overriding computeQpIntegral().\n */\nclass KEViscousWater : public ElementIntegralPostprocessor,\n                                             public MooseVariableInterface<Real>\n{\npublic:\n  static InputParameters validParams();\n\n  KEViscousWater(const InputParameters & parameters);\n\nprotected:\n  virtual Real computeQpIntegral() override;\n\n  /// Holds the solution at current quadrature points\n  const VariableValue & _u;\n  /// Holds the solution gradient at the current quadrature points\n  const VariableGradient & _grad_u;\n\n  const VariableValue & _vel_x;\n  const VariableGradient & _grad_vel_x;\n  const VariableSecond & _second_vel_x;\n\n  const VariableValue & _c;\n  const VariableGradient & _grad_c;\n  \n  const Real & _mu;\n};\n\n#include \"KEViscousWater.h\"\n\nregisterMooseObject(\"MooseApp\", KEViscousWater);\n\nInputParameters\nKEViscousWater::validParams()\n{\n  InputParameters params = ElementIntegralPostprocessor::validParams();\n  params.addRequiredCoupledVar(\"variable\", \"The name of the variable that this object operates on\");\n  params.addRequiredCoupledVar(\"vel_x\", \"vel_x\");\n  params.addRequiredCoupledVar(\"c\", \"c\");\n\n  params.addClassDescription(\"Computes a volume integral of the specified variable\");\n  params.addParam<Real>(\"mu\", 1.0, \"mu\");\n  return params;\n}\n\nKEViscousWater::KEViscousWater(\n    const InputParameters & parameters)\n  : ElementIntegralPostprocessor(parameters),\n    MooseVariableInterface<Real>(this,\n                                 false,\n                                 \"variable\",\n                                 Moose::VarKindType::VAR_ANY,\n                                 Moose::VarFieldType::VAR_FIELD_STANDARD),\n    _u(coupledValue(\"variable\")),\n    _grad_u(coupledGradient(\"variable\")),\n    _vel_x(coupledValue(\"vel_x\")),\n    _grad_vel_x(coupledGradient(\"vel_x\")), \n    _second_vel_x(coupledSecond(\"vel_x\")),\n      \n\n    _c(coupledValue(\"c\")),\n    _grad_c(coupledGradient(\"c\")),\n    _mu(getParam<Real>(\"mu\"))\n\n\n{\n  addMooseVariableDependency(&mooseVariableField());\n}\n\nReal\nKEViscousWater::computeQpIntegral()\n{\n  if (_c[_qp] < -0.0)\n  return 0;\n  return _mu * (_vel_x[_qp]) * (_second_vel_x[_qp](0,0) + _second_vel_x[_qp](1,1)  );\n}",
                  "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-7278314",
                  "updatedAt": "2023-10-14T01:29:16Z",
                  "publishedAt": "2023-10-14T01:29:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "integration by parts to reduce the order of the derivative is what we usually do",
                          "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-7278322",
                          "updatedAt": "2023-10-14T01:32:31Z",
                          "publishedAt": "2023-10-14T01:32:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "For me, I should do the volume integration.\nHow about creating a multiapp and use the LaplacianSplit? (I assume it gives d2u/dx2+d2u/dy2)\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-7298716",
                          "updatedAt": "2023-10-17T01:31:58Z",
                          "publishedAt": "2023-10-17T01:31:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m not sure what you mean by that\nIntegration by parts is still a volume integration, just of a different term. And there's an additional boundary integral. But the reduction in order is worth it",
                          "url": "https://github.com/idaholab/moose/discussions/21442#discussioncomment-7298756",
                          "updatedAt": "2023-10-17T01:38:55Z",
                          "publishedAt": "2023-10-17T01:38:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}