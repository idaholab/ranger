{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wMS0yOVQxMzowNzo0MS0wNzowMM4ASS9b"
    },
    "edges": [
      {
        "node": {
          "title": "High level documentation of Boundary Conditions",
          "author": {
            "login": "ttruster"
          },
          "bodyText": "As I was working on my own documentation for a pull request, I noticed that all the other MOOSE syntax pages except for https://mooseframework.inl.gov/syntax/BCs/index.html have a good or even great discussion of the types of classes derived from that syntax. E.g. Variables, Kernels, Constraints, Interface Kernels, ...\nOther than the example at https://mooseframework.inl.gov/getting_started/examples_and_tutorials/examples/ex04_bcs.html and some of the videos, I haven't found a nice high-level list of the types of BC in MOOSE and how to add new ones. If I'm missing the link, let me know so I can bookmark it.\nI'm not volunteering since I'm rather rather new here, but I'll throw out some ideas. I think like half a page is good enough to categorize them; like what is at the https://mooseframework.inl.gov/syntax/ICs/index.html page. Mentioning the difference (input file and PDE-treatment) of Dirichlet and Neumann BC (and Robin), and nodal versus integrated BCs.",
          "url": "https://github.com/idaholab/moose/discussions/23291",
          "updatedAt": "2023-02-04T06:40:24Z",
          "publishedAt": "2023-01-31T18:33:58Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou are very much right. We are missing syntax-documentation for some of the core systems of MOOSE\nThis would be the page for it\nhttps://mooseframework.inl.gov/syntax/BCs/index.html\nWe have spent a lot of time to document all the framework objects. The syntax / core systems can be a little tougher to document because of all the things one has to know about the system, hence the delay. I will try to find the time.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23291#discussioncomment-4834063",
                  "updatedAt": "2023-01-31T21:01:24Z",
                  "publishedAt": "2023-01-31T21:01:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Questions about boundary condition setting",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Now I have two systems that share one common interface.\nCan I set same pressure and pressure gradient for their shared boundary?",
          "url": "https://github.com/idaholab/moose/discussions/23278",
          "updatedAt": "2023-02-04T06:40:16Z",
          "publishedAt": "2023-01-30T19:10:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "What variables do you have?\nAnd are they defined on both sides of the interface, or one side each",
                  "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4822225",
                  "updatedAt": "2023-01-30T19:12:53Z",
                  "publishedAt": "2023-01-30T19:12:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "What variables do you have? And are they defined on both sides of the interface, or one side each\n\nI have a fluid flow process with the Navier-Stoke flow (1st system) and Darcy flow (2nd system). In the 1st system, we have pressure and mass flow rate as variables and in the 2nd system, we have only pressure as variable.\nSo only pressure is defined on both sides but not others.",
                          "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4822380",
                          "updatedAt": "2023-01-30T19:20:30Z",
                          "publishedAt": "2023-01-30T19:19:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what variable type is pressure?\nis it continuous?",
                          "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4822422",
                          "updatedAt": "2023-01-30T19:22:19Z",
                          "publishedAt": "2023-01-30T19:22:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "what variable type is pressure? is it continuous?\n\npressure is continuous and I want to use multiApp to couple these two systems. pressure is scalar variable.",
                          "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4822448",
                          "updatedAt": "2023-01-30T19:25:27Z",
                          "publishedAt": "2023-01-30T19:25:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "what variable type is pressure? is it continuous?\n\nSo I want to compute variable values in one system then transfer to another system.",
                          "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4822460",
                          "updatedAt": "2023-01-30T19:27:02Z",
                          "publishedAt": "2023-01-30T19:27:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "A scalar variable is a single scalar for the entire mesh.\nIsn\u2019t pressure a field variable instead?\nUsing a multi app approach, you can transfer a field. But here you need boundary values right?",
                          "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4822712",
                          "updatedAt": "2023-01-30T19:55:16Z",
                          "publishedAt": "2023-01-30T19:55:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "A scalar variable is a single scalar for the entire mesh. Isn\u2019t pressure a field variable instead?\nUsing a multi app approach, you can transfer a field. But here you need boundary values right?\n\nok, pressure is field vairable in 3D grids.\nYes, boundary values are not defined at the interface of two systems.",
                          "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4823154",
                          "updatedAt": "2023-01-30T20:51:10Z",
                          "publishedAt": "2023-01-30T20:51:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would replicate the mesh in both systems, and store the pressure from the OTHER system in an auxiliary variable.\nThen the transfers will naturally map the pressure fields from each half of the mesh in one system to the same half on the other system. You may even be able to use the MultiAppCopyTransfer with block restriction\nThen either:\n\ndevelop an interface kernel to handle the interaction between the two variables at the boundary\nOR\nuse a matched value BC to match the pressures",
                          "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4823165",
                          "updatedAt": "2023-01-30T20:59:08Z",
                          "publishedAt": "2023-01-30T20:54:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "I would replicate the mesh in both systems, and store the pressure from the OTHER system in an auxiliary variable. Then the transfers will naturally map the pressure fields from each half of the mesh in one system to the same half on the other system. You may even be able to use the MultiAppCopyTransfer with block restriction\nThen either:\n\ndevelop an interface kernel to handle the interaction between the two variables at the boundary\nOR\nuse a matched value BC to match the pressures\nThanks a lot.\nI amnot sure if I understand - replicate the mesh in both system, Do you mean use one system containing these two sub-systems? Or one gmsh file contains both systems? Thanks again.",
                          "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4823227",
                          "updatedAt": "2023-01-30T21:02:07Z",
                          "publishedAt": "2023-01-30T21:02:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "I would replicate the mesh in both systems, and store the pressure from the OTHER system in an auxiliary variable. Then the transfers will naturally map the pressure fields from each half of the mesh in one system to the same half on the other system. You may even be able to use the MultiAppCopyTransfer with block restriction\nThen either:\n\ndevelop an interface kernel to handle the interaction between the two variables at the boundary\nOR\nuse a matched value BC to match the pressures\n\n\nBy the way, I have another question. I use our uni cluster to run simulations. But if I increase the numbers of the nodes and cores in the uni cluster, the 'Solve Did NOT Converge' will be shown in the outcome. What is the reason for this?",
                          "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4823247",
                          "updatedAt": "2023-01-30T21:04:25Z",
                          "publishedAt": "2023-01-30T21:04:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Use one gmsh file in both applications. And use block restrictions to restrict the physics on both sides of this interface.\nThe preconditioning is different in serial and in parallel.\nYou will want to find a preconditioner that works for you in parallel.",
                          "url": "https://github.com/idaholab/moose/discussions/23278#discussioncomment-4823375",
                          "updatedAt": "2023-01-30T21:22:14Z",
                          "publishedAt": "2023-01-30T21:22:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "can't call computeOffDiagJacobianScalar in a NodalKernel?",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "A NodalKernel has a computeOffDiagJacobianScalar method accoring to doxygen, but it doesn't seem to be getting called in my nodal kernel. I have scalar variables in my system, and they are coupled in my constructor (coupledScalar). Is there something more I need to do? FWIW, my on-diagonal Jacobian method is being called. I also threw in a computeQpOffDiagJacobian method that does nothing, but that doesn't seem be getting called either, which is odd because I have 2 nonlinear displacement variables in my system (it is a 2D mechanics problem).",
          "url": "https://github.com/idaholab/moose/discussions/23267",
          "updatedAt": "2023-01-31T18:28:54Z",
          "publishedAt": "2023-01-27T15:17:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "It is off diagonal w.r.t. other scalar variables.",
                  "url": "https://github.com/idaholab/moose/discussions/23267#discussioncomment-4798553",
                  "updatedAt": "2023-01-27T16:08:03Z",
                  "publishedAt": "2023-01-27T16:08:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Oh, didn't realize that. Well, I have 3 scalar variables in my system so I would still expect it to be called!\nThen I guess my question should be - what is the proper method for computing the Jacobian contribution for nonlinear variables with respect to scalar variables and vice versa?",
                          "url": "https://github.com/idaholab/moose/discussions/23267#discussioncomment-4798585",
                          "updatedAt": "2023-01-27T16:10:40Z",
                          "publishedAt": "2023-01-27T16:10:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "We had some discussion about a similar issue for Mortar Constraints over here #22020. Basically, the computeOffDiagJacobianScalar method is only implemented within the assembly loops for Kernels and IntegratedBC within MOOSE; none of the other ResidualObjects address that method. I have an open pull request at #22376 to implement interfaces for coupling scalar variables to Kernels and MortarConstraints more effectively. My next plan is for InterfaceKernels and maybe IntegratedBC, although it won't be for a while. You can look there for some inspiration and discuss sometime if you want. The basic idea is to add a focus scalar variable to the Kernel object and then do assembly of that scalar within the computeResidual and computeJacobian contributions to the field variables.",
                          "url": "https://github.com/idaholab/moose/discussions/23267#discussioncomment-4832844",
                          "updatedAt": "2023-01-31T18:19:07Z",
                          "publishedAt": "2023-01-31T18:19:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "FWIW, what I ended up doing was overriding computeJacobian in both my nodal kernel and scalar kernel and setting Jacobian entries manually with _assembly.cacheJacobian(row, col, value,...), where the row and column come from the DoF associated with the kernel's variable (or coupled variable) and node via the dof_number method of the Node class.",
                          "url": "https://github.com/idaholab/moose/discussions/23267#discussioncomment-4832927",
                          "updatedAt": "2023-01-31T18:28:37Z",
                          "publishedAt": "2023-01-31T18:28:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "multi phase grain tracker",
          "author": {
            "login": "starkekr"
          },
          "bodyText": "Is there a multi phase grain tracker feature in MOOSE? I am trying to solve a multi-phase (3 phases) multi-grain (hundreds of grains) system and a cant seem to find a multi phase grain tracker object in moose.\nI was thinking of trying to use the GrainDataTracker object to store the phase id but ran into difficulty when initializing the object because the newGrain function only takes as input the grain id. Ideally I would like it to pass the phase as well but i dont know how possible this is seeing as this function derives from newGrainCreated in GrainTracker which i think is pulling data from the FeatureFloodCount object? I guess the alternative is to maintain a grain_id->phase_id map.\nAny thoughts on this is greatly appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/22755",
          "updatedAt": "2023-03-09T18:25:49Z",
          "publishedAt": "2022-11-18T20:51:26Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs this page helpful?\nhttps://mooseframework.inl.gov/moose/source/postprocessors/GrainTracker.html\nWe do support multiphase and multi-grain in the phase field module.\nMaybe @permcody could point you further.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4191370",
                  "updatedAt": "2022-11-21T01:59:07Z",
                  "publishedAt": "2022-11-21T01:59:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "I have read this page. Unfortunately, it was not that useful for incorporating multiphase information into the Grain tracker. The FeatureFloodCount object only seems to have information about the centroid locations and a unique id for the grains. I may be able to use the centroid locations to initialize each of the phases for each grain for my GrainDataTracker object but was wondering if there were any other ideas?",
                          "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4196255",
                          "updatedAt": "2022-11-21T14:38:16Z",
                          "publishedAt": "2022-11-21T14:38:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Hi @starkekr - As the author of the FeatureFloodCounter and GrainTracker, I did design those objects with was as much flexibility as possible so that developers could easily extend these objects further. The purpose of these two objects is simply to identify \"connected regions\", and to \"track across time\" respectively. @dschwen, later created the GrainDataTracker so that we could attach arbitrary information to each grain keyed by unique ID (everything from secondary identifiers, Euler angles, and I'm fairly certain phase should already be included). We should be able to store and retrieve all of that data now. I may have to dig around for an example, but I'm fairly certain there is an EBSD example where we have multiple phases right now.\nWorst case scenario, you can certainly create one more map in your own \"GrainTracker-derived\" class, but you really shouldn't need to do this. As to your exact question, @dschwen will be able to better answer your question, but rather than pass a bunch of data to the \"newGrainCreated\" method and inevitably miss something (like phase). I believe we delegated the job of how to create a new grain downstream a bit further so that users could potentially augment the data or method that goes into creating a new grain.\nSorry for all the rambling, I only bring answers to half of the questions here. I do believe we have the capabilities you need, sorry that it's not more clear on how to unlock everything.",
                          "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4199797",
                          "updatedAt": "2022-11-21T22:59:09Z",
                          "publishedAt": "2022-11-21T22:59:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "This is great information, thank you! The code is written very well! Yes, I see there is an example in ebsd_reconstruction (IN100-111grn.i) which reads grain information from a text file which has the phase id and euler angles as secondary identifiers. But it is still a single phase problem. When I change one of the grains the ebsd reader gives me the following error\n\"An EBSD feature needs to have a uniform phase.\"\nI dont think we need to dwell on this though because I can write my own object to initialize the grains. Once I hear back from dschwen maybe he can give me a better idea of a path forward.",
                          "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4205727",
                          "updatedAt": "2022-11-22T13:20:24Z",
                          "publishedAt": "2022-11-22T13:20:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "Just checking to see if there is there any update on this?",
                          "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4284397",
                          "updatedAt": "2022-12-01T15:20:27Z",
                          "publishedAt": "2022-12-01T15:20:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@dschwen want to comment on what Cody said or on the error @starkekr hit?",
                          "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4586481",
                          "updatedAt": "2023-01-03T23:17:26Z",
                          "publishedAt": "2023-01-03T23:17:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "If I remember correctly the way this is set up right now is that you have a separate set of OPs for each phase. Each with their own Grain tracker, and each with their own PolycrystalEBSD - that user object has a parameter to pick one specific phase from the EBSD file. You'd need to figure out how to formulate the interaction of grains in different phases though.",
                          "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4639208",
                          "updatedAt": "2023-01-09T23:34:52Z",
                          "publishedAt": "2023-01-09T23:34:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "Is there an example where this is done with the grain tracker? I see there are a few reconstruction tests (some of which use the grain tracker) but these only use one PolycrystalEBSD reader object to initialize the grains (using PolycrystalColoringIC)?\nI have tried creating two sets of variables with different var_base_name's (eta_p1 & eta_p2) then created two PolycrystalEBSD reader objects differing in their phase along with two GrainTracker objects which take in the different PolycrystalEBSD objects. The problem comes in producing the initial conditions for the order parameters.  I have attached the test file which gives me an error that polycrystal_ic_uo and op_num are supplied multiple times.\nc_chem_only2d_small2.txt\nI can write an IC object too but just wanted to check if there was a workaround for this part.\nAlso how do I tell the grain tracker to only work on a subset of the order parameters?",
                          "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4647713",
                          "updatedAt": "2023-01-10T17:06:25Z",
                          "publishedAt": "2023-01-10T17:06:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "Sorry refer to this file. I think I found out how to make the grain tracker work on a subset of order parameters. Is the way I am doing it correct?\nc_chem_only2d_small2.txt",
                          "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4648096",
                          "updatedAt": "2023-01-10T17:33:00Z",
                          "publishedAt": "2023-01-10T17:32:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Yes, you can certainly supply the list of variables manually to the GrainTracker. We normally build the list automatically based on a prefix and suffix pattern, but this is valid too.",
                          "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4649192",
                          "updatedAt": "2023-01-10T19:31:34Z",
                          "publishedAt": "2023-01-10T19:31:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "Is there a way to print out the materials that are defined? I have created an input file which produces the following error:\n*** ERROR ***\nThe following error occurred in the object \"EM\", of type \"ComputeRotatedRankTwoTensorGT\".\nFailed to get a parameter with the name \"grain_trackerMT\" when getting a UserObjectName.\nmin_error_file.txt\nComputeRotatedRankTwoTensorGT is a templated class which derives from CompositeTensorBase.In this class I try to get one of the created grain trackers using the line\n_grain_trackers[i] = &this->template getUserObject<GrainDataTracker>(_gt_names[i]);\nand I get the above error.",
                          "url": "https://github.com/idaholab/moose/discussions/22755#discussioncomment-4768339",
                          "updatedAt": "2023-01-24T16:10:11Z",
                          "publishedAt": "2023-01-24T16:10:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "RunTime is not a registered object",
          "author": {
            "login": "RWTHLHK"
          },
          "bodyText": "I am a new user to MOOSE and am running the example of phase-field module. But at 2nd step make a faster model in block Postprocessors, it always reports error RunTime is not a registered object. After I modify the Makefile All_MODULES=yes, the error still occurs.",
          "url": "https://github.com/idaholab/moose/discussions/23285",
          "updatedAt": "2023-04-07T16:50:36Z",
          "publishedAt": "2023-01-31T13:40:04Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCould you please paste the error you are getting exactly?\nIn s2_fasttest.i the Postprocessors do not have a RunTime object\n[Postprocessors]\n  [./evaluations]           # Cumulative residual calculations for simulation\n    type = NumResidualEvaluations\n  [../]\n  [./elapsed]\n    type = PerfGraphData\n    section_name = \"Root\"\n    data_type = total\n  [../]\n[]\n\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23285#discussioncomment-4831050",
                  "updatedAt": "2023-01-31T15:12:21Z",
                  "publishedAt": "2023-01-31T15:12:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using Cauchy Stress as Target Value in Homogenization System",
          "author": {
            "login": "grld"
          },
          "bodyText": "Dear community,\nI would like to use the MOOSE tensor mechanics module to run stress-controlled RVE calculations. I read about the homogenization system and that it can be used in combination with periodic boundary conditions to impose cell-average stress or strain conditions.\nThe documentation states that in the finite strain framework, either the deformation gradient F or the first Piola-Kirchhoff PK1 can be used as target quantities. For the calculations that I would like to run, I am interested in targeting the Cauchy stress tensor and use the finite strain formulation. The reason is that I don't know the deformation gradient F before I run the simulation so I can not define the PK1 beforehand as boundary condition but only the cauchy.\nI know that this is theoretically possible in Abaqus as explained in this work. The author implements periodic boundary conditions by coupling edge and face nodes at opposite sides of the RVE. Either Neumann or Dirichlet boundary conditions are applied on so-called reference nodes at the corners of the RVE (see page 27). Defining Neumann boundary conditions on the reference nodes is then equivalent to defining an average Cauchy stress (see page 80)\nI was wondering if this can be also done in MOOSE. Has someone experience with this or any recommendations?\nThank you very much for your support already:)",
          "url": "https://github.com/idaholab/moose/discussions/23275",
          "updatedAt": "2023-02-04T06:41:19Z",
          "publishedAt": "2023-01-30T12:36:52Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@grld  you should be able to apply periodic boundary conditions on the displacement variables,\nexamples of periodic boundary conditions tests are here:\nhttps://github.com/idaholab/moose/tree/next/test/tests/bcs/periodic",
                  "url": "https://github.com/idaholab/moose/discussions/23275#discussioncomment-4824447",
                  "updatedAt": "2023-01-31T00:10:50Z",
                  "publishedAt": "2023-01-31T00:10:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "yeah, that's one way to impose KUBC (well PBC strictly speaking, which is a mix of KUBC and SUBC) but probably isn't what the OP is after. Right now we support SUBC with given homogenized PK1 stress. Adding support for Cauchy stress should be possible and is a good addition IMHO. Feel free to open a feature request and tag me there.",
                          "url": "https://github.com/idaholab/moose/discussions/23275#discussioncomment-4824759",
                          "updatedAt": "2023-01-31T01:04:03Z",
                          "publishedAt": "2023-01-31T01:02:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grld"
                          },
                          "bodyText": "Hello, thank you very much for your answers.\n@ngrilli I am aware of the possibility to apply periodic boundary conditions (PBC) in Moose together with Dirichlet BC. As @hugary1995 mentions there, is the possibility to combine them with homogenized PK1 stress (in case of finite strains) as explained here: https://mooseframework.inl.gov/modules/tensor_mechanics/Homogenization.html\nAdding the Cauchy stress as the homogenized or targeted quantity there would be exactly what I am looking for.\n@hugary1995 I have never opened a feature request before. Is there any guide to this?\nThanks to both of you again:)",
                          "url": "https://github.com/idaholab/moose/discussions/23275#discussioncomment-4827964",
                          "updatedAt": "2023-01-31T09:49:08Z",
                          "publishedAt": "2023-01-31T09:49:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You can open a new issue and then choose \"feature request\" (rather than bug report). I've done that for you: #23287",
                          "url": "https://github.com/idaholab/moose/discussions/23275#discussioncomment-4830779",
                          "updatedAt": "2023-01-31T14:49:25Z",
                          "publishedAt": "2023-01-31T14:49:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Parallelisation of THM",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi all, looking at parallelisation of THM calculations - looking at the news section within THM - https://mooseframework.inl.gov/modules/thermal_hydraulics/index.html - I see that it says ''The Thermal hydraulics module can now run with distributed memory parallelism (MPI). Note that HeatTransferFromHeatStructure1Phase currently requires a replicated mesh; see issue.\"\nThe last time I tried to run my problem in parallel, which has HeatStructureFromFile3D and HeatTransferFromHeatStructure3D1Phase, I couldn't run in parallel which limits the scalability by using replicated mesh. I see that PR #20578 was merged in, but that looks like only part of the solution. If anyone could drop a few hints, I could have a crack and see what changes needed to be made? Its on my critical path so it makes me motivated :)",
          "url": "https://github.com/idaholab/moose/discussions/23276",
          "updatedAt": "2023-02-04T06:40:58Z",
          "publishedAt": "2023-01-30T13:45:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@joshuahansel",
                  "url": "https://github.com/idaholab/moose/discussions/23276#discussioncomment-4820774",
                  "updatedAt": "2023-01-30T16:27:43Z",
                  "publishedAt": "2023-01-30T16:27:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Yes, HeatTransferFromHeatStructure3D1Phase would have the same issue as HeatTransferFromHeatStructure1Phase. The issue you referenced: #20798, has everything that I know. I'll continue the discussion on that issue.",
                          "url": "https://github.com/idaholab/moose/discussions/23276#discussioncomment-4821548",
                          "updatedAt": "2023-01-30T17:47:40Z",
                          "publishedAt": "2023-01-30T17:47:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fortran options when compiling UMAT code to use with tensor mechanics",
          "author": {
            "login": "ngrilli"
          },
          "bodyText": "Dear MOOSE users,\nI have recently tried the UMAT plugin.\nIt works well but I noticed that to compile properly my UMAT with make command in my MOOSE App folder,\nI need to do some modifications compared with the UMAT I use for Abaqus.\nSpecifically, I notice that I need to shorten some lines by going to new line with +,\nthis makes me think that fortran 77 standard is followed.\nAlso, fortran modules are not compiled by the make command, I need to compile them separately using:\ngfortran -c name_of_module.f\nto generate the .mod files\nThe UMAT that works well is this one:\nhttps://github.com/ngrilli/c_pfor_am/tree/main/test/plugins\nbut I had to make many changes compared with the original one here:\nhttps://github.com/TarletonGroup/CrystalPlasticity\nIs there a way to set gfortran options when compiling the UMAT?\nFor instance I would like to have the free form option and compiling with f90 standards.\nThank you very much in advance.\nBest Regards,\nNicol\u00f2",
          "url": "https://github.com/idaholab/moose/discussions/19560",
          "updatedAt": "2023-01-30T09:13:17Z",
          "publishedAt": "2021-12-07T00:04:03Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dschwen",
                  "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-1776794",
                  "updatedAt": "2022-05-31T09:43:40Z",
                  "publishedAt": "2021-12-09T04:51:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@GiudGiud  @dschwen  Thank you very much in advance for the answer.\nI also want to point out that in the UMAT and Abaqus mesh convention, the input variables NOEL and NPT,\nwhich are the element number and integration point number,\nstart from 1 and not from 0, as in the MOOSE convention.\nIn the current implementation of AbaqusUMATStress this is not considered,\ntherefore I modified my UMAT and use NOEL+1 and NPT+1\nI think this could be easily fixed in the AbaqusUMATStress\nand would lead to full compatibility with UMATs, like mine, that use NOEL and NPT for some of the calculations.\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-1779395",
                  "updatedAt": "2022-05-31T09:44:49Z",
                  "publishedAt": "2021-12-09T14:21:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Thanks Nicol\u00f2, the 1 based indexing is a valuable comment. I'll change that. Hopefully it won't screw things up for existing users.\nI wrote a system for compiling multi file plugins, but it does not deal with .mod files yet. An easy fix. Look at\nhttps://github.com/idaholab/moose/tree/next/modules/tensor_mechanics/examples/umat_build\nfor an example Makefile. The example is C++, but this should work for fortran (not .mod yet) files. I'll fix that today.",
                  "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-1779462",
                  "updatedAt": "2022-05-31T09:46:05Z",
                  "publishedAt": "2021-12-09T14:29:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Here is a PR addressing your points: #19593",
                          "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-1782409",
                          "updatedAt": "2022-05-31T09:46:05Z",
                          "publishedAt": "2021-12-09T22:18:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@dschwen Thank you very much, now I understand how to compile multiple files.\nWhat about the free form fortran option?\nIs there an option I can put in the Makefile to tell the compiler that I want free form fortran?\nRight now I need to truncate my entire UMAT to column 72.\nThank you very much in advance,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-1784688",
                  "updatedAt": "2022-05-31T09:46:31Z",
                  "publishedAt": "2021-12-10T10:08:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "I'd also like to know how to set compiler flags when compiling Fortran UMAT's.\nFor instance I'd like to compile a Fortran UMAT with -O0. If I compile my app with METHOD=dbg make -n, the C++ files get compiled with -O0 but the Fortran still gets compiled with -O2. If I manually set FFLAGS='-O0' (as well as FCFLAGS, F90FLAGS, F77FLAGS because why not), I still get -O2.\n@dschwen @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-2767636",
                          "updatedAt": "2022-05-31T09:46:52Z",
                          "publishedAt": "2022-05-17T13:14:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "See your own comment on this thread #21476\nabout the PLUGIN_FLAGS.\nI'm documenting this to facilitate future searches",
                          "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-3201947",
                          "updatedAt": "2022-07-21T23:35:27Z",
                          "publishedAt": "2022-07-21T23:35:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Good call. Forgot that I answered my own question.",
                          "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-3202252",
                          "updatedAt": "2022-07-22T00:58:08Z",
                          "publishedAt": "2022-07-22T00:58:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grld"
                          },
                          "bodyText": "Hello, thank you very much for your explanations. I followed the comments here and in this thread #21201. I am also trying to use a Fortran UMAT  in MOOSE. I struggled to compile but added three compiler flags here. Now gfortran can compile the UMAT files.\nHowever, my UMAT consists of different .f files and .mods files. As @ngrilli has described in #21201, the files depend on each other and need to be compiled in a certain order. My problem is exactly there: The build.mk compiles the fortran files in an alphabetical order and not in the order I need.\nI tried to understand the Makefile @dschwen pointed out above. However, I don't understand to which Makefile I need to add the lines.\nSorry for my confusion and thank you very much in advance!\nJan",
                          "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-4765438",
                          "updatedAt": "2023-01-24T11:00:09Z",
                          "publishedAt": "2023-01-24T10:58:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Possibly we can manually add dependencies like\n$(YOUR_FORTRAN_SRC_DIR)/A.f90: $(YOUR_FORTRAN_SRC_DIR)/B.$(obj-suffix)\n\nIn this way, B.f90 will be compiled ahead of A.f90.",
                          "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-4768324",
                          "updatedAt": "2023-01-24T16:08:48Z",
                          "publishedAt": "2023-01-24T16:08:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grld"
                          },
                          "bodyText": "Thank you @YaqiWang this would be a quick fix.",
                          "url": "https://github.com/idaholab/moose/discussions/19560#discussioncomment-4816432",
                          "updatedAt": "2023-01-30T09:13:18Z",
                          "publishedAt": "2023-01-30T09:13:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Converting vel_x and vel_u to vel",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello,\nIn Navier-Stokes module, because of the way that the kernels are developed, I need to solve for vel_x (velocity in x direction) and vel_y (velocity in y direction) separately (not defining the velocity variable as a vector).\nBut in a part of my input file, I need to use a kernel which requires me to have velocity as a vector. My question is that how can I define a new variable and convert vel_x and vel_y to a 2D vector called vel?\nThanks,\nAli",
          "url": "https://github.com/idaholab/moose/discussions/23271",
          "updatedAt": "2023-02-04T06:51:36Z",
          "publishedAt": "2023-01-30T00:01:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI m afraid you can't do that. While you could form a vector auxiliary variable using the component nonlinear variables, you cant use a kernel on that, kernels require nonlinear variables.\nThe solution here is to re-write the kernel to accept component variables\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23271#discussioncomment-4813763",
                  "updatedAt": "2023-01-30T01:33:14Z",
                  "publishedAt": "2023-01-30T01:33:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "initQpStatefulProperties() setting",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear all,\nI have a question about the Stateful Material Properties. I need to define the Stateful Material Properties _n1 and _n2.\nSee below \uff1a\n_n1 is defined as the  _ind[_qp] multiplying coupledValue _s[_qp]. _ind[_qp] is the function of temperature _T[_qp]. The initial value of _n2 is 0.\nAre the following initQpStatefulProperties correct or not?\nvoid\nMaterial::initQpStatefulProperties()\n{\n  if (_T[_qp] < 1) {\n    _ind[_qp] = 1.0;\n  }\n  else {\n    _ind[_qp] = 0.0;\n  }\n\n  _n1[_qp] = _ind[_qp] * _s[_qp];\n  _n2[_qp] = 0.0;\n}\n\nJ",
          "url": "https://github.com/idaholab/moose/discussions/23263",
          "updatedAt": "2023-02-04T16:00:10Z",
          "publishedAt": "2023-01-26T23:13:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Joseph-0123"
                  },
                  "bodyText": "Hello @GiudGiud, could you please help me have a look at this?",
                  "url": "https://github.com/idaholab/moose/discussions/23263#discussioncomment-4792198",
                  "updatedAt": "2023-01-26T23:14:07Z",
                  "publishedAt": "2023-01-26T23:14:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This seems right, depending on the definition that _ind should have which you did not explain.\nHowever it's not the whole picture, this is just the initialization. You need to have a computeQpPoperties still\nMore on stateful properties\nhttps://mooseframework.inl.gov/syntax/Materials/#f5ffdc6c-3cc9-4a43-bbfd-566e34905cf3",
                          "url": "https://github.com/idaholab/moose/discussions/23263#discussioncomment-4793741",
                          "updatedAt": "2023-01-27T05:15:38Z",
                          "publishedAt": "2023-01-27T05:15:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "This seems right, depending on the definition that _ind should have which you did not explain.\nHowever it's not the whole picture, this is just the initialization. You need to have a computeQpPoperties still More on stateful properties https://mooseframework.inl.gov/syntax/Materials/#f5ffdc6c-3cc9-4a43-bbfd-566e34905cf3\n\nThanks for your answers, GiudGiud. I have another simple question:\nin the computeQpJacobian of  TimeDerivative kernel: could 'du_dot_du' be replaced by '_phi[_j][_qp] * 1/dt' since the du_dot_du = d[(u-u_old)/dt]/du = _phi[_j][_qp] * 1/dt",
                          "url": "https://github.com/idaholab/moose/discussions/23263#discussioncomment-4795360",
                          "updatedAt": "2023-01-27T10:04:05Z",
                          "publishedAt": "2023-01-27T10:04:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not if you want to use other more complicated time integration schemes.\nIn general you want to use the dot routines to get XX_dot terms, they make sure the time derivative expression is the one consistent with the time integration scheme",
                          "url": "https://github.com/idaholab/moose/discussions/23263#discussioncomment-4799587",
                          "updatedAt": "2023-01-27T18:07:18Z",
                          "publishedAt": "2023-01-27T18:07:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "not if you want to use other more complicated time integration schemes. In general you want to use the dot routines to get XX_dot terms, they make sure the time derivative expression is the one consistent with the time integration scheme\n\nThanks a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/23263#discussioncomment-4812268",
                          "updatedAt": "2023-01-29T20:07:42Z",
                          "publishedAt": "2023-01-29T20:07:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}