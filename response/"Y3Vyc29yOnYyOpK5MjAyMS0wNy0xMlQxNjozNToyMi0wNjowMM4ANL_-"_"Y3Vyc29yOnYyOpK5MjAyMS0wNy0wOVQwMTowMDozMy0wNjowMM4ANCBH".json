{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNy0wOVQwMTowMDozMy0wNjowMM4ANCBH"
    },
    "edges": [
      {
        "node": {
          "title": "How to draw a stress-strain curve from a uni-axial traction simulation",
          "author": {
            "login": "Xelver"
          },
          "bodyText": "Hi, guys,\nI'm working on a simple uniaxial traction simulation for a 1mm x 1mm x 1mm cube with some randomly distributed defect elements inside, as:\n\nBecause there are some defects, the stress and strain in different elements are not the same. I've tried to get the average value on the surface or the whole cube, but the result seems wrong.\nIn Abaqus, we can set a reference point and couple the point with the traction surface. Then we can obtain the displacement and the reaction force of the reference point to calculate the stress-strain curve.  So I am wondering whether MOOSE has a similar function.\nThanks for your answers",
          "url": "https://github.com/idaholab/moose/discussions/18241",
          "updatedAt": "2022-07-25T08:01:15Z",
          "publishedAt": "2021-07-02T08:58:23Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "What do you mean \"the result seems wrong\"?  Usually you plot average stress vs average strain (which you can get using a couple of Postprocessors).  The average stress is equal to (average) surface traction, so you could use that instead.  The average strain is equal to (average) surface displacement, so you could use that instead.   Obviously you have to choose the relevant components of stress and strain.\nPerhaps the result \"looks wrong\" because you're incorrectly normalising using the void volume?",
                  "url": "https://github.com/idaholab/moose/discussions/18241#discussioncomment-956062",
                  "updatedAt": "2022-07-25T08:01:13Z",
                  "publishedAt": "2021-07-02T10:05:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Xelver"
                          },
                          "bodyText": "Thanks for your answer.\nI had used ElementAverageValue to get average stress and average strain, but the curve I had got was exactly the same as the cube without the defects. (Normally the slope should be lower).  I think it's because the ElementAverageValue doesn't count the volume of the defect.\nSo I used another method.  I didn't delete the defect elements, instead, I put them into a subdomain and assigned them a very small Young's modules\uff080.001\uff09 and poisons ratio \uff081e-11\uff09.  The slope changed with this method, but it still wasn't what I wanted.  Normally the Young's modulus of a cube (430GPa, 0.2) with 10% voids is about 352 GPa ( I've got the same result with ABAQUS), but here I've got 370 GPa.",
                          "url": "https://github.com/idaholab/moose/discussions/18241#discussioncomment-967920",
                          "updatedAt": "2022-07-25T08:01:13Z",
                          "publishedAt": "2021-07-06T01:08:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Firstly, i'd check your boundary conditions - load the result into paraview and check that the cube \"moves\" in roughly the same way as ABAQUS.  You're getting a stiffer result, so maybe the MOOSE model is more constrained than the ABAQUS one.\nSecondly, you could easily be using different shape functions in ABAQUS and MOOSE.  If you use linear-lagrange (the default in MOOSE) then you'll get a stiffer result because the solid material can't deform accurately around a 1-element void.  That's a bit hard to explain - tell me if you don't understand.\nYou're correct about the ElementAverageValue : it simply averages over the elements.",
                          "url": "https://github.com/idaholab/moose/discussions/18241#discussioncomment-967945",
                          "updatedAt": "2022-07-25T08:01:12Z",
                          "publishedAt": "2021-07-06T01:21:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Xelver"
                          },
                          "bodyText": "The boundary conditions are\n\ndisp_x = 0, left\ndisp_y = 0, bottom\ndisp_z = 0, back\ndisp_y = f, top (1e-6 m at 10 s)\nI've used the same boundary conditions for ABAQUS.\n\nYes, I used the default option as follows.  I'll try to use higher-order later. But I'm not very clear about it. Could you please explain a little bit if it doesn't trouble you?\n[Modules/TensorMechanics/Master]\n  [./all]\n    add_variables = true\n    strain = FINITE\n    #incremental = true\n    generate_output = 'vonmises_stress stress_yy strain_yy'\n    use_displaced_mesh = true\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18241#discussioncomment-968190",
                          "updatedAt": "2022-07-25T08:01:58Z",
                          "publishedAt": "2021-07-06T03:20:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Xelver"
                          },
                          "bodyText": "Hey, I have tried using a higher-order elem_type with HEX20 and HEX27 with second-order-Lagrange variables. The resulted effective Young's modulus are 355 GPa (which is closer to ABAQUS result)  for HEX20 and 348 GPa for HEX27.",
                          "url": "https://github.com/idaholab/moose/discussions/18241#discussioncomment-972848",
                          "updatedAt": "2022-09-12T17:16:07Z",
                          "publishedAt": "2021-07-07T03:24:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Xelver\nIt's easy to plot stress-strain curves with paraview:\n\nClick on \"Select cell through\" (or \"f\" on keyboard)\nSelect the element at the boundary where you want the stress\nFilters > Extract Selection > Apply\nNow you will see only the selected elements\nFilters > Integrate Variables + tick \"Divide cell data by volume\" in the properties tab > Apply\nIn the spreadsheet on the right you will see the average quantities, select Attribute > Cell Data\nand you will see your average stress.\nIf you want to plot the stress as a function of time, you can select the line in the spreadsheet,\nthen Filters > Plot Selection over time\nYou will see all Cell Quantities as a function of time, averaged over the selected element.\nBecause you can see the selected elements, making mistakes is very unlikely.\n\nTrust this helps,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/18241#discussioncomment-957599",
                  "updatedAt": "2022-07-25T08:01:58Z",
                  "publishedAt": "2021-07-02T16:16:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Xelver"
                          },
                          "bodyText": "Thanks for your answer.\nIt really helps. But I want to obtain the curve of the entire object or the \"equivalent young's modulus\" of the object .\nI used your method to get the average value of the cube, the results were as same as using postprocessors ElementAverageValue.  So I thought that it may not be the average value that we should use to draw the stress-strain curve?",
                          "url": "https://github.com/idaholab/moose/discussions/18241#discussioncomment-967981",
                          "updatedAt": "2022-07-25T08:02:02Z",
                          "publishedAt": "2021-07-06T01:37:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @Xelver\nGetting a stress-strain curve by averaging over all elements does not make a lot of sense to me.\nPhysically the stress is measured as average over a surface.\nI am not sure what you mean by \"equivalent Young's modulus\",\nif your material properties are homogeneous, the Young modulus will be the same everywhere anyway.\nIf you mean you want an effective Young modulus of the structure, which will be lower than Young modulus\nof the bulk because of the holes, then definitely average the stress on a surface.\nYou can repeat the operations on different surfaces and with different distribution of the holes\nto get more statistics\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18241#discussioncomment-968922",
                          "updatedAt": "2022-07-25T08:18:56Z",
                          "publishedAt": "2021-07-06T08:26:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Xelver"
                          },
                          "bodyText": "Dear @ngrilli\nI think that you're right.  I mean the effective Young modulus of the structure.\nSo I tried to get the stress on different surfaces with different distributions of the holes.  The boundary conditions are\ndisp_x = 0, left\ndisp_y = 0, bottom\ndisp_z = 0, back\ndisp_y = f, top (1e-6 m at 10 s)\nThe average stress of the bottom and the top kept pretty much unchanged with different distribution of the holes, while the average stress of the other surfaces changed a lot with the different distribution.  So I'm not sure which could be used to calculate the effective Young's modulus.",
                          "url": "https://github.com/idaholab/moose/discussions/18241#discussioncomment-969714",
                          "updatedAt": "2022-07-25T08:18:56Z",
                          "publishedAt": "2021-07-06T11:46:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "Hi @Xelver,\nIf you would like to determine the effective Young's modulus of the complete structure, you may also find the Asymptotic Expansion Homogenization capabilities useful, particularly the AsymptoticExpansionHomogenizationElasticConstants postprocessor and the associated kernels--links to documentation on the kernels are given on the postprocessor page. More details about this approach are available in Hales et al.(2015).",
                  "url": "https://github.com/idaholab/moose/discussions/18241#discussioncomment-995465",
                  "updatedAt": "2022-07-25T08:18:59Z",
                  "publishedAt": "2021-07-12T19:36:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Dynamic loading for multiApps",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "Hello,\nI am running into an issue when trying to run multiapps. I have my main app called mole and the subapp called SAM. SAM uses git submodule for MOOSE and has it located in its main directory. I have set my MOOSE_DIR path for both SAM and mole to point to the git submodule for MOOSE in SAM. I have built both codes using this MOOSE directory. Both codes compile and are able to run independently. I have a simple input file which uses the mutliapps block to call SAM from mole.\n[MultiApps]\n  [sam]\n    type = FullSolveMultiApp\n    app_type = SAMApp\n    input_files = 'sam_pipe.i'\n    execute_on = 'INITIAL'\n  []\n[]\n\nI have tried two ways of setting the library path. First by setting library_path in the MultiApps block to the SAM lib. Second by exporting the MOOSE_LIBRARY_PATH to the SAM lib folder. Both of these methods lead to the same error, shown below.\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/tensor_mechanics/lib/libtensor_mechanics-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/ray_tracing/lib/libray_tracing-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/heat_conduction/lib/libheat_conduction-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/ray_tracing/lib/libray_tracing-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/fluid_properties/lib/libfluid_properties-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/module_loader/lib/libmodule_loader_with_fp_ray_hc_tm-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/tensor_mechanics/lib/libtensor_mechanics-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/ray_tracing/lib/libray_tracing-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/heat_conduction/lib/libheat_conduction-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/ray_tracing/lib/libray_tracing-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/moose/modules/fluid_properties/lib/libfluid_properties-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** Warning ***\nUnable to find extern \"C\" method \"SAMApp__registerApps\" in library: /Users/qt5/Desktop/coding/projects/SAM/lib/libsam-dbg.0.dylib.\nThis doesn't necessarily indicate an error condition unless you believe that the method should exist in that library.\n\n*** ERROR ***\nUnable to locate library for \"SAMApp\".\nWe attempted to locate the library \"libsam-dbg.la\" in the following paths:\n\nMake sure you have compiled the library and either set the \"library_path\" variable in your input file or exported \"MOOSE_LIBRARY_PATH\".\nCompiled in debug mode to see the list of libraries checked for dynamic loading methods.```",
          "url": "https://github.com/idaholab/moose/discussions/18217",
          "updatedAt": "2022-06-26T09:19:28Z",
          "publishedAt": "2021-06-30T19:14:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "rwcarlsen"
                  },
                  "bodyText": "From those warnings, it is clear that libsam is being correctly discovered and searched.  But there should be an extern C (exported) function like this: \n  \n    \n      moose/test/src/base/MooseTestApp.C\n    \n    \n         Line 125\n      in\n      d4a83b1\n    \n  \n  \n    \n\n        \n          \n           MooseTestApp__registerApps() \n        \n    \n  \n\n.  Can you confirm such functions exist for SamApp?",
                  "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-951420",
                  "updatedAt": "2022-06-26T09:19:55Z",
                  "publishedAt": "2021-07-01T17:45:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "Im not familiar with these lines of code from that file you mentioned.\nextern \"C\" void\nMooseTestApp__registerAll(Factory & f, ActionFactory & af, Syntax & s)\n{\n  MooseTestApp::registerAll(f, af, s);\n}\n\n// External entry point for dynamic application loading\nextern \"C\" void\nMooseTestApp__registerApps()\n{\n  MooseTestApp::registerApps();\n}\n\nIve never see it in any documentation or in the MOOSE tutorials. Can you provide more information on them?",
                          "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-951455",
                          "updatedAt": "2022-06-26T09:19:55Z",
                          "publishedAt": "2021-07-01T17:58:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rwcarlsen"
                          },
                          "bodyText": "We don't say too much about them because the stork templates we provide for people to create new apps with automatically include/provide these functions.  Users generally should never need to do anything with them.  But it's possible these functions were inadvertently removed from SAM.  If there are not similar functions in SAM, then this pattern will need to be followed to add them back (in the SAMApp.C file).  i.e. add back SAMApp__registerApps() {SAMApp::registerApps();} and SAMApp__registerAll(...) {SAMApp::registerAll(...);}",
                          "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-951585",
                          "updatedAt": "2022-06-26T09:20:05Z",
                          "publishedAt": "2021-07-01T18:33:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "These functions are in SAMApp.C",
                          "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-951627",
                          "updatedAt": "2022-06-26T09:20:06Z",
                          "publishedAt": "2021-07-01T18:45:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rwcarlsen"
                          },
                          "bodyText": "Hmmm...  That's too bad because that would have been an easy fix.  Maybe @permcody has some ideas.  I know that there have been some issues related to dynamic library loading for us on macs.",
                          "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-953045",
                          "updatedAt": "2022-07-08T07:20:38Z",
                          "publishedAt": "2021-07-01T19:34:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "I am running on a mac, Big Sur version 11.4. What issues are there on the macs?",
                          "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-953141",
                          "updatedAt": "2022-07-08T07:20:38Z",
                          "publishedAt": "2021-07-01T20:03:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rwcarlsen"
                          },
                          "bodyText": "Your issue doesn't seem to be the same as some of the other ones, but if you just search our issues for \"dynamic loading\" you'll find several.  Some to do with path handling, some to do with inter-module dependencies, some to do with crashes, etc.  Have you tried running your scenario/setup on a linux system?  Does it work there or do you observe the same problem?",
                          "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-953198",
                          "updatedAt": "2022-07-08T07:20:37Z",
                          "publishedAt": "2021-07-01T20:19:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "So i do get this same error when i try to run on linux.",
                          "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-970622",
                          "updatedAt": "2022-07-08T07:20:37Z",
                          "publishedAt": "2021-07-06T15:02:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrsd"
                          },
                          "bodyText": "Your error message is complaining about SAMApp__registerApps, but SAM implemented SamApp__registerApps, SamApp__registerAll and SamApp__registerObjects.\nProbably you want to change app_type = SAMApp to app_type = SamApp. These things are case-sensitive.",
                          "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-979578",
                          "updatedAt": "2022-07-08T07:20:37Z",
                          "publishedAt": "2021-07-08T13:42:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "Wow, i feel dumb now. This fixed the issue. Thank you for the help.",
                          "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-980738",
                          "updatedAt": "2022-07-08T07:20:37Z",
                          "publishedAt": "2021-07-08T17:43:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrsd"
                          },
                          "bodyText": "Cool! Glad to hear that. Maybe, ping the SAM developers to they make spelling of SAM consistent thought out the code. Sometimes that use SAM, sometimes they use Sam. Then, it leads to problems like this.",
                          "url": "https://github.com/idaholab/moose/discussions/18217#discussioncomment-995257",
                          "updatedAt": "2022-07-08T07:20:37Z",
                          "publishedAt": "2021-07-12T18:41:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "a question about \u201cAnistropic mobility\u201d or Interface Orientation",
          "author": {
            "login": "dongcongcong606"
          },
          "bodyText": "Dear friends\uff01\nHi everyone, I have a question about the code of \"anistropy\". I would like to know how to introduce anisotropic mobility into the phase field model in Moose. And I read some file  such as \"InterfaceOrienation.c\" \u3001\"ADInterfaceOrienationMaterial.c\" . But I don't know which of these two models is a better model for anisotropic mobility. And why the \"Orientation angle\" in terms of acos rather than atan? I am very grateful to all the friends and experts present here for giving me directions. Thanks again!",
          "url": "https://github.com/idaholab/moose/discussions/18016",
          "updatedAt": "2022-06-16T03:02:17Z",
          "publishedAt": "2021-06-07T08:50:56Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hello- the InterfaceOrientationMaterial is to account for anisotropic interfacial energy rather than anisotropic order parameter mobility. So, you do not want to use this material if you want to include anisotropic mobility in the Allen-Cahn equation. If you want a similar 2-D anisotropy as described in the Kobayashi paper, you would need to create a new material that would be very similar to InterfaceOrientationMaterial. However, rather than eps, you would want to create a material property called L (for example) that could be supplied to the mob_name parameter in the AllenCahn and ACInterface kernels (also make sure to also specify variable_L = true to ACInterface).",
                  "url": "https://github.com/idaholab/moose/discussions/18016#discussioncomment-841492",
                  "updatedAt": "2022-06-16T03:02:19Z",
                  "publishedAt": "2021-06-08T18:08:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dongcongcong606"
                          },
                          "bodyText": "Thank you very much. I obey your suggestion to define a new material named \"ADANisotropicFirst\"  in the following file, and I also introduce an anisotropic function to represent \"mobility\" \uff0cand whether I am supposed to adjust or even define a new kernel like \u201cKobayashi1\u201d to describe my own Jacobian codes \uff1fPlease forgive me for my shallow knowledge. I would like to express my gratitude again here.",
                          "url": "https://github.com/idaholab/moose/discussions/18016#discussioncomment-895675",
                          "updatedAt": "2022-06-16T03:02:32Z",
                          "publishedAt": "2021-06-21T03:34:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "If you use the AD versions of the other kernels, you won't need to code the Jacobians, they will be calculated automatically.",
                          "url": "https://github.com/idaholab/moose/discussions/18016#discussioncomment-940182",
                          "updatedAt": "2022-06-16T03:02:32Z",
                          "publishedAt": "2021-06-29T20:30:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dongcongcong606"
                          },
                          "bodyText": "If you use the AD versions of the other kernels, you won't need to code the Jacobians, they will be calculated automatically.\nthank you very much",
                          "url": "https://github.com/idaholab/moose/discussions/18016#discussioncomment-992214",
                          "updatedAt": "2022-06-16T03:02:32Z",
                          "publishedAt": "2021-07-12T06:58:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "SolutionUserObject and SolutionFunction for part of mesh",
          "author": {
            "login": "hsheldon"
          },
          "bodyText": "I have a situation where I need to read values (e.g. porosity) from an exodus file that covers only part of the simulated domain, using SolutionUserObject and SolutionFunction. Currently this results in an error because MOOSE is trying to read values from a region that doesn't exist in the exodus file. Am I missing some way of getting round this? If not it would be useful to have the option to do this, with the ability to specify a default value where none exists.",
          "url": "https://github.com/idaholab/moose/discussions/18250",
          "updatedAt": "2022-07-26T13:18:13Z",
          "publishedAt": "2021-07-04T21:46:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nhappy 4th of July!\nthe way of getting around this is to reload the variable in a multi app with the same mesh as the previous solution, then use a transfer to move the porosity to your simulation. You can execute this multi app at INITIAL, just once\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18250#discussioncomment-964073",
                  "updatedAt": "2022-07-26T13:18:27Z",
                  "publishedAt": "2021-07-05T03:46:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Ha, clever!",
                          "url": "https://github.com/idaholab/moose/discussions/18250#discussioncomment-964085",
                          "updatedAt": "2022-07-26T13:18:31Z",
                          "publishedAt": "2021-07-05T03:51:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "Interesting. Don't suppose there's an example somewhere that would give me some idea how to do this? I haven't played with multi apps before.",
                          "url": "https://github.com/idaholab/moose/discussions/18250#discussioncomment-964244",
                          "updatedAt": "2022-07-26T13:18:32Z",
                          "publishedAt": "2021-07-05T05:28:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Create an input file that just reads the previous solution into an AuxVariable called phi_from_exodus.  This probably doesn't need to have any PorousFlow stuff in it.  Call this input file \"subapp.i\"\nThen, in your regular input file (the one that does the PorousFlow simulation) have an AuxVariable called porosity_aux, and simply include the following at the bottom of the file:\n[MultiApps]\n  [define_porosity]\n    type = TransientMultiApp\n    input_files = subapp.i\n    execute_on = INITIAL\n  []\n[]\n\n[Transfers]\n  [populate_porosity]\n    type = MultiAppInterpolationTransfer\n    direction = from_multiapp\n    multi_app = define_porosity\n    source_variable = phi_from_exodus\n    variable = porosity_aux\n  []\n[]\n\nThe MultiAppInterpolationTransfer has some other options you might like to use (see the doco)",
                          "url": "https://github.com/idaholab/moose/discussions/18250#discussioncomment-964278",
                          "updatedAt": "2022-07-26T13:18:35Z",
                          "publishedAt": "2021-07-05T05:46:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There s a dedicated multi app example on the mooseframeworks doc website. (I think, it got merged 2 weeks ago iirc). Should be in the main tabs\nIn the subapp input file, you can add solve=false and kernel_coverage_check=false in the Problems block to reduce the number of things to provide to make it a valid input file.",
                          "url": "https://github.com/idaholab/moose/discussions/18250#discussioncomment-964288",
                          "updatedAt": "2023-05-09T18:59:49Z",
                          "publishedAt": "2021-07-05T05:51:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "I got it working with MultiAppMeshFunctionTransfer. Thanks for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/18250#discussioncomment-991814",
                          "updatedAt": "2023-05-09T19:00:12Z",
                          "publishedAt": "2021-07-12T03:55:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "It is a bit of a messy solution though. It would be sooo much simpler if SolutionFunction could handle a partial mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/18250#discussioncomment-991818",
                          "updatedAt": "2023-05-09T19:01:04Z",
                          "publishedAt": "2021-07-12T03:58:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "sideset cannot generate from nodeset",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "Hi,\nI have a strip with a meshed-in crack on the left in the centerline. I first defined two pieces of mesh for the top and bottom half and then stitched them together in the middle outside the crack. Then I want to redefine the two boundaries at the crack to have a closed sideset for later use. I have set construct_side_list_from_node_list = true, but there is no side sets generated from new boundaries. Please tell me what to do.\n[Mesh]\n  [top_half]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 94 #750/8\n    ny = 16 #125\n    xmax = 30 #30\n    ymin = 0\n    ymax = 5 #5\n    boundary_id_offset = 0\n    boundary_name_prefix = top_half\n  []\n  [top_nonstitch]\n    type = BoundingBoxNodeSetGenerator\n    input = top_half\n    new_boundary = top_nonstitch\n    bottom_left = '0 0 0' #5\n    top_right = '5 0 0' #30\n    show_info = true\n  []\n  [top_stitch]\n    type = BoundingBoxNodeSetGenerator\n    input = top_nonstitch\n    new_boundary = top_stitch\n    bottom_left = '5 0 0' #5\n    top_right = '30 0 0' #30\n    show_info = true\n  []\n  [bottom_half]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 94 #0\n    ny = 16 #5\n    xmax = 30 #0\n    ymin = -5\n    ymax = 0\n    boundary_id_offset = 7\n    boundary_name_prefix = bottom_half\n  []\n  [bottom_nonstitch]\n    type = BoundingBoxNodeSetGenerator\n    input = bottom_half\n    new_boundary = bottom_nonstitch\n    bottom_left = '0 0 0'\n    top_right = '5 0 0'\n    show_info = true\n  []\n  [bottom_stitch]\n    type = BoundingBoxNodeSetGenerator\n    input = bottom_nonstitch\n    new_boundary = bottom_stitch\n    bottom_left = '5 0 0'\n    top_right = '30 0 0'\n    show_info = true\n  []\n  [stitch]\n    type = StitchedMeshGenerator\n    inputs = 'top_stitch bottom_stitch'\n    stitch_boundaries_pairs = 'top_stitch bottom_stitch'\n    show_info = true\n  []\n  construct_side_list_from_node_list = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/18298",
          "updatedAt": "2022-07-20T19:08:27Z",
          "publishedAt": "2021-07-09T22:52:16Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\ncan you add show_info = true to the last mesh generator in the chain?\nThat will show what sidesets are being created\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-987038",
                  "updatedAt": "2022-07-20T19:08:39Z",
                  "publishedAt": "2021-07-09T23:02:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "I think I did. It is in '[stitch]'. Or is that not the last generator?",
                          "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-987047",
                          "updatedAt": "2022-07-20T19:08:40Z",
                          "publishedAt": "2021-07-09T23:06:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh can you paste the output then please",
                          "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-987068",
                          "updatedAt": "2022-07-20T19:08:40Z",
                          "publishedAt": "2021-07-09T23:18:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m Mesh Information:\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  elem_dimensions()={2}\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  spatial_dimension()=2\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  n_nodes()=3151\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m    n_local_nodes()=3151\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  n_elem()=3008\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m    n_local_elem()=3008\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m    n_active_elem()=3008\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  n_subdomains()=1\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  n_partitions()=1\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  n_processors()=1\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  n_threads()=1\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  processor_id()=0\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  is_prepared()=true\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  is_replicated()=true\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m Mesh Bounding Box:\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Minimum: (x,y,z)=(       0,       -5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Delta:   (x,y,z)=(      30,       10,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m Mesh Element Type(s):\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  QUAD4\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m Mesh Nodesets:\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 0 (top_half_bottom), 95 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 1 (top_half_right), 17 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 2 (top_half_top), 95 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 3 (top_half_left), 17 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 4, 16 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=( 4.78723,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=( 4.78723,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 5, 79 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=( 5.10638,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=( 24.8936,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 7 (bottom_half_bottom), 95 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,       -5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,       -5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 8 (bottom_half_right), 17 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(      30,       -5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 9 (bottom_half_top), 95 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 10 (bottom_half_left), 17 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,       -5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 11, 16 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=( 4.78723,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=( 4.78723,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Nodeset 12, 79 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=( 5.10638,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=( 24.8936,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m Mesh Sidesets:\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Sideset 0 (top_half_bottom), 94 sides (EDGE2), 94 elems (QUAD4), 95 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Side volume: 30\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Sideset 1 (top_half_right), 16 sides (EDGE2), 16 elems (QUAD4), 17 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Side volume: 5\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Sideset 2 (top_half_top), 94 sides (EDGE2), 94 elems (QUAD4), 95 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Side volume: 30\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Sideset 3 (top_half_left), 16 sides (EDGE2), 16 elems (QUAD4), 17 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Side volume: 5\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Sideset 7 (bottom_half_bottom), 94 sides (EDGE2), 94 elems (QUAD4), 95 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Side volume: 30\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,       -5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,       -5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Sideset 8 (bottom_half_right), 16 sides (EDGE2), 16 elems (QUAD4), 17 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Side volume: 5\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(      30,       -5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Sideset 9 (bottom_half_top), 94 sides (EDGE2), 94 elems (QUAD4), 95 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Side volume: 30\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Sideset 10 (bottom_half_left), 16 sides (EDGE2), 16 elems (QUAD4), 17 nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Side volume: 5\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,       -5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m Mesh Edgesets:\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  None\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m Mesh Subdomains:\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Subdomain 0: 3008 elems (QUAD4, 3008 active), 3151 active nodes\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Volume: 300\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,       -5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,       10,        0)\n\ufffd[36mStitchedMeshGenerator 'stitch': \ufffd[39m  Global mesh volume = 300",
                          "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-987083",
                          "updatedAt": "2022-07-20T19:08:41Z",
                          "publishedAt": "2021-07-09T23:26:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so none of the desired sidesets are generated it seems?\nAre they generated before the stitch and destroyed by the stitch or are they never generated? (place show_info in an earlier generator to check)",
                          "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-989285",
                          "updatedAt": "2024-01-23T05:00:53Z",
                          "publishedAt": "2021-07-10T23:02:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "here is what happened in [top_nonstitch], an object before [stitch]",
                          "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-991051",
                          "updatedAt": "2024-01-23T05:00:53Z",
                          "publishedAt": "2021-07-11T20:08:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m Mesh Information:\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  elem_dimensions()={2}\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  spatial_dimension()=2\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  n_nodes()=1615\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m    n_local_nodes()=1615\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  n_elem()=1504\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m    n_local_elem()=1504\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m    n_active_elem()=1504\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  n_subdomains()=1\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  n_partitions()=1\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  n_processors()=1\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  n_threads()=1\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  processor_id()=0\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  is_prepared()=true\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  is_replicated()=true\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m Mesh Bounding Box:\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Delta:   (x,y,z)=(      30,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m Mesh Element Type(s):\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  QUAD4\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m Mesh Nodesets:\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Nodeset 0 (top_half_bottom), 95 nodes\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Nodeset 1 (top_half_right), 17 nodes\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Nodeset 2 (top_half_top), 95 nodes\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Nodeset 3 (top_half_left), 17 nodes\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(       0,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Nodeset 4, 16 nodes\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box maximum: (x,y,z)=( 4.78723,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box delta: (x,y,z)=( 4.78723,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m Mesh Sidesets:\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Sideset 0 (top_half_bottom), 94 sides (EDGE2), 94 elems (QUAD4), 95 nodes\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Side volume: 30\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Sideset 1 (top_half_right), 16 sides (EDGE2), 16 elems (QUAD4), 17 nodes\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Side volume: 5\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(      30,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Sideset 2 (top_half_top), 94 sides (EDGE2), 94 elems (QUAD4), 95 nodes\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Side volume: 30\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Sideset 3 (top_half_left), 16 sides (EDGE2), 16 elems (QUAD4), 17 nodes\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Side volume: 5\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(       0,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box delta: (x,y,z)=(       0,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m Mesh Edgesets:\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  None\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m Mesh Subdomains:\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Subdomain 0: 1504 elems (QUAD4, 1504 active), 1615 active nodes\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Volume: 150\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box maximum: (x,y,z)=(      30,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m   Bounding box delta: (x,y,z)=(      30,        5,        0)\n\ufffd[36mBoundingBoxNodeSetGenerator 'top_nonstitch': \ufffd[39m  Global mesh volume = 150",
                          "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-991053",
                          "updatedAt": "2024-01-23T05:00:53Z",
                          "publishedAt": "2021-07-11T20:09:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "from the output it seems like the sidesets were never generated. but when I apply boundary condition to these new boundaries, it was successful.",
                          "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-991055",
                          "updatedAt": "2022-09-14T15:49:52Z",
                          "publishedAt": "2021-07-11T20:13:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "[bottom_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = bottom_half_bottom\n    function = bc_func\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-991058",
                          "updatedAt": "2022-09-14T15:49:55Z",
                          "publishedAt": "2021-07-11T20:13:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'm guessing that's because the construct_side_list_from_node_list step is not applied until all mesh generators are done. You can't assume those nodesets to be sidesets in mesh generators.\n@GiudGiud It's probably not a bad idea to add a ConstructSidesetsFromNodesetsGenerator.",
                          "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-991095",
                          "updatedAt": "2022-09-14T15:49:55Z",
                          "publishedAt": "2021-07-11T20:32:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@hugary1995 I think that is a potential bug yeah. Though the nodesets are present after the final mesh generators, so the sidesets should have been created??\nThe boundaries reported for sideset 4 are odd though. I think there is some finite precision comparison failures going on there. Like I would expect to see 5 0 0 as the maximum\nCould you please try generating those sidesets another way?\nEither of these, SideSetsBetweenSubdomainsGenerator\nSideSetsFromBoundingBoxGenerator\nSideSetsFromNormalsGenerator\nSideSetsFromPointsGenerator\ncould do the trick in my opinion\nNote: the boundary condition you pasted worked fine because it depends on the output of a GeneratedMeshGenerator, not on any of the nodesets created",
                          "url": "https://github.com/idaholab/moose/discussions/18298#discussioncomment-991630",
                          "updatedAt": "2022-09-14T15:49:55Z",
                          "publishedAt": "2021-07-12T02:04:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stiffness tensor of void or bubble when coupling elastic energy",
          "author": {
            "login": "wenpeng231024"
          },
          "bodyText": "Dear MOOSE group,\nI try to add elastic energy in our model of void or bubble evolution in the matrix as Aagesen's paper (Aagesen, 2017, Quantifying elastic energy effects on interfacial energy in the Kim-Kim-Suzuki phase-field model with different interpolation schemes).\nhttps://www.sciencedirect.com/science/article/pii/S0927025617304111\nHowever, I am a little confused about how to set the void/bubble stiffness tensor. I found most papers assuming the stiffness tensor of gas bubbles is the same as the matrix. Does this make sense? The stress due to the eigenstrain is constant. But the elastic strain should be different on the interface using different stiffness tensors of gas bubbles. And the stress in the matrix caused by the void/bubble should be also different.\nSo my question is that how to select the stiffness tensor of void/bubble when we use eigenstrain to develop stress in the matrix caused by the void/bubble?\nI also show some relevant papers here.\nLi, Nuclear Instruments and Methods in Physics Research B 303 (2013) 62\u201367.\nHu, Journal of Nuclear Materials 392 (2009) 292\u2013300.\nXiao, Computational Materials Science 184 (2020) 109867.\nThanks,\nPeng",
          "url": "https://github.com/idaholab/moose/discussions/18288",
          "updatedAt": "2022-06-11T08:50:06Z",
          "publishedAt": "2021-07-08T13:32:09Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen",
                  "url": "https://github.com/idaholab/moose/discussions/18288#discussioncomment-980803",
                  "updatedAt": "2022-06-11T08:50:33Z",
                  "publishedAt": "2021-07-08T18:01:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Hi Peng, to use the eigenstrain approach to simulate gas bubble pressure, I think it's fine to use the bubble stiffness tensor to be the same as the matrix. What you are doing is using an inclusion to mimic the effect of the gas pressure, which can result in a non-zero stress experienced by the matrix outside of the bubble. (The pressure felt outside the bubble is actually given by the difference between the gas bubble pressure and the surface tension. This is not considered in either of the two earlier works you mentioned, but it is considered in the 2020 paper.) So using the eigenstrain approach will allow you to consider a bubble with a fixed overpressure or underpressure relative to surface tension. (For an equilbrium bubble, or a bubble whose pressure is exactly balanced by surface tension, there is no stress felt outside the bubble.) So the bubble phase elastic constant do not physically represent the actual elastic constants of the gas phase; this is sort of a trick to mimic the effect of the gas pressure on the surrounding matrix. This approach has some disadvantages, such as inaccurate response to applied loads.",
                          "url": "https://github.com/idaholab/moose/discussions/18288#discussioncomment-981828",
                          "updatedAt": "2022-06-11T08:50:34Z",
                          "publishedAt": "2021-07-09T00:00:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wenpeng231024"
                          },
                          "bodyText": "Hi Larry,\nThanks so much for your reply. If I understand correctly, that means the calculated total stress or elastic stress inside the bubble is meaningless. Because we just care about the stress in the matrix around the bubble.\nActually, I try to test using different elastic constants of gas bubble. I found when I use VTS interpolation scheme (assuming the total strain is the same for both phases on the interface) to add the elastic energy, a larger elastic stress is obtained in the matrix around the bubble using a smaller elastic constants of gas bubble. Because, although the pressure in the bubble is a constant. But a larger total strain (Total strain = elastic strain - eigenstrain) for bubble is obtained when using a smaller stiffness of gas bubble. (For gas, it seems more reasonable to use a smaller elastic modulus.) This larger total strain in the bubble leads to a larger strain in the matrix through the interface due to the continuum assumption.\nSo how can we remove this stress difference in the matrix due to the selected of the stiffness of gas bubble? Maybe it's better to use KHS scheme? Because it assume the stress is the same for both phases on the interface. Or we can ignore this effect if this difference is not very large.\nYou mentioned this approach is inaccurate response to applied stress in the matrix. This is exactly what I am doing. Can you show more about this? I use \"ADPressure\" boundary conditions to add applied stress in the matrix. Then, I compared the stress in the matrix around the bubble between adding applied stress case and no applied stress case. Their difference is approximately the applied stress. Does this indicate the eigenstrain approach works for applied loading?\nMany thanks,\nPeng",
                          "url": "https://github.com/idaholab/moose/discussions/18288#discussioncomment-982003",
                          "updatedAt": "2022-06-11T08:50:35Z",
                          "publishedAt": "2021-07-09T01:27:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Hm that is interesting. I do think that seems reasonable for the applied stress case, for what you are looking at (the stress in the matrix). I was thinking more about applying a load and looking at the total displacement in response to that load, for example. If you apply a fixed load, for the case of a void, physically there is nothing to resist the applied load, so you would expect a larger total displacement than for the simulations where you mimic the effect of a void with the eigenstrain approach, because the void is represented by a region of material that has the same elastic constant as the matrix and therefore significantly resists the applied load.",
                          "url": "https://github.com/idaholab/moose/discussions/18288#discussioncomment-987005",
                          "updatedAt": "2022-06-11T08:51:01Z",
                          "publishedAt": "2021-07-09T22:41:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wenpeng231024"
                          },
                          "bodyText": "Yes, I agree with you about the void.\nI think the elastic constants of void/bubble should affect the stress in the matrix. And the applied loading maybe enlarge this effect.\nThanks,\nPeng",
                          "url": "https://github.com/idaholab/moose/discussions/18288#discussioncomment-991065",
                          "updatedAt": "2022-06-11T08:51:15Z",
                          "publishedAt": "2021-07-11T20:18:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Frictional contact",
          "author": {
            "login": "samyogshr"
          },
          "bodyText": "Hi Moose users,\nI am modeling a 3D structural dynamics problem (using Hex8 elements) with frictional contact (penalty formulation) in MOOSE. The analysis converges and displacements look fine. But, there are spikes (high frequency oscillation at few time-steps) in acceleration output at some nodes in the slave and master surfaces (specially prominent at corners). I came across a few parameters in the contact block that were previously suggested in previous discussions, e.g., tangential_tolerance, normal_smooting_distance etc.\nHas anybody else experienced similar problem? Does anybody know if using these parameters will help?\nI also couldn't find information on what it means by defining tangential_tolerance = 1e-5 compared to 1e-3 for example. Could somebody please explain or provide a good reference?\nThank you,\nSamyog",
          "url": "https://github.com/idaholab/moose/discussions/17264",
          "updatedAt": "2022-11-07T13:11:46Z",
          "publishedAt": "2021-03-09T22:13:06Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dzheng26"
                  },
                  "bodyText": "@samyogshr , I cannot really help you since I'm also trying to use the 3D frictional contact. I cannot even get it converge for my example. Could you post your .i file here so that it may help me get my example converged first. Many Thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/17264#discussioncomment-484582",
                  "updatedAt": "2022-11-07T13:11:46Z",
                  "publishedAt": "2021-03-15T15:49:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "samyogshr"
                          },
                          "bodyText": "@dzheng-conti , hope you have resolved it by now. Sorry for late reply.\nContact block in my input file. I have 5 surfaces in contact and using 8-noded brick elements.\n[Contact]\n[./base]\nsecondary = 10006\nprimary = 105\nmodel = coulomb\nformulation = penalty\nnormalize_penalty = true\nfriction_coefficient = 0.2\ntangential_tolerance = 1e-5\npenalty = 1e4\nnormal_smoothing_distance = 0.1\n[../]\n[./side2]\nsecondary = 10008\nprimary = 107\nmodel = coulomb\nformulation = penalty\nnormalize_penalty = true\nfriction_coefficient = 0.2\ntangential_tolerance = 1e-5\npenalty = 1e4\nnormal_smoothing_distance = 0.1\n[../]\n[./side3]\nsecondary = 10010\nprimary = 109\nmodel = coulomb\nformulation = penalty\nnormalize_penalty = true\nfriction_coefficient = 0.2\ntangential_tolerance = 1e-5\npenalty = 1e4\nnormal_smoothing_distance = 0.1\n[../]\n[./side4]\nsecondary = 10012\nprimary = 111\nmodel = coulomb\nformulation = penalty\nnormalize_penalty = true\nfriction_coefficient = 0.2\ntangential_tolerance = 1e-5\npenalty = 1e4\nnormal_smoothing_distance = 0.1\n[../]\n[./side5]\nsecondary = 10014\nprimary = 113\nmodel = coulomb\nformulation = penalty\nnormalize_penalty = true\nfriction_coefficient = 0.2\ntangential_tolerance = 1e-5\npenalty = 1e4\nnormal_smoothing_distance = 0.1\n[../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/17264#discussioncomment-578031",
                          "updatedAt": "2022-11-07T13:11:46Z",
                          "publishedAt": "2021-04-07T05:32:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "Thanks for your help. I got my problem somewhat resolved. It converged but slowly. The contact works better with lower friction coefficient. In my case, the friction coefficient is 1.0",
                          "url": "https://github.com/idaholab/moose/discussions/17264#discussioncomment-687161",
                          "updatedAt": "2022-11-07T13:11:54Z",
                          "publishedAt": "2021-05-03T09:40:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc should be able to help",
                  "url": "https://github.com/idaholab/moose/discussions/17264#discussioncomment-495527",
                  "updatedAt": "2022-11-07T13:11:54Z",
                  "publishedAt": "2021-03-17T20:13:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "samyogshr"
                          },
                          "bodyText": "@bwspenc Could you please share your thoughts on this, thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/17264#discussioncomment-578035",
                          "updatedAt": "2022-11-07T13:11:54Z",
                          "publishedAt": "2021-04-07T05:36:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Sorry for coming into this way too late!  The tangential_tolerance parameter controls the distance (in the physical coordinates of your model) that the face is virtually extended beyond the edge. This helps in problems where you have two blocks that are in contact right along their edges. I'm not sure whether that would help your particular problem.\nTo prevent high-frequency noise, anything you can do to smooth the behavior of contact will help. normal_smoothing_distance should help somewhat with that, as would a lower friction coefficient, as you already found.",
                          "url": "https://github.com/idaholab/moose/discussions/17264#discussioncomment-987124",
                          "updatedAt": "2022-11-07T13:11:54Z",
                          "publishedAt": "2021-07-09T23:52:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "In addition to Ben's suggestions, you could also incorporate Rayleigh damping. You can use a higher damping coefficient near the contact surfaces.",
                          "url": "https://github.com/idaholab/moose/discussions/17264#discussioncomment-987254",
                          "updatedAt": "2022-11-07T13:11:55Z",
                          "publishedAt": "2021-07-10T01:34:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Populating aux. variable from a function",
          "author": {
            "login": "am-tc01"
          },
          "bodyText": "Hi,\nI want to update an auxiliary variable (T) using a function that is dependent on a variable I am solving for (u). The function should point to an input data file that has two columns, values of u in the first column and T in the second. Furthermore, I want to get the values on nodal points and not a volume-averaged value on elemental level. Is there a straightforward way to do it?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/18292",
          "updatedAt": "2022-07-07T04:43:44Z",
          "publishedAt": "2021-07-08T15:02:39Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou should look into AuxKernels to do this.\nIf the function from u to T is simple, you can use a ParsedAux\nIf not, you should modify derive from the SelfAux for your class. You will have to create your own as there are none that do this tabulation you need afaik.\nIf the AuxVariable is a nodal variable and so is u, that should not be a problem.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18292#discussioncomment-980142",
                  "updatedAt": "2022-07-07T04:43:44Z",
                  "publishedAt": "2021-07-08T15:23:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "Hi Guillaume\nThanks for the reply. Yes, I've been looking into Auxkernels but couldn't find any kernel that I could just use off-the-shelf. FunctionAux could be one but then I can only have a function of x,y,z or t. Also, the function form u to T is not simple so I have to read in the data from an input file.\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/18292#discussioncomment-982839",
                          "updatedAt": "2022-07-07T04:43:46Z",
                          "publishedAt": "2021-07-09T07:52:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "FunctionAux could work with a ParsedFunction for your application, but if the function is not simple then that would not work because you have to be able to write down the expression for it in the input file. If you are ok with a really long input file, you could use python to write the table in a functionalized 'if u in this interval etc' form.\nI think you've identified a need. If you want to implement this capability, I could see it either as an AuxKernel, something like PiecewiseConstantAux OR more naturally as an extension of the Piecewise-... functions, which would let you specify a variable in addition to the axis eg x,y,z,t",
                          "url": "https://github.com/idaholab/moose/discussions/18292#discussioncomment-985619",
                          "updatedAt": "2022-07-07T04:43:46Z",
                          "publishedAt": "2021-07-09T14:43:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow - Strain",
          "author": {
            "login": "MatiasAllay"
          },
          "bodyText": "Hi,\nWhy my RZ PorousFlow model converges nicely when the strain is computed with ComputeSmallStrain, but it does not with ComputeAxisymmetricRZSmallStrain? Is it correct to use ComputeSmallStrain with cylindrical coordinates? If not, how can I help MOOSE to converge using ComputeAxisymmetricRZSmallStrain?\nThanks again!\nMatias",
          "url": "https://github.com/idaholab/moose/discussions/18290",
          "updatedAt": "2023-02-05T14:41:05Z",
          "publishedAt": "2021-07-08T14:59:54Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "You must use ComputeAxisymmetricRZSmallStrain .   You've possibly omitted another \"RZ\" thing, or maybe your BCs are wrong.   Inspect the test files that have \"RZ\" in them and compare with yours.  I'd start with\n.test/tests/thm_rehbinder/fixed_outer_rz.i\nexamples/tutorial/11_2D. i\n\na",
                  "url": "https://github.com/idaholab/moose/discussions/18290#discussioncomment-981527",
                  "updatedAt": "2023-02-05T14:41:05Z",
                  "publishedAt": "2021-07-08T21:40:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "MatiasAllay"
                          },
                          "bodyText": "Thanks once again!",
                          "url": "https://github.com/idaholab/moose/discussions/18290#discussioncomment-982682",
                          "updatedAt": "2023-02-05T14:41:05Z",
                          "publishedAt": "2021-07-09T07:08:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Appropriate mesh file created in gmsh",
          "author": {
            "login": "Ali1990dashti"
          },
          "bodyText": "Dear community,\nI am new in using moose and want to import my mesh into moose. I am using an open source code developed on top of moose (called Tiger) to change my mesh from .msh file into a exodus file to visualize it in paraview. I created my mesh using gmsh. Then I used a syntax of Tiger to change the mesh (--mesh-only) but the result which I am seeing in paraview is completely different from what I created in gmsh. My mesh has two blocks and 7 surfaces (uploaded fig). I want to do THM modelling using mentioned code (Tiger) on the uploaded mesh file but I can see the mesh I created. I have no idea what is the problem of my mesh. How can I check if my mesh is correctly prepared for moose? I do appreciate any help in advance.\n\nmesh.zip",
          "url": "https://github.com/idaholab/moose/discussions/18106",
          "updatedAt": "2022-06-18T18:48:36Z",
          "publishedAt": "2021-06-17T09:57:50Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ajacquey"
                  },
                  "bodyText": "Hi Ali,\nIt would help if you share your .geo file you used to create the mesh with gmsh.\nWithout it, I can only give you some hints to check.\nFirst, did you set the physical blocks in the .geo file?\nIt is usually done with:\nPhysical Volume(0) = {1};\nPhysical Volume(1) = {2};\n\nwith 1 and 2 being the volume you creates and 0 and 1 being the block number that you can use in the moose input file.\nThen, you can do the same with the boundary surfaces:\nPhysical Surface(\"bottom\") = {1};\n\nHope it helps.",
                  "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883377",
                  "updatedAt": "2022-06-18T18:48:59Z",
                  "publishedAt": "2021-06-17T13:37:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ali1990dashti"
                          },
                          "bodyText": "Dear @ajacquey, I do not use .geo files to create my mesh. I am using python API of gmsh and my syntax is in python. If you open my msh file with gmsh, volumes and surfaces look fine, but I have no idea why moose is not reading them. If you have look at my mesh, you can see that I have  defined both my 2d and 3d Physical Names.",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883402",
                          "updatedAt": "2022-06-18T18:49:13Z",
                          "publishedAt": "2021-06-17T13:43:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ajacquey"
                          },
                          "bodyText": "Hi @Ali1990dashti ,\nYes, I can indeed see that the mesh has physical volumes and surfaces. The log message from moose reads fine when using the --mesh-only option.\nFrom paraview, I can only see the bottom part of your model in a volume representation. Any other representation yields nothing.\n\nMaybe there is something wrong in the top part of your model. I have never experienced this issue so I'm not sure I will be of any help.",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883473",
                          "updatedAt": "2022-06-18T18:49:12Z",
                          "publishedAt": "2021-06-17T13:58:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ajacquey"
                          },
                          "bodyText": "My bad, I think it's the top part of your model (block unit_3).\nThe issue might come from the basement block",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883483",
                          "updatedAt": "2022-06-18T18:49:31Z",
                          "publishedAt": "2021-06-17T13:59:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ali1990dashti"
                          },
                          "bodyText": "@ajacquey , Thanks for your help. Visualized section is the basement block. At least in my mesh it is the basement block. Another problem is that it does not read my surfaces. Strange thing is that I can convert it without any error but when I visualize it, it looks different.",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883504",
                          "updatedAt": "2024-03-26T05:54:29Z",
                          "publishedAt": "2021-06-17T14:04:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ajacquey"
                          },
                          "bodyText": "I can also load and display the physical surfaces properly.\nHowever, they all have really large values of ObjectId (around 7000-9000,  physical surface ID).\nCould you try to set these values to something closer to unity?",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883516",
                          "updatedAt": "2024-03-26T05:54:29Z",
                          "publishedAt": "2021-06-17T14:05:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ajacquey"
                          },
                          "bodyText": "This is what I mean with the ObjectId values.",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883527",
                          "updatedAt": "2022-10-26T13:54:02Z",
                          "publishedAt": "2021-06-17T14:08:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ali1990dashti"
                          },
                          "bodyText": "@ajacquey do you mean the tag number of surfaces and volumes should be reduced and be for example less than 100?",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883532",
                          "updatedAt": "2022-10-27T21:52:00Z",
                          "publishedAt": "2021-06-17T14:10:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ajacquey"
                          },
                          "bodyText": "Yes,\nYour 2 subdomains have now 7406 (unit_3) and 9290 (basement) as IDs.\nAnd your sidesets 9291-9296.\nWhen I first opened the exodus file in Paraview, I got a warning about large numbers but I think I clicked on 'Ok, don't show again' so I cannot see this warning anymore.\nI don't know how your python gmsh API works but can you try to set the IDs directly instead of giving names for your physical volumes and surfaces?",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883617",
                          "updatedAt": "2022-10-27T21:52:00Z",
                          "publishedAt": "2021-06-17T14:23:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ajacquey"
                          },
                          "bodyText": "FYI, I have the same issue with peacock",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883647",
                          "updatedAt": "2022-10-27T21:52:00Z",
                          "publishedAt": "2021-06-17T14:27:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@ajacquey @Ali1990dashti any news on this?",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-979989",
                          "updatedAt": "2022-10-27T21:52:00Z",
                          "publishedAt": "2021-07-08T14:49:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Ali1990dashti"
                  },
                  "bodyText": "@ajacquey , I changed the mesh but still I cannot see any result in paraview. I installed the last version of moose and also use paraview 5.9.\nChanged_mesh.zip",
                  "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883668",
                  "updatedAt": "2022-06-18T18:49:33Z",
                  "publishedAt": "2021-06-17T14:30:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ali1990dashti"
                          },
                          "bodyText": "@ajacquey , Can I ask which version of paraview and conda are you using? I am seeing different things (almost nothing!!!) in my paraview. For moose also I installed it just two days ago. It has some problems with anaconda and I used following lines to install moose:\nconda create -n moose -q -y\nconda activate moose\nconda install moose-tools\nconda install moose-libmesh",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883854",
                          "updatedAt": "2022-06-18T18:49:39Z",
                          "publishedAt": "2021-06-17T15:01:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ajacquey"
                          },
                          "bodyText": "@Ali1990dashti\nI have Paraview 5.9.1\nI updated moose and conda in May:\ngit commit 5cda0d3 on 2021-05-10",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-883875",
                          "updatedAt": "2022-06-18T18:49:39Z",
                          "publishedAt": "2021-06-17T15:05:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ali1990dashti"
                          },
                          "bodyText": "@ajacquey, problem was my mesh. I was creating physical groups for blocks of my mesh but because of a mistake in a for loop, these physical groups were creating two times. Thanks for all your support. Sorry for my late feedback.",
                          "url": "https://github.com/idaholab/moose/discussions/18106#discussioncomment-982653",
                          "updatedAt": "2022-06-18T18:49:39Z",
                          "publishedAt": "2021-07-09T07:00:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}