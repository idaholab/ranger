{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNi0wOVQxNjoxOToxOS0wNjowMM4APmvI"
    },
    "edges": [
      {
        "node": {
          "title": "Refine mesh within a subdomain",
          "author": {
            "login": "patte103"
          },
          "bodyText": "Hello!\nI am trying to refine my mesh within a subdomain while the rest of the mesh remains coarse. I am currently using the mesh generators within moose and have been referencing the #19047 discussion. From the documentation, the RefineMeshGenerator seemed to only apply to CartesianMeshGenerator, and whenever I coupled it with my SubdomainBoundingBoxGenerator it resulted in this error:\nYour MeshGenerator tree contains multiple possible generator outputs :\n\"subdomain and one or more of the following from an independent set: \"refine\"\n\nThis may be due to a missing dependency or may be intentional. Please select the final MeshGenerator in\nthe [Mesh] block with the \"final_generator\" parameter or add additional dependencies to remove the ambiguity.\n\n\nIs there a way to refine my mesh in the subdomain specified region only? Or, which combination of mesh generators will yield the ideal result?\nMy current Mesh coupled with RefineMeshGenerator:\n[Mesh]\n[gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 80\n    ny = 40\n    xmin = 0.0\n    ymin = 0.0\n    xmax = 8000.0\n    ymax = 4000.0\n    elem_type = QUAD4\n  []\n  [./subdomain]\n    type = SubdomainBoundingBoxGenerator\n    input = gen\n    bottom_left = '0 1500 0'\n    top_right = '8000 2500 0'\n    block_id = 1\n   [../]\n [refine]\n   type = RefineBlockGenerator\n   input = gen\n    block = '1'\n    refinement = '4'\n    show_info = true\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/21272",
          "updatedAt": "2022-06-25T05:47:51Z",
          "publishedAt": "2022-06-10T19:36:29Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYour tree of MGs is wrong. The inputs to these two cannot both be 'gen'. They need to be chained.\nMaybe try input = subdomain for the refine MG\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21272#discussioncomment-2925760",
                  "updatedAt": "2022-06-10T20:14:04Z",
                  "publishedAt": "2022-06-10T20:14:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "patte103"
                          },
                          "bodyText": "That worked! Thanks so much Guillaume!",
                          "url": "https://github.com/idaholab/moose/discussions/21272#discussioncomment-2939332",
                          "updatedAt": "2022-06-13T14:55:25Z",
                          "publishedAt": "2022-06-13T14:55:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to set a variable field of \"Yield Stress\" in the J2 plasticity model",
          "author": {
            "login": "sSajjad90"
          },
          "bodyText": "Hi everyone,\nIn a phase calculation, the yield stress is calculated in material and is not constant. Now, I am going to add this yield stress to the J2 plasticity model, although available userobjects, TensorMechanicsHardeningConstant.C for instance, take constant values.\n[Materials]\n  [./Hardening]\n    type = PrecipitationHardening\n\n    Delta_Sigma_p = 'Sigma_p'          //Declared Yeild Stress\n\n    Time_step = 'time_step'\n    BurgursVec = 'b_V'\n    ShearModule = 'Mu'\n    PoisionRatio = 'Nu'\n    TaylorFactor = 'M_Taylor'\n    Gama = 'Gama_TDP'\n    PhaseNumber = 3\n    q_exponent = 2\n  [../]\n\n[UserObjects]\n  [./str]\n    type = TensorMechanicsHardeningConstant\n\n    value =         **//  hope to use 'Sigma_p' (material property) instead  of constant value**\n  [../]\n  [./j2]\n    type = TensorMechanicsPlasticJ2\n    yield_strength = str\n    yield_function_tolerance = 1E-3\n    internal_constraint_tolerance = 1E-9\n  [../]\n[]\n\nIn this way, I tried to change the type of parameter inside the TensorMechanicsHardeningConstant.C  and  ***.h files and got errors. (I tried getMaterialProperty<Real> and adCoupledValue and I got error)\nThis problem has already been discussed in #19454, but I could not realize how to figure it out.\nWould you please let me know the proper parameters to use the mentioned 'Sigma_p'  from the material calculation in the userobject?\nSincerely,\nSajjad",
          "url": "https://github.com/idaholab/moose/discussions/21261",
          "updatedAt": "2022-06-25T05:48:30Z",
          "publishedAt": "2022-06-10T02:17:51Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "so you want to use a material property?\nOr a variable? or a function?\nThere are plenty of examples for using each of these.",
                  "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2925510",
                  "updatedAt": "2022-06-10T19:17:07Z",
                  "publishedAt": "2022-06-10T19:17:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sSajjad90"
                          },
                          "bodyText": "I am going to use a material property which is not constant and would be changed via time",
                          "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2929986",
                          "updatedAt": "2022-06-11T22:03:30Z",
                          "publishedAt": "2022-06-11T20:10:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can have a look at ADMatDiffusion for how to work with those",
                          "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2930335",
                          "updatedAt": "2022-06-11T22:35:31Z",
                          "publishedAt": "2022-06-11T22:35:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sSajjad90"
                          },
                          "bodyText": "Please look at the below codes, derived from TensorMechanicsHardeningModel, providing yield_strength for the TensorMechanicsPlasticJ2 userobject.\nI understand that _qp is defined for regular materials using the computeQpProperties routine. But what exactly I want is that material property that is calculated each time (and will update next time). Now, I am wondering how I could use this material property in the userobject.\n#include \"YieldStressofBainaryPrecipitationHardening.h\"\n\nregisterMooseObject(\"microstructureApp\", YieldStressofBainaryPrecipitationHardening);\n\nInputParameters\nYieldStressofBainaryPrecipitationHardening::validParams()\n{\n  InputParameters params = TensorMechanicsHardeningModel::validParams();\n  params.addRequiredParam<MaterialPropertyName>(\"value_0\", \"The yield strength when internal variable = 0\");\n\n  params.addClassDescription(\"Hardening defined by Percipitation\");\n\n  return params;\n}\n\nYieldStressofBainaryPrecipitationHardening::YieldStressofBainaryPrecipitationHardening(\n    const InputParameters & parameters)\n  : TensorMechanicsHardeningModel(parameters),\n    _value_0(getMaterialProperty<Real>(\"value_0\"))\n{\n}\nReal\nYieldStressofBainaryPrecipitationHardening::value(Real intnl) const\n{\n  return _value_0[_qp];\n}\nReal\nYieldStressofBainaryPrecipitationHardening::derivative(Real intnl)  const\n{\n  return 0;\n}\nstd::string\nYieldStressofBainaryPrecipitationHardening::modelName() const\n{\n  return \"PrecipitationHardening\";\n}\n\n#pragma once\n\n#include \"TensorMechanicsHardeningModel.h\"\n\n\nclass YieldStressofBainaryPrecipitationHardening : public TensorMechanicsHardeningModel\n{\npublic:\n  static InputParameters validParams();\n\n  YieldStressofBainaryPrecipitationHardening(const InputParameters & parameters);\n\n  virtual Real value(Real intnl) const override;\n\n  virtual Real derivative(Real intnl) const override;\n\n  virtual std::string modelName() const override;\n\n\nprivate:\n  const MaterialProperty<Real> & _value_0;\n};\n\n\nAnd in the assembly file, Sigma_p is calculated in material properties and will be used in the ./str useobject at each time step.\n[Materials]\n  [./Hardening]\n    type = PrecipitationHardening\n\n    Delta_Sigma_p = 'Sigma_p'          //Declared Yeild Stress\n\n    Time_step = 'time_step'\n    BurgursVec = 'b_V'\n    ShearModule = 'Mu'\n    PoisionRatio = 'Nu'\n    TaylorFactor = 'M_Taylor'\n    Gama = 'Gama_TDP'\n    PhaseNumber = 3\n    q_exponent = 2\n  [../]\n[]\n\n[UserObjects]\n  [./str]\n    type = YieldStressofBainaryPrecipitationHardening\n    value = Sigma_p        \n  [../]\n  [./j2]\n    type = TensorMechanicsPlasticJ2\n    yield_strength = str\n    yield_function_tolerance = 1E-3\n    internal_constraint_tolerance = 1E-9\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2930417",
                          "updatedAt": "2022-06-11T23:26:49Z",
                          "publishedAt": "2022-06-11T23:26:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nMaterial properties are updated on every linear iteration, so as often as possible, so you do not need to worry about when it is updated.\nI'm not sure about your implementation though, it seems you are not replacing what was previously a constant with a material property?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2930953",
                          "updatedAt": "2022-06-12T04:23:13Z",
                          "publishedAt": "2022-06-12T04:23:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sSajjad90"
                          },
                          "bodyText": "Hi,\nI tried to replace the constant value taking in the TensorMechanicsHardeningConstant with a material property, but it does not work.\nLet me explain my problem with a simple example. Imagine yield strengthening depends on time_step and calculated by a ParsedMaterial, which changes based on the time t, like below.\nThis Yiled_Stress must be used in TensorMechanicsPlasticJ2. For this matter, another userobject is required to get the value from the material block and provide it for the plasticity model. ([./str] block)\nAvailable userobjects that provide yield_strength like TensorMechanicsHardeningConstant, TensorMechanicsHardeningPowerRule, etc., can not get this type of property. I tried rewriting the TensorMechanicsHardeningPowerRule code to get material property; however, it does not work.\nMy problem is to define a proper useruoject in the [./str] block to get the Yiled_Stress.\n[Materials]\n [./Hardening]\n   type = ParsedMaterial\n   f_name = 'Yiled_Stress'\n   material_property_names =  '75 + t * 0.3'\n   function = 't'\n [../]\n[]\n\n[UserObjects]\n  [./str]\n    type = \n    value = 'Yiled_Stress'        \n  [../]\n  [./j2]\n    type = TensorMechanicsPlasticJ2\n    yield_strength = str\n    yield_function_tolerance = 1E-3\n    internal_constraint_tolerance = 1E-9\n  [../]\n[]\n\nMany thanks for your kind support,",
                          "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2933051",
                          "updatedAt": "2022-06-12T15:22:38Z",
                          "publishedAt": "2022-06-12T15:22:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What do you mean by \"it does not work\" ?\nDoes it not compile?\nIs it not retrieving the right value?\nIs it not converging?",
                          "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2933520",
                          "updatedAt": "2022-06-12T17:08:55Z",
                          "publishedAt": "2022-06-12T17:08:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sSajjad90"
                          },
                          "bodyText": "It did not compile.  And the error is in the picture for the following  YieldStressofBainaryPrecipitationHardening userobject.\n\n\n#include \"YieldStressofBainaryPrecipitationHardening.h\"\n\nregisterMooseObject(\"microstructureApp\", YieldStressofBainaryPrecipitationHardening);\n\nInputParameters\nYieldStressofBainaryPrecipitationHardening::validParams()\n{\n  InputParameters params = TensorMechanicsHardeningModel::validParams();\n  params.addRequiredParam<MaterialPropertyName>(\"value_0\", \"The yield strength when internal variable = 0\");\n\n  params.addClassDescription(\"Hardening defined by Percipitation\");\n\n  return params;\n}\n\nYieldStressofBainaryPrecipitationHardening::YieldStressofBainaryPrecipitationHardening(\n    const InputParameters & parameters)\n  : TensorMechanicsHardeningModel(parameters),\n    _value_0(getMaterialProperty<Real>(\"value_0\"))\n{\n}\nReal\nYieldStressofBainaryPrecipitationHardening::value(Real intnl) const\n{\n  return _value_0[_qp];\n}\nReal\nYieldStressofBainaryPrecipitationHardening::derivative(Real intnl)  const\n{\n  return 0;\n}\nstd::string\nYieldStressofBainaryPrecipitationHardening::modelName() const\n{\n  return \"PrecipitationHardening\";\n}\n\n\n#pragma once\n\n#include \"TensorMechanicsHardeningModel.h\"\n\n\nclass YieldStressofBainaryPrecipitationHardening : public TensorMechanicsHardeningModel\n{\npublic:\n  static InputParameters validParams();\n\n  YieldStressofBainaryPrecipitationHardening(const InputParameters & parameters);\n\n  virtual Real value(Real intnl) const override;\n\n  virtual Real derivative(Real intnl) const override;\n\n  virtual std::string modelName() const override;\n\n\nprivate:\n  const MaterialProperty<Real> & _value_0;\n};",
                          "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2933567",
                          "updatedAt": "2022-06-12T17:21:32Z",
                          "publishedAt": "2022-06-12T17:21:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So is this code trying to\n\ndefine the material property you want to use\nOR\nuse that material property in the tensor mechanics model\n\nSeems to me like there is a confusion here",
                          "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2933670",
                          "updatedAt": "2022-06-12T17:51:17Z",
                          "publishedAt": "2022-06-12T17:51:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sSajjad90"
                          },
                          "bodyText": "Sorry for my bad explanation.\nuse that material property in the tensor mechanics model",
                          "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2933762",
                          "updatedAt": "2022-06-12T18:19:33Z",
                          "publishedAt": "2022-06-12T18:19:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok I dived a little bit into this code and it doesnt look like it is set up to use a material at all.\nDo you need both spatial and time dependence? Or just time dependence?\nIf time dependence only you should use a Function.",
                          "url": "https://github.com/idaholab/moose/discussions/21261#discussioncomment-2934116",
                          "updatedAt": "2022-06-12T20:16:26Z",
                          "publishedAt": "2022-06-12T20:16:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Impose a solution of block 1 onto block 2",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I am solving a heat transfer problem in MOOSE. The problem domain solves for the temperature on two separate meshes(two blocks same file). I am imposing a constant temperature on a small circular domain. I am solving convective heat in the other mesh domain which is square and much larger than the circular domain. I would like to impose the solution of the constant temperature domain into the convective solution domain in order to determine the effect of the imposed constant solution on that of the convective solve. Is it possible to translate a nearest neighbor (meshes overlap) solution from one mesh domain into another without using MultiApp, since the meshes are contained in the same mesh file and are solved for in the same Kernel block?",
          "url": "https://github.com/idaholab/moose/discussions/20884",
          "updatedAt": "2022-06-25T05:49:02Z",
          "publishedAt": "2022-04-27T03:48:25Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont know of a way to exactly do that currently.\nIf the 'nearest-neighbor' transformation (eg you are happy with that mapping of the square onto the circle) works for you, you could use a MultiApp to use that transfer.\nElse if there's a 1-1 relationship between nodes in the circle and square boundaries you could try using the Constraints system.\nFinally you could write your own user object to do this.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2643985",
                  "updatedAt": "2022-06-05T05:33:03Z",
                  "publishedAt": "2022-04-27T06:23:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "I have implemented MultiAppNearestNodeTransfer where I have defined the physics and boundary conditions for each mesh (block) in separate solver files. Each solutions is a transient solution. The controlling app appears to progress as a time based solution. The multi app input file appears to restart for each data push and is not time varying. Is it possible preserve the transient solution of all files and observe the progression of the solution in the controlling app?",
                          "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2651402",
                          "updatedAt": "2022-06-05T05:33:35Z",
                          "publishedAt": "2022-04-28T02:52:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So in a MultiApp set up?\nDid you use a FullSolveMultiApp or a TransientMultiApp ? Because the former is resetting every time step currently.\nThe latter is the one to use to get parallel time evolution of the two solves.",
                          "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2656377",
                          "updatedAt": "2022-06-05T05:33:35Z",
                          "publishedAt": "2022-04-28T16:58:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "I am using the TransientMultiApp, with the following format:\n[MultiApps]\n  [sub_app]\n    type = TransientMultiApp\n    positions = '0.1 0.1 0  0.4 0.4 0  0.7 0.7 0'\n     input_files = '2D_Move_Fluid_Ball.i'\n    execute_on = timestep_end\n    output_in_position = true\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2658950",
                          "updatedAt": "2022-06-05T05:33:48Z",
                          "publishedAt": "2022-04-29T03:50:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the exodus output if turned on in the subapp should include the solution of the subapp at all times in the transient",
                          "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2659014",
                          "updatedAt": "2022-06-10T13:48:17Z",
                          "publishedAt": "2022-04-29T04:01:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "When I solve the problem,I am only seeing the main output and not the subapp. Exodus is true for both.",
                          "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2659027",
                          "updatedAt": "2022-06-10T13:48:17Z",
                          "publishedAt": "2022-04-29T04:05:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does ls give in the directory?",
                          "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2659052",
                          "updatedAt": "2022-06-10T13:48:17Z",
                          "publishedAt": "2022-04-29T04:15:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "peacock_run_exe_tmp_2D_Move_Ball_All_MultiApp.i\npeacock_run_exe_tmp_2D_Move_Ball_All_MultiApp_out.e\npeacock_run_exe_tmp_2D_Move_Ball_All_MultiApp_out_sub_app0.e\npeacock_run_exe_tmp_2D_Move_Ball_All_MultiApp_out_sub_app1.e\npeacock_run_exe_tmp_2D_Move_Ball_All_MultiApp_out_sub_app2.e\npeacock_run_exe_tmp_2D_Move_Fluid_Ball.i\npeacock_run_exe_tmp_2D_Move_Fluid_Ball_out.e\npeacock_run_mesh_tmp_2D_Move_Ball_All_MultiApp.e",
                          "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2659057",
                          "updatedAt": "2022-06-10T13:48:17Z",
                          "publishedAt": "2022-04-29T04:17:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "I am seeing what I expect in the subapp_out, but that solution does not seem to translate back into the MultiApp_out.",
                          "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2659090",
                          "updatedAt": "2022-06-10T13:48:19Z",
                          "publishedAt": "2022-04-29T04:30:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "these ones:\npeacock_run_exe_tmp_2D_Move_Ball_All_MultiApp_out_sub_app0.e\npeacock_run_exe_tmp_2D_Move_Ball_All_MultiApp_out_sub_app1.e\npeacock_run_exe_tmp_2D_Move_Ball_All_MultiApp_out_sub_app2.e\n\nthese are the outputs of the subapp.\nWhat do you mean by translate back? As in have the solutions in the same file?",
                          "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2659125",
                          "updatedAt": "2022-06-10T13:48:33Z",
                          "publishedAt": "2022-04-29T04:36:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Here are my files:\n2D_Move_Ball_All_MultiApp_i.txt\n2D_Move_Fluid_Ball_i.txt\nFallingBall_e.txt",
                          "url": "https://github.com/idaholab/moose/discussions/20884#discussioncomment-2659129",
                          "updatedAt": "2022-06-10T13:48:34Z",
                          "publishedAt": "2022-04-29T04:37:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "how to use MetaPhysicL::raw_value",
          "author": {
            "login": "saturn00000"
          },
          "bodyText": "Hi MOOSEers,\nWhen I try to  find the direction angle for _grad_u[_qp], must I use \"raw_value\"?,\n ADReal theta= std::atan2(raw_value(_grad_u[_qp](1)), raw_value(_grad_u[_qp](0)));\nor  without \"raw_value\"\n ADReal theta = std::atan2(_grad_u[_qp](1), _grad_u[_qp](0));\nI appreciate any suggestions and help.Thank you.\nRef: #20312",
          "url": "https://github.com/idaholab/moose/discussions/21276",
          "updatedAt": "2022-06-12T22:26:54Z",
          "publishedAt": "2022-06-11T13:26:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nraw_value is used to remove the derivatives, so to create a Real out of an ADReal.\nSo it depends. If you are contributing to the residual with an ADKernel you want to use ADReal. If you are building an auxkernel or a postprocessor you can use Real.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21276#discussioncomment-2929290",
                  "updatedAt": "2022-06-11T16:25:53Z",
                  "publishedAt": "2022-06-11T16:25:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "saturn00000"
                          },
                          "bodyText": "can we direct use std::atan2(_grad_u_qp, _grad_u_qp)?  or",
                          "url": "https://github.com/idaholab/moose/discussions/21276#discussioncomment-2929499",
                          "updatedAt": "2022-06-11T17:25:27Z",
                          "publishedAt": "2022-06-11T17:25:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "saturn00000"
                  },
                  "bodyText": "Hello @GiudGiud,\nif we use  std::atan2(_grad_u_qp, _grad_u_qp)  to the residual with an ADKernel , then we will have the error:\nLinear solve did not converge due to DIVERGED_NANORINF iterations 0\nNonlinear solve did not converge due to DIVERGED_LINEAR_SOLVE iterations 0\nSolve Did NOT Converge!\nFinished Solving",
                  "url": "https://github.com/idaholab/moose/discussions/21276#discussioncomment-2929562",
                  "updatedAt": "2022-06-11T17:51:42Z",
                  "publishedAt": "2022-06-11T17:40:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThis can happen if the function derivative is not defined everywhere, especially if the function's derivative has a pole where its value is undefined.\nHowever, atan's derivative is fairly well behaved so I'm not sure.\nWhile it is preferred to use ADReal everywhere and preserve all derivatives, if a term is difficult to handle you may remove its derivatives and have an imperfect Jacobian. You may also use an if condition to isolate the problematic area.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21276#discussioncomment-2930965",
                          "updatedAt": "2022-06-12T04:26:55Z",
                          "publishedAt": "2022-06-12T04:26:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "saturn00000"
                          },
                          "bodyText": "Hello @GiudGiud\nthanks a lot for your reply!\nI think the reason may be that that the (AD) derivative of  the function atan2 is not defined in \"MetaPhysicL\".\nP.S.  the (AD) derivative of  the function atan can be used in MOOSE, but not atan2 ...",
                          "url": "https://github.com/idaholab/moose/discussions/21276#discussioncomment-2934454",
                          "updatedAt": "2022-06-12T22:26:24Z",
                          "publishedAt": "2022-06-12T22:26:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The coupling of phase field and mechanical stress",
          "author": {
            "login": "biaogxb"
          },
          "bodyText": "I just came into contact with moose. I want to use the phase field method to simulate the growth of dendrites and couple the mechanical stress by adding  elastic strain energy . I encountered difficulties in coupling the mechanical stress. Is there a similar example?\nAnd I want to customize kappa as kappa=k0 (1+w*cos\uff08 \u03b8\uff09\uff09\uff0c among \u03b8 is the changing angle between the normal vector of interface and the reference axis, I don't know how to express this \u03b8\uff0c Do you have any suggestions?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/21246",
          "updatedAt": "2022-06-11T08:35:23Z",
          "publishedAt": "2022-06-09T09:13:15Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere are examples in the combined module.\nhttps://github.com/idaholab/moose/tree/next/modules/combined/examples/phase_field-mechanics\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21246#discussioncomment-2915347",
                  "updatedAt": "2022-06-09T16:45:44Z",
                  "publishedAt": "2022-06-09T16:45:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Thank you!!! I want to customize kappa as kappa=k0 (1+w*cos\uff08 \u03b8\uff09\uff09\uff0c among \u03b8 is the changing angle between the normal vector of interface and the reference axis, I don't know how to express this \u03b8\uff0c Do you have any suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/21246#discussioncomment-2918727",
                          "updatedAt": "2022-06-10T02:20:22Z",
                          "publishedAt": "2022-06-10T02:20:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so this theta, is it a property of the dendrites or is it local to the mesh?\nYou should search in moose for models for kappa.",
                          "url": "https://github.com/idaholab/moose/discussions/21246#discussioncomment-2925496",
                          "updatedAt": "2022-06-10T19:14:32Z",
                          "publishedAt": "2022-06-10T19:14:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Okay thank you very much",
                          "url": "https://github.com/idaholab/moose/discussions/21246#discussioncomment-2927835",
                          "updatedAt": "2022-06-11T08:35:19Z",
                          "publishedAt": "2022-06-11T08:35:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "the problem of combustion",
          "author": {
            "login": "xiaojbing"
          },
          "bodyText": "Does MOOSE support to compute the problem of combustion\uff1fWhether to support  files of CHEMKIN\uff1f",
          "url": "https://github.com/idaholab/moose/discussions/21219",
          "updatedAt": "2022-06-13T08:10:19Z",
          "publishedAt": "2022-06-07T01:16:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@permcody do you know?",
                  "url": "https://github.com/idaholab/moose/discussions/21219#discussioncomment-2909860",
                  "updatedAt": "2022-06-09T01:49:14Z",
                  "publishedAt": "2022-06-09T01:49:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "No, we don\u2019t have any support for that.",
                          "url": "https://github.com/idaholab/moose/discussions/21219#discussioncomment-2926779",
                          "updatedAt": "2022-06-11T01:29:55Z",
                          "publishedAt": "2022-06-11T01:29:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Help needed on PowerLawCreepStressUpdate class",
          "author": null,
          "bodyText": "Dear MOOSE experts,\nI\u2019m a newbie to MOOSE, and I\u2019m leveraging the capabilities of the PowerLawCreepStressUpdate class in FALCON (MOOSE application). I have a few questions about the parent classes of the PowerLawCreepStressUpdate.\nLine 170 in the SingleVariableReturnMappingSolution.C class reads: scalar = initialGuess (effective_trial_stress).\nI think that scalar is being initialized here, but does this mean that scalar is initialized with the \u201ceffective_trial_stress \u201d value? If this is true, does it mean I can define my own parameter that I can use to initialize the scalar parameter?\nAlso, Line 211 in the RadialReturnStressUpdate.C file reads: _scalar_effective_inelastic_strain = 0.0. Is _scalar_effective_inelastic_strain being initialized here too? If yes, can I define my own value and use it to initialize _scalar_effective_inelastic_strain?\nThanks in advance for your help!",
          "url": "https://github.com/idaholab/moose/discussions/21267",
          "updatedAt": "2022-06-25T05:50:33Z",
          "publishedAt": "2022-06-10T16:39:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "No. The initialGuess is a a virtual function. By default, it is zero. As I mentioned before in our emails, we use a Newton method to solve scalar. A good initial guess will help convergence. If you do not know, zero would be a nice guess.",
                  "url": "https://github.com/idaholab/moose/discussions/21267#discussioncomment-2924740",
                  "updatedAt": "2022-06-10T16:52:30Z",
                  "publishedAt": "2022-06-10T16:52:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Thanks, @jiangwen84. So what is the role of the effective_trial_stress in the brackets after the initialGuess on line 170 in the SingleVariableReturnMappingSolution.C class?",
                          "url": "https://github.com/idaholab/moose/discussions/21267#discussioncomment-2924828",
                          "updatedAt": "2022-06-10T17:03:37Z",
                          "publishedAt": "2022-06-10T17:03:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "It provides a way to formulate the initial guess as a function of effective_trial_stress. In this case, effective_trial_stress is not used.",
                          "url": "https://github.com/idaholab/moose/discussions/21267#discussioncomment-2924869",
                          "updatedAt": "2022-06-10T17:09:45Z",
                          "publishedAt": "2022-06-10T17:09:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "3D mortar contact: why is contact stiffness matrix implemented by automatic differentiation?",
          "author": {
            "login": "ch950423"
          },
          "bodyText": "Hi MOOSE experts.\nI am trying to implement the 3D mortar contact using dual Lagrange multipliers following the thesis of Alexander Popp. But the contact stiffness matrix is so complicated that it is even not fully written in the thesis. The thesis just told me every term of the contact stiffness matrix, i.e. the directional derivatives of the mortar matrix \u0394D and \u0394M.\nI debugged the following example:\nmoose/modules/contact/test/tests/3d-mortar-contact/frictionless-mortar-3d-test-derivative-trimming.i\nI found the contact stiffness matrix is computed as follows:\nmoose/modules/contact/src/constraints/ADMortarLagrangeConstraint.C\n90 void\n91 ADMortarLagrangeConstraint::computeJacobian(Moose::MortarType mortar_type)\n...\n146  std::vector< DualReal > residuals_lower;\n147  residuals_lower.resize(number_indices_on_lowerd, 0);\n148\n149  // Only populate nodal residuals on the primary/secondary surfaces\n150  // We do this regardless of whether we are interpolating normals. Use of this class\n151  // implies we have Lagrange elements, so internal (high-dimensional) normals have no meaning\n152  // and should be zero. As such, we decide to omit them and avoid possible spurious population of\n153  // automatic differentiation-generated derivatives.\n154  for (_qp = 0; _qp < _qrule_msm->n_points(); _qp++)\n155  {\n156    unsigned int index_lower = 0;\n157    for (const auto index : is_index_on_lower_dimension)\n158    {\n159      _i = index;\n160      residuals_lower[index_lower] += _JxW_msm[_qp] * _coord[_qp] * computeQpResidual(mortar_type);\n161\n162      // Get rid of derivatives that we assume won't count (tolerance prescribed by user)\n163      // residuals_lower[index_lower].derivatives().sparsity_trim(_ad_derivative_threshold);\n164      index_lower++;\n165    }\n166  }\n\nThe line 160 is computing the residuals and its derivatives, i.e. the contact forces and the contact stiffness. Then the residuals_lower[i].derivatives() are used for assembly of the contact stiffness matrix.\nI found the computeQpResidual(mortar_type) is a ADReal and the automatic differentiation technique is used here.\nWhy is the contact stiffness matrix implemented by the automatic differentiation rather than implemented directly according to the formula? Is it because the formula is too complicated? What is the difference between the two ways?\nWhat is your advise if I want to compute the contact stiffness matrix?\nThanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/21220",
          "updatedAt": "2022-06-10T01:16:58Z",
          "publishedAt": "2022-06-07T02:40:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "The complexity of computing contact stiffness matrices is avoided by usage of automatic differentiation (AD) in MOOSE. AD also allows to change the way one defines contact forces without much development (e.g. one may want to introduce additional dependencies in the constraint equations). AD may generate additional computations to compute the system Jacobian, but, in the case of contact, since it acts on lower-dimensional domain, I have not found it to be limiting in any relevant way. I don't think there is a significant difference between the manual and the AD approach in the intended final result. Terms can be neglected both using AD or computing the Jacobian manually.\nNot sure if you want to compute the contact stiffness matrix in your own code or get the result from MOOSE. In the former case, I'd suggest dig into the literature. In the latter, I'd output the Jacobian in MOOSE for simpler problems.",
                  "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2899071",
                  "updatedAt": "2022-06-07T15:39:47Z",
                  "publishedAt": "2022-06-07T15:39:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ch950423"
                          },
                          "bodyText": "I have read relevant literature Automatic Differentiation in MetaPhysicL and Its Applications in MOOSE and A mortar thermomechanical contact computational framework for nuclear fuel performance simulation.\nIt seems the main feature of AD is the simplification of the computation of the derivative, at the cost of memory and computing efficiency, but without lose of accuracy.\nI still have some questions:\nThe relevant literature aforementioned focus on AD application in mortar contact in 2D.\nWhat the effect of applying AD to 3D mortar frictional contact? How about the convergence?\nWhen simulating a large model (i.e. too many DOFs and multiple contact zones existing), will the main disadvantages of AD show up? (will memory usage and computing efficiency become unacceptable?)\nThanks a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2911994",
                          "updatedAt": "2022-06-09T09:11:23Z",
                          "publishedAt": "2022-06-09T09:11:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ch950423"
                          },
                          "bodyText": "By the way, because the main complexity relies on computing the contact stiffness, is it feasible that I use AD to compute the contact stiffness matrix only, while computing other part of the system Jacobian manually (i.e. implementing other part of the system Jacobian directly according to the formula)?",
                          "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2912153",
                          "updatedAt": "2022-06-09T09:35:50Z",
                          "publishedAt": "2022-06-09T09:35:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "What the effect of applying AD to 3D mortar frictional contact? How about the convergence?\n\nI don't think there is any fundamental difference between 2D and 3D, other than dimensionality, which would increase the number of AD dependencies by some factor.\n\nwill the main disadvantages of AD show up? (will memory usage and computing efficiency become unacceptable?)\n\nWhen the AD container size is required to be too large, some memory limitations could potentially come into play. Say, if you have many variables per element, 3D problem, high-order elements, and a fine (finely meshed relative to the secondary side) primary side which increases the number of dependencies via projections. Typical simulations do not reach this kind of problems.\n\nBy the way, because the main complexity relies on computing the contact stiffness, is it feasible that I use AD to compute the contact stiffness matrix only, while computing other part of the system Jacobian manually (i.e. implementing other part of the system Jacobian directly according to the formula)?\n\nYes, that's what I meant by \"AD may generate additional computations to compute the system Jacobian, but, in the case of contact, since it acts on lower-dimensional domain, I have not found it to be limiting in any relevant way\".",
                          "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2913250",
                          "updatedAt": "2022-06-09T12:34:26Z",
                          "publishedAt": "2022-06-09T12:31:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "btw dont forget to reconfigure then recompile MOOSE with a larger ad-derivative-container size (see ./configure --help) to work on mortar contact with AD.\nStart with 200 maybe and let us know if you run into any issue",
                          "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2915357",
                          "updatedAt": "2022-06-09T16:47:29Z",
                          "publishedAt": "2022-06-09T16:47:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ch950423"
                          },
                          "bodyText": "OK",
                          "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2918392",
                          "updatedAt": "2022-06-10T01:16:58Z",
                          "publishedAt": "2022-06-10T01:16:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fluid-solid conjugate heat transfer problem",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, everyone, I recently ran into a fluid-solid conjugate heat transfer problem.\nThis is a relatively simple question, with only one variable called temp. This is the radial mesh:\n\nIn Kernels I have a volume heat source term in the fuel section and a convection term in the coolant section. Fuel, cladding, and coolant all have time and heat conduction terms. In BCs, I set the coolant inlet temperature(593K) and outlet velocity. And I set the initial value of temp is 593K.The entire input file is as follows:\nflow_velocity = 151.5 # cm/s\nini_temp = 593 # K\ncoolant_inlet_temp = 593 # K\n\n[Variables]\n  [./temp]\n    initial_condition = ${ini_temp}\n  [../]\n[]\n\n[Mesh]\n  file = 'model_finer.msh'\n[]\n\n[Kernels]\n  [./temp_time_derivative]\n    type = INSTemperatureTimeDerivative\n    variable = temp\n  [../]\n  [./temp_diffusion]\n    type = MatDiffusion\n    diffusivity = 'k'\n    variable = temp\n  [../]\n  [./temp_heat_source]\n    type = HeatSource\n    variable = temp\n    block = 'fuel'\n    value = 1e8\n  [../]\n  [./temp_advection_fuel]\n    type = ConservativeTemperatureAdvection\n    velocity = '0 0 ${flow_velocity}'\n    variable = temp\n    block = 'cool'\n  [../]\n[]\n\n[BCs]\n  [./temp_inlet_coolant]\n    type = DirichletBC\n    boundary = 'cool_inlet'\n    variable = temp\n    value = '${coolant_inlet_temp}'\n  [../]\n  [./temp_advection_coolant]\n    type = TemperatureOutflowBC\n    boundary = 'cool_outlet'\n    variable = temp\n    velocity = '0 0 ${flow_velocity}'\n  [../]\n[]\n\n[Materials]\n  [./rho_fuel]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.010982399418993717'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n  [./cp_fuel]\n    type = ParsedMaterial\n    f_name = cp\n    function = '297.81083870424914'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n  [./k_fuel]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.059515513277033714'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n\n  [./rho_clad]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.007667215971999999'\n    args = 'temp'\n    block = 'clad'\n  [../]\n  [./cp_clad]\n    type = ParsedMaterial\n    f_name = cp\n    function = '581.7254559999992'\n    args = 'temp'\n    block = 'clad'\n  [../]\n  [./k_clad]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.3'\n    args = 'temp'\n    block = 'clad'\n  [../]\n\n  [./rho_cool]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.0103111'\n    args = 'temp'\n    block = 'cool'\n  [../]\n  [./cp_cool]\n    type = ParsedMaterial\n    f_name = cp\n    function = '145.2432'\n    args = 'temp'\n    block = 'cool'\n  [../]\n  [./k_cool]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.12085239999999998'\n    args = 'temp'\n    block = 'cool'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 100\n  dt = 2e-7\n  #end_time = 100\n\n  nl_rel_tol = 1e-6\n  nl_abs_tol = 1e-6\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n   # petsc_options_iname = '-snes_type'\n  # petsc_options_value = 'test'\n\n  nl_max_its = 30\n  l_max_its = 100\n  steady_state_detection = true\n  steady_state_tolerance = 1e-10\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Postprocessors]\n  [./max_temp_fuel]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'fuel'\n  [../]\n  [./max_temp_clad]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'clad'\n  [../]\n  [./max_temp_cool]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'cool'\n  [../]\n  [./min_temp_fuel]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'fuel'\n  [../]\n  [./min_temp_clad]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'clad'\n  [../]\n  [./min_temp_cool]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'cool'\n  [../]\n  [./average_temp_fuel]\n    type = ElementAverageValue\n    variable = temp\n    block = 'fuel'\n  [../]\n  [./average_temp_clad]\n    type = ElementAverageValue\n    variable = temp\n    block = 'clad'\n  [../]\n  [./average_temp_cool]\n    type = ElementAverageValue\n    variable = temp\n    block = 'cool'\n  [../]\n[]\n\n[VectorPostprocessors]\n  [./aa]\n    type = LineValueSampler\n    variable = 'temp'\n    start_point = '0.57 0 45'\n    end_point = '0.57 1.14 45'\n    num_points = 115\n    sort_by = y\n    execute_on = TIMESTEP_END\n  [../]\n[]\n\n[Outputs]\n  perf_graph = true\n  print_linear_residuals = true\n  [./exodus]\n    type = Exodus\n    file_base = 'thermal_time_diff_adv_heatsource'\n  [../]\n  [./csv]\n    type = CSV\n    file_base = 'thermal_time_diff_adv_heatsource'\n  [../]\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\nSince I use a software called Moltres, the ConservativeTemperatureAdvvection and TemperatureOutflowBC in the input file are in Moltres, so you may not be able to run this input file. But I posted the result of running it. Below are the average, maximum, and minimum temperatures of the fuel, cladding, and coolant sections, and plots of temperature versus y at x=0.57cm, z=45cm at 1e-5 seconds.\n\n\n\n\nIt stands to reason that, given the initial and boundary conditions, the fuel is always exothermic, and there should be no temperature drop in the entire system. But there is an unusual temperature drop in the picture. I would like to know why this is the case, is it necessary to set some conditions at the interface of fluid and solid in fluid-solid conjugate heat transfer ? Do I also need to set conditions for solid-to-solid heat transfer ?\nI also tried to calculate an extreme case where in addition to the time term, only the volume heat source term for the fuel part of the entire system. The input file is as follows (this one can be run by anyone who has installed MOOSE):\nini_temp = 593 # K\ncoolant_inlet_temp = 593 # K\n\n\n[Variables]\n  [./temp]\n    initial_condition = ${ini_temp}\n  [../]\n[]\n\n[Mesh]\n  file = 'model_finer.msh'\n[]\n\n[Kernels]\n  [./temp_time_derivative]\n    type = INSTemperatureTimeDerivative\n    variable = temp\n  [../]\n  [./temp_heat_source]\n    type = HeatSource\n    variable = temp\n    block = 'fuel'\n    value = 1e8\n  [../]\n[]\n\n[BCs]\n  [./temp_inlet_coolant]\n    type = DirichletBC\n    boundary = 'cool_inlet'\n    variable = temp\n    value = '${coolant_inlet_temp}'\n  [../]\n[]\n\n[Materials]\n  [./rho_fuel]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.010982399418993717'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n  [./cp_fuel]\n    type = ParsedMaterial\n    f_name = cp\n    function = '297.81083870424914'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n  [./k_fuel]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.059515513277033714'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n\n  [./rho_clad]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.007667215971999999'\n    args = 'temp'\n    block = 'clad'\n  [../]\n  [./cp_clad]\n    type = ParsedMaterial\n    f_name = cp\n    function = '581.7254559999992'\n    args = 'temp'\n    block = 'clad'\n  [../]\n  [./k_clad]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.3'\n    args = 'temp'\n    block = 'clad'\n  [../]\n\n  [./rho_cool]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.0103111'\n    args = 'temp'\n    block = 'cool'\n  [../]\n  [./cp_cool]\n    type = ParsedMaterial\n    f_name = cp\n    function = '145.2432'\n    args = 'temp'\n    block = 'cool'\n  [../]\n  [./k_cool]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.12085239999999998'\n    args = 'temp'\n    block = 'cool'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 100\n  dt = 2e-7\n  #end_time = 100\n\n  nl_rel_tol = 1e-6\n  nl_abs_tol = 1e-6\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n   # petsc_options_iname = '-snes_type'\n  # petsc_options_value = 'test'\n\n  nl_max_its = 30\n  l_max_its = 100\n  steady_state_detection = true\n  steady_state_tolerance = 1e-10\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Postprocessors]\n  [./max_temp_fuel]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'fuel'\n  [../]\n  [./max_temp_clad]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'clad'\n  [../]\n  [./max_temp_cool]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'cool'\n  [../]\n  [./min_temp_fuel]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'fuel'\n  [../]\n  [./min_temp_clad]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'clad'\n  [../]\n  [./min_temp_cool]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'cool'\n  [../]\n  [./average_temp_fuel]\n    type = ElementAverageValue\n    variable = temp\n    block = 'fuel'\n  [../]\n  [./average_temp_clad]\n    type = ElementAverageValue\n    variable = temp\n    block = 'clad'\n  [../]\n  [./average_temp_cool]\n    type = ElementAverageValue\n    variable = temp\n    block = 'cool'\n  [../]\n[]\n\n[VectorPostprocessors]\n  [./aa]\n    type = LineValueSampler\n    variable = 'temp'\n    start_point = '0.57 0 45'\n    end_point = '0.57 1.14 45'\n    num_points = 115\n    sort_by = y\n    execute_on = TIMESTEP_END\n  [../]\n[]\n\n[Outputs]\n  perf_graph = true\n  print_linear_residuals = true\n  [./exodus]\n    type = Exodus\n    file_base = 'thermal_time_heatsource'\n  [../]\n  [./csv]\n    type = CSV\n    file_base = 'thermal_time_heatsource'\n  [../]\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\nIt stands to reason that only the temperature of the fuel will rise in this case, and the temperature of the cladding and coolant will not change (because there is no heat conduction and advection heat transfer). But its calculation result is very, very similar to the previous one, I only post the result for the minimum temperature:\n\nI would like to know why this happens. The .msh file needed for the calculation and the .geo file to generate the meshes have been attached.\nThanks for any advice!\nmesh.zip",
          "url": "https://github.com/idaholab/moose/discussions/21251",
          "updatedAt": "2022-06-25T05:42:50Z",
          "publishedAt": "2022-06-09T15:35:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is pretty obviously a nuclear system and we cant really legally help you with modeling this kind of system.\nI'd encourage you to reach out to the moltres community for assistance.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21251#discussioncomment-2915493",
                  "updatedAt": "2022-06-09T17:04:12Z",
                  "publishedAt": "2022-06-09T17:04:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Can you give me some suggestions for fluid-structure coupling heat transfer calculations using MOOSE? This kind of calculation is actually very, very common, it happens in all fields. For example, water flows and transfers heat through pipes.",
                          "url": "https://github.com/idaholab/moose/discussions/21251#discussioncomment-2915540",
                          "updatedAt": "2022-06-09T17:10:32Z",
                          "publishedAt": "2022-06-09T17:10:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Given @GiudGiud 's answer, i don't think you're going to get any help here.  I have no experience in your type of model, but would something like this help?  https://mooseframework.inl.gov/source/kernels/PorousFlowHeatMassTransfer.html",
                          "url": "https://github.com/idaholab/moose/discussions/21251#discussioncomment-2917266",
                          "updatedAt": "2022-06-09T21:03:28Z",
                          "publishedAt": "2022-06-09T21:03:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thanks a lot, Andy. I'll read it carefully.",
                          "url": "https://github.com/idaholab/moose/discussions/21251#discussioncomment-2918208",
                          "updatedAt": "2022-06-10T00:31:41Z",
                          "publishedAt": "2022-06-10T00:31:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Accessing quadrature points of a feature to modify material properties",
          "author": {
            "login": "rayaprolu143"
          },
          "bodyText": "Hello,\nTo modify the material properties within a feature, I want to access the quadrature points of elements that are part of a feature (e.g., precipitate, bubble). I did try the method getVarToFeatureVector(_current_elem->id()) of the FeatureFloodCount to know if an element has any features, but I only ended up getting invalid id for every element. Could anyone provide me guidance to achieve the latter?\nThanks,\nSreekar",
          "url": "https://github.com/idaholab/moose/discussions/21066",
          "updatedAt": "2022-06-25T05:39:05Z",
          "publishedAt": "2022-05-22T12:53:32Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen @SudiptaBiswas",
                  "url": "https://github.com/idaholab/moose/discussions/21066#discussioncomment-2909810",
                  "updatedAt": "2022-06-09T01:38:44Z",
                  "publishedAt": "2022-06-09T01:38:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "getVarToFeatureVector gives you the grain_id to order parameter map for the element. If the element is within a bubble, you would get invalid_id.  Can you not identify the features by the active order parameter (or variable) values? We would need more information about what you are trying to implement to guide you toward the right approach.",
                          "url": "https://github.com/idaholab/moose/discussions/21066#discussioncomment-2917669",
                          "updatedAt": "2022-06-09T22:19:19Z",
                          "publishedAt": "2022-06-09T22:19:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}