{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wMy0yMlQxNTozNjowNi0wNjowMM4AMiZf"
    },
    "edges": [
      {
        "node": {
          "title": "Does MOOSE support electrical simulation?",
          "author": {
            "login": "tongfen"
          },
          "bodyText": "Hi, I am new to MOOSE. I am looking to simulate electrical-mechanical coupling. Does MOOSE support this? Thank you very much.",
          "url": "https://github.com/idaholab/moose/discussions/17389",
          "updatedAt": "2022-06-24T03:46:46Z",
          "publishedAt": "2021-03-19T15:29:54Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "If all you need is an electrostatic field simulation, then the Diffusion kernel (or one of the custom versions: FuncDiffusion or MatDiffusion if you want to couple in a material property for the permittivity) could help you set up Poisson's Equation to solve for potential. Then you can set up an AuxKernel to get electric field as an AuxVariable from the electrostatic potential. If you need full Maxwell's, an electromagnetic module for MOOSE has been built but is not cleared for public release yet. It should be coming very soon though.",
                  "url": "https://github.com/idaholab/moose/discussions/17389#discussioncomment-503809",
                  "updatedAt": "2022-06-24T03:46:46Z",
                  "publishedAt": "2021-03-19T15:49:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tongfen"
                          },
                          "bodyText": "Hi Cticenhour,\nThank you so much for your information. It is still beyond my understanding. I will spend some time to figure it out. Thanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/17389#discussioncomment-504941",
                          "updatedAt": "2022-06-24T03:46:56Z",
                          "publishedAt": "2021-03-19T20:24:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "No problem! Feel free to post more questions you begin learning MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/17389#discussioncomment-505022",
                          "updatedAt": "2022-06-24T03:46:56Z",
                          "publishedAt": "2021-03-19T20:54:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mangerij"
                  },
                  "bodyText": "Are you asking about piezoelectric materials?",
                  "url": "https://github.com/idaholab/moose/discussions/17389#discussioncomment-510795",
                  "updatedAt": "2022-06-24T03:46:56Z",
                  "publishedAt": "2021-03-21T21:05:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tongfen"
                          },
                          "bodyText": "Not exactly, do you have any idea about using MOOSE to simulate piezoresistive materials? Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/17389#discussioncomment-511095",
                          "updatedAt": "2022-06-24T03:46:56Z",
                          "publishedAt": "2021-03-21T23:53:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "In my limited knowledge of piezoresistivity, wouldn't you just need to couple elastic deformations to a change in conductivity? This would just be a postprocessor added to what is already in Moose: tensor mechanics\nOr is there coupling between the current and the strain?",
                          "url": "https://github.com/idaholab/moose/discussions/17389#discussioncomment-514191",
                          "updatedAt": "2022-06-24T03:47:24Z",
                          "publishedAt": "2021-03-22T16:50:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "This would just be a postprocessor\n\nMore likely a Material that couples in the stress or strain and computes a Diffusivity (or electrical conductivity) at each quadrature point.",
                          "url": "https://github.com/idaholab/moose/discussions/17389#discussioncomment-514937",
                          "updatedAt": "2022-06-24T03:47:26Z",
                          "publishedAt": "2021-03-22T19:53:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tongfen"
                          },
                          "bodyText": "Mangerij and Dschwen, I see. Thank you for your reply. I got some useful information from you both.",
                          "url": "https://github.com/idaholab/moose/discussions/17389#discussioncomment-530051",
                          "updatedAt": "2022-12-20T07:33:14Z",
                          "publishedAt": "2021-03-25T14:50:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "See also #17362",
                  "url": "https://github.com/idaholab/moose/discussions/17389#discussioncomment-514948",
                  "updatedAt": "2022-07-14T09:37:27Z",
                  "publishedAt": "2021-03-22T19:56:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "using Auxvaribles from previous step for extra-stress calculation",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nI defined Auxvaribale as below, I just wonder how can I use it for extra-stress calculation? seems like I cannot just call the variable name.\n[AuxVariables]\n  [./stress_xx]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n  [./stress_yy]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n  [./stress_zz]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n[]\n[AuxKernels]\n  [./matl_s11]\n    type = RankTwoAux\n    rank_two_tensor = stress\n    index_i = 0\n    index_j = 0\n    variable = stress_xx\n  [../]\n  [./matl_s22]\n    type = RankTwoAux\n    rank_two_tensor = stress\n    index_i = 1\n    index_j = 1\n    variable = stress_yy\n  [../]\n  [./matl_s33]\n    type = RankTwoAux\n    rank_two_tensor = stress\n    index_i = 2\n    index_j = 2\n    variable = stress_zz\n  [../]\n[]\n\nbelow is for the extra-stress\n[./void_stress]\n  type = ComputeExtraStressConstant\n  block = 1\n  extra_stress_tensor = '-stress_xx -stress_yy -stress_zz 0 0 0'\n  prefactor = Ex_stress1\n[../]\n\n[./Ex_stress1]\n  type = ParsedFunction\n  value = 'if(t<2,1,1e-4)'\n[../]\n\nhere is the error message: cannot convert '-stress_zz' to float\nIt should be quite straightforward, but I couldn't find the way around it.\nThank you!\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/17408",
          "updatedAt": "2022-10-20T13:29:33Z",
          "publishedAt": "2021-03-22T23:45:35Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "note that: the objective here is to remove the stress for a particular block, hence, extra_stress_tensor equal to previous step stress but in opposite direction",
                  "url": "https://github.com/idaholab/moose/discussions/17408#discussioncomment-515782",
                  "updatedAt": "2022-10-20T13:29:35Z",
                  "publishedAt": "2021-03-23T00:59:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "You should be able to setup the stress to only be calculated on the desired block and setup another on the other block that is zero, since the stress calculations are Material objects.\nBut, I am not familiar with mechanics module; perhaps some mechanics folks could jump in @jiangwen84 or @sapitts with the correct approach.",
                  "url": "https://github.com/idaholab/moose/discussions/17408#discussioncomment-527803",
                  "updatedAt": "2022-10-20T13:29:35Z",
                  "publishedAt": "2021-03-25T03:21:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "The name of ComputeExtraStressConstant indicates that it only works for a constant stress tensor. If the stress in your simulation is not a constant, i.e., with spatial variation, you cannot use this object.\nCould you explain a bit more on what you are trying to do? Do you want zero stress in the void?",
                          "url": "https://github.com/idaholab/moose/discussions/17408#discussioncomment-527843",
                          "updatedAt": "2022-10-20T13:29:39Z",
                          "publishedAt": "2021-03-25T03:43:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi, yes, I instead modified the computestress .C file by adding the prefactor term, so now I can multiply the old stress by some prefactor which can reduce the stress in the particular block (creating the void).\nAll good now, thanks guys!\n{\n\n  _stress[_qp] = _stress_old[_qp]* _prefactor[_qp]+ _elasticity_tensor[_qp] * elastic_strain_increment;\n\n  computeQpJacobian();\n}",
                          "url": "https://github.com/idaholab/moose/discussions/17408#discussioncomment-527872",
                          "updatedAt": "2022-10-20T13:29:40Z",
                          "publishedAt": "2021-03-25T03:59:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Failing test (CRASH)",
          "author": {
            "login": "pastoreg"
          },
          "bodyText": "Hi all,\nI have an MR that is failing because of a test failure (CRASH).  It seems the test runs fine in serial or with mpiexec, however, ./run_tests --n-threads=2 reproduces the error, as below.  I am not sure what may be causing this and would appreciate any help.  Thanks!\n(moose) gpastore@x86_64-apple-darwin13 bison % ./run_tests --n-threads=2 --re=test:tensor_mechanics/fecral_plasticity/power-law_strain_hardening.test_power-law_plasticity_fecral_tm\ntest:tensor_mechanics/fecral_plasticity/power-law_strain_hardening.test_power-law_plasticity_fecral_tm: Exit Code: -11\ntest:tensor_mechanics/fecral_plasticity/power-law_strain_hardening.test_power-law_plasticity_fecral_tm: ################################################################################\ntest:tensor_mechanics/fecral_plasticity/power-law_strain_hardening.test_power-law_plasticity_fecral_tm: Tester failed, reason: CRASH\ntest:tensor_mechanics/fecral_plasticity/power-law_strain_hardening.test_power-law_plasticity_fecral_tm:\ntest:tensor_mechanics/fecral_plasticity/power-law_strain_hardening.test_power-law_plasticity_fecral_tm [...] FAILED (CRASH)\nFinal Test Results:\n\ntest:tensor_mechanics/fecral_plasticity/power-law_strain_hardening.test_power-law_plasticity_fecral_tm [...] FAILED (CRASH)\n\nRan 1 tests in 1.5 seconds. Average test time 0.2 seconds, maximum test time 0.2 seconds.\nGiovanni\n--\nGiovanni Pastore, PhD\nResearch Associate Professor\nDepartment of Nuclear Engineering\nUniversity of Tennessee\nKnoxville, TN 37916\ngpastore@utk.edu",
          "url": "https://github.com/idaholab/moose/discussions/17361",
          "updatedAt": "2022-07-08T00:05:32Z",
          "publishedAt": "2021-03-17T21:24:26Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "pastoreg"
                  },
                  "bodyText": "Never mind, I figured this out.\nThe crash was due to a segfault caused by a pretty simple error.  Below is a code snippet from a function called by my constructor:\nif (!_fe_problem.hasFunction(\"FeCrAl_hardening_function_296K\"))\n{\nconst std::vector hf0_plastic_strains = {0.0e+00,\n1.0e-03,\n2.0e-03,\n3.0e-03,\n4.0e-03,\n5.0e-03,\n1.0e-02,\n2.0e-02,\n3.0e-02,\n4.0e-02,\n5.0e-02,\n6.0e-02,\n7.0e-02,\n8.0e-02,\n9.0e-02,\n1.0e-01,\n1.1e-01,\n1.6e-01};\nconst std::vector hf0_stresses = {4.55e+08,\n4.65e+08,\n4.71e+08,\n4.75e+08,\n4.79e+08,\n4.82e+08,\n4.94e+08,\n5.12e+08,\n5.26e+08,\n5.39e+08,\n5.51e+08,\n5.63e+08,\n5.74e+08,\n5.85e+08,\n5.96e+08,\n6.07e+08,\n6.17e+08,\n6.72e+08};\nInputParameters hf0_params = _app.getFactory().getValidParams(\"PiecewiseLinear\");\nhf0_params.set<std::vector<Real>>(\"x\") = hf0_plastic_strains;\nhf0_params.set<std::vector<Real>>(\"y\") = hf0_stresses;\n_fe_problem.addFunction(\"PiecewiseLinear\", \"FeCrAl_hardening_function_296K\", hf0_params);\n\n}\n_hf_temperatures.push_back(296.);\n_hardening_functions.push_back(dynamic_cast<const PiecewiseLinear *>(\n&_fe_problem.getFunction(\"FeCrAl_hardening_function_296K\")));\nIn the version that was giving the test crash (segfaulting), the last two lines were inside the if statement, hence, the _hf_temperatures and _hardening_functions ended up having size zero in multi-thread.\nThanks,\nGiovanni",
                  "url": "https://github.com/idaholab/moose/discussions/17361#discussioncomment-514149",
                  "updatedAt": "2022-07-08T00:05:39Z",
                  "publishedAt": "2021-03-22T16:38:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Thanks for posting the solution.",
                          "url": "https://github.com/idaholab/moose/discussions/17361#discussioncomment-527817",
                          "updatedAt": "2022-07-08T00:06:06Z",
                          "publishedAt": "2021-03-25T03:25:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "BC setting with Boundary Value Calculation",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "MOOSE Team,\nFor my transient (unsteady) model, I would like to use NeumannBC for the BC setting and the value of flux is obtained in the following 5 steps for one time level with temperature and time step size called in (total concentration = 0 for the initial condition). Please help.\n(1)\tFor temperature \u2264 100[K], temp = constant_A * temperature\n(2)\tFor temperature > 100[K], temp = constant_B * temperature\nthen\n(3)\tconcentration at the current time step = temp * \u2206t\n(where \u2206t = time step size = current time \u2013 previous time)\n(4)\ttotal concentration = total concentration + temp * \u2206t (concentration at the current time step)\n(5)\tFlux = constant_C * total concentration\nSincerely,\nThomas",
          "url": "https://github.com/idaholab/moose/discussions/17373",
          "updatedAt": "2021-03-31T21:16:46Z",
          "publishedAt": "2021-03-18T17:47:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "If I was doing this, I would compute the \"total concentration\" in a Material object as a material property. Then create a BC object that accepts a constant input parameter and the material property name.",
                  "url": "https://github.com/idaholab/moose/discussions/17373#discussioncomment-503495",
                  "updatedAt": "2021-03-19T14:32:46Z",
                  "publishedAt": "2021-03-19T14:32:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you Andrew!\nI am still new and learning MOOSE.  Please be patient with me.\nAre you suggesting to modify source code \"Material.C\" in /moose/framework/src/materials to include my 5 steps to calculate \"total concentration?\"\nI was thinking to use \"FunctionNeumannBC\" with \"ParsedFunction\" so that I can put my 5 steps in the input file, which is a lot easier for me. Is this possible?\nPlease let me know.\nSincerely,\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17373#discussioncomment-504329",
                          "updatedAt": "2021-03-19T17:30:15Z",
                          "publishedAt": "2021-03-19T17:30:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "No. You should never need to modify source code of MOOSE. You should be working within your own custom application. I suggest you work through our tutorial: https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/17373#discussioncomment-513387",
                          "updatedAt": "2021-03-22T14:11:21Z",
                          "publishedAt": "2021-03-22T14:11:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you Andrew!\nI apologize for my confusing question.\nMy question is what is the specific Material object you suggest to use (GenericConstantMaterial, GenericFunctionMaterial, or Material.C\" in /moose/framework/src/materials).\nI do appreciate your patience with me.\nSincerely,\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17373#discussioncomment-514452",
                          "updatedAt": "2021-03-22T17:52:40Z",
                          "publishedAt": "2021-03-22T17:52:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "You would start by creating an object that inherits from Material, as done here: https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/step09_mat_props.html#step-9-develop-a-material-object",
                          "url": "https://github.com/idaholab/moose/discussions/17373#discussioncomment-527807",
                          "updatedAt": "2021-03-25T03:23:47Z",
                          "publishedAt": "2021-03-25T03:23:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cahn-Hilliard and NeumannBC",
          "author": {
            "login": "souzanha"
          },
          "bodyText": "Hi all!\nI'm working with the Cahn-Hilliard kernels and want to include a BC with an outward flux of a species.\nAt the moment, I'm trying with a constant flux using a NeumannBC. The files compile and the solution converges, but the concentration is not changing. Any suggestions to what could be wrong?\n[Mesh]\ntype = GeneratedMesh # Can generate simple lines, rectangles and rectangular prisms\ndim = 2 # Dimension of the mesh\nnx = 100 # Number of elements in the x direction\nny = 100 # Number of elements in the y direction\nxmin = 0\nxmax = 100e-9\nymin= 0\nymax = 100e-9\n[]\n[Variables]\n[./c]\n[../]\n[./w]\n[../]\n[]\n[ICs]\n[./c]\ntype = ConstantIC\nvariable = c\nvalue = 1\n[../]\n[]\n#[BCs]\n#[./right]\n#type = ADButlerVolmerBC\n#variable = c\n#boundary = right\n#w = w\n#[../]\n#[]\n[BCs]\n[./right]\ntype = NeumannBC\nvariable = w\nboundary = right\nvalue = -0.1\n[../]\n[]\n[Materials]\n[./constants]\ntype = GenericConstantMaterial\nprop_names = 'R T omega Vm D'\nprop_values = '8.3145 298 12e3 43.8e-6 1e-15'\n[../]\n[./free_energy]\ntype = DerivativeParsedMaterial\nf_name = f\nargs = 'c'\nconstant_names = 'R T omega Vm'\nconstant_expressions = '8.3145 298 12e3 43.8e-6'\nfunction = '((RT/Vm)(c*plog(c,1e-3)+(1-c)*plog(1-c,1e-3)))+((omega/Vm)c(1-c))'\nderivative_order = 2\n[../]\n[./mobility]\ntype = DerivativeParsedMaterial\nf_name = mob\nfunction = '(c*(1-c)DVm)/(R*T)'\nargs = 'c'\nconstant_names  = 'R T Vm D'\nconstant_expressions = '8.3145 298 43.8e-6 1e-15'\nderivative_order = 1\n[../]\n[]\n**[Kernels]\n[./time]\ntype=CoupledTimeDerivative\nvariable = w\nv = c\n[../]\n[./wres]\ntype=SplitCHWRes\nvariable = w\nmob_name = mob\n[../]\n[./c_res]\ntype=SplitCHParsed\nvariable = c\nw = w\nf_name = f\nkappa_name = 1.68e-10\n[../]\n[]**\n[Preconditioning]\n[./smp]\ntype = SMP\nfull = true\n[../]\n[]\n[Executioner]\ntype = Transient\nscheme = bdf2\nsolve_type = NEWTON\nl_max_its = 30\nnl_max_its = 10\nl_tol = 1.0e-4\nnl_rel_tol = 1.0e-6\nnl_abs_tol = 1.0e-6\ndt = 1e-3\nend_time = 10\n[]\n[Outputs]\ninterval = 1000\nexodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/17345",
          "updatedAt": "2022-06-22T07:33:44Z",
          "publishedAt": "2021-03-17T08:48:23Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "You probably want to apply the NeumannBC on variable c instead of w.",
                  "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494283",
                  "updatedAt": "2022-06-22T07:33:53Z",
                  "publishedAt": "2021-03-17T15:29:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Yes, I've been thinking about that actually. Looking at the Cahn-Hilliard residual, we get a surface term (boundary term) for both the chemical potential and the concentration. The chemical potential and the concentration are both coupled in a way.\nI started out with applying the NeumannBC on c, and did not get a change in the system. Then I found a few examples where other people have applied the flux to w instead.\nIn the end, I would like to use the Butler-Volmer BC I have which induces a flux of ions, and looking at the published work I try to mimic the flux has the same units as the chemical potential and not the concentration term.\nI would be very happy to discuss this :) Thanks for your answer.",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494731",
                          "updatedAt": "2022-06-22T07:33:54Z",
                          "publishedAt": "2021-03-17T17:18:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Either way you should see a mass change. I am curious how do you know there is no change in the system. Did you compute the total mass and look at its change?",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494839",
                          "updatedAt": "2022-06-22T07:33:54Z",
                          "publishedAt": "2021-03-17T17:38:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "I'm sure there are better way to do this .. but I display the system in Vislt and look at the last time-step. The color bar stays at max/min=1. Could it be that the change is so small that it isn't displayed? I tried plotting it across a line, and still get c=1.",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494878",
                          "updatedAt": "2022-06-22T07:33:54Z",
                          "publishedAt": "2021-03-17T17:45:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "So I display the variable c as a 2D graph.",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494882",
                          "updatedAt": "2022-06-22T12:37:16Z",
                          "publishedAt": "2021-03-17T17:46:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "It is better to use a post processor to compute the integral of c over whole domain.\nI made some tests a while ago. jiangwen84@cf52415\ntake a look at modules/phase_field/test/tests/CahnHilliardFluxBC/anisotropic_split.i  in that branch.",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494946",
                          "updatedAt": "2022-06-22T12:37:14Z",
                          "publishedAt": "2021-03-17T17:58:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Thank you, I'll take a look. I saw some posts regarding the previous CahnHilliardFluxBC but couldn't find any files to look at.\nWhile I have you on the loop, do you mind another question? Its regarding the DerivativeParsedMaterial for the free energy. I have written the function completely underivated (i.e. f_chem(c) and not df/dc that usually goes into the chemical potential), but specified the order to 2. Is this correct?",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-495022",
                          "updatedAt": "2022-06-22T12:37:31Z",
                          "publishedAt": "2021-03-17T18:08:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Correct. The code will compute derivatives up the the order you specify.",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-495098",
                          "updatedAt": "2022-06-22T12:37:31Z",
                          "publishedAt": "2021-03-17T18:24:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Thank you for suggesting the postprocessor, its really handy.\nThis is confusing though, I set the initial condition on c to be 1. However it is 0? It is also increasing (very little) when it actually should decrease due to the negative flux value.\nPostprocessor Values:\n+----------------+----------------+\n| time           | total_solute   |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n|   1.000000e+00 |   1.000000e-14 |\n|   2.000000e+00 |   1.000000e-14 |\n|   3.000000e+00 |   1.000000e-14 |\n|   4.000000e+00 |   1.000000e-14 |\n|   5.000000e+00 |   1.000000e-14 |\n|   6.000000e+00 |   1.000000e-14 |\n|   7.000000e+00 |   1.000000e-14 |\n|   8.000000e+00 |   1.000000e-14 |\n|   9.000000e+00 |   1.000000e-14 |\n|   1.000000e+01 |   1.000000e-14 |\n|   1.100000e+01 |   1.000000e-14 |\n|   1.200000e+01 |   1.000000e-14 |\n|   1.300000e+01 |   1.000000e-14 |\n|   1.400000e+01 |   1.000000e-14 |\n+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-495127",
                          "updatedAt": "2022-06-22T12:37:41Z",
                          "publishedAt": "2021-03-17T18:31:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "From what you showed, the integral of c is 1e-14 and does not change at all.\nLooks like your solution does not actually converge, or not sufficiently. You domain size is too small, and could you change the unit system to make it around 1. It is not necessary but it could make the convergence setup easier.\nYou also need to tight the tolerance a bit, i.e.,\nnl_rel_tol = 1.0e-10\nnl_abs_tol = 1.0e-10",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-495243",
                          "updatedAt": "2022-06-23T14:45:35Z",
                          "publishedAt": "2021-03-17T19:02:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Now it starts to make sense! So the reason I have such a small system is to compare to the published work.\nChanging the tolerance and the size to 1 -> does not converge. Which is a good thing in a way, now I get that something is wrong while knowing something is wrong.\nDo you have any idea for why the initial state doesn't match my input? I'm setting c=1.\nTime Step 0, time = 0\nPostprocessor Values:\n+----------------+----------------+\n| time           | total_solute   |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-496982",
                          "updatedAt": "2022-06-23T14:45:36Z",
                          "publishedAt": "2021-03-18T07:46:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multigrid Solvers in Moose",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Does Moose have the ability to solve Finite Element Problems using multi-grid solvers?",
          "url": "https://github.com/idaholab/moose/discussions/17338",
          "updatedAt": "2022-12-13T13:57:45Z",
          "publishedAt": "2021-03-16T21:35:39Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@fdkong could you elaborate on our capabilities.",
                  "url": "https://github.com/idaholab/moose/discussions/17338#discussioncomment-495621",
                  "updatedAt": "2022-12-13T13:57:45Z",
                  "publishedAt": "2021-03-17T20:38:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "Yes, there are several MG solvers available in MOOSE. For Algebraic MG, we can use hypre (-pc_type hypre), ML (-pc_type ml), and GAMG (-pc_type gamg).\nFor geometric MG, we have something in libmesh, but we do not explore much yet.\nWhat is your context? What are you looking for?",
                  "url": "https://github.com/idaholab/moose/discussions/17338#discussioncomment-495689",
                  "updatedAt": "2022-12-13T13:57:45Z",
                  "publishedAt": "2021-03-17T20:48:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "For the combined solution of the equation of motion (F=ma) and the navier stokes, I am seeking to solve each equation in two separate domains then apply the solution to a third domain which is then applied as an initial condition on the navier stokes domain for successive iterations in time.  Here are some additional details that I seek advisement on for implementation in moose. An example of the method applied in moose would be an even greater starting point for my research:\nEmploy a (rough) boundary parametrization which sufficiently describes all large-scale structures with regard to the boundary conditions.\nTreat all fine- scale features as interior objects such that the corresponding components in all matrices and vectors are unknown degrees offreedom which are implicitely incorporated into all iterative solution steps.\nUtilize filtering techniques to project the corresponding vector components onto the subspace of \"correct\" boundary conditions, before and directly after each iterative substep.",
                          "url": "https://github.com/idaholab/moose/discussions/17338#discussioncomment-495985",
                          "updatedAt": "2022-12-13T13:58:22Z",
                          "publishedAt": "2021-03-17T22:15:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "As far as I know, there is no example close to what you want. I might not completely understand your description here.\nYou may explore a multi-app system that allows to solve different physics and transfer solutions from one system to another. After transfer, you can use the transferred solution as the initial guess for the current system. The projection step can be done as part of the transfer, but you might need to implement your customized projection transfer if the existing transfers do not work for you.",
                          "url": "https://github.com/idaholab/moose/discussions/17338#discussioncomment-526497",
                          "updatedAt": "2022-12-13T13:58:27Z",
                          "publishedAt": "2021-03-24T19:24:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you very much for this information. I think that it will provide a good start in the right direction. I will try the multi app approach.",
                          "url": "https://github.com/idaholab/moose/discussions/17338#discussioncomment-527100",
                          "updatedAt": "2022-12-13T13:58:27Z",
                          "publishedAt": "2021-03-24T22:17:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A few questions on the DG Capabilities in MOOSE",
          "author": {
            "login": "pzimbrod"
          },
          "bodyText": "Hi all,\nI'm currently setting up MOOSE to help me model the complex physics within metal additive manufacturing (Powder Bed Fusion, to be precise). As there are a lot of length scales involved, the capabilities of MOOSE are really helping me out and I'm loving the framework and its structure, thanks for the extensive work so far!\nAs I'm also dealing with rather complex advection-diffusion equations and I have a background coming from FV based methods, I was looking into the DG capabilities of MOOSE. My understanding is that it provides a useful formulation for such problems as CG-FEM falls behind on solving hyperbolic PDEs (see e.g. 1,  Theorem 5.3 p.222) and FV has obvious limitations regarding p-refinement (which to my understanding is especially nice when solving in parallel to reduce MPI communication).\nI've looked into the documentation of the DG Kernels along with the test cases and came across a few questions regarding the implementation:\n\nFirst of all, I'm wondering why you need to specify the DG Kernels separately as an addition to a regular kernel, instead of replacing it - see e.g.:\n\n[...]\n[Variables]\n  [./u]\n    order = FIRST\n    family = MONOMIAL\n  [../]\n[]\n\n[Kernels]\n  [./time_u]\n    type = TimeDerivative\n    variable = u\n  [../]\n\n  [./adv_u]\n    implicit = false\n    type = ConservativeAdvection\n    variable = u\n    velocity = '1 0 0'\n  [../]\n[]\n\n[DGKernels]\n  [./dg_advection_u]\n    implicit = false\n    type = DGConvection\n    variable = u\n    velocity = '1 0 0'\n  [../]\n[]\n\n[...]\n(from test/tests/dgkernels/1d_advection_dg/1d_advection_dg.i)\nI stumbled across this as I was trying to modify these simple test cases and noticed the redundant definitions of velocity in this case. Is this a requirement or rather a workaround so the DG schemes fit in nicely with the CG main code of MOOSE?\n\n\nI've looked into the source of some DG Kernels and got the impression that the code uses the same basis for trial and test function, so adhering to the Bubnov instead of Petrov Galerkin method. That would fit into the concept of the \"main\" code as declared here. Is that correct? If so, wouldn't it be more advantageous in terms of assembling the mass matrix to allow for separate function spaces or is this too complicated to implement or otherwise not feasible? Ern and Guermod1 address this issue e.g. in Remark 5.4 p. 225 and in chap. 5.7.\n\n\nWhen looking at the source code and examples, I couldn't find input file entries or info about the upwinding scheme used - which to my knowledge would be required at least for convection-type problems. How is this done in MOOSE? From FV I know some schemes in order to get reasonable tradeoff between diffusivity and stability, e.g. with WENO or TVD schemes (MinMod, SuperBee, etc.). If that's something to still implement into MOOSE, would it be possible to carry these over from the rDG app? I've seen here that some TVD limiters have already been introduced into the rDG scheme. If so, I'd try to do that for myself and when that yields satisfactory results, share the code of course with everyone.\n\n\nLastly, do you guys think that further developing DG Kernels in MOOSE is even worthwhile in comparison with the classic CG-FEM for dealing with hyperbolic PDEs? Surely, CG-FEM (at least as I know it) is better suited for elliptic and parabolic problems, but does anyone know how severe the performance disadvantage for hyperbolic problems is in comparison to e.g. FV or rDG in this case? I'm asking since e.g. in your tutorial sessions (which helped me hugely set foot into the MOOSE ecosystem btw) you deal with advection problems in a fairly confident manner, so I got the impression that problems of such type would not be a big deal for MOOSE. Also, according to your website, even the Navier Stokes app relies on the CG-FEM method which got me wondering quite a bit.\nI know that's a lot of questions, sorry for the long text. Hopefully someone can help shed some light on these topics.\nThanks and have a good weekend,\nPatrick\n\n1: A. Ern, J.-L. Guermond. Theory and Practice of Finite Elements, Springer 2004.",
          "url": "https://github.com/idaholab/moose/discussions/17383",
          "updatedAt": "2022-06-14T22:54:48Z",
          "publishedAt": "2021-03-19T10:25:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad You should probably help out here.",
                  "url": "https://github.com/idaholab/moose/discussions/17383#discussioncomment-503428",
                  "updatedAt": "2022-06-14T22:54:58Z",
                  "publishedAt": "2021-03-19T14:18:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "1. First of all, I'm wondering why you need to specify the DG Kernels separately as an addition to a regular kernel, instead of replacing it - see e.g.:\n\n\nWe use Beatrice Riviere's \"Discontinuous Galerkin Methods for Solving Elliptic and Parabolic Equations: Theory and Implementation\" text for implementing the relatively rudimentary objects you are looking at. The object naming is definitely confusing. One would very reasonably think that DGConvection does everything needed for a DG method...but it doesn't. It instead implements only the convection interior face term. So If you have Riviere's text, DGConvection implements the middle term of equation 4.9. You still need ConservativeAdvection to capture the first term of equation 4.9, e.g. the elemental contributions.\n\n2. I've looked into the source of some DG Kernels and got the impression that the code uses the same basis for trial and test function, so adhering to the Bubnov instead of Petrov Galerkin method. That would fit into the concept of the \"main\" code as declared [here](https://mooseframework.inl.gov/source/problems/FEProblemBase.html#shape_functions). Is that correct? If so, wouldn't it be more advantageous in terms of assembling the mass matrix to allow for separate function spaces or is this too complicated to implement or otherwise not feasible? Ern and Guermod1 address this issue e.g. in Remark 5.4 p. 225 and in chap. 5.7.\n\n\nThis is definitely true for the objects you are looking at. However, an application developer/MOOSE user has complete flexibility to choose the finite element method they wish. An example of this from continuous finite elements draws from the ADKernelStabilized and its child ADKernelSUPG where the user \"strong residual\" (which should look exactly like terms in the non-integrated/strong PDE) is multiplied by velocity * tau * grad_test. Here grad_test is indeed based off the same finite element family and order as the shape function used to evaluate the approximate solution, but this is still a piece of a Petrov-Galerkin method. In general you can write your own kernels, and define computeQpResidual (or its relatives) however you wish. E.g. you are not constrained to multiply by the _test member that corresponds to the Bubnov-Galerkin method.\n\n3\\. When looking at the source code and examples, I couldn't find input file entries or info about the upwinding scheme used - which to my knowledge would be required at least for convection-type problems. How is this done in MOOSE? From FV I know some schemes in order to get reasonable tradeoff between diffusivity and stability, e.g. with WENO or TVD schemes (MinMod, SuperBee, etc.). If that's something to still implement into MOOSE, would it be possible to carry these over from the rDG app? I've seen [here](https://mooseframework.inl.gov/modules/rdg/index.html) that some TVD limiters have already been introduced into the rDG scheme. If so, I'd try to do that for myself and when that yields satisfactory results, share the code of course with everyone.\n\n\nDGConvection uses simple upwinding. We would certainly welcome more advanced convection discretizations in the framework or in our modules. To be honest, the DG kernels that are currently in the framework are probably not used by anyone in \"production\"-level simulations. I do not know too much about our rDG module. Perhaps @andrsd or @joshuahansel can comment more on that. I believe most of rDG development to date has been done with 1D target applications, but I'm not going to say that it won't work in multi-dimensions (simply because I do not know). We have been focusing a lot of development recently on finite volume in MOOSE and we have worked mostly on HLLC for free-flow and porous versions of the Euler equations. I know that rDG has some code for WENO/TVD schemes, including the MinMod and SuperBee that you mentioned.\n\nLastly, do you guys think that further developing DG Kernels in MOOSE is even worthwhile in comparison with the classic CG-FEM for dealing with hyperbolic PDEs? Surely, CG-FEM (at least as I know it) is better suited for elliptic and parabolic problems, but does anyone know how severe the performance disadvantage for hyperbolic problems is in comparison to e.g. FV or rDG in this case? I'm asking since e.g. in your tutorial sessions (which helped me hugely set foot into the MOOSE ecosystem btw) you deal with advection problems in a fairly confident manner, so I got the impression that problems of such type would not be a big deal for MOOSE. Also, according to your website, even the Navier Stokes app relies on the CG-FEM method which got me wondering quite a bit.\n\nI do think that DG/rDG/FV development/use in advection dominated applications is critical/advantageous when compared to CG-FEM. We have done a fair amount of simulation of incompressible Navier-Stokes with CFEM, but I think that in the long haul our discontinuos schemes are going to win out and become the schemes predominantly used by our user-base. CFEM in general struggles around any area of discontinuity whether it be at a corner where you have different boundary conditions meeting, or near shocks. Here is a very relevant figure of CFEM failing to handle the canonical Sod shock-tube problem:\n\nFinite volume development is very heavy right now. I'll point you to the recently merged #15644 and open pull request #17088. I also have a CNSFV branch that I'm currently working on that we'll be submitting a PR to MOOSE for once we receive approval from export control. And with respect to more sophisticated DG/rDG objects compared to those currently in the framework I'll leave that to @andrsd and @joshuahansel",
                  "url": "https://github.com/idaholab/moose/discussions/17383#discussioncomment-519857",
                  "updatedAt": "2022-06-14T22:54:58Z",
                  "publishedAt": "2021-03-23T20:57:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@pzimbrod if you have any follow-on questions, please let me know. We certainly welcome new contributors!!",
                          "url": "https://github.com/idaholab/moose/discussions/17383#discussioncomment-519909",
                          "updatedAt": "2022-06-14T22:56:51Z",
                          "publishedAt": "2021-03-23T21:11:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "When looking at the source code and examples, I couldn't find input file entries or info about the upwinding scheme used\n\nThe rDG module has only implemented the scalar advection equation. Its upwinding scheme is implemented in AEFVUpwindInternalSideFlux, and this is the general strategy - you implement your numerical flux scheme in a flux user object.\n\nFrom FV I know some schemes in order to get reasonable tradeoff between diffusivity and stability, e.g. with WENO or TVD schemes (MinMod, SuperBee, etc.). If that's something to still implement into MOOSE, would it be possible to carry these over from the rDG app?\n\nThere is no generic WENO/TVD capability in the rDG module, just the implementation for the scalar advection equation. The rDG mostly just provides base classes that can be useful for implementing an rDG scheme.",
                  "url": "https://github.com/idaholab/moose/discussions/17383#discussioncomment-520523",
                  "updatedAt": "2022-06-14T22:56:50Z",
                  "publishedAt": "2021-03-23T23:16:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "pzimbrod"
                  },
                  "bodyText": "Thank you both for the valuable insights! Definitely helped me a lot wrapping my head around the DG functionality that's already implemented in MOOSE. I'll look into that subject a little more in the next time and make sure to submit a PR as soon as I get a fruitful solution out of these ideas. I won't dare to make any promises since I come from using OpenFOAM and am rather new to the MOOSE style of getting things done, but definitely will give it a shot.\nPlease keep up the good work, I'd love to see projects like these pick up momentum in all types of applications!",
                  "url": "https://github.com/idaholab/moose/discussions/17383#discussioncomment-521456",
                  "updatedAt": "2022-06-14T22:56:53Z",
                  "publishedAt": "2021-03-24T07:17:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Nonlinear Convergence problem in Phase field",
          "author": {
            "login": "ada-ayy"
          },
          "bodyText": "Dear Moose users:\nI am trying to solve an equation like this:\n\nWhen I set the L to be a constant, it can be well solved.\nHowever, when I try to set L as a function of G (elastic energy, while Gc is the constant critical value), the time step keeps reducing by half. Even if I construct L to be a smooth function of G, it still faces the same problem.\nI have tried to use ParsedMaterial to define the L.\nAlso, I have tried to use AuxVariable/ AuxKernel as below:\n[AuxVariables]\n [./mob]\n  order = CONSTANT\n  family = MONOMIAL\n [../]\n[]\n\n[AuxKernels]\n [./MOB]\n  type =MaterialRealAux\n  property = Fe\n  variable = mob\n [../]\n[]\n\n  [./L]\n    type = ParsedMaterial\n    f_name = L\n    args = 'mob'\n    function = 'if (mob <0.0001, 0, if( mob > 0.002,10,(mob-0.0001)*(mob-0.0001)*(mob-0.002)*(mob-0.002)))'\n    outputs = exodus\n    block = 0\n  [../]\n\nThanks,\nAda",
          "url": "https://github.com/idaholab/moose/discussions/17310",
          "updatedAt": "2023-03-02T08:34:03Z",
          "publishedAt": "2021-03-14T05:09:42Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Ada\nBy the time step keeps reducing by half you mean the non-linear solves are not converging?\nCan you plot the values of L in the domain by converting it to an AuxVariable using a MaterialAuxKernel to see what is happening with L\nI reformatted your code with ``` btw.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17310#discussioncomment-495465",
                  "updatedAt": "2023-03-02T08:34:18Z",
                  "publishedAt": "2021-03-17T19:57:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "Thank you for your reply!\nThis is the distribution of L at t = 0\n\nand this is L at t = 3 (when it gets stuck)\n\n\nAlso, this is the elastic energy Fe at t=3\n\nBy contrast, this is Fe when setting L = constant at 3",
                          "url": "https://github.com/idaholab/moose/discussions/17310#discussioncomment-496776",
                          "updatedAt": "2023-03-02T08:34:21Z",
                          "publishedAt": "2021-03-18T05:55:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "A zero mobility such as this is likely to be a problem when using an implicit time stepping scheme. You could try making your L some very small number like 10^-2 or 10^-3 such that microstructural evolution in the region where G<G_c is negligible. (This is probably more realistic physically anyway because it's unlikely that the mobility of a solute species is identically 0.)  You could also try using an explicit time stepper.",
                          "url": "https://github.com/idaholab/moose/discussions/17310#discussioncomment-504323",
                          "updatedAt": "2023-03-02T08:34:44Z",
                          "publishedAt": "2021-03-19T17:28:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "Thank you for your advice!! I have used 'tanh' as well to solve this problem.",
                          "url": "https://github.com/idaholab/moose/discussions/17310#discussioncomment-521278",
                          "updatedAt": "2023-03-02T08:34:44Z",
                          "publishedAt": "2021-03-24T05:44:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Prefactor of ComputeExtraStressConstant cannot be defined by ParsedFunction",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nFor some reason I cannot define the Prefactor of ComputeExtraStressConstant by ParsedFunction\nI thought it would be straightforward like other properties (density and elastic_tensor), but apparently, it's not.\ncould you please help me have a look?\n[./const_stress]\n  type = ComputeExtraStressConstant\n  block = 1\n  extra_stress_tensor = '1 1 1 0 0 0'\n prefactor = stress_fac1\n[../]\n\nParsedFunction is shown below\n[./stress_fac1]\n  type = ParsedFunction\n  value = 'if(t=2,1e4,1)'\n[../]\n\nerror says One or more Material Properties were not supplied on block 1: stress_fac1\nI reckon it might got something to do with .C file of ComputeExtraStressConstant\nThank you guys,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/17410",
          "updatedAt": "2022-06-15T11:57:38Z",
          "publishedAt": "2021-03-23T05:04:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "For whatever reason, prefactor is a MaterialProperty name.  So you must define something like this\n[Materials]\n  [fac1]\n    type = GenericConstantMaterial\n    prop_names = stress_fac1\n    prop_values = 1234.5\n  []\n\nAlthough the ComputeExtraStressConstant:prefactor says it is Name of material defining additional constant prefactor, i don't see why it needs to be constant.  Perhaps someone can explain the documentation.  It looks like you could also do:\n[Materials]\n  [fac1]\n    type = GenericFunctionMaterial\n    prop_names = stress_fac1\n    prop_values = fac1_fcn\n  []\n[]\n[Functions]\n  [fac1_fcn]\n    type = ParsedFunction\n    value = 'if(t=2,1e4,1)'\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/17410#discussioncomment-516245",
                  "updatedAt": "2022-06-18T21:54:40Z",
                  "publishedAt": "2021-03-23T05:46:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi Andy, thank you, may I ask how does 'GenericFunctionMaterial' knows that I'm calling ComputeExtraStressConstant, I'm a bit confused.",
                          "url": "https://github.com/idaholab/moose/discussions/17410#discussioncomment-516258",
                          "updatedAt": "2022-07-29T10:05:56Z",
                          "publishedAt": "2021-03-23T05:55:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "It doesn't.  GenericFunctionMaterial will calculate a thing called stress_fac1 (the prop_names), regardless of the rest of your input file.  It's up to the ComputeExtraStressConstant to utilize this using its prefactor.  The MOOSE dependency resolver ensures that the GenericFunctionMaterial computes stress_fac1 before it is used by ComputeExtraStressConstant.\nSimilarly, all your other Materials just compute their MaterialProperties, regardless of whether you use them in Kernels etc.  If you really wanted to burden your computer, you could define a million Materials that aren't used by anything, and MOOSE would still compute them.",
                          "url": "https://github.com/idaholab/moose/discussions/17410#discussioncomment-516321",
                          "updatedAt": "2022-07-29T10:05:56Z",
                          "publishedAt": "2021-03-23T06:05:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi Andy, yes, I kinda get it now, basically I need to call both ComputeExtraStressConstant and GenericFunctionMaterial, and it will look like this (very messy though)\n[Materials]\n[./const_stress]\n  type = ComputeExtraStressConstant\n  block = 1\n  extra_stress_tensor = '1 1 1 0 0 0'\n prefactor = stress_fac1\n[../]\n  [fac1]\n    type = GenericFunctionMaterial\n    prop_names = stress_fac1\n    prop_values = fac1_fcn\n  []\n[]\n\n[Functions]\n  [fac1_fcn]\n    type = ParsedFunction\n    value = 'if(t=2,1e4,1)'\n  []\n[]\n\nThank you again for your help! I learn a lot from you here :)\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17410#discussioncomment-516332",
                          "updatedAt": "2022-07-29T10:05:58Z",
                          "publishedAt": "2021-03-23T06:09:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "HeatSource and DerivativeParsedMaterial",
          "author": {
            "login": "hamedattariani"
          },
          "bodyText": "We are solving two coupled transient heat conduction differential equations. The heat source terms (body force) in each equation are functions of temperatures, e.g. A*(T1-T2). So, we used \"HeatSource\" along with \"DerivativeParsedMaterial\" to define the source terms. This implementation does not work, because we see temperature rise, although one sets the heat source to zero. I think this implementation messes up the weak forms. Do I need to write a new kernel for this body force or there is already a kernel for this purpose in MOOSE?\n[./volumetric_heat]\ntype = DerivativeParsedMaterial\nf_name = 'volumetric_heat1'\nargs = 'T1 T2'\nfunction ='(1000)*(T1-T2)'\n[../]",
          "url": "https://github.com/idaholab/moose/discussions/17402",
          "updatedAt": "2022-11-10T21:40:35Z",
          "publishedAt": "2021-03-22T20:19:26Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthere should be an \u2018ambient convection\u2019 kernel of this form in the navier stokes module you may use. I can\u2019t now but I ll have a look later to see if I can post a link to it here\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17402#discussioncomment-515036",
                  "updatedAt": "2022-11-10T21:40:35Z",
                  "publishedAt": "2021-03-22T20:22:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hamedattariani"
                          },
                          "bodyText": "I just looked at the Kernel. \"T_ambient\" is defined as a constant. In our case, T_ambient is the main variable itself.\nThe system of equations is as follow:\nHeat capacityd(T1/dt)=...+(T1-T2)\nHeat capacityd(T2/dt)=...-(T1-T2)",
                          "url": "https://github.com/idaholab/moose/discussions/17402#discussioncomment-515083",
                          "updatedAt": "2022-11-10T21:40:36Z",
                          "publishedAt": "2021-03-22T20:39:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok then you could implement a version with non-constant T_ambient but a coupledVar instead.\nThe finite volume implementation, NSFVEnergyAmbientConvection has it set up that way",
                          "url": "https://github.com/idaholab/moose/discussions/17402#discussioncomment-515285",
                          "updatedAt": "2022-11-10T21:40:37Z",
                          "publishedAt": "2021-03-22T21:36:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}