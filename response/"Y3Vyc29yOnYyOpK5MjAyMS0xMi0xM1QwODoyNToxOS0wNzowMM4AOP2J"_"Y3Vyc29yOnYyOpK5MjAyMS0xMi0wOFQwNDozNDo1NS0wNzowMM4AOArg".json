{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMi0wOFQwNDozNDo1NS0wNzowMM4AOArg"
    },
    "edges": [
      {
        "node": {
          "title": "built rtags",
          "author": {
            "login": "xiaojbing"
          },
          "bodyText": "I try to build rtags in my ubantu 20.04\uff0c\ngit clone https://github.com/Andersbakken/rtags.git\ncd rtags/\ngit submodule init\ngit submodule update\nmkdir mybuild && cd mybuild\ncmake ..\nmake\nbut when I use the command :make ,an error appeared as followed.\n[  1%] Building CXX object src/CMakeFiles/rtags.dir/ClangIndexer.cpp.o\n[  2%] Building CXX object src/CMakeFiles/rtags.dir/ClangThread.cpp.o\n[  4%] Building CXX object src/CMakeFiles/rtags.dir/ClassHierarchyJob.cpp.o\n[  5%] Building CXX object src/CMakeFiles/rtags.dir/CompilerManager.cpp.o\n[  7%] Building CXX object src/CMakeFiles/rtags.dir/CompletionThread.cpp.o\n[  8%] Building CXX object src/CMakeFiles/rtags.dir/DependenciesJob.cpp.o\n[  9%] Building CXX object src/CMakeFiles/rtags.dir/IncludePathJob.cpp.o\n[ 11%] Building CXX object src/CMakeFiles/rtags.dir/FileManager.cpp.o\n[ 12%] Building CXX object src/CMakeFiles/rtags.dir/FindFileJob.cpp.o\n[ 14%] Building CXX object src/CMakeFiles/rtags.dir/FindSymbolsJob.cpp.o\n[ 15%] Building CXX object src/CMakeFiles/rtags.dir/FollowLocationJob.cpp.o\n[ 16%] Building CXX object src/CMakeFiles/rtags.dir/IncludeFileJob.cpp.o\n[ 18%] Building CXX object src/CMakeFiles/rtags.dir/IndexMessage.cpp.o\n[ 19%] Building CXX object src/CMakeFiles/rtags.dir/IndexParseData.cpp.o\n[ 21%] Building CXX object src/CMakeFiles/rtags.dir/IndexerJob.cpp.o\n[ 22%] Building CXX object src/CMakeFiles/rtags.dir/JobScheduler.cpp.o\n[ 23%] Building CXX object src/CMakeFiles/rtags.dir/ListSymbolsJob.cpp.o\n[ 25%] Building CXX object src/CMakeFiles/rtags.dir/Location.cpp.o\n[ 26%] Building CXX object src/CMakeFiles/rtags.dir/Preprocessor.cpp.o\n[ 28%] Building CXX object src/CMakeFiles/rtags.dir/Project.cpp.o\n[ 29%] Building CXX object src/CMakeFiles/rtags.dir/QueryJob.cpp.o\n[ 30%] Building CXX object src/CMakeFiles/rtags.dir/QueryMessage.cpp.o\n[ 32%] Building CXX object src/CMakeFiles/rtags.dir/RClient.cpp.o\n[ 33%] Building CXX object src/CMakeFiles/rtags.dir/RTags.cpp.o\n[ 35%] Building CXX object src/CMakeFiles/rtags.dir/ReferencesJob.cpp.o\n[ 36%] Building CXX object src/CMakeFiles/rtags.dir/Sandbox.cpp.o\n[ 38%] Building CXX object src/CMakeFiles/rtags.dir/ScanThread.cpp.o\n[ 39%] Building CXX object src/CMakeFiles/rtags.dir/Server.cpp.o\n[ 40%] Building CXX object src/CMakeFiles/rtags.dir/ServerMessageHandlers.cpp.o\n[ 42%] Building CXX object src/CMakeFiles/rtags.dir/Source.cpp.o\n[ 43%] Building CXX object src/CMakeFiles/rtags.dir/StatusJob.cpp.o\n[ 45%] Building CXX object src/CMakeFiles/rtags.dir/Symbol.cpp.o\n[ 46%] Building CXX object src/CMakeFiles/rtags.dir/SymbolInfoJob.cpp.o\n[ 47%] Building CXX object src/CMakeFiles/rtags.dir/Token.cpp.o\n[ 49%] Building CXX object src/CMakeFiles/rtags.dir/TokensJob.cpp.o\n[ 50%] Linking CXX static library librtags.a\n[ 50%] Built target rtags\nScanning dependencies of target rct\n[ 52%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/Buffer.cpp.o\n[ 53%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/Config.cpp.o\n[ 54%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/Connection.cpp.o\n[ 56%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/CpuUsage.cpp.o\n[ 57%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/Date.cpp.o\n[ 59%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/EventLoop.cpp.o\n[ 60%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/FileSystemWatcher.cpp.o\n[ 61%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/Log.cpp.o\n[ 63%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/MemoryMonitor.cpp.o\n[ 64%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/Message.cpp.o\n[ 66%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/MessageQueue.cpp.o\n[ 67%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/Path.cpp.o\n[ 69%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/Plugin.cpp.o\n[ 70%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/Rct.cpp.o\n[ 71%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/ReadWriteLock.cpp.o\n[ 73%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/Semaphore.cpp.o\n[ 74%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/SharedMemory.cpp.o\n[ 76%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/SocketClient.cpp.o\n[ 77%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/SocketServer.cpp.o\n[ 78%] Building CXX object src/CMakeFiles/rct.dir/rct/rct/String.cpp.o\n/home/xjb/rtags/src/rct/rct/String.cpp:3:10: fatal error: zconf.h:No such file or directory\n3 | #include <zconf.h>\n|          ^~~~~~~~~\ncompilation terminated.\nmake[2]: *** [src/CMakeFiles/rct.dir/build.make:310\uff1asrc/CMakeFiles/rct.dir/rct/rct/String.cpp.o] error 1\nmake[1]: *** [CMakeFiles/Makefile2:1110\uff1asrc/CMakeFiles/rct.dir/all] error 2\nmake: *** [Makefile:141\uff1aall] error 2\nso, how should I solve this ?",
          "url": "https://github.com/idaholab/moose/discussions/19594",
          "updatedAt": "2022-06-22T12:39:12Z",
          "publishedAt": "2021-12-10T06:15:54Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "See this answer\nhttps://stackoverflow.com/questions/67621721/zlib-h3419-fatal-error-zconf-h-no-such-file-or-directory-include-zconf-h\nseems you need to install a package for it",
                  "url": "https://github.com/idaholab/moose/discussions/19594#discussioncomment-1787397",
                  "updatedAt": "2022-06-22T12:39:19Z",
                  "publishedAt": "2021-12-10T18:23:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "thanks very much , it works. but when I run\nMOOSE_UNITY=false make compile_commands.json && rc -J .\nin the directory projects/moose/modules, a new error occurred.\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/libtool: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/libtool: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\nUsing HIT from /home/xjb/projects/moose/framework/contrib/hit\n/bin/sh: 1: /home/xjb/projects/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n[Server] Compilation failed to load.",
                          "url": "https://github.com/idaholab/moose/discussions/19594#discussioncomment-1792427",
                          "updatedAt": "2022-07-01T11:08:36Z",
                          "publishedAt": "2021-12-12T04:06:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "I forget to use\nconda activate moose\nsorry. . .   there is no problem now.",
                          "url": "https://github.com/idaholab/moose/discussions/19594#discussioncomment-1796722",
                          "updatedAt": "2022-07-01T11:08:36Z",
                          "publishedAt": "2021-12-13T08:59:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "nice glad it works!",
                          "url": "https://github.com/idaholab/moose/discussions/19594#discussioncomment-1798728",
                          "updatedAt": "2022-07-01T11:08:49Z",
                          "publishedAt": "2021-12-13T14:49:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiphase simulations with grain tracker \"Material has no property named: L\"",
          "author": {
            "login": "ritamcj"
          },
          "bodyText": "Hi everyone,\nI am attempting to simulate nucleation and grain growth in a dual phase material. Currently, in my input file, I have defined order parameters eta1 and eta2 for the two phases, which evolve according to the Allen-Cahn equation. To incorporate grain growth, as soon as I incorporate grain tracker, I am seeing an error \"Material has no property named: L\". I realize that mobility is required for the Allen-Cahn equation for the grains. I attempted various methods such as defining a generic material with L/ defining L as a global parameter. I also tried to define grains as gr0,gr1 etc. and using the Allen-Cahn kernel as:\n [./dgr0dt]\n    type = TimeDerivative\n    variable = gr0\n    [../]\n\n  [./ACBulk1_gr0]\n    type = AllenCahn\n    variable = gr0\n    args = 'c'\n    mob_name = L1\n    f_name = F\n  [../]\n\nAll these methods haven't worked. I'd be grateful if someone could highlight a mistake in the current approach. A pseudo-code is attached.\nWarm regards,\nRitam Chatterjee\nL_error_test.txt",
          "url": "https://github.com/idaholab/moose/discussions/18515",
          "updatedAt": "2022-06-29T05:45:52Z",
          "publishedAt": "2021-08-03T17:19:32Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Do you want to simulate a poly crystalline material with many grains where each grain can be one of two phases (and an arbitrary orientation)?\nCheck out ACGrGrMulti and see if that gets you anywhere. It is a multi-phase multi-grain grand potential model.\nhttps://mooseframework.inl.gov/moose/source/kernels/ACGrGrMulti.html\n@laagesen can probably elaborate further if necessary.",
                  "url": "https://github.com/idaholab/moose/discussions/18515#discussioncomment-1127064",
                  "updatedAt": "2022-06-29T05:45:52Z",
                  "publishedAt": "2021-08-03T19:12:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Thank you Daniel, this is really helpful. I will read Aagesen et al. (2018) and then try implement.",
                          "url": "https://github.com/idaholab/moose/discussions/18515#discussioncomment-1128775",
                          "updatedAt": "2022-06-29T05:45:55Z",
                          "publishedAt": "2021-08-04T06:10:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "By \"implement\" you mean write an input file? Because the model is already coded up in MOOSE as far as I can see.",
                          "url": "https://github.com/idaholab/moose/discussions/18515#discussioncomment-1130802",
                          "updatedAt": "2022-06-29T05:45:55Z",
                          "publishedAt": "2021-08-04T15:25:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Yes I will add it to my input file and make modifications in the code if necessary.",
                          "url": "https://github.com/idaholab/moose/discussions/18515#discussioncomment-1131654",
                          "updatedAt": "2022-06-29T05:45:56Z",
                          "publishedAt": "2021-08-04T19:17:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "I just wanted to update that \"Material has no property named: L\" occurred because I had declared a velocity gradient tensor in FiniteStrainUObasedCP as 'L', which caused a mixup of variable names. Silly mistake but I'm glad I noticed that.",
                          "url": "https://github.com/idaholab/moose/discussions/18515#discussioncomment-1795929",
                          "updatedAt": "2022-09-01T10:33:37Z",
                          "publishedAt": "2021-12-13T05:26:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Slower when computing across nodes",
          "author": {
            "login": "xiekai-mc"
          },
          "bodyText": "Hello everyone.\nI find that it is slower when computing across nodes.\nThis is my input file: input.zip\nIt is basically the same as part_1.2.i.\nThere are some changes in the Mesh, BCs and Executioner:\n[Mesh]\n  file = necking_quad4.e\n  uniform_refine = 6\n[]\n[BCs]\n  [./left]\n    type = DirichletBC\n    variable = disp_x\n    boundary = left\n    value = 0.0\n  [../]\n  [./bottom]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0.0\n  [../]\n  [./top]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = top\n    function = 't'\n  [../]\n[]\n[Executioner]\n  type = Transient\n  dt = 0.001\n  end_time = 0.6\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart'\n  petsc_options_value = 'asm lu 1 101'\n[]\n\n26 processors, 52 processors and 104 processors (2 nodes, 52 for each) were used.\nThe following is their performance log:\n\nAnd their full logs: log.zip\nI find that the time of FEProblem::computeResidualInternal and FEProblem::computeJacobianInternal in the Total(s) column is almost doubled when computing across nodes. I guess something's wrong. Please help me.",
          "url": "https://github.com/idaholab/moose/discussions/19598",
          "updatedAt": "2022-06-12T09:29:28Z",
          "publishedAt": "2021-12-10T10:44:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere are many things to be mindful about when doing parallel simulations to get good scaling far out.\nFirst you should try to use a distributed mesh (--distributed-mesh) so that mesh operations are not replicated (here, you are spending most of the time computing the residual, so it should not be the problem)\nThen you should use a preconditioner that scales well. SMP+asm should be ok. I dont know if it s the best fitted for this particular physics.\nHow are the number of iterations evolving as the number of processes is increased?\nYou should make sure you have enough DOFs on every rank. At least 20,000. What does it say in the beginning of the log?\nUniform refine = 6 is quite a bit of refinement, but still good to check.\nGuillaume\nPS: I would also look through other discussions to find more advice previously given on this forum by other devs.",
                  "url": "https://github.com/idaholab/moose/discussions/19598#discussioncomment-1787308",
                  "updatedAt": "2022-06-12T09:29:30Z",
                  "publishedAt": "2021-12-10T18:04:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "Thank you for your help. I should use the distributed mesh.\nHere is the result using the distributed mesh. The end_time was changed from 0.6 to 0.3.\n\nIt looks much better. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/19598#discussioncomment-1790506",
                          "updatedAt": "2022-06-12T09:29:31Z",
                          "publishedAt": "2021-12-11T13:53:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Comunnication between nodes can have a.fairly large overhead depending on the architecture of your cluster. I observe the same thing on some of the nodes on our university's cluster, if there is a way to improve the speed, I'm all ears.",
                  "url": "https://github.com/idaholab/moose/discussions/19598#discussioncomment-1789411",
                  "updatedAt": "2022-06-12T09:29:46Z",
                  "publishedAt": "2021-12-11T02:21:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE Build Error",
          "author": {
            "login": "aarograh"
          },
          "bodyText": "I'm trying get get a MOOSE environment set up for myself.  I'm working in the windows subsystem for linux, so it's ubuntu 20.04.  I had an old environment and tried updating it, but I hit the build error below.  I decided to just completely wipe my MOOSE repo and miniconda installation to start from scratch.  I did that, then exactly followed the instructions here: https://mooseframework.inl.gov/getting_started/installation/conda.html .  I encountered no errors along the way.  However, upon trying to build, I'm still getting the exact same sets of error messages shown below.  Any ideas what's going on?  It seems like it's looking for libmesh in the moose directory instead of in the conda environment?\n(moose) aarograh@PC0123449:~/ag6-windows/repos/moose/test$ make -j 4\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/libtool: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/libtool: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\nUsing HIT from /home/aarograh/ag6-windows/repos/moose/framework/contrib/hit\nRebuilding symlinks in /home/aarograh/ag6-windows/repos/moose/framework/build/header_symlinks\nRebuilding symlinks in /home/aarograh/ag6-windows/repos/moose/test/build/header_symlinks\nChecking if header needs updating: /home/aarograh/ag6-windows/repos/moose/framework/include/base/MooseRevision.h...\nCreating Unity Directory /home/aarograh/ag6-windows/repos/moose/framework/build/unity_src\nCopying default MOOSE configuration to: /home/aarograh/ag6-windows/repos/moose/framework/include/base/MooseConfig.h...\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\nCompiling C++ (in opt mode) /home/aarograh/ag6-windows/repos/moose/framework/contrib/pcre/src/pcrecpp.cc...\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/libtool: not found\nCompiling C++ (in opt mode) /home/aarograh/ag6-windows/repos/moose/framework/contrib/pcre/src/pcre_stringpiece.cc...\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/contrib/bin/libmesh-config: not found\nmake: *** [/home/aarograh/ag6-windows/repos/moose/framework/build.mk:119: /home/aarograh/ag6-windows/repos/moose/framework/contrib/pcre/src/pcrecpp..opt.lo] Error 127\nmake: *** Waiting for unfinished jobs....\n/bin/sh: 1: /home/aarograh/ag6-windows/repos/moose/libmesh/installed/libtool: not found",
          "url": "https://github.com/idaholab/moose/discussions/19604",
          "updatedAt": "2022-06-22T12:36:51Z",
          "publishedAt": "2021-12-10T20:24:45Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Try closing your terminal and opening it again. You command line prompt should contain (moose) now. If not then you didn't follow the instructions exactly :-). You might be missing the conda init step or the conda activate moose step.",
                  "url": "https://github.com/idaholab/moose/discussions/19604#discussioncomment-1788196",
                  "updatedAt": "2022-06-22T12:36:55Z",
                  "publishedAt": "2021-12-10T20:30:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "I did follow the instructions exactly and my terminal contained (moose) like you said (I've done this before, it has just been awhile).\nThat being said, I closed the terminal and tried again and it seems to be working.  Re-reading the instructions, I think this part may have been the source of confusion:\n\n\n\"Where SHELL_NAME is the shell you discovered in the previous step. Once complete, close any terminals you have opened, and re-open them. Then run conda activate moose again. If successful proceed to installing packages:\"\n\n\nThat sounded to me like you only have to reopen the terminals if you encountered errors with your shell, but in light of your comment it seems that you always need to restart the terminal.  I'd recommend rewording that to be a bit more clear if it is expected that the user always needs to reopen their terminal.\nThanks for the suggestion.",
                          "url": "https://github.com/idaholab/moose/discussions/19604#discussioncomment-1788227",
                          "updatedAt": "2022-06-22T12:37:14Z",
                          "publishedAt": "2021-12-10T20:41:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "We totally agree, and are working on those instructions currently: #19453\nThe mock site is available here: https://mooseframework.inl.gov/docs/PRs/19453/site/getting_started/installation/conda.html\nI believe if these instructions were instead made available, you would have had a better experience.",
                          "url": "https://github.com/idaholab/moose/discussions/19604#discussioncomment-1788252",
                          "updatedAt": "2022-06-22T12:37:25Z",
                          "publishedAt": "2021-12-10T20:47:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "Jason, thanks, good to know.   That does look a little more clear, and it's nice that the references to conda are being changed to mamba.  I see a few lingering commands that use conda still (adding channels and the uninstall instructions)... have those not been updated yet, or is conda actually the correct command in those instances?",
                          "url": "https://github.com/idaholab/moose/discussions/19604#discussioncomment-1788300",
                          "updatedAt": "2022-06-22T12:37:33Z",
                          "publishedAt": "2021-12-10T20:51:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Mamba has yet to \"wrap\" certain commands unfortunately. So the ones you see still stating conda are necessary :( I am ... like 99% sure we checked them all!\nI think anything relating to a configuration will probably have to remain conda (aside from mamba init), like adding channels and the like. We don't like it... we would love to see 100% mamba. Its faster, would be less confusing, and seem to just \"do\" everything better (like auto-discovering your shell).",
                          "url": "https://github.com/idaholab/moose/discussions/19604#discussioncomment-1788422",
                          "updatedAt": "2022-07-04T10:58:10Z",
                          "publishedAt": "2021-12-10T21:03:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "Yes, that's annoying, but obviously outside of your control.  Maybe something will get updated with conda/mamba to clean that up in the near future.  Thank you for the clarifications!",
                          "url": "https://github.com/idaholab/moose/discussions/19604#discussioncomment-1788457",
                          "updatedAt": "2022-07-04T10:58:10Z",
                          "publishedAt": "2021-12-10T21:11:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "INSFV Memory Usage",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi All\nQuick one, a colleague pointed out that he was seeing high memory usage in INSFV, so I took @ChrocheMisawa 's problem as posted in #17760 and cracked up the refinement. Im seeing huge memory increases for memory usage\n\nSuggesting 1e6 elements being 200 Gb of memory! That doesnt seem right, thats huge a post on the OpenFOAM forum (apples and elephants comparison) suggests 1e6 elements ~ 1 Gb of memory, so even accounting for the AD cost, this seems expensive.\nThanks\nAndy",
          "url": "https://github.com/idaholab/moose/discussions/17874",
          "updatedAt": "2022-07-06T15:40:16Z",
          "publishedAt": "2021-05-18T18:13:39Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "Are you running these tests with ReplicatedMesh or DistributedMesh? Note that the former keeps a full copy of the mesh on every processor rank when running in parallel. You can imagine how this can get pretty expensive. For larger problems spread across more ranks, you should be using DistributedMesh. We also have the ability to pre-split the mesh to avoid startup spikes in both terms of memory and time. We can run tens of millions of elements using just hundreds of MBs on each rank in this fashion.\n[Mesh]\n    ...\n    parallel_type = distributed\n[]\n\nHere is some information on presplitting:\nhttps://mooseframework.inl.gov/syntax/Mesh/splitting.html",
                  "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-763707",
                  "updatedAt": "2022-07-06T15:40:15Z",
                  "publishedAt": "2021-05-20T14:40:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "I should've pointed out this is in serial",
                  "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-763742",
                  "updatedAt": "2022-07-06T15:40:14Z",
                  "publishedAt": "2021-05-20T14:47:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think it's gmres that is building a very large krylov base in this example. How many linear iterations is this case doing per non-linear iteration?\nThe LU sub-preconditioner also may not help.\nWithout profiling for memory it's hard to give you a definite answer. Thanks for reporting this.",
                  "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-763758",
                  "updatedAt": "2022-07-06T15:40:14Z",
                  "publishedAt": "2021-05-20T14:51:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "I tried hypre euclid, but that was a no go. See the image below, its the same problem once at a default resolution, and the 2nd refined further, results from gperf",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-764725",
                          "updatedAt": "2022-07-06T15:40:14Z",
                          "publishedAt": "2021-05-20T18:01:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "18 linear iterations per non-linear iteration, 3 non-linear iterations for convergence",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-764736",
                          "updatedAt": "2022-07-06T15:40:14Z",
                          "publishedAt": "2021-05-20T18:02:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok it's clear from gperf that the gradient caching on each face is the culprit.\nMaybe we should re-consider that choice. I ll bring it up at the next FV meeting\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-764743",
                          "updatedAt": "2022-07-07T11:06:07Z",
                          "publishedAt": "2021-05-20T18:04:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I like that you said this was a quick one \ud83d\ude06 So yea @GiudGiud is working on this in in #18009 and in #18012. You did point out that the OpenFOAM to MOOSE comparison is apples to elephants and that's good. Because after eliminating the caching @GiudGiud 's profiles show that at least 60% of remaining memory allocation comes out of PETSc. 34% of that is a matrix alone and there's a pretty good chance that the referenced OpenFOAM case is using explicit time integration. Some of the remaining PETSc memory will be that minimum of 30 GMRES vectors (perhaps more if you increase the restart) unless you are using a different -ksp_type. You will still have a mass matrix with explicit time integration but for our spatial discretization of the time derivative term the matrix is purely diagonal and we actually have non-PETSc-based methods for solving this (no explicit matrix storage nor GMRES iterations required!).\nReally appreciate this discussion as it will seriously cut down on our FV memory usage. It would be good to do some more serious profile comparisons to OpenFOAM moving forward where we use the same solution methods because we want to be in the same ballpark for sure. I would be shocked if we ever \"beat\" them, but yea in the same ballpark is where I want us to be.",
                  "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-835140",
                  "updatedAt": "2022-07-07T11:06:07Z",
                  "publishedAt": "2021-06-07T14:16:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Glad to be of use :) When they get approved I have someone at our end to do a thorough OpenFOAM/MOOSE FV comparison.",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-835443",
                          "updatedAt": "2022-07-07T11:06:07Z",
                          "publishedAt": "2021-06-07T15:17:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I will prepare myself to feel embarrassed then haha. But this will be great to help us to continue to grow/improve",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-835680",
                          "updatedAt": "2022-07-07T11:06:06Z",
                          "publishedAt": "2021-06-07T16:03:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@makeclean this PR got merged if you still want to look at openFOAM vs moose FV.\nWe now don't cache face gradients or values by default.\nWe still cache element gradients everywhere and face values on extrapolated boundary conditions (velocity inlet, pressure outlet)",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-1579138",
                          "updatedAt": "2022-07-07T11:06:06Z",
                          "publishedAt": "2021-11-02T22:48:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Closing this. Situation has largely improved with the caching PRs.",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-1787454",
                          "updatedAt": "2022-07-07T11:08:31Z",
                          "publishedAt": "2021-12-10T18:31:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Compiling apps together",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "Hello,\nI have a problem were I am compiling two moose apps together and i am getting a linking error:\nLinking Library /home/qt5/projects/mole/test/lib/libmole_test-opt.la...\nlibtool:   error: cannot find the library '/home/qt5/projects/mole/test/lib/libmole_test-opt.la' or unhandled argument '/home/qt5/projects/mole/test/lib/libmole_test-opt.la'\n\nThis is what my make file looks like:\n# Set up MOOSE framework\nifeq ($(wildcard $(MOOSE_DIR)/framework/Makefile),)\n  $(error MOOSE framework was not found!  Please set MOOSE_DIR to the MOOSE directory!)\nendif\nFRAMEWORK_DIR      := $(MOOSE_DIR)/framework\ninclude $(FRAMEWORK_DIR)/build.mk\ninclude $(FRAMEWORK_DIR)/moose.mk\n\n################################## MODULES ####################################\n# To use certain physics included with MOOSE, set variables below to\n# yes as needed.  Or set ALL_MODULES to yes to turn on everything (overrides\n# other set variables).\n\nALL_MODULES                 := no\n\nCHEMICAL_REACTIONS          := yes\nCONTACT                     := no\nEXTERNAL_PETSC_SOLVER       := no\nFLUID_PROPERTIES            := no\nFUNCTIONAL_EXPANSION_TOOLS  := no\nHEAT_CONDUCTION             := no\nLEVEL_SET                   := yes\nMISC                        := no\nNAVIER_STOKES               := no\nPHASE_FIELD                 := yes\nPOROUS_FLOW                 := no\nRDG                         := no\nRICHARDS                    := no\nSOLID_MECHANICS             := no\nSTOCHASTIC_TOOLS            := no\nTENSOR_MECHANICS            := no\nXFEM                        := no\n\n# Modify modules for SAM\nifneq ($(wildcard $(SAM_DIR)/Makefile),)\n  # Sam will need these modules\n  FLUID_PROPERTIES := yes\n  HEAT_CONDUCTION  := yes\n  TENSOR_MECHANICS := yes\nendif\n\ninclude $(MOOSE_DIR)/modules/modules.mk\n\n############################## SAM ############################################\nifneq ($(wildcard $(SAM_DIR)/Makefile),)\n  APPLICATION_DIR     := ${SAM_DIR}\n  APPLICATION_NAME    := sam\n  BUILD_EXEC          := yes\n  include             $(FRAMEWORK_DIR)/app.mk\n  ADDITIONAL_INCLUDES += -I$(SAM_DIR)/include/base\n  ADDITIONAL_CPPFLAGS += -DSAM_ENABLED\n  ADDITIONAL_LIBS     += $(SAM_DIR)/lib/libsam-$(METHOD).la\nendif\n\n############################## MOLE ############################################\nAPPLICATION_DIR    := $(CURDIR)\nAPPLICATION_NAME   := mole\nBUILD_EXEC         := yes\nGEN_REVISION       := no\nDEP_APPS           := $(shell $(FRAMEWORK_DIR)/scripts/find_dep_apps.py $(APPLICATION_NAME))\ninclude            $(FRAMEWORK_DIR)/app.mk\n\n###############################################################################\n# Additional special case targets should be added here\n\nI thought i got this working a few months ago but I can't remember if i did anything to the Makefile. Im compiling both codes with MOOSE commit 00fa7c0.",
          "url": "https://github.com/idaholab/moose/discussions/18684",
          "updatedAt": "2022-05-31T15:07:10Z",
          "publishedAt": "2021-08-23T19:44:36Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think you may be missing\nBUILD_TEST_OBJECTS_LIB := yes in your if_SAM loop\n?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1224740",
                  "updatedAt": "2022-05-31T15:07:15Z",
                  "publishedAt": "2021-08-23T22:48:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "So that did not help. Whats interesting is that if i try to recompile it right after it fails to compile the first time. It works. The first time i try to compile it, it says that it cannot find libmole_test-opt.la but if i look in the folder it was looking in, its there. So when i compile it again, it finds the library.",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1255572",
                          "updatedAt": "2022-05-31T15:07:11Z",
                          "publishedAt": "2021-08-30T18:24:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Let's look at the output of make -n and see in what order things are being linked. You could email it to me if you dont want to share it here",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1289017",
                          "updatedAt": "2022-05-31T15:07:11Z",
                          "publishedAt": "2021-09-07T05:03:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Zack, A few things which may or may not help:\n\nYou should never need to touch the main.C file. If you think you need to, you are working outside of our intended system.\nYour Makefile seems a little bit complicated. We've really tried to simplify the necessary blocks you need when compiling applications together. If the dependent MOOSE application is required, the block should be this simple:\n\n# SAM\nSAM_DIR            ?= $(CURDIR)/SAM\nAPPLICATION_DIR    := $(SAM_DIR)\nAPPLICATION_NAME   := sam\ninclude            $(FRAMEWORK_DIR)/app.mk\n\nFor optional dependencies, it does get a bit more complex since you have to create compiler defines and use several preprocessor commands as you've done.\nOne other big difference is that we normally don't build \"execs\" for anything but the final application. While I can't see why that would be the problem it's related to the \"test\" library that you are getting so maybe. Perhaps a variable we expect to only be defined once is getting defined multiple times (again, our system expects only a single exec).\nThe test library should be built only for the final application it's normally not linked in anywhere except for that final application. The intent is that you can have test objects that don't pollute scope further up the stream. Try taking that line out and see if we can get further.\nWe should chat about getting access at the INL. I think it would be very helpful. We can setup a government use agreement very quickly. It doesn't have to go through full technology deployment process for another lab to get it.",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1471162",
                          "updatedAt": "2022-05-31T15:07:19Z",
                          "publishedAt": "2021-10-13T14:02:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "I made the changes to the Makefile as you suggested and the code compiles as it should with no errors. I reverted back my changes made in the main.C file. So i changed from using the moleApp object to the original moleTestApp object. I have a set of test that run for SAM/Mole coupled which failed because it was not able to find the Actions/kernels.. etc. that should be provided by SAM. I also tried running the test files with mole-opt exc and i get the same failure. If i made the changes to the  main.C file to use the moleApp object instead of moleTestApp it works. I would like to note that we changes to the moleApp.C file  for special cases when SAM is compiled with Mole. These changes include:\nInputParameters\nmoleApp::validParams()\n{\n  auto params = MooseApp::validParams();\n#ifdef SAM_ENABLED\n  params += SamApp::validParams();\n#endif\n\n  // Class description\n  params.addClassDescription(\"The moleApp class creates an instance of a mole \"\n    \"solver, which solves various species transport related problems for \"\n    \"molten salt reactors.\");\n\n  return params;\n}\n\nmoleApp::moleApp(InputParameters parameters)\n#ifdef SAM_ENABLED\n  : SamApp(parameters)\n#else\n  : MooseApp(parameters)\n#endif\n{\n  moleApp::registerAll(_factory, _action_factory, _syntax);\n}\n\nvoid\nmoleApp::registerAll(Factory & f, ActionFactory & af, Syntax & s)\n{\n  ModulesApp::registerAll(f, af, s);\n  Registry::registerObjectsTo(f, {\"moleApp\"});\n  Registry::registerActionsTo(af, {\"moleApp\"});\n\n  /* register custom execute flags, action syntax, etc. here */\n  associateSyntaxInner(s, af);\n#ifdef SAM_ENABLED\n  SamApp::registerAll(f, af, s);\n#endif\n}\n\nWould these changes also need to be included in the moleTestApp.C file? Why does the main.C file use the moleTestApp object and not the moleApp object?",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1472594",
                          "updatedAt": "2022-06-21T20:51:52Z",
                          "publishedAt": "2021-10-13T18:04:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Some of the changes (like registering from SAMApp) will be included because moleTestApp::registerAll calls moleApp::registerAll.\nSame for validParams, moleTestApp gets its validParam from moleApp\nThe only change I can see that doesnt propagate is moleApp inheriting from SamApp, since moleTestApp does not inherit from moleApp.\nWhat do you need that for?",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1472667",
                          "updatedAt": "2022-06-21T20:52:19Z",
                          "publishedAt": "2021-10-13T18:18:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "We thought it would be required to have the SAM app kerenels/actions available to Mole so that we could use them in the input file. I came into this project after the initial work was done. So i did not add this part",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1472745",
                          "updatedAt": "2022-06-21T20:52:20Z",
                          "publishedAt": "2021-10-13T18:35:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "I changed the moleTestApp object to inherit from SamApp like I did with molApp and everything seems to work. Thought, I don't really like having to inherit from the SamApp.",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1472870",
                          "updatedAt": "2022-06-21T20:52:20Z",
                          "publishedAt": "2021-10-13T19:03:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you should not need that, but I just went to check and BlueCrab (the ultimate combined app) does that (inheriting from SamApp too).\nSo it is what it is..\nOk glad to hear that. Please let us know if any more issues arise",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1472896",
                          "updatedAt": "2022-06-21T20:52:22Z",
                          "publishedAt": "2021-10-13T19:08:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "@GiudGiud (or any other MOOSE dev) I have been working with @rtaylo45 and others on development of our Mole app.  This issue has arisen again because we are attempting to couple with several different codes. and a couple different developers ended up pursuing this different ways.\nI have a couple questions.  First, a \"clean\" moleApp will have class moleApp : public MooseApp and class moleTestApp : public MooseApp.  As Zack mentioned, we modified the first of those to be class moleApp : public SamApp.  What I don't understand is this: moleTestApp can properly use moleApp objects just fine, but it cannot use SamApp objects (unless we have it also inherit from SamApp).  However, moleTestApp does not inherit from moleApp.  I do not understand why it can successfully use all the mole objects but cannot use the Sam objects?  Especially since moleApp does all the objects and app registrations for Sam as well.  If you could provide some additional clarity on exactly what the expectations are, that woudl be helpful.  I want to prevent this kind of thing:\n#ifdef APP1_ENABLED && APP2_ENABLED && APP3_ENABLED\n  class moleApp : public app1, public app2, public app3\n#elseif APP1_ENABLED && APP2_ENABLED\n  class moleApp : public app1, public app2\n#elseif APP1_ENABLED && APP3_ENABLED\n  class moleApp : public app1, public app3\n...\netc.\n...\nObviously that gets silly after awhile.  And furthermore, having to make this same set of changes in both moleApp and moleTestApp is 1) annoying and redundant, and 2) confusing to me.\nThe second question I have concerns the test objects.  It's unclear to me exactly what kinds of objects this might be?  I'm envisioning special post-processors, problems, or executioners to operate the application in an abnormal way for testing, but I've never made use of such a setup.  Is there useful documentation/examples of what such test objects might be?  It's possible that we may not use them, in which case we may take the simple approach of modifying main.C to just use moleApp instead of moleTestApp.  However, I do not want to make this change without first understanding possible issues we may encounter as a results.",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1786441",
                          "updatedAt": "2022-06-21T20:52:26Z",
                          "publishedAt": "2021-12-10T15:43:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nA partial response to your questions:\n\nIf you dont do this:\n\n#ifdef APP1_ENABLED && APP2_ENABLED && APP3_ENABLED\n  class moleApp : public app1, public app2, public app3\n#elseif APP1_ENABLED && APP2_ENABLED\n  class moleApp : public app1, public app2\n#elseif APP1_ENABLED && APP3_ENABLED\n  class moleApp : public app1, public app3\n...\netc.\n\nhow is the compiler going to know what a SamApp is when Sam is not enabled?\nIf you choose to work with inheritance (and one alternative is dynamic loading), then you have to do this imo.\n@andrsd may advise you better here, he is in charge of another combined application.\nNote that for the test app, it calls the registering routines from the main app, see there for example\nhttps://github.com/idaholab/TMAP8/blob/devel/test/src/base/TMAPTestApp.C\nI dont see why test apps could not inherit from the main app, but i have not tried this setup.\n\nTest objects are for reaching hard-to-reach statements in the code, to make sure they work. We really need them.\nYou can see a bunch of them in moose/test/src",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1787083",
                          "updatedAt": "2022-06-21T20:52:44Z",
                          "publishedAt": "2021-12-10T17:24:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to assign different grain boundary mobility to different grains ?",
          "author": {
            "login": "zengfy-hust"
          },
          "bodyText": "Hello everyone:\nI would like to make some changes by assign different GB mobility to different grains like https://www.mdpi.com/1996-1944/12/24/4048/htm,which makes the misorientation angle as an  threshold,I looked up in moose repository and found some cases like this ,the GB mobilities .I would like to assign more grains (more than 100),how can I make this ? thank you .any suggesstion would be fine !",
          "url": "https://github.com/idaholab/moose/discussions/19459",
          "updatedAt": "2022-06-16T02:39:04Z",
          "publishedAt": "2021-11-23T03:45:34Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen",
                  "url": "https://github.com/idaholab/moose/discussions/19459#discussioncomment-1742106",
                  "updatedAt": "2022-06-16T02:39:05Z",
                  "publishedAt": "2021-12-03T06:44:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "We don't have anisotropic mobilities exactly like this currently implemented in MOOSE- the most closely related example shows what happens when different grains have different mobiliites:\nmoose/modules/phase_field/test/tests/GBAnisotropy/test2.i",
                  "url": "https://github.com/idaholab/moose/discussions/19459#discussioncomment-1776052",
                  "updatedAt": "2022-06-16T02:39:14Z",
                  "publishedAt": "2021-12-09T00:25:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Enquiry about using interface diffusion coefficient calculated by DFT in phase field",
          "author": {
            "login": "ZhigangPu"
          },
          "bodyText": "Dear,\nI have a question about phase field that bothers me a lot.\nUsually in phase field, people use an interpolation function to give the diffusion coefficient at the interface(interpolate the coefficient between phase A and phase B). But if through DFT calculation, I can clearly compute the diffusion coefficient at the interface, is there a way I can use the calculated coefficient instead of the interpolation one? If there is a way, then the physical property at the interface may be more meaningful. Also, we can explore more nanoscale factors\u2019 influence on the microstructure evolution through coupling between DFT and PF.\nAny response is highly appreciated!\nBest wishes,\nzhigang",
          "url": "https://github.com/idaholab/moose/discussions/19545",
          "updatedAt": "2022-12-22T05:34:18Z",
          "publishedAt": "2021-12-04T11:38:13Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Are you talking about the \"Multi-scale simulation\" animation on the gallery page? MOOSE uses the MultiApp system to achieve this.",
                  "url": "https://github.com/idaholab/moose/discussions/19545#discussioncomment-1772050",
                  "updatedAt": "2022-12-22T05:34:19Z",
                  "publishedAt": "2021-12-08T11:40:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "You could create an interpolation function that is non-zero only in the interface, then multiply that by the diffusion coefficient. For example, say you have a two-phase system with represented by an order parameter eta that is 1 in the alpha phase and 0 in the beta phase. As you said, normally the diffusivity between the two phases would be represented by function like D_alpha * h + D_beta * (1-h), where h is an interpolation function. If the diffusivity at the interface is much larger than in the bulk, you could make the total diffusivity as D_alpha * h + D_beta * (1-h) + D_int * eta^2 * (1-eta)^2, so that the contribution from interfacial diffusivity is only non-zero at the interface.",
                          "url": "https://github.com/idaholab/moose/discussions/19545#discussioncomment-1776043",
                          "updatedAt": "2022-12-22T05:34:20Z",
                          "publishedAt": "2021-12-09T00:20:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Convergence Issues",
          "author": {
            "login": "edwardXZ06"
          },
          "bodyText": "Bug Description\nI have used current UMAT interface to run a bug free simple hyperelastic umat file, yet the convergence perform really bad no matter I use Newton or PJFNK.\nDoes this mean for the nonlinear problem, we shall specify the Jacobian ourselves, considering this interface has not been built to work with the AD?\nSteps to Reproduce\n\nImpact",
          "url": "https://github.com/idaholab/moose/discussions/18502",
          "updatedAt": "2022-06-20T08:40:31Z",
          "publishedAt": "2021-08-03T02:03:22Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "I'm converting this over to a discussion. If it turns out there is an actual bug in the implementation we can move it back.",
                  "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122886",
                  "updatedAt": "2022-06-20T08:40:36Z",
                  "publishedAt": "2021-08-03T02:12:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "edwardXZ06"
                          },
                          "bodyText": "Of course. Here is my fortran file, which has been tested on Abaqus multiple times, and I have confidence on its DDSDDE derivation as well. This is a NeoHookean hyperelastic umat. For the i file, I just change the elastic.i that you tested for the finite strain elastic umat, by just calling this fortran.\n       SUBROUTINE UMAT(STRESS,STATEV,DDSDDE,SSE,SPD,SCD,\n     1 RPL,DDSDDT,DRPLDE,DRPLDT,\n     2 STRAN,DSTRAN,TIME,DTIME,TEMP,DTEMP,PREDEF,DPRED,CMNAME,\n     3 NDI,NSHR,NTENS,NSTATV,PROPS,NPROPS,COORDS,DROT,PNEWDT,\n     4 CELENTCELENT,DFGRD0,DFGRD1,NOEL,NPT,LAYER,KSPT,KSTEP,KINC)\nC\n      CHARACTER*80 CMNAME\n      DIMENSION STRESS(NTENS),STATEV(NSTATV),\n     1 DDSDDE(NTENS,NTENS),DDSDDT(NTENS),DRPLDE(NTENS),\n     2 STRAN(NTENS),DSTRAN(NTENS),TIME(2),PREDEF(1),DPRED(1),\n     3 PROPS(NPROPS),COORDS(3),DROT(3,3),DFGRD0(3,3),DFGRD1(3,3)\nC\n      DIMENSION DTAU_VEC(6),DLEFT_CAUCHY(6),\n     1 DTAU_MAT(3,3),DEYE(3,3),DPDF(3,3,3,3)\n\t  REAL DJN0, DJN1\n      PARAMETER (ONE=1.0D0,TWO=2.0D0,THREE=3.0D0,SIX=6.0D0,\n     1 SMALL=1.D-12,DHALF=0.5D0,ZERO=0.0D0)\nC\nC -----------------------------------------------------------\nC     UMAT FOR ISOTROPIC NEOHOOKEAN FINTE STRAIN ELASTICITY\nC     GENERAL 3D FORMULATION\nC -----------------------------------------------------------\nC     STRESS CONVENTION:\nC     STRESS(1) - SIGMA_11\nC     STRESS(2) - SIGMA_22\nC     STRESS(3) - SIGMA_33\nC     STRESS(4) - SIGMA_12\nC     STRESS(5) - SIGMA_13\nC     STRESS(6) - SIGMA_23\nC -----------------------------------------------------------\nC     PROPERTIES:\nC     PROPS(1) - DLAMBDA\nC     PROPS(2) - DMU\nC -----------------------------------------------------------\nC     INTERNAL STATE VARIABLES: NONE? STRAINS?\nC     STATEV(1) \nC -----------------------------------------------------------\nC\nC...CALCULATE JACOBIAN AT TIME N0 AND N1\n      DJN0=DFGRD0(1,1)*(DFGRD0(2,2)*DFGRD0(3,3)-\n     1     DFGRD0(2,3)*DFGRD0(3,2))-\n     1     DFGRD0(1,2)*(DFGRD0(2,1)*DFGRD0(3,3)-\n     1     DFGRD0(2,3)*DFGRD0(3,1))+\n     1     DFGRD0(1,3)*(DFGRD0(2,1)*DFGRD0(3,2)-\n     1     DFGRD0(2,2)*DFGRD0(3,1))\n      DJN1=DFGRD1(1,1)*(DFGRD1(2,2)*DFGRD1(3,3)-\n     1     DFGRD1(2,3)*DFGRD1(3,2))-\n     1     DFGRD1(1,2)*(DFGRD1(2,1)*DFGRD1(3,3)-\n     1     DFGRD1(2,3)*DFGRD1(3,1))+\n     1     DFGRD1(1,3)*(DFGRD1(2,1)*DFGRD1(3,2)-\n     1     DFGRD1(2,2)*DFGRD1(3,1))\nC\nC...RECOVER ISVs\nC\nC...ELASTIC PARAMETERS\n      DLAMBDA=PROPS(1)\n      DMU=PROPS(2)\nC      WRITE(*,*) 'DMU = ',DMU\nC\nC...IDENTITY 3X3 MATRIX\n      DO 10 K1=1,3\n        DO 20 K2=1,3\n           IF (K2.NE.K1) THEN \n            DEYE(K2,K1)=ZERO\n           ELSE \n            DEYE(K2,K1)=ONE\n           ENDIF\n 20     CONTINUE\n 10   CONTINUE\nC\nC...LEFT CAUCHY-GREEN VECTOR\nC\n      DLEFT_CAUCHY(1) = DFGRD1(1,1)*DFGRD1(1,1)\n     1 + DFGRD1(1,2)*DFGRD1(1,2) + DFGRD1(1,3)*DFGRD1(1,3)\n      DLEFT_CAUCHY(2) = DFGRD1(2,1)*DFGRD1(2,1)\n     1 + DFGRD1(2,2)*DFGRD1(2,2) + DFGRD1(2,3)*DFGRD1(2,3)\n      DLEFT_CAUCHY(3) = DFGRD1(3,1)*DFGRD1(3,1)\n     1 + DFGRD1(3,2)*DFGRD1(3,2) + DFGRD1(3,3)*DFGRD1(3,3)\n      DLEFT_CAUCHY(4) = DFGRD1(1,1)*DFGRD1(2,1)\n     1 + DFGRD1(1,2)*DFGRD1(2,2) + DFGRD1(1,3)*DFGRD1(2,3)\n      DLEFT_CAUCHY(5) = DFGRD1(1,1)*DFGRD1(3,1)\n     1 + DFGRD1(1,2)*DFGRD1(3,2) + DFGRD1(1,3)*DFGRD1(3,3)\n      DLEFT_CAUCHY(6) = DFGRD1(2,1)*DFGRD1(3,1)\n     1 + DFGRD1(2,2)*DFGRD1(3,2) + DFGRD1(2,3)*DFGRD1(3,3)\nC\nC...KIRCHHOFF STRESS VECTOR\nC\n       DO 30 K1=1,6\n         DTAU_VEC(K1) = DMU*DLEFT_CAUCHY(K1)\n 30   CONTINUE\n      DTAU_VEC(1) = DTAU_VEC(1) + DLAMBDA*LOG(DJN1) - DMU\n      DTAU_VEC(2) = DTAU_VEC(2) + DLAMBDA*LOG(DJN1) - DMU\n      DTAU_VEC(3) = DTAU_VEC(3) + DLAMBDA*LOG(DJN1) - DMU\nC\nC...CAUCHY STRESS VECTOR (should there be a rotation?)\nC\n       DO 40 K1=1,6\n         STRESS(K1) = DTAU_VEC(K1)/DJN1\n 40   CONTINUE\nc      WRITE(*,*) 'DTAU_VEC = ',DTAU_VEC\nc\t  WRITE(*,*) 'DJN1 = ',DJN1\nC\nC...KIRCHHOFF STRESS MATRIX\nC\n      DTAU_MAT(1,1) = DTAU_VEC(1)\n      DTAU_MAT(1,2) = DTAU_VEC(4)\n      DTAU_MAT(1,3) = DTAU_VEC(5)\n      DTAU_MAT(2,1) = DTAU_VEC(4)\n      DTAU_MAT(2,2) = DTAU_VEC(2)\n      DTAU_MAT(2,3) = DTAU_VEC(6)\n      DTAU_MAT(3,1) = DTAU_VEC(5)\n      DTAU_MAT(3,2) = DTAU_VEC(6)\n      DTAU_MAT(3,3) = DTAU_VEC(3)\n\nC...TANGENT MATRIX 6X6\nC\n      DDSDDE(1,1)=(TWO*DTAU_MAT(1,1)+DLAMBDA-\n     1    TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n      DDSDDE(1,2)=(DLAMBDA)/DJN1\n      DDSDDE(1,3)=(DLAMBDA)/DJN1\n      DDSDDE(1,4)=(DTAU_MAT(2,1))/DJN1\n      DDSDDE(1,5)=(DTAU_MAT(3,1))/DJN1\n      DDSDDE(1,6)=ZERO\nC\n      DDSDDE(2,1)=DDSDDE(1,2)\n      DDSDDE(2,2)=(TWO*DTAU_MAT(2,2)+DLAMBDA-\n     1    TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n      DDSDDE(2,3)=(DLAMBDA)/DJN1\n      DDSDDE(2,4)=(DTAU_MAT(2,1))/DJN1\n      DDSDDE(2,5)=ZERO\n      DDSDDE(2,6)=(DTAU_MAT(3,2))/DJN1\nC\n      DDSDDE(3,1)=DDSDDE(1,3)\n      DDSDDE(3,2)=DDSDDE(2,3)\n      DDSDDE(3,3)=(TWO*DTAU_MAT(3,3)+DLAMBDA-\n     1    TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n      DDSDDE(3,4)=ZERO\n      DDSDDE(3,5)=(DTAU_MAT(3,1))/DJN1\n      DDSDDE(3,6)=(DTAU_MAT(3,2))/DJN1\nC\n      DDSDDE(4,1)=DDSDDE(1,4)\n      DDSDDE(4,2)=DDSDDE(2,4)\n      DDSDDE(4,3)=DDSDDE(3,4)\n      DDSDDE(4,4)=(DTAU_MAT(2,2)+DTAU_MAT(1,1)\n     1    -TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n      DDSDDE(4,5)=(DTAU_MAT(3,2))/DJN1\n      DDSDDE(4,6)=ZERO\nC\n      DDSDDE(5,1)=DDSDDE(1,5)\n      DDSDDE(5,2)=DDSDDE(2,5)\n      DDSDDE(5,3)=DDSDDE(3,5)\n      DDSDDE(5,4)=DDSDDE(4,5)\n      DDSDDE(5,5)=(DTAU_MAT(3,3)+DTAU_MAT(1,1)\n     1    -TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n      DDSDDE(5,6)=(DTAU_MAT(1,2))/DJN1\nC\n      DDSDDE(6,1)=DDSDDE(1,6)\n      DDSDDE(6,2)=DDSDDE(2,6)\n      DDSDDE(6,3)=DDSDDE(3,6)\n      DDSDDE(6,4)=DDSDDE(4,6)\n      DDSDDE(6,5)=DDSDDE(5,6)\n      DDSDDE(6,6)=(DTAU_MAT(3,3)+DTAU_MAT(2,2)\n     1    -TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n\t \n\t  DO 130 K1=1,NDI\n        DO 140 K2=1,NDI\n            IF (DDSDDE(K1,K2).NE.ZERO) THEN \n\t\t\t\tDDSDDE(K1,K2)=-DDSDDE(K1,K2)\n\t\t\tENDIF\n140     CONTINUE\n130   CONTINUE\nC\nC     WRITE(*,*) 'STRESS(2) = ',STRESS(2)\n      RETURN\n      END\nC",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122919",
                          "updatedAt": "2022-06-20T08:40:37Z",
                          "publishedAt": "2021-08-03T02:27:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Alrighty. I'll check this out tomorrow. Could you also share your MOOSE input please? Have you added an SMP preconditioner block with full=true (that should added automatically be default when using NEWTON, but not with PJFNK). I'm assuming you're doing very large deformation? I found our Jacobian lacking in those scenarios when not using AD.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122928",
                          "updatedAt": "2022-06-20T08:40:50Z",
                          "publishedAt": "2021-08-03T02:33:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "oh, I see, you're using elastic.i... That answers my questions.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122930",
                          "updatedAt": "2022-06-20T08:40:49Z",
                          "publishedAt": "2021-08-03T02:34:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "edwardXZ06"
                          },
                          "bodyText": "Yes, the SMP condition is included and I have tried NEWTON as well, still cannot converge. This umat is designed for large deformation, but I started with very small deformation can still cannot converge.\nMany thanks! It will be a great news if I don't need manually input the Jacobian since I am even going to couple with temperature or other physics with this umat interface as well.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122945",
                          "updatedAt": "2022-07-21T21:15:49Z",
                          "publishedAt": "2021-08-03T02:40:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Your UMAT expects the two Lame constants, where our elastic.f expects Young's modulus and Poisson's ration. Did you convert those inputs when you ran the modified elastic.i file?",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122951",
                          "updatedAt": "2022-07-21T21:15:49Z",
                          "publishedAt": "2021-08-03T02:42:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Enabling forward mode automatic differentiation support for UMAT files will not be easy. It would be a custom extension of the UMAT interface and will only work with C++ UMAT files, as we rely on operator overloading provided by the MetaPhysicL library.\nIt might actually be worth your time to look into implementing these models in \"native\" MOOSE code.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122957",
                          "updatedAt": "2022-07-21T21:15:49Z",
                          "publishedAt": "2021-08-03T02:45:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "edwardXZ06"
                          },
                          "bodyText": "Since this is displacement controlled BVP, the parameters don't matter, you can use test '75 75', but I think any real number should be able to run if converges well.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122960",
                          "updatedAt": "2022-07-21T21:15:50Z",
                          "publishedAt": "2021-08-03T02:48:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "edwardXZ06"
                          },
                          "bodyText": "I see. Then probably I need to calculate and supply material Jacobian to MOOSE eventually. Actually, I understand right now you use DDSDDE for Jacobian is just a rough estimate, since DDSDDE represents derivative of stress wrt strain, while Jacobian is the derivative of stress equilibrium function wrt displacement, that might explain it always converges well for linear problem, but might not work for the nonlinear one.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122968",
                          "updatedAt": "2022-07-21T21:15:49Z",
                          "publishedAt": "2021-08-03T02:53:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Wow, that input file just bombs! Inverted elements right away :-(",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122974",
                          "updatedAt": "2022-07-21T21:15:49Z",
                          "publishedAt": "2021-08-03T02:55:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    xmin = -0.5\n    xmax = 0.5\n    ymin = -0.5\n    ymax = 0.5\n    zmin = -0.5\n    zmax = 0.5\n    nx = 5\n    ny = 5\n  []\n[]\n\n[Functions]\n  [top_pull]\n    type = ParsedFunction\n    value = t/100\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = FINITE\n  []\n[]\n\n[BCs]\n  [y_pull_function]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = top\n    function = top_pull\n  []\n  [x_bot]\n    type = DirichletBC\n    variable = disp_x\n    boundary = left\n    value = 0.0\n  []\n  [y_bot]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0.0\n  []\n  [z_bot]\n    type = DirichletBC\n    variable = disp_z\n    boundary = front\n    value = 0.0\n  []\n[]\n\n[Materials]\n  [umat]\n    type = AbaqusUMATStress\n    constant_properties = '75 75'\n    plugin = 'plugins/edward'\n    num_state_vars = 0\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n\n  # petsc_options = '-snes_ksp_ew'\n  # petsc_options_iname = '-ksp_gmres_restart'\n  # petsc_options_value = '101'\n  petsc_options_iname = '-pc_type -sub_pc_type   -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm       lu            nonzero'\n\n  line_search = 'none'\n\n  l_max_its = 100\n  nl_max_its = 100\n  nl_rel_tol = 1e-12\n  nl_abs_tol = 1e-10\n  l_tol = 1e-6\n  start_time = 0.0\n  num_steps = 30\n  dt = 1e-6\n  dtmin = 1e-6\n[]\n\n[Preconditioning]\n  [smp]\n    type = FDP\n    full = true\n  []\n[]\n\n[Outputs]\n  exodus = true\n  execute_on = 'INITIAL TIMESTEP_END NONLINEAR LINEAR'\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1126141",
                          "updatedAt": "2022-07-21T21:15:50Z",
                          "publishedAt": "2021-08-03T15:57:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Hm, running this with\n./tensor_mechanics-opt -i edward.i -snes_test_jacobian -snes_force_iteration\n\nshows an abysmal Jacobian. So thaer emight be a bug after all.\nTime Step 0, time = 0\n\nTime Step 1, time = 1e-06, dt = 1e-06\n 0 Nonlinear |R| = 0.000000e+00\n  ---------- Testing Jacobian -------------\n  Run with -snes_test_jacobian_view and optionally -snes_test_jacobian <threshold> to show difference\n    of hand-coded and finite difference Jacobian entries greater than <threshold>.\n  Testing hand-coded Jacobian, if (for double precision runs) ||J - Jfd||_F/||J||_F is\n    O(1.e-8), the hand-coded Jacobian is probably correct.\n  ||J - Jfd||_F/||J||_F = 0.999811, ||J - Jfd||_F = 205.818\n      0 Linear |R| = 0.000000e+00\n 1 Nonlinear |R| = 0.000000e+00\n Solve Converged!\n\nTime Step 2, time = 2e-06, dt = 1e-06\n 0 Nonlinear |R| = 5.303301e-07\n  ---------- Testing Jacobian -------------\n  ||J - Jfd||_F/||J||_F = 0.999811, ||J - Jfd||_F = 205.818\n      0 Linear |R| = 5.303301e-07\n      1 Linear |R| = 1.317381e-14\n 1 Nonlinear |R| = 1.483677e-14\n Solve Converged!\n\nTime Step 3, time = 3e-06, dt = 1e-06\n 0 Nonlinear |R| = 6.783279e+10\n  ---------- Testing Jacobian -------------\n  ||J - Jfd||_F/||J||_F = 34.3538, ||J - Jfd||_F = 2.52089e+18\n      0 Linear |R| = 6.783279e+10\n      1 Linear |R| = 3.919297e+09\n  Elem Information\n[...]\n\n(thats where it inverts)",
                  "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122984",
                  "updatedAt": "2022-06-20T08:40:50Z",
                  "publishedAt": "2021-08-03T03:00:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Wait.. this doesn't even converge with a finite difference preconditioner and a direct solver...",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122994",
                          "updatedAt": "2022-06-20T08:41:00Z",
                          "publishedAt": "2021-08-03T03:05:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "edwardXZ06"
                          },
                          "bodyText": "I guess the main reason is the mathematical difference between global Jacobian and DDSDDE, but the transition between these two is not that intimidating, if we know required information from shape function, like the B matrix, derivative of shape function in reference coordinates, etc...\nBTW, I saw there are examples of hyperelastic-creep model under tensor mechanics module, and that input file doesn't even supply any manual Jacobian, if my understanding is correct.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1123019",
                          "updatedAt": "2022-06-20T08:41:06Z",
                          "publishedAt": "2021-08-03T03:16:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "@dschwen I have a stupid question, I couldn't even find UMAT in my MOOSE folder? is this an extension? how can I install it?\nIt would be very interesting to integrate MOOSE with Abaqus.\nKind regards,\nTraiwit",
                  "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1166640",
                  "updatedAt": "2022-06-20T08:41:06Z",
                  "publishedAt": "2021-08-13T05:36:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fixing mesh without affecting the calculation",
          "author": {
            "login": "souzanha"
          },
          "bodyText": "Hi!\nI have a system with and outward flux on one boundary. This flux nucleates a new phase at that specific boundary and I use the tensor mechanics module to see how the mechanical energy affects the evolution of the interface.\nIt could be that I'm doing it incorrectly, but I started without any Dirichlet BCs on the edges and then get a change in my geometry.\nBut using Dirichlet conditions on the edge affects the simulation results. This makes sense, as I'm keeping the nodes there at constant value 0. Is there a way to fix the mesh in position without me affecting the results?\nThese are the conditions that I'm using:\n##DISPLACEMENT BOUNDARY CONDITIONS, zero total shear and constant volume\n  [./bottom_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom_edge'\n    value = 0\n  [../]\n  [./top_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'top_edge'\n    value = 0\n  [../]\n  [./left_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left_edge'\n    value = 0\n  [../]\n  [./right_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'right_edge'\n    value = 0\n  [../]\n\n##PERIODIC BOUNDARY CONDITIONS, TOP BOTTOM\n   [./Periodic]\n    [./pbc_c]\n      variable = c\n      auto_direction = 'y'\n    [../]\n\n    [./pbc_w]\n      variable = w\n      auto_direction = 'y'\n    [../]\n  [../]\n\n  [./right_w]\n     type = ADFluxFunction (my own)\n     variable = w\n     boundary = right_edge\n [../]\n\n  [./left_w]\n     type = NeumannBC\n     variable = w\n     boundary = left_edge\n     value = 0\n [../]\n\n  [./left_c]\n     type = NeumannBC\n     variable = c\n     boundary = left_edge\n     value = 0\n [../]\n\n  #total free free energy (chemical + elastic)\n  [./total_free_energy]\n    type = DerivativeSumMaterial\n    f_name = f_tot\n    sum_materials = 'f_chem f_elast'\n    args = 'c'\n    derivative_order=2\n  [../]\n\n  [./elasticity_tensor]\n    type = ComputeElasticityTensor\n    C_ijkl = '157 51 53 0 0 0 171 33 0 0 0 0 0 0 0 38 0 0 49 0 52' #unitless\n    fill_method = symmetric21 #general symmetry\n  [../]\n\n  [./eigenstrain] #nocomplaints\n   type = ComputeVariableEigenstrain\n   material_property_names = 'e0_11 e0_22 e0_33'\n   #eigen_base = 'e0_11 e0_22 e0_33 0 0 0' #cannot convert to float\n   eigen_base = '0.05 0.036 -0.019 0 0 0' #eps0, Vegard\u2019s law coefficients\n   prefactor = var_dep #the prefactor is defined in a derivative\n   args = 'c'\n   eigenstrain_name = eigenstrain\n  [../]\n\n  [./var_dependence]\n   type = DerivativeParsedMaterial\n   function = 'c' #0.5*c^2\n   args = 'c'\n   output_properties = 'var_dep'\n   f_name = var_dep\n   enable_jit = true #Enable just-in-time compilation of function expressions for faster evaluation\n   derivative_order = 2\n  [../]\n\n  [./strain]\n   type =  ComputeIncrementalSmallStrain #ComputeSmallStrain #strain, without composition part. eps=1/2*(u*nabla+nablau)\n   displacements = 'disp_x disp_y'\n   eigenstrain_names = eigenstrain #eigenstrains to be applied in this strain calculation. Substracts the eigenstrain from the total strain = mechanical strain.\n  [../]\n\n  [./stress]\n   type = ComputeFiniteStrainElasticStress #ComputeLinearElasticStress #sigma=C*mechanical strain = total strain\n  [../]",
          "url": "https://github.com/idaholab/moose/discussions/19315",
          "updatedAt": "2022-07-11T06:06:56Z",
          "publishedAt": "2021-11-08T11:10:52Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think I'd try pinning a single node first.\nPlease see how to do this here\nhttps://mooseframework.inl.gov/modules/tensor_mechanics/tutorials/introduction/step03a.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19315#discussioncomment-1742061",
                  "updatedAt": "2022-07-11T06:06:58Z",
                  "publishedAt": "2021-12-03T06:31:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "I see! Sounds like a very nice approach, I will try it.  Thank you for the suggestion and the link",
                          "url": "https://github.com/idaholab/moose/discussions/19315#discussioncomment-1757414",
                          "updatedAt": "2022-07-11T06:06:58Z",
                          "publishedAt": "2021-12-06T12:55:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "This is an issue with your formulation rather than with the tensor mechanics module. You need to first think about what boundary conditions you really want for the control volume.\nIf this is something at macroscale, you can apply boundary conditions that make sense on that structure. Depending on the actual problem, pinning a single node may or may not be your best choice.\nIf this is an RVE, you may choose traditional KUBC or SUBCs. If you choose SUBC then you need to pin an additional node to remove rigid body modes. Alternatively, you can constrain the RVE to have a prescribed homogenized strain/stress. The global strain system in the tensor mechanics module helps you do that.",
                  "url": "https://github.com/idaholab/moose/discussions/19315#discussioncomment-1772027",
                  "updatedAt": "2022-07-11T06:06:58Z",
                  "publishedAt": "2021-12-08T11:34:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}