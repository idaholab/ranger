{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOC0wMlQyMTowMjo1Mi0wNjowMM4AQSvC"
    },
    "edges": [
      {
        "node": {
          "title": "Issues with \"DisplacementAboutAxis\"",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Hi All,\nI am using the type \"DisplacementAboutAxis\" to apply torsional displacement to a ring sample.\nI hold the bottom of the sample fixed in all directions and then rotate the top surface about the z-axis.\nThe sample rotates as expected, but I noticed that in addition to rotating about the axis, the surface where the boundary condition is applied also expands in the radial direction.\nI exaggerated the displacements to show better what was occurring. The bulge at the top surface should not be there.\n\nI have attached my input file and mesh.\nArchive.zip\nIs this a known bug, or is there an issue on my end?\nThank you in advance!",
          "url": "https://github.com/idaholab/moose/discussions/21809",
          "updatedAt": "2022-09-02T19:46:38Z",
          "publishedAt": "2022-08-09T15:45:08Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs the surface held at the top so that it would not expand radially? This could be physical?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21809#discussioncomment-3359491",
                  "updatedAt": "2022-08-09T16:14:31Z",
                  "publishedAt": "2022-08-09T16:14:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Hi!\nI do not have a separate boundary condition that holds the radius fixed. However, the entire top surface is treated with a Dirichlet boundary condition for the x and y displacements. So the x and y displacements at the top surface should only be the values that the DisplacementAboutAxis BC prescribes. If that line of thinking is correct, then the radial expansion that I am seeing must be coming from DisplacementAboutAxis",
                          "url": "https://github.com/idaholab/moose/discussions/21809#discussioncomment-3359522",
                          "updatedAt": "2022-08-09T16:20:08Z",
                          "publishedAt": "2022-08-09T16:20:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "are you seeing something larger than you prescribe with the BC?",
                          "url": "https://github.com/idaholab/moose/discussions/21809#discussioncomment-3359699",
                          "updatedAt": "2022-08-09T16:43:32Z",
                          "publishedAt": "2022-08-09T16:43:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "With respect to angular displacement, I am seeing what I wish to prescribe.\nHowever, there should be no change in the radius of the top surface, which is what I am seeing.",
                          "url": "https://github.com/idaholab/moose/discussions/21809#discussioncomment-3359751",
                          "updatedAt": "2022-08-09T16:50:46Z",
                          "publishedAt": "2022-08-09T16:50:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so you are prescribing a pure rotation?\nwhat does your BC block look like?",
                          "url": "https://github.com/idaholab/moose/discussions/21809#discussioncomment-3359772",
                          "updatedAt": "2022-08-09T16:53:24Z",
                          "publishedAt": "2022-08-09T16:53:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "[top_x]\n    type = DisplacementAboutAxis\n    boundary = top\n    function = '1'\n    angular_velocity = true\n    angle_units = degrees\n    axis_origin = '0 0 1.25'\n    axis_direction = '0. 0. 1'\n    component = 0\n    variable = 'disp_x'\n  []\n  [top_y]\n    type = DisplacementAboutAxis\n    boundary = top\n    function = '1'\n    angular_velocity = true\n    angle_units = degrees\n    axis_origin = ' 0 0 1.25'\n    axis_direction = '0. 0. 1'\n    component = 1\n    variable = 'disp_y'\n  []\n  [bottom_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = bottom\n    value = 0.0\n  []\n\n  [bottom_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0.0\n  []\n\n  [bottom_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = bottom\n    value = 0.0\n  []\n\nHere is my BC block\nThe flanged surface in the picture is the 'top' BC",
                          "url": "https://github.com/idaholab/moose/discussions/21809#discussioncomment-3360296",
                          "updatedAt": "2022-08-09T18:06:55Z",
                          "publishedAt": "2022-08-09T18:06:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@TheGreatCid Can you do me a favor and try implementing this rotation matrix https://en.wikipedia.org/wiki/Rotation_matrix#Axis_and_angle in DisplacementAboutAxis, then see if this fixes the issue? The formula used currently seems unnecessarily complicated to me.",
                          "url": "https://github.com/idaholab/moose/discussions/21809#discussioncomment-3360715",
                          "updatedAt": "2022-08-09T19:24:49Z",
                          "publishedAt": "2022-08-09T19:24:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "I'll implement that when I get a second and let you know how it goes\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/21809#discussioncomment-3360772",
                          "updatedAt": "2022-08-09T19:36:01Z",
                          "publishedAt": "2022-08-09T19:36:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE team job opening",
          "author": {
            "login": "GiudGiud"
          },
          "bodyText": "Hello!\nWe have a job opening for a computational scientist on the MOOSE team!\nAll the details about the posting: inl.taleo.net\nIf you enjoy open-source software that benefits thousands of researchers worldwide, please apply!\nGuillaume for the MOOSE team",
          "url": "https://github.com/idaholab/moose/discussions/21570",
          "updatedAt": "2022-08-09T14:25:30Z",
          "publishedAt": "2022-07-12T22:06:42Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "faisal-bhuiyan"
                  },
                  "bodyText": "Hi @GiudGiud. This is Faisal Bhuiyan - I believe I will be a good fit for this role and applied via the above link. Looking forward to hearing back and please feel free to ask questions!",
                  "url": "https://github.com/idaholab/moose/discussions/21570#discussioncomment-3214499",
                  "updatedAt": "2022-07-24T03:14:17Z",
                  "publishedAt": "2022-07-24T03:14:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "This posting is now closed. We are conducting interviews over the next few weeks. Thanks to all who applied!",
                  "url": "https://github.com/idaholab/moose/discussions/21570#discussioncomment-3358550",
                  "updatedAt": "2022-08-09T14:20:24Z",
                  "publishedAt": "2022-08-09T14:20:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Code coverage on getParam",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hi eveyrone,\nIn https://mooseframework.inl.gov/docs/PRs/21592/coverage/geochemistry/src/userobjects/GeochemistryKineticRate.C.gcov.html you can see that the final line in\n     133         121 :     _monod_ind(isParamValid(\"promoting_monod_indices\")\n     134             :                    ? getParam<std::vector<Real>>(\"promoting_monod_indices\")\n     135           0 :                    : std::vector<Real>(_promoting_names.size(), 0.0)),\n\nis not covered by any test.  However, i have tests that supply promoting_monod_indices and tests that do not supply that parameter.  Why is the final line not covered by the tests?\na",
          "url": "https://github.com/idaholab/moose/discussions/21795",
          "updatedAt": "2022-08-08T20:32:08Z",
          "publishedAt": "2022-08-08T10:37:28Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "In order for us to afford running coverage with so many different configurations and tests, all of the module coverage is produced in opt mode (with -O2, lots of optimization). This optimization... can unfortunately trick gcov. This is likely one of those cases.\nYou're probably not going to be able to hit 100% with this. Rest assured, you know that it's tested \ud83d\ude06",
                  "url": "https://github.com/idaholab/moose/discussions/21795#discussioncomment-3350522",
                  "updatedAt": "2022-08-08T15:23:34Z",
                  "publishedAt": "2022-08-08T15:23:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thanks you @loganharbour",
                          "url": "https://github.com/idaholab/moose/discussions/21795#discussioncomment-3352653",
                          "updatedAt": "2022-08-08T20:32:08Z",
                          "publishedAt": "2022-08-08T20:32:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Extrapolate from gauss points to nodes",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "Hello,\nJust a simple question here, I have in the main app the stress calculated at the gauss points, and whenever I transferred them to the sub app, I used MultiAppProjectionTransfer in order to extrapolate these values to the nodes.\n  [./tau1_to_sub]\n    type = MultiAppProjectionTransfer\n    fixed_meshes = true\n    proj_type = l2\n    direction = to_multiapp\n    multi_app = sub_app\n    source_variable = tau1Aux\n    variable = tau1 \n  [../]\n\nwhere tau1Aux is a MONOMIAL and tau1 is a LAGRANGE variables.\nMind you, the mesh between the two apps are exactly identical, in fact, I use clone_mesh tag.\nis there a better way to do this because this transfer is pretty much holding back the run speed  since I have to do 12 of these transfers?\nThanks in advance!",
          "url": "https://github.com/idaholab/moose/discussions/21701",
          "updatedAt": "2022-08-07T19:53:39Z",
          "publishedAt": "2022-07-27T14:33:33Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo this is a performance issue?\nOr are you unsatisfied with the granularity of the transfer? I think that projection will not be exactly what you describe here, from Gauss points to nodes\nIf this is solely a performance issue, fixed_meshes = true is already the fastest with ProjectionTransfer\nIf you need faster, I would recommend working on moving to a MultiAppCopyTransfer, our fastest field transfer. For this you will need to have the same type of variable in both applications. I think this will be beneficial for the accuracy of the projections too\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21701#discussioncomment-3261788",
                  "updatedAt": "2022-07-27T15:17:32Z",
                  "publishedAt": "2022-07-27T15:17:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "It is a performance issue.\nI would use the MultiAppCopyTransfer if I have these values calculated on the nodes but they are on qp, is there an existing auxkernel or so to interpolate the values from qp to nodes?\nThanks,\nKhaled",
                          "url": "https://github.com/idaholab/moose/discussions/21701#discussioncomment-3263225",
                          "updatedAt": "2022-07-27T17:46:43Z",
                          "publishedAt": "2022-07-27T17:37:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "any nodal auxkernel already does this, computes the nodal values based on the qp values.\nSo if you have an auxkernel that does the job, it should likely work\nin the code if it refers to _current_elem instead of qp, typically it doesnt work for nodal variables",
                          "url": "https://github.com/idaholab/moose/discussions/21701#discussioncomment-3263482",
                          "updatedAt": "2022-07-27T18:16:41Z",
                          "publishedAt": "2022-07-27T18:16:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "It seems like this wont work with material properties defined on qp\nit results in the following error:\nNodal AuxKernel 'tau1Aux' attempted to reference material property 'mandel_stress'\nConsider using an elemental auxiliary variable for 'tau1Aux'.\n\nif there is an example AuxKernel that you can refer me to I'd really appreciate it\nmy auxkernel basically does a double contraction of the _mandel_stress[_qp].doubleContraction(R);",
                          "url": "https://github.com/idaholab/moose/discussions/21701#discussioncomment-3300455",
                          "updatedAt": "2022-08-01T18:06:05Z",
                          "publishedAt": "2022-08-01T16:45:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Do you have to use LAGRANGE type on your target mesh? If not, you can make the two variables in the same type and order and do the copy transfer, which is much faster. If you have to, you still can use a reaction kernel and a body force kernel (to assembly the material property) with tau1Aux being a primal variable. I did not check the code but suppose that the projection transfer can transfer elemental variables to nodal variables and the main cost goes into the setup.",
                          "url": "https://github.com/idaholab/moose/discussions/21701#discussioncomment-3302422",
                          "updatedAt": "2022-08-01T21:09:14Z",
                          "publishedAt": "2022-08-01T21:09:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There's two things here:\n\nsaving the material property to a constant monomial loses information, then projecting it using the transfer to a nodal variable will not recover this information, it ll be approximate. If you dont care too much about this, and only want to solve the performance issue, you will want to use the fixed_meshes parameter. This will cache most of the work performed in this transfer, making it very fast after the first time it is used\nif you do care about this error, then you will need to implement the nodal version of a materialRealAux. We purposely do not have this because it would not be very well defined at interfaces between blocks. But as long as you make a consistent choice of which block is preferred, or suggest an interpolation method or something, then it will be OK.",
                          "url": "https://github.com/idaholab/moose/discussions/21701#discussioncomment-3302863",
                          "updatedAt": "2022-08-01T22:50:08Z",
                          "publishedAt": "2022-08-01T22:50:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "Thank you @YaqiWang and @GiudGiud  for your replies!\nI took a look at MaterialPropertyValue kernel, and created a version that is compatible with RankTwoTensor material properties using indices. This pretty much does what a reaction or body force kernel would do.\nI can share the code here if that would be useful.\nThanks again!\n~Khaled",
                          "url": "https://github.com/idaholab/moose/discussions/21701#discussioncomment-3344635",
                          "updatedAt": "2022-08-07T19:53:07Z",
                          "publishedAt": "2022-08-07T19:53:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "wrap angles modulus 2 Pi",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "Is there a simple way to wrap azimuthal angles in cylindrical coordinates back to [0, 2 Pi)? I guess using the C++ modulus function could be fraught as the wrapping should ideally be made during the executioner?",
          "url": "https://github.com/idaholab/moose/discussions/21778",
          "updatedAt": "2022-09-02T19:48:56Z",
          "publishedAt": "2022-08-04T15:26:33Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "mangerij"
                  },
                  "bodyText": "I should add that we are interested in spherical coordinates. I can wrap the azimuthal angle in an UO (similar to the one @dschwen provided to renormalize the vector solution to be on the unit sphere).\nTo wrap, I just use this line:\nfor (const auto i : index_range(_var_numbers)) \n            if (solution(dof_indices[i][j]) > 2.0*libMesh::pi)\n\u2002\u2002\u2002\u2002\u2002\u2002      solution.set(dof_indices[i][j], solution(dof_indices[i][j]) - 2.0*libMesh::pi * floor( solution(dof_indices[i][j]) / (2.0*libMesh::pi) ));\n\nj here could mean more azimuthal angles - very useful\nNow we are trying (quite obviously because it gives a lot of speed up) to do the problem with just two degrees of freedom, the azimuthal [0,2pi) and polar angle [0,pi). However, subtracting modulo pi from the solution is not the same because it is a 180 degree rotation not 360. Any thoughts here?",
                  "url": "https://github.com/idaholab/moose/discussions/21778#discussioncomment-3327649",
                  "updatedAt": "2022-08-04T18:14:28Z",
                  "publishedAt": "2022-08-04T18:10:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I m not sure I understand what you want to do here.\nIn what forms are those angles? Are they in a variable like @mangerij is accessing? Is it an aux or nonlinear?",
                  "url": "https://github.com/idaholab/moose/discussions/21778#discussioncomment-3329560",
                  "updatedAt": "2022-08-05T00:54:21Z",
                  "publishedAt": "2022-08-05T00:54:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hi Guillaume,\n\nThey are the non-linear variables (spherical coordinates) and it is vital\nto have them wrapped back appropriately to [0,2 Pi) (azimuth) and a little\nmore complicated wrapping for the polar angle to [0,Pi].\n\u2026\n-Olle\nOn Thu, Aug 4, 2022 at 7:54 PM Guillaume Giudicelli < ***@***.***> wrote:\n I m not sure I understand what you want to do here.\n In what forms are those angles? Are they in a variable like @mangerij\n <https://github.com/mangerij> is accessing? Is it an aux or nonlinear?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21778 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF7DXNZTJBAMHAHSHYLVXRQ4PANCNFSM55S7EUVA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21778#discussioncomment-3329823",
                  "updatedAt": "2022-08-05T02:08:34Z",
                  "publishedAt": "2022-08-05T02:08:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so they are the result of a non-linear solve?\nWe typically don't modify those after the solve, though it s totally possible with user objects",
                          "url": "https://github.com/idaholab/moose/discussions/21778#discussioncomment-3330013",
                          "updatedAt": "2022-08-05T03:01:01Z",
                          "publishedAt": "2022-08-05T03:01:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Yes, they are the result of a non-linear solve. Ideally (just like with the\nrenormalization), one would like to do the wrapping at each step that\nmodifies the angles. The problem is that when the polar angle is close to 0\nor Pi, there can be divergencies and/or discontinuities that makes the\nsolution diverge or crash.\n\u2026\nOn Thu, Aug 4, 2022 at 10:01 PM Guillaume Giudicelli < ***@***.***> wrote:\n so they are the result of a non-linear solve?\n We typically don't modify those after the solve, though it s totally\n possible with user objects\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21778 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEFZKSRFJT3MGOFAWMNLVXR7XPANCNFSM55S7EUVA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21778#discussioncomment-3333604",
                  "updatedAt": "2022-08-05T13:21:07Z",
                  "publishedAt": "2022-08-05T13:21:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would go the user object route. You may execute user objects very often, as often as every linear iteration, so that can be helpful in the solve if the normalization is constantly needed",
                          "url": "https://github.com/idaholab/moose/discussions/21778#discussioncomment-3338106",
                          "updatedAt": "2022-08-06T05:01:40Z",
                          "publishedAt": "2022-08-06T05:01:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Another thing you can try is leveraging the Bounds system to keep the nonlinear variable in the desired range. This could hinder the convergence of the solver but it might be worth a try\nhttps://mooseframework.inl.gov/source/auxkernels/ConstantBoundsAux.html",
                          "url": "https://github.com/idaholab/moose/discussions/21778#discussioncomment-3341821",
                          "updatedAt": "2022-08-07T04:15:56Z",
                          "publishedAt": "2022-08-07T04:15:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mangerij"
                  },
                  "bodyText": "Hi,\nI tried the Bounds and Damper systems and the solver crapped out at some point. At this moment, the wrapping is successfully done in a UO with\nazimuthal:\n solution.set(dof_indices[i][j], solution(dof_indices[i][j]) - 2.0*libMesh::pi * floor( solution(dof_indices[i][j]) / (2.0*libMesh::pi) ));\npolar:\n            if (floor( solution(dof_indices[i][j]) / (libMesh::pi) ) >= 1.0)\n            {\n              std::cout << \"Found dof above polar angle limit, wrapping...\" << std::endl;\n              solution.set(dof_indices[i][j], 2.0*libMesh::pi - solution(dof_indices[i][j]) );\n            }\n            else if (floor( solution(dof_indices[i][j]) / (libMesh::pi) ) <= -1.0)\n            {\n              std::cout << \"Found dof below polar angle limit, wrapping...\" << std::endl;\n              solution.set(dof_indices[i][j], -1.0*solution(dof_indices[i][j]) );\n            }\n\nbut now we think we have something else unrelated that is problematic with our sph coord formulation. But thanks for the comments!",
                  "url": "https://github.com/idaholab/moose/discussions/21778#discussioncomment-3344045",
                  "updatedAt": "2022-08-07T16:38:30Z",
                  "publishedAt": "2022-08-07T16:38:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Applying 2 types of BCs on a single surface (surface + nodeset) [PorousFlow]",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys, so I have a surface and a nodeset in a single mesh\nThe nodeset (blue dots) represents the river on this surface\n\nfor the surface I'd like to apply this BC\n[./drain_TOPOLSRF_Y2008_M01] \ntype = PorousFlowPiecewiseLinearSink \nvariable = porepressure \nboundary = 'TOPOLSRF_Y2008_M01'\npt_vals = '-1e9 1e9' \nmultipliers = '-1e9 1e9' \nflux_function = 1 \nv = min\nPT_shift = -98100 \nuse_mobility = true\nfluid_phase = 0\n[../]\n\nand the nodeset I just want to set pwp of those nodes = 0\nI know that MOOSE cannot project BC directly into a nodeset (which is very weird), but I know how to work around it (see the thread below)\n#21209\nNow I want both BCs at the same time i.e. pwp of those nodes = 0 & PorousFlowPiecewiseLinearSink on the rest of the surface.\nIs there a way to work around this?\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/21751",
          "updatedAt": "2022-08-06T05:14:18Z",
          "publishedAt": "2022-08-02T13:43:29Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "I see MOOSE can convert node list into side list\nhttps://mooseframework.inl.gov/source/mesh/MooseMesh.html\n construct_side_list_from_node_list=true\nHowever, it converts all the nodesets into sidesets\nis there a way to specifically convert only 1 nodeset into a surface?",
                  "url": "https://github.com/idaholab/moose/discussions/21751#discussioncomment-3313086",
                  "updatedAt": "2022-08-03T05:10:38Z",
                  "publishedAt": "2022-08-03T05:10:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not currently. We are adding a generator which should be able to do this in its final form here:\n#21196\nbut currently it still does all sidesets / nodesets.\nWhat you could do is turn the conversions off in MOOSE and do it somewhere else like in Cubit",
                          "url": "https://github.com/idaholab/moose/discussions/21751#discussioncomment-3316089",
                          "updatedAt": "2022-08-03T12:42:01Z",
                          "publishedAt": "2022-08-03T12:42:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud, so NodeSetToSideSetGenerator from that PR still does not do what I want, right? I will need to wait then",
                          "url": "https://github.com/idaholab/moose/discussions/21751#discussioncomment-3316231",
                          "updatedAt": "2022-08-03T13:00:24Z",
                          "publishedAt": "2022-08-03T13:00:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yeah both are still geared towards all sidesets/ all nodesets.\nBut you should be able to rename part of a nodeset or a sideset. So while all are converted, you may be able to extract the one you care about?",
                          "url": "https://github.com/idaholab/moose/discussions/21751#discussioncomment-3325504",
                          "updatedAt": "2022-08-04T13:42:31Z",
                          "publishedAt": "2022-08-04T13:42:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "PorousFlowPiecewiseLinearSink may be set naturally I think then for pwp of those nodes = 0 you could look at using a NodalKernel to set the BC instead, maybe with a penalty.\nWhat do you get when trying to set both directly?",
                  "url": "https://github.com/idaholab/moose/discussions/21751#discussioncomment-3316173",
                  "updatedAt": "2022-08-03T12:51:55Z",
                  "publishedAt": "2022-08-03T12:51:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "What do you get when trying to set both directly?\n\nI just realised that #21209 wouldn't work, because in that case I specify pwp values to the target nodes and leave pwp the rest to 0. However, in this particular case, I want my target nodes pwp to be 0 and don't assign anything to the rest. (pwp = pore water pressure)",
                          "url": "https://github.com/idaholab/moose/discussions/21751#discussioncomment-3316260",
                          "updatedAt": "2022-08-03T13:03:41Z",
                          "publishedAt": "2022-08-03T13:03:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "do you have a nodeset that only has the nodes you want to set the pwp to 0 ?",
                          "url": "https://github.com/idaholab/moose/discussions/21751#discussioncomment-3325513",
                          "updatedAt": "2022-08-04T13:45:09Z",
                          "publishedAt": "2022-08-04T13:45:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@GiudGiud NodalKernel works, at least it starts solving, I will get back to you once I get the results.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/21751#discussioncomment-3330477",
                          "updatedAt": "2022-08-05T05:18:37Z",
                          "publishedAt": "2022-08-05T05:18:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "all works fine now, thank you @GiudGiud\nBut yeh, I'd rather move NodalKernel into Nodal BC or we should have this type of object, to us it's like the most basic type of BCs (even more basic than surface BC)\nKind regards,\nTraiwit\n[BCs]\n[./water_grad_lTOPOLSRF_WALLS_SRFSET]\ntype = FunctionDirichletBC\nvariable = porepressure\nboundary = 'TOPOLSRF_WALLS_SRFSET'\nfunction = ini_pp\n[../]\n[./drain_DRAINSRF_Y1996_M01]\ntype = PorousFlowPiecewiseLinearSinkBEH\nvariable = porepressure\nboundary = 'DRAINSRF_Y1996_M01'\npt_vals = '0 1e9'\nmultipliers = '0 1e9'\nflux_function = 1\nv = min\nPT_shift = 0\nuse_mobility = true\nfluid_phase = 0\n[../]\n[./drain_TOPOLSRF_Y1996_M01]\ntype = PorousFlowPiecewiseLinearSinkBEH\nvariable = porepressure\nboundary = 'TOPOLSRF_Y1996_M01'\npt_vals = '-1e9 1e9'\nmultipliers = '-1e9 1e9'\nflux_function = 1e-06\nv = min\nPT_shift = -29430\nuse_mobility = true\nfluid_phase = 0\n[../]\n[]\n[NodalKernels]\n[./bc_river]\ntype = PenaltyDirichletNodalKernel\nvariable = porepressure\nvalue = 0\nboundary = 'TOPO_RIVERSANDLAKES_NSET'\npenalty = 1e10\n[../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21751#discussioncomment-3332479",
                          "updatedAt": "2022-08-05T10:26:38Z",
                          "publishedAt": "2022-08-05T10:26:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm glad. If you get difficulties with the penalty you could try a constraint with a scalar variable lagrange multiplier btw\nWell nodesets are very alike, whether internal or external to the mesh, and also the action done by nodal kernels is supposed to be local to a single node and not really be too aware of its spatial location. Anyway maybe it's not set in stone but I think that s why we dont have nodal BCs, only nodal kernels.",
                          "url": "https://github.com/idaholab/moose/discussions/21751#discussioncomment-3338134",
                          "updatedAt": "2022-08-06T05:14:18Z",
                          "publishedAt": "2022-08-06T05:14:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Recovery",
          "author": {
            "login": "klaw13"
          },
          "bodyText": "Hi, I'm facing issues with using the \"--recover\" option on my simulation.\n*** ERROR *** ERROR: Neither one of the following files can be located: '_mesh.cpr/1/header.cpr' nor '_mesh.cpr' If you are running a parallel job, double check that you've created a split for 1 ranks. Note: One of paths above may refer to a valid directory on your system, however we are attempting to read a valid header file.\nThe checkpoint file is being created in the directory I'm running the simulation from.",
          "url": "https://github.com/idaholab/moose/discussions/21761",
          "updatedAt": "2022-08-05T12:58:17Z",
          "publishedAt": "2022-08-03T13:58:48Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\ndo you have an execute_on flag set in the Outputs block by any chance?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21761#discussioncomment-3318756",
                  "updatedAt": "2022-08-03T17:57:10Z",
                  "publishedAt": "2022-08-03T17:57:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "No, I do not. My output block is as follows:\n[Outputs]\n  exodus = true\n  perf_graph = true\n  print_linear_residuals = true\n  \n  [./checkpoint]\n    type = Checkpoint\n    num_files = 2\n    use_displaced = True\n  []\n  [console]\n    type = Console\n    all_variable_norms = true\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21761#discussioncomment-3318771",
                          "updatedAt": "2022-08-04T13:12:52Z",
                          "publishedAt": "2022-08-03T17:59:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok thanks different issue then.\nCan you specify the prefix for the recover file? on the command line\nAre you creating the checkpoint in parallel or in serial? Are you loading it with the same number of processes?\nbtw i think you want to use triple quotes for formatting",
                          "url": "https://github.com/idaholab/moose/discussions/21761#discussioncomment-3325296",
                          "updatedAt": "2022-08-04T13:14:26Z",
                          "publishedAt": "2022-08-04T13:14:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Ah, thanks!\nThe checkpoint directory is hydSq_629_checkpoint_cp with a subdirectory of 5250_mesh.cpr which has a meta_data_mesh.rd file and a 1/header.cpr and 1/split-1-0.cpr\nThe command I use to call the recovery is\n ../../eel-opt -i hydSq_629.i --recover",
                          "url": "https://github.com/idaholab/moose/discussions/21761#discussioncomment-3326477",
                          "updatedAt": "2022-08-04T15:43:10Z",
                          "publishedAt": "2022-08-04T15:42:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes after that command you will need to pass the name of the folder.\nIf you type ../../eel-opt --help it ll say that\n  --recover [file_base]                             Continue the calculation.  If file_base is omitted then the most recent recovery file will be utilized",
                          "url": "https://github.com/idaholab/moose/discussions/21761#discussioncomment-3329544",
                          "updatedAt": "2022-08-05T00:51:11Z",
                          "publishedAt": "2022-08-05T00:51:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ykvishal"
                  },
                  "bodyText": "I faced similar issue. When I edited folder name by replacing checkpoint to out (i.e. rename hydSq_629_checkpoint_cp to hydSq_629_out_cp), the  --recover option was working.\nIn future, you can use this block\n [./out]\n     type = Checkpoint\n     num_files = 2\n     use_displaced = True\n []",
                  "url": "https://github.com/idaholab/moose/discussions/21761#discussioncomment-3328430",
                  "updatedAt": "2022-08-04T20:17:09Z",
                  "publishedAt": "2022-08-04T20:14:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "That worked, thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/21761#discussioncomment-3328551",
                          "updatedAt": "2022-08-04T20:34:35Z",
                          "publishedAt": "2022-08-04T20:34:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "for future reference, the folder name should be passed as an argument to --recover. out works here because it s the default",
                          "url": "https://github.com/idaholab/moose/discussions/21761#discussioncomment-3329550",
                          "updatedAt": "2022-08-05T00:52:08Z",
                          "publishedAt": "2022-08-05T00:52:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Perfect, thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/21761#discussioncomment-3333439",
                          "updatedAt": "2022-08-05T12:58:18Z",
                          "publishedAt": "2022-08-05T12:58:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Implementing the mortar Jacobian",
          "author": {
            "login": "hugary1995"
          },
          "bodyText": "Hi, I am trying to implement a non-AD version of PenaltyEqualValueConstraint as follows:\nReal\nRegularPenaltyEqualValueConstraint::computeQpResidual(Moose::MortarType mortar_type)\n{\n  switch (mortar_type)\n  {\n    case Moose::MortarType::Secondary:\n    {\n      auto residual =\n          -(_u_primary[_qp] - _u_secondary[_qp]) * _penalty_value * _test_secondary[_i][_qp];\n\n      return residual;\n    }\n\n    case Moose::MortarType::Primary:\n    {\n      auto residual =\n          (_u_primary[_qp] - _u_secondary[_qp]) * _penalty_value * _test_primary[_i][_qp];\n\n      return residual;\n    }\n\n    default:\n      return 0;\n  }\n}\n\nReal\nRegularPenaltyEqualValueConstraint::computeQpJacobian(Moose::ConstraintJacobianType jacobian_type,\n                                                      unsigned int jvar)\n{\n  typedef Moose::ConstraintJacobianType JType;\n\n  switch (jacobian_type)\n  {\n    case JType::SecondarySecondary:\n      if (jvar == _secondary_var.number())\n        return (*_phi)[_j][_qp] * _penalty_value * _test_secondary[_i][_qp];\n      break;\n\n    case JType::SecondaryPrimary:\n      if (jvar == _primary_var.number())\n        return -(*_phi)[_j][_qp] * _penalty_value * _test_secondary[_i][_qp];\n      break;\n\n    case JType::PrimarySecondary:\n      if (jvar == _secondary_var.number())\n        return -(*_phi)[_j][_qp] * _penalty_value * _test_primary[_i][_qp];\n      break;\n\n    case JType::PrimaryPrimary:\n      if (jvar == _primary_var.number())\n        return (*_phi)[_j][_qp] * _penalty_value * _test_primary[_i][_qp];\n      break;\n\n    default:\n      return 0;\n  }\n\n  return 0;\n}\nHowever, the matrix assembled using the non-AD mortar constraint isn't the same as the AD version (it is mainly missing some off-diagonal entries). I must be missing some Jacobian contributions somewhere. @lindsayad @recuero do you have any idea what might be going on here?\nThanks,\nGary",
          "url": "https://github.com/idaholab/moose/discussions/21771",
          "updatedAt": "2022-08-04T00:18:32Z",
          "publishedAt": "2022-08-03T20:53:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I also commented out line 145-147 in MortarConstraint.C:\n      // There's no actual coupling between secondary and primary dofs\n      // if ((jacobian_type == JType::SecondaryPrimary) || (jacobian_type ==\n      // JType::PrimarySecondary))\n      //   continue;",
                  "url": "https://github.com/idaholab/moose/discussions/21771#discussioncomment-3319904",
                  "updatedAt": "2022-08-03T20:56:09Z",
                  "publishedAt": "2022-08-03T20:56:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "All:\nI've also noticed a similar issue when deriving from the MortarConstraint class that the assembled matrix seems to miss the values that are being computed for PrimarySecondary and SecondaryPrimary.\nI'll add that I have also commented the lines\n// There's no actual coupling between secondary and primary dofs\nif ((jacobian_type == JType::SecondaryPrimary) || (jacobian_type == JType::PrimarySecondary))\ncontinue;\nwithin the MortarConstraint.C file in the 7/29/2022 version of the code. And I can confirm from VSCode debugging that there are some non-zero entries in the local k matrix of the PrimarySecondary, and a call is made to accumulate that matrix.\nThanks,\nTim",
                  "url": "https://github.com/idaholab/moose/discussions/21771#discussioncomment-3319930",
                  "updatedAt": "2022-08-03T20:59:45Z",
                  "publishedAt": "2022-08-03T20:59:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Are you guys making sure that you are using an SMP matrix with full = true? If you use solve_type = NEWTON or you have AD objects in your simulation, then we programmatically set that in the framework. But if you are using PJFNK with no AD objects, then by default you will only get diagonal matrix entries",
                  "url": "https://github.com/idaholab/moose/discussions/21771#discussioncomment-3320569",
                  "updatedAt": "2022-08-03T23:28:16Z",
                  "publishedAt": "2022-08-03T23:28:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "although if you are running this with the same variable for both secondary_variable and primary_variable then that is not a concern",
                          "url": "https://github.com/idaholab/moose/discussions/21771#discussioncomment-3320577",
                          "updatedAt": "2022-08-03T23:31:49Z",
                          "publishedAt": "2022-08-03T23:31:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I was using newton, and the same variable on primary and secondary.",
                          "url": "https://github.com/idaholab/moose/discussions/21771#discussioncomment-3320598",
                          "updatedAt": "2022-08-03T23:39:21Z",
                          "publishedAt": "2022-08-03T23:39:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I see the problem. Assembly::cacheJacobianMortar does not accumulate the SecondaryPrimary or PrimarySecondary blocks. That method is unused by AD but is used by the hand-coded objects. Do you think you'll put up a PR for this non-AD object? If so, you (or I) could put the fix for that method in that PR",
                          "url": "https://github.com/idaholab/moose/discussions/21771#discussioncomment-3320612",
                          "updatedAt": "2022-08-03T23:42:46Z",
                          "publishedAt": "2022-08-03T23:42:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I see! I'll do it. Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/21771#discussioncomment-3320617",
                          "updatedAt": "2022-08-03T23:44:24Z",
                          "publishedAt": "2022-08-03T23:44:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PETSc has been updated to 3.16.6",
          "author": {
            "login": "cticenhour"
          },
          "bodyText": "A new PETSc made its way to the MOOSE master branch yesterday. For those using the conda packages, please perform\nmamba update --all\n\nin your MOOSE conda environment. The appropriate moose-petsc package version should be 3.16.6 with build build_0. For those using the the PETSc submodule, please run in the moose/scripts directory\n./update_and_rebuild_petsc.sh\n\nafter updating your copy of MOOSE. Because you have updated PETSc, you will also need to run the update_and_rebuild_libmesh.sh script in order for libMesh to use the new PETSc.",
          "url": "https://github.com/idaholab/moose/discussions/21765",
          "updatedAt": "2022-08-03T17:20:50Z",
          "publishedAt": "2022-08-03T17:20:49Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Tutorial execute file couldn't found in directory",
          "author": {
            "login": "seongwonHam"
          },
          "bodyText": "Hello, MOOSE users.\nI'm starter of MOOSE and I ran some examples to understand MOOSE.\nToday, I start to tutorial02_multiapps in /projects/moose/tutorials/tutorial02_multiapps, but I can't found execute file in this path, there only exist some input files.\nI have some experience of MOOSE example and tutorial01, but I had ran the program with the input file and -opt file to calculate it. So, I wonder how can I execute the tutorial02 and get some output file at /projects/moose/tutorials/tutorial02_multiapps.\nPlease let me know how can I do this.\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/21747",
          "updatedAt": "2022-08-03T03:02:52Z",
          "publishedAt": "2022-08-02T03:22:03Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe app is in moose/tutorials/tutorial02_multiapps/app and you may build the executable in that folder. Then you will have to refer to it to run your input files.\nYou could also probably build just any MOOSE executable for this tutorial, they would all work for this tutorial.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21747#discussioncomment-3307708",
                  "updatedAt": "2022-08-02T12:38:55Z",
                  "publishedAt": "2022-08-02T12:38:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "seongwonHam"
                          },
                          "bodyText": "Oh, I see. I'll follow it.\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/21747#discussioncomment-3312614",
                          "updatedAt": "2022-08-03T03:02:52Z",
                          "publishedAt": "2022-08-03T03:02:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}