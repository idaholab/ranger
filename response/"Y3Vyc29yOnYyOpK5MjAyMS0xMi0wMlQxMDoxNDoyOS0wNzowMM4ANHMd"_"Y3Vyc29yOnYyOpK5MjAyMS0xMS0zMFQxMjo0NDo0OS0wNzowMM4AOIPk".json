{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMS0zMFQxMjo0NDo0OS0wNzowMM4AOIPk"
    },
    "edges": [
      {
        "node": {
          "title": "The X11 connection broke (error 1).",
          "author": {
            "login": "wowodejiajia"
          },
          "bodyText": "Dear MOOSE developers,\nI ran it on Peacock for two days and then reported an error.  How can I solve it?\n(moose) phlab@DESKTOP-PRQA4JN:~/projects/donkey/problems$ peacock -i ex02.i\nQStandardPaths: XDG_RUNTIME_DIR not set, defaulting to '/tmp/runtime-phlab'\nFound executable: /home/phlab/projects/donkey/donkey-opt\nExodus filenames: ['peacock_run_exe_tmp_ex02_other.e']\nPostprocessor filenames: ['peacock_run_exe_tmp_ex02_out.csv']\nRunning command: mpiexec -n 16 /home/phlab/projects/donkey/donkey-opt Outputs/csv=true -i peacock_run_exe_tmp_ex02.i\nWorking directory: /home/phlab/projects/donkey/problems\nThe X11 connection broke (error 1). Did the X11 server die?",
          "url": "https://github.com/idaholab/moose/discussions/19522",
          "updatedAt": "2022-07-25T14:59:12Z",
          "publishedAt": "2021-12-02T03:51:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nhard to know. Maybe it did.\nYou should try to recover from the checkpoint or exodus output, see this page:\nhttps://mooseframework.inl.gov/application_usage/restart_recover.html\nand see if the simulation runs well again or if it dies (and that s what caused the broken connection?)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19522#discussioncomment-1734818",
                  "updatedAt": "2022-09-27T03:46:15Z",
                  "publishedAt": "2021-12-02T04:33:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wowodejiajia"
                          },
                          "bodyText": "Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/19522#discussioncomment-1735477",
                          "updatedAt": "2022-09-27T03:46:21Z",
                          "publishedAt": "2021-12-02T08:05:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Adding Fourier noise to a material property",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "I have material property 'c'. I want another material property 'c_true' which has a Fourier noise in material property 'c'.\nI have already defined the function Fourier noise. But how do I add it to my material property c_true?",
          "url": "https://github.com/idaholab/moose/discussions/19523",
          "updatedAt": "2022-12-03T07:23:37Z",
          "publishedAt": "2021-12-02T04:26:05Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "you can use a ParsedMaterial to define c_sum = c + c_noise\nhttps://mooseframework.inl.gov/source/materials/ParsedMaterial.html",
                  "url": "https://github.com/idaholab/moose/discussions/19523#discussioncomment-1734815",
                  "updatedAt": "2023-07-13T21:33:13Z",
                  "publishedAt": "2021-12-02T04:30:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Yes, I tried doing that but it makes the calculations very slow. Is there any efficient way to add Fourier noise or any other noise (https://mooseframework.inl.gov/moose/source/functions/FourierNoise.html) to directly operate on material  property 'c' and give new material property c_true ?",
                          "url": "https://github.com/idaholab/moose/discussions/19523#discussioncomment-1735015",
                          "updatedAt": "2023-07-13T21:33:13Z",
                          "publishedAt": "2021-12-02T05:59:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you'll have to code your own material if you want to make it fast",
                          "url": "https://github.com/idaholab/moose/discussions/19523#discussioncomment-1735058",
                          "updatedAt": "2023-07-13T21:33:13Z",
                          "publishedAt": "2021-12-02T06:12:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Random Number function",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "I want to create a function which randomly takes value between 0.5 to 1. Are there such kind of inbuilt functions. Can I use ParsedFunction and provide value as random? Please help I am new to moose.",
          "url": "https://github.com/idaholab/moose/discussions/19516",
          "updatedAt": "2022-09-28T07:33:12Z",
          "publishedAt": "2021-12-01T11:21:41Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@zachmprince\nI dont think we have that right now.\nFunctionIC has the code for doing this though, you could port it to a function",
                  "url": "https://github.com/idaholab/moose/discussions/19516#discussioncomment-1731715",
                  "updatedAt": "2022-09-28T07:33:19Z",
                  "publishedAt": "2021-12-01T21:08:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Transfer of a variable's derivative in MultiApp",
          "author": {
            "login": "lekah"
          },
          "bodyText": "Novice user alert \ud83d\ude04\nI have a master application in MOOSE that needs to access not just the (aux)variable y of a sub-application, but also the derivative of that variable, dy/dc, where c is another variable. How can I do that?\nI didn't find any good way of doing that via the transfer mechanism. I can transfer the derivative separately, but then I don't know how to inform MOOSE that this thing I transferred is actually a derivative of y.\nHope that was clear!\nAny hints are appreciated, thank you so much!",
          "url": "https://github.com/idaholab/moose/discussions/19509",
          "updatedAt": "2022-07-08T08:03:52Z",
          "publishedAt": "2021-11-30T18:12:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nTransferring it separately is the way to go here.\nNote that auxvariables don't hold derivative information (they only hold a single field for their value, even when trying to use AD), so you ll have to code in your derivative explicitly in the kernels.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19509#discussioncomment-1724617",
                  "updatedAt": "2022-07-08T08:03:51Z",
                  "publishedAt": "2021-11-30T20:33:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lekah"
                          },
                          "bodyText": "Hi Giullaume,\nthanks for the answer. The variable and derivative are calculated as a material property, I just copy them into AuxVariables for the transfer. I managed to transfer them separately into the master application (again into auxvariables). What is a good way to \"assemble\" them again into MaterialProperty plus the derivative in the Master application?\nLeonid",
                          "url": "https://github.com/idaholab/moose/discussions/19509#discussioncomment-1724661",
                          "updatedAt": "2022-07-08T08:03:51Z",
                          "publishedAt": "2021-11-30T20:43:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can use a MaterialRealAux to define material properties from auxiliary variables",
                          "url": "https://github.com/idaholab/moose/discussions/19509#discussioncomment-1724676",
                          "updatedAt": "2022-07-08T08:03:51Z",
                          "publishedAt": "2021-11-30T20:46:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lekah"
                          },
                          "bodyText": "Thanks for you answer, Guillaume!\nIn the documentation , it is written that The MaterialRealAux AuxKernel is used to output material properties as an element-level, constant variable. . I am using that in the subapplication to  assign a material's property to a variable (and the derivative to another variable).\nThe thing missing for me is the reverse operation (in the master application): assigning an AuxVariable as a materialProperty, and another AuxVariable as the derivative of that MaterialProperty. Do you know of a way to do that?",
                          "url": "https://github.com/idaholab/moose/discussions/19509#discussioncomment-1726784",
                          "updatedAt": "2022-07-08T08:03:51Z",
                          "publishedAt": "2021-12-01T08:22:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh good point.\nto copy an auxvariable into a material property you can use DerivativeParsedMaterial\nhttps://mooseframework.inl.gov/source/materials/DerivativeParsedMaterial.html\nbut you wont be able to set the derivative, the code will try to compute it itself.\nYour solution below works",
                          "url": "https://github.com/idaholab/moose/discussions/19509#discussioncomment-1729489",
                          "updatedAt": "2022-10-15T02:36:35Z",
                          "publishedAt": "2021-12-01T16:46:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you could also have used 2 parsedmaterials to define the property and its derivative. When setting the derivative, use the name that is used to retrieve that derivative in the kernels",
                          "url": "https://github.com/idaholab/moose/discussions/19509#discussioncomment-1729517",
                          "updatedAt": "2022-10-15T02:36:00Z",
                          "publishedAt": "2021-12-01T16:48:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lekah"
                          },
                          "bodyText": "Ah, that's a good idea. Well, since I implemented a class now I will stick to that, but using 2 parsed materials and hacking the name would have been an easier way!",
                          "url": "https://github.com/idaholab/moose/discussions/19509#discussioncomment-1729528",
                          "updatedAt": "2022-10-15T02:35:57Z",
                          "publishedAt": "2021-12-01T16:50:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lekah"
                  },
                  "bodyText": "So, together with @GiudGiud  's answer I found a solution.\nIn the subapplication, copy (field and derivative) from MaterialsProperty to AuxVariable using MaterialRealAux.\nTransfer from AuxVariable in subapplication to AuxVariable in master application (field and derivatives separately).\nTransfer from AuxVariable to MaterialsProperty and declare PropertyDerivative (had to write my own class for that).",
                  "url": "https://github.com/idaholab/moose/discussions/19509#discussioncomment-1729462",
                  "updatedAt": "2022-07-08T08:03:50Z",
                  "publishedAt": "2021-12-01T16:42:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Caught signal 11 (Segmentation fault)",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hello Mooser,\nI come across this error, and I tried the debugging as https://mooseframework.inl.gov/application_development/debugging.html but it didn't work well. Any advice on that? Thank you.\n[mpsc0377:966319:0:966319] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x128)\n==== backtrace (tid: 966319) ====\n 0  /shared/apps/.gcc/8.3/openucx/1.11.2/lib/libucs.so.0(ucs_handle_error+0x254) [0x1463524ead34]\n 1  /shared/apps/.gcc/8.3/openucx/1.11.2/lib/libucs.so.0(+0x23ef4) [0x1463524eaef4]\n 2  /shared/apps/.gcc/8.3/openucx/1.11.2/lib/libucs.so.0(+0x240aa) [0x1463524eb0aa]\n 3  /lib64/libpthread.so.0(+0x12b20) [0x14634f4b2b20]\n 4  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libsuperlu_dist.so.6(BcTree_getDestCount+0x19) [0x1463547322f0]\n 5  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libsuperlu_dist.so.6(+0x687aa) [0x1463547817aa]\n 6  /lib64/libgomp.so.1(GOMP_parallel+0x46) [0x14634e2e2706]\n 7  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libsuperlu_dist.so.6(pdgstrs+0x138f) [0x146354784a40]\n 8  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libsuperlu_dist.so.6(pdgssvx+0x1ce6) [0x14635475b40f]\n 9  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0x4a6a08) [0x146355f3ba08]\n10  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(MatSolve+0x291) [0x1463560d7d56]\n11  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xa10a53) [0x1463564a5a53]\n12  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(PCApply+0x42d) [0x14635663083e]\n13  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(KSPUnwindPreconditioner+0xc0) [0x146356733bcf]\n14  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xbfa833) [0x14635668f833]\n15  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xbfd737) [0x146356692737]\n16  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xbfdb22) [0x146356692b22]\n17  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xc8dc6b) [0x146356722c6b]\n18  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(KSPSolve+0x13) [0x14635672543a]\n19  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xcb7e97) [0x14635674ce97]\n20  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(SNESSolve+0x1330) [0x1463567b9c13]\n21  /home/rh40rejy/MOOSE/moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(_ZN7libMesh20PetscNonlinearSolverIdE5solveERNS_12SparseMatrixIdEERNS_13NumericVectorIdEES7_dj+0x37f) [0x146358c0863f]\n22  /home/rh40rejy/MOOSE/moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(_ZN7libMesh23NonlinearImplicitSystem5solveEv+0xe5) [0x146358c734f5]\n23  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN14TimeIntegrator5solveEv+0x28) [0x14635a4865b8]\n24  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN15NonlinearSystem5solveEv+0x11f) [0x14635aa6e6cf]\n25  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN13FEProblemBase5solveEv+0xd4) [0x14635a5d2b04]\n26  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN14FEProblemSolve5solveEv+0x48) [0x14635a954808]\n27  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN15FixedPointSolve9solveStepERdS0_RKSt3setImSt4lessImESaImEE+0x24c) [0x14635a9563cc]\n28  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN15FixedPointSolve5solveEv+0x272) [0x14635a959d72]\n29  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN11TimeStepper4stepEv+0x2b) [0x14635a706ecb]\n30  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN9Transient8takeStepEd+0xac) [0x14635a95594c]\n31  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN17TransientMultiApp9solveStepEddb+0x103e) [0x14635ab67b8e]\n32  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN13FEProblemBase13execMultiAppsE13MooseEnumItemb+0x346) [0x14635a5cb376]\n33  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN15FixedPointSolve9solveStepERdS0_RKSt3setImSt4lessImESaImEE+0x42d) [0x14635a9565ad]\n34  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN15FixedPointSolve5solveEv+0x272) [0x14635a959d72]\n35  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN11TimeStepper4stepEv+0x2b) [0x14635a706ecb]\n36  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN9Transient8takeStepEd+0xac) [0x14635a95594c]\n37  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN9Transient7executeEv+0x57) [0x14635a95ab37]\n38  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN8MooseApp18executeExecutionerEv+0x243) [0x14635b178873]\n39  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN8MooseApp3runEv+0x74e) [0x14635b17b3ee]\n40  /home/rh40rejy/MOOSE/hound/hound-opt() [0x40a490]\n41  /lib64/libc.so.6(__libc_start_main+0xf3) [0x14634df2f493]\n42  /home/rh40rejy/MOOSE/hound/hound-opt() [0x40a6ce]\n=================================\nsrun: error: mpsc0377: task 32: Segmentation fault (core dumped)",
          "url": "https://github.com/idaholab/moose/discussions/19518",
          "updatedAt": "2022-07-04T08:29:20Z",
          "publishedAt": "2021-12-01T15:17:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nthis is still an opt build. You should work with a debug build to debug this. Please recompile and get a backtrace with a debug build.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19518#discussioncomment-1729272",
                  "updatedAt": "2022-07-04T08:29:18Z",
                  "publishedAt": "2021-12-01T16:13:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stresses and strain in shell elements",
          "author": {
            "login": "hrishiv"
          },
          "bodyText": "The test modules/tensor_mechanics/test/tests/shell/static/plate_bending2.i compares the displacement result of the shell element in MOOSE with ABAQUS. I created the same ABAQUS input file and also added the strains and stresses output for the shell elements in MOOSE. The displacement results of the node C that are mentioned in the MOOSE test file were similar in MOOSE (12.519)  and ABAQUS (12.54) as mentioned in the test input file.\nHowever, I can see that the results of the stress and strains are significantly different.\nMOOSE                                      ABAQUS\nStress xx -              3.4641                                              6\nStress yy -              3.4641                                              6\nStress xy-               8.15e-15 (0)                                      6\nMOOSE and ABAQUS use different formulations for Shell elements. I am unsure if that would be the only reason for the result to be halved in MOOSE than ABAQUS. So, I would be thankful if someone could explain the reason for it or have a look at it.\nI have also attached the picture of the ABAQUS result for displacement and stress xx.\n\n\n# Shell element verification test from Abaqus verification manual 1.3.13\n\n# A 40 m x 20 m x 1 m plate that has E = 1000 Pa and Poisson's ratio = 0.3\n# is subjected to the following boundary/loading conditions. A single shell\n# element is used to model the plate.\n\n# disp_z = 0 at vertices A (0, 0), B (40, 0) and D (20, 0).\n# disp_x and disp_y are zero at all four vertices.\n\n# F_z = -2.0 N at vertex C (40, 20).\n# M_x = 20.0 Nm at vertices A and B (bottom boundary)\n# M_x = -20.0 Nm at vertices C and D (top boundary)\n# M_y = 10.0 Nm at vertices B and C (right boundary)\n# M_y = -10.0 Nm at vertices A and D (left boundary)\n\n# The disp_z at vertex C is -12.54 m using S4 elements in Abaqus.\n# The solution obtained using Moose is -12.519 m with a relative error\n# of 0.16%.\n\n[Mesh]\n  [./gmg]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 1\n    ny = 1\n    xmin = 0.0\n    xmax = 40.0\n    ymin = 0.0\n    ymax = 20.0\n  [../]\n\n  [./c_node]\n    type = ExtraNodesetGenerator\n    input = gmg\n    new_boundary = 100\n    coord = '40.0 20.0'\n  [../]\n[]\n\n[Variables]\n  [./disp_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_z]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./rot_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./rot_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n[AuxVariables]\n  [./stress_xx0]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./strain_xx0]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./stress_yy0]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./strain_yy0]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./stress_xy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./strain_xy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./stress_zy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./strain_zy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./stress_xx0]\n    type = RankTwoAux\n    variable = stress_xx0\n    rank_two_tensor = global_stress_t_points_1\n    index_i = 0\n    index_j = 0\n  [../]\n  [./strain_xx0]\n    type = RankTwoAux\n    variable = strain_xx0\n    rank_two_tensor = total_global_strain_t_points_1\n    index_i = 0\n    index_j = 0\n  [../]\n  [./stress_yy0]\n    type = RankTwoAux\n    variable = stress_yy0\n    rank_two_tensor = global_stress_t_points_1\n    index_i = 1\n    index_j = 1\n  [../]\n  [./strain_yy0]\n    type = RankTwoAux\n    variable = strain_yy0\n    rank_two_tensor = total_global_strain_t_points_1\n    index_i = 1\n    index_j = 1\n  [../]\n  [./stress_xy]\n    type = RankTwoAux\n    variable = stress_xy\n    rank_two_tensor = global_stress_t_points_1\n    index_i = 0\n    index_j = 1\n  [../]\n  [./strain_xy]\n    type = RankTwoAux\n    variable = strain_xy\n    rank_two_tensor = total_global_strain_t_points_1\n    index_i = 0\n    index_j = 1\n  [../]\n  [./strain_zy]\n    type = RankTwoAux\n    variable = strain_xy\n    rank_two_tensor = total_global_strain_t_points_1\n    index_i = 1\n    index_j = 2\n  [../]\n  [./stress_yz]\n    type = RankTwoAux\n    variable = stress_xy\n    rank_two_tensor = global_stress_t_points_1\n    index_i = 1\n    index_j = 2\n  [../]\n  []\n\n[BCs]\n  [./simply_support_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'right top bottom left'\n    value = 0.0\n  [../]\n  [./simply_support_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'right top bottom left'\n    value = 0.0\n  [../]\n  [./simply_support_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom left'\n    value = 0.0\n  [../]\n[]\n\n[NodalKernels]\n  [./force_C]\n    type = ConstantRate\n    variable = disp_z\n    boundary = 100\n    rate = -2.0\n  [../]\n  [./Mx_AB]\n    type = ConstantRate\n    variable = rot_x\n    boundary = bottom\n    rate = 20.0\n  [../]\n  [./Mx_CD]\n    type = ConstantRate\n    variable = rot_x\n    boundary = top\n    rate = -20.0\n  [../]\n  [./My_BC]\n    type = ConstantRate\n    variable = rot_y\n    boundary = right\n    rate = 10.0\n  [../]\n  [./My_AD]\n    type = ConstantRate\n    variable = rot_y\n    boundary = left\n    rate = -10.0\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  line_search = 'none'\n  #nl_max_its = 2\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 6e-6\n\n  dt = 1.0\n  dtmin = 1.0\n  end_time = 3\n[]\n\n[Kernels]\n  [./solid_disp_x]\n    type = ADStressDivergenceShell\n    block = '0'\n    component = 0\n    variable = disp_x\n    through_thickness_order = SECOND\n  [../]\n  [./solid_disp_y]\n    type = ADStressDivergenceShell\n    block = '0'\n    component = 1\n    variable = disp_y\n    through_thickness_order = SECOND\n  [../]\n  [./solid_disp_z]\n    type = ADStressDivergenceShell\n    block = '0'\n    component = 2\n    variable = disp_z\n    through_thickness_order = SECOND\n  [../]\n  [./solid_rot_x]\n    type = ADStressDivergenceShell\n    block = '0'\n    component = 3\n    variable = rot_x\n    through_thickness_order = SECOND\n  [../]\n  [./solid_rot_y]\n    type = ADStressDivergenceShell\n    block = '0'\n    component = 4\n    variable = rot_y\n    through_thickness_order = SECOND\n  [../]\n[]\n\n[Materials]\n  [./elasticity]\n    type = ADComputeIsotropicElasticityTensorShell\n    youngs_modulus = 1e3\n    poissons_ratio = 0.3\n    block = 0\n    through_thickness_order = SECOND\n  [../]\n  [./strain]\n    type = ADComputeIncrementalShellStrain\n    block = '0'\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y'\n    thickness = 1.0\n    through_thickness_order = SECOND\n  [../]\n  [./stress]\n    type = ADComputeShellStress\n    block = 0\n    through_thickness_order = SECOND\n  [../]\n[]\n\n[Postprocessors]\n  [./disp_z2]\n    type = PointValue\n    point = '40.0 20.0 0.0'\n    variable = disp_z\n  [../]\n  [./stress_xx_el_0]\n   type = ElementalVariableValue\n   elementid = 0\n   variable = stress_xx0\n [../]\n [./strain_xx_el_0]\n  type = ElementalVariableValue\n  elementid = 0\n  variable = strain_xx0\n[../]\n[./stress_yy_el_0]\n type = ElementalVariableValue\n elementid = 0\n variable = stress_yy0\n[../]\n[./stress_xy_el_0]\n type = ElementalVariableValue\n elementid = 0\n variable = stress_xy\n[../]\n[./stress_yz_el_0]\n type = ElementalVariableValue\n elementid = 0\n variable = stress_zy\n[../]\n[./strain_xy_el_0]\n type = ElementalVariableValue\n elementid = 0\n variable = strain_xy\n[../]\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/18592",
          "updatedAt": "2022-06-18T08:03:29Z",
          "publishedAt": "2021-08-12T19:54:04Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hrishiv"
                  },
                  "bodyText": "@sveerara I am not sure if you are still working on MOOSE but thought you would be the best person to ask :)",
                  "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1165353",
                  "updatedAt": "2022-06-18T08:03:51Z",
                  "publishedAt": "2021-08-12T19:54:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hrishiv"
                  },
                  "bodyText": "I was able to match the stress in xx and yy direction to 3.464 in MOOSE and ABAQUS by using Gauss thickness integration with 2 points in ABAQUS but still, MOOSE result indicates 0 stress in XY direction whereas ABAQUS results show stress XY to be 3.464.",
                  "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1165530",
                  "updatedAt": "2022-06-18T08:03:51Z",
                  "publishedAt": "2021-08-12T20:35:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "@hrishiv This comparison is tricky without knowing where Abaqus is measuring the stresses. I am guessing Abaqus is measuring stresses at the mid-thickness point. Assume we are using N points, in moose, the through thickness integration points are indexed by 0, 1, 2, ..., N-1, and the mid-thickness point would correspond to the (N-1)/2th point.\nI slightly modified your input file to reflect that. In the input file I defined two parameters order and N. order would be the through thickness quadrature order, and I evaluate the stress at the Nth point. For example, order = THIRD corresponds to N = 1, and order = SEVENTEENTH corresponds to N = 8. I can obtain satisfactory results with these changes:\norder stress_xx stress_yy stress_xy\n3     3.464102  3.464102  3.464102\n5     4.647580  4.647580  4.647580\n9     5.437079  5.437079  5.437079\n17    5.808961  5.808961  5.808961\n33    5.943453  5.943453  5.943453\n\nI remember the implementation in moose is mostly the same as Abaqus's, but don't quote me on that.\nMy input file is attached here:\norder = THIRD\nN = 1\n\n[GlobalParams]\n  through_thickness_order = ${order}\n  large_strain = true\n[]\n\n[Mesh]\n  [gmg]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 1\n    ny = 1\n    xmin = 0.0\n    xmax = 40.0\n    ymin = 0.0\n    ymax = 20.0\n  []\n  [A]\n    type = ExtraNodesetGenerator\n    input = gmg\n    new_boundary = A\n    coord = '0 0'\n  []\n  [B]\n    type = ExtraNodesetGenerator\n    input = A\n    new_boundary = B\n    coord = '40 0'\n  []\n  [C]\n    type = ExtraNodesetGenerator\n    input = B\n    new_boundary = C\n    coord = '40 20'\n  []\n  [D]\n    type = ExtraNodesetGenerator\n    input = C\n    new_boundary = D\n    coord = '0 20'\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n  [rot_x]\n  []\n  [rot_y]\n  []\n[]\n\n[BCs]\n  [simply_support_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'A B C D'\n    value = 0\n  []\n  [simply_support_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'A B C D'\n    value = 0\n  []\n  [simply_support_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'A B D'\n    value = 0\n  []\n[]\n\n[NodalKernels]\n  [force_C]\n    type = ConstantRate\n    variable = disp_z\n    boundary = C\n    rate = -2\n  []\n  [Mx_AB]\n    type = ConstantRate\n    variable = rot_x\n    boundary = bottom\n    rate = 20\n  []\n  [Mx_CD]\n    type = ConstantRate\n    variable = rot_x\n    boundary = top\n    rate = -20\n  []\n  [My_BC]\n    type = ConstantRate\n    variable = rot_y\n    boundary = right\n    rate = 10\n  []\n  [My_AD]\n    type = ConstantRate\n    variable = rot_y\n    boundary = left\n    rate = -10\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n  nl_rel_tol = 1e-08\n  nl_abs_tol = 1e-10\n\n  num_steps = 1\n[]\n\n[Kernels]\n  [solid_disp_x]\n    type = ADStressDivergenceShell\n    component = 0\n    variable = disp_x\n  []\n  [solid_disp_y]\n    type = ADStressDivergenceShell\n    component = 1\n    variable = disp_y\n  []\n  [solid_disp_z]\n    type = ADStressDivergenceShell\n    component = 2\n    variable = disp_z\n  []\n  [solid_rot_x]\n    type = ADStressDivergenceShell\n    component = 3\n    variable = rot_x\n  []\n  [solid_rot_y]\n    type = ADStressDivergenceShell\n    component = 4\n    variable = rot_y\n  []\n[]\n\n[Materials]\n  [elasticity]\n    type = ADComputeIsotropicElasticityTensorShell\n    youngs_modulus = 1e3\n    poissons_ratio = 0.3\n  []\n  [strain]\n    type = ADComputeFiniteShellStrain\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y'\n    thickness = 1.0\n  []\n  [stress]\n    type = ADComputeShellStress\n    output_properties = 'global_stress_t_points_7'\n    outputs = exodus\n  []\n[]\n\n[Postprocessors]\n  [disp_z]\n    type = PointValue\n    point = '40.0 20.0 0.0'\n    variable = disp_z\n  []\n  [stress_xx]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 0\n    index_j = 0\n  []\n  [stress_yy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 1\n    index_j = 1\n  []\n  [stress_xy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 0\n    index_j = 1\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1166158",
                  "updatedAt": "2022-06-18T08:03:53Z",
                  "publishedAt": "2021-08-13T01:21:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "@hugary1995 Thanks for the suggestion. I can now get the same stresses in the format that you suggested with single element but is there any other postprocessor that allows me to get the stress at a particular element when I have multiple elements.\nHowever, when I try to output the strain in a similar way using small strain formulation in both ABAQUS and MOOSE I am facing some differences (I changed to small strain because when I used ADComputeFiniteShellStrain and   output_properties = 'total_global_strain_t_points_${N}' I was getting 0 for the strains).\nABAQUS - strain xx  and strainyy = 2.425e-3,    strainxy = 9.007e-3\nMOOSE - strainxx = 3.879e2     strainyy =2.424e2        strainxy=1.801e2\nI think there is an error during the transformation of the strain in lines 240-241 of ADComputeIncrementalShellStrain.\n      (*_total_global_strain[j])[i] = (*_rotation_matrix[j])[i].transpose() *\n                                      _unrotated_total_strain * (*_rotation_matrix[j])[i];\n\nI changed this line to\n        (*_total_global_strain[j])[i] =  ((*_rotation_matrix[j])[i].inverse()).transpose() *\n                                    _unrotated_total_strain * (*_rotation_matrix[j])[i].inverse();\n\nand the results for xx and yy are close and xy is half (may be abaqus is giving me 2exy not sure though)\nMOOSE after change - strain xx  and strainyy = 2.42487e-3,    strainxy = 4.503332e-3\nPlease correct me if I am wrong or have made any mistakes.\nThank you\nHere is my input file.\norder = THIRD\nN = 1\n\n[GlobalParams]\n  through_thickness_order = ${order}\n  # large_strain = true\n[]\n\n[Mesh]\n  [gmg]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 1\n    ny = 1\n    xmin = 0.0\n    xmax = 40.0\n    ymin = 0.0\n    ymax = 20.0\n  []\n  [A]\n    type = ExtraNodesetGenerator\n    input = gmg\n    new_boundary = A\n    coord = '0 0'\n  []\n  [B]\n    type = ExtraNodesetGenerator\n    input = A\n    new_boundary = B\n    coord = '40 0'\n  []\n  [C]\n    type = ExtraNodesetGenerator\n    input = B\n    new_boundary = C\n    coord = '40 20'\n  []\n  [D]\n    type = ExtraNodesetGenerator\n    input = C\n    new_boundary = D\n    coord = '0 20'\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n  [rot_x]\n  []\n  [rot_y]\n  []\n[]\n\n[BCs]\n  [simply_support_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'A B C D'\n    value = 0\n  []\n  [simply_support_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'A B C D'\n    value = 0\n  []\n  [simply_support_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'A B D'\n    value = 0\n  []\n[]\n\n[NodalKernels]\n  [force_C]\n    type = ConstantRate\n    variable = disp_z\n    boundary = C\n    rate = -2\n  []\n  [Mx_AB]\n    type = ConstantRate\n    variable = rot_x\n    boundary = bottom\n    rate = 20\n  []\n  [Mx_CD]\n    type = ConstantRate\n    variable = rot_x\n    boundary = top\n    rate = -20\n  []\n  [My_BC]\n    type = ConstantRate\n    variable = rot_y\n    boundary = right\n    rate = 10\n  []\n  [My_AD]\n    type = ConstantRate\n    variable = rot_y\n    boundary = left\n    rate = -10\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n  nl_rel_tol = 1e-08\n  nl_abs_tol = 1e-10\n\n  num_steps = 1\n[]\n\n[Kernels]\n  [solid_disp_x]\n    type = ADStressDivergenceShell\n    component = 0\n    variable = disp_x\n  []\n  [solid_disp_y]\n    type = ADStressDivergenceShell\n    component = 1\n    variable = disp_y\n  []\n  [solid_disp_z]\n    type = ADStressDivergenceShell\n    component = 2\n    variable = disp_z\n  []\n  [solid_rot_x]\n    type = ADStressDivergenceShell\n    component = 3\n    variable = rot_x\n  []\n  [solid_rot_y]\n    type = ADStressDivergenceShell\n    component = 4\n    variable = rot_y\n  []\n[]\n\n[Materials]\n  [elasticity]\n    type = ADComputeIsotropicElasticityTensorShell\n    youngs_modulus = 1e3\n    poissons_ratio = 0.3\n  []\n  [strain]\n    type = ADComputeIncrementalShellStrain\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y'\n    thickness = 1.0\n    output_properties = 'total_global_strain_t_points_${N}'\n  []\n  [stress]\n    type = ADComputeShellStress\n    output_properties = 'global_stress_t_points_${N}'\n    outputs = exodus\n  []\n[]\n\n[Postprocessors]\n  [disp_z]\n    type = PointValue\n    point = '40.0 20.0 0.0'\n    variable = disp_z\n  []\n  [stress_xx]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 0\n    index_j = 0\n  []\n  [stress_yy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 1\n    index_j = 1\n  []\n  [stress_xy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 0\n    index_j = 1\n  []\n  [strain_xx]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'total_global_strain_t_points_${N}'\n    index_i = 0\n    index_j = 0\n  []\n  [strain_yy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'total_global_strain_t_points_${N}'\n    index_i = 1\n    index_j = 1\n  []\n  [strain_xy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'total_global_strain_t_points_${N}'\n    index_i = 0\n    index_j = 1\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1190922",
                          "updatedAt": "2022-06-23T14:42:51Z",
                          "publishedAt": "2021-08-16T16:15:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Your modification looks reasonable to me. You could simplify that using the fact that the inverse of the rotation matrix is its transpose.\nHowever, I cannot guarantee this is exactly what you need, as I have never gone through the shell formulation in moose in detail. I believe @cbolisetti has more experience about this shell formulation.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1192217",
                          "updatedAt": "2022-06-23T14:42:53Z",
                          "publishedAt": "2021-08-16T21:23:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "@hugary1995 With the postprocessor you suggested I was able to get the stress and strain when I used the single element. But, as it gives average stress or strain over the volume, I think it can't give me stress and strain of a particular element when I use 2 or more elements. Is there any other postprocessor that you would suggest to output the stress and strain of a particular element when I use multiple elements?\nAlso, is there any postprocessor to output the strain and stress at the quadrature points?",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1329828",
                          "updatedAt": "2022-06-23T14:42:52Z",
                          "publishedAt": "2021-09-14T20:33:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You can use an elemental Auxkernel to output stress/strain per element. If you use RankTwoAux, you can optionally provide a parameter selected_qp to output the quantity at a specific quadrature point.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1346145",
                          "updatedAt": "2022-06-23T14:43:06Z",
                          "publishedAt": "2021-09-17T07:38:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "@hugary1995 Thank you for the reply. It helped me in static case but now I am facing problems in dynamic simulations with shell elements and comparing with ABAQUS. So I decided to run one of the similar tests created by the MOOSE group.\nmodules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment.i\nIt was not running and I had to uncomment the commented section in the Executioner block and had to add petsc for convergence to\n[Executioner]\ntype = Transient\nsolve_type = PJFNK\nnl_max_its = 20\nnl_rel_tol = 1e-10\nnl_abs_tol = 5e-4\ndt = 0.0005\ndtmin = 0.0005\nend_time = 1\n[./TimeIntegrator]\ntype = NewmarkBeta\nbeta = 0.25\ngamma = 0.5\n[../]\npetsc_options = '-snes_ksp_ew'\npetsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\npetsc_options_value = '201                hypre    boomeramg      4'\n[]\nThe analytical solution for the displacement at tip has been calculated in the heading as disp_z= 1.9 m using the small deformation theory. I was able to get 1.98 m in ABAQUS, the higher value may be on accounting for the large deflection theory.\nBut when I ran the test in MOOSE I was able to get only 0.645 m.  Also, the header mentions that the displacement at the tip is 1.875 m in MOOSE. I am confused why I am not getting so much difference.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427232",
                          "updatedAt": "2022-06-23T14:43:06Z",
                          "publishedAt": "2021-10-04T22:58:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "That input file (shell_dynamics_bending_moment.i) is not being tested. I just happen to have touched it in an open PR. You cannot trust what it says in the header, sorry.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427290",
                          "updatedAt": "2022-06-23T14:43:06Z",
                          "publishedAt": "2021-10-04T23:29:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "@dschwen I checked the analytical solution and it seems correct. Also, the result in the ABAQUS is close to it. So, I would assume MOOSE to give a similar result but the results in the MOOSE for the dynamic analysis of shell elements are way off. I am more concerned with the deviation of results from the analytical and ABAQUS solution rather than the MOOSE answer mentioned in the header file.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427330",
                          "updatedAt": "2022-06-23T14:43:06Z",
                          "publishedAt": "2021-10-04T23:53:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'll take a look at this.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427632",
                          "updatedAt": "2022-06-23T14:43:06Z",
                          "publishedAt": "2021-10-05T01:49:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I modified the input file such that it matches the description in the heading:\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  rotations = 'rot_x rot_y'\n  thickness = 0.1\n  through_thickness_order = FOURTH\n[]\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 1\n  ny = 4\n  xmin = 0.0\n  xmax = 1.0\n  ymin = 0.0\n  ymax = 10.0\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n  [rot_x]\n  []\n  [rot_y]\n  []\n[]\n\n[AuxVariables]\n  [stress_yy]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [stress_yz]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  # aux variables for dynamics\n  [vel_x]\n  []\n  [vel_y]\n  []\n  [vel_z]\n  []\n  [accel_x]\n  []\n  [accel_y]\n  []\n  [accel_z]\n  []\n  [rot_vel_x]\n  []\n  [rot_vel_y]\n  []\n  [rot_accel_x]\n  []\n  [rot_accel_y]\n  []\n[]\n\n[AuxKernels]\n  [stress_yy]\n    type = RankTwoAux\n    variable = stress_yy\n    rank_two_tensor = global_stress_t_points_0\n    index_i = 1\n    index_j = 1\n  []\n  [stress_yz]\n    type = RankTwoAux\n    variable = stress_yz\n    rank_two_tensor = global_stress_t_points_0\n    index_i = 1\n    index_j = 2\n  []\n\n  # Kernels for dynamics\n  [accel_x]\n    type = NewmarkAccelAux\n    variable = accel_x\n    displacement = disp_x\n    velocity = vel_x\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_x]\n    type = NewmarkVelAux\n    variable = vel_x\n    acceleration = accel_x\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_y]\n    type = NewmarkAccelAux\n    variable = accel_y\n    displacement = disp_y\n    velocity = vel_y\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_y]\n    type = NewmarkVelAux\n    variable = vel_y\n    acceleration = accel_y\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_z]\n    type = NewmarkAccelAux\n    variable = accel_z\n    displacement = disp_z\n    velocity = vel_z\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_z]\n    type = NewmarkVelAux\n    variable = vel_z\n    acceleration = accel_z\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [rot_accel_x]\n    type = NewmarkAccelAux\n    variable = rot_accel_x\n    displacement = rot_x\n    velocity = rot_vel_x\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [rot_vel_x]\n    type = NewmarkVelAux\n    variable = rot_vel_x\n    acceleration = rot_accel_x\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [rot_accel_y]\n    type = NewmarkAccelAux\n    variable = rot_accel_y\n    displacement = rot_y\n    velocity = rot_vel_y\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [rot_vel_y]\n    type = NewmarkVelAux\n    variable = rot_vel_y\n    acceleration = rot_accel_y\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n\n[]\n\n[BCs]\n  [fixx1]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    value = 0.0\n  []\n  [fixy1]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0.0\n  []\n  [fixz1]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    value = 0.0\n  []\n  [fixr1]\n    type = DirichletBC\n    variable = rot_x\n    boundary = 'bottom'\n    value = 0.0\n  []\n  # [fixr2]\n  #   type = DirichletBC\n  #   variable = rot_y\n  #   boundary = 'bottom'\n  #   value = 0.0\n  # []\n[]\n\n[NodalKernels]\n  [force_y2]\n    type = UserForcingFunctionNodalKernel\n    variable = disp_z\n    boundary = 'top'\n    function = 0.5\n  []\n[]\n\n[Kernels]\n  [solid_disp_x]\n    type = ADStressDivergenceShell\n    component = 0\n    variable = disp_x\n    use_displaced_mesh = true\n  []\n  [solid_disp_y]\n    type = ADStressDivergenceShell\n    component = 1\n    variable = disp_y\n    use_displaced_mesh = true\n  []\n  [solid_disp_z]\n    type = ADStressDivergenceShell\n    component = 2\n    variable = disp_z\n    use_displaced_mesh = true\n  []\n  [solid_rot_x]\n    type = ADStressDivergenceShell\n    component = 3\n    variable = rot_x\n    use_displaced_mesh = true\n  []\n  [solid_rot_y]\n    type = ADStressDivergenceShell\n    component = 4\n    variable = rot_y\n    use_displaced_mesh = true\n  []\n  [inertial_force_x]\n    type = ADInertialForceShell\n    velocities = 'vel_x vel_y vel_z'\n    accelerations = 'accel_x accel_y accel_z'\n    rotational_velocities = 'rot_vel_x rot_vel_y'\n    rotational_accelerations = 'rot_accel_x rot_accel_y'\n    component = 0\n    variable = disp_x\n  []\n  [inertial_force_y]\n    type = ADInertialForceShell\n    velocities = 'vel_x vel_y vel_z'\n    accelerations = 'accel_x accel_y accel_z'\n    rotational_velocities = 'rot_vel_x rot_vel_y'\n    rotational_accelerations = 'rot_accel_x rot_accel_y'\n    component = 1\n    variable = disp_y\n  []\n  [inertial_force_z]\n    type = ADInertialForceShell\n    velocities = 'vel_x vel_y vel_z'\n    accelerations = 'accel_x accel_y accel_z'\n    rotational_velocities = 'rot_vel_x rot_vel_y'\n    rotational_accelerations = 'rot_accel_x rot_accel_y'\n    component = 2\n    variable = disp_z\n  []\n  [inertial_force_rot_x]\n    type = ADInertialForceShell\n    velocities = 'vel_x vel_y vel_z'\n    accelerations = 'accel_x accel_y accel_z'\n    rotational_velocities = 'rot_vel_x rot_vel_y'\n    rotational_accelerations = 'rot_accel_x rot_accel_y'\n    component = 3\n    variable = rot_x\n  []\n  [inertial_force_rot_y]\n    type = ADInertialForceShell\n    velocities = 'vel_x vel_y vel_z'\n    accelerations = 'accel_x accel_y accel_z'\n    rotational_velocities = 'rot_vel_x rot_vel_y'\n    rotational_accelerations = 'rot_accel_x rot_accel_y'\n    component = 4\n    variable = rot_y\n  []\n[]\n\n[Materials]\n  [elasticity]\n    type = ADComputeIsotropicElasticityTensorShell\n    youngs_modulus = 2100000\n    poissons_ratio = 0.0\n  []\n  [strain]\n    type = ADComputeFiniteShellStrain\n  []\n  [stress]\n    type = ADComputeShellStress\n  []\n  [density]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = '1.0'\n  []\n[]\n\n[Postprocessors]\n  [disp_z_tip]\n    type = PointValue\n    point = '1.0 10.0 0.0'\n    variable = disp_z\n  []\n  [rot_x_tip]\n    type = PointValue\n    point = '0.0 10.0 0.0'\n    variable = rot_x\n  []\n  [stress_yy_el_0]\n    type = ElementalVariableValue\n    elementid = 0\n    variable = stress_yy\n  []\n  [stress_yy_el_1]\n    type = ElementalVariableValue\n    elementid = 1\n    variable = stress_yy\n  []\n  [stress_yy_el_2]\n    type = ElementalVariableValue\n    elementid = 2\n    variable = stress_yy\n  []\n  [stress_yy_el_3]\n    type = ElementalVariableValue\n    elementid = 3\n    variable = stress_yy\n  []\n  [stress_yz_el_0]\n    type = ElementalVariableValue\n    elementid = 0\n    variable = stress_yz\n  []\n  [stress_yz_el_1]\n    type = ElementalVariableValue\n    elementid = 1\n    variable = stress_yz\n  []\n  [stress_yz_el_2]\n    type = ElementalVariableValue\n    elementid = 2\n    variable = stress_yz\n  []\n  [stress_yz_el_3]\n    type = ElementalVariableValue\n    elementid = 3\n    variable = stress_yz\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = PJFNK\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '201 hypre boomeramg 4'\n\n  # solve_type = NEWTON\n  # petsc_options_iname = '-pc_type'\n  # petsc_options_value = 'lu'\n\n  automatic_scaling = true\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-8\n\n  dt = 0.0005\n  dtmin = 0.0005\n  end_time = 1\n\n  timestep_tolerance = 1e-9\n\n  [TimeIntegrator]\n    type = NewmarkBeta\n  []\n[]\n\n[Outputs]\n  print_linear_residuals = false\n  exodus = true\n[]\n\nThe most notable change is in the forcing function. Before, it was mistakenly ramped from 0 to 0.5, and I changed to constant 0.5.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427677",
                          "updatedAt": "2022-06-23T14:43:07Z",
                          "publishedAt": "2021-10-05T02:18:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "WIth these changes, the tip disp_z goes to 1.704083 and tip rot_x goes to 0.2725277. They are much closer, but still not perfect. I'd have to look at the original problem setup to figure whatelse might be wrong.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427681",
                          "updatedAt": "2022-06-23T14:43:18Z",
                          "publishedAt": "2021-10-05T02:20:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can MOOSE work with overlapping subdomains?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys, I'm having trouble uploading Abaqus mesh (with overlapping subdomain) to MOOSE\nMOOSE's meshfile and FileMeshGenerator don't seem to detect the subdomain within the larger subdomain for example the figure below (mining-related)\nthe green and the yellow are the model rock type block and the smaller blocks are the mining activity blocks,\nbut in this case, MOOSE will only see the rock type blocks and completely ignore the smaller blocks\nI need both of them for my workflow, is there a way to deal with this issue?\n\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/19501",
          "updatedAt": "2022-09-27T19:57:11Z",
          "publishedAt": "2021-11-30T00:31:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Every element belongs to one and only one subdomain. This has been a fundamental assumption in lots of code in libmesh. You may look into alternatives such as elemental auxvariables and extra element IDs.",
                  "url": "https://github.com/idaholab/moose/discussions/19501#discussioncomment-1728106",
                  "updatedAt": "2022-09-27T19:57:11Z",
                  "publishedAt": "2021-12-01T12:45:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "fail to import pyhit in HPC",
          "author": {
            "login": "ada-ayy"
          },
          "bodyText": "Hello, everyone!\nI have installed moose on the HPC cluster followed by https://mooseframework.inl.gov/getting_started/installation/conda.html.\nWhen I try \"run_tests\" on my login node, they all go on smoothly. But when I submit a task to compute nodes, it always fails with \"fail to import pyhit\".\n$ which python\n~/miniconda3/envs/moose/bin/python\n$ module list\nNo modules loaded\n(for the compute nodes, I sometimes module load intel, but it still fails to import pyhit)\nAnd here is my conda list and ldd result.\nconda list and ldd.txt\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/19483",
          "updatedAt": "2022-07-01T16:17:55Z",
          "publishedAt": "2021-11-25T02:33:54Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIn your submit script, do you load the environment?\neg do you have conda activate moose ?\nNote that the conda install isnt optimal for HPC clusters. You want to look at these instructions for that:\nhttps://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1697747",
                  "updatedAt": "2022-07-20T15:25:26Z",
                  "publishedAt": "2021-11-25T03:50:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "yeah, I have loaded the environment,  when I \"echo $CONDA_DEFAULT_ENV\", both of the login node and compute node return \"moose\"\nI have tried https://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html, but it fails with many problems, so I wonder whether I could use conda to install it.",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1697773",
                          "updatedAt": "2022-07-20T15:25:30Z",
                          "publishedAt": "2021-11-25T04:01:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "My experience is that you can but it wont be as fast. Not sure for the error message. @milljm will know",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1697798",
                          "updatedAt": "2022-07-20T15:25:30Z",
                          "publishedAt": "2021-11-25T04:11:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "Thanks! I will try the hpc_install guide again if the conda doesn't fit.",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1697806",
                          "updatedAt": "2022-07-20T15:25:30Z",
                          "publishedAt": "2021-11-25T04:17:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ada-ayy"
                  },
                  "bodyText": "@milljm Hello! Do you have any suggestions for me?",
                  "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1713236",
                  "updatedAt": "2022-07-20T15:25:33Z",
                  "publishedAt": "2021-11-29T01:25:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Are you using qsub to launch a job? If so, can we see the qsub script?\nHave you tried to perform the same things in this qsub script, manually, using qsub -I. -I launches an interactive session on a node, allowing you to troubleshoot things like this.\n\"fail to import pyhit\" usually means MOOSE is attempting to be run with a different environment than it was built with. So we're looking for reasons why \"conda activate moose\" may not be occurring during your job submission routine.\nINL HPC?\nWhich HPC cluster are we talking about? One of ours at INL? If so, we have modules available that are better suited to running MOOSE instead of using Conda's \"non-optimized compilers\". Concerning Falcon, Lemhi, and Sawtooth, the general instructions for obtaining these compilers is:\nmodule load use.moose PETSc",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1716617",
                          "updatedAt": "2022-07-20T15:25:32Z",
                          "publishedAt": "2021-11-29T15:22:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Also, sorry @ada-ayy. I am going through my email after a long period of inactivity (thanksgiving holiday for us), and I just made it to yours (about me asking you to create a new discussion). I was keeping my eye out for one from you, but it slipped through my attention...",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1716780",
                          "updatedAt": "2022-07-20T15:25:33Z",
                          "publishedAt": "2021-11-29T15:50:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "Never mind, I'm not in a hurry :\uff09\nI use sbatch script (slurm system)  to submit my task.\nThe HPC cluster I use is from my university, not INL. I do not use the default conda environment in my cluster, but create a new one within my home directory. Maybe this is the problem?\nThe operating system is CentOS 7.6.\nThis is my script:\n#!/bin/bash\n#SBATCH -p cpu-normal \n#SBATCH -J moosetest\n#SBATCH -N 1\n#SBATCH -n 4\n#SBATCH  -t 1:00:00\n\nsrun hostname | sort > machinefile.${SLURM_JOB_ID}\n\nNP=`cat machinefile.${SLURM_JOB_ID} | wc -l`\n\n#conda activate moose\n#module load intel/19.0.5.281\n\n#make hit\n\n#srun -n 4 ./run_tests \n./run_tests -j 4",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1719673",
                          "updatedAt": "2022-07-20T15:25:39Z",
                          "publishedAt": "2021-11-30T03:01:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I am not understanding this batch script... it looks like conda activate moose is commented out. Pretty sure you want this line to actually run. I would uncomment that as the first step.",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1722617",
                          "updatedAt": "2022-12-11T13:52:04Z",
                          "publishedAt": "2021-11-30T14:35:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "yeah, I have tried, but failed with the same problem again. Maybe it is more related to the environment of my HPC cluster. I will ask the administer for advice or try another way to install moose. Thanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1725818",
                          "updatedAt": "2022-12-11T13:52:04Z",
                          "publishedAt": "2021-12-01T02:23:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Use \"if-else\" in input file & set initial value for post-processor",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Because I'm working on several themes simultaneously, I made several discussion...\nI'm sorry about that.\nFirst question is\n\"How to use \"if-else\" statement in an input file?\"\n\nI tried to use \"if-else\" statement, but this failed.. I also tried to find an appropriate example for what I need. It was hard to find.\nfor example, what I want to do is\nif (time=0) {'vals = 0 1.03665 0.4'}\nelse {'vals = 0.03607 1.03665 0.4'}\nSecond question is\n\"How to assign the initial value (initialization) for post-processor?\"\nFrom the previous discussion that I made, I knew Postprocessor is not being executed at the 0th timestep.\nSo, introducing execute_on = 'initial timestep_end' in the postprocessor will work.\nHowever, what I want to do now is \"assign a specific value for postprocessor at 0th step\"\nFor my function like below,\n\nI need to assign 0 on postprocessor \"numerical_phi_YSZ\" at 0th step to make it work correctly.",
          "url": "https://github.com/idaholab/moose/discussions/18247",
          "updatedAt": "2022-07-19T18:51:24Z",
          "publishedAt": "2021-07-02T22:59:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo this is fine, a discussion for each topic is definitely the way to go.\nIn general, you can use the Controls system to enable/disable blocks, to make if-else like statements.\nBut for a parsed function, you can use this syntax:\n  [./const_ref]\n    type = ParsedFunction\n    value = '\n            ix := if(x < 0.5, 0, if(x < 1, 1, 2));\n            iy := if(y > 0, 2, if(y > -0.5, 1, 0));\n            iy * 3 + ix\n            '\n  [../]\n\nYou cant do that for postprocessors. If executing at the initial timestep does not work for you, then you need to use an if-else statement there too.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18247#discussioncomment-958781",
                  "updatedAt": "2022-07-19T18:16:19Z",
                  "publishedAt": "2021-07-02T23:09:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "First you dont need this:\nmaterial_property_names = k\nk does not come in the function expression\nthen I just tested your block with this input file below and it gave 0.024 as expected:\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 10\n  ny = 10\n[]\n\n[Variables]\n  [u]\n  []\n[]\n\n[Kernels]\n  [diff]\n    type = Diffusion\n    variable = u\n  []\n[]\n\n[BCs]\n  [left]\n    type = DirichletBC\n    variable = u\n    boundary = left\n    value = 0\n  []\n  [right]\n    type = DirichletBC\n    variable = u\n    boundary = right\n    value = 1\n  []\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[AuxVariables]\n  [temperature]\n    type = MooseVariableFVReal\n    initial_condition = 2000\n  []\n  [k]\n    type = MooseVariableFVReal\n  []\n[]\n\n[AuxKernels]\n  [to_k]\n    type = MaterialRealAux\n    property = k\n    variable = k\n  []\n[]\n\n[Materials]\n  [thermal_conductivity]\n    type = DerivativeParsedMaterial\n    function ='if(temperature<=1268,0.015 ,if(1268<temperature & temperature<=1923, 0.012, 0.024))'\n    args = 'temperature'\n    f_name = k\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nAlso please create your own post, dont hijack someone else's",
                          "url": "https://github.com/idaholab/moose/discussions/18247#discussioncomment-1725665",
                          "updatedAt": "2022-07-19T18:15:59Z",
                          "publishedAt": "2021-12-01T01:28:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Which kernel can model U_xy term",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nGiven the following differential equation, which kernel should I use to model the second and the third terms?\n\nOr, I would need to implement a custom one?",
          "url": "https://github.com/idaholab/moose/discussions/19475",
          "updatedAt": "2022-07-12T12:49:37Z",
          "publishedAt": "2021-11-24T18:40:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont know of one but libmesh can compute hessians so it should be possible. @lindsayad do we have this in MOOSE? I had no luck looking in the variable code.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1697841",
                  "updatedAt": "2022-07-12T12:49:37Z",
                  "publishedAt": "2021-11-25T04:32:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "It's possible that somewhere in the MOOSE app eco-system someone has this, but I don't believe we have this in the MOOSE repository itself. So you will likely need to implement a custom one. Is u your nonlinear variable for the equation you posted? If so you can couple in second derivatives of variables. You can look here for an example of using the coupledSecond API. The automatic differentiation (AD) version is adCoupledSecond. I believe the tensor that is returned to you will be upper triangular with the knowledge that partial derivatives commute. So you should always index u_ij with j >= i, I believe. If you don't, you'll probably always get zeroes returned. @roystgnr could potentially weigh in on this last bit",
                  "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1718383",
                  "updatedAt": "2022-07-12T12:50:19Z",
                  "publishedAt": "2021-11-29T20:47:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@jwpeterson would also know about the libMesh hessians and if my reading of the code is right and it's upper triangular, then our current SUPG stabilization for INS is not quite right, e.g. this code should not be as simple as it is now\nRealVectorValue\nINSBase::strongViscousTermTraction()\n{\n  return strongViscousTermLaplace() -\n         _mu[_qp] *\n             (_second_u_vel[_qp].row(0) + _second_v_vel[_qp].row(1) + _second_w_vel[_qp].row(2));\n}",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1718435",
                          "updatedAt": "2022-07-12T12:50:22Z",
                          "publishedAt": "2021-11-29T20:56:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "You should always see u_ij == u_ji; internally we loop over only one triangle's entries when computing basis second derivatives, but we copy the off-diagonal entries into the other triangle too.\nIn hindsight I should have created a SymmetricTensor class, though.  You can write simple kernels thanks to the full tensor being complete, but generally as soon as that's done you want to rewrite them to also only loop over one triangle's entries to again save a few flops.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1718535",
                          "updatedAt": "2022-07-12T12:50:19Z",
                          "publishedAt": "2021-11-29T21:12:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jwpeterson"
                          },
                          "bodyText": "@lindsayad The code you have above looks correct to me. In Cartesian coords and using index notation, the term in question is:\nu_i,jj + u_j,ij\n\nwith summation over the dummy index j, and where the comma represents differentiation. The strongViscousTermLaplace() call gives you the first term, and I checked that the various row calls you make give you the the second term. In cylindrical coords the second derivatives are a bit messier... not sure if we claim to support that.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1718716",
                          "updatedAt": "2022-07-12T12:50:38Z",
                          "publishedAt": "2021-11-29T21:50:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Oh what a dope. I only looking at the comment in the h1 transformation code. Right there in the equalities ... both xy and yx\n              // phi_{x y}\n              d2phi[i][p].slice(0).slice(1) = d2phi[i][p].slice(1).slice(0) = d2phidxdy[i][p] =",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1719270",
                          "updatedAt": "2022-09-15T18:21:43Z",
                          "publishedAt": "2021-11-30T00:58:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "d I checked that the various ro\n\nYesm\n\nIt's possible that somewhere in the MOOSE app eco-system someone has this, but I don't believe we have this in the MOOSE repository itself. So you will likely need to implement a custom one. Is u your nonlinear variable for the equation you posted? If so you can couple in second derivatives of variables. You can look here for an example of using the coupledSecond API. The automatic differentiation (AD) version is adCoupledSecond. I believe the tensor that is returned to you will be upper triangular with the knowledge that partial derivatives commute. So you should always index u_ij with j >= i, I believe. If you don't, you'll probably always get zeroes returned. @roystgnr could potentially weigh in on this last bit\n\nYes, U and W are my nonlinear variables that are coupled and live on the same mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1723925",
                          "updatedAt": "2022-09-15T18:21:46Z",
                          "publishedAt": "2021-11-30T18:15:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jwpeterson"
                  },
                  "bodyText": "@aaelmeli This is a strong form PDE, once you multiply by a test function and apply the divergence theorem, you won't need to use second derivatives, right? Unless I guess you are planning to do some sort of stabilization scheme that requires the strong form...",
                  "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1718753",
                  "updatedAt": "2022-07-12T12:50:51Z",
                  "publishedAt": "2021-11-29T21:58:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Yes, this is the strong form PDE. As you said, I won't need to use the second derivative after forming the weak form, however, I am not aware of a kernel in moose that can model the second term.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1723920",
                          "updatedAt": "2022-07-12T12:50:51Z",
                          "publishedAt": "2021-11-30T18:15:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "aware of a kernel in moose that can model the second term.\n\nYea I don't think we have anything for you. How does this equation generalize to 3D? I'm curious whether there is a nice way to write this with divergence and gradient operators.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1724135",
                          "updatedAt": "2022-07-12T12:50:47Z",
                          "publishedAt": "2021-11-30T18:56:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "In 3D, after some manipulation to the coefficient, this can be written as\n\nYes, that is what I am trying. I am trying to use stress divergence to model this PDE.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1724331",
                          "updatedAt": "2022-07-12T12:50:46Z",
                          "publishedAt": "2021-11-30T19:37:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jwpeterson"
                          },
                          "bodyText": "Your 3D PDE is in the usual divergence form\ndiv \\sigma(u) = b\n\nwhere \\sigma is a stress tensor, so the weak form is also standard,\n-\\int \\sigma(u) : grad test = \\int b . test + boundary terms\n\nNot sure if you need to introduce the auxiliary variables \"theta\" and \"e\", but it should be possible to do in MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1724377",
                          "updatedAt": "2022-07-12T12:50:52Z",
                          "publishedAt": "2021-11-30T19:44:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}