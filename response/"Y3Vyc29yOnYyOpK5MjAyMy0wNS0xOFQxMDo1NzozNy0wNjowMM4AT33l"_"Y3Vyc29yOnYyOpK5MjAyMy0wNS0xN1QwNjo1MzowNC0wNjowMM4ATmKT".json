{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNS0xN1QwNjo1MzowNC0wNjowMM4ATmKT"
    },
    "edges": [
      {
        "node": {
          "title": "Slow convergence of plasticity model",
          "author": {
            "login": "tairoon1"
          },
          "bodyText": "Hi everyone,\nI have been trying to use tensor mechanics to simulate a plasticity example, but somehow experience extremely slow convergence using Newton solver. I tried to make a minimal example, can someone please take a look at my input file, here?\nI have two materials, the matrix has a von Mises isotropic hardening model, the fiber is linear elastic. I want to use small strain formulation. The loading is applied uniaxially until time=0.5 and then unloading until time=1. During plastic deformation, it would sometimes take over 100 nonlinear iterations for Newton to converge and there is definitely no quadratic convergence. Is that normal behavior?\nThanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/16905",
          "updatedAt": "2023-05-18T06:08:38Z",
          "publishedAt": "2021-02-05T15:26:37Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI had a quick look at your input. The non linear relative error convergence criterion seems really small.\nCan you please have a look at https://mooseframework.inl.gov/modules/tensor_mechanics/Convergence.html to see if it needs to be adjusted.\nHave not worked on plasticity for a while now, do you expect the small strain formulation to be valid for a 30% displacement? (mesh is 1 by 1 and right_displacement_x goes to 0.3).\nI don't know how much the non linear iteration count may be reduced, it depends on your problem's non-linearity. To mitigate this cost, you could try adaptive time stepping to reduce the number of time steps, consequently reducing the number of non-linear solves. And you could add pre-conditionning to make your linear solves inverting the Jacobian faster.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-356890",
                  "updatedAt": "2022-06-20T08:43:05Z",
                  "publishedAt": "2021-02-10T15:08:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "Hi, thanks for your response. Actually, I am using the absolute error convergence criterion to converge (10^-10) which should be fine, I believe.\nThe result is definitely unphysical and wrong, but this was also meant more as an academic example. The same happens when I would take only 3% strain with a yield stress of 1/10.\nWell, the thing is, even if I set the fiber to the same material as the matrix, i.e. the material is homogeneous, the slow convergence still appears, so the problem should not be very nonlinear... Another thing that I noticed is, the more plastic strain there is, the more nonlinear iterations are needed for a timestep to converge. An example of the convergence behavior is below. Can you please take a more thorough look? I do not really understand what is happening.\nTime Step 36, time = 0.36, dt = 0.01\n0 Nonlinear |R| = 3.286335e-02\n1 Nonlinear |R| = 9.414443e-04\n2 Nonlinear |R| = 4.019062e-04\n3 Nonlinear |R| = 2.413215e-04\n4 Nonlinear |R| = 1.647919e-04\n5 Nonlinear |R| = 1.191983e-04\n6 Nonlinear |R| = 8.981290e-05\n7 Nonlinear |R| = 6.902610e-05\n8 Nonlinear |R| = 5.399464e-05\n9 Nonlinear |R| = 4.289745e-05\n10 Nonlinear |R| = 3.447887e-05\n11 Nonlinear |R| = 2.795538e-05\n12 Nonlinear |R| = 2.282174e-05\n13 Nonlinear |R| = 1.873410e-05\n14 Nonlinear |R| = 1.545260e-05\n15 Nonlinear |R| = 1.279490e-05\n16 Nonlinear |R| = 1.062149e-05\n17 Nonlinear |R| = 8.845436e-06\n18 Nonlinear |R| = 7.387003e-06\n19 Nonlinear |R| = 6.184153e-06\n20 Nonlinear |R| = 5.188392e-06\n21 Nonlinear |R| = 4.361392e-06\n22 Nonlinear |R| = 3.672593e-06\n23 Nonlinear |R| = 3.097446e-06\n24 Nonlinear |R| = 2.616114e-06\n25 Nonlinear |R| = 2.212475e-06\n26 Nonlinear |R| = 1.873369e-06\n27 Nonlinear |R| = 1.588007e-06\n28 Nonlinear |R| = 1.347508e-06\n29 Nonlinear |R| = 1.144539e-06\n30 Nonlinear |R| = 9.730259e-07\n31 Nonlinear |R| = 8.279240e-07\n32 Nonlinear |R| = 7.050327e-07\n33 Nonlinear |R| = 6.008464e-07\n34 Nonlinear |R| = 5.124338e-07\n35 Nonlinear |R| = 4.373398e-07\n36 Nonlinear |R| = 3.735039e-07\n37 Nonlinear |R| = 3.191944e-07\n38 Nonlinear |R| = 2.729543e-07\n39 Nonlinear |R| = 2.335556e-07\n40 Nonlinear |R| = 1.999625e-07\n41 Nonlinear |R| = 1.713000e-07\n42 Nonlinear |R| = 1.468283e-07\n43 Nonlinear |R| = 1.259216e-07\n44 Nonlinear |R| = 1.080495e-07\n45 Nonlinear |R| = 9.276236e-08\n46 Nonlinear |R| = 7.967877e-08\n47 Nonlinear |R| = 6.847478e-08\n48 Nonlinear |R| = 5.887508e-08\n49 Nonlinear |R| = 5.064552e-08\n50 Nonlinear |R| = 4.358684e-08\n51 Nonlinear |R| = 3.752934e-08\n52 Nonlinear |R| = 3.232840e-08\n53 Nonlinear |R| = 2.786069e-08\n54 Nonlinear |R| = 2.402099e-08\n55 Nonlinear |R| = 2.071945e-08\n56 Nonlinear |R| = 1.787932e-08\n57 Nonlinear |R| = 1.543500e-08\n58 Nonlinear |R| = 1.333037e-08\n59 Nonlinear |R| = 1.151743e-08\n60 Nonlinear |R| = 9.955062e-09\n61 Nonlinear |R| = 8.608056e-09\n62 Nonlinear |R| = 7.446233e-09\n63 Nonlinear |R| = 6.443716e-09\n64 Nonlinear |R| = 5.578305e-09\n65 Nonlinear |R| = 4.830943e-09\n66 Nonlinear |R| = 4.185269e-09\n67 Nonlinear |R| = 3.627225e-09\n68 Nonlinear |R| = 3.144729e-09\n69 Nonlinear |R| = 2.727393e-09\n70 Nonlinear |R| = 2.366277e-09\n71 Nonlinear |R| = 2.053691e-09\n72 Nonlinear |R| = 1.783012e-09\n73 Nonlinear |R| = 1.548535e-09\n74 Nonlinear |R| = 1.345344e-09\n75 Nonlinear |R| = 1.169201e-09\n76 Nonlinear |R| = 1.016452e-09\n77 Nonlinear |R| = 8.839422e-10\n78 Nonlinear |R| = 7.689509e-10\n79 Nonlinear |R| = 6.691275e-10\n80 Nonlinear |R| = 5.824420e-10\n81 Nonlinear |R| = 5.071402e-10\n82 Nonlinear |R| = 4.417056e-10\n83 Nonlinear |R| = 3.848266e-10\n84 Nonlinear |R| = 3.353688e-10\n85 Nonlinear |R| = 2.923503e-10\n86 Nonlinear |R| = 2.549210e-10\n87 Nonlinear |R| = 2.223447e-10\n88 Nonlinear |R| = 1.939836e-10\n89 Nonlinear |R| = 1.692849e-10\n90 Nonlinear |R| = 1.477694e-10\n91 Nonlinear |R| = 1.290213e-10\n92 Nonlinear |R| = 1.126800e-10\n93 Nonlinear |R| = 9.843259e-11\nSolve Converged!",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-356973",
                          "updatedAt": "2022-06-20T08:43:05Z",
                          "publishedAt": "2021-02-10T15:32:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Plastic strain is non linear so it causing an increase in non-linear iterations is not surprising.\nYou seem to be obtaining a linear convergence (roughly 10x reduction every 15 iterations). I would examine the Jacobian to see if it's exact on a smaller problem. That would reduce your convergence rate from quadratic to linear.\nYou can use the command line options -snes_test_jacobian -snes_test_jacobian_view but the problem should be really small so the output is understandable.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-357105",
                          "updatedAt": "2022-06-20T08:43:11Z",
                          "publishedAt": "2021-02-10T16:08:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "srinath-chakravarthy"
                          },
                          "bodyText": "I am getting non-linear convergence within 2 non-linear iterations with your input file, but using the Tensor-mechanics master action instead of the full input file you have. It is recommended to use the MasterAction in most cases i think. Here is the input file\n[Mesh]\nfile = mat_fiber.msh\nuse_displaced_mesh = false\n[]\n[GlobalParams]\ndisplacements = 'disp_x disp_y'\n[]\n[Variables]\n[./disp_x]\n[../]\n[./disp_y]\n[../]\n[]\n[Functions]\n[./Exx]\ntype = PiecewiseLinear\nx = '0. 0.5 1 '\ny = '0 0.3 0'\n[../]\n[./right_displacement_x]\ntype = ParsedFunction\nvalue = Exx\nvars = 'Exx'\nvals = 'Exx'\n[../]\n[]\n[BCs]\n[./left_x]\ntype = DirichletBC\nvariable = 'disp_x'\nboundary = left\nvalue = 0\n[../]\n[./left_y]\ntype = DirichletBC\nvariable = 'disp_y'\nboundary = left\nvalue = 0\n[../]\n[./right_x]\ntype = FunctionDirichletBC\nvariable = 'disp_x'\nboundary = right\nfunction = right_displacement_x\npreset   = false\n[../]\n[./right_y]\ntype = DirichletBC\nvariable = 'disp_y'\nboundary = right\nvalue = 0\n[../]\n[]\n[Modules/TensorMechanics/Master]\n[./all]\nadd_variables = true\nstrain = SMALL\nincremental = true\n# volumetric_locking_correction = true\ngenerate_output = 'stress_xx stress_yy strain_xx strain_yy vonmises_stress hydrostatic_stress'\n[../]\n[]\n[Materials]\n[./elasticity_tensor_matrix]\ntype = ComputeIsotropicElasticityTensor\nblock = 'matrix'\nyoungs_modulus = 1.0\npoissons_ratio = 0.3\n[../]\n[./stress_matrix]\ntype = ComputeMultipleInelasticStress\ninelastic_models = 'isoplas'\nblock = 'matrix'\n[../]\n[./isoplas]\ntype = IsotropicPlasticityStressUpdate\nyield_stress = 0.18\nhardening_constant = 0.1\nblock = 'matrix'\n[../]\n[./elasticity_tensor_fiber]\ntype = ComputeIsotropicElasticityTensor\nblock = 'fiber'\nyoungs_modulus = 1.0\npoissons_ratio = 0.1\n[../]\n[./stress_fiber]\ntype = ComputeFiniteStrainElasticStress\nblock = 'fiber'\n[../]\n[]\n[Executioner]\ntype = Transient\nsolve_type = NEWTON\npetsc_options_iname = '-pc_type'\npetsc_options_value = 'lu'\nstart_time = 0.0\ndtmin = 0.0001\nend_time = 1.0\nnl_abs_tol = 1e-10\nnl_rel_tol = 1e-20\nnl_max_its = 200\ndt = 0.01\n[]\n[Outputs]\nexecute_on = 'INITIAL TIMESTEP_END'\nexodus = true\nprint_linear_residuals = false\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-357166",
                          "updatedAt": "2022-06-20T08:43:11Z",
                          "publishedAt": "2021-02-10T16:31:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "@srinath-chakravarthy Thanks for your response. I tried your input file, but I observe the same convergence behavior as with my own file. The first 17 timesteps are fine since there is no plastic deformation yet. The plastic deformation starts at timestep 18.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-357885",
                          "updatedAt": "2022-07-12T15:03:22Z",
                          "publishedAt": "2021-02-10T20:56:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "@GiudGiud Thanks for the hint. I tried it with the command.\nFor elastic deformation, it is perfectly consistent with finite differences:\n---------- Testing Jacobian -------------\n||J - Jfd||_F/||J||_F = 1.6109e-16, ||J - Jfd||_F = 1.95199e-15\nHowever, when plastic deformation starts:\n---------- Testing Jacobian -------------\n||J - Jfd||_F/||J||_F = 0.039895, ||J - Jfd||_F = 0.483421.\nSo it looks like the jacobian is wrong... But I am directly using the code from TensorMechanics Module. Does that mean that the implementation of MOOSE is incorrect?",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-357906",
                          "updatedAt": "2022-07-12T15:03:22Z",
                          "publishedAt": "2021-02-10T21:04:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Try this input instead:\n[Mesh]\n  file = mat_fiber.msh\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n[]\n\n[Functions]\n  [Exx]\n    type = PiecewiseLinear\n    x = '0. 0.5 1 '\n    y = '0 0.3 0'\n  []\n  [right_displacement_x]\n    type = ParsedFunction\n    value = Exx\n    vars = 'Exx'\n    vals = 'Exx'\n  []\n[]\n\n[BCs]\n  [left_x]\n    type = DirichletBC\n    variable = 'disp_x'\n    boundary = left\n    value = 0\n  []\n  [left_y]\n    type = DirichletBC\n    variable = 'disp_y'\n    boundary = left\n    value = 0\n  []\n  [right_x]\n    type = FunctionDirichletBC\n    variable = 'disp_x'\n    boundary = right\n    function = right_displacement_x\n    preset = false\n  []\n  [right_y]\n    type = DirichletBC\n    variable = 'disp_y'\n    boundary = right\n    value = 0\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = SMALL\n    incremental = true\n    # volumetric_locking_correction = true\n    generate_output = 'stress_xx stress_yy strain_xx strain_yy vonmises_stress hydrostatic_stress'\n  []\n[]\n\n[Materials]\n  [elasticity_tensor_matrix]\n    type = ComputeIsotropicElasticityTensor\n    block = 'matrix'\n    youngs_modulus = 1.0\n    poissons_ratio = 0.3\n  []\n  [stress_matrix]\n    type = ComputeMultipleInelasticStress\n    inelastic_models = 'isoplas'\n    block = 'matrix'\n  []\n  [isoplas]\n    type = IsotropicPlasticityStressUpdate\n    yield_stress = 0.18\n    hardening_constant = 0.1\n    block = 'matrix'\n  []\n\n  [elasticity_tensor_fiber]\n    type = ComputeIsotropicElasticityTensor\n    block = 'fiber'\n    youngs_modulus = 1.0\n    poissons_ratio = 0.1\n  []\n  [stress_fiber]\n    type = ComputeFiniteStrainElasticStress\n    block = 'fiber'\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu superlu_dist'\n\n  start_time = 0.0\n  dtmin = 0.0001\n\n  end_time = 1.0\n  nl_abs_tol = 1e-10\n  nl_rel_tol = 1e-20\n  nl_max_its = 200\n  dt = 0.01\n[]\n\n[Outputs]\n  execute_on = 'INITIAL TIMESTEP_END'\n  exodus = true\n  print_linear_residuals = false\n[]\n\nThe finite deformation jacobian in tensor_mechanics isn't perfect (as of now, it will improve by a lot soon!). Using PJFNK for non-AD or using Newton for AD should improve the convergence.\nSome other options you could play with are the tangent_operator option in ComputeMultiInelasticStress and use_finite_deform_jacobian in the action.",
                  "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-357947",
                  "updatedAt": "2022-06-20T08:43:11Z",
                  "publishedAt": "2021-02-10T21:21:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "srinath-chakravarthy"
                          },
                          "bodyText": "Also,\nOne more thing, you are applying a displacement bc and so the amount of plastic strain per increment is increasing, which is why you are seeing an increase in the no. of iterations per increment. Try to get non constant time steps and also try to see if you can apply a velocity bc. I have had a considerable amount of success by choosing an analytical vel. bc in lieu of displacment bc.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-358322",
                          "updatedAt": "2022-06-20T08:44:00Z",
                          "publishedAt": "2021-02-11T00:07:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "Thanks @hugary1995. So the jacobian in tensor_mechanics is currently not computed correctly. Are you currently working on a correct and consistent jacobian implementation? Can I ask, when soon is going to be? Using PJFNK seems to work around it quite well, however each linear iteration seems to be much slower than Newton.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-359302",
                          "updatedAt": "2022-06-20T08:43:56Z",
                          "publishedAt": "2021-02-11T11:53:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "@srinath-chakravarthy I am sorry, I do not really understand what you mean. I am working with quasistatic conditions, so there should not be any velocity.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-359303",
                          "updatedAt": "2022-06-20T08:43:56Z",
                          "publishedAt": "2021-02-11T11:55:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'm not - but that's in our radar for a while. @bwspenc can probably comment on this.\nPJFNK uses our inaccurate hand-coded jacobian for preconditioning, so linear convergence might be slow, but each iteration is also supposed to be much cheaper. See https://mooseframework.inl.gov/source/systems/NonlinearSystem.html  for more details.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-359490",
                          "updatedAt": "2022-06-20T08:44:20Z",
                          "publishedAt": "2021-02-11T13:18:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "Okay, thank you so much for clarifying!",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-369928",
                          "updatedAt": "2022-06-20T08:44:20Z",
                          "publishedAt": "2021-02-15T09:44:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "@hugary1995 @bwspenc\nHi Gary ,\nDoes the problem in calculation of Jacobian in tensor_mechanics still persists ? Or has it been already fixed ? Do you have any info on that ?\nThank you very much for your time.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-5773346",
                          "updatedAt": "2023-05-01T16:45:01Z",
                          "publishedAt": "2023-05-01T16:45:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "There is a new system (we refer to it as \"lagrangian mechanics kernels/materials\" at several places). As far as I know, the current state of Jacobian accuracy is:\n\nsome non-AD simple plasticity models in the old system now have correct Jacobians;\nmost non-AD creep models in the old system have correct Jacobians;\nall AD inelastic models in the old system have correct Jacobians;\nall inelastic models in the new system have correct Jacobians, though we only added a few inelastic models so far -- migration in progress.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-5774720",
                          "updatedAt": "2023-05-01T19:53:48Z",
                          "publishedAt": "2023-05-01T19:53:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ttw0626"
                          },
                          "bodyText": "sorry this borthing, I wanna ask how to imporve the convergenced speed of non-AD inelastic model (Lagragian) which I did not use build-in return-mapping ? it will take too much time (around 2 h in 3D tensile coarse mesh) compared with commercial one (5-10mins). maybe my jacobian has problem, but it will get good convergency in 2D problem.\nBest regards,\nTAN",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-5934601",
                          "updatedAt": "2023-05-18T03:54:36Z",
                          "publishedAt": "2023-05-18T03:54:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou can check your Jacobian using these tools:\nhttps://mooseframework.inl.gov/help/development/analyze_jacobian.html\nIf your Jacobian has issues you ll see a higher number of nonlinear iterations.\nIf it's not that, you will want to work on the preconditioning to improve performance in most cases.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-5934849",
                          "updatedAt": "2023-05-18T04:06:06Z",
                          "publishedAt": "2023-05-18T04:06:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ttw0626"
                          },
                          "bodyText": "Thanks for reply, Guillaume.\n\n\n\nI am going to try.\n\n\n\nActually, I wonder what's the reason why my material jacobian [modification based on ComputeLagrangianPK2Stress()] will failure in moose but is fine in abaqus umat when the problem become a little bit complicated?\nI understood the difference of the material jacobian between TM new system and abaqus umat, however, the basic StressUpdate algorithm should be same I think.\n\n\n\nThis is first implementation in moose about inelastic material, if I wanna insert more nonlinear on this framework in the future, the converged problem is super-important for me, could you give me some advice or recommendations about this ?\nBest regards.\nTAN",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-5935736",
                          "updatedAt": "2023-05-18T06:08:38Z",
                          "publishedAt": "2023-05-18T06:08:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Potential issue with mesh adaptivity and ExtraNodesetGenerator",
          "author": {
            "login": "starkekr"
          },
          "bodyText": "I am having convergence issues with a simple deformation input file (attached).\nm_file_error.txt\nIn this simulation I have a precipitate which I am translating to one of the corner nodes in the simulation domain (using a time dependent aux variable). The displacement of the  corner nodes are fixed to prevent rigid body translations. After 40 timesteps, the precipitate reaches the corner node and then the simulation stops converging. I am thinking that this is because of mesh adaptivity relabeling the corner node? I also get the same problem with allow_renumbering = false so maybe its something else.\nSo I am wondering what the default behavior is when an element is refined and that element contains part of a nodeset? Any comments or thought is greatly appreciated :)",
          "url": "https://github.com/idaholab/moose/discussions/24369",
          "updatedAt": "2023-05-17T23:36:41Z",
          "publishedAt": "2023-05-15T21:15:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "sideset information is associated with the level 0 elements. With respect to nodesets, when new nodes are added along a boundary during mesh refinement, I don't actually know whether they get incorporated into existing nodesets (@roystgnr ?). I would guess not as how could we know the conditions under which a node should be considered as part of a nodeset? If you build a nodeset from a sideset post-adaptivity, then that would be clear. Anyway, I don't think that particular information is relevant to you in this case.\nWhat is relevant: if you were relying on applying a specific condition to a specific DofObject ID (e.g. element or node ID), then you would indeed be in trouble if renumbering was enabled during adaptivity, but it looks like you are using the nodeset throughout the input file. That should be fine and robust irrespective of whether you allow renumbering or not.",
                  "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5909946",
                  "updatedAt": "2023-05-15T22:02:38Z",
                  "publishedAt": "2023-05-15T21:59:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "They don't get incorporated by libMesh.  Nodesets were originally meant to be for things like point sources, pins in elastoplasticity, etc.  \"Create a new nodeset for every sideset\" was a MOOSE innovation ... so maybe MOOSE updates them after AMR, too?  I'd kinda expect it to be a bug if not, based on how MOOSE codes rely on that.",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5909960",
                          "updatedAt": "2023-05-15T22:02:23Z",
                          "publishedAt": "2023-05-15T22:02:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Wow you responded before I could even update my post \ud83d\ude04",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5909965",
                          "updatedAt": "2023-05-15T22:03:09Z",
                          "publishedAt": "2023-05-15T22:03:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Yes we do indeed rely on build_node_list_from_side_list post mesh refinement (otherwise our Dirichlet BC classes would not work)",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5909984",
                          "updatedAt": "2023-05-15T22:07:18Z",
                          "publishedAt": "2023-05-15T22:07:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "I just realized that I didn't get rid of all of my personal code. The problem still persists if I run this new input file\nm_file_error.txt",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5910589",
                          "updatedAt": "2023-05-16T01:17:23Z",
                          "publishedAt": "2023-05-16T00:39:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "What does poor convergence mean? Poor linear convergence? Poor nonlinear convergence?",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5911617",
                          "updatedAt": "2023-05-16T03:38:43Z",
                          "publishedAt": "2023-05-16T03:38:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "Poor nonlinear convergence. Here is a screenshot of the residuals\n\nI also just noticed that the displacement field shows problems even earlier than timstep 42. If you compare the x component of the displacement field as shown here in timestep 20\n\nto the next timestep 21\n\nyou can see that there are some issues. Both plots are scaled to the same magnitude. I would expect the displacement field to continue to look more or less like the one in timestep 20 but something weird happens as the precipitate approaches the boundary",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5915726",
                          "updatedAt": "2023-05-16T12:04:06Z",
                          "publishedAt": "2023-05-16T12:04:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Yea I don't know this physics very well. I'm going to ask some of our community members to chime in here",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5918772",
                          "updatedAt": "2023-05-16T16:45:04Z",
                          "publishedAt": "2023-05-16T16:45:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "will you paste your input file into a comment",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5918808",
                          "updatedAt": "2023-05-16T16:49:03Z",
                          "publishedAt": "2023-05-16T16:49:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Very likely just bad Jacobian... Are you using AD?",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5919352",
                          "updatedAt": "2023-05-16T17:45:53Z",
                          "publishedAt": "2023-05-16T17:45:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "[GlobalParams]\ndisplacements = 'disp_x disp_y'\n[]\n[Mesh]\n[msh]\ntype = GeneratedMeshGenerator\ndim  = 2\nnx   = 16\nny   = 16\nnz   = 0\nxmin = 0\nxmax = 4.0\nymin = 0\nymax = 4.0\nzmin = 0\nzmax = 0.0\n[]\n[ns]\ntype         = ExtraNodesetGenerator\ninput        = msh\nnew_boundary = ns1\ncoord        = '0 0 0'\n#nodes        = 1\n[]\nuniform_refine    = 3\n[]\n[Variables]\n[disp_x]\nfamily = LAGRANGE\norder  = FIRST\n[]\n[disp_y]\nfamily = LAGRANGE\norder  = FIRST\n[]\n[]\n[AuxVariables]\n[eta0]\nfamily = LAGRANGE\norder  = FIRST\n[]\n[eta1]\nfamily = LAGRANGE\norder  = FIRST\n[]\n[bnds]\nfamily = LAGRANGE\norder  = FIRST\n[]\n[]\n[Kernels]\n[stress_x]\ntype              = StressDivergenceTensors\nvariable          = disp_x\ncomponent         = 0\neigenstrain_names = eigenstrain\n[]\n[stress_y]\ntype              = StressDivergenceTensors\nvariable          = disp_y\ncomponent         = 1\neigenstrain_names = eigenstrain\n[]\n[]\n[AuxKernels]\n[eta0]\ntype = FunctionAux\nvariable = eta0\nfunction = '1.0/(1+exp(-(sqrt((x-(1-t))^2+(y-(1-t))^2)-0.5^2)/0.03))\n+1.0/(1+exp(-(sqrt((x-(5-t))^2+(y-(5-t))^2)-0.5^2)/0.03))\n+1.0/(1+exp(-(sqrt((x-(1-t))^2+(y-(5-t))^2)-0.5^2)/0.03))\n+1.0/(1+exp(-(sqrt((x-(5-t))^2+(y-(1-t))^2)-0.5^2)/0.03))\n-3'\nexecute_on = 'initial timestep_begin'\n[]\n[eta1]\ntype = ParsedAux\nvariable = eta1\nargs = eta0\nfunction = '1-eta0'\nexecute_on = 'initial timestep_begin'\n[]\n[bnds]\ntype = ParsedAux\nvariable = bnds\nargs = 'eta0 eta1'\nfunction = 'eta0*(1-eta0)'\nexecute_on = 'initial timestep_begin'\n[]\n[]\n[Materials]\n[./elasticity_tensor_A]\ntype = ComputeElasticityTensor\nbase_name = A\nfill_method = symmetric9\nC_ijkl = '1e1 1e0 1e0 1e1 0 1e1 .4e1 .2e1 .5e1'\n[../]\n[./strain_A]\ntype = ComputeSmallStrain\nbase_name = A\neigenstrain_names = eigenstrain\n[../]\n[./stress_A]\ntype = ComputeLinearElasticStress\nbase_name = A\n[../]\n[./eigenstrain_A]\ntype = ComputeEigenstrain\nbase_name = A\neigen_base = '0.1 0.05 0 0 0 0.01'\nprefactor = -1\neigenstrain_name = eigenstrain\n[../]\n[./elasticity_tensor_B]\ntype = ComputeElasticityTensor\nbase_name = B\nfill_method = symmetric9\nC_ijkl = '1e1 0 0 1e1 0 1e1 .5e1 .5e1 .5e1'\n[../]\n[./strain_B]\ntype = ComputeSmallStrain\nbase_name = B\neigenstrain_names = 'B_eigenstrain'\n[../]\n[./stress_B]\ntype = ComputeLinearElasticStress\nbase_name = B\n[../]\n[./eigenstrain_B]\ntype = ComputeEigenstrain\nbase_name = B\neigen_base = '0.1 0.05 0 0 0 0.01'\nprefactor = -1\neigenstrain_name = 'B_eigenstrain'\n[../]\n[./switching]\ntype = SwitchingFunctionMaterial\neta = eta0\n[../]\n[./combined]\ntype = TwoPhaseStressMaterial\nbase_A = A\nbase_B = B\n[../]\n[]\n[BCs]\n[fixed_x]\ntype     = DirichletBC\nvariable = disp_x\nboundary = ns1\nvalue    = 0\n[]\n[fixed_y]\ntype     = DirichletBC\nvariable = disp_y\nboundary = ns1\nvalue    = 0\n[]\n[Periodic]\n[all]\nvariable       = 'disp_x disp_y'\nauto_direction = 'x y'\n[]\n[]\n[]\n[Adaptivity]\nmarker      = combo\nmax_h_level = 4\n[Markers]\n[combo]\ntype    = ComboMarker\nmarkers = interface\n[]\n[interface]\ntype     = ValueThresholdMarker\nvariable = bnds\nrefine   = 0.05\ncoarsen  = 0.05\n[]\n[]\n[]\n[Executioner]\ntype                = Transient\nscheme              = bdf2\nsolve_type          = NEWTON\npetsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\npetsc_options_value = 'hypre boomeramg 101'\nl_max_its           = 100\nl_tol               = 0.0001\nnl_max_its          = 40\nnl_rel_tol          = 1e-05\nnl_abs_tol          = 1e-07\ndt                  = 0.01\nstart_time          = 0.0\nnum_steps           = 100\n[]\n[Outputs]\nexodus                 = true\nexecute_on             = 'initial timestep_end'\nprint_linear_residuals = false\ncheckpoint             = true\ninterval               = 1\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5919445",
                          "updatedAt": "2023-05-16T17:57:09Z",
                          "publishedAt": "2023-05-16T17:57:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "starkekr"
                  },
                  "bodyText": "Ahh, yes you are absolutely right, my mistake. With my executioner block set as:\n[Executioner]\n  type                = Transient\n  scheme              = bdf2\n  solve_type          = NEWTON\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu '\n  automatic_scaling   = true\n  l_tol               = 1e-12\n  nl_max_its          = 40\n  nl_rel_tol          = 1e-13\n  nl_abs_tol          = 1e-15\n  start_time          = 0.0\n  dt                  = 0.01\n  num_steps           = 150\n[]\n\nthe AMR solution seems to be consistent with the non adaptive case. Just out of curiosity @hugary1995 what preconditioner would you use?",
                  "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5920382",
                  "updatedAt": "2023-05-17T16:14:59Z",
                  "publishedAt": "2023-05-16T19:55:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The hypre boomeramg preconditioner is supposed to be pretty good at solving mechanics problems. However, the default parameters are far less effective compared to a well-tuned set of parameters. This page has a gentle introduction to some of the common parameters: https://mooseframework.inl.gov/releases/moose/v1.0.0/application_development/hypre.html\nI've found the following parameters effective for many problems I have at hand:\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor'\n  petsc_options_value = 'hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4'\nI am optimistic that the above preconditioner can get your problem to converge. However, it's NOT going to change the solution. The solution doesn't depend on the type of preconditioner you use, except some numerical corner cases...",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5920872",
                          "updatedAt": "2023-05-16T20:59:36Z",
                          "publishedAt": "2023-05-16T20:59:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "I think the problem may be related to pinning the corner node and simultaneously having a misfitting precipitate there - the misfit strain is going to make your displacement want to be non-zero. You are going to have an inconsistency between the physics of the problem and the boundary condition (zero displacement) you are putting on the corner node. Conventional wisdom in the finite element world says you need to pin at least node to prevent finite translations or rotations of the whole mesh, but in previous work on precipitation problems in the MOOSE phase-field module, I have seen that if you use natural (zero-traction) BCs for the mechanical equilibrium equation, you can solve successfully without needing to pin a node. So I would give that a try. If that doesn't work, try pinning a node that is nowhere near a precipitate.",
                  "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5929656",
                  "updatedAt": "2023-05-17T16:15:29Z",
                  "publishedAt": "2023-05-17T16:12:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You are right on the cause of the misfit. Strain periodicity will fix this \"problem\" without relying on a parallel preconditioner to workaround the null space. We have the entire homogenization system and the global strain system designed for this scenario.",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5930780",
                          "updatedAt": "2023-05-17T18:05:22Z",
                          "publishedAt": "2023-05-17T18:05:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "Maybe I'm mistaken but the misfit strain should force the total strain to be nonzero rather than the displacement field. Anyway here is the final input file that seems to be working for those who are interested. It utilizes the global strain system to enforce all the components of the mean stress to 0. @hugary1995  I also tried the preconditioner that you gave and it had trouble converging when the global strain system was added (it worked great without it!) so I reverted back to ilu and it seemed to work for this problem\n[GlobalParams]\n  displacements = 'fluct_x fluct_y'\n[]\n[Mesh]\n  [msh]\n    type = GeneratedMeshGenerator\n    dim  = 2\n    nx   = 16\n    ny   = 16\n    nz   = 0\n    xmin = 0\n    xmax = 4.0\n    ymin = 0\n    ymax = 4.0\n    zmin = 0\n    zmax = 0.0\n  []\n  [ns]\n    type         = ExtraNodesetGenerator\n    input        = msh\n    new_boundary = ns1\n    coord        = '0 0 0'\n    #nodes        = 1\n  []\n  uniform_refine    = 3\n[]\n[UserObjects]\n  [global_strain_uo]\n    type                  = GlobalStrainUserObject\n    applied_stress_tensor = '0 0 0 0 0 0'\n    execute_on            = 'Initial Linear Nonlinear'\n  []\n[]\n[ScalarKernels]\n  [global_strain_kernel]\n    type             = GlobalStrain\n    variable         = global_strain\n    global_strain_uo = global_strain_uo\n  []\n[]\n[Variables]\n  [fluct_x]\n    family = LAGRANGE\n    order  = FIRST\n  []\n  [fluct_y]\n    family = LAGRANGE\n    order  = FIRST\n  []\n  [global_strain]\n    order  = THIRD\n    family = SCALAR\n  []\n[]\n\n[AuxVariables]\n  [disp_x]\n    order   = FIRST\n    family  = LAGRANGE\n    outputs = exodus\n  []\n  [disp_y]\n    order   = FIRST\n    family  = LAGRANGE\n    outputs = exodus\n  []\n  [eta0]\n    family = LAGRANGE\n    order  = FIRST\n  []\n  [eta1]\n    family = LAGRANGE\n    order  = FIRST\n  []\n  [bnds]\n    family = LAGRANGE\n    order  = FIRST\n  []\n[]\n[Kernels]\n  [stress_x]\n    type              = StressDivergenceTensors\n    variable          = fluct_x\n    component         = 0\n    eigenstrain_names = eigenstrain\n  []\n  [stress_y]\n    type              = StressDivergenceTensors\n    variable          = fluct_y\n    component         = 1\n    eigenstrain_names = eigenstrain\n  []\n[]\n[AuxKernels]\n  [disp_x]\n    type                 = GlobalDisplacementAux\n    variable             = disp_x\n    scalar_global_strain = global_strain\n    global_strain_uo     = global_strain_uo\n    component            = 0\n  []\n  [disp_y]\n    type                 = GlobalDisplacementAux\n    variable             = disp_y\n    scalar_global_strain = global_strain\n    global_strain_uo     = global_strain_uo\n    component            = 1\n  []\n    [eta0]\n\t\ttype = FunctionAux\n\t\tvariable = eta0\n\t\tfunction = '1.0/(1+exp(-(sqrt((x-(1-t))^2+(y-(1-t))^2)-0.5^2)/0.03))\n\t\t           +1.0/(1+exp(-(sqrt((x-(5-t))^2+(y-(5-t))^2)-0.5^2)/0.03))\n\t\t           +1.0/(1+exp(-(sqrt((x-(1-t))^2+(y-(5-t))^2)-0.5^2)/0.03))\n\t\t           +1.0/(1+exp(-(sqrt((x-(5-t))^2+(y-(1-t))^2)-0.5^2)/0.03))\n\t\t           -3'\n\t\texecute_on = 'initial timestep_begin'\n\t[]\n\t[eta1]\n\t\ttype = ParsedAux\n\t\tvariable = eta1\n\t\targs = eta0\n\t\tfunction = '1-eta0'\n\t\texecute_on = 'initial timestep_begin'\n\t[]\n  [bnds]\n  \ttype = ParsedAux\n\tvariable = bnds\n\targs = 'eta0 eta1'\n\tfunction = 'eta0*(1-eta0)'\n\texecute_on = 'initial timestep_begin'\n  []\n[]\n[Materials]\n  [heta0]\n    type              = SwitchingFunctionMultiPhaseMaterial\n    h_name            = heta0\n    all_etas          = 'eta0 eta1'\n    phase_etas        = eta0\n    outputs           = exodus\n    output_properties = heta0\n  []\n  [heta1]\n    type              = SwitchingFunctionMultiPhaseMaterial\n    h_name            = heta1\n    all_etas          = 'eta0 eta1'\n    phase_etas        = eta1\n    outputs           = exodus\n    output_properties = heta1\n  []\n  [C_eta0]\n    type            = ComputeElasticityTensor\n    fill_method     = symmetric9\n    C_ijkl          = '1.025 0.288 0.406 1.025 0.404 1.059 0.183 0.183 0.368'\n    base_name       = C_eta0\n    rotation_matrix = '-0.98726 0.15910 0.00000 -0.15910 -0.98726 0.00000 0.00000 0.00000 1.00000'\n  []\n  [e_eta1]\n    type            = RotatedGenericConstantRankTwoTensor\n    tensor_values   = '-0.138 0.0 0.0 0.0 0.493 0.0 0.0 0.0 -0.064'\n    tensor_name     = e_eta1\n    rotation_matrix = '-0.54917 -0.83571 0.00000 0.83571 -0.54917 0.00000 -0.00000 0.00000 1.00000'\n  []\n  [C_eta1]\n    type            = ComputeElasticityTensor\n    fill_method     = symmetric9\n    C_ijkl          = '1.011 0.643 0.680 1.011 0.643 1.036 0.433 0.417 0.417'\n    base_name       = C_eta1\n    rotation_matrix = '-0.54917 -0.83571 0.00000 0.83571 -0.54917 0.00000 -0.00000 0.00000 1.00000'\n  []\n  [elastic_tensor]\n    type    = CompositeElasticityTensor\n    args    = 'eta0 eta1'\n    tensors = 'C_eta0 C_eta1'\n    weights = 'heta0 heta1'\n  []\n  [eigenstrain]\n    type             = CompositeEigenstrain\n    tensors          = 'e_eta1'\n    weights          = 'heta1'\n    args             = 'eta0 eta1'\n    eigenstrain_name = eigenstrain\n  []\n  [strain]\n    type          = ComputeSmallStrain\n    eigenstrain_names = eigenstrain\n    global_strain = global_strain\n  []\n  [stress]\n    type              = ComputeLinearElasticStress\n    outputs           = exodus\n    output_properties = stress\n  []\n  [global_strain_material]\n    type                 = ComputeGlobalStrain\n    scalar_global_strain = global_strain\n    global_strain_uo     = global_strain_uo\n  []\n[]\n[BCs]\n  [fixed_x]\n    type     = DirichletBC\n    variable = fluct_x\n    boundary = ns1\n    value    = 0\n  []\n  [fixed_y]\n    type     = DirichletBC\n    variable = fluct_y\n    boundary = ns1\n    value    = 0\n  []\n  [Periodic]\n    [all]\n      variable       = 'fluct_x fluct_y'\n      auto_direction = 'x y'\n    []\n  []\n[]\n[Adaptivity]\n  marker      = combo\n  max_h_level = 4\n  [Markers]\n    [combo]\n      type    = ComboMarker\n      markers = interface\n    []\n    [interface]\n      type     = ValueThresholdMarker\n      variable = bnds\n      refine   = 0.05\n      coarsen  = 0.05\n    []\n  []\n[]\n[Executioner]\n  type                = Transient\n  scheme              = bdf2\n  solve_type          = NEWTON\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'ilu '\n  automatic_scaling   = true\n  l_tol               = 1e-12\n  nl_max_its          = 40\n  nl_rel_tol          = 1e-13\n  nl_abs_tol          = 1e-15\n  start_time          = 0.0\n  dt                  = 0.01\n  num_steps           = 150\n[]\n[Outputs]\n  exodus                 = true\n  execute_on             = 'initial timestep_end'\n  print_linear_residuals = false\n  checkpoint             = true\n  interval               = 1\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5931776",
                          "updatedAt": "2023-05-17T20:49:42Z",
                          "publishedAt": "2023-05-17T20:31:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Thanks for sharing this. You're right that the misfit strain affects the strain field, but strain is calculated as derivatives of displacements, and displacements are actually what are being solved for- you can't get non-zero strain without spatially varying displacements.",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5932017",
                          "updatedAt": "2023-05-17T21:07:11Z",
                          "publishedAt": "2023-05-17T21:07:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Right, the hypre boomeramg preconditioner doesn't handle saddle point problem well (which you get by using the global strain system). I think a field split approach should work, though I had no luck with it so far. I've heard @ttruster discovered a bug in the FSP and that could fix it potentially.",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5932405",
                          "updatedAt": "2023-05-17T22:20:57Z",
                          "publishedAt": "2023-05-17T22:20:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "There wasn't really a bug. It just wasn't allowed. But yes that is fixed in #24379",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5932794",
                          "updatedAt": "2023-05-17T23:36:41Z",
                          "publishedAt": "2023-05-17T23:36:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Apply a Loading Rate (Force) as a Boundary condition",
          "author": {
            "login": "Vandenbg"
          },
          "bodyText": "I am currently working on a spherical indentation model in MARMOT and until now I have been using displacement control. I would like to compare my results to different applied loads over time,  i.e. 20mn/s or 80mn/s. This should be set up the same as MOOSE. So far I have tried two different methods, Pressure BC and Neumann BC. I have been unsuccessful on both accounts in getting my indenter tip to budge at all.\nThis is what I have been using.\n  [push_down]\n    type = ParsedFunction\n    expression = 'if(t<2, -(t/0.005)*3.2e-6, -0.001280)'\n  []\n  ...\n  [topy]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = '202'\n    function = push_down\n  []\n\nThis is what I tried for Neumann BC. I attempted several functions, each in the same form but changing the 0.020 to higher numbers.\n[topy]\n  type = FunctionNeumannBC\n  variable = disp_y\n  boundary = '202'\n  function = t*0.020\n[]\n\nHere is what I attempted with Pressure BC. Again, I changed the 0.020 value to a range of values with not avail.\n[Pressure]\n  [topy]\n    boundary = '202'\n    function = t*0.020\n    displacements = 'disp_y'\n  []\n[]\n\nPlease let me know If I am doing this correctly, or how I should go about applying a specific loading rate to a boundary. Thank you!",
          "url": "https://github.com/idaholab/moose/discussions/24413",
          "updatedAt": "2023-05-17T22:38:48Z",
          "publishedAt": "2023-05-17T19:36:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "So you are applying both a dirichlet and a load on the same boundary?",
                  "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931560",
                  "updatedAt": "2023-05-17T20:04:19Z",
                  "publishedAt": "2023-05-17T20:04:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Vandenbg"
                          },
                          "bodyText": "Yes, for boundary 202, disp_x and disp_z I am applying dirichlet conditions of 0, and for disp_y I am using what I described above.",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931646",
                          "updatedAt": "2023-05-17T20:14:54Z",
                          "publishedAt": "2023-05-17T20:14:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For disp_y, you have a dirichlet above as well",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931664",
                          "updatedAt": "2023-05-17T20:16:47Z",
                          "publishedAt": "2023-05-17T20:16:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Vandenbg"
                          },
                          "bodyText": "That is correct, it is what I have been using up until this point. The three examples above were all used independently. All three were not used at the same time.",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931672",
                          "updatedAt": "2023-05-17T20:18:40Z",
                          "publishedAt": "2023-05-17T20:18:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "how many time steps did you take? what was the value of 't' in the end",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931905",
                          "updatedAt": "2023-05-17T20:51:01Z",
                          "publishedAt": "2023-05-17T20:51:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Vandenbg"
                          },
                          "bodyText": "In both cases, I let the simulation run with no displacement for roughly 0.5 seconds.",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5932163",
                          "updatedAt": "2023-05-17T21:33:47Z",
                          "publishedAt": "2023-05-17T21:33:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "@recuero and @jiangwen84 do either of you have any insights on modeling nanoindentation with a prescribed load (rather than displacement control)?",
                  "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931566",
                  "updatedAt": "2023-05-17T20:04:51Z",
                  "publishedAt": "2023-05-17T20:04:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "The methodology I'd use would be something like:\n\nMake sure to remove any possible rigid body motion in the indenter\nUse displacement control to move the indenter down (Dirichlet BC)\nEstablish contact to some extent.\nSwitch to load control, i.e. remove the Dirichlet BC and use controls to impose a load/pressure gradually.\nMake sure the transition between displacement control and load control is smooth. You do that by computing a reaction force for the displacement control part and then applying a consistent initial pressure value.",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5932004",
                          "updatedAt": "2023-05-17T21:20:04Z",
                          "publishedAt": "2023-05-17T21:06:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Vandenbg"
                          },
                          "bodyText": "Thank you for this suggestion. I will attempt this method. Have I set up the Pressure boundary condition correctly, would the reaction force value be placed where 0.02 is in the function?\n[Pressure]\n  [topy]\n    boundary = '202'\n    function = t*0.020 #<-- here?\n    displacements = 'disp_y'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5932190",
                          "updatedAt": "2023-05-17T21:38:14Z",
                          "publishedAt": "2023-05-17T21:38:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Yes, but note that you'll have to sum all the reaction forces and then come up with an initial pressure value that'll have a similar overall loading effect. It doesn't have to be exact, but it has to: 1) Keep precluding rigid body motion and 2) Not deviate from equilibrium too much, i.e. the system needs to be able to converge.",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5932501",
                          "updatedAt": "2023-05-17T22:38:49Z",
                          "publishedAt": "2023-05-17T22:38:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stress assisted diffusion coupling for anisotropic system",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE experts,\nI am trying to add the stress assisted coupling for the anisotropic case which includes the following term:\n\nIn the above equation, diffusion (D) and expansion tensor \\beta is 3 by 3 matrix.\nI already did this coupling for the isotropic case; but, struggling to add for the anisotropic system.\nCan you please point me in the right direction?\nThanks,\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/24366",
          "updatedAt": "2023-05-17T19:51:01Z",
          "publishedAt": "2023-05-15T16:16:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Compute stress double contracted with beta.\nCompute its gradient. I see that you are already aware of #22910\nD is also a second order tensor, so the result is the mass flux (a vector).",
                  "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5918178",
                  "updatedAt": "2023-05-16T15:47:42Z",
                  "publishedAt": "2023-05-16T15:47:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thanks @hugary1995\nI already calculated sigma_xx and sigma_yy and sigma_zz using RankTwoCartesianComponent in the material kernel and extracted them as material property using Auxkernel MaterialRealAux.\nI am looking for the module to multiply them with expansion values and then add them to consider it a single variable. Then I can use the MatDiffusion kernel for the coupling.\nMy another query is how to add prefactor in the MatDiffusion which can accommodate diffusivity as matrix.\nCan you please me point me towards the modules which I can use?\nBest,\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5929523",
                          "updatedAt": "2023-05-17T16:01:19Z",
                          "publishedAt": "2023-05-17T16:01:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nDoes the anisotropic diffusion work for you?\nhttps://mooseframework.inl.gov/source/kernels/ADMatAnisoDiffusion.html\nIf not changing the diffusion coefficient in the kernel should not be too difficult\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5929711",
                          "updatedAt": "2023-05-17T16:16:34Z",
                          "publishedAt": "2023-05-17T16:16:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Hello @GiudGiud\nI need to add diffusivity as prefactor because there are other terms which needs to be included.\nFor the isotropic case, I did it something like this:\n[./constants]\n    type = GenericConstantMaterial\n    prop_names  = 'factor                 Omega   \tD\tR\t           T'\n    prop_values = '${pressure_coupling}  ${expansion_coeff}  ${diff}  ${gas_constant}\t${temp}'\n  [../]\n\n  [./stress_coeff]\n    type = ParsedMaterial\n    function = 'factor*(D*Omega*c)/(R*T)'\n    args = 'c'\n    f_name = 'prefactor_pressure_coupling'\n    material_property_names = 'factor D Omega\tR\tT'\n  [../]\n\nand then added it in the kernel as\n [stress_grad]\n   type = MatDiffusion\n   variable = 'c'\n   v = 'pressure'\n   diffusivity = 'prefactor_pressure_coupling'\n []\n\nIs there a way to do same thing when diffusivity is matrix?\nThen I can use MatAnisoDiffusion kernel for the coupling.\nOther than that\nCan you also point me to the module which I can use to find the sum of sigma_xx*beta_xx + sigma_yy*beta_yy + sigma_zz*beta_zz  and then add it as material property for the coupling, the same way I did it for isotropic case?\nBest,\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5929879",
                          "updatedAt": "2023-05-17T16:35:02Z",
                          "publishedAt": "2023-05-17T16:33:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "See the object I pasted for a start on anisotropic diffusion",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5929895",
                          "updatedAt": "2023-05-17T16:35:05Z",
                          "publishedAt": "2023-05-17T16:35:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Though I m sure there's anisotropic stress models in the tensor mechanics module you could look at as well",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5930236",
                          "updatedAt": "2023-05-17T17:07:46Z",
                          "publishedAt": "2023-05-17T17:07:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "This will be quite a stretch without writing some C++.",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5930964",
                          "updatedAt": "2023-05-17T18:33:10Z",
                          "publishedAt": "2023-05-17T18:33:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "@hugary1995  Ok. Can you please point me to the closest kernel (.C subroutine) so that I can build on top of it? Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5931449",
                          "updatedAt": "2023-05-17T19:51:18Z",
                          "publishedAt": "2023-05-17T19:51:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiphase modelling without concentration parameter",
          "author": {
            "login": "MScKarl"
          },
          "bodyText": "Hi everyone!\nI have been using MOOSE for a while but there are still things I really can\u2019t grasp. This is the only place I can turn to for help and I am in desperate need of some.\nFor some time, I have tried to convert my single-phase parameter algorithm into a dual-phase parameter algorithm. The problem I seem to face is that multiple of the required modules (switching functions, barrier functions, and penalty functions), require me to define a concentration of the different phases. In my case, I do not want to use the concentration.\nThe mathematical equations that I am using (which are shown in the images below) use mechanical stress to drive the phase transformation. How can I in the best possible way define this in MOOSE? The equations are already combined into one in f_eta, but when I run my code, everything changes phase, which isn\u2019t right.\nI would very much appreciate any help, explanations, and code-changing suggestions.\nBest Regards\nKarl\n\n[Mesh]\n    type = GeneratedMesh\n    dim = 2\n    nx = 400\n    ny = 400\n    xmin = -3\n    xmax = 3\n    ymin = -3\n    ymax = 3\n    elem_type = QUAD4\n[]\n\n[AuxVariables]\n  [./local_energy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n  [./cross_energy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[Variables]\n  [./eta1]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./eta2]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n[]\n\n[ICs]\n  [./eta1]\n    variable = eta1\n    type = RandomIC\n    min = 1e-5\n    max = 1e-3\n  [../]\n\n  [./eta2]\n    variable = eta2\n    type = RandomIC\n    min = 1e-5\n    max = 1e-3\n  [../]\n[]\n\n[BCs]\n\n   [./left_1]\n    type = NeumannBC\n    variable = 'eta1'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n  [./left_2]\n    type = NeumannBC\n    variable = 'eta2'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n   [./right_1]\n    type = NeumannBC\n    variable = 'eta1'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n  [./right_2]\n    type = NeumannBC\n    variable = 'eta2'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n   [./top_1]\n    type = NeumannBC\n    variable = 'eta1'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n  [./top_2]\n    type = NeumannBC\n    variable = 'eta2'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n  [./bottom_1]\n    type = NeumannBC\n    variable = 'eta1'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n  [./bottom_2]\n    type = NeumannBC\n    variable = 'eta2'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n[]\n\n[AuxKernels]\n\n  [./cross_terms]\n    type = CrossTermGradientFreeEnergy\n    variable = cross_energy\n    interfacial_vars = 'eta1 eta2'\n\n    kappa_names = 'kappa11 kappa12 \n                   kappa21 kappa22' \n                   \n  [../]\n\n[]\n\n[Kernels]\n  #\n  # Order parameter eta1\n  #\n  # Time derivative 1 \n  [./deta1_dt]\n    type = TimeDerivative\n    variable = eta1\n  [../]\n\n  #Interface 1\n  [./ACIntF_1]\n    type = ACMultiInterface\n    variable = eta1\n    etas = 'eta1 eta2'\n    mob_name = L1\n    kappa_names = 'kappa11 kappa12' \n  [../]\n\n  #Bulk 1\n  [./ACbulk_eta1]\n    type = AllenCahn\n    variable = eta1\n    coupled_variables = 'eta2'\n    mob_name = L1\n    f_name = F\n  [../]\n\n  #\n  # Order parameter eta2\n  #\n  # Time derivative 2      \n  [./deta2_dt]\n    type = TimeDerivative\n    variable = eta2\n  [../]\n\n  #Interface 2\n  [./ACIntF_2]\n    type = ACMultiInterface\n    variable = eta2\n    etas = 'eta1 eta2'\n    mob_name = L2\n    kappa_names = 'kappa21 kappa22' \n  [../]\n\n  #Bulk 2\n  [./ACbulk_eta2]\n    type = AllenCahn\n    variable = eta2\n    coupled_variables = 'eta1'\n    mob_name = L2\n    f_name = F\n  [../]\n[]\n\n[Materials]\n\n  [./kappa]\n    type = GenericConstantMaterial\n    prop_names  = 'kappa11 kappa12 kappa21 kappa22'\n    prop_values = '0.0000000133\t\t0\t0.000000334\t0'\n  [../]\n\n   [./L1]\n    type = GenericConstantMaterial\n    prop_names = 'L1'\n    prop_values = '1.0'\n  [../]\n\n   [./L2]\n    type = GenericConstantMaterial\n    prop_names = 'L2'\n    prop_values = '1.0'\n  [../]\n\n  [./P0]\n    type = GenericConstantMaterial\n    prop_names = 'P0'\n    prop_values = '144000000'\n  [../]\n\n  [./s]\n    type = GenericConstantMaterial\n    prop_names = 's'\n    prop_values = '0.6'\n  [../]\n\n  [./f_eta]\n    type = DerivativeParsedMaterial\n    property_name = f_eta # Name of the function\n    coupled_variables = 'eta1 eta2' \n    constant_names = 'P0 s'\n    constant_expressions = '144*10^6 0.6'\n    expression = 'P0*(((eta1^2-1)^2)+((eta2^2-1)^2)*(s/4*(eta1*(eta1+2)*(eta1^2+2*eta1-6)-7)))'\n  [../]\n\n[]\n\n[Postprocessors]\n  \n  [./eta_1]\n    type = ElementIntegralVariablePostprocessor\n    variable = 'eta1'\n  [../]\n  [./eta_2]\n    type = ElementIntegralVariablePostprocessor\n    variable = 'eta2'\n  [../]\n\n[]\n\n\n[Preconditioning]\n\n    type = SMP\n    full = true\n  [../]\n\n[]\n\n[Executioner]\n  type = Transient\n  scheme = 'bdf2'\n\n  solve_type = 'NEWTON'\n\n  start_time = 0.0\n  end_time   = 500.0\n\n  [./TimeStepper]\n    type = SolutionTimeAdaptiveDT\n    dt = 0.1\n  [../]\n[]\n\n[Debug]\n  # show_var_residual_norms = true\n[]\n\n[Outputs]\n\n  [./exodus]\n    type = Exodus\n  [../]\n\n[]\n\n\nBest regards\nKarl",
          "url": "https://github.com/idaholab/moose/discussions/24321",
          "updatedAt": "2023-05-17T16:29:25Z",
          "publishedAt": "2023-05-10T16:18:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "MScKarl"
                  },
                  "bodyText": "Hi @dschwen @amjokisaari!\nIn your profile, which I got from the MOOSE discussion page, it said that you are working in computational material science, which is the same area in which I tried to apply MOOSE. I was wondering if you maybe could have a look at my question. Maybe you could give me some suggestions or input on how I should proceed. If anything is unclear or if there is something I need to specify please let me know.\nBest regards\nKarl",
                  "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5905680",
                  "updatedAt": "2023-05-15T13:56:33Z",
                  "publishedAt": "2023-05-15T13:56:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MScKarl"
                  },
                  "bodyText": "@GiudGiud Maybe you are able to help me? I am in urgent need of help.\nBest regards\nKarl",
                  "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5917774",
                  "updatedAt": "2023-05-16T15:10:56Z",
                  "publishedAt": "2023-05-16T15:10:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm sorry this (phase field and mechanics) is not my area of expertise.\n@laagesen or @hugary1995 will know more than me.",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918259",
                          "updatedAt": "2023-05-16T15:54:42Z",
                          "publishedAt": "2023-05-16T15:54:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Hi @GiudGiud!\nI understand, but thanks for your reply. Is there a quick way to contact these people, as I'm a bit pressed for time?",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918347",
                          "updatedAt": "2023-05-16T16:04:05Z",
                          "publishedAt": "2023-05-16T16:04:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Their emails are public you can try that.\nThey are both active on this forum they'll pitch in if they have time.",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918406",
                          "updatedAt": "2023-05-16T16:10:54Z",
                          "publishedAt": "2023-05-16T16:10:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I don't have expertise on this matter, sorry. But before others chime in, I have the following suggestions/questions for starters:\n\nremove the Neumann BCs, they are unnecessary unless you want to prescribe nonzero fluxes.\nYou said \"The mathematical equations that I am using (which are shown in the images below) use mechanical stress to drive the phase transformation.\" but I don't see any elastic energy contribution in your free energy.",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918479",
                          "updatedAt": "2023-05-16T16:18:16Z",
                          "publishedAt": "2023-05-16T16:18:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "To add to what @hugary1995 said, I'm not sure what the evolution equations of the model are. Do you have Allen-Cahn equations for eta1 and eta2 derived from this? There would need to be gradient energy terms defined, as well as elastic energy terms as @hugary1995 mentioned.",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918650",
                          "updatedAt": "2023-05-16T16:31:29Z",
                          "publishedAt": "2023-05-16T16:31:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Hi!\nThank you for your answers. In the images below is the Allen-Cahn equation used and the Total free energy equation that is being used.\n\n\u0413ij is a diagonal matrix referred to as the mobility tensor and is multiplied by the functional derivative of the total free energy \ud835\udc39",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918807",
                          "updatedAt": "2023-05-16T16:53:10Z",
                          "publishedAt": "2023-05-16T16:48:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You can start from this example: modules/combined/examples/phase_field-mechanics/SimplePhaseTrans.i",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918854",
                          "updatedAt": "2023-05-16T16:54:01Z",
                          "publishedAt": "2023-05-16T16:54:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Thank you. I will go through the example. I may ask some follow up questions later if I don't solve it. I hope that's okay?",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918890",
                          "updatedAt": "2023-05-16T16:57:33Z",
                          "publishedAt": "2023-05-16T16:57:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yes sure, just post it here. All of us try our best to offer free premium support within our bandwidth :)",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918948",
                          "updatedAt": "2023-05-16T17:05:33Z",
                          "publishedAt": "2023-05-16T17:05:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MScKarl"
                  },
                  "bodyText": "Hi again!\nI apologize that I return so quickly, but I just realized that I made a small mistake in my equations regarding the total free energy.\nWhat I missed was that the elastic energy is included in the potential and should not be handled separately. In the first-mentioned equations, all energy contributions are mathematically included except the gradient term (i.e. the interface contribution). This means that the mechanical part comes implicitly through its (x,y)- dependency. This would in turn mean that the mechanical energy is only spatial dependent and should not evolve with the phase evolution. The problem for me is to try to solve the equations:",
                  "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5926507",
                  "updatedAt": "2023-05-17T11:21:22Z",
                  "publishedAt": "2023-05-17T11:21:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'm totally lost. Someone else please help...",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5927370",
                          "updatedAt": "2023-05-17T12:56:58Z",
                          "publishedAt": "2023-05-17T12:56:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Based on the equations you've posted here, you should be able to solve the problem using two Allen-Cahn equations, one for eta1 and another for eta2. For each one, you need 3 kernels: TimeDerivative, ACInterface, and AllenCahn. Based on the form of the gradient terms, you don't need to use ACMultiInterface. You can need to pass your free energy f_eta to each of the two Allen-Cahn equations. Please have a look at this documentation and study how each kernel implements the governing equation as I've described: https://mooseframework.inl.gov/modules/phase_field/Phase_Field_Equations.html",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5929834",
                          "updatedAt": "2023-05-17T16:29:26Z",
                          "publishedAt": "2023-05-17T16:29:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow: Problem in convergence",
          "author": {
            "login": "sinaomrani96"
          },
          "bodyText": "Dear all,\nHope you are doing well.\nI wanted to simulate a 2-phase 3-component (water + tracer + CO2) system. First, I simulated the water + tracer system with PorousFlowFullySaturated similar to an example in tutorial_06. The I used \"Restarting and recovering from previous simulations\" to inject CO2, as I want to have tracer transport as CO2 get injected in my system. However, I have problem regarding convergence. I don't know that this problem is highly nonlinear or there are simpler ways to do it. I appreciate your insight on this. Also, Here are the input files if you want to have a look. Thanks.\nhttps://github.com/sinaomrani96/Test\nBest regards,\nSina",
          "url": "https://github.com/idaholab/moose/discussions/24235",
          "updatedAt": "2023-05-17T15:55:19Z",
          "publishedAt": "2023-05-01T11:34:32Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Hey @sinaomrani96 ,\nThere is general advice here: https://mooseframework.inl.gov/modules/porous_flow/nonlinear_convergence_problems.html  Please read carefully, as almost every sentence there comes from people struggling with many convergence problems.\nYour model is the most difficult situation (multiphase and multicomponent).  It is very easy for PorousFlow to drive a model to a situation where:\n\nthe boundary conditions are trying to remove fluid components that don't exist at the boundary\nthe saturation or mass fraction is very close to zero or one\nthe Jacobian is almost singular\n\nYou could try running for a while, recording residuals into AuxVars and visualising them to determine what the problem is.  You could try a different initialisation, eg, instead of mass_fraction = 0 somewhere, make it 0.1, just to see what happens.  You could try using a PP (2 porepressures) rather than PS formulation.   You could try changing \"variable = \" the Kernels+BCs+Diracs , eg, swap \"variable = tracer\" for \"variable = sgas\".   You could try turning off various BCs, or adding others (such as removing other components from boundary=right) or using different use_* to handle strange cases of saturation=0, etc.",
                  "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5775325",
                  "updatedAt": "2023-05-01T21:36:07Z",
                  "publishedAt": "2023-05-01T21:36:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Dear @WilkAndy,\nThanks for your reply.\nI will follow your comment and instructions. Sorry to take more of your time but I tried to run the first simulation a bit shorter, and after that run the second simulation (2-phase 3-components) and it converges at least but to a wrong answer (the previous setup failed to converge from the beginning). I tried to record residuals into AuxVars as you suggested but I face Segmentation fault. I was wondering if I am doing it wrong or there is something else. I would appreciate it if you could help me why I cannot record the residuals. Also here is the saturation profile if I turn off the DebugResidualAux.\ninput files: https://github.com/sinaomrani96/Test/tree/main",
                          "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5779400",
                          "updatedAt": "2023-05-02T10:35:40Z",
                          "publishedAt": "2023-05-02T10:35:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Use the save_in feature of a Kernel to shove the residual into an AuxVariable.\nOh dear, the saturation is waaay wrong (negative saturation).   I suspect it's due to using PorousFlowCapillaryPressureConst instead of an experimentally-measured capillary curve.\nOne other thing to try - probably best to do this before the other items mentioned above - is to copy almost exactly porous_flow/examples/restart/gas_injection.i .  See https://mooseframework.inl.gov/modules/porous_flow/restart.html .    That does almost exactly what you want, but is only 2-component.  Then you can figure out whether it's the extra fluid component or the gas phase that is causing your problems.",
                          "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5785624",
                          "updatedAt": "2023-05-02T21:50:50Z",
                          "publishedAt": "2023-05-02T21:50:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Dear @WilkAndy,\nThanks for your help and time. I finally got it running to a more logical answer, but still it needs correction. As I was getting values other than 0 for mass fraction of my second component (which is gas in the gas phase and should not have any value in the 1st phase), I suspected that this is the issue. I do not know if this is a silly approach or actually smart but this is what I did:\nAs I initialise my second simulation based on a single-phase tracer+water system, I assigned a ParseMaterial to have the value of mass fraction for water in that system. Then I used this for my second run instead of initialising water mass fraction with the values calculated by PorousFlowPropertyAux. However, the problem of getting values (highly negative) for my second component in first phase still persists, and this makes error in calculating mass fractions. How I can prevent this? Here are my input files and results (gas saturation profile and its mass fraction in first phase) now:\nhttps://github.com/sinaomrani96/Test/tree/main\n\n\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5790544",
                          "updatedAt": "2023-05-03T12:05:39Z",
                          "publishedAt": "2023-05-03T12:05:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Hey @sinaomrani96 - i'm not going to have time to look at this for the next few days.   i'm giving some important lectures and organising a conference and they're taking all my time.",
                          "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5809847",
                          "updatedAt": "2023-05-04T21:06:57Z",
                          "publishedAt": "2023-05-04T21:06:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Hi,\nI just wanted to update the status of this problem that changing the order of numbering will solve this issue. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5929465",
                          "updatedAt": "2023-05-17T15:55:19Z",
                          "publishedAt": "2023-05-17T15:55:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Recrystallization literature and open source code",
          "author": {
            "login": "KangChenRui"
          },
          "bodyText": "Hi\uff0cEveryone\uff01\nI would like to learn about the literature and open source code related to recrystallization.\nIs there any content on these aspects on MOOSE?\nThank you for your help\nChenrui",
          "url": "https://github.com/idaholab/moose/discussions/24409",
          "updatedAt": "2023-05-17T15:06:15Z",
          "publishedAt": "2023-05-17T08:02:55Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "We have done recrystallization simulations, where we keep track of a stored energy content in each grain and use the DiscreteNucleation system to nucleate new grains. @amjokisaari has worked on this.",
                  "url": "https://github.com/idaholab/moose/discussions/24409#discussioncomment-5928870",
                  "updatedAt": "2023-05-17T15:01:18Z",
                  "publishedAt": "2023-05-17T15:01:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "https://link.springer.com/article/10.1007/s11837-019-03830-z",
                  "url": "https://github.com/idaholab/moose/discussions/24409#discussioncomment-5928931",
                  "updatedAt": "2023-05-17T15:06:16Z",
                  "publishedAt": "2023-05-17T15:06:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow: Sink dirackernel of components with the whole mass_flux",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear all,\nI learn the Point and line sources/sinks page. I can set the source dirackernels with known separate mass_flux for all components by PorousFlowSquarePulsePointSource. For example,\n[DiracKernels]\n  [source1]\n    type = PorousFlowSquarePulsePointSource\n    start_time = 0\n    end_time = 100\n    point = '0.5 0.5 0'\n    mass_flux = 0.1\n    variable = pp\n  []\n  [source0]\n    type = PorousFlowSquarePulsePointSource\n    start_time = 0\n    end_time = 100\n    point = '0.5 0.5 0'\n    mass_flux = 0.02\n    variable = mf_0\n  []\n[]\n\nAnd I also want to set the sink dirackernel for all components. Only the sum of the mass flux of all components is known. I try the PorousFlowPeacemanBorehole but the produced mass flux is dynamic and it is the function of the pressure.\nBut I want to set the fixed overall mass flux of all components, equal to the overall mass flux in the source dirackernel.\nHow can I solve this problem?\nThanks for your help.\nJ",
          "url": "https://github.com/idaholab/moose/discussions/24375",
          "updatedAt": "2023-05-17T14:36:52Z",
          "publishedAt": "2023-05-15T23:14:37Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "You could use a PorousFlowPolyLineSink and specify mass_fraction_component in place of the PorousFlowPeacemanBorehole as your production well - see https://github.com/idaholab/moose/blob/next/modules/combined/examples/geochem-porous_flow/geotes_2D/porous_flow.i for an example",
                  "url": "https://github.com/idaholab/moose/discussions/24375#discussioncomment-5910460",
                  "updatedAt": "2023-05-16T00:09:04Z",
                  "publishedAt": "2023-05-16T00:09:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "You could use a PorousFlowPolyLineSink and specify mass_fraction_component in place of the PorousFlowPeacemanBorehole as your production well - see https://github.com/idaholab/moose/blob/next/modules/combined/examples/geochem-porous_flow/geotes_2D/porous_flow.i for an example\n\nHello Chris, thanks for your suggestions. It does work well.",
                          "url": "https://github.com/idaholab/moose/discussions/24375#discussioncomment-5928584",
                          "updatedAt": "2023-05-17T14:36:53Z",
                          "publishedAt": "2023-05-17T14:36:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow: Hydromechanical Iterative Coupling Question",
          "author": {
            "login": "jrpatterson79"
          },
          "bodyText": "Hello friends,\nFirst time poster and new user to the MOOSE framework. I'm working to build a coupled hydromechanical discrete fracture model. My starting point is a 2D penny-shaped, horizontal, fracture embedded in a 3D rock mesh. I would like to use an iterative coupling scheme to couple the hydraulic problem to the quasi-static linear elastic mechanical problem using Multi-Apps and Transfers.\nI can run the model, in its current form, to completion without Picard (Fixed Point) iterations; however, when I add the Fixed Point iterations to the Executioner block I get the error below. I read this error as saying my injection location (a Dirac kernel) has the same node ID as one of the nodes in the 3D mesh, but I'm not sure how to correct it. Does anyone have any insights they can share?\n*** ERROR ***\nThe following error occurred in the object \"pp_from_frac\", of type \"ReporterPointSource\".\n\nCached Dirac point (x,y,z)=(       0,        0,        0) already exists with ID: 0 and does not match point (x,y,z)=( 9.69032,  92.1973,        0)\n\nThe input files are located at https://github.com/jrpatterson79/testing\nI updated MOOSE and all packages in the mamba moose environment this morning to ensure I'm running with the most recent release and package versions.\nThanks in advance,\nJ Patt",
          "url": "https://github.com/idaholab/moose/discussions/24367",
          "updatedAt": "2023-05-17T13:47:53Z",
          "publishedAt": "2023-05-15T19:43:08Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "I'm not sure if I can help with this problem but just wanted to say this looks really cool! Hopefully it is something simple that one of the MOOSE team can help with.",
                  "url": "https://github.com/idaholab/moose/discussions/24367#discussioncomment-5910481",
                  "updatedAt": "2023-05-16T00:12:42Z",
                  "publishedAt": "2023-05-16T00:12:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "let me take a look today",
                          "url": "https://github.com/idaholab/moose/discussions/24367#discussioncomment-5916351",
                          "updatedAt": "2023-05-16T13:09:16Z",
                          "publishedAt": "2023-05-16T13:09:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok I found the issue, the cache is not cleared and the reporter values (giving the points) change.\nI dont think this was in whoever designed Dirac Kernel's objectives to have moving points. It might not be too difficult to fix though",
                          "url": "https://github.com/idaholab/moose/discussions/24367#discussioncomment-5919865",
                          "updatedAt": "2023-05-16T18:46:37Z",
                          "publishedAt": "2023-05-16T18:46:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For right now you can either check out my PR\n#24400\nor work with this object\nhttps://mooseframework.inl.gov/source/dirackernels/ReporterTimePointSource.html",
                          "url": "https://github.com/idaholab/moose/discussions/24367#discussioncomment-5920179",
                          "updatedAt": "2023-05-16T19:28:50Z",
                          "publishedAt": "2023-05-16T19:28:49Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jrpatterson79"
                          },
                          "bodyText": "@GiudGiud, thank you for making the time to have a look and offer your insight. I will see what I can do with the ReporpterTimePointSource while the PR is being reviewed for merge.",
                          "url": "https://github.com/idaholab/moose/discussions/24367#discussioncomment-5927972",
                          "updatedAt": "2023-05-17T13:47:36Z",
                          "publishedAt": "2023-05-17T13:47:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about the Hw in Custom Closures",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "@joshuahansel @licharlot\nI write an input file which calculates a 7-rods case(with 18 channels). I'm not sure if I use the custom closures in the right way.\nHere is the picture of the assembly:\n\nIn my understanding, if there is only one heat structure connected with a flow channel, the heat transfer coefficient is Hw by default. And if there are two heat structures connected with a flow channel, the heat transfer coefficients are Hw:1 and Hw:2(3 hs case, the heat transfer coefficients are Hw:1 Hw:2 and Hw:3).  The problem is that all these 3 cases appear in my input file.\nFor example, there should only be a Hw in channel1 which connected to rod1.  But for channel2, there should be Hw:1 and Hw:2, right? I write the input file in this way and meet an error: the terminal says that I should define Hw in channel2 and I can't understand why. But I still define Hw in all flow channels(to avoid error).\nAnd the input file is:\nT_in = 522.436        # K\n# m_dot_in = 1e-4     # kg/s\npress = 101325        # Pa\n\nflow_blocks = 'core_chan1 core_chan2 core_chan3 core_chan4 core_chan5 core_chan6\n               core_chan7 core_chan8 core_chan9 core_chan10 core_chan11 core_chan12\n               core_chan13 core_chan14 core_chan15 core_chan16 core_chan17 core_chan18'\n# ht_blocks_1SC = 'core_chan1 core_chan3 core_chan9 core_chan10 core_chan16 core_chan18'\nht_blocks_2SC = 'core_chan2 core_chan4 core_chan5 core_chan6 core_chan7 core_chan8\n                 core_chan11 core_chan12 core_chan13 core_chan14 core_chan15 core_chan17'\nht_blocks_3SC = 'core_chan6 core_chan7 core_chan8 core_chan11 core_chan12 core_chan13'\n\n\n[GlobalParams]\n  initial_p = ${press}\n  initial_vel = 0\n  initial_T = ${T_in}\n\n  rdg_slope_reconstruction = full\n  closures = simple_closures\n  fp = Lead\n  pitch = 0.023\n  rod_diameter = 0.012\n#  wire_lead = 0.3048\n#  f = 0.033\n#  Hw = 343.173\n[]\n\n[FluidProperties]\n  [./Lead]\n    type = LeadBismuthFluidProperties_zxy\n  [../]\n[]\n\n[Functions]\n  [PowerDistribution]\n    type = ParsedFunction\n    expression = sin(5*pi*z/3)\n  [../]\n[]\n\n[Materials]\n  [f_mat]\n    type = ADWallFrictionChurchillMaterial\n    D_h = D_h\n    f_D = f_D\n    mu = mu\n    rho = rho\n    vel = vel\n    block = ${flow_blocks}\n  [../]\n  [Hw_mat]\n    type = ADWallHeatTransferCoefficientMikityukMaterial\n    D_h = D_h\n    rho = rho\n    vel = vel\n    T = T\n    cp = cp\n    mu = mu\n    k = k\n    Hw = Hw\n    block = ${flow_blocks}\n  [../]\n  [Hw1_mat]\n    type = ADWallHeatTransferCoefficientMikityukMaterial\n    D_h = D_h\n    rho = rho\n    vel = vel\n    T = T\n    cp = cp\n    mu = mu\n    k = k\n    Hw = Hw:1\n    block = ${ht_blocks_2SC}\n  [../]\n  [Hw2_mat]\n    type = ADWallHeatTransferCoefficientMikityukMaterial\n    D_h = D_h\n    rho = rho\n    vel = vel\n    T = T\n    cp = cp\n    mu = mu\n    k = k\n    Hw = Hw:2\n    block = ${ht_blocks_2SC}\n  [../]\n  [Hw3_mat]\n    type = ADWallHeatTransferCoefficientMikityukMaterial\n    D_h = D_h\n    rho = rho\n    vel = vel\n    T = T\n    cp = cp\n    mu = mu\n    k = k\n    Hw = Hw:3\n    block = ${ht_blocks_3SC}\n  [../]\n[]\n\n[Closures]\n  [simple_closures]\n#    type = Closures1PhaseSimple\n    type = Closures1PhaseNone\n  []\n[]\n\n[HeatStructureMaterials]\n  [fuel-mat]\n    type = SolidMaterialProperties\n    k = 15\n    cp = 460\n    rho = 8.4e3\n  [../]\n#  [gap-mat]\n#    type = SolidMaterialProperties\n#    k = 0.027\n#    cp = 1007\n#    rho = 0.43\n#  []\n#  [clad-mat]\n#    type = SolidMaterialProperties\n#    k = 20\n#    cp = 450\n#    rho = 7.95e3\n#  []\n[]\n\n[Components]\n  [total_power]\n    type = TotalPower\n    power = 3335.933\n  [../]\n  [./inlet1]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan1:in'\n    m_dot = 0.0394\n    T = ${T_in}\n  [../]\n  [core_chan1]\n    type = FlowChannel1Phase\n    position = '-0.015 -0.02598 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 92.598e-6\n    D_h = 16.622e-3\n  [../]\n  [outlet1]\n    type = Outlet1Phase\n    input = 'core_chan1:out'\n    p = ${press}\n  [../]\n  [./inlet2]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan2:in'\n    m_dot = 0.1124\n    T = ${T_in}\n  [../]\n  [core_chan2]\n    type = FlowChannel1Phase\n    position = '0 -0.02598 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 263.874e-6\n    D_h = 25.221e-3\n  [../]\n  [outlet2]\n    type = Outlet1Phase\n    input = 'core_chan2:out'\n    p = ${press}\n  [../]\n  [./inlet3]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan3:in'\n    m_dot = 0.0394\n    T = ${T_in}\n  [../]\n  [core_chan3]\n    type = FlowChannel1Phase\n    position = '0.015 -0.02598 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 92.598e-6\n    D_h = 16.622e-3\n  [../]\n  [outlet3]\n    type = Outlet1Phase\n    input = 'core_chan3:out'\n    p = ${press}\n  [../]\n  [./inlet4]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan4:in'\n    m_dot = 0.1124\n    T = ${T_in}\n  [../]\n  [core_chan4]\n    type = FlowChannel1Phase\n    position = '-0.0225 -0.01299 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 263.874e-6\n    D_h = 25.221e-3\n  [../]\n  [outlet4]\n    type = Outlet1Phase\n    input = 'core_chan4:out'\n    p = ${press}\n  [../]\n  [./inlet5]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan5:in'\n    m_dot = 0.1124\n    T = ${T_in}\n  [../]\n  [core_chan5]\n    type = FlowChannel1Phase\n    position = '0.0225 -0.01299 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 263.874e-6\n    D_h = 25.221e-3\n  [../]\n  [outlet5]\n    type = Outlet1Phase\n    input = 'core_chan5:out'\n    p = ${press}\n  [../]\n  [./inlet6]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan6:in'\n    m_dot = 0.0735\n    T = ${T_in}\n  [../]\n  [core_chan6]\n    type = FlowChannel1Phase\n    position = '0 -0.01299 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 172.515e-6\n    D_h = 36.608e-3\n  [../]\n  [outlet6]\n    type = Outlet1Phase\n    input = 'core_chan6:out'\n    p = ${press}\n  [../]\n  [./inlet7]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan7:in'\n    m_dot = 0.0735\n    T = ${T_in}\n  [../]\n  [core_chan7]\n    type = FlowChannel1Phase\n    position = '-0.01125 -0.006495 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 172.515e-6\n    D_h = 36.608e-3\n  [../]\n  [outlet7]\n    type = Outlet1Phase\n    input = 'core_chan7:out'\n    p = ${press}\n  [../]\n  [./inlet8]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan8:in'\n    m_dot = 0.0735\n    T = ${T_in}\n  [../]\n  [core_chan8]\n    type = FlowChannel1Phase\n    position = '0.01125 -0.006495 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 172.515e-6\n    D_h = 36.608e-3\n  [../]\n  [outlet8]\n    type = Outlet1Phase\n    input = 'core_chan8:out'\n    p = ${press}\n  [../]\n  [./inlet9]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan9:in'\n    m_dot = 0.0394\n    T = ${T_in}\n  [../]\n  [core_chan9]\n    type = FlowChannel1Phase\n    position = '-0.03 0 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 92.598e-6\n    D_h = 16.622e-3\n  [../]\n  [outlet9]\n    type = Outlet1Phase\n    input = 'core_chan9:out'\n    p = ${press}\n  [../]\n  [./inlet10]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan10:in'\n    m_dot = 0.0394\n    T = ${T_in}\n  [../]\n  [core_chan10]\n    type = FlowChannel1Phase\n    position = '0.03 0 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 92.598e-6\n    D_h = 16.622e-3\n  [../]\n  [outlet10]\n    type = Outlet1Phase\n    input = 'core_chan10:out'\n    p = ${press}\n  [../]\n  [./inlet11]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan11:in'\n    m_dot = 0.0735\n    T = ${T_in}\n  [../]\n  [core_chan11]\n    type = FlowChannel1Phase\n    position = '-0.01125 0.006495 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 172.515e-6\n    D_h = 36.608e-3\n  [../]\n  [outlet11]\n    type = Outlet1Phase\n    input = 'core_chan11:out'\n    p = ${press}\n  [../]\n  [./inlet12]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan12:in'\n    m_dot = 0.0735\n    T = ${T_in}\n  [../]\n  [core_chan12]\n    type = FlowChannel1Phase\n    position = '0.01125 0.006495 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 172.515e-6\n    D_h = 36.608e-3\n  [../]\n  [outlet12]\n    type = Outlet1Phase\n    input = 'core_chan12:out'\n    p = ${press}\n  [../]\n  [./inlet13]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan13:in'\n    m_dot = 0.0735\n    T = ${T_in}\n  [../]\n  [core_chan13]\n    type = FlowChannel1Phase\n    position = '0 0.01299 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 172.515e-6\n    D_h = 36.608e-3\n  [../]\n  [outlet13]\n    type = Outlet1Phase\n    input = 'core_chan13:out'\n    p = ${press}\n  [../]\n  [./inlet14]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan14:in'\n    m_dot = 0.1124\n    T = ${T_in}\n  [../]\n  [core_chan14]\n    type = FlowChannel1Phase\n    position = '-0.0225 0.01299 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 263.874e-6\n    D_h = 25.221e-3\n  [../]\n  [outlet14]\n    type = Outlet1Phase\n    input = 'core_chan14:out'\n    p = ${press}\n  [../]\n  [./inlet15]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan15:in'\n    m_dot = 0.1124\n    T = ${T_in}\n  [../]\n  [core_chan15]\n    type = FlowChannel1Phase\n    position = '0.0225 0.01299 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 263.874e-6\n    D_h = 25.221e-3\n  [../]\n  [outlet15]\n    type = Outlet1Phase\n    input = 'core_chan15:out'\n    p = ${press}\n  [../]\n  [./inlet16]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan16:in'\n    m_dot = 0.0394\n    T = ${T_in}\n  [../]\n  [core_chan16]\n    type = FlowChannel1Phase\n    position = '-0.015 0.02598 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 92.598e-6\n    D_h = 16.622e-3\n  [../]\n  [outlet16]\n    type = Outlet1Phase\n    input = 'core_chan16:out'\n    p = ${press}\n  [../]\n  [./inlet17]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan17:in'\n    m_dot = 0.1124\n    T = ${T_in}\n  [../]\n  [core_chan17]\n    type = FlowChannel1Phase\n    position = '0 0.02598 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 263.874e-6\n    D_h = 25.221e-3\n  [../]\n  [outlet17]\n    type = Outlet1Phase\n    input = 'core_chan17:out'\n    p = ${press}\n  [../]\n  [./inlet18]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan18:in'\n    m_dot = 0.0394\n    T = ${T_in}\n  [../]\n  [core_chan18]\n    type = FlowChannel1Phase\n    position = '0.015 0.02598 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    A = 92.598e-6\n    D_h = 16.622e-3\n  [../]\n  [outlet18]\n    type = Outlet1Phase\n    input = 'core_chan18:out'\n    p = ${press}\n  [../]\n  [7RODS]\n    type = FLARE_7RODS_TEST\n    flow_channel1 = core_chan1\n    flow_channel2 = core_chan2\n    flow_channel3 = core_chan3\n    flow_channel4 = core_chan4\n    flow_channel5 = core_chan5\n    flow_channel6 = core_chan6\n    flow_channel7 = core_chan7\n    flow_channel8 = core_chan8\n    flow_channel9 = core_chan9\n    flow_channel10 = core_chan10\n    flow_channel11 = core_chan11\n    flow_channel12 = core_chan12\n    flow_channel13 = core_chan13\n    flow_channel14 = core_chan14\n    flow_channel15 = core_chan15\n    flow_channel16 = core_chan16\n    flow_channel17 = core_chan17\n    flow_channel18 = core_chan18\n  [../]\n  [ROD1]\n    type = HeatStructureCylindrical\n    position = '-0.0115 -0.0199 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    initial_T = 522.436\n    names = 'fuel'\n    widths = '0.006'\n    n_part_elems = '5'\n    materials = 'fuel-mat'\n  [../]\n  [ROD2]\n    type = HeatStructureCylindrical\n    position = '0.0115 -0.0199 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    initial_T = 522.436\n    names = 'fuel'\n    widths = '0.006'\n    n_part_elems = '5'\n    materials = 'fuel-mat'\n  [../]\n  [ROD3]\n    type = HeatStructureCylindrical\n    position = '-0.023 0 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    initial_T = 522.436\n    names = 'fuel'\n    widths = '0.006'\n    n_part_elems = '5'\n    materials = 'fuel-mat'\n  [../]\n  [ROD4]\n    type = HeatStructureCylindrical\n    position = '0 0 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    initial_T = 522.436\n    names = 'fuel'\n    widths = '0.006'\n    n_part_elems = '5'\n    materials = 'fuel-mat'\n  [../]\n  [ROD5]\n    type = HeatStructureCylindrical\n    position = '0.023 0 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    initial_T = 522.436\n    names = 'fuel'\n    widths = '0.006'\n    n_part_elems = '5'\n    materials = 'fuel-mat'\n  [../]\n  [ROD6]\n    type = HeatStructureCylindrical\n    position = '-0.0115 0.0199 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    initial_T = 522.436\n    names = 'fuel'\n    widths = '0.006'\n    n_part_elems = '5'\n    materials = 'fuel-mat'\n  [../]\n  [ROD7]\n    type = HeatStructureCylindrical\n    position = '0.0115 0.0199 0'\n    orientation = '0 0 1'\n    length = 0.6\n    n_elems = 60\n    initial_T = 522.436\n    names = 'fuel'\n    widths = '0.006'\n    n_part_elems = '5'\n    materials = 'fuel-mat'\n  [../]\n  [HeatSource1]\n    type = HeatSourceFromTotalPower\n    hs = ROD1\n    regions = 'fuel'\n    power = total_power\n    power_shape_function = PowerDistribution\n    power_fraction = 0.142857\n  [../]\n  [HeatSource2]\n    type = HeatSourceFromTotalPower\n    hs = ROD2\n    regions = 'fuel'\n    power = total_power\n    power_shape_function = PowerDistribution\n    power_fraction = 0.142857\n  [../]\n  [HeatSource3]\n    type = HeatSourceFromTotalPower\n    hs = ROD3\n    regions = 'fuel'\n    power = total_power\n    power_shape_function = PowerDistribution\n    power_fraction = 0.142857\n  [../]\n  [HeatSource4]\n    type = HeatSourceFromTotalPower\n    hs = ROD4\n    regions = 'fuel'\n    power = total_power\n    power_shape_function = PowerDistribution\n    power_fraction = 0.142857\n  [../]\n  [HeatSource5]\n    type = HeatSourceFromTotalPower\n    hs = ROD5\n    regions = 'fuel'\n    power = total_power\n    power_shape_function = PowerDistribution\n    power_fraction = 0.142857\n  [../]\n  [HeatSource6]\n    type = HeatSourceFromTotalPower\n    hs = ROD6\n    regions = 'fuel'\n    power = total_power\n    power_shape_function = PowerDistribution\n    power_fraction = 0.142857\n  [../]\n  [HeatSource7]\n    type = HeatSourceFromTotalPower\n    hs = ROD7\n    regions = 'fuel'\n    power = total_power\n    power_shape_function = PowerDistribution\n    power_fraction = 0.142857\n  [../]\n  [ROD1_FLOWSC1]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan1\n    hs = ROD1\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw\n  [../]\n  [ROD1_FLOWSC2]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan2\n    hs = ROD1\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:1\n  [../]\n  [ROD1_FLOWSC4]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan4\n    hs = ROD1\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:1\n  [../]\n  [ROD1_FLOWSC6]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan6\n    hs = ROD1\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:1\n  [../]\n  [ROD1_FLOWSC7]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan7\n    hs = ROD1\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:1\n  [../]\n  [ROD2_FLOWSC2]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan2\n    hs = ROD2\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:2\n  [../]\n  [ROD2_FLOWSC3]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan3\n    hs = ROD2\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw\n  [../]\n  [ROD2_FLOWSC5]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan5\n    hs = ROD2\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:1\n  [../]\n  [ROD2_FLOWSC6]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan6\n    hs = ROD2\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:2\n  [../]\n  [ROD2_FLOWSC8]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan8\n    hs = ROD2\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:1\n  [../]\n  [ROD3_FLOWSC4]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan4\n    hs = ROD3\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:2\n  [../]\n  [ROD3_FLOWSC7]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan7\n    hs = ROD3\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:2\n  [../]\n  [ROD3_FLOWSC9]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan9\n    hs = ROD3\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw\n  [../]\n  [ROD3_FLOWSC11]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan11\n    hs = ROD3\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:1\n  [../]\n  [ROD3_FLOWSC14]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan14\n    hs = ROD3\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:1\n  [../]\n  [ROD4_FLOWSC6]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan6\n    hs = ROD4\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:3\n  [../]\n  [ROD4_FLOWSC7]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan7\n    hs = ROD4\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:3\n  [../]\n  [ROD4_FLOWSC8]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan8\n    hs = ROD4\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:2\n  [../]\n  [ROD4_FLOWSC11]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan11\n    hs = ROD4\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:2\n  [../]\n  [ROD4_FLOWSC12]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan12\n    hs = ROD4\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:1\n  [../]\n  [ROD4_FLOWSC13]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan13\n    hs = ROD4\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:1\n  [../]\n  [ROD5_FLOWSC5]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan5\n    hs = ROD5\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:2\n  [../]\n  [ROD5_FLOWSC8]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan8\n    hs = ROD5\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:3\n  [../]\n  [ROD5_FLOWSC10]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan10\n    hs = ROD5\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw\n  [../]\n  [ROD5_FLOWSC12]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan12\n    hs = ROD5\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:2\n  [../]\n  [ROD5_FLOWSC15]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan15\n    hs = ROD5\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:1\n  [../]\n  [ROD6_FLOWSC11]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan11\n    hs = ROD6\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:3\n  [../]\n  [ROD6_FLOWSC13]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan13\n    hs = ROD6\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:2\n  [../]\n  [ROD6_FLOWSC14]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan14\n    hs = ROD6\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:2\n  [../]\n  [ROD6_FLOWSC16]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan16\n    hs = ROD6\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw\n  [../]\n  [ROD6_FLOWSC17]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan17\n    hs = ROD6\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:1\n  [../]\n  [ROD7_FLOWSC12]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan12\n    hs = ROD7\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:3\n  [../]\n  [ROD7_FLOWSC13]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan13\n    hs = ROD7\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw:3\n  [../]\n  [ROD7_FLOWSC15]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan15\n    hs = ROD7\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:2\n  [../]\n  [ROD7_FLOWSC17]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan17\n    hs = ROD7\n    hs_side = outer\n    P_hf = 0.0377/4\n    Hw = Hw:2\n  [../]\n  [ROD7_FLOWSC18]\n    type = HeatTransferFromHeatStructure1Phase\n    flow_channel = core_chan18\n    hs = ROD7\n    hs_side = outer\n    P_hf = 0.0377/6\n    Hw = Hw\n  [../]\n[]\n\n[Preconditioning]\n  [./a]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[VectorPostprocessors]\n  [./T_SC_CORNER1]\n    type = ElementValueSampler\n    variable = T\n    sort_by = z\n    block = 8\n  [../]\n  [./T_SC_CORNER2]\n    type = ElementValueSampler\n    variable = T\n    sort_by = z\n    block = 0\n  [../]\n  [./T_SC_SIDE]\n    type = ElementValueSampler\n    variable = T\n    sort_by = z\n    block = 16\n  [../]\n  [./T_SC_CENTER]\n    type = ElementValueSampler\n    variable = T\n    sort_by = z\n    block = 7\n  [../]\n#  [./M_SC_CORNER]\n#    type = ElementValueSampler\n#    variable = rhouA\n#    sort_by = z\n#    block = 8\n#  [../]\n#  [./M_SC_SIDE]\n#    type = ElementValueSampler\n#    variable = rhouA\n#    sort_by = z\n#    block = 16\n#  [../]\n#  [./M_SC_CENTER]\n#    type = ElementValueSampler\n#    variable = rhouA\n#    sort_by = z\n#    block = 7\n#  [../]\n[]\n\n[Executioner]\n  type = Transient\n  start_time = 0\n  end_time = 200\n  dt = 1\n\n# line_search = basic\n  solve_type = 'PJFNK'\n  l_max_its = 100\n\n  nl_rel_tol = 1e-5\n  nl_abs_tol = 1e-5\n  nl_max_its = 100\n\n  automatic_scaling = true\n  off_diagonals_in_auto_scaling = true\n  line_search = 'none'\n\n  petsc_options = '-ksp_type<preonly>'\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n[]\n\n[Outputs]\n  exodus = true\n  [CSV]\n    type = CSV\n    start_time = 190\n    end_time = 200\n  [../]\n[]\n\nBtw, the ADWallHeatTransferCoefficientMikityukMaterial closure is defined by me, which don't need the T_wall.\nI don't know if this input file is right. Can anybody help me?\nEthan",
          "url": "https://github.com/idaholab/moose/discussions/24197",
          "updatedAt": "2023-05-17T12:53:04Z",
          "publishedAt": "2023-04-27T13:52:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "meet an error: the terminal says that I should define Hw in channel2\n\nCan you post this error message?",
                  "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5745109",
                  "updatedAt": "2023-04-27T16:23:27Z",
                  "publishedAt": "2023-04-27T16:23:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "OK. When I only set Hw in the corner flow channel like this:\n  [Hw_mat]\n    type = ADWallHeatTransferCoefficientMikityukMaterial\n    D_h = D_h\n    rho = rho\n    vel = vel\n    T = T\n    cp = cp\n    mu = mu\n    k = k\n    Hw = Hw\n    block = ${ht_blocks_1SC}\n  [../]\n\nAnd ht_blocks_1SC is like:\nht_blocks_1SC = 'core_chan1 core_chan3 core_chan9 core_chan10 core_chan16 core_chan18'\nThe error is:\n*** ERROR ***\nThe following error occurred in the object \"THM:problem\", of type \"THMProblem\".\n\nMaterial property 'Hw', requested by 'core_chan2:avg_T_wall_3eqn_mat' is not defined on block core_chan2\nMaterial property 'Hw', requested by 'core_chan2:avg_T_wall_3eqn_mat_face' is not defined on block core_chan2\nMaterial property 'Hw', requested by 'core_chan2:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan2\nMaterial property 'Hw', requested by 'core_chan4:avg_T_wall_3eqn_mat' is not defined on block core_chan4\nMaterial property 'Hw', requested by 'core_chan4:avg_T_wall_3eqn_mat_face' is not defined on block core_chan4\nMaterial property 'Hw', requested by 'core_chan4:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan4\nMaterial property 'Hw', requested by 'core_chan5:avg_T_wall_3eqn_mat' is not defined on block core_chan5\nMaterial property 'Hw', requested by 'core_chan5:avg_T_wall_3eqn_mat_face' is not defined on block core_chan5\nMaterial property 'Hw', requested by 'core_chan5:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan5\nMaterial property 'Hw', requested by 'core_chan6:avg_T_wall_3eqn_mat' is not defined on block core_chan6\nMaterial property 'Hw', requested by 'core_chan6:avg_T_wall_3eqn_mat_face' is not defined on block core_chan6\nMaterial property 'Hw', requested by 'core_chan6:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan6\nMaterial property 'Hw', requested by 'core_chan7:avg_T_wall_3eqn_mat' is not defined on block core_chan7\nMaterial property 'Hw', requested by 'core_chan7:avg_T_wall_3eqn_mat_face' is not defined on block core_chan7\nMaterial property 'Hw', requested by 'core_chan7:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan7\nMaterial property 'Hw', requested by 'core_chan8:avg_T_wall_3eqn_mat' is not defined on block core_chan8\nMaterial property 'Hw', requested by 'core_chan8:avg_T_wall_3eqn_mat_face' is not defined on block core_chan8\nMaterial property 'Hw', requested by 'core_chan8:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan8\nMaterial property 'Hw', requested by 'core_chan11:avg_T_wall_3eqn_mat' is not defined on block core_chan11\nMaterial property 'Hw', requested by 'core_chan11:avg_T_wall_3eqn_mat_face' is not defined on block core_chan11\nMaterial property 'Hw', requested by 'core_chan11:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan11\nMaterial property 'Hw', requested by 'core_chan12:avg_T_wall_3eqn_mat' is not defined on block core_chan12\nMaterial property 'Hw', requested by 'core_chan12:avg_T_wall_3eqn_mat_face' is not defined on block core_chan12\nMaterial property 'Hw', requested by 'core_chan12:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan12\nMaterial property 'Hw', requested by 'core_chan13:avg_T_wall_3eqn_mat' is not defined on block core_chan13\nMaterial property 'Hw', requested by 'core_chan13:avg_T_wall_3eqn_mat_face' is not defined on block core_chan13\nMaterial property 'Hw', requested by 'core_chan13:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan13\nMaterial property 'Hw', requested by 'core_chan14:avg_T_wall_3eqn_mat' is not defined on block core_chan14\nMaterial property 'Hw', requested by 'core_chan14:avg_T_wall_3eqn_mat_face' is not defined on block core_chan14\nMaterial property 'Hw', requested by 'core_chan14:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan14\nMaterial property 'Hw', requested by 'core_chan15:avg_T_wall_3eqn_mat' is not defined on block core_chan15\nMaterial property 'Hw', requested by 'core_chan15:avg_T_wall_3eqn_mat_face' is not defined on block core_chan15\nMaterial property 'Hw', requested by 'core_chan15:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan15\nMaterial property 'Hw', requested by 'core_chan17:avg_T_wall_3eqn_mat' is not defined on block core_chan17\nMaterial property 'Hw', requested by 'core_chan17:avg_T_wall_3eqn_mat_face' is not defined on block core_chan17\nMaterial property 'Hw', requested by 'core_chan17:avg_T_wall_3eqn_mat_neighbor' is not defined on block core_chan17\n\n\nStack frames: 14\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\n2: callMooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, MooseApp*)\n3: /home/linux/projects/moose/framework/libmoose-opt.so.0(+0x88e6bd) [0x7f29990db6bd]\n4: SubProblem::checkBlockMatProps()\n5: FEProblemBase::checkProblemIntegrity()\n6: Action::timedAct()\n7: ActionWarehouse::executeActionsWithAction(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)\n8: ActionWarehouse::executeAllActions()\n9: MooseApp::runInputFile()\n10: MooseApp::run()\n11: main\n12: __libc_start_main\n13: ./flare-opt(+0x33ef) [0x55a07b44d3ef]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\n\nEthan",
                          "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5745439",
                          "updatedAt": "2023-04-27T16:59:44Z",
                          "publishedAt": "2023-04-27T16:59:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "licharlot"
                          },
                          "bodyText": "If you have several heat transfers, the Closures1PhaseNone will calculate an average wall temperature, using an user-defined material Hw.  This is why you have an error if you don't define it. We should probably remove that from the code. Anyways, I think your input file is ok. Is it giving you correct results?\nLise",
                          "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5746535",
                          "updatedAt": "2023-04-27T19:03:43Z",
                          "publishedAt": "2023-04-27T19:03:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Oh, I have the guess that maybe the Hw is some average value.\nThe result is not that good. The fluid is LBE. The average temperature rise is OK. And for the specific flow channel, the temperature rise of center channel should be higher than the temperature rise of side and corner channel. But their temperature rise are nearly the same.\nIf the input file is OK, maybe there're some problems with the new closure.\nAnd I remember one thing that maybe causes the problem:\nThe FlowChannel1Phase need e_from_v_h.But there is no e_from_v_h in LeadBismuthFluidProperties.\nSo I define a e_from_v_h in the LeadBismuthFluidProperties_zxy. But I'm not sure if this is right.\nIs there anyway to replace the e_from_v_h in FlowChannel1Phase by e_from_p_T? If so, we can directly use liquid metal material in FlowChannel1Phase.\nEthan",
                          "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5749553",
                          "updatedAt": "2023-04-28T05:28:17Z",
                          "publishedAt": "2023-04-28T02:58:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "The FlowChannel1Phase need e_from_v_h.But there is no e_from_v_h in LeadBismuthFluidProperties.\nSo I define a e_from_v_h in the LeadBismuthFluidProperties_zxy. But I'm not sure if this is right.\nIs there anyway to replace the e_from_v_h in FlowChannel1Phase by e_from_p_T? If so, we can directly use liquid metal material in FlowChannel1Phase.\n\nThis we can address fairly easily. I'll do it now.",
                          "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5753792",
                          "updatedAt": "2023-04-28T12:13:41Z",
                          "publishedAt": "2023-04-28T12:13:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "I spoke too soon. I looked at the fluid properties. The idea was to invert the existing h_from_v_e relation, but it has no dependence on e whatsoever, which makes no sense to me.",
                          "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5754196",
                          "updatedAt": "2023-04-28T12:50:17Z",
                          "publishedAt": "2023-04-28T12:50:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "If you have an implementation, do it directly in LeadBismuthFluidProperties, not a new class. There's a unit test modules/fluid_properties/unit/src/LeadBismuthFluidPropertiesTest.C that you can use to check your work. Let me know if it doesn't make sense to you. To run it, go into modules/fluid_properties/unit and do make -j6 or whatever and then run that executable. Let me know if anything doesn't make sense.",
                          "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5754216",
                          "updatedAt": "2023-04-28T12:52:58Z",
                          "publishedAt": "2023-04-28T12:52:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "I was discussing LeadBismuthFluidProperties with @GiudGiud , and we decided that LeadBismuthFluidProperties is an incompressible equation of state and doesn't make sense to be used with THM's flow model, which solves equations where v and e are solved independently. Maybe it could work in practice, but it seems fundamentally flawed. Maybe you'd just see stiffness in the equations but you're able to overcome this. It was suggested that maybe you try to use SimpleFluidProperties instead to see if that is able to meet your needs.\nWe're considering adding a check for the compressibility of the equation of state so that the user gets a warning/error.",
                          "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5754886",
                          "updatedAt": "2023-04-28T13:50:08Z",
                          "publishedAt": "2023-04-28T13:50:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can also try the new\nhttps://mooseframework.inl.gov/source/userobjects/TemperaturePressureFunctionFluidProperties.html\nJust be careful when you define the function fluid properties.\nAnd maybe you ll miss some implementations, please let me know",
                          "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5755124",
                          "updatedAt": "2023-04-28T14:10:31Z",
                          "publishedAt": "2023-04-28T14:10:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "@joshuahansel Hello josh, I have the same worry. I defined a e_from_v_h in the LeadBismuthFluidProperties_zxy and it can work successfully in most of cases. But as you say, this success seems fundamentally flawed because of the incompressibility.\n\nIt was suggested that maybe you try to use SimpleFluidProperties instead to see if that is able to meet your needs.\n\nAnd I don't understand how I should use SimpleFluidProperties. If I use SimpleFluidProperties, I still need to define a e_from_v_h to satisfy to need of FlowChannel1Phase, right?",
                          "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5755185",
                          "updatedAt": "2023-04-28T14:16:22Z",
                          "publishedAt": "2023-04-28T14:16:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "You can also try the new\nhttps://mooseframework.inl.gov/source/userobjects/TemperaturePressureFunctionFluidProperties.html\nJust be careful when you define the function fluid properties.\nAnd maybe you ll miss some implementations, please let me know\n\n@GiudGiud Thank you Giud, I haven't seen it before. I think this is a good option.",
                          "url": "https://github.com/idaholab/moose/discussions/24197#discussioncomment-5755219",
                          "updatedAt": "2023-04-28T14:19:34Z",
                          "publishedAt": "2023-04-28T14:19:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}