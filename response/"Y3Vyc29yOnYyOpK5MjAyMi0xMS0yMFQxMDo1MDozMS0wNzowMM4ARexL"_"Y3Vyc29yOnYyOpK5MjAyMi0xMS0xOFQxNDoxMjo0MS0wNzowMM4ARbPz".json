{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMS0xOFQxNDoxMjo0MS0wNzowMM4ARbPz"
    },
    "edges": [
      {
        "node": {
          "title": "Questions about thermal hydraulics module",
          "author": {
            "login": "Raven-pro"
          },
          "bodyText": "Hello developers!\nI am using the TH module to simulate the conjugate heat transfer process of the 1-D single-phase flow in vertical pipes.\nAs in tutorial 02, when implementing the conjugate heat transfer, the power is set to be constant everywhere (I also want to ask about what tot_power means in the input file by the way, does that mean power of the whole rod or just of that single element of the rod)\nBut I want to make the power distribution different, like individually setting the power of each node, Is there any way to achieve that?",
          "url": "https://github.com/idaholab/moose/discussions/22763",
          "updatedAt": "2022-11-24T12:41:31Z",
          "publishedAt": "2022-11-20T16:01:14Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou may specify the \"power_shape_function\" parameter in the HeatSourceFromTotalPower to have a shape.\nThis should be the name of a Function, which may have any spatial and time dependence.\nThe total power is specified in a TotalPower component\nthe heat source component uses this TotalPower component to know how much power to generate\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22763#discussioncomment-4189150",
                  "updatedAt": "2022-11-20T16:24:31Z",
                  "publishedAt": "2022-11-20T16:24:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "recover",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "If I use --recover (checkpoints and split mesh), how does the recover read the input file? Specifically, I read a file using PiecewiseMultilinear in the input file. If I change the file that is read by PiecewiseMultilinear, will the values from the new file be read in on the recover, or are the old values stored and be used? What this really getting to is trying to use a previously equilibrated run (using split-mesh) as a starting point for a new run, but with changed driving function read by PiecewiseMultilinear.\nIt will be awesome to get a restart capability with using Nemesis split files as starting point....",
          "url": "https://github.com/idaholab/moose/discussions/22656",
          "updatedAt": "2022-11-20T15:44:19Z",
          "publishedAt": "2022-11-10T20:50:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe input file is not saved to the recover checkpoint. It is read again. The checkpoint provides solution vectors, which if the input file is compatible with, will be used to recover the solution.\nRecover is really meant to start the same exact simulation, except it crashed for X reason the first time.\nI think you may want to look into checkpoint restart, by specifying the restart_file_base in the Problem.\nYou may change the data file from PiecewiseMultilinear when performing any kind of restart or recover.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22656#discussioncomment-4184555",
                  "updatedAt": "2022-11-19T15:17:50Z",
                  "publishedAt": "2022-11-19T15:17:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "heinono1"
                          },
                          "bodyText": "Thanks, Guillaume!",
                          "url": "https://github.com/idaholab/moose/discussions/22656#discussioncomment-4188960",
                          "updatedAt": "2022-11-20T15:44:18Z",
                          "publishedAt": "2022-11-20T15:44:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error writing coordinates to Exodus file.",
          "author": {
            "login": "KangChenRui"
          },
          "bodyText": "Hello everyone!\nI first encountered the following error yesterday.\n\nThe output module I set is shown in the figure below\uff1a\n\nThanks for your help!\nChenRui",
          "url": "https://github.com/idaholab/moose/discussions/22727",
          "updatedAt": "2022-11-20T04:53:29Z",
          "publishedAt": "2022-11-17T01:07:21Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid anything else happened?\nDid you run out of disk space?\nWas the file modified during the simulation?\nPS: please avoid screenshots in the future, this could all have been copy pasted as text\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22727#discussioncomment-4179234",
                  "updatedAt": "2022-11-18T17:33:20Z",
                  "publishedAt": "2022-11-18T17:33:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "do you consistently get this error?",
                          "url": "https://github.com/idaholab/moose/discussions/22727#discussioncomment-4179237",
                          "updatedAt": "2022-11-18T17:33:37Z",
                          "publishedAt": "2022-11-18T17:33:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KangChenRui"
                          },
                          "bodyText": "Hello!\nI ran out of disk space.\nThanks a lot!",
                          "url": "https://github.com/idaholab/moose/discussions/22727#discussioncomment-4186827",
                          "updatedAt": "2022-11-20T04:53:29Z",
                          "publishedAt": "2022-11-20T04:53:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to plot negative axis in Paraview",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hello,\nMy question is:\n\nConsider the attached input file and the paraview result, how do i get the result to plot from [-1,1] instead of the attached output result of [0,2] that paraview gave me?\n\n----Paraview result plotting [0,2]-----------------\n\n---------Desired output is over [-1,1]----------------\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 64\n  xmin = -1\n  xmax = 1\n\n[]\n\n[Variables]\n  [v]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [flux_v]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[Kernels]\n  [diffusion]\n    type = MatDiffusion\n    variable = v\n    diffusivity = 1\n  []\n[]\n\n[AuxKernels]\n  [fluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = 1\n    variable = flux_v\n    diffusion_variable = v\n    component = x\n  []\n[]\n\n[BCs]\n   [leftBC] \n    type = DirichletBC\n    variable = v\n    boundary = 'left'\n    value = 0\n  []\n\n  [rightBC] \n    type = NeumannBC\n    variable = v\n    boundary = 'right'\n    value = 3\n  []\n[]\n\n\n[Executioner]\n  type = Steady\n  solve_type = 'PJFNK'\n[]\n\n[Outputs]\n  exodus = true\n  #csv = true\n  console = true\n[]\n\n\n\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/22609",
          "updatedAt": "2023-01-03T23:10:11Z",
          "publishedAt": "2022-11-07T17:09:27Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is more of a paraview topic than MOOSE.\nThe axis settings in paraview may be modified, the coordinates may be transformed as well, there isnt a single solution\nOn the left properties panel when you have the plot up, you may select a different X-axis, which could be data modified in any way you want. make sure the 'use index as x-axis' in not checked\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22609#discussioncomment-4184568",
                  "updatedAt": "2022-11-19T15:22:39Z",
                  "publishedAt": "2022-11-19T15:22:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to parse AuxVariables to a vector?",
          "author": {
            "login": "Minjiang-Zhu"
          },
          "bodyText": "As described above.",
          "url": "https://github.com/idaholab/moose/discussions/22753",
          "updatedAt": "2022-11-19T15:08:18Z",
          "publishedAt": "2022-11-18T19:33:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nwhat do you mean?\nUse it in a parsed expression? That\u2019s possible for the ParsedMaterial or the ParsedAux\nguillaum",
                  "url": "https://github.com/idaholab/moose/discussions/22753#discussioncomment-4181231",
                  "updatedAt": "2022-11-18T22:55:58Z",
                  "publishedAt": "2022-11-18T22:55:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Minjiang-Zhu"
                  },
                  "bodyText": "I use a vector function and apply ParsedVectorFunction to fix it.",
                  "url": "https://github.com/idaholab/moose/discussions/22753#discussioncomment-4182523",
                  "updatedAt": "2022-11-19T04:14:00Z",
                  "publishedAt": "2022-11-19T04:13:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok I saw the other post. Please consolidate on a single post in the future.",
                          "url": "https://github.com/idaholab/moose/discussions/22753#discussioncomment-4184519",
                          "updatedAt": "2022-11-19T15:08:18Z",
                          "publishedAt": "2022-11-19T15:08:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Apply functions to a vector auxvariable",
          "author": {
            "login": "Minjiang-Zhu"
          },
          "bodyText": "I have two scalar functions and I want to apply them to the components of a vector auxvariable, what should I do? Please notice the functions are not simply functions of x, y, z, and t (they are read from the solution file of the previous step and then are modified a bit).",
          "url": "https://github.com/idaholab/moose/discussions/22752",
          "updatedAt": "2023-01-20T18:53:25Z",
          "publishedAt": "2022-11-18T19:05:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Minjiang-Zhu"
                  },
                  "bodyText": "I know there is an auxkernal called 'VectorFunctionAux' which can assign a vector-function to a vector auxvariable. If someone knows how to combine two scalar functions into a vector function, that will also help.",
                  "url": "https://github.com/idaholab/moose/discussions/22752#discussioncomment-4179908",
                  "updatedAt": "2022-11-18T19:13:51Z",
                  "publishedAt": "2022-11-18T19:13:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nVectorFunctionAux will let you set the auxiliary variable using a Function that has a vectorValue() routine. It does NOT parse postprocessor names or scalar variables directly. A MooseParsedVectorFunction can do that upstream of the auxkernel.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22752#discussioncomment-4184516",
                  "updatedAt": "2022-11-19T15:07:15Z",
                  "publishedAt": "2022-11-19T15:07:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error Using AnnularMesh",
          "author": {
            "login": "zsren"
          },
          "bodyText": "Hi,\nI am having receiving error message while using annular mesh. Could you please help on this? Thanks so much!\nZR\n*** ERROR ***\nEach subdomain must contain at least one Kernel.\nThe following block(s) lack an active kernel: 1 \n\nStack frames: 11\n0: 0   libmesh_opt.0.dylib                 0x000000010ae223a3 libMesh::print_trace(std::__1::basic_ostream<char, std::__1::char_traits<char> >&) + 1091\n1: 1   libmoose-opt.0.dylib                0x000000010a2b2a07 moose::internal::mooseErrorRaw(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >) + 823\n2: 2   libmoose-opt.0.dylib                0x00000001094535b1 void mooseError<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >&&) + 257\n3: 3   libmoose-opt.0.dylib                0x0000000109e29f47 NonlinearSystemBase::checkKernelCoverage(std::__1::set<unsigned short, std::__1::less<unsigned short>, std::__1::allocator<unsigned short> > const&) const + 4471\n4: 4   libmoose-opt.0.dylib                0x0000000109942834 FEProblemBase::checkProblemIntegrity() + 1572\n5: 5   libmoose-opt.0.dylib                0x0000000109cc339f ActionWarehouse::executeActionsWithAction(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) + 1359\n6: 6   libmoose-opt.0.dylib                0x0000000109cf2ed8 ActionWarehouse::executeAllActions() + 280\n7: 7   libmoose-opt.0.dylib                0x000000010a2839f2 MooseApp::runInputFile() + 98\n8: 8   libmoose-opt.0.dylib                0x000000010a27ef40 MooseApp::run() + 960\n9: 9   in718-opt                           0x00000001083ffbe4 main + 132\n10: 10  libdyld.dylib                       0x00007fff6bdb7cc9 start + 1\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor",
          "url": "https://github.com/idaholab/moose/discussions/22748",
          "updatedAt": "2022-11-19T10:10:55Z",
          "publishedAt": "2022-11-18T11:53:21Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe mesh contains a block with no kernels.\nVery likely, the variables or the kernels are block restricted, and your mesh contains several blocks. Some of these blocks are not covered by the block restriction you are using\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22748#discussioncomment-4179112",
                  "updatedAt": "2022-11-18T17:17:44Z",
                  "publishedAt": "2022-11-18T17:17:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you could paste your input here if you dont find the block restriction issue",
                          "url": "https://github.com/idaholab/moose/discussions/22748#discussioncomment-4179113",
                          "updatedAt": "2022-11-18T17:18:00Z",
                          "publishedAt": "2022-11-18T17:17:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zsren"
                  },
                  "bodyText": "Hi Guillaume\uff0c\nThanks for your prompt reply and helpful suggestions! I found the issue and it works now.\nZR",
                  "url": "https://github.com/idaholab/moose/discussions/22748#discussioncomment-4183420",
                  "updatedAt": "2022-11-19T10:10:52Z",
                  "publishedAt": "2022-11-19T10:10:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How does Cohesive zone actually works? for modelling stress with faults",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nThe documentation and examples for CZM are quite insufficient to me, I'm not sure how to implement it to my problem.\nhttps://mooseframework.inl.gov/syntax/Modules/TensorMechanics/CohesiveZoneMaster/\nLet's say the example below.\nthe objective of the simulation is to look into stress/strain change over mining steps (similar to coal mining problem)\n\nBlock = blockID saperation\nRed = faults OR cohesive zone (cohesive element in Abaqus), as I read from 'CohesiveZoneMaster', BreakMeshByBlockGenerator will duplicate the note at the blocks above and below the fault line (red). Can I basically just import a similar Abaqus mesh without having to use BreakMeshByBlockGenerator?\nThen I am not sure how does it work, will CZMInterfaceKernel automatically pick up these fault lines?\nas I see from the example, I only see this ...\n[Modules/TensorMechanics/CohesiveZoneMaster]\n  [./czm1]\n    boundary = 'interface'\n    displacements = 'disp_x disp_y disp_z'\n  [../]\n[]\n\nThen the properties of CohesiveZone is later defined under [Materials] block\n  [./czm_3dc]\n    type = SalehaniIrani3DCTraction\n    boundary = 'interface'\n    normal_gap_at_maximum_normal_traction = 1\n    tangential_gap_at_maximum_shear_traction = 0.5\n    maximum_normal_traction = 100\n    maximum_shear_traction = 70\n    displacements = 'disp_x disp_y disp_z'\n  [../]\n\nand that's pretty much it, I am not sure if MOOSE's czm is applicable to my problem, would be nice if we have cohesive elements like Abaqus instead, so we basically can identify the faults from an input mesh.\nIt would be nice if someone could shed some light. Thank you\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/18240",
          "updatedAt": "2022-11-21T22:34:04Z",
          "publishedAt": "2021-07-02T05:46:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Just wondering if anyone has ever implemented CZM with MOOSE at all?",
                  "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-977205",
                  "updatedAt": "2022-06-08T09:10:44Z",
                  "publishedAt": "2021-07-08T01:34:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I'm not sure what you mean by \"like Abaqus\". Moose can definitely import a mesh from Abaqus .inp file though. Then BreakMeshByBlockGenerator should work.\n@arovinelli knows more about czm in moose.",
                  "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1015953",
                  "updatedAt": "2022-06-08T09:10:45Z",
                  "publishedAt": "2021-07-17T11:42:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks for your reply @hugary1995.\nAs far as I know, Abaqus use cohesive elements but MOOSE use cohesive interfaces. Hence, I'm not sure if I import mesh with cohesive elements from Abaqus, will MOOSE czm automatically recognise it as an interface OR I have to use BreakMeshByBlockGenerator in order to generate interfaces and remove cohesive elements from the mesh.\n@arovinelli I'm also following your finite strain CZM, looking forward to using it!",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1016050",
                          "updatedAt": "2022-06-08T09:10:53Z",
                          "publishedAt": "2021-07-17T12:45:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I see. I think you'll have to remove those cohesive elements in the Abaqus mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1016075",
                          "updatedAt": "2022-06-08T09:10:53Z",
                          "publishedAt": "2021-07-17T13:02:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@Traiwit It is definitely applicable to your problem as it's very similar to what I use it for.\nThe \"problem\" is setting up the mesh correctly. Unfortunately you can't use an ABAQUS mesh with cohesive elements directly for this problem. You will need to remove the ABAQUS cohesive elements, assign different \"block_ids\" to the different regions of your mesh around which you want cohesive interfaces, you could use cubit to achieve this. Then in your input file use break mesh by block generator to split the mesh. It will create a boundary called interface around all the blocks. That is the boundary representing the cohesive zone.\nSo ideally you should start with a mesh that looks like the figure on the left.\n\nThe cohesive interface, (teh boundary named interface in MOOSE) will be like the on on the right.\nWhen you specify Modules/TensorMechanics/CohesiveZoneMaster/cmz1/boundary=interface will tell MOOSE to add cohesive interface kernels on the boundary called interface, that's how the system work, no much more to do. Finally, in the materials you also specify the boundary=interface .  Nothing more is needed to make the simulation run.\nHope this helps, if you have more questions just let me know",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1016222",
                          "updatedAt": "2022-06-08T09:10:53Z",
                          "publishedAt": "2021-07-17T14:37:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @arovinelli Thank for your reply!\nI've tried to work with this testing mesh (attached), there are 2 blocks but for some reason, BreakMeshByBlockGenerator doesn't seem to work, it does not create an interface between these 2 blocks.\n[mesh]\n  type = FileMeshGenerator\n   file = converting_in.e\n   construct_side_list_from_node_list=true\n   []\n        [./breakmesh]\n          input = mesh\n          type = BreakMeshByBlockGenerator\n          split_interface=true\n          show_info = true\n        [../]\n  show_info = true\n  allow_renumbering=false\n\nNot sure if I miss anything. is there a limitation that I'm not aware of? for example, predefined duplicated nodes etc...\nKind regards,\nTraiwi\n\nmesh_CZM_test.zip",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032649",
                          "updatedAt": "2022-07-06T19:09:41Z",
                          "publishedAt": "2021-07-21T13:52:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Also another question, how would you work around with such a fault (attached figure), where the CZM is right in the middle of the geometry",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032656",
                          "updatedAt": "2022-07-06T19:09:58Z",
                          "publishedAt": "2021-07-21T13:54:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "Hi @arovinelli Thank for your reply!\nI've tried to work with this testing mesh (attached), there are 2 blocks but for some reason, BreakMeshByBlockGenerator doesn't seem to work, it does not create an interface between these 2 blocks.\n[mesh]\n  type = FileMeshGenerator\n   file = converting_in.e\n   construct_side_list_from_node_list=true\n   []\n        [./breakmesh]\n          input = mesh\n          type = BreakMeshByBlockGenerator\n          split_interface=true\n          show_info = true\n        [../]\n  show_info = true\n  allow_renumbering=false\n\nNot sure if I miss anything. is there a limitation that I'm not aware of? for example, predefined duplicated nodes etc...\nKind regards,\nTraiwi\n\nmesh_CZM_test.zip\n\nyes the mesh should not already have duplicated nodes, otherwise the algorithm will not find neighbors. That is exactly what is happening in your case.\nFor your second question is a bit trickier but the same principle apply. One way of doing it is to use the BreakMeshByBlockGenerator block_pair option see here.  That would require careful design of domains id.\nI guess what we should really do in your case is to implement a join mesh algorithm such that you could start from a mesh from which you have removed cohesive elements... If you fill this might be an important tool could you open a ticket requesting for it?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032805",
                          "updatedAt": "2022-07-06T19:10:06Z",
                          "publishedAt": "2021-07-21T14:20:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Hi @arovinelli Thank for your reply!\nI've tried to work with this testing mesh (attached), there are 2 blocks but for some reason, BreakMeshByBlockGenerator doesn't seem to work, it does not create an interface between these 2 blocks.\n[mesh]\n  type = FileMeshGenerator\n   file = converting_in.e\n   construct_side_list_from_node_list=true\n   []\n        [./breakmesh]\n          input = mesh\n          type = BreakMeshByBlockGenerator\n          split_interface=true\n          show_info = true\n        [../]\n  show_info = true\n  allow_renumbering=false\n\nNot sure if I miss anything. is there a limitation that I'm not aware of? for example, predefined duplicated nodes etc...\nKind regards,\nTraiwi\n\nmesh_CZM_test.zip\n\nyes the mesh should not already have duplicated nodes, otherwise the algorithm will not find neighbors. That is exactly what is happening in your case.\nFor your second question is a bit trickier but the same principle apply. One way of doing it is to use the BreakMeshByBlockGenerator block_pair option see here. That would require careful design of domains id.\nI guess what we should really do in your case is to implement a join mesh algorithm such that you could start from a mesh from which you have removed cohesive elements... If you fill this might be an important tool could you open a ticket requesting for it?\n\nIf your mesh already has duplicated nodes along the interface, there is no reason to use BreakMeshByBlockGenerator again to create the interface.\nFor your second question, if you still want to use CZM, maybe another option is to implement a new MeshGenerator that uses a lower dimension mesh (i.e. fracture surface) to create the CZM interface instead of using the blocks.\nFor your application, are you trying to model crack propagation or just model the discrete fracture surfaces?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032894",
                          "updatedAt": "2022-07-06T19:10:24Z",
                          "publishedAt": "2021-07-21T14:33:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @jiangwen84 @arovinelli thank you for your reply\nI am working on mine modelling in order to produce stress field, displacements, and damage (plastic strain) v time.\nThe faults within the mesh are pre-defined (Abaqus with cohesive elements).\nis there a way to manually generate the interface between the two blocks with mesh that has duplicated nodes? or the only way to work around this is to merge them back and apply BreakMeshByBlockGenerator\nIt seems like BreakMeshByBlockGenerator can be split into 2 sub-algorithms (from the attached figure).",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032996",
                          "updatedAt": "2022-07-06T19:10:41Z",
                          "publishedAt": "2021-07-21T14:52:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Yes, we need to start with a fully connected mesh and then apply BreakMeshByBlockGenerator to create the interface and reconstruct the connectivity. The reason for that is that we need to use the neighbor information from the original mesh in our InterfaceCZM kernel.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1033622",
                          "updatedAt": "2022-07-06T19:10:38Z",
                          "publishedAt": "2021-07-21T15:45:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@jiangwen84 @arovinelli sorry gents, I still can't get over this\nI'm checking BreakMeshByBlockGenerator.C I see it does 3 things, 1) making new duplicated nodes 2) attach the nodes back to the elements and then 3) create the cohesive interface. I only need to extract the last part (3) from the script.\nie I want to create a script that can generate cohesive interface from any of the available data listed below:\nWhat I have available from Abaqus mesh are:\n\nduplicated nodes (list of node pairs)\nlist of surface pairs\nlist of element pairs\n\n\nis it possible to use any of these in order to generate the cohesive interface? I'm not very good with C++ it would be very helpful if you could point out which section of BreakMeshByBlockGenerator.C I should take out?\nThank you very much, much appreciated.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1042118",
                          "updatedAt": "2022-07-06T19:10:40Z",
                          "publishedAt": "2021-07-23T12:31:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "arovinelli"
                  },
                  "bodyText": "@jiangwen84 you need to reconstruct the connectivity somehow... as far as I know, there is not a generator available that start from a split mesh and reconstruct the connectivity or do we?",
                  "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032921",
                  "updatedAt": "2022-06-08T09:10:53Z",
                  "publishedAt": "2021-07-21T14:39:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@jiangwen84 you need to reconstruct the connectivity somehow... as far as I know, there is not a generator available that start from a split mesh and reconstruct the connectivity or do we?\n\n@arovinelli  Yes, we need to implement new generators. The current CZM interface generator uses blocks to define the interface location. A second option I suggest is to use lower dimension mesh to define the interface. But we need to make sure that lower dimension mesh sits on the element edges of the computation mesh. Either way we need reconstruct the connectivity.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032982",
                          "updatedAt": "2022-06-08T09:10:55Z",
                          "publishedAt": "2021-07-21T14:49:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@jiangwen84 you need to reconstruct the connectivity somehow... as far as I know, there is not a generator available that start from a split mesh and reconstruct the connectivity or do we?\n\n@arovinelli Yes, we need to implement new generators. The current CZM interface generator uses blocks to define the interface location. A second option I suggest is to use lower dimension mesh to define the interface. But we need to make sure that lower dimension mesh sits on the element edges of the computation mesh. Either way we need reconstruct the connectivity.\n\nIf nodes are coincident wouldn't be easier simply to look for element with coincident faces but not sharing all the nodes? once we find the faces we simply add them to a boundary, still it would be difficult to discern between different surfaces...",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1033011",
                          "updatedAt": "2022-06-08T09:10:55Z",
                          "publishedAt": "2021-07-21T14:56:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "chunhuizhao478"
                  },
                  "bodyText": "I think this question is relevant to our problem, so I would like to post my questions here: Is there a way for CZM to create/identify embedded cracks? I don't think the \"BreakMeshByBlockGenerator\" is able to handle this since there is no actual \"block\" between the crack interfaces. Or we need to get our hand dirty to pre-split, provide the list and write them in the code as suggested by arovinelli?",
                  "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3974914",
                  "updatedAt": "2022-10-26T22:28:57Z",
                  "publishedAt": "2022-10-26T22:28:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "If you mean pre-existing embedded cracks, at the moment we only have two mesh generators for generating cohesive interfaces: BreakMeshByBlockGenerator and ExplodeMeshGenerator. You need to either predefine the subdomains so that you can use the existing mesh generators to generate the embedded cracks, or write your own CZM interface generator.\nIf you want to model actual crack nucleation and propagation, you'll want to use the ExplodeMeshGenerator and apply the CZM model everywhere, as every element-element pair is a potential nucleation site.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3974974",
                          "updatedAt": "2022-10-26T22:39:34Z",
                          "publishedAt": "2022-10-26T22:39:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks for your reply. For the current stage we would like to introduce multiple pre-existing cracks. To use \"BreakMeshByBlockGenerator\", one needs to set different block-id to either side of the crack. For the case where it is not a through crack, what would be the best way to assign block-id? Could subdomains just surrounding the crack be easily identified?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3975178",
                          "updatedAt": "2022-10-26T22:54:25Z",
                          "publishedAt": "2022-10-26T22:54:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Nice figure. How are you generating the mesh with the element edges aligned along the crack? If this mesh is generated using an external meshing tool, there should be an easy way to identify the blocks based on the starting and ending points of the pre-existing cracks.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3975300",
                          "updatedAt": "2022-10-26T23:04:24Z",
                          "publishedAt": "2022-10-26T23:04:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks. If I use Gmsh, after creating the crack, I need to find a way to identify elements ID that surround the crack, then pass the information into MOOSE and assign different ID for elements on either side, then break the crack interface, is this correct?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3984408",
                          "updatedAt": "2022-10-27T17:25:37Z",
                          "publishedAt": "2022-10-27T17:25:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Btw, do you suggest using Gmsh or CUBIT as external mesh generator? Which one would be better?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3984439",
                          "updatedAt": "2022-10-27T17:27:41Z",
                          "publishedAt": "2022-10-27T17:27:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Thanks. If I use Gmsh, after creating the crack, I need to find a way to identify elements ID that surround the crack, then pass the information into MOOSE and assign different ID for elements on either side, then break the crack interface, is this correct?\n\nThat's correct, although I'm not sure how to conditionally assign a physical surface in gmsh, based on my limited experience with gmsh.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3986835",
                          "updatedAt": "2022-10-27T22:39:55Z",
                          "publishedAt": "2022-10-27T22:39:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Btw, do you suggest using Gmsh or CUBIT as external mesh generator? Which one would be better?\n\ngmsh is free while cubit probably has more features. Your institution may be hosting a license of cubit.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3986839",
                          "updatedAt": "2022-10-27T22:41:06Z",
                          "publishedAt": "2022-10-27T22:41:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "BTW, generating a CZM interface based on starting and ending points of a line segment is also useful for us, so I may be able to write a mesh generator to do that later this year. You are welcome to create an issue to help me track that",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3986848",
                          "updatedAt": "2022-10-27T22:43:23Z",
                          "publishedAt": "2022-10-27T22:43:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "\"there should be an easy way to identify the blocks based on the starting and ending points of the pre-existing cracks.\" Just want to make sure if there is another way, all I can think of right now is write scripts and play around in MSH file to get the information, but it is not easy to do.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3986865",
                          "updatedAt": "2022-10-27T22:46:54Z",
                          "publishedAt": "2022-10-27T22:46:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "It might be easier to use the gmsh python api.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3987007",
                          "updatedAt": "2022-10-27T23:23:07Z",
                          "publishedAt": "2022-10-27T23:23:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "chunhuizhao478"
                  },
                  "bodyText": "I would like to ask for the reference article if possible for cohesive zone model implementation in moose (It is mentioned that the cohesive zone model is implemented using a discrete Galerkin approach).",
                  "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4131864",
                  "updatedAt": "2022-11-14T05:32:02Z",
                  "publishedAt": "2022-11-14T05:32:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "For small strain, it is very simple DG-like constraint. For large strain, this report https://www.osti.gov/biblio/1658575 is a good one. For mesh generator, see https://doi.org/10.1016/j.advengsoft.2014.04.002",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4131951",
                          "updatedAt": "2022-11-14T05:59:18Z",
                          "publishedAt": "2022-11-14T05:59:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks for your reply, for now we are dealing with small strain, but would like to gain more idea behind the model, could you direct me to similar DG-like constraint articles? Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4141277",
                          "updatedAt": "2022-11-14T22:52:19Z",
                          "publishedAt": "2022-11-14T22:52:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Did you read the mesh generator paper? It seems that they have listed a few reference in their introduction section. If you cannot find what you need, let us know.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4141483",
                          "updatedAt": "2022-11-14T23:37:35Z",
                          "publishedAt": "2022-11-14T23:37:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi, I checked the mesh generator paper, but I'm not sure that is the same idea in the cohesive zone model implementation in MOOSE: The papers listed there are about hybrid DG/CZM methods, where \"zero thickness interface element\" is still introduced, but in the description of MOOSE, there is no cohesive element introduced in the formulation at all. So could you direct me to more specific articles where MOOSE adopts? Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4150821",
                          "updatedAt": "2022-11-15T21:44:00Z",
                          "publishedAt": "2022-11-15T21:43:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think if you introduce a discontinuity at an element edge (where this element is connected to its neighbor), that edge can be viewed as the so-called zero thickness element between this element and its neighbor.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4151109",
                          "updatedAt": "2022-11-15T22:27:09Z",
                          "publishedAt": "2022-11-15T22:27:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks, these are very helpful. I'll look into the reference articles.\nTo be more specific, the attempt to explode every element-element boundary as a CZM and study crack nucleation and propagation bring up some questions about its fundamentals:\n\nWhether the jump [[u]] is evaluated at quadrature point of interface element (plus/mins side) or nodal points?\nHow are the nodes sharing the same coordinate (after node duplication) interact with each other if one surface has experience tangential/normal jump and pass the motion forward to other surfaces? Take the three middle nodes in the figure for example.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4151283",
                          "updatedAt": "2022-11-15T22:59:54Z",
                          "publishedAt": "2022-11-15T22:59:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The jump is computed at qps on element edges. I don't quite get your 2nd question. Could you help me understand what you mean by \"pass the motion forward to other surfaces\"?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4152116",
                          "updatedAt": "2022-11-16T01:40:35Z",
                          "publishedAt": "2022-11-16T01:40:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks, I\u2019m just wondering if there is some continuity relations among the three nodes in the center so that if one surface has tangential jump, the other two surfaces can be affected (like a rupture propagates towards to other surfaces) or put it in the other way, how is cohesive zone model handle crack propagation in this case.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4152309",
                          "updatedAt": "2022-11-16T01:58:06Z",
                          "publishedAt": "2022-11-16T01:58:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Sorry if this may sound confusing, I try to understand how element cohesive zone surface interact with its neighbors",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4152331",
                          "updatedAt": "2022-11-16T02:00:35Z",
                          "publishedAt": "2022-11-16T02:00:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi guys, I still don't see the current MOOSE CZM and BreakMeshByBlockGenerator could handle more complex systems such as the one below:\n\n\nThese are C3D6 elements embedded within C3D4 mesh and connecting the node pair via NodalConstraint (works well with hydro/porousflow problems, but too expensive for mech problems)\nI still believe introducing cohesive elements (zero thickness elements) still the way to go in the case that we already have pre-defined faults/cracks in the system.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4173486",
                          "updatedAt": "2022-11-18T03:35:19Z",
                          "publishedAt": "2022-11-18T03:35:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Tensor Mechanics and Heat Conduction coupling",
          "author": {
            "login": "krb-nantes"
          },
          "bodyText": "Hi everyone!\nI am currently trying to make a code using Tensor Mechanics Action to calculate the SED for a piece of Zircaloy-4 with a temperature transient. I will add at the end the input for Initial Conditions, Boundary Conditions, TensorMechanics/Master, and Materials block I used for this code.\nWhen I do the simulation using the same mesh, but with only Heat Conduction or only Tensor Mechanics, both work, just when I try to put them together it does not converge anymore.\n*Note 1: If I do not use the \"use_displaced_mesh = true\" it returns a negative temperature in some elements in ZryThermal material.\n*Note 2: I tried to add the ZryThermalExpansionMATPROEigenstrain in Material, but it did not change.\nIf anyone has any idea on how could I solve this problem, I appreciate the help!\n**INPUT**\n[Functions]\n####### FUNCTION FOR HEAT CONDUCTION PROBLEM #########\n  [temp_IC]\n    type = ParsedFunction\n    value = 588.70              #-35561*x+643.15 Initial T constant or as a gradient, does not change convergency.\n  []\n  [inner_temperature_profile]\n    type = PiecewiseLinear\n    format = columns\n    xy_data = '0                622.26\n               9616346.107      622.36\n               10974285.48      441.15\n               11449485.48      293.15'\n  []\n  [outer_temp_profile]\n    type = PiecewiseLinear\n    format = columns\n    xy_data = '0                588.70\n               9616346.107      588.70\n               10974285.48      293.15\n               11449485.48      293.15'\n  []\n####### FUNCTION FOR TENSOR MECHANICS #########  \n  [inner_disp_profile]\n    type = PiecewiseBilinear\n    axis = 1\n    data_file = inner_disp_x.csv\n  []\n  [outer_disp_profile]\n    type = PiecewiseBilinear\n    axis = 1\n    data_file = outer_disp_x.csv\n  []\n[]\n\n[ICs]\n    [temp_ic]\n        type = FunctionIC\n        variable = temp\n        function = temp_IC\n    []\n[]\n\n[BCs]\n########### BC FOR HEAT CONDUCTION ##########\n  [outer_temp]\n    type = FunctionDirichletBC\n    variable = temp\n    boundary = 'right spallation'\n    function = outer_temp_profile\n    use_displaced_mesh = true\n    preset = false\n  []\n  [inner_temperature]\n    type = FunctionDirichletBC\n    variable = temp\n    boundary = 'left'\n    function = inner_temperature_profile\n    use_displaced_mesh = true\n    preset = false\n  []\n########### BC FOR TENSOR MECHANICS ##########\n [inner_disp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = 'left'\n    function = inner_disp_profile\n    preset = false\n    use_displaced_mesh = true\n  []\n  [outer_disp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = 'right'\n    function = outer_disp_profile\n    preset = false\n    use_displaced_mesh = true\n  []\n  [no_disp_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0.0\n    preset = false\n    use_displaced_mesh = true\n  []\n[]\n[Modules/TensorMechanics/Master]\n    [tensor]                        # this division is necessary\n        strain = SMALL\n        incremental = true\n        add_variables = true\n        generate_output = 'stress_xx stress_yy stress_zz vonmises_stress hoop_stress strain_xx strain_yy strain_zz hoop_strain'\n        planar_formulation = PLANE_STRAIN\n    []\n[]\n\n[Materials]\n########### MATERIAL FOR HEAT CONDUCTION #####\n  [clad_thermal]\n    type = ZryThermal\n    block = '0'\n    temperature = temp\n    use_displaced_mesh = true\n  []\n  [density_clad]\n    type = Density\n    block = '0'\n    density = 6550                         # kg/m3\n  []\n  [oxide_conduction]                    # delta-ZrH1.66 @ 500K\n    type = GenericConstantMaterial\n    prop_values =  '1.675 0'            # W/mK\n    prop_names = 'thermal_conductivity thermal_conductivity_dT'\n    block = '1'\n    use_displaced_mesh = true\n  []\n  [oxide_density]\n    type = GenericConstantMaterial\n    prop_values = 6150                  # kg/m3 from AZOMaterials\n    block = '1'\n    prop_names = 'density'\n  []\n  [oxide_cp]\n    type = GenericConstantMaterial\n    prop_values = 540                   # J/kgK\n    block = '1'\n    prop_names = 'specific_heat'\n    use_displaced_mesh = true\n  []\n########### MATERIAL FOR TENSOR MECHANICS #########\n  [strain_energy_density]\n    type = StrainEnergyDensity\n    incremental = true\n    use_displaced_mesh = true\n    block = '0 1'\n  []\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 99e+9 \n    poissons_ratio = 0.3\n    block = '0 1'\n    use_displaced_mesh = true\n  []  \n  [elastic_stress]\n    type = ComputeMultipleInelasticStress\n    inelastic_models = 'isoplas'\n    block = '0 1'\n  []\n  [isoplas]\n    type = IsotropicPlasticityStressUpdate\n    yield_stress = 381e6 \n    hardening_constant = 0.0\n    use_displaced_mesh = true\n  []\n[]\n\n**CSV FILES**\n_outer_disp_x:_\n0,0.003736,0.007472,0.011207\n0,0,0,0,0\n9616346.107,1.29E-06,1.28E-06,1.27E-06,1.27E-06\n10974285.48,-1.08E-05,-1.08E-05,-1.08E-05,-1.08E-05\n11449485.48,-1.20E-05,-1.20E-05,-1.20E-05,-1.20E-05\n\n_inner_disp_x:_\n0,0.003736,0.007472,0.011207\n0,0,0,0,0\n9616346.107,1.72E-06,1.70E-06,1.69E-06,1.69E-06\n10974285.48,-9.20E-06,-9.20E-06,-9.20E-06,-9.20E-06\n11449485.48,-1.05E-05,-1.05E-05,-1.05E-05,-1.05E-05",
          "url": "https://github.com/idaholab/moose/discussions/22348",
          "updatedAt": "2023-01-04T00:00:39Z",
          "publishedAt": "2022-10-10T17:55:00Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "What type of simulation are you trying to do?  If you are trying to do a Steady calculation - you may want to use Transient instead... and ramp up the temperature / boundary conditions.\nYou can also try to \"decouple\" these - but still solve the coupled problem.  Set temperature as an AuxiliaryVariable and then give it a constant value that is reasonable... and couple that in as temperature in your TensorMechanics problem and make sure that solves.  You may just have an unreasonable material property somewhere that depends on temperature.",
                  "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3843445",
                  "updatedAt": "2022-10-10T23:18:57Z",
                  "publishedAt": "2022-10-10T23:18:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "Also: you have several HUGE constants in your TensorMechanics.  That will make it tough to converge the heat conduction problem (due to the residual / jacobian entries being so much smaller).  You may want to try scaling / automatic scaling.  The scaling parameters are in the Executioner block... you can see them at the bottom of the page here: https://mooseframework.inl.gov/source/executioners/Transient.html",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3843458",
                          "updatedAt": "2022-10-10T23:21:37Z",
                          "publishedAt": "2022-10-10T23:21:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Also why did you set preset = false in all the BCs? which example input did you work from?",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3875471",
                          "updatedAt": "2022-10-14T03:50:43Z",
                          "publishedAt": "2022-10-14T03:50:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "For solid-mechanics it can sometimes be necessary to turn off preset - imagine a DirichletBC for displacement that is large enough to invert elements... that's exactly what would instantly happen if preset is on.\nOn the other hand - if you're not going to invert elements with your displacement, it is certainly better to use preset.  Double-edged sword.",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3880879",
                          "updatedAt": "2022-10-14T16:50:22Z",
                          "publishedAt": "2022-10-14T16:50:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Probably off-topic here, @friedmud I think I was the person who said preset=true is good for all my (mechanics) problems several years ago when we consolidated preset and dirichlet BCs. But over the years I've found that preset=false performs better for plasticity problems with a high hardening rate (even when the preset BC isn't inverting elements). My hypothesis is that the preset BC is forcing certain elements into the return mapping when they shouldn't in the equilibriated solution.\nAnyways, preset=true is still a good default by in large. But the scenario I mentioned above may be a collective knowledge we should document at some point...",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3881003",
                          "updatedAt": "2022-10-14T17:10:52Z",
                          "publishedAt": "2022-10-14T17:10:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "That's good to know @hugary1995 .  Turning off preset will allow the solver to \"solve to\" the final solution... moving with everything else in the system.  This can be \"softer\"... akin to taking small timesteps and letting everything equilibrate during the solve... so I think it makes sense.",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3881044",
                          "updatedAt": "2022-10-14T17:16:22Z",
                          "publishedAt": "2022-10-14T17:16:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "krb-nantes"
                          },
                          "bodyText": "Hi all, thanks for helping!\n1- I worked based on the examples in: moose/modules/tensor_mechanics/test/tests/strain_energy_density/ , but I am not actually using it in all the BC only for the axial constraint, it was my mistake posting here with this in all of them. And, indeed depending on the displacement value I set its necessary to use the preset = false.\n2- I tried set the constant temperature as an AuxVariable, and it actually did not change;\n3- I think the most possible solution here will be the scaling. As I understood from your suggestion, I apply the scaling parameters on Executioner block (and I am using Transient), however, with these parameters I could only scale the displacement variables and it seems to be going, but very slow. So, I was wondering if it is possible to scale the Material properties as well (Young's modulus and Yield Stress), or this is already done in \"automatic_scaling\", this still not so clear to me?",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3881343",
                          "updatedAt": "2022-10-14T18:06:34Z",
                          "publishedAt": "2022-10-14T18:06:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "The automatic scaling scales the \"result\" of using those large material properties (the residuals and jacobians that are resultant).  When you say \"going slow\"... what does that mean?  Can you post some of your convergence history?",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3897727",
                          "updatedAt": "2022-10-17T15:26:10Z",
                          "publishedAt": "2022-10-17T15:26:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any update on this @krb-nantes ?",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3937906",
                          "updatedAt": "2022-10-22T00:05:26Z",
                          "publishedAt": "2022-10-22T00:05:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "krb-nantes"
                          },
                          "bodyText": "Hi all, so in my first try using the scaling, the code stopped because it reached the wall time of 5h, it did not finished, but also did not have any errors. I do not think I have the performance metrics file for this time, but I have this one below. This one correspond for the same file, I ran it a second time and then I had a non-convergency error.\nmesoscale_TM_HC_performance_metrics.csv",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3962980",
                          "updatedAt": "2022-10-25T18:00:22Z",
                          "publishedAt": "2022-10-25T18:00:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any update on this?\nI've also seen some segregate the two solves using a multiapp and do a fixed point iteration. This should be more stable, especially with relaxation, if that s what s needed",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-4149397",
                          "updatedAt": "2022-11-15T18:16:46Z",
                          "publishedAt": "2022-11-15T18:16:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using Variable array and c++ Eigen Library in MOOSE",
          "author": {
            "login": "thewhitewalker10"
          },
          "bodyText": "Hello,\nI\u2019m finding it difficult to replicate the following code I obtained online into MOOSE:\ntemplate <int DisplacementDim>\nPropertyDataType EmbeddedFracturePermeability<DisplacementDim>::value(\n    VariableArray const& variable_array,\n    ParameterLib::SpatialPosition const& pos, double const t,\n    double const /*dt*/) const\n{\n    Eigen::Matrix<double, 3, 1> const n = [&]\n    {\n        if (_n_const)\n        {\n            return _n;\n        }\n        auto const sigma = formEigenTensor<3>(\n            std::get<SymmetricTensor>(variable_array.total_stress));\n        Eigen::SelfAdjointEigenSolver<Eigen::Matrix<double, 3, 3>> e_s(sigma);\n        return (Eigen::Matrix<double, 3, 1>)e_s.eigenvectors().col(2);\n    }();\n\nIn the code, it seems the total stress was obtained and transformed into a symmetric tensor. Then, eigenvectors were derived from this symmetric tensor using various functions from the c++ Eigen Library. The code finally returns the second column of the eigenvectors. Is there a way to do this in moose differently? If not, how do I approach it? My main problem is how to obtain the eigenvectors from the stress. Any clue on how to approach it will be helpful. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/22703",
          "updatedAt": "2022-12-10T07:32:32Z",
          "publishedAt": "2022-11-15T04:50:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can use Eigen in MOOSE the same way.\nIs the issue converting from an array variable value to an Eigen::Matrix?\nWhere is this snippet from?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4147816",
                  "updatedAt": "2022-11-15T15:30:36Z",
                  "publishedAt": "2022-11-15T15:30:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "thewhitewalker10"
                          },
                          "bodyText": "Hi @GiudGiud\nYes, the issue is in two folds. First, I\u2019m looking for a way to obtain the total stress (I'm developing a new material using the porousflow module btw). And second, how to obtain the eigenvectors using the eigen library.\nThe code is an OGS (opengeosys) code.",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4148803",
                          "updatedAt": "2022-11-17T19:02:19Z",
                          "publishedAt": "2022-11-15T17:04:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is the stress the quantity you solve the equation for?\nor is it a function/dependent on the quantities you solve the equations for?\ndepending on this, a variable or a material property (which can be a tensor) make more sense",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4148892",
                          "updatedAt": "2022-11-15T17:14:58Z",
                          "publishedAt": "2022-11-15T17:14:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "thewhitewalker10"
                          },
                          "bodyText": "The stress is the quantity being solved for. I'm assuming I need to make the stress an auxvariable. correct?",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4148914",
                          "updatedAt": "2022-11-15T17:17:45Z",
                          "publishedAt": "2022-11-15T17:17:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If the stress is the quantity to solve in the nonlinear system, then stress should be a nonlinear variable, basically a main variable, not an aux variable\nPlease have a look at other porous flow stress models and/or how the tensor mechanics module deals with stress.",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4149094",
                          "updatedAt": "2022-11-15T17:41:11Z",
                          "publishedAt": "2022-11-15T17:41:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "thewhitewalker10"
                          },
                          "bodyText": "Hello @GiudGiud,\nGot it. it works now! Actually, the property I'm solving for is dependent on the stress from the tensor mechanics action. So, I obtained this stress as a material property. I'm however getting an error trying to use \"Eigen::SelfAdjointEigenSolver\" to compute eigenvectors. Does moose compute eigenvectors differently? Here is the error message:\nChecking if header needs updating: /home/thewalker/MOOSE/projects/moose/framework/include/base/MooseRevision.h...\nCompiling C++ (in opt mode) /home/thewalker/MOOSE/projects/ergs/build/unity_src/materials_Unity.C...\nIn file included from /home/thewalker/MOOSE/projects/ergs/build/unity_src/materials_Unity.C:2:\n/home/thewalker/MOOSE/projects/ergs/src/materials/PorousFLowPermeabilityEmbeddedFractures.C: In lambda function:\n/home/thewalker/MOOSE/projects/ergs/src/materials/PorousFLowPermeabilityEmbeddedFractures.C:89:79: error: no matching function for call to 'Eigen::SelfAdjointEigenSolver<Eigen::Matrix<double, 3, 3> >::SelfAdjointEigenSolver(const MaterialProperty<RankTwoTensorTempl<double> >&)'\n   89 |         Eigen::SelfAdjointEigenSolver<Eigen::Matrix<double, 3, 3>> e_s(_stress);\n      |                                                                               ^\nIn file included from /home/thewalker/mambaforge3/libmesh/include/Eigen/Eigenvalues:39,\n                 from /home/thewalker/mambaforge3/libmesh/include/Eigen/Dense:7,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/RankFourTensor.h:26,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/DataIO.h:20,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/MaterialProperty.h:17,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/MaterialData.h:12,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/BlockRestrictable.h:15,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/MaterialBase.h:14,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/Material.h:13,\n                 from /home/thewalker/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowMaterial.h:12,\n                 from /home/thewalker/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowMaterialVectorBase.h:12,\n                 from /home/thewalker/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowPermeabilityBase.h:12,\n                 from /home/thewalker/MOOSE/projects/ergs/build/header_symlinks/PorousFLowPermeabilityEmbeddedFractures.h:3,\n                 from /home/thewalker/MOOSE/projects/ergs/src/materials/PorousFLowPermeabilityEmbeddedFractures.C:1,\n                 from /home/thewalker/MOOSE/projects/ergs/build/unity_src/materials_Unity.C:2:\n/home/thewalker/mambaforge3/libmesh/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:162:14: note: candidate: 'template<class InputType> Eigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const Eigen::EigenBase<OtherDerived>&, int) [with InputType = InputType; _MatrixType = Eigen::Matrix<double, 3, 3>]'\n  162 |     explicit SelfAdjointEigenSolver(const EigenBase<InputType>& matrix, int options = ComputeEigenvectors)",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4161311",
                          "updatedAt": "2022-11-18T21:09:37Z",
                          "publishedAt": "2022-11-16T21:20:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThere is a mismatch in the data types.\nThe error says you are feeding a material property, but the object you may construct only accepts some eigen format (of a tensor I assume)\nYou will need to perform the conversion\nhere you pass const MaterialProperty<RankTwoTensorTempl<double>\nerror: no matching function for call to 'Eigen::SelfAdjointEigenSolver<Eigen::Matrix<double, 3, 3> >::SelfAdjointEigenSolver(const MaterialProperty<RankTwoTensorTempl<double> >&)'\n\nwhat is accepted is Eigen::EigenBase<OtherDerived>&\n/home/thewalker/mambaforge3/libmesh/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:162:14: note: candidate: 'template<class InputType> Eigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const Eigen::EigenBase<OtherDerived>&, int) [with InputType = InputType; _MatrixType = Eigen::Matrix<double, 3, 3>]'\n\nYou want to look at examples of code calling Eigen::Matrix. I m sure we have this exact conversion done somewhere already\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4180725",
                          "updatedAt": "2022-11-18T21:12:42Z",
                          "publishedAt": "2022-11-18T21:12:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}