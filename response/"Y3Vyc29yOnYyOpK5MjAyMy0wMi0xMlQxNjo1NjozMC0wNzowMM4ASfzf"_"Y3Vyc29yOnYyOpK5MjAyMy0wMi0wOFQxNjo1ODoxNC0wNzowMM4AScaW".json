{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wMi0wOFQxNjo1ODoxNC0wNzowMM4AScaW"
    },
    "edges": [
      {
        "node": {
          "title": "Material property transfer in THM",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "The VariableValueTransferMaterial can create an AD material property for a variable transferred from the boundary of a 2D mesh onto a 1D mesh. And now I have a material property which I want to transfer from the boundary of a 2D mesh onto a 1D mesh. How can I achieve it? Should I rewrite VariableValueTransferMaterial.C and make it possible to transfer the material property from the boundary of a 2D mesh onto a 1D mesh? @joshuahansel\nEthan",
          "url": "https://github.com/idaholab/moose/discussions/23349",
          "updatedAt": "2023-04-07T16:35:40Z",
          "publishedAt": "2023-02-06T12:38:29Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Ethan-xj"
                  },
                  "bodyText": "By the way, in VariableValueTransferMaterial\nChannelVariableTransferMaterial::computeProperties()\n{\n  std::vector<ADReal> T_w_nodal_values;\n  for (const auto i : _current_elem->node_index_range())\n  {\n    const Node & nd = _current_elem->node_ref(i);\n\n    // Assumes the variable you are coupling to is from the nonlinear system for now.\n    const Node * const nearest = _nearest_node.nearestNode(nd.id());\n    mooseAssert(nearest, \"I do not have the nearest node for you\");\n    const auto dof_number = nearest->dof_number(_nl_sys.number(), _paired_variable, 0);\n    T_w_nodal_values.push_back((*_serialized_solution)(dof_number));\n    Moose::derivInsert(T_w_nodal_values.back().derivatives(), dof_number, 1.);\n  }\n\nWhat is (*_serialized_solution)(dof_number)? I don't know much about it.",
                  "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4882318",
                  "updatedAt": "2023-02-06T13:18:57Z",
                  "publishedAt": "2023-02-06T13:18:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@joshuahansel",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4883232",
                          "updatedAt": "2023-02-06T14:45:15Z",
                          "publishedAt": "2023-02-06T14:45:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "@lindsayad VariableValueTransferMaterial is hot right now. What do you think about being able to transfer material properties rather than variables?\nEthan, at the very least, if you have no other option, in principle, you can transfer all of the material property's variable dependencies onto the 1D side and then recompute it there, but I'm not sure in your case how complex that would be.",
                  "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4884873",
                  "updatedAt": "2023-02-06T17:09:17Z",
                  "publishedAt": "2023-02-06T17:09:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "How would you evaluate the material property from the node?",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4885628",
                          "updatedAt": "2023-02-06T18:29:38Z",
                          "publishedAt": "2023-02-06T18:29:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Right, it couldn't be like it is now with the nearest node. I meant to ask if there was some kind of nearest QP transfer we could do \ud83d\ude04 Or just any other idea to solve this problem. Obviously there's also the maybe terrible solution I suggested above. Or AD aux variables \ud83e\udd24",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4885694",
                          "updatedAt": "2023-02-06T18:36:00Z",
                          "publishedAt": "2023-02-06T18:36:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Evaluating the variable dependencies seems like a pretty good idea to me. This kind of thing would be pretty easy with a functor material property, but I doubt @Ethan-xj is familiar with those (we'd also have to add a nodal-evaluation overload as well, so it wouldn't work right out of the box ... it would work out of the box with a nearest-qp evaluation)",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4885753",
                          "updatedAt": "2023-02-06T18:42:15Z",
                          "publishedAt": "2023-02-06T18:42:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "I found a new problem. The variable transfered by VariableValueTransferMaterial is nonlinear. Can VariableValueTransferMaterial transfer aux variables?",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4891567",
                          "updatedAt": "2023-02-07T09:30:16Z",
                          "publishedAt": "2023-02-07T09:30:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "As for the material property I want to transfer, I think I can use the VariableValueTransferAux to transfer variable dependencies and recompute the material property on the 1D side.",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4892202",
                          "updatedAt": "2023-02-07T10:44:10Z",
                          "publishedAt": "2023-02-07T10:44:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "@lindsayad can check my work here: I expect that VariableValueTransferMaterial could be modified to work with aux variables; however, you would lose the AD in that chain (anytime you introduce aux variables into your calculation). You'd probably be better off recomputing the aux quantities on the 1D side if you can manage that.",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4894320",
                          "updatedAt": "2023-02-07T14:38:30Z",
                          "publishedAt": "2023-02-07T14:38:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "I\u2018m working on the lateral flow between 2 1D flow channels and I want to transfer the density velocity and pressure of one channel to another. But in FlowChannelSinglePhase pressure is a aux variable. So in current situation I can\u2019t transfer pressure in AD form\uff0cright\uff1f",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4894966",
                          "updatedAt": "2023-02-07T15:36:48Z",
                          "publishedAt": "2023-02-07T15:36:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Right, you can't transfer pressure directly. You'll need to transfer the solution variables rhoA, rhouA, and rhoEA and then recompute pressure. See ADFluidProperties3EqnMaterial for how to compute pressure from these.",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4895522",
                          "updatedAt": "2023-02-07T16:27:27Z",
                          "publishedAt": "2023-02-07T16:27:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "(In your case, if you're using VariableValueTransferMaterial, those solution variables will come into your new material as material properties instead of coupled variables.)",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4895544",
                          "updatedAt": "2023-02-07T16:29:11Z",
                          "publishedAt": "2023-02-07T16:29:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We could definitely modify that material to work with aux variables if desired",
                          "url": "https://github.com/idaholab/moose/discussions/23349#discussioncomment-4895833",
                          "updatedAt": "2023-02-07T16:55:00Z",
                          "publishedAt": "2023-02-07T16:55:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Generate cracks by duplicating nodes",
          "author": {
            "login": "tfc1992"
          },
          "bodyText": "Dear Moose user,\nI am learning the phase field modeling of fracture using moose. And I want to create a pre-crack by duplicating the nodes. how do I realize it in moose?  any examples available?  Many thanks.",
          "url": "https://github.com/idaholab/moose/discussions/16494",
          "updatedAt": "2023-02-10T10:06:33Z",
          "publishedAt": "2020-12-15T03:04:55Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @tfc1992\nI believe this must be done in gmsh.\nYou can create \"Point\" and \"Line\" and \"Line Loop\" manually in the .geo file\nYou don't need to duplicate nodes, just define two different \"Line\" along the same segment\nand define \"Line Loop\" by adding the two \"Line\" one after the other.\nIn this way the nodes on the two \"Line\" will be independent.\nI paste below and example of .geo file, but it's not for crack, you will need to modify it.\nHope this helps.\nBest Regards,\nNicol\u00f2 Grilli\n//Points\nPoint(1) = {0, 0, 0, 10};\nPoint(2) = {100, 0, 0, 10};\nPoint(3) = {600, 0, 0, 10};\nPoint(4) = {700, 0, 0, 10};\nPoint(5) = {700, 500, 0, 10};\nPoint(6) = {500, 500, 0, 10};\nPoint(7) = {200, 500, 0, 10};\nPoint(8) = {0, 500, 0, 10};\nPoint(9) = {100, 200, 0, 10};\nPoint(10) = {200, 200, 0, 10};\nPoint(11) = {200, 300, 0, 10};\nPoint(12) = {500, 300, 0, 10};\nPoint(13) = {500, 200, 0, 10};\nPoint(14) = {600, 200, 0, 10};\nPoint(15) = {700, 200, 0, 10};\nPoint(16) = {0, 200, 0, 10};\nPoint(17) = {200, 0, 0, 10};\nPoint(18) = {500, 0, 0, 10};\nPoint(19) = {50, 0, 0, 10};\nPoint(20) = {50, 200, 0, 10};\nPoint(21) = {50, 500, 0, 10};\n//Lines\nLine(1) = {8, 21};\nLine(2) = {21, 7};\nLine(3) = {7, 6};\nLine(4) = {6, 5};\nLine(5) = {5, 15};\nLine(6) = {15, 4};\nLine(7) = {4, 3};\nLine(8) = {3, 18};\nLine(9) = {18, 17};\nLine(10) = {17, 2};\nLine(11) = {2, 19};\nLine(12) = {19, 1};\nLine(13) = {1, 16};\nLine(14) = {16, 8};\nLine(15) = {7, 11};\nLine(16) = {11, 10};\nLine(17) = {10, 9};\nLine(18) = {9, 20};\nLine(19) = {20, 16};\nLine(20) = {6, 12};\nLine(21) = {12, 13};\nLine(22) = {13, 14};\nLine(23) = {14, 15};\nLine(24) = {3, 14};\nLine(25) = {13, 18};\nLine(26) = {2, 9};\nLine(27) = {10, 17};\nLine(28) = {11, 12};\nCircle(29) = {9, 10, 11};\nCircle(30) = {14, 13, 12};\nLine(31) = {10, 13};\nLine(32) = {19, 20};\nLine(33) = {20, 21};\n// Line Loops\nLine Loop(101) = {1, -33, 19, 14};\nPlane Surface(201) = {101};\nLine Loop(102) = {2, 15, -29, 18, 33};\nPlane Surface(202) = {102};\nLine Loop(103) = {3, 20, -28, -15};\nPlane Surface(203) = {103};\nLine Loop(104) = {4, 5, -23, 30, -20};\nPlane Surface(204) = {104};\nLine Loop(105) = {16, 17, 29};\nPlane Surface(205) = {105};\nLine Loop(106) = {28, 21, -31, -16};\nPlane Surface(206) = {106};\nLine Loop(107) = {-30, -22, -21};\nPlane Surface(207) = {107};\nLine Loop(108) = {12, 13, -19, -32};\nPlane Surface(208) = {108};\nLine Loop(109) = {11, 32, -18, -26};\nPlane Surface(209) = {109};\nLine Loop(110) = {27, 10, 26, -17};\nPlane Surface(210) = {110};\nLine Loop(111) = {25, 9, -27, 31};\nPlane Surface(211) = {111};\nLine Loop(112) = {8, -25, 22, -24};\nPlane Surface(212) = {112};\nLine Loop(113) = {6, 7, 24, 23};\nPlane Surface(213) = {113};\n// Transfinite Line\nTransfinite Line {7, 8, 10, 23, 22, 17, 16, 21, 29, 30} = 11 Using Progression 1;\nTransfinite Line {6, 24, 25, 27, 26, 32, 13, 15, 20, 4} = 21 Using Progression 1;\nTransfinite Line {9, 31, 28, 3, 5, 14, 33} = 31 Using Progression 1;\nTransfinite Line {11, 12, 18, 19, 1} = 6 Using Progression 1;\nTransfinite Line {2} = 16 Using Progression 1;\n// Transfinite Surface\nTransfinite Surface {201};\n//Transfinite Surface {202};\nTransfinite Surface {203};\n//Transfinite Surface {204};\n//Transfinite Surface {205};\nTransfinite Surface {206};\n//Transfinite Surface {207};\nTransfinite Surface {208};\nTransfinite Surface {209};\nTransfinite Surface {210};\nTransfinite Surface {211};\nTransfinite Surface {212};\nTransfinite Surface {213};\n// Recombine Surface\nRecombine Surface {201};\nRecombine Surface {202};\nRecombine Surface {203};\nRecombine Surface {204};\nRecombine Surface {205};\nRecombine Surface {206};\nRecombine Surface {207};\nRecombine Surface {208};\nRecombine Surface {209};\nRecombine Surface {210};\nRecombine Surface {211};\nRecombine Surface {212};\nRecombine Surface {213};\n// Physical Line\nPhysical Line(\"top\") = {1, 2, 3, 4};\nPhysical Line(\"right\") = {5, 6};\nPhysical Line(\"bottom\") = {7, 8, 9, 10, 11, 12};\nPhysical Line(\"left\") = {13, 14};\n// Physical Surface\nPhysical Surface(\"sylgard\") = {201, 202, 203, 204, 208, 209, 213};\nPhysical Surface(\"hmx\") = {205, 206, 207, 210, 211, 212};",
                  "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-207609",
                  "updatedAt": "2022-07-18T13:13:16Z",
                  "publishedAt": "2020-12-15T07:12:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tfc1992"
                          },
                          "bodyText": "Dear @ngrilli,  Very grateful for your help. I understand the method you proposed and I will try. Besides, I also found a plugin termed ''crack'' in Gmsh, but it didn't work. The following is a simple .geo file. Maybe I missed something.\n//+\nPoint(1) = {0, 0, 0, 1.0};\n//+\nPoint(2) = {1, 0, 0, 1.0};\n//+\nPoint(3) = {1, 1, 0, 1.0};\n//+\nPoint(4) = {-0, 1, 0, 1.0};\n//+\nLine(1) = {1, 2};\n//+\nLine(2) = {2, 3};\n//+\nLine(3) = {3, 4};\n//+\nLine(4) = {4, 1};\n//+\nCurve Loop(1) = {3, 4, 1, 2};\n//+\nPlane Surface(1) = {1};\n//+\nPhysical Curve(\"top\") = {3};\n//+\nPhysical Curve(\"right\") = {2};\n//+\nPhysical Curve(\"left\") = {4};\n//+\nPhysical Curve(\"bottom\") = {1};\n//+\nTransfinite Surface {1};\n//+\nTransfinite Surface {1} = {4, 3, 2, 1};\n//+\nTransfinite Curve {4, 2} = 5 Using Progression 1;\n//+\nTransfinite Curve {3, 1} = 5 Using Progression 1;\n//+\nMesh 2;\nRecombineMesh;\nPlugin(Crack).Dimension=1;\nPlugin(Crack).PhysicalGroup=5;\nPlugin(Crack).OpenBoundaryPhysicalGroup=0;\nPlugin(Crack).NormalX=0;\nPlugin(Crack).NormalY=0;\nPlugin(Crack).NormalZ=1;\nPlugin(Crack).Run;",
                          "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-207641",
                          "updatedAt": "2022-07-18T13:13:20Z",
                          "publishedAt": "2020-12-15T07:37:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @tfc1992\nI don't know about the crack plugin, I would just do that by hand.\nFor instance, in your file, you can create three more points:\nPoint(5) = {0, 0.5, 0, 1.0};\nPoint(6) = {0.5, 0.5, 0, 1.0};\nPoint(7) = {0, 0.5, 0, 1.0};\nThen instead of connecting 4 to 1, you do:\nLine(4) = {4, 5};\nLine(5) = {5, 6};\nLine(6) = {6, 7};\nSo line 5 and 6 will be different but located in the same positions.\nWhen you generate the mesh, the nodes will be independent on those two lines\nand if you apply vertical load, the crack will open.\nPoint 6 is the crack tip\nThis should work, let me know\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                          "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-210437",
                          "updatedAt": "2022-07-18T13:13:22Z",
                          "publishedAt": "2020-12-15T16:21:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tfc1992"
                          },
                          "bodyText": "Dear @ngrilli  Thanks for your response.  I Ttried this method, but it can't achieve the result I want, like the Fig.6 in the following paper https://onlinelibrary.wiley.com/doi/full/10.1002/nme.6172,",
                          "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-212252",
                          "updatedAt": "2022-07-18T13:13:22Z",
                          "publishedAt": "2020-12-16T01:35:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @tfc1992\nYou can definitely reproduce that result in figure 6 with MOOSE.\nIt seems the crack surfaces in that figure are not coincident, so you can built a domain where the crack has already an opening\nand you model the initial crack tip as a semi-sphere, you will see stress concentration at the tip and then the phase field =1 region will appear.\nPlease let us know which results you see in your simulations and share input file, otherwise it is difficult to help\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                          "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-213056",
                          "updatedAt": "2022-07-18T13:13:24Z",
                          "publishedAt": "2020-12-16T07:13:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tfc1992"
                          },
                          "bodyText": "Dear @ngrilli  Thank you for your help. Inspired by the method you proposed, I just got it in gmsh. Here is the .geo file. However, I haven't developed the moose input file yet. Actually, I am a new moose user.\nPoint(1) = {0, 0, 0, 1.0};\n//+\nPoint(2) = {0.5, 0, 0, 1.0};\n//+\nPoint(3) = {1, 0, 0, 1.0};\n//+\nPoint(4) = {1, 0.5, 0, 1.0};\n//+\nPoint(5) = {1, 1, 0, 1.0};\n//+\nPoint(6) = {0.5, 1, 0, 1.0};\n//+\nPoint(7) = {0, 1, 0, 1.0};\n//+\nPoint(8) = {0, 0.5, 0, 1.0};\n//+\nPoint(9) = {0.5, 0.5, 0, 1.0};\n//+\nPoint(10) = {-0, 0.5, 0, 1.0};\n//+\nLine(1)={1,2};\n//+\nLine(2) = {2, 3};\n//+\nLine(3) = {3, 4};\n//+\nLine(4) = {4, 5};\n//+\nLine(5) = {5, 6};\n//+\nLine(6) = {6, 7};\n//+\nLine(7) = {7, 8};\n//+\nLine(8) = {8, 9};\n//+\nLine(9) = {9, 10};\n//+\nLine(10) = {10, 1};\n//+\nPhysical Curve(\"top\") = {6, 5};\n//+\nPhysical Curve(\"left\") = {7, 10};\n//+\nPhysical Curve(\"right\") = {4, 3};\n//+\nPhysical Curve(\"bottom\") = {1, 2};\n//+\nLine(11) = {9, 6};\n//+\nLine(12) = {9, 4};\n//+\nLine(13) = {9, 2};\n//+\nCurve Loop(1) = {7, 8, 11, 6};\n//+\nPlane Surface(1) = {1};\n//+\nCurve Loop(2) = {5, -11, 12, 4};\n//+\nPlane Surface(2) = {2};\n//+\nCurve Loop(3) = {13, 2, 3, -12};\n//+\nPlane Surface(3) = {3};\n//+\nCurve Loop(4) = {9, 10, 1, -13};\n//+\nPlane Surface(4) = {4};\n//+\nTransfinite Curve {7, 11, 6, 8} = 100 Using Progression 1;\n//+\nTransfinite Curve {5, 11, 4, 12} =100 Using Progression 1;\n//+\nTransfinite Curve {3, 13, 12, 2} = 100 Using Progression 1;\n//+\nTransfinite Curve {9, 10, 13, 1} = 100 Using Progression 1;\n//+\nTransfinite Surface {1};\n//+\nTransfinite Surface {2};\n//+\nTransfinite Surface {3};\n//+\nTransfinite Surface {4};\n//+\nRecombine Surface {1};\n//+\nRecombine Surface {2};\n//+\nRecombine Surface {3};\n//+\nRecombine Surface {4};",
                          "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-213084",
                          "updatedAt": "2022-07-18T13:13:24Z",
                          "publishedAt": "2020-12-16T07:36:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @tfc1992\nThere are lot of ready input file for phase field fracture here:\nhttps://github.com/idaholab/moose/tree/next/modules/combined/test/tests/phase_field_fracture\nYou just need to import your mesh using the FileMeshGenerator object\nand assign \"physical surfaces\" in gmsh to apply boundary conditions in MOOSE\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                          "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-214946",
                          "updatedAt": "2022-07-18T13:13:28Z",
                          "publishedAt": "2020-12-16T14:03:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tfc1992"
                          },
                          "bodyText": "Dear @ngrilli  Many thanks. I found it.\nBest Regards,\nFucheng Tian",
                          "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-217747",
                          "updatedAt": "2022-07-18T13:13:34Z",
                          "publishedAt": "2020-12-17T00:35:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "@tfc1992 Dear Fucheng, I also need the same mesh urgently. But it always reports an error when I import the mesh generated by your .geo file. It always says the boundary top can't be found... And I checked the mesh using peacock, the top, bottom, and so on are blocks not boundaries...",
                          "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-4933184",
                          "updatedAt": "2023-02-10T10:06:33Z",
                          "publishedAt": "2023-02-10T10:06:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "An easy hack is to precrack along a boundary by constraining displacements only for part of the boundary (the remaining unconstrained part is the crack).",
                  "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-211997",
                  "updatedAt": "2022-07-18T13:13:25Z",
                  "publishedAt": "2020-12-15T23:30:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tfc1992"
                          },
                          "bodyText": "Dear @dschwen , Thanks for your response.  I tried this, but it won't work if the crack is not located at the boundary.",
                          "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-212097",
                          "updatedAt": "2022-07-18T13:13:28Z",
                          "publishedAt": "2020-12-16T00:45:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "To prescribe an initial crack for phase-field fracture in MOOSE, you can\n\nUse meshing software, such as gmsh and Cubit, to explicitly mesh the crack by either duplicating nodes or creating non-overlapping crack surfaces.\nYou can use damage variable itself to prescribe the crack, and use either history variable approach or variational inequality solver to enforce the irreversibility of your initial crack.\nUse XFEM capability to cut your mesh and represent the crack. Add the following blocks into your input. XFEM doesn't work with mesh adaptivity though.\n\n[XFEM]\nqrule = volfrac\noutput_cut_plane = true\n[]\n[UserObjects]\n[./line_seg_cut_uo]\ntype = LineSegmentCutUserObject\ncut_data = '0.5 1.0 0.5 0.5'   #cut_data = 'x0 y0 x1 y1' and  segment defined by point(x0,y0) and  point(x1 y1) #\ntime_start_cut = 0.0\ntime_end_cut = 0.0\n[../]\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-215560",
                  "updatedAt": "2022-07-18T13:13:29Z",
                  "publishedAt": "2020-12-16T15:33:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tfc1992"
                          },
                          "bodyText": "Dear @jiangwen84  Thanks for your good suggestion. Under the help of  @ngrilli, I solved this problem in Gmsh. But, I will try the second method you provided.\nBest Regards,\nFucheng Tian",
                          "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-217816",
                          "updatedAt": "2022-07-18T13:13:32Z",
                          "publishedAt": "2020-12-17T01:19:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GregVernon"
                  },
                  "bodyText": "@tfc1992,\n@jiangwen84 provides several great methods.  If you are interested in his first suggestion, please know that you can get a free copy of Coreform Cubit Learn for non-commercial use, or a free-trial of Coreform Cubit for commercial use.  I recently helped a group from SDSU build a mesh for a geological fault - which is essentially a crack - by duplicating nodes as you've described.  I'd be happy to assist you with this approach if you're interested.\nLink: https://coreform.com/products/coreform-cubit/\nBest regards,\nGreg Vernon\nDirector of Product Management\nCoreform LLC",
                  "url": "https://github.com/idaholab/moose/discussions/16494#discussioncomment-216802",
                  "updatedAt": "2022-07-18T13:13:32Z",
                  "publishedAt": "2020-12-16T18:48:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "IterationAdaptiveDT unused parameters",
          "author": {
            "login": "fervaldies"
          },
          "bodyText": "Hello, I am trying to run my simulation with the IterationAdaptiveDT (look at the part of the Executioner pasted below) and I receive and error saying that linear_iteraction_ratio, optimal_iteractions, and iteraction_window are \"unused parameters\". Is this because I need to add anything else in the code apart from this part in the Executioner named \"TimeStepper\"? Thank you in advance.\n\n\n[Executioner]\nTransient (time-dependent) problem\ntype = Transient\nSolver\nsolve_type = NEWTON\n#Options for PETSc (how to solve linear equations)\nautomatic_scaling = false\npetsc_options = '-snes_converged_reason -ksp_converged_reason'\npetsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_max_levels -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_P_max -pc_hypre_boomeramg_truncfactor -pc_hypre_boomeramg_print_statistics'\npetsc_options_value = 'hypre boomeramg 51 0.7 4 5 25 PMIS ext+i 2 0.3 0'\nSolver tolerances\nl_max_its = 50\n#l_tot = 1e-4 #1e-6\nnl_max_its = 50\nnl_rel_tol = 1e-6\nnl_abs_tol = 1e-6\nnl_forced_its = 1\nline_search = 'bt' # 'none'/'bt'\nTime variables\nstart_time = 0.0\nend_time = 15000.0\ndtmin = 1e-6\ndtmax = 0.1\n[./TimeStepper]\ntype = IterationAdaptiveDT\ngrowth_factor = 2\ncutback_factor = 0.5\nlinear_iteraction_ratio = 1000\noptimal_iteractions = 8 #12\niteraction_window = 3\ndt = 0.1\n[../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23395",
          "updatedAt": "2023-02-10T04:40:49Z",
          "publishedAt": "2023-02-10T04:11:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nnope it s just spelled iteration not iteraction\nOnce that\u2019s fixed it should stop complaining about unused parameters.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23395#discussioncomment-4928176",
                  "updatedAt": "2023-02-10T04:35:02Z",
                  "publishedAt": "2023-02-10T04:35:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "fervaldies"
                          },
                          "bodyText": "Oh, thank you very much! haha my bad, I was confused with interaction. Now it is working",
                          "url": "https://github.com/idaholab/moose/discussions/23395#discussioncomment-4928203",
                          "updatedAt": "2023-02-10T04:40:39Z",
                          "publishedAt": "2023-02-10T04:40:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem about mesh",
          "author": {
            "login": "Johnney12138"
          },
          "bodyText": "Hello,\nI was trying to solve an phase field problem. After running, it gave me an error message:\n*** ERROR ***  No mesh file was supplied and no generation block was provided\nThe complete code is attached as follows:\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2               \n    nx = 10               \n    ny = 10               \n    xmin = 2\n    xmax = 4              \n    ymin = 2\n    ymax = 4\n  []\n[]\n  \n[Variables]\n  [./w]       # chemical potential (concentration).\n  [../]\n  [./phi]     # phase\n  [../]\n  [./T]       # temperature\n  [../]\n[]\n  \n[ICs]\n  [./w_InitialCondition]\n    type = ConstantIC\n    value = 0.1\n    variable = w\n  [../]\n  [./phi_InitialCondition]\n    type = SmoothCircleIC\n      variable = phi\n      int_width = 0.01\n      x1 = 3\n      y1 = 3\n      radius = 0.1\n      outvalue = 0\n      invalue = 1\n  [../]\n  [./T_InitialCondition]\n    type = ConstantIC\n    value = 10\n    variable = T\n  [../]\n[]\n  \n[Kernels]\n  # Order parameter phi\n  [./AC_bulk]\n    type = AllenCahn      \n    variable = phi        \n    f_name = F            \n    coupled_variables = 'w T'     \n  [../]\n  [./anisoACinterface1]\n    type = ACInterfaceKobayashi1                 \n    variable = phi                               \n    mob_name = M\n  [../]\n  [./anisoACinterface2]\n    type = ACInterfaceKobayashi2                 \n    variable = phi                               \n    mob_name = M\n  [../]\n  [./phi_dot]\n    type = TimeDerivative   \n    variable = phi\n  [../]\n  # Chemical potential (concentration). \n  [./w_dot]\n    type = SusceptibilityTimeDerivative   \n    variable = w\n    f_name = chi                          \n    coupled_variables = 'phi'\n  [../]\n  [./Diffusion]\n    type = MatDiffusion                   \n    variable = w\n    diffusivity = Dchi                    \n  [../]\n  [./coupled_phidot]\n    type = CoupledSusceptibilityTimeDerivative\n    variable = w\n    v = phi\n    f_name = ft\n    coupled_variables = 'phi'\n  [../]\n    # adding antitrapping current term in the model.\n  [./coupled_phidot_int]\n    type = AntitrappingCurrent\n    variable = w\n    v = phi\n    f_name = rhodiff\n  [../]\n  # temperature equation.        \n  [./coupled_tempdiff]\n    type = TimeDerivative\n    variable = T\n  [../]\n  [./coef_diffusion]\n    type = CoefDiffusion\n    variable = T\n    coef = 10\n  [../]\n  [./coef_coupledtimederi]\n    type = CoefCoupledTimeDerivative\n    variable = T\n    v = phi\n    coef = -0.5\n  [../]\n[]\n  \n  [Materials]\n  [./mobility]\n    type = DerivativeParsedMaterial\n    property_name = M\n    coupled_variables = 'phi w'\n    material_property_names = 'phiy:=D[phi,y] phix:=D[phi,x]'\n    expression = 'M_0*(1+eps*(phix^4-6*phix^2*phiy^2+phiy^4)/(phix^2+phiy^2)^2)^2*(1/Le+NCi*(1+(1-k)*w))'\n    enable_jit = true\n    derivative_order = 2\n  [../]\n  [./buck free energy]\n    type = DerivativeParsedMaterial\n    property_name = F\n    coupled_variables = 'phi w T'\n    expression = 'M*(phi^3 - phi + lambda*(1-phi^2)^2*(NCi*w+T))'\n    enable_jit = true\n    derivative_order = 2\n  [../]\n  [./antitrapping coef]\n    type = DerivativeParsedMaterial           \n    args = 'w'\n    f_name = rhodiff\n    function = '-tc/sqrt(2)*((1-k)*w+1)'   \n  [../]\n  [./chi]\n    type = DerivativeParsedMaterial\n    args = 'phi'        \n    f_name = chi\n    function = '1+k-(1-k)*phi'    \n  [../]\n  [./Dchi]\n    type = DerivativeParsedMaterial\n    args = 'phi'\n    f_name = Dchi\n    function = 'Di*(phi-1)'        \n  [../]\n  [./ft]\n    type = DerivativeParsedMaterial\n    args = 'w'\n    f_name = ft\n    function = '(1-k)*w+1'\n  [../]\n  [./const]\n    type = GenericConstantMaterial\n    prop_names =  'M_0   eps    Le  NCi   k    lambda tc    Di'\n    prop_values = '0.0005 0.02  1  0.15  0.15  3.1913  0.01  2'\n  [../]\n[]\n  \n[Preconditioning]\n  [./SMP]\n    type = SMP        \n    full = true      \n  [../]\n[]\n  \n[Executioner]\n  type = Transient\n  scheme = bdf2           \n  solve_type = PJFNK      \n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\n  petsc_options_value = 'hypre    boomeramg      31'\n  l_tol = 1.0e-3          \n  l_max_its = 100          \n  nl_max_its = 100         \n  nl_rel_tol = 1.0e-8     \n  nl_abs_tol = 1e-8       \n  # end_time = 2          \n  [./TimeStepper]\n    type = IterationAdaptiveDT  \n    dt = 0.0005                 \n    cutback_factor = 0.7        \n    growth_factor = 1.2         \n  [../]\n[]\n\n[Adaptivity]\ninitial_steps = 3                   \nmax_h_level = 3                     \ninitial_marker = err_eta           \nmarker = err_bnds                  \n[./Markers]                          \n  [./err_eta]\n    type = ErrorFractionMarker     \n    coarsen = 0.3\n    refine = 0.95\n    indicator = ind_eta\n  [../]\n  [./err_bnds]\n    type = ErrorFractionMarker\n    coarsen = 0.3\n    refine = 0.95\n    indicator = ind_bnds\n  [../]\n[../]\n[./Indicators]                       \n  [./ind_eta]\n    type = GradientJumpIndicator     \n    variable = etaa0\n  [../]\n  [./ind_bnds]\n    type = GradientJumpIndicator    \n    variable = bnds\n  [../]\n[../]\n[]\n    \n[Outputs]\n  interval = 10     \n  exodus = true\n[]\n\nI am confused since I did had the mesh block. Is there any wrong with my input? Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/23171",
          "updatedAt": "2023-03-21T23:12:04Z",
          "publishedAt": "2023-01-16T05:11:34Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis should not happen, as you do have a Mesh block\nCan you type the exact command you use here to run the code?\nYou may find it in bash_history, a file often at ~/.bash_history\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4700274",
                  "updatedAt": "2023-01-16T18:54:32Z",
                  "publishedAt": "2023-01-16T18:54:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Johnney12138"
                          },
                          "bodyText": "Hi @GiudGiud ,\nThank you for your reply.\nThe content in bash_history is attached as follows:\nchsh -s /bin/zsh gcc --version gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4) Copyright (C) 2015 Free Software Foundation, Inc. This is free software; see the source for copying conditions.  There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. chsh -s /bin/zsh export PACKAGES_DIR=/some/path/with/write/access export STACK_SRC=mktemp -d /tmp/moose_stack_src.XXXXXX /Applications/OpenFOAM-v2206.app/Contents/Resources/etc/openfoam chsh -s /bin/zsh gcc --version gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4) Copyright (C) 2015 Free Software Foundation, Inc. This is free software; see the source for copying conditions.  There is NO bash --noprofile export PACKAGES_DIR=/some/path/with/write/access export STACK_SRC=mktemp -d /tmp/moose_stack_src.XXXXXX umask 022 chsh -s /bin/zsh exit\nNan Liu",
                          "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4703849",
                          "updatedAt": "2023-01-17T06:39:09Z",
                          "publishedAt": "2023-01-17T06:39:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Your GCC is much too old.",
                          "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4870101",
                          "updatedAt": "2023-02-04T15:54:09Z",
                          "publishedAt": "2023-02-04T15:54:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "https://mooseframework.inl.gov/modules/misc/sqa/misc_srs.html#71f0d41b-e0a4-43d6-9d40-5444df3c4153",
                          "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4870105",
                          "updatedAt": "2023-02-04T15:55:03Z",
                          "publishedAt": "2023-02-04T15:55:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Johnney12138"
                          },
                          "bodyText": "Hi @GiudGiud\nThank you very much. Through your guidance, I have successfully solved this problem. I encounter a new problem. I was trying to solve a phase field problem where the parameter A is 1+erp*(dpx^4-6dpx^2dpy^2+dpy^4)/(dpx^2+dpy^2)^2). dpx and dpy are \\partial phi/ \\partial x and \\partial phi/ \\partial y, respectively. I have defined dpx and dpy as derivatives in Materials block. But it gave me an error message: phi_x: Coupled variable 'x' was not found. Do I need to declare somewhere that phi is a function of x and y? The complete code is attached as follows:\n[Mesh]\n    type = GeneratedMesh\n    dim = 2               \n    nx = 10               # Number of elements in the X direction.\n    ny = 10               # Number of elements in the Y direction.\n    xmin = 2\n    xmax = 4              # Upper X Coordinate of the generated mesh.\n    ymin = 2\n    ymax = 4\n    uniform_refine = 2\n[]\n\n[GlobalParams]\n    derivative_order = 4\n[]\n\n[Variables]\n    [./w]       # concentration\n    [../]\n    [./phi]   # phase field\n    [../]\n    [./T]   # temperature\n    [../]\n[]\n\n[AuxVariables]\n  # Definition of Derivative\n  [./phi_x]\n  [../]\n  [./phi_y]\n  [../]\n[]\n\n[AuxKernels]\n  [./Definition_Derivative_x]\n    type = FunctionAux\n    function = dpx\n    variable = phi_x\n  [../]\n  [./Definition_Derivative_y]\n    type = FunctionAux\n    function = dpy\n    variable = phi_y\n  [../]  \n[]\n\n[Functions]\n  [./A]\n    type = ParsedFunction\n    expression = 'if (dpx==0 & dpy==0,1, if(dpx!=0 \uff5c dpy!=0, 1+erp*(dpx^4-6*dpx^2*dpy^2+dpy^4)/(dpx^2+dpy^2)^2))'\n  [../]\n[]\n\n[ICs]\n    [./w]\n      type = ConstantIC\n      variable = w\n      value = 0.3\n    [../]\n    [./T]\n      type = ConstantIC\n      variable = T\n      value = 2.1\n    [../]\n    [./phi]\n      type = SmoothCircleIC\n      variable = phi\n      x1 = 3\n      y1 = 3\n      invalue = 1\n      outvalue = 0\n      radius = 0.1\n      int_width = 0.01\n    [../]\n[]\n\n[Kernels]\n  # phase field\n    [./phi_dot]\n      type = SusceptibilityTimeDerivative\n      variable = phi\n      f_name = tau\n    [../]\n    [./free_energy]\n      type = AllenCahn\n      variable = phi\n      f_name = Fr\n    [../]  \n    [./interface]    \n      type = ACInterface\n      variable = phi\n      kappa_name = 0.01\n    [../]\n  # Chemical potential.\n    [./w_dot]\n      type = SusceptibilityTimeDerivative   # A modified time derivative Kernel that multiplies the time derivative of a variable by a generalized susceptibility. I think this is equation (12).\n      variable = w\n      f_name = chi                          # Susceptibility function F defined in a FunctionMaterial.\n      coupled_variables = 'phi'\n    [../]\n    [./Diffusion]\n      type = MatDiffusion                   # Diffusion equation Kernel that takes an isotropic Diffusivity from a material property\n      variable = w\n      diffusivity = Dchi                    # D*chi defined in [material] > [mobility]\n      coupled_variables = 'phi'\n    [../]\n    [./coupled_etaa0dot]\n      type = CoupledSusceptibilityTimeDerivative\n      variable = w\n      v = phi\n      f_name = ft\n      coupled_variables = 'phi'\n    [../]\n    [./coupled_antitrapping]\n      type = AntitrappingCurrent\n      variable = w\n      v = phi\n      f_name = rhodiff\n    [../]\n    # temperature.\n    [./coupled_etaa0dot_time]\n      type = TimeDerivative\n      variable = T\n    [../]\n    [./coupled_etab0dot_diff]\n      type = CoefDiffusion\n      variable = T\n      coef = 1e8\n    [../]\n    [./coupled_etab0dot_ctim]\n      type = CoefCoupledTimeDerivative\n      variable = T\n      v = phi\n      coef = -0.5\n    [../]    \n[]\n  \n[Materials]\n    [./speexpress]\n      type = ParsedMaterial           \n      coupled_variables = 'phi w T'\n      f_name = Fr\n      material_property_names = 'lambda MCi'\n      function = 'phi^3-phi+lambda*(1-phi^2)^2*(MCi*w+T)' \n    [../]\n    [./mobility]\n      type = ParsedMaterial\n      coupled_variables = 'w'  \n      f_name = tau\n      material_property_names = 'tau0 Le MCi k A'\n      expression = 'tau0*A^2*(1/Le+MCi*(1+(1-k)*w))' \n    [../]\n    [./phi_x]\n      type = DerivativeParsedMaterial\n      args = 'x'\n      f_name = dpx\n      function = 'phi'\n      derivative_order = 4\n    [../]\n    [./phi_y]\n      type = DerivativeParsedMaterial\n      args = 'y'\n      f_name = dpy\n      function = 'phi'\n      derivative_order = 4\n    [../]\n    [./chemp]\n      type = ParsedMaterial\n      coupled_variables = 'phi'\n      f_name = chi\n      material_property_names = 'k'\n      function = '1+k-(1-k)*phi' \n    [../]\n    [./matdiff]\n      type = ParsedMaterial\n      coupled_variables = 'phi'\n      f_name = Dchi\n      material_property_names = 'D'\n      function = 'D*(1-phi)' \n    [../]\n    [./antitrap]\n      type = ParsedMaterial\n      coupled_variables = 'w'\n      f_name = rhodiff\n      material_property_names = 'k wid'\n      function = 'wid/sqrt(2)*(1+(1-k)*w)' \n    [../]\n    [./int]\n      type = ParsedMaterial\n      coupled_variables = 'w'\n      f_name = ft\n      material_property_names = 'k'\n      function = '1+(1-k)*w' \n    [../]\n    [./const]\n      type = GenericConstantMaterial\n      prop_names =  'tau0   Le  MCi   k  lambda   D  wid L erp'\n      prop_values = '1e-5  1.0  0.15  0.15  3.1913  2.0  0.01 1 0.01'\n    [../]\n    [./int_material]\n      type = ADInterfaceOrientationMaterial\n      op = phi\n      anisotropy_strength = 0.05\n    [../]\n[]\n\n  \n[Preconditioning]\n    [./SMP]\n      type = SMP        # Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.\n      full = true       # Set to true if you want the full set of couplings between variables simply for convenience so you don't have to set every off_diag_row and off_diag_column combination.\n    [../]\n[]\n  \n[Executioner]\n    type = Transient\n    scheme = bdf2           # second-order backward differentiation formula\n    solve_type = PJFNK      # precondictioned jacobian-free Newton-Krylov method\n    petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\n    petsc_options_value = 'hypre    boomeramg      31'\n    l_tol = 1.0e-3          # linear tolerance\n    l_max_its = 100          # max linear iterations\n    nl_max_its = 100         # max non-linear iterations\n    nl_rel_tol = 1.0e-8     # non-linear relative tolerance\n    nl_abs_tol = 1e-8       # non-linear absolute tolerance\n    end_time = 0.01          # The end time of the simulation. Default:1e+30\n    [./TimeStepper]\n      type = IterationAdaptiveDT  # Adjust the timestep based on the number of iterations\n      dt = 0.00005                 # The timestep size between solves\n      cutback_factor = 0.7        # Factor to apply to timestep if difficult convergence\n      growth_factor = 1.2         # Factor to apply to timestep if easy convergence\n    [../]\n[]\n  \n[Adaptivity]\n   initial_steps = 3                   # The number of adaptive steps to do based on the initial condition.\n   max_h_level = 3                     # Maximum number of times a single element can be refined. If 0 then infinite.\n   initial_marker = err_phi            # The name of the Marker to use to adapt the mesh during initial refinement.\n  [./Markers]                          # a Marker is used to decide which elements to refine or coarsen.\n     [./err_phi]\n       type = ErrorFractionMarker      # Marks elements for refinement or coarsening based on the fraction of the min/max error from the supplied indicator.\n       coarsen = 0.3\n       refine = 0.95\n       indicator = ind_phi\n     [../]\n  [../]\n[]\n  \n[Outputs]\n    interval = 10     # only output every 10 timesteps.\n    exodus = true\n[]\n\n[Debug]\n  show_material_props = true\n[]\n\nThanks!\nNan Liu",
                          "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4883067",
                          "updatedAt": "2023-02-07T00:31:58Z",
                          "publishedAt": "2023-02-06T14:30:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThis syntax is wrong\n  [./A]\n    type = ParsedFunction\n    expression = 'if (dpx==0 & dpy==0,1, if(dpx!=0 \uff5c dpy!=0, 1+erp*(dpx^4-6*dpx^2*dpy^2+dpy^4)/(dpx^2+dpy^2)^2))'\n  [../]\n\nyou need to pass more parameters than that. it needs to know what you means by any of these variables.\nSee the docs for that object\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4888140",
                          "updatedAt": "2023-02-07T00:33:11Z",
                          "publishedAt": "2023-02-07T00:33:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Johnney12138"
                          },
                          "bodyText": "Hello @GiudGiud\nThank you for pointing out the problem with the code. If I want to declare that phi is a function of x and y, which block do I need to write such code?\nNan Liu",
                          "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4894302",
                          "updatedAt": "2023-02-07T14:37:04Z",
                          "publishedAt": "2023-02-07T14:37:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "x and y can be written directly into the expression\nit's these dpx and dpy that need to be specified either as a function, postprocessor etc",
                          "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4894492",
                          "updatedAt": "2023-02-07T14:54:50Z",
                          "publishedAt": "2023-02-07T14:54:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Johnney12138"
                          },
                          "bodyText": "Hello @GiudGiud\nThank you for your reply.\nI still haven't solved the problem. In order to facilitate understanding, I use mathematical expressions to describe this problem.   In a phase field model, Allen-Cahn equation has an anisotropic mobility. The anisotropic mobility is given as follows:\nTau=tau_0A^2{1/Le+Mc*[1+(1-k)*U]},\nwhere tau_0, Le, Mc, and k are constants, and U is temperature. A=1+epicos(4theta) is a function that describes the anisotropy and theta is the angle between the direction normal to the interface and the x (horizontal) axis. In Moose, I don't seem to find objects or examples of how to deal with the anisotropic mobility of the AC equation. I tried to write the form of mobility directly in the code, but there was a problem with the expression of theta. I would like to know, in moose, are there objects that can represent the mobility or theta of the AC equation?\nThanks!\nNan Liu",
                          "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4920907",
                          "updatedAt": "2023-02-09T16:09:14Z",
                          "publishedAt": "2023-02-09T16:09:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m not familiar with that.\nMaybe @dschwen or @recuero",
                          "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4925153",
                          "updatedAt": "2023-02-09T21:02:52Z",
                          "publishedAt": "2023-02-09T21:02:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Johnney12138"
                          },
                          "bodyText": "Hello @GiudGiud\nThank you for your reply.\nNan Liu",
                          "url": "https://github.com/idaholab/moose/discussions/23171#discussioncomment-4927745",
                          "updatedAt": "2023-02-10T03:14:39Z",
                          "publishedAt": "2023-02-10T03:14:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "how to get the value like f(n+1)=g(f(n))",
          "author": {
            "login": "xiaojbing"
          },
          "bodyText": "hello\nI want to ask, if I know the initial value of f(0), and the fuction f(n+1)=g(f(n)), n is the time, g is a fuction. how to coupled f(n+1) to my Kernel?\nthank you!!!",
          "url": "https://github.com/idaholab/moose/discussions/23388",
          "updatedAt": "2023-04-07T16:35:30Z",
          "publishedAt": "2023-02-09T15:57:09Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi\nCheck out the doxygen for kernels, you can get the current time and the dt, then you can evaluate the function at the time you need\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classKernel.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23388#discussioncomment-4925134",
                  "updatedAt": "2023-02-09T21:01:15Z",
                  "publishedAt": "2023-02-09T21:01:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "It seems I need the old value f(n) if I want to evaluate f(n+1). I only know the initial value of f(n) and function. Specifically speaking,f(0) and g is known, f(1)=g(f(0)), then f(2)=g(f(1)), ...\nI dont konw how to solve this.\nthank you",
                          "url": "https://github.com/idaholab/moose/discussions/23388#discussioncomment-4927462",
                          "updatedAt": "2023-02-10T02:23:30Z",
                          "publishedAt": "2023-02-10T02:23:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can evaluate functions at any time you want.\nMaybe rewrite your equation using MOOSE terminology.\nWhat are f, g, n exactly?",
                          "url": "https://github.com/idaholab/moose/discussions/23388#discussioncomment-4927542",
                          "updatedAt": "2023-02-10T02:37:16Z",
                          "publishedAt": "2023-02-10T02:37:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "f is the value I want to couple to my kernel. g is a fuction about f. n is the time",
                          "url": "https://github.com/idaholab/moose/discussions/23388#discussioncomment-4927559",
                          "updatedAt": "2023-02-10T02:41:09Z",
                          "publishedAt": "2023-02-10T02:41:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to output the values of variables in source codes to .txt file",
          "author": {
            "login": "pshen20127"
          },
          "bodyText": "Hello\nI create a new variable 'shearstrain' in 'CrystalPlasticityKalidindiUpdate.C' and want to output it to a .txt file. I add\nFILE *fp = fopen(\"/home/pshen/Mercury2/IN625/test/shearstrain.txt\",\"a+\"); in line 15\nand\nfprintf(fp, \"shearstrain%d = %lf\\n\",i,_shearstrain[_qp][i]); in line 118. But I met this error\n\nDO you know what's the reason of it? How can I output it into txt file?\nHere is my codes:https://github.com/pshen20127/IN625.git\nThanks\nPengfei",
          "url": "https://github.com/idaholab/moose/discussions/23340",
          "updatedAt": "2023-06-24T20:01:16Z",
          "publishedAt": "2023-02-03T23:54:06Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFrom my quick look,\nYou never resized the vector so it s of size 0, and you are inserting and reading out of bounds.\nYou ll need to resize it at initialization\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23340#discussioncomment-4867887",
                  "updatedAt": "2023-02-04T05:48:07Z",
                  "publishedAt": "2023-02-04T05:48:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Also this is a material property for future reference (not a nonlinear/aux variable)",
                          "url": "https://github.com/idaholab/moose/discussions/23340#discussioncomment-4868006",
                          "updatedAt": "2023-02-04T06:46:21Z",
                          "publishedAt": "2023-02-04T06:46:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "I resized it in file 'CrystalPlasticityStressUpdateBaseAddStateVars.C' like below. But it doesn't work.\n144   _shearstrain[_qp].resize(_number_slip_systems);",
                          "url": "https://github.com/idaholab/moose/discussions/23340#discussioncomment-4923783",
                          "updatedAt": "2023-02-09T18:57:28Z",
                          "publishedAt": "2023-02-09T18:57:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Saturation",
          "author": {
            "login": "marinsiebert"
          },
          "bodyText": "Hello everyone,\nI am encountering an issue, which for the love of me I am not able to fix properly.\nI read on multiple occasions that the saturation calculation within the porous flow module considers a model to be fully saturated (S = 1.0) when the porepressure (Pp) is above 0, therefore S should be <1 when  Pp <= 0, however I cannot reproduce this assumption.\nI tried it with the THM, Fully Saturated and Unsaturated Action as well as with my own Kernel setup.\nThe model is supposed to be a 2D soil environment which I want to investigate in regards of thermal fields in a dry and fully water saturated, respectively, as well as at differents level of residual saturation and water tables. I assume that my comprehension of the problem is wrong at some point but I cannot figure out where, so hopefully someone might be able to help me out.\nBelow an example for the THM action.  Note that here the porepressures are far below zero (which of course does not make sense), however the saturation is still remaining at 1. What am I missing?\ndummy.zip\n[Mesh]\n  [./mesh]\n    type = FileMeshGenerator\n    file = mesh.off\n    allow_renumbering = false\n  [../]\n  [./outer]\n    type = SideSetsFromNormalsGenerator\n    input = mesh\n    new_boundary = 'top left bottom right'\n    normals = '0 1 0 -1 0 0 0 -1 0 1 0 0'\n  [../]\n  [./cable]\n    type = SubdomainBoundingBoxGenerator\n    input = outer\n    block_id = '1'\n    bottom_left = '-0.06 -1.55 0'\n    top_right = '0.045 -1.44 0'\n\n\n  [../]\n  [./blocks]\n    type = RenameBlockGenerator\n    input = cable\n    old_block = '0 1'\n    new_block = 'soil cable'\n  [../]\n[]\n\n[GlobalParams]\n  biot_coefficient = 1\n  PorousFlowDictator = dictator\n  displacements = 'disp_x disp_y'\n[]\n\n[Functions]\n  [./pressure_gradient]\n    type = ParsedFunction\n    vars = 'a b'\n    vals = '1000 -9.8065'\n    value = 'if(y>-1.5,0, a*b*y)'\n  [../]\n  [./temperature_gradient]\n    type = ParsedFunction\n    vars = 'a c'\n    vals = '-0.03 293.15'\n    value = a*y+c\n  [../]\n[]\n\n[Variables]\n  [./temperature]\n    [./InitialCondition]\n      type = FunctionIC\n      variable = temperature\n      function = temperature_gradient\n    [../]\n    scaling = 1e-5\n  [../]\n  [./porepressure]\n    [./InitialCondition]\n      type = FunctionIC\n      variable = porepressure\n      function = pressure_gradient\n    [../]\n  [../]\n  [./disp_x]\n    scaling = 1e-10\n  [../]\n  [./disp_y]\n    scaling = 1e-10\n  [../]\n[]\n\n[PorousFlowBasicTHM]\n  porepressure = porepressure\n  temperature = temperature\n  coupling_type = ThermoHydroMechanical\n  gravity = '0 0 0'\n  fp = simple_fluid\n  eigenstrain_names = thermal_contribution\n  use_displaced_mesh = false\n  displacements = 'disp_x disp_y'\n[]\n\n[BCs]\n\n  [./pinned_topx]\n   type = DirichletBC\n   variable = disp_x\n   value = 0\n   boundary = 'top bottom'\n  [../]\n  [./roller_tmax]\n    type = DirichletBC\n    variable = disp_x\n    value = 0\n    boundary = 'left right'\n  [../]\n  [./pinned_topy]\n   type = DirichletBC\n   variable = disp_y\n   value = 0\n   boundary = 'top'\n  [../]\n []\n[]\n\n[FluidProperties]\n  [simple_fluid]\n    type = SimpleFluidProperties\n    bulk_modulus = 2e9\n    viscosity = 0.001\n    density0 = 1000\n    thermal_expansion = 0.000214\n    cp = 4194\n    cv = 4186\n    porepressure_coefficient = 1\n  [../]\n[]\n\n\n\n[Materials]\n\n\n#_______________________________________________\n\n#General\n\n#_______________________________________________\n\n[./porosity_soil]\n  type = PorousFlowPorosity\n  porosity_zero = 0.1\n[../]\n#_______________________________________________\n\n#Thermo\n\n#_______________________________________________\n\n[./thermal_conductivity_soil]\n  type = PorousFlowThermalConductivityIdeal\n  dry_thermal_conductivity = '0.4 0 0  0 0.4 0  0 0 0.4'\n  wet_thermal_conductivity = '1 0 0 0 1 0 0 0 1'\n[../]\n\n[./internal_energy_soil]\n  type = PorousFlowMatrixInternalEnergy\n  density = 1600\n  specific_heat_capacity = 835\n[../]\n\n[./thermal_expansion_soil]\n  type = PorousFlowConstantThermalExpansionCoefficient\n  drained_coefficient = 0.003\n  fluid_coefficient = 0.0002\n[../]\n#_______________________________________________\n\n#Hydro\n\n#_______________________________________________\n\n[./permeability_soil]\n  type = PorousFlowPermeabilityConst\n  permeability = '1e-14 0 0   0 1e-14 0   0 0 1e-14'\n[../]\n\n#_______________________________________________\n\n#Mechanical\n#_______________________________________________\n\n[./biotconstant_uni]\n  type = PorousFlowConstantBiotModulus\n  solid_bulk_compliance = 2.85e-11\n  fluid_bulk_modulus = 2e9\n[../]\n\n[./elasticity_soil]\n  type = ComputeIsotropicElasticityTensor\n  shear_modulus = 44e9\n  bulk_modulus = 38e9\n[../]\n\n[./thermal_contribution_soil]\n  type = ComputeThermalExpansionEigenstrain\n  temperature = temperature\n  thermal_expansion_coeff = 0.001\n  eigenstrain_name = thermal_contribution_soil\n  stress_free_temperature = 293.15\n[../]\n\n[./stress_uni]\n  type = ComputeLinearElasticStress\n[../]\n\n[./strain_soil]\n  type = ComputeSmallStrain #\n  eigenstrain_names = 'thermal_contribution_soil'\n[../]\n\n[Preconditioning]\n  active = basic\n  [./basic]\n    type = SMP\n    full = true\n    petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n    petsc_options_value = ' lu       mumps'\n  [../]\n  [./extended]\n   type = SMP\n   full = true\n   petsc_options = '-ksp_diagonal_scale -ksp_diagonal_scale_fix'\n   petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap'\n   petsc_options_value = ' asm      lu           NONZERO                   2'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  end_time = 1\n  dt = 1\n  nl_abs_tol = 1e-10\n  nl_rel_tol = 1e-10\n[]\n\n[Outputs]\n  print_linear_residuals = true\n  perf_graph = true\n  [./exodus]\n  type = Exodus\n  file_base = output\n  [../]\n  [./csv]\n  type = CSV\n  file_base = output\n  [../]\n\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23335",
          "updatedAt": "2023-02-09T09:17:28Z",
          "publishedAt": "2023-02-03T15:53:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "The PorousFlowBasicTHM assumes that the model is fully saturated - see https://mooseframework.inl.gov/modules/porous_flow/additional_objects.html\nBut you say that you tried using PorousFlowUnsaturated? That should have worked?",
                  "url": "https://github.com/idaholab/moose/discussions/23335#discussioncomment-4866353",
                  "updatedAt": "2023-02-03T21:56:28Z",
                  "publishedAt": "2023-02-03T21:56:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "marinsiebert"
                  },
                  "bodyText": "Well this is awkward, I must have overread this. However, the same happens in PorousFlowUnsaturated. I tried it without BCs as well as with BCs at all boundaries with zero pressure using a Dirichlet and a Neumann, respectively. The latter does create some gradient artifacts, the values remain the same though. I am able to create a reduction in the saturation by emptying the model with sinks through the boundaries, but this does not dry out the whole model.\nUnsaturated.zip\ndry_steady.zip\n[Variables]\n[./temperature]\n[./InitialCondition]\ntype = FunctionIC\nvariable = temperature\nfunction = temperature_gradient\n[../]\nscaling = 1e-8\n[../]\n[./porepressure]\n[./InitialCondition]\ntype = ConstantIC  #FunctionIC\nvalue = 0\nvariable = porepressure\n[../]\n[../]\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/23335#discussioncomment-4868015",
                  "updatedAt": "2023-02-04T06:57:24Z",
                  "publishedAt": "2023-02-04T06:49:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "marinsiebert"
                          },
                          "bodyText": "Apparently my misinterpretation happened in the PorousFlowCapillaryPressureVG, which clearly states, that the effective saturation sits at 1.0 for Pp >= 0, therefore Pp has to be negative  (not = 0) with Pp = - Pc (capillary pressure).\nIn order for the saturation to decrease one then has to choose the van genuchten parameters m and alpha as well as Pp accordingly, e.g. Pp = 1e-6 m = 0.3 and alpha = 1e-4 yields a saturation of roughly 0.14, an Excel-Sheet is helpful to calulcate the achievable saturations.\nAssuming this is now correct I hope this helps others who encounter the same problem.",
                          "url": "https://github.com/idaholab/moose/discussions/23335#discussioncomment-4916577",
                          "updatedAt": "2023-02-09T09:17:00Z",
                          "publishedAt": "2023-02-09T09:16:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Questions about kernels",
          "author": {
            "login": "RWTHLHK"
          },
          "bodyText": "Hello MOOSE experts,\nI am trying to simulate fracture process using phase field module. But one needed kernel \"PhaseFieldFractureMechanicsOffDiag\" is not documented yet. Would someone please give me some explanation what does it do? Another question is that the nonconserved parameters evolution equation is decomposed into 3 parts and compute residuals: TimeDerivative, AllenCahn, and ACInterface, are these residuals summed up during solving?",
          "url": "https://github.com/idaholab/moose/discussions/23379",
          "updatedAt": "2023-06-24T19:40:58Z",
          "publishedAt": "2023-02-08T13:12:05Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@sveerara",
                  "url": "https://github.com/idaholab/moose/discussions/23379#discussioncomment-4913270",
                  "updatedAt": "2023-02-09T02:10:31Z",
                  "publishedAt": "2023-02-09T02:10:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to integrate 'equivalent_slip_increment'",
          "author": {
            "login": "pshen20127"
          },
          "bodyText": "Hello All\nI am trying to integrate 'equivalent_slip_increment' in the file 'CrystalPlasticityStressUpdateBaseAddStateVars.C'. I added several lines as below:\n106   equivalent_slip_increment(declareProperty<RankTwoTensor>(\"equivalent_slip_increment\")),\n107   equivalent_slip_increment_old(getMaterialPropertyOld<RankTwoTensor>(\"equivalent_slip_increment\")),\n\n501   equivalent_slip_increment += equivalent_slip_increment_old;\n\nBut it met an error like this:\n\nWhat's wrong with it and how to fix it? Here is may codes:https://github.com/pshen20127/IN625.git\nThanks\nPengfei",
          "url": "https://github.com/idaholab/moose/discussions/23365",
          "updatedAt": "2023-02-23T21:35:28Z",
          "publishedAt": "2023-02-07T18:20:02Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ajacquey"
                  },
                  "bodyText": "Try:\nequivalent_slip_increment[_qp] += equivalent_slip_increment_old[_qp];",
                  "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4897576",
                  "updatedAt": "2023-02-07T20:15:48Z",
                  "publishedAt": "2023-02-07T20:15:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Thank you for your reply. I have tried and it doesn't work. This is error message.",
                          "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4898092",
                          "updatedAt": "2023-02-07T21:16:31Z",
                          "publishedAt": "2023-02-07T21:16:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You probably are overriding equivalent_slip_increment locally... try\nequivalent_slip_increment += equivalent_slip_increment_old[_qp];\n\nwhich should work but indicate something else you are doing is wrong.",
                          "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4898220",
                          "updatedAt": "2023-02-07T21:28:07Z",
                          "publishedAt": "2023-02-07T21:28:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ajacquey"
                          },
                          "bodyText": "There are a number of things which are incorrect in your files:\n\nThe material property equivalent_slip_increment is declared as a stateful property (you need the old value) but is not initialized in initQpStatefulProperties()\nThe function where the the operation equivalent_slip_increment[_qp] += equivalent_slip_increment_old[_qp]; takes place has equivalent_slip_increment as argument. I am not sure what you are doing because I did not find where and how this function is called in your file. In principle, equivalent_slip_increment += equivalent_slip_increment_old[_qp];  should work but it's confusing. I advise renaming your material property _equivalent_slip_increment to differentiate between local variable and material property.",
                          "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4898256",
                          "updatedAt": "2023-02-07T21:31:22Z",
                          "publishedAt": "2023-02-07T21:31:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "I tried equivalent_slip_increment += equivalent_slip_increment_old[_qp]; and it works. Could you please explain why the former equivalent_slip_increment doesn't need [_qp] but the latter one needs?",
                          "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4899104",
                          "updatedAt": "2023-02-07T23:38:17Z",
                          "publishedAt": "2023-02-07T23:38:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You are adding a rank two tensor to another. The LHS is a rank two tensor, the RHS also has to be a rank two tensor. Your equivalent_slip_increment_old is an array, hence the [] accessor to retrieve the rank two tensor inside.\nPlease follow @ajacquey 's suggestions above.",
                          "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4899897",
                          "updatedAt": "2023-02-08T01:53:24Z",
                          "publishedAt": "2023-02-08T01:53:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Thanks, will do. I also declare equivalent_slip_increment_old as a rank two tensor like below.\nequivalent_slip_increment_old(getMaterialPropertyOld<RankTwoTensor>(\"equivalent_slip_increment\")),\n\nWhy do you say it is array?",
                          "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4908084",
                          "updatedAt": "2023-02-08T17:58:52Z",
                          "publishedAt": "2023-02-08T17:58:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "getMaterialPropertyOld<RankTwoTensor>(\"equivalent_slip_increment\") returns a const MaterialProperty<RankTwoTensor> &. A MaterialProperty<T> is essentially a MooseArray<T> at its core, and MooseArray is our implementation of resizable array.",
                          "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4908746",
                          "updatedAt": "2023-02-08T19:16:54Z",
                          "publishedAt": "2023-02-08T19:16:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "As an aside, I would recommend caution in adding an old equivalent slip increment to the current slip increment: the current slip increment value is used in ComputeMultipleCrystalPlasticityStress to calculate the plastic deformation gradient, see \n  \n    \n      moose/modules/tensor_mechanics/src/materials/crystal_plasticity/ComputeMultipleCrystalPlasticityStress.C\n    \n    \n        Lines 507 to 514\n      in\n      198b8ca\n    \n  \n  \n    \n\n        \n          \n             _models[i]->calculateEquivalentSlipIncrement(equivalent_slip_increment_per_model); \n        \n\n        \n          \n             equivalent_slip_increment += equivalent_slip_increment_per_model; \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n\n        \n          \n           RankTwoTensor residual_equivalent_slip_increment = \n        \n\n        \n          \n               RankTwoTensor::Identity() - equivalent_slip_increment; \n        \n\n        \n          \n           _inverse_plastic_deformation_grad = \n        \n\n        \n          \n               _inverse_plastic_deformation_grad_old * residual_equivalent_slip_increment; \n        \n    \n  \n\n\nOne of the beauties of open source code is that you can make whatever change you like :-) In this case you might want to consider the downstream implications as you make your changes",
                  "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4899949",
                  "updatedAt": "2023-02-08T02:01:20Z",
                  "publishedAt": "2023-02-08T02:01:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Thanks, get it. I will create another variable assigned the value of equivalent slip increment.",
                          "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4908110",
                          "updatedAt": "2023-02-08T18:00:49Z",
                          "publishedAt": "2023-02-08T18:00:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Hello\nAs you suggested, I add some new variables and codes. The main calculation I want to do is from line 505 as below.\n505   equivalent_shearstrain = equivalent_slip_increment;\n506   equivalent_shearstrain += equivalent_shearstrain_old;\n507   equivalent_plastic_strain = sqrt(pow(equivalent_shearstrain(0,0),2)+pow(equivalent_shearstrain(0,1),2)+pow(equivalent_shearstrain(0,2),2)\n508                                  +pow(equivalent_shearstrain(1,0),2)+pow(equivalent_shearstrain(1,1),2)+pow(equivalent_shearstrain(1,2),2)\n509                                  +pow(equivalent_shearstrain(2,0),2)+pow(equivalent_shearstrain(2,1),2)+pow(equivalent_shearstrain(2,2),2));\n\nThe equation from line 507 to 509 is\n\nWhen I compiled the codes, I met many errors:\n\nCould you please tell me how to fix it? Here is my codes : https://github.com/pshen20127/IN625.git",
                          "url": "https://github.com/idaholab/moose/discussions/23365#discussioncomment-4911274",
                          "updatedAt": "2023-02-09T00:16:36Z",
                          "publishedAt": "2023-02-09T00:16:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Dirac Kernels for INSAD",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "Is there a simple way to have DiracKernels work with Vector Variables? Not sure if there is a way to apply it component-wise. Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/23378",
          "updatedAt": "2023-02-15T12:29:04Z",
          "publishedAt": "2023-02-08T11:52:06Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I think the answer is no. This is the first request for this kind of capability. Would you want to take a stab at a VectorDiracKernel? Otherwise you can convert this to an issue (well we should do that anyway) and we can try to tackle it when someone has time!",
                  "url": "https://github.com/idaholab/moose/discussions/23378#discussioncomment-4908739",
                  "updatedAt": "2023-02-08T19:16:00Z",
                  "publishedAt": "2023-02-08T19:15:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "I can take a crack at it. I'm assuming modeling it like ADKernel, templating it for VectorVariable?",
                          "url": "https://github.com/idaholab/moose/discussions/23378#discussioncomment-4909328",
                          "updatedAt": "2023-02-08T20:29:35Z",
                          "publishedAt": "2023-02-08T20:29:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "That would be the most ideal",
                          "url": "https://github.com/idaholab/moose/discussions/23378#discussioncomment-4911138",
                          "updatedAt": "2023-02-08T23:58:14Z",
                          "publishedAt": "2023-02-08T23:58:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}