{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOC0yNFQxNzo0Njo1NC0wNjowMM4AQhgK"
    },
    "edges": [
      {
        "node": {
          "title": "Does Jacobian important for the computation?",
          "author": {
            "login": "Oops-Qiao"
          },
          "bodyText": "Hello buddy,\nI want to ask that in the kernel, if we donot use the AD version, then we should write the weak form and Jacobian. Today I heard from my friend that the weak form should be well written, however, the Jacobian can be written with some terms igonored. Can anyone make comment for this? how and why.\nThank you in advance.\nKind regards,\nQiao",
          "url": "https://github.com/idaholab/moose/discussions/21958",
          "updatedAt": "2022-09-02T20:11:53Z",
          "publishedAt": "2022-08-29T13:47:33Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs this in the context of using Newton's method or PJFNK?\nWith PJFNK, the jacobian may be used for preconditioning. Imperfect preconditioning may or may not affect convergence. If the jacobian is mostly correct, especially if there are correct diagonally dominant terms, then it's likely to converge anyway.\n\nHello buddy,\n\nwho is this buddy you refer to?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21958#discussioncomment-3502047",
                  "updatedAt": "2022-08-29T16:31:09Z",
                  "publishedAt": "2022-08-29T16:31:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Thank you very much. I mean in the context of Newton method.",
                          "url": "https://github.com/idaholab/moose/discussions/21958#discussioncomment-3502142",
                          "updatedAt": "2022-08-29T16:40:47Z",
                          "publishedAt": "2022-08-29T16:40:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "So what you mean here is in PJFNK, incorrect Jacobian just affect the convergence, not the solution right?",
                          "url": "https://github.com/idaholab/moose/discussions/21958#discussioncomment-3502147",
                          "updatedAt": "2022-08-29T16:42:09Z",
                          "publishedAt": "2022-08-29T16:42:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Hello buddy means Hello friend, am I right?",
                          "url": "https://github.com/idaholab/moose/discussions/21958#discussioncomment-3502149",
                          "updatedAt": "2022-08-29T16:42:46Z",
                          "publishedAt": "2022-08-29T16:42:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in both methods, an imperfect Jacobian will only affect the convergence, not the solution (if it is unique). You should search the litterature to learn more about convergence with imperfect Jacobians, we dont have much in the documentation.\nThe solution, which in a well-posed problem is unique, is uniquely defined such that the residual is 0.\nBuddy is pretty familiar for addressing other scientists who you do not know personally ;).",
                          "url": "https://github.com/idaholab/moose/discussions/21958#discussioncomment-3502374",
                          "updatedAt": "2022-08-29T17:09:50Z",
                          "publishedAt": "2022-08-29T17:09:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Ok, thank you very much and also for the explaination of buddy. \uff1a\uff09",
                          "url": "https://github.com/idaholab/moose/discussions/21958#discussioncomment-3503941",
                          "updatedAt": "2022-08-29T21:42:55Z",
                          "publishedAt": "2022-08-29T21:42:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Modify test tolerances",
          "author": {
            "login": "aarograh"
          },
          "bodyText": "Hello, I'm having some challenges setting some test tolerances.  I've tried difference_tol and ratio_tol, both of which are in the output of run_tests --dump, and both of them result in this:\ntests:32: unused parameter \"difference_tol\"\ntests:33: unused parameter \"ratio_tol\"\n\nConversely, I tried setting abs_zero to a very high value since it appears in the dump just like the other 2.  This parameter worked and caused the test to pass.\nAny ideas why those parameters aren't working?  I'm sure I'm misunderstanding something but this is the first time I'm even remotely delving into the test harness.",
          "url": "https://github.com/idaholab/moose/discussions/21949",
          "updatedAt": "2022-09-02T20:11:47Z",
          "publishedAt": "2022-08-26T20:54:17Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthere\u2019s a difference between the parameter names in the test harness and in the utility the test harness leverages.\nabs_zero and rel_tolerr can be parsed by the test harness. I haven\u2019t seen the other two. If you have seen them elsewhere in the repository could you please point me to them?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21949#discussioncomment-3491229",
                  "updatedAt": "2022-08-29T18:00:37Z",
                  "publishedAt": "2022-08-27T23:44:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It\u2019s weird they are in the dump though. I ll check when I get back",
                          "url": "https://github.com/idaholab/moose/discussions/21949#discussioncomment-3491230",
                          "updatedAt": "2022-08-27T23:45:17Z",
                          "publishedAt": "2022-08-27T23:45:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "Thanks for the information, I'll give those names a try.  It would definitely be helpful if the --dump names reflected the actual names that could be used in the file.",
                          "url": "https://github.com/idaholab/moose/discussions/21949#discussioncomment-3500456",
                          "updatedAt": "2022-08-29T13:32:48Z",
                          "publishedAt": "2022-08-29T13:32:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "@GiudGiud I tried rel_tol and still got unused parameter \"rel_tol\" in the test output so it seems like that didn't work.",
                          "url": "https://github.com/idaholab/moose/discussions/21949#discussioncomment-3501247",
                          "updatedAt": "2022-08-29T14:57:10Z",
                          "publishedAt": "2022-08-29T14:57:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so ratio_tol and difference_tol are only for Jacobian exactness testing.\nmy bad, it's not rel_tol but rel_err",
                          "url": "https://github.com/idaholab/moose/discussions/21949#discussioncomment-3502411",
                          "updatedAt": "2022-08-29T17:15:36Z",
                          "publishedAt": "2022-08-29T17:15:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "Oh, got it.  rel_err is listed in the dump as well, so that's good.  Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/21949#discussioncomment-3502425",
                          "updatedAt": "2022-08-29T17:18:03Z",
                          "publishedAt": "2022-08-29T17:18:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yeah I double checked the dump.\nIt's organized by test type, the parameters you used previously are under the test type AnalyzeJacobian only",
                          "url": "https://github.com/idaholab/moose/discussions/21949#discussioncomment-3502708",
                          "updatedAt": "2022-08-29T18:00:18Z",
                          "publishedAt": "2022-08-29T18:00:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Differences among auxiliary kernel, material and userobject.",
          "author": {
            "login": "Oops-Qiao"
          },
          "bodyText": "Hello buddy,\nIt has been awhile for me to undrstand the differences among auxiliary kernel, material and userobject.\nAnyone can give a brief introduction for the differences among these three cases.\nFor me, they all have the common chracteristic, that is, compute something then other objects can use their results.\nThank you in advance.\nBest regards,\nQiao",
          "url": "https://github.com/idaholab/moose/discussions/21956",
          "updatedAt": "2022-09-02T20:11:37Z",
          "publishedAt": "2022-08-29T13:41:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Docs pages should help\nhttps://mooseframework.inl.gov/syntax/Materials/index.html\nhttps://mooseframework.inl.gov/syntax/AuxKernels/index.html\nhttps://mooseframework.inl.gov/syntax/UserObjects/index.html\nin short, you should try to use material properties if you can, especially if using AD.\nauxkernels are equally desirable to compute fields, but dont support AD, and cost more memory (storing an extra field)\nIf your calculation is very complicated, then you ll want to make a custom user object.",
                  "url": "https://github.com/idaholab/moose/discussions/21956#discussioncomment-3502400",
                  "updatedAt": "2022-08-29T17:13:51Z",
                  "publishedAt": "2022-08-29T17:13:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "libmesh error - You requested to reuse the nonlinear residual vector as the base vector",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "I ran into this error that seems to trace back to libmesh, i was wondering if someone could give me some insight.\nYou requested to reuse the nonlinear residual vector as the base vector for computing the action of the matrix-free Jacobian, but the vectors are not the same. Your physics must have states; either remove the states from your code or make sure that you set_mf_reuse_base(false)\nThanks,\nZack",
          "url": "https://github.com/idaholab/moose/discussions/19496",
          "updatedAt": "2022-08-29T15:57:14Z",
          "publishedAt": "2021-11-29T19:06:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@fdkong",
                  "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-1717928",
                  "updatedAt": "2022-08-25T18:02:08Z",
                  "publishedAt": "2021-11-29T19:16:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "@rtaylo45 Could you briefly state what problems are you solving? Are you working on contact problems? Does your problem have discontinuities?",
                  "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-1717944",
                  "updatedAt": "2022-08-25T18:02:08Z",
                  "publishedAt": "2021-11-29T19:19:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "The issue kinda comes up in a weird way. I am coupling SAM and an ORNL moose based app called Mole. I am compiling the codes together in the Mole make file. I can break this problem down into two cases:\n\nClone down both repos, i go into the SAM repo and call make. Go into the Mole repo call make. Run my unit tests and get some exodiff errors with the test associated with coupled Mole/SAM test (not the topic of this discussion) . I run a problem that includes a SAM flow loop and everything runs fine.\nClone down both repos, i go into the Mole repo and call make. The make file tells the code to go and compile SAM and link to it. Run my unit tests, which all pass. But when i try to run the flow loop problem, i get the error i showed above.\n\nWhat's interesting is that the problem only seems to show up for flow loop problems in SAM. Its possible that it will show up in other cases, but i have not found a case where it has. Im not exactly sure what SAM does under the hood to solve these flow problems but i can reach out to them and ask.",
                          "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-1718065",
                          "updatedAt": "2022-08-25T18:02:17Z",
                          "publishedAt": "2021-11-29T19:46:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "It is interesting. There are two modes in SAM: \"stand-alone\" and \"work-with-other.\" That might explain the weird behavior you saw here. Option 1 you did should involve the SAM stand-alone mode that SAM developers might test extensively.  The option 2 you tried was the \"work-with-other\" mode, which might not be fully explored.\nIt could be another reason as well. We have an option to turn this error message off \"snesmf_reuse_base=false\" (executioner block), but we need to get to the bottom of the problem instead of just turning off messages.\nWhat was happening was that PETSc saw the nonlinear function change from nonlinear and linear iterations. That is not common, and in moose, that occurs primarily in mechanics contact module because of contact.\nA SAM developer might be helpful here @lingzou",
                          "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-1718199",
                          "updatedAt": "2022-08-25T18:02:21Z",
                          "publishedAt": "2021-11-29T20:06:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "travismui"
                          },
                          "bodyText": "Hi @fdkong @rtaylo45,\nI believe in SAM we actually set this param snesmf_reuse_base = false by default for our standalone mode. In the coupled Mole/SAM, this option is probably not being set which is why you're seeing the error messages. We are not modeling mechanical contact but there may be other factors that prevent us from using this optimization in some scenarios.",
                          "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-1737801",
                          "updatedAt": "2022-08-25T18:02:22Z",
                          "publishedAt": "2021-12-02T15:20:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Turning terms on or off can create this error right @fdkong ?\nI think this is a common thing to do for 1D TH.",
                          "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-1738689",
                          "updatedAt": "2022-08-25T18:03:45Z",
                          "publishedAt": "2021-12-02T17:16:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "If the function has a state, we can not reuse the base from the nonlinear iteration. In this case, we need to use \"snesmf_reuse_base = false\" to disable that, otherwise you will see an error message. By default, we have \"snesmf_reuse_base = true\" in moose, which means we want to reuse the base from the nonlinear iteration to reduce the number of residual evaluations that is not cheap.\nI am not sure whether or not 1D TH has a state. The equations look just fine to me. There are some special materials?\nIf we are sure that the function has a state, then it is safe to turn the message off. Otherwise that could be a bug somewhere",
                          "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-1741596",
                          "updatedAt": "2022-08-25T18:03:45Z",
                          "publishedAt": "2021-12-03T03:32:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "I've hit this same error in creating a regression test for a new tensor mechanics (crystal plasticity), no contact. I was able to get around the error in opt by moving all of my stateful increment calculations into a single method, but then hit the same error as given in the original posting in dbg.\nClearly I'm piggy-backing on this discussion topic, yet are there any recommendations for how to write materials to avoid this error? I've got an existing PR with the failing regression test and problematic code up ( #19502 ) if it peaks anyone's interest",
                  "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-1725065",
                  "updatedAt": "2022-08-25T18:02:22Z",
                  "publishedAt": "2021-11-30T22:13:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "@sapitts did you ever get any resolution on this?  I am currently running into this error as well in trying to update an app's MOOSE from March 28 to a more recent commit (July 20).",
                          "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-3477044",
                          "updatedAt": "2022-08-25T18:07:05Z",
                          "publishedAt": "2022-08-25T18:07:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Hi @aarograh, I ended up lagging some of the stateful material properties, that were used to calculated other stateful material properties, in order to avoid the error and error message. There's a good chance that the error worked as intended and helped me avoid conflicting states. I hope that you can resolve the error in your code too!",
                          "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-3478321",
                          "updatedAt": "2022-08-25T20:50:56Z",
                          "publishedAt": "2022-08-25T20:50:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I would second Fande's suggestion above: if your residual has state, then you can just set snesmf_reuse_base to false. If your residual doesn't have state, this is a bug. You should get to the bottom of this, otherwise you may get nondeterministic results.",
                          "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-3478594",
                          "updatedAt": "2022-08-25T22:04:40Z",
                          "publishedAt": "2022-08-25T22:04:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "I'm getting back into MOOSE after a couple years out of it, so I'm probably going to ask some stupid questions here.  What do you mean by \"if your residual has state\"?  This particular failure is for a test case of a pretty simple kernel in our application.  The fact that it works with MOOSE from March but not July is pretty concerning.\nI tried setting the snesmf_reuse_base = false and the solve just completely fails to converge the first timestep.  So based on your comment, there is a real problem going on here, but I'm not clear on where to begin in searching for the issue.  Perhaps a better understanding of \"state\"/\"stateful\" would clarify things for me.",
                          "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-3484184",
                          "updatedAt": "2022-08-26T14:10:27Z",
                          "publishedAt": "2022-08-26T14:10:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "We use here the phrase 'residual has state' to indicate that material properties, which depend on old material properties, from the previous timestep, are used in the calculation of the weak form of the PDE.\nAs an example, in rate-dependent tensor mechanics models, we calculate the stress divergence as a function of material properties (e.g. yield surface) that depend on the previous value (from the previous timestep) of that yield surface. We would say this yield surface material property is stateful or has state. This yield stress is used to calculate the stress, and that stress is used to calculate the stress divergence. In a tensor mechanics FEM simulation, we drive the stress divergence to as close to zero as we can (or within a tolerance), and that difference between the ideal zero and actual FEM calculation value is the residual. Because the residual depends on a stateful material property, through this chain, we say here that the residual has state. Hope this helps\nIf you have multiple stateful material properties in your code, as I did, I wonder if there is a potential for those stateful properties to get out of sync. If it was me debugging this type of problem, I'd start by checking to make sure all the material properties were initialized as expected and then walk through the system to monitor the values. I'm interested to hear the debugging recommendations from @hugary1995 too!",
                          "url": "https://github.com/idaholab/moose/discussions/19496#discussioncomment-3501012",
                          "updatedAt": "2022-08-29T14:33:58Z",
                          "publishedAt": "2022-08-29T14:33:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the variable values from neighbor elements of current element\uff1f",
          "author": {
            "login": "xiaojbing"
          },
          "bodyText": "Hello\uff0c\nI want to know how to get the  variable from  nieghbor element, and which class need to be inherited.\nthank you.",
          "url": "https://github.com/idaholab/moose/discussions/21907",
          "updatedAt": "2022-08-26T16:01:00Z",
          "publishedAt": "2022-08-20T11:42:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCould you please give us more details about what you're trying to do here?\nTypically you would want to use the coupledNeighborValue from the Coupleable interface to retrieve the neighbor values.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3443772",
                  "updatedAt": "2022-08-22T04:15:06Z",
                  "publishedAt": "2022-08-22T04:15:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "Thank you.\nI want to caculate and refresh a coefficient every timestep.\nThis coefficient rely an average value of current element and surrounding element.\nFor example,  a is a value stored in current element , b , c , d are sepretedly the values stored in surrounding elements of current element. and I want to get 1/4(a+b+c+d).\nWhat should I do?",
                          "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3444349",
                          "updatedAt": "2022-08-22T08:56:41Z",
                          "publishedAt": "2022-08-22T06:50:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so is there a single value by element? Many variable types will have different values at each quadrature point",
                          "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3448224",
                          "updatedAt": "2022-08-22T14:30:58Z",
                          "publishedAt": "2022-08-22T14:30:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "Thank you\nthe a b c d are the same variable, just in different element. An element only have one value, for example, A represent velocity, each element only have one velocity. I want to get an average velocity of current element and it's surrouding element. may not the value\nat quadrature point. So how to get the single value in different element?",
                          "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3452473",
                          "updatedAt": "2022-08-23T02:33:02Z",
                          "publishedAt": "2022-08-23T02:33:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "For a generic finite element formulation there is no one single variable value in an element. Only constant monomial finite element types have constant elemental values",
                          "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3455753",
                          "updatedAt": "2022-08-23T11:32:21Z",
                          "publishedAt": "2022-08-23T11:32:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "I am a new user of moose....\nfor example,\nIn ex_01 , every quadrature point have a variable diffused\uff0cthe value at other positions is interpolated, right?\n[Variables]\n  [./diffused]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3463565",
                          "updatedAt": "2022-08-24T08:32:25Z",
                          "publishedAt": "2022-08-24T08:32:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes.\nYou may project the variable on a CONSTANT MONOMIAL basis if you want need a cell-average",
                          "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3465241",
                          "updatedAt": "2022-08-24T12:18:42Z",
                          "publishedAt": "2022-08-24T12:18:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "Thank you.\nAnother question is how to get the variable in elements around the current element?\nCan I use a pointer to get the sourrounding elemental information? pointer  _current_elem in Kernel point to current element, right?",
                          "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3465804",
                          "updatedAt": "2022-08-24T13:32:00Z",
                          "publishedAt": "2022-08-24T13:32:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "From current elem you can obtain the list of neighbors. From there you could obtain the degree-of-freedom (dof) index and index into the solution variable. I dont think we have any open example of doing this though",
                          "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3467658",
                          "updatedAt": "2022-08-24T16:57:36Z",
                          "publishedAt": "2022-08-24T16:57:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it's pretty hacky at this point",
                          "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3467660",
                          "updatedAt": "2022-08-24T16:57:56Z",
                          "publishedAt": "2022-08-24T16:57:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "Thank you.\nThat is good, but not convient to get the variable value in cornel element.\n\nSo I want to ask a new question...\nThe variable values at each element node are interplated. which quadrature points are used to caculate the value at node? The element inner quadrature points around the node? if so, I want to to get the variable value at every current element node. And my question will be solved.",
                          "url": "https://github.com/idaholab/moose/discussions/21907#discussioncomment-3470632",
                          "updatedAt": "2022-08-25T02:57:23Z",
                          "publishedAt": "2022-08-25T02:57:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error in compiling Moose Application",
          "author": {
            "login": "Salma-Mao"
          },
          "bodyText": "Hello everyone,\nThere are two problems.\n\nThe core of my computer is 18  and he running memory is 64g. If the number of cores selected  exceeds 10, the calculation cannot be performed. I get the error.\n\n===================================================================================\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 5191 RUNNING AT 940a54af5dff\n=   EXIT CODE: 7\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Bus error (signal 7)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions\n\nThe blocks of my case are 4. When I only output the mesh, it  displays 4 blocks. However,  the number of blocks in the output after the calculation  is 2.",
          "url": "https://github.com/idaholab/moose/discussions/21934",
          "updatedAt": "2022-09-02T19:53:03Z",
          "publishedAt": "2022-08-25T15:18:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you try running with a distributed mesh?\nThat's weird. Are you running something that deletes elements?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3475871",
                  "updatedAt": "2022-08-25T15:32:42Z",
                  "publishedAt": "2022-08-25T15:32:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Salma-Mao"
                          },
                          "bodyText": "https://mooseframework.inl.gov/source/userobject/CoupledVarThresholdElementSubdomainModifier.html is used. I donot know how to run with a distributed mesh. Could you give me an example\uff1f",
                          "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3476074",
                          "updatedAt": "2022-08-25T15:55:28Z",
                          "publishedAt": "2022-08-25T15:54:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if all the objects in your simulation are good for distributed meshes, just add --distributed-mesh on the command line\nsee this docs\nReplicated and Distributed Mesh",
                          "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3476084",
                          "updatedAt": "2022-08-25T15:55:35Z",
                          "publishedAt": "2022-08-25T15:55:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Salma-Mao"
                          },
                          "bodyText": "Do you know why  the number of cores selected exceeds 10, the calculation cannot be performed?  The cores of  my computer are 18.",
                          "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3476119",
                          "updatedAt": "2022-08-25T15:59:47Z",
                          "publishedAt": "2022-08-25T15:59:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it could be that you are running out of memory. That s why we should try the distributed mesh.\nYou could add a postprocessor to report on memory usage",
                          "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3476385",
                          "updatedAt": "2022-08-25T16:31:01Z",
                          "publishedAt": "2022-08-25T16:31:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Salma-Mao"
                  },
                  "bodyText": "I only used 30% of the running memory. That's so  weird.",
                  "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3481471",
                  "updatedAt": "2022-08-26T08:48:04Z",
                  "publishedAt": "2022-08-26T08:48:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the memory can spike at times. You d want to run that postprocessor that captures all spikes\nhttps://mooseframework.inl.gov/source/postprocessors/MemoryUsage.html",
                          "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3485093",
                          "updatedAt": "2022-08-26T15:55:20Z",
                          "publishedAt": "2022-08-26T15:55:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "libMesh Update 2022.08.23",
          "author": {
            "login": "milljm"
          },
          "bodyText": "A new libMesh made its way to the MOOSE master branch yesterday. For those using the conda packages, please perform\nmamba update --all\n\nin your MOOSE conda environment. The appropriate moose-libmesh package version should be 2022.08.23. For those using the the libMesh submodule, please run in the moose/scripts directory\n./update_and_rebuild_libmesh.sh\n\nafter updating your copy of MOOSE.",
          "url": "https://github.com/idaholab/moose/discussions/21936",
          "updatedAt": "2022-08-25T15:51:13Z",
          "publishedAt": "2022-08-25T15:51:12Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Convergence impact of volumetric locking correction",
          "author": {
            "login": "Flolaffel"
          },
          "bodyText": "Hello,\nI already opened a similar discussion once but I'm still having trouble with the volumetric locking correction in my frictional contact problems. The input I'm using is:\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  volumetric_locking_correction = true\n[]\n\n[Mesh]\n  [rad]\n    type = AnnularMeshGenerator\n    nt = 16\n    nr = 12\n    rmin = 17.5\n    rmax = 40\n    dmin = 225\n    dmax = 315\n  []\n  [extrude]\n    type = MeshExtruderGenerator\n    input = rad\n    extrusion_vector = '0 0 18'\n    num_layers = 7\n  []\n  [transform]\n    type = TransformGenerator\n    input = extrude\n    transform = translate\n    vector_value = '0 40 0'\n  []\n  [rad_id]\n    type = SubdomainIDGenerator\n    input = transform\n    subdomain_id = 1\n  []\n  [boden]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 8\n    ny = 1\n    nz = 5\n    xmin = -35\n    xmax = 35\n    ymin = -1\n    ymax = 0\n    zmin = -7\n    zmax = 25\n    boundary_id_offset = 100\n  []\n  [boden_id]\n    type = SubdomainIDGenerator\n    input = boden\n    subdomain_id = 2\n  []\n  [collect_meshes]\n    type = MeshCollectionGenerator\n    inputs = 'rad_id boden_id'\n  []  \n  patch_update_strategy = iteration\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = FINITE\n    block = '1 2'\n  []\n[]\n\n[Contact]\n  [kontakt]\n    primary = top\n    secondary = rmax\n    formulation = penalty\n    penalty = 1e4 \n    model = coulomb\n    friction_coefficient = 0.6\n    normal_smoothing_distance = 0.1\n  []\n[]\n\n[Dampers]\n  [contact_slip]\n    type = ContactSlipDamper\n    primary = top\n    secondary = rmax\n  []\n[]\n\n[Functions]\n  [load_disp]\n    type = ParsedFunction\n    value = '-3.7 * t'\n  []\n[]\n\n[BCs]\n  [load_disp]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = rmin\n    function = load_disp\n  []\n  [ground_fixed_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = bottom\n    value = 0\n  []\n  [ground_fixed_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0\n  []\n  [ground_fixed_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = bottom\n    value = 0\n  []\n  [wheel_fixed_z] \n    type = DirichletBC\n    variable = disp_z\n    boundary = rmin\n    value = 0\n  []\n  [wheel_fixed_x] \n    type = DirichletBC\n    variable = disp_x\n    boundary = rmin\n    value = 0\n  []\n[]\n\n[Materials]\n  [rad_elasticity]\n    type = ComputeIsotropicElasticityTensor\n    bulk_modulus = 320\n    shear_modulus = 0.5\n    block = '1'\n  []\n  [rad_stress]\n    type = ComputeFiniteStrainElasticStress\n    block = '1'\n  []    \n  [boden_elasticity]\n    type = ComputeIsotropicElasticityTensor\n    block = '2'\n    youngs_modulus = 1e3\n    poissons_ratio = 0.35\n  []\n  [boden_stress]\n    type = ComputeFiniteStrainElasticStress\n    block = '2'\n  []\n[]\n\n[Preconditioning]\n  [SMP]\n    solve_type = 'PJFNK'\n    type = SMP\n    full = true\n    petsc_options_iname = '-pc_type -pc_factor_mat_solver_type'\n    petsc_options_value = 'lu       superlu_dist'\n  []\n[]\n\n\n[Executioner]\n   type = Transient\n   start_time = 0.0\n   dt = 0.0125\n   end_time = 1.0\n   nl_abs_tol = 1e-6\n   nl_rel_tol = 1e-6\n   line_search = none\n   [Predictor]\n     type = SimplePredictor\n     scale = 1.0\n   []\n    l_tol = 1e-3\n   nl_max_its = 50\n []\n\n[Outputs]\n  exodus = true\n  csv = true\n[]\n\n[Postprocessors]\n  [nonlin_it]\n    type = NumNonlinearIterations\n  []\n  [cumulative_nonlin_it]\n    type = CumulativeValuePostprocessor\n    postprocessor = nonlin_it\n  []\n  [lin_it]\n    type = NumLinearIterations\n  []\n  [cumulative_lin_it]\n    type = CumulativeValuePostprocessor\n    postprocessor = lin_it\n  []\n  [time_sum]\n    type = PerfGraphData\n    section_name = \"Root\"\n    data_type = total\n    execute_on = 'initial nonlinear timestep_end'\n  []\n[]\n\nIt is meant to represent a segment of a rubber wheel getting pressed onto the ground. When not using locking correction there is locking which leads to incorrect contact behavior to the ground (the material in the contact zone is forced to expand to side in z direction instead of a more frictional sticky behaviour). I ran the simulation with two different shear moduli mu: 5 MPa and 0.5 MPa. The locking is worse for 0.5 MPa since the material is closer to incompressibility there. Then I ran both these simulations again but with locking correction activated.\nWhat I observed regarding convergence:\n\n0.5 MPa: 189 nonlinear iterations (nl it), 4182 linear iterations (l it)\n5 MPa: 222 nl it, 10775 l it\n0.5 MPa with locking correction: convergence so bad I aborted the simulation, would've taken too long\n5 MPa with locking correction: 199 nl it, 6297 l it\n\nWhat confuses me is the impact of the locking correction. Since there shouldn't be any locking regardless of the used shear modulus I'd expect the simulations that use the locking correction to behave similarily. But when mu = 0.5 MPa the locking correction has a harsh negative impact on convergence while with mu = 5 MPa it actually benefits convergence.\nIs there any known impact on convergence for locking correction? Or does anyone have an idea what causes this behaviour?",
          "url": "https://github.com/idaholab/moose/discussions/21730",
          "updatedAt": "2022-09-02T19:53:35Z",
          "publishedAt": "2022-07-30T12:39:38Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@recuero @jiangwen84 @bwspenc any suggestions for this user?",
                  "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3380503",
                  "updatedAt": "2022-08-12T02:30:39Z",
                  "publishedAt": "2022-08-12T02:30:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "It may be that the Jacobian, when volumetric locking is used, is not as accurate as without locking correction. Any numerical impediment when using frictional contact will tend to hinder convergence noticeably. I agree that, in many problems, locking correction can be enabled and its practical impact on the results still be negligible, but, with contact, I wonder if the additional modes of deformation enabled by locking correction make the contact interface problem more challenging (i.e. can the combination of frictional and internal forces excite volumetric modes?).\nBelow an input file that uses automatic differentiation with your problem. I halved the time step. It solves in 4/5 nonlinear iterations and the number of linear iterations per nonlinear iteration is no more than 12/13.\nThat said, I do not fully understand these statements:\n\nSince there shouldn't be any locking regardless of the used shear modulus\n\nand\n\nWhen not using locking correction there is locking which leads to incorrect contact behavior to the ground (the material in the contact zone is forced to expand to side in z direction instead of a more frictional sticky behaviour)\n\nDo you expect locking correction to be relevant for the problem above? Are you using a different material model for your own testing?\n\n  displacements = 'disp_x disp_y disp_z'\n  volumetric_locking_correction = true\n[]\n\n[Mesh]\n  [rad]\n    type = AnnularMeshGenerator\n    nt = 16\n    nr = 12\n    rmin = 17.5\n    rmax = 40\n    dmin = 225\n    dmax = 315\n  []\n  [extrude]\n    type = MeshExtruderGenerator\n    input = rad\n    extrusion_vector = '0 0 18'\n    num_layers = 7\n  []\n  [transform]\n    type = TransformGenerator\n    input = extrude\n    transform = translate\n    vector_value = '0 40 0'\n  []\n  [rad_id]\n    type = SubdomainIDGenerator\n    input = transform\n    subdomain_id = 1\n  []\n  [boden]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 8\n    ny = 1\n    nz = 5\n    xmin = -35\n    xmax = 35\n    ymin = -1\n    ymax = 0\n    zmin = -7\n    zmax = 25\n    boundary_id_offset = 100\n  []\n  [boden_id]\n    type = SubdomainIDGenerator\n    input = boden\n    subdomain_id = 2\n  []\n  [collect_meshes]\n    type = MeshCollectionGenerator\n    inputs = 'rad_id boden_id'\n  []\n  patch_update_strategy = iteration\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = FINITE\n    block = '1 2'\n    use_automatic_differentiation = true\n  []\n[]\n\n[Contact]\n  [kontakt]\n    primary = top\n    secondary = rmax\n    formulation = penalty\n    penalty = 1e1\n    normalize_penalty = true\n    model = coulomb\n    friction_coefficient = 0.6\n    normal_smoothing_distance = 0.1\n  []\n[]\n\n[Dampers]\n  [contact_slip]\n    type = ContactSlipDamper\n    primary = top\n    secondary = rmax\n  []\n[]\n\n[Functions]\n  [load_disp]\n    type = ParsedFunction\n    value = '-3.7 * t'\n  []\n[]\n\n[BCs]\n  [load_disp]\n    type = ADFunctionDirichletBC\n    variable = disp_y\n    boundary = rmin\n    function = load_disp\n  []\n  [ground_fixed_x]\n    type = ADDirichletBC\n    variable = disp_x\n    boundary = bottom\n    value = 0\n  []\n  [ground_fixed_y]\n    type = ADDirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0\n  []\n  [ground_fixed_z]\n    type = ADDirichletBC\n    variable = disp_z\n    boundary = bottom\n    value = 0\n  []\n  [wheel_fixed_z]\n    type = ADDirichletBC\n    variable = disp_z\n    boundary = rmin\n    value = 0\n  []\n  [wheel_fixed_x]\n    type = ADDirichletBC\n    variable = disp_x\n    boundary = rmin\n    value = 0\n  []\n[]\n\n[Materials]\n  [rad_elasticity]\n    type = ADComputeIsotropicElasticityTensor\n    bulk_modulus = 320\n    shear_modulus = 0.5\n    block = '1'\n  []\n  [rad_stress]\n    type = ADComputeFiniteStrainElasticStress\n    block = '1'\n  []\n  [boden_elasticity]\n    type = ADComputeIsotropicElasticityTensor\n    block = '2'\n    youngs_modulus = 1e3\n    poissons_ratio = 0.35\n  []\n  [boden_stress]\n    type = ADComputeFiniteStrainElasticStress\n    block = '2'\n  []\n[]\n\n[Preconditioning]\n  [SMP]\n    solve_type = 'PJFNK'\n    type = SMP\n    full = true\n\n  []\n[]\n\n[Executioner]\n  type = Transient\n  start_time = 0.0\n  dt = 0.00625\n  end_time = 1.0\n  nl_abs_tol = 1e-6\n  nl_rel_tol = 1e-6\n  line_search = none\n\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_type'\n  petsc_options_value = 'lu       superlu_dist'\n  #[Predictor]\n  #  type = SimplePredictor\n  #  scale = 1.0\n  #[]\n  l_tol = 1e-3\n  nl_max_its = 50\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n[]\n\n[Postprocessors]\n  [nonlin_it]\n    type = NumNonlinearIterations\n  []\n  [cumulative_nonlin_it]\n    type = CumulativeValuePostprocessor\n    postprocessor = nonlin_it\n  []\n  [lin_it]\n    type = NumLinearIterations\n  []\n  [cumulative_lin_it]\n    type = CumulativeValuePostprocessor\n    postprocessor = lin_it\n  []\n  [time_sum]\n    type = PerfGraphData\n    section_name = \"Root\"\n    data_type = total\n    execute_on = 'initial nonlinear timestep_end'\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3386226",
                  "updatedAt": "2022-08-12T17:30:06Z",
                  "publishedAt": "2022-08-12T17:30:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "I wonder if the additional modes of deformation enabled by locking correction make the contact interface problem more challenging (i.e. can the combination of frictional and internal forces excite volumetric modes?).\n\nSadly, I'm not able to answer this question. But assuming it was true that the enabled deformation modes make the problem more challenging, then why would locking correction improve convergence for mu = 5 and hinder it for mu = 0.5?\n\nBelow an input file that uses automatic differentiation with your problem. I halved the time step. It solves in 4/5 nonlinear iterations and the number of linear iterations per nonlinear iteration is no more than 12/13.\n\nIs the picture you attached from said input? Because while you're right that the linear convergence improves massively with AD, running the input still results in a lot of failed time steps for me (negative Jacobian entries).\nIs there any specific reason you commented out the predictor? Because in my experience it's quite a helpful tool for contact convergence in MOOSE which is also true for your provided input (it runs seemingly without failed time steps with predictor enabled).\n\nDo you expect locking correction to be relevant for the problem above? Are you using a different material model for your own testing?\n\nYes, volumetric locking seems to be a significant problem in the presented simulation. I just worded myself poorly. What I intented to say, was:\n\nSince there shouldn't be any locking regardless of the used shear modulus when using locking correction\n\nSo the quintessence of my statement was: I would expect the simulations that use locking correction to behave similarly regarding convergence impact, regardless of the shear modulus since volumetric locking should be non existent anymore. Problem is: they don't which is part of my confusion.\nFurthermore, I used different material models for testing. The plan is to use UMAT as the final material model. There, the behavioral problems are similar to the built-in material model which is why I provided that one for the forum discussion.\nUnluckily though your AD solution isn't compatible with the MOOSE UMAT class AFAIK.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3388949",
                          "updatedAt": "2022-08-13T11:20:03Z",
                          "publishedAt": "2022-08-13T09:46:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "why would locking correction improve convergence for mu = 5 and hinder it for mu = 0.5?\n\nI'd speculate, given the AD results, we can improve the Jacobian in that case. For mu = 0.5, Poisson's ratio is closer to incompressibility so the action of volumetric locking correction would be more relevant.\n\nIs the picture you attached from said input? Because while you're right that the linear convergence improves massively with AD, running the input still results in a lot of failed time steps for me (negative Jacobian entries).\n\n\nIs there any specific reason you commented out the predictor? Because in my experience it's quite a helpful tool for contact convergence in MOOSE which is also true for your provided input (it runs seemingly without failed time steps with predictor enabled).\n\nYeah, the picture is from that AD input file, which runs until the end of your simulation. There are a number of failed time steps in the simulation, especially as deformation becomes larger. Honestly, I didn't look too much into it, but it seemed to me that it was mostly cutting the time step once, or twice at the very end. You can certainly add the predictor for this problem, and I'd think it would help, just like you said. The only reason I removed the predictor was to assess convergence behavior without it.\n\nregardless of the shear modulus since volumetric locking should be non existent anymore\n\nTrue. And AD seems to show that the Jacobian can be improved, because the more we need the locking correction, the more its Jacobian contribution will be relevant.\n\nUnluckily though your AD solution isn't compatible with the MOOSE UMAT class AFAIK.\n\nAs things stand right now, you are right. We could potentially support a version of user subroutines that leverages AD objects for C++. Alternatively, you could take a stab at implementing your models within MOOSE's design, but this latter option is less appealing to you as far as I understand.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3390022",
                          "updatedAt": "2022-08-13T15:38:11Z",
                          "publishedAt": "2022-08-13T15:38:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "I'd speculate, given the AD results, we can improve the Jacobian in that case. For mu = 0.5, Poisson's ratio is closer to incompressibility so the action of volumetric locking correction would be more relevant.\n\nWell then I guess I'll just have to deal with it for now. Thanks for opening the issue though.\n\nAlternatively, you could take a stab at implementing your models within MOOSE's design, but this latter option is less appealing to you as far as I understand.\n\nI already have an AD version of the UMAT implemented (Neo Hooke). But you are right that using this implementation is less appealing than the UMAT right now since using the UMAT serves as a proof of concept for possible future projects with more complex UMATs. I guess I'll use both for now for comparison.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3394204",
                          "updatedAt": "2022-08-14T20:14:57Z",
                          "publishedAt": "2022-08-14T20:14:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The new kernels in tensor mechanics + NEML could give you exact Jacobian using UMAT without AD.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3394275",
                          "updatedAt": "2022-08-14T20:34:13Z",
                          "publishedAt": "2022-08-14T20:34:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "What is NEML?",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3396354",
                          "updatedAt": "2022-08-15T07:58:04Z",
                          "publishedAt": "2022-08-15T07:58:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I take it back, you don't need NEML here (NEML is another material library). So we've been developing this new system in tensor mechanics that gives you exact Jacobian without using AD. But an Abaqus UMAT interface is still missing in the new system. I can add that interface for UMAT and you should be able to get exact Jacobian (with volumetric locking correction) without AD. I should be able to do it this month. That being said, I don't guarantee an exact Jacobian will solve your convergence issue with contact.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3415198",
                          "updatedAt": "2022-08-17T14:04:38Z",
                          "publishedAt": "2022-08-17T14:04:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay, so the PR is up: #21871\nYou can checkout the PR and test to see if it improves the convergence with VLC. Mind that your DDSDDE in the UMAT has to be exact in order for the overall Jacobian to be exact.\nYou can also be patient and wait for this PR to be merged. It's up to you.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3417294",
                          "updatedAt": "2022-08-17T19:10:53Z",
                          "publishedAt": "2022-08-17T19:10:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Thanks a lot! I was on holiday, but I'll check it out in the following days.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3473105",
                          "updatedAt": "2022-08-25T10:02:43Z",
                          "publishedAt": "2022-08-25T10:02:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "Issue on @Flolaffel's investigation: #21842.",
                  "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3390030",
                  "updatedAt": "2022-08-13T15:43:49Z",
                  "publishedAt": "2022-08-13T15:43:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "a problem of multivariable",
          "author": {
            "login": "dingqiushi"
          },
          "bodyText": "I want to write a kernel for multivariable, but I have some problems with the data type when calculating the residuals and Jacobi.\n\nIn a kernel suitable for single variable, I know that the component of the data type RealVectorValue is of type Real, so in a kernel suitable for multiple variables, what component of the data type is of type RealEigenVector? In other words, what is the data type of a variable consisting of the RealEigenVector type?\nBecause of the member function type requirement, the data type of the return value must be RealEigenVector. By testing I know that the data type of _grad_test[_i][_qp] is RealGradient, and I want to know what data type can be multiplied with the RealGradient type and the result of the multiplication is RealEigenVector type. I tried the RealVectorArrayValue type and the RealEigenMatrix type ,the following errors were reported at compile time.\n\uff081)\n\nerror: no match for operator* (operand types are \u2019libMesh::RealVectorArrayValue {aka Eigen::Matrix<double,-1,3>}\u201d and 'const value_type {aka const libMesh::VectorValue<double>}') \nreturn flux * _test[_i][_qp] + (lift*_grad_test[_i][_qp]);\n\n\uff082\uff09\nerror: no match for operator* (operand types are \u2019libMesh::RealEigenMatrix {aka Eigen::Matrix<double,-1,-1>}\u201d and 'const value_type {aka const libMesh::VectorValue<double>}') \nreturn flux * _test[_i][_qp] + (lift*_grad_test[_i][_qp]);\n\n\nIn my attempts to pass values, I found that it actually compiles when the left side of the equal sign is of type RealGradient and the right side is of type Real, does this make sense?",
          "url": "https://github.com/idaholab/moose/discussions/21922",
          "updatedAt": "2022-09-02T19:53:59Z",
          "publishedAt": "2022-08-23T12:16:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you want a kernel that contributes to the residual for multiple variables? Is this an array variable or multiple regular variables?\nVariables with the RealEigenVector type are array variables.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3457205",
                  "updatedAt": "2022-08-23T14:20:27Z",
                  "publishedAt": "2022-08-23T14:20:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dingqiushi"
                          },
                          "bodyText": "Yes, the variables I use are array variables. The kernel inherit from ArrayKernel.C.",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3461222",
                          "updatedAt": "2022-08-24T00:55:03Z",
                          "publishedAt": "2022-08-24T00:55:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "All definitions are in moose/framework/include/utils/MooseTypes.h including the following:\ntypedef Eigen::Matrix<Real, Eigen::Dynamic, 1> RealEigenVector;\n\nYou also want to take a look at ArrayDiffusion.C.",
                  "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3460654",
                  "updatedAt": "2022-08-23T22:26:54Z",
                  "publishedAt": "2022-08-23T22:25:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dingqiushi"
                          },
                          "bodyText": "Thanks for the replies, I noticed ArrayDiffusion.C but I didn't see anything similar to what I did and didn't find any variables to multiply with _grad_test[_i][_qp].\nI have one more question for you all here, what is the difference between _array_grad_test and _grad_test?",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3461422",
                          "updatedAt": "2022-08-24T01:40:31Z",
                          "publishedAt": "2022-08-24T01:40:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Regular variables multiply with grad_test when doing integration by parts on a laplacian for example.\narray_grad_test is the equivalent for array variables",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3461845",
                          "updatedAt": "2022-08-24T03:33:02Z",
                          "publishedAt": "2022-08-24T03:33:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dingqiushi"
                          },
                          "bodyText": "Is there a data type which can fit multiple variables and at the same time represent a four-dimensional matrix?\nTip: The four-dimensional matrix I want to construct (size 5533) can be understood as a large matrix (55) with many small matrices (25 small 3*3 matrices in total) nested inside it.",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3463721",
                          "updatedAt": "2022-08-24T08:48:52Z",
                          "publishedAt": "2022-08-24T08:48:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no there are no tensor variables in moose. You may use a very large array if it's convenient with regards to the equations",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3465234",
                          "updatedAt": "2022-08-24T12:17:58Z",
                          "publishedAt": "2022-08-24T12:17:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dingqiushi"
                          },
                          "bodyText": "Thanks for your reply, I saw this definition in the Eigen library and it seems to represent a four dimensional variable, is there a similar expression in moose?\n\nhttp://eigen.tuxfamily.org/dox/classEigen_1_1Array.html#title4",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3470374",
                          "updatedAt": "2022-08-25T02:01:19Z",
                          "publishedAt": "2022-08-25T02:01:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can use these constructs but not for variables currently. You could create tensor material properties for example",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3470649",
                          "updatedAt": "2022-08-25T03:02:36Z",
                          "publishedAt": "2022-08-25T03:02:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem while using HEX20 elements with AD",
          "author": {
            "login": "Sina-av"
          },
          "bodyText": "Hi all!\nI try to run a simple 3D example of a solid. The body consists of a single cube fixed at one end and pulled from the other end. I use Moose to generate the mesh, and set\nelem_type = HEX20\n\nand accordingly set the order of displacements to second.\nFor all kernels and materials I use the AD version available in the TensorMechanics module.\nI get a Libmesh error massage\n.../libmesh/include/metaphysicl/dynamic_std_array_wrapper.h, line 125, compiled Aug 23 2022 at 15:50:25\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\n\nHowever, the simulation runs without a problem when I set the element type to Hex8.\nBelow is the input file:\nE = 35000.\nnu = 0.2\n\nK = '${fparse E/3/(1-2*nu)}'\nG = '${fparse E/2/(1+nu)}'\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  order = second\n[]\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 1\n    ny = 1\n    nz = 1\n    elem_type = HEX20\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n[]\n\n[Kernels]\n  [solid_x]\n    type = ADStressDivergenceTensors\n    variable = disp_x\n    component = 0\n  []\n  [solid_y]\n    type = ADStressDivergenceTensors\n    variable = disp_y\n    component = 1\n  []\n  [solid_z]\n    type = ADStressDivergenceTensors\n    variable = disp_z\n    component = 2\n  []\n[]\n\n[BCs]\n  [xfix]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    value = 0\n  []\n  [yfix]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0\n  []\n  [zfix]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    value = 0\n  []\n  [pull]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'top'\n    function = t\n  []\n[]\n\n[Materials]\n  [strain]\n    type = ADComputeSmallStrain\n  []\n  [elasticity]\n    type = ADComputeIsotropicElasticityTensor\n    shear_modulus = ${G}\n    bulk_modulus = ${K}\n  []\n  [stress]\n    type = ADComputeLinearElasticStress\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu       superlu_dist                 '\n\n  line_search = none\n  automatic_scaling = true\n\n  dt = 0.1\n  end_time = 0.1\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-8\n[]\n\nThanks a lot.",
          "url": "https://github.com/idaholab/moose/discussions/21929",
          "updatedAt": "2022-08-24T23:46:54Z",
          "publishedAt": "2022-08-24T22:16:31Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis error is typical from having an AD derivative container that is too small.\nYou will need to recompile with a larger container size in moose/ with\n./configure --with-derivative-size=100 to roughly double that size (it may not be enough).\nThen recompile and try again.\nIt's not very gracious but dynamically sizing these containers comes at a very high performance cost so we have statically sized them\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21929#discussioncomment-3469609",
                  "updatedAt": "2022-08-24T22:19:04Z",
                  "publishedAt": "2022-08-24T22:19:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Sina-av"
                          },
                          "bodyText": "Thank you so much, it worked!",
                          "url": "https://github.com/idaholab/moose/discussions/21929#discussioncomment-3469882",
                          "updatedAt": "2022-08-24T23:46:55Z",
                          "publishedAt": "2022-08-24T23:46:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}