{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNS0wMy0xMVQwNzo1MDo0My0wNjowMM4AePt3"
    },
    "edges": [
      {
        "node": {
          "title": "SubChannel not in Application Makefile",
          "author": {
            "login": "garcs2"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello!\nI'm wanting to use the Subchannel module that I see is now up in the master branch (or I see it located in moose/modules/subchannel). I'd like to include it in my own application, where I have my own executable with subchannel installed for local input file testing along with being able to use the VSCode MOOSE extension. However, I see that after updating my moose repo I don't see subchannel available in the Makefile of my application. Does this mean that subchannel is still not quite ready for deployment and I should wait a bit?",
          "url": "https://github.com/idaholab/moose/discussions/30084",
          "updatedAt": "2025-03-13T14:44:44Z",
          "publishedAt": "2025-03-13T14:16:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nyou need to modify your makefile to add subchannel := yes. The makefile wont add the new options automatically",
                  "url": "https://github.com/idaholab/moose/discussions/30084#discussioncomment-12489511",
                  "updatedAt": "2025-03-13T14:41:54Z",
                  "publishedAt": "2025-03-13T14:41:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Geoscience: your desired MOOSE enhancements",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi folks,\nThis week, at the MOOSE International Workshop we're going to be discussing potential MOOSE enhancements for geoscience research.  I hope that we will cluster and rank potential enhancements, and work out implementation plans amongst ourselves and with the Framework team.  I suspect most enhancements will focus on PorousFlow, but there will be discussion around our typical \"companion\" modules such as FluidProperties, SolidMechanics, Geochemistry, etc.\nPlease could you list your desired enhancements in the discussion below?\nPreferably, you would contribute during the next 24 hours, but we'll probably see your ideas and include them in discussions if they appear during the next 72 hours.\nWe'll be having at least one face-to-face session to cluster, rank and plan (and probably more than one session) over the next 4 days.  It may be possible to dial into a Teams/Zoom/etc meeting to be involved: I've yet to explore the practicality of that.  If you want to be involved in a potential dial-in, please write that below, and I/someone will contact you with details before the dial-in happens (if it happens).\nWhen I have time, I'll include some of my ideas below, but please don't let them restrict your thinking.  If you're not attending the Workshop, please include appropriate level of detail so we understand your idea.\nTagging: @rpodgorney , @cpgr , @ly",
          "url": "https://github.com/idaholab/moose/discussions/30062",
          "updatedAt": "2025-03-13T04:11:18Z",
          "publishedAt": "2025-03-10T12:04:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Hmmm, i meant to tag @lynnmunday  and not @ly .",
                  "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12448362",
                  "updatedAt": "2025-03-10T12:06:04Z",
                  "publishedAt": "2025-03-10T12:06:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I want MOOSE to run faster on simple problems.  Eg, other customised solvers (such as PFLOTRAN) are a lot faster because they're customised to solving just one type of physics.",
                  "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12448414",
                  "updatedAt": "2025-03-10T12:11:14Z",
                  "publishedAt": "2025-03-10T12:11:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I want more robust contact dynamics when solving mining problems involving rock strata in the mining roof collapsing onto the floor strata",
                  "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12448433",
                  "updatedAt": "2025-03-10T12:12:40Z",
                  "publishedAt": "2025-03-10T12:12:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I want to be able to simulate flow through fractures.  These could be:\n\npredefined fractures (so probably this is just a meshing problem)\nfractures that are 2D (within a 3D mesh) or 3D (within a 3D mesh)\nfractures that deform due to solid mechanics\nfractures that grow due to fluid pressures within the fracture, and/or rock stresses",
                  "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12448455",
                  "updatedAt": "2025-03-10T12:15:01Z",
                  "publishedAt": "2025-03-10T12:14:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I want AI to help me write good input files.  This could be via my natural-language description of what I want, and/or spotting possible mistakes in something i've hand-written.  (I know this isn't just related to geoscience - I'm getting a bit carried away here!)",
                  "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12448472",
                  "updatedAt": "2025-03-10T12:16:49Z",
                  "publishedAt": "2025-03-10T12:16:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "MengnanLi91"
                          },
                          "bodyText": "We are working on this in MOOSE team. I am working on light weight open source MOOSE chatbot to help user with documentation, keywords, example and complete MOOSE input files. We can discuss more if you are interested in collaboration. I think geoscience can be really good resource for my large language model fine-tuning work",
                          "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12450537",
                          "updatedAt": "2025-03-10T15:03:16Z",
                          "publishedAt": "2025-03-10T15:03:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "This sounds really useful! My main gripe is that the input files for anything remotely complicated are so long! It makes it both tedious and error prone so something that would do the heavy lifting would be fantastic",
                          "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12455816",
                          "updatedAt": "2025-03-11T00:51:43Z",
                          "publishedAt": "2025-03-11T00:51:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I want to be able to easily vary parameters over specified distributions.  Eg, the permeability should be drawn from a distribution, and MOOSE automatically spawns a bunch of simulations in a MonteCarlo approach, then the results are collated together appropriately.  Perhaps this is already possible in MOOSE, sorry for my ignorance!",
                  "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12448488",
                  "updatedAt": "2025-03-10T12:18:47Z",
                  "publishedAt": "2025-03-10T12:18:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "We can do this with the stochastic_tools module.  I would include more of my input files in the falcon repo but they are too large to run as tests.  Maybe they could just do syntax checking instead of full simulations.  These types of simulations also require post-processing with python and we hardly ever check those types of files into the repo.",
                          "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12462592",
                          "updatedAt": "2025-03-11T14:16:53Z",
                          "publishedAt": "2025-03-11T14:16:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I want all the terminology in Geochemistry to be better explained.  At the moment it's quite confusing for non-experts",
                  "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12448592",
                  "updatedAt": "2025-03-10T12:29:14Z",
                  "publishedAt": "2025-03-10T12:29:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I want Geochemistry to work for very saline groundwaters.",
                  "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12448597",
                  "updatedAt": "2025-03-10T12:29:57Z",
                  "publishedAt": "2025-03-10T12:29:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I want Geochemistry to offer better support for high-temperature simulations",
                  "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12448604",
                  "updatedAt": "2025-03-10T12:30:21Z",
                  "publishedAt": "2025-03-10T12:30:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I want the \"transport\" of Geochemistry + PorousFlow to be better explained.  At the moment, Geochemistry's inbuilt transport is very rudimentary compared with PorousFlow, which is fine, but when coupling with PorousFlow via a MultiApp, it's very easy to get the timestepping and passing back-and-forth of information mixed up, so that the simulation doesn't do what it's supposed to do!",
                  "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12448622",
                  "updatedAt": "2025-03-10T12:32:48Z",
                  "publishedAt": "2025-03-10T12:32:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "MengnanLi91"
                          },
                          "bodyText": "I hope we can use the physics module @GiudGiud developed to simplify the set up of Geochemistry + PorousFlow problems. Right now in order to transfer between geochemistry and porous flow, a large amount of auxvaribles, auxkernels, postprocessors, etc. I think the key problem here is to preserve the flexibility meanwhile simplify the input files",
                          "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12450701",
                          "updatedAt": "2025-03-10T15:17:19Z",
                          "publishedAt": "2025-03-10T15:17:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Yea, i agree @MengnanLi91 .   Can @GiudGiud explain what this is?",
                          "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12454044",
                          "updatedAt": "2025-03-10T20:19:30Z",
                          "publishedAt": "2025-03-10T20:19:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "I also think the idea of the physics modules is very good. They have the potential to reduce complexity (and therefore sources of error) and significantly improve auditability. I would also like to see these modules expanded and supplemented. Examples would be\n\nFixing generate_output in SolidMechanics/QuasiStatic\nSupport for beams and shells in SolidMechanics/QuasiStatic",
                          "url": "https://github.com/idaholab/moose/discussions/30062#discussioncomment-12458268",
                          "updatedAt": "2025-03-11T07:18:02Z",
                          "publishedAt": "2025-03-11T07:17:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Eigenvalue problem with complex eigenvalues",
          "author": {
            "login": "rainiscold"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI want to solve an eigenvalue problem with complex numbers.\nI know MOOSE cannot represent complex numbers so I need to separate the real and imaginary parts.\nSay I want solve this problem: A x = $\\lambda$  x\nThen I decompose into: A = $A_1$ + j $A_2$, $\\lambda$ = $\\lambda_1$ + j $\\lambda_2$, $x$ = $x_1$ + j $x_2$\nI need to solve the following system of equations in MOOSE:\n| $A_1$     $-A_{2}$  |    |  $x_1$  |  =  | $\\lambda_1$   $-\\lambda_2$|  |  $x_1$  |\n| $A_2$    $A_{1}$  |   |  $x_2$  |  =  | $\\lambda_1$  $\\lambda_2$ |  | $x_2$  |\nDoes anyone know how to solve this in MOOSE? Or How can I manipulate the interface between MOOSE and SLEPc?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/29886",
          "updatedAt": "2025-03-12T15:38:31Z",
          "publishedAt": "2025-02-14T19:12:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nyou should add these two equations using kernels and a variable for each component. The kernels with the eigenvalue will be derived from eigenkernels\nthen use the Eigenvalue executioner\n\nOr How can I manipulate the interface between MOOSE and SLEPc?\n\nIdeally you should not have to",
                  "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12204995",
                  "updatedAt": "2025-02-14T19:48:12Z",
                  "publishedAt": "2025-02-14T19:48:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rainiscold"
                          },
                          "bodyText": "Thank you for your reply.\nConstructing the matrices should be straightforward.\nThe question is the Eigenvalue executioner returns a scalar of eigenvalue, not a vector of eigenvalues for each component.\nFor my problem, A becomes a 2x2 block matrices, x is a two-block vector. The eigenvalue executioner returns a scalar value $\\lambda$, not a 2-dimension vector ($\\lambda_1$, $\\lambda_2$). Or I have misunderstood the executioner.\nI looked at the example: modal_analysis.i. The displacement has three components, I got a scalar eigenvalue not a vector for each component (I believe it should be a scalar.)\nFor complex number, I reformulated the problem and I don't know how to fit it into the API anymore.",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12205120",
                          "updatedAt": "2025-02-14T20:05:45Z",
                          "publishedAt": "2025-02-14T20:05:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The question is the Eigenvalue executioner returns a scalar of eigenvalue, not a vector of eigenvalues for each component.\n\ngood point.\nYou might need to write a new Eigenvalue executioner to deal with two eigenvalues.\nLet's confirm with @fdkong or @YaqiWang",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12205133",
                          "updatedAt": "2025-02-14T20:08:02Z",
                          "publishedAt": "2025-02-14T20:08:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rainiscold"
                          },
                          "bodyText": "I was thinking if there is a way to manipulate the interface to SLEPc:\nSay feeding SLEPc with corresponding matrices (real and imaginary parts), SLEPc will return the imaginary component. Currently, the imaginary component in MOOSE is always 0.",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12205161",
                          "updatedAt": "2025-02-14T20:12:26Z",
                          "publishedAt": "2025-02-14T20:12:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tophmatthews"
                          },
                          "bodyText": "@YaqiWang I think you've worked with this in the past, can you can help @rainiscold a bit with context? He's reached the ends of my knowledge...",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12243219",
                          "updatedAt": "2025-02-18T23:18:21Z",
                          "publishedAt": "2025-02-18T23:18:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tophmatthews"
                          },
                          "bodyText": "@GiudGiud , I think @rainiscold is still struggling with this, who can he reach out too?",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12417757",
                          "updatedAt": "2025-03-06T18:46:43Z",
                          "publishedAt": "2025-03-06T18:46:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@cticenhour @fdkong @YaqiWang @lindsayad  could you please let us know how you would approach this?",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12417817",
                          "updatedAt": "2025-03-06T20:18:10Z",
                          "publishedAt": "2025-03-06T18:52:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "We typically use a Newton eigen solver for solving neutronics problems, which @fdkong pushed into SLEPc. In this solver, we cast the real-number equation Ax=lambda*Bx into a nonlinear equation like F(x)=Ax-Bx/|Bx|=0 and use Newton solver to solve it preconditioned typically with A or an approximation of A. |Bx| can be any norm of x or even a simple integration of x. After convergence, lambda is equal to 1/|Bx| and the solution is normalized such that |Bx|=lambda. If we can think of a way of defining |Bx| for the complex number, we might be able to still use Eigenvalue executioner (I am not sure). I am also not sure how to manipulate SLEPc so that we can solve this with other types of eigen solvers.",
                  "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12418749",
                  "updatedAt": "2025-03-06T20:43:24Z",
                  "publishedAt": "2025-03-06T20:43:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rainiscold"
                          },
                          "bodyText": "Thank you for your reply!  Here I don't understand why 1/|Bx| equals the eigen value lambda? Are (Bx)s in Ax=lambda*Bx and 1/|Bx| the same?",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12419854",
                          "updatedAt": "2025-03-06T23:22:36Z",
                          "publishedAt": "2025-03-06T23:22:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "|Bx| is a scalar value. As I have mentioned, it can be any norm of x or of Bx or even a simple integration of x. Only after convergence, 1/|Bx| is equal to lambda.",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12420402",
                          "updatedAt": "2025-03-07T01:03:16Z",
                          "publishedAt": "2025-03-07T01:03:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rainiscold"
                          },
                          "bodyText": "Then it is possible to extend this to complex problems. In the complex case, the vector x contains two blocks(x1, x2) where x = x1 + x2 j. We just need to use two scalar for the two blocks in Bx, say F(x) = Ax - ([Bx]1/|Bx1|,   [Bx]2/|Bx2|). After convergence, the eigen value for the real and imaginary part would be, 1/|Bx1| and 1/|Bx2|.\nDo you think this is achievable in the current framework?",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12428250",
                          "updatedAt": "2025-03-07T15:46:56Z",
                          "publishedAt": "2025-03-07T15:46:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "I think we cannot treat the two parts separately. You can try defining the complex number c in Ax-Bx/c with |c|=||x||_2 and angle of c being the angle of an entry in x. This means in you Bx kernels, you need to have a postprocessor to evaluate the rotation angle of an entry in x (preferred the entry with maximum norm), and couple the postprocessor to apply a rotation based on the rotation angle. Then you should be able to use Eigenvalue executioner. After convergence, the eigenvalue given by the executioner is |lambda| and the rotation angle postprocessor will be the angle of lambda. This essentially forces the norm of ||x|| equal to |lambda| and the entry in x aligned with the eigenvalue angle as a normalization. This might work.",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12429480",
                          "updatedAt": "2025-03-07T17:57:33Z",
                          "publishedAt": "2025-03-07T17:53:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rainiscold"
                          },
                          "bodyText": "I am not sure I know how to apply the angle to the following problem.\n\nSay I want solve this problem: A x = \u03bb x Then I decompose into: $A = A_1 + j A_2 , \u03bb = \u03bb_1 + j \u03bb_2 , x = x_1 + j x_2$ I need to solve the following system of equations in MOOSE:\n| $A_1$  $\u2212A_2$ |  | $x_1$ | =  | $\u03bb_1$  $\u2212\u03bb_2$ | | $x_1$ |\n| $A_2$  $A_1$ | | $x_2$ | =  | $\u03bb_2$  $\u03bb_1$ | | $x_2$ |\n\nOn the RHS I factor out a parameter and start from there? I'd appreciate it if you can point me to any example or reference.",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12464551",
                          "updatedAt": "2025-03-11T16:55:23Z",
                          "publishedAt": "2025-03-11T16:55:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "You will need a new postprocessor named like RotationAngle which should be a node postprocessor if your x1 and x2 are nodal variables in type of LAGRANGE, or an elemental postprocessor if the variables are elemental. In the validParams function of the postprocessor, you will need to have params.addRequiredCoupledVar for both variables and evaluate the rotation angle as I mentioned earlier.\nYou may want to have another postprocessor be like RotationAngle, but return ||x||. Note that you do not have to add this postprocessor because MOOSE can use the numerical L2 norm of the solution vector of x1 and x2 internally during eigenvalue calculation.\nYou will also need a new kernel that couples the other part of variable (x2 for x1 and x1 for x2) and couples the postprocessor in type of RotationAngle. It will rotate the residual contribution based on the postprocessor value. You do not need to couple the other postprocessor because MOOSE will do it for you if you make that as the custom eigenvalue postprocessor (with Problem/bx_norm parameter). If you do not have the other postprocessor, you do not need to worry about this.\nIn your input, the RotationAngle postprocessor must be executed on linear and your two kernels for x1 and x2 in type of that new kernel must be marked as the RHS kernel with extra_vector_tags = eigen.\nYou can use tests/problems/eigen_problem/eigensolvers/ne.i as the example. This is the implementation of my idea. Hope this helps.",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12468443",
                          "updatedAt": "2025-03-12T01:06:22Z",
                          "publishedAt": "2025-03-12T01:05:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rainiscold"
                          },
                          "bodyText": "thank you very much. I will give it a try.",
                          "url": "https://github.com/idaholab/moose/discussions/29886#discussioncomment-12476821",
                          "updatedAt": "2025-03-12T15:38:32Z",
                          "publishedAt": "2025-03-12T15:38:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "'_q_point[_qp]' and 'n_points' in Dirichlet BC",
          "author": {
            "login": "echo1115"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi all,\nI want to get _q_point[_qp] and _qrule->n_points() in Dirichlet BC ,\nbut it shows the error:\n\n_q_point was not declared in this scope\n_qrule was not declared in this scope\n\nHow can I get the q_point and the total number of points in Dirichlet BC\uff1f\nThanks in advanced!",
          "url": "https://github.com/idaholab/moose/discussions/30063",
          "updatedAt": "2025-03-12T04:11:10Z",
          "publishedAt": "2025-03-10T14:52:40Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDirichletBC do not use a quadrature. It does not take an integration to set a value on a node.\nWhy do you need this?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/30063#discussioncomment-12450391",
                  "updatedAt": "2025-03-10T14:54:35Z",
                  "publishedAt": "2025-03-10T14:54:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "I want to use the temperature distribution calculated by other code as the DirichletBC for MOOSE and interpolate based on the q_point.",
                          "url": "https://github.com/idaholab/moose/discussions/30063#discussioncomment-12451214",
                          "updatedAt": "2025-03-10T15:51:19Z",
                          "publishedAt": "2025-03-10T15:51:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "which type of variable are you setting with this Dirichlet BC?\nA classic first order lagrange variable?\nIf this temperature distribution from the other code is stored in a regular MOOSE auxiliary variable, then a number of dirichletBCs can already do this. For example FunctorDirichletBC or MatchedValueBC",
                          "url": "https://github.com/idaholab/moose/discussions/30063#discussioncomment-12451305",
                          "updatedAt": "2025-03-10T15:58:38Z",
                          "publishedAt": "2025-03-10T15:58:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "The temperature and and corresponding coordinates from the other code are stored in a separate data file, I  read the data file in the Dirichlet BC source file and  I want to assign values in the Dirichlet BC based on the q_point.",
                          "url": "https://github.com/idaholab/moose/discussions/30063#discussioncomment-12452940",
                          "updatedAt": "2025-03-10T18:16:00Z",
                          "publishedAt": "2025-03-10T18:15:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you load this data in an auxkernel instead? Then you could use a variable in your BCs\nOr in a PropertyReadFile user object? Then you can use a function in your BC. The PropertyReadFile can read formatted CSV files which might be convenient for you?",
                          "url": "https://github.com/idaholab/moose/discussions/30063#discussioncomment-12453382",
                          "updatedAt": "2025-03-10T19:23:15Z",
                          "publishedAt": "2025-03-10T19:04:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "Is there any way to replace _q_point[_qp] and _qrule->n_points() in Dirichlet BC?\nIf I  load this data by auxkernel, the data will be stored as auxailable in quadrature points, then how can I use the auxvariable in the Dirichlet BC?",
                          "url": "https://github.com/idaholab/moose/discussions/30063#discussioncomment-12455573",
                          "updatedAt": "2025-03-11T00:07:39Z",
                          "publishedAt": "2025-03-11T00:07:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Look at dirichletBCBase.h\nThere are some location attributes but they are not Qps",
                          "url": "https://github.com/idaholab/moose/discussions/30063#discussioncomment-12458363",
                          "updatedAt": "2025-03-11T07:25:24Z",
                          "publishedAt": "2025-03-11T07:25:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "A MatchedValueBC or a finctorDirichletBC Will both take an auxiliary variable as an input",
                          "url": "https://github.com/idaholab/moose/discussions/30063#discussioncomment-12458369",
                          "updatedAt": "2025-03-11T07:26:06Z",
                          "publishedAt": "2025-03-11T07:26:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "Thanks  for your suggestions! @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/30063#discussioncomment-12469621",
                          "updatedAt": "2025-03-12T04:11:11Z",
                          "publishedAt": "2025-03-12T04:11:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Correct Boundary Condition for an Open Atmosphere?",
          "author": {
            "login": "waaizhaq"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A Navier Stokes is the most appropriate category for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (avoid screenshots if possible, triple back quotes before/after pasted text, etc)\n\nQuestion\nHello,\nI revisited one of my early MOOSE practice problems about natural circulation flow from a heated wall (constant temperature), and open to the atmosphere. This problem was taken from Bergman and Lavine Heat and Mass Transfer Textbook:\n\n\nI defined my mesh as a simple 2D rectangle, where the left boundary represents the heated wall, the bottom boundary represents the ground, and the right and top boundaries represent ambient air. I had to compute the heat rate coming off the wall to compare it to the one from the textbook. However, the value I computed was less than the textbook's example: ~ 232.42 Watts < 1108.24 Watts. I'm not sure if I computed the heat rate wrong or if I set my boundary conditions incorrectly. Currently I have a dirichlet boundary condition on the right and top boundaries of 296 Kelvin, but I don't think that represents ambient air accurately. I tried to use an outflow condition with INSFVMomentumAdvectionOutflowBC for velocity and FVNeumann for the temperature both set to 0, but the solve was unstable and didn't converge.\nAdditional information\nMesh size and type: 30x30\nReynolds number:\nDiscretization (finite element CG/DG, finite volume, etc): finite volume\nModels (turbulence, porous media, etc): natural circulation\nSolver method (fully coupled, segregated, multiapps, etc):\nBase input you started from:",
          "url": "https://github.com/idaholab/moose/discussions/29893",
          "updatedAt": "2025-03-12T00:03:27Z",
          "publishedAt": "2025-02-16T03:40:27Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Currently I have a dirichlet boundary condition on the right and top boundaries of 296 Kelvin\n\nSetting the temperature would not influence the result if it were very far from the heat source. Right now it seems close, and will impose a strong decrease in the temperature to meet this boundary condition.\n\nFVNeumann for the temperature both set to 0\n\nThis sets the heat flux to 0. This is in effect imposing a symmetry of the system, which is also not realistic.\nI think the right solution for temperature is no boundary condition on the right and top, letting the INSFVEnergyAdvection kernel advect energy through those boundaries.\nMomentum and MassOutflow should be correct too imo.\nCan you get the flow equations to converge with a fixed temperature profile (using an exodus restart from the current T profile for example)",
                  "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12213598",
                  "updatedAt": "2025-02-16T06:50:53Z",
                  "publishedAt": "2025-02-16T06:50:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "I see, I'll change those boundary conditions and see if it's stable. Is there a such thing as over constraining the boundaries? I would assume there is.",
                          "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12218207",
                          "updatedAt": "2025-02-16T23:12:12Z",
                          "publishedAt": "2025-02-16T23:12:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "there is. if you over-constrain, the problem will be ill-posed and is unlikely to converge.",
                          "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12218220",
                          "updatedAt": "2025-02-16T23:15:36Z",
                          "publishedAt": "2025-02-16T23:15:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "Okay so I changed the boundaries and the solution converges, but it seems like it just accelerates straight to the max temperature, the hot wall temperature of 505.15 Kelvin. I initially thought this might be because my domain is too small, even though the textbook problem also had a small domain, so I increased my xmax to 10 m and ymax to 5 m, and the same thing happened. I also attached my input below.\n\nnat_conv_wall.txt",
                          "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12219801",
                          "updatedAt": "2025-02-17T04:24:42Z",
                          "publishedAt": "2025-02-17T04:24:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you have commented out all the time derivatives. So the steady state is reached immediately, which is a flat profile",
                          "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12220431",
                          "updatedAt": "2025-02-17T06:02:56Z",
                          "publishedAt": "2025-02-17T06:02:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "I also tried it with a transient, and I got the same result so I just commented it out.",
                          "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12220507",
                          "updatedAt": "2025-02-17T06:11:11Z",
                          "publishedAt": "2025-02-17T06:11:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "type = INSFVEnergyAdvection\n    variable = T\n    advected_quantity = 1.2\n\nthis is not advecting temperature. it s advecting a constant. you want to be advecting either 'h' the enthalpy or its approximation by 'cp * T'.\nThis functor material's job is to compute these quantities as functors\nhttps://mooseframework.inl.gov/source/functormaterials/INSFVEnthalpyFunctorMaterial.html",
                          "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12220543",
                          "updatedAt": "2025-02-17T06:15:04Z",
                          "publishedAt": "2025-02-17T06:14:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "Ohh okay that makes sense. That\u2019s most definitely my issue. I appreciate the help, thank you again!",
                          "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12220612",
                          "updatedAt": "2025-02-17T06:25:14Z",
                          "publishedAt": "2025-02-17T06:25:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "Hello,\nI apologize for pestering about this problem again, but it's really been a humbling experience for me haha. I've changed the advection term so now it's not advecting a constant, but rather the enthalpy through INSFVEnthalpyFunctorMaterial. But whenever I run the simulation I get:\n 0 Nonlinear |R| = 1.420159e+05\n    Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                   PC failed due to FACTOR_OUTMEMORY\n  Nonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nI couldn't figure out if something was wrong with my input, so then I checked my jacobian matrix with analyzejacobian.py and I got:\nRunning input with executable moose-opt ...\n\n\nKernel for variable 'vel_y':\n  (1,1) On-diagonal Jacobian should just return  zero\n\nKernel for variable 'T':\n  (3,0) Off-diagonal Jacobian for variable 'vel_x' is slightly off (by 0.134962 %)\n  (3,1) Off-diagonal Jacobian for variable 'vel_y' is slightly off (by 0.149508 %)\n\nI'm not exactly sure how to debug this or alter my jacobian matrix. I was looking at some discussion posts related to this issue and one solution I could do is to switch to AD, but AD cannot be applicable to FV if I remember correctly.",
                          "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12269445",
                          "updatedAt": "2025-02-20T23:09:51Z",
                          "publishedAt": "2025-02-20T23:09:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I could do is to switch to AD, but AD cannot be applicable to FV if I remember correctly\n\nthat s not quite correct.\nINSFV is AD only\nLinearFV is nonAD only",
                          "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12269822",
                          "updatedAt": "2025-02-21T00:11:36Z",
                          "publishedAt": "2025-02-21T00:11:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the vel_y jacobian terms should be correct.\nYou should try removing the energy equation for now and getting the pressure velocity coupling to be correct",
                          "url": "https://github.com/idaholab/moose/discussions/29893#discussioncomment-12269834",
                          "updatedAt": "2025-02-21T00:13:49Z",
                          "publishedAt": "2025-02-21T00:13:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stress strain curve not yielding",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "I am using the CrystalPlasticityKalidindiUpdate class for Inconel 718 model as shown in my material block below.\n[Materials]\n  [elasticity_tensor_phase0]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '2.596e5 1.79e5 1.79e5 2.596e5 1.79e5 2.596e5 1.096e5 1.096e5 1.096e5'\n    fill_method = symmetric9\n    base_name = phase0\n  []\n  [stress_phase0]\n    type = ComputeMultipleCrystalPlasticityStress\n    crystal_plasticity_models = 'trial_xtalpl_phase0'\n    rtol = 1e-9\n    abs_tol = 1e-10\n    tan_mod_type = exact\n    base_name = phase0\n  []\n  [trial_xtalpl_phase0]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.txt\n    crystal_lattice_type = FCC\n    r = 1.0             \n    h = 6000            \n    t_sat = 598.5        \n    gss_a = 1.5         \n    ao = 0.001           \n    xm = 0.017             \n    gss_initial = 465.5  \n    base_name = phase0\n  []\n  [strain_phase0]\n    type = ComputeFiniteStrain\n    displacements = 'disp_x disp_y'\n    base_name = phase0\n    #    eigenstrain_names = eigenstrain2\n  []\n\n  [elasticity_tensor_phase1]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '2.596e5 1.79e5 1.79e5 2.596e5 1.79e5 2.596e5 1.096e5 1.096e5 1.096e5'\n    fill_method = symmetric9\n    euler_angle_1 = 0.0\n    euler_angle_2 = 0.0\n    euler_angle_3 = 0.0\n    base_name = phase1\n  []\n  [stress_phase1]\n    type = ComputeMultipleCrystalPlasticityStress\n    crystal_plasticity_models = 'trial_xtalpl_phase1'\n    rtol = 1e-9\n    abs_tol = 1e-10\n    tan_mod_type = exact\n    base_name = phase1\n  []\n  [trial_xtalpl_phase1]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.txt\n    crystal_lattice_type = FCC\n    r = 1.0             \n    h = 6000            \n    t_sat = 598.5        \n    gss_a = 1.5         \n    ao = 0.001           \n    xm = 0.017             \n    gss_initial = 465.5     \n    base_name = phase1\n  []\n\n  [strain_phase1]\n    type = ComputeFiniteStrain\n    displacements = 'disp_x disp_y'\n    base_name = phase1\n  []\n\n  # Switching functions for each phase\n  [h0]\n    type = SwitchingFunctionMultiPhaseMaterial\n    phase_etas = eta0\n    all_etas = 'eta0 eta1'\n    h_name = h0\n  []\n  [h1]\n    type = SwitchingFunctionMultiPhaseMaterial\n    phase_etas = eta1\n    all_etas = 'eta0 eta1'\n    h_name = h1\n  []\n\n  # Generate the global stress from the phase stresses\n  [global_stress]\n    type = MultiPhaseStressMaterial\n    phase_base = 'phase0 phase1'\n    h = 'h0  h1'\n  []\n[]\n\n\nI got all my crystal plasticity parameters from experimental data except the gss_a for this alloy. The problem I am having is after plotting the stress-strain curve, it never enters the plastic region. The plot shows only the elastic. What could be the possible reasons?\nPs: I have used this model with other crystal plasticity parameters and elastic constants it entered the plastic region.\nI have attached pictures of the experimental data.\n\n\n@sapitts @dschwen @GiudGiud",
          "url": "https://github.com/idaholab/moose/discussions/28086",
          "updatedAt": "2025-03-11T23:41:37Z",
          "publishedAt": "2024-07-09T12:18:29Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Emmanuel-324"
                  },
                  "bodyText": "Below is my full input script for your perusal\n[Mesh]\n  [file]\n    type = FileMeshGenerator\n    file = my_kks_noload_one8_out.e-s170\n    use_for_exodus_restart = true\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n\n  # order parameter 0\n  [eta0]\n    initial_from_file_var = eta1\n  []\n  # order parameter 1\n  [eta1]\n    initial_from_file_var = eta3\n  []\n[]\n\n[AuxVariables]\n  [phase0_pk2]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [phase0_fp_xx]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [phase0_e_xx]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [phase1_pk2]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [phase1_fp_xx]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [phase1_e_xx]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [vonmises]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [stress_xx]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [phase0_gss]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  []\n  [phase0_slip_increment]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  []\n  [phase1_gss]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  []\n  [phase1_slip_increment]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  []\n[]\n\n[AuxKernels]\n  [phase0_pk2]\n    type = RankTwoAux\n    variable = phase0_pk2\n    rank_two_tensor = phase0_second_piola_kirchhoff_stress\n    index_j = 2\n    index_i = 2\n    execute_on = timestep_end\n  []\n  [phase0_fp_xx]\n    type = RankTwoAux\n    variable = phase0_fp_xx\n    rank_two_tensor = phase0_plastic_deformation_gradient\n    index_j = 2\n    index_i = 2\n    execute_on = timestep_end\n  []\n  [phase0_e_xx]\n    type = RankTwoAux\n    variable = phase0_e_xx\n    rank_two_tensor = phase0_total_lagrangian_strain\n    index_j = 2\n    index_i = 2\n    execute_on = timestep_end\n  []\n  [phase1_pk2]\n    type = RankTwoAux\n    variable = phase1_pk2\n    rank_two_tensor = phase1_second_piola_kirchhoff_stress\n    index_j = 2\n    index_i = 2\n    execute_on = timestep_end\n  []\n  [phase1_fp_xx]\n    type = RankTwoAux\n    variable = phase1_fp_xx\n    rank_two_tensor = phase1_plastic_deformation_gradient\n    index_j = 2\n    index_i = 2\n    execute_on = timestep_end\n  []\n  [phase1_e_xx]\n    type = RankTwoAux\n    variable = phase1_e_xx\n    rank_two_tensor = phase1_total_lagrangian_strain\n    index_j = 2\n    index_i = 2\n    execute_on = timestep_end\n  []\n\n  [vonmises]\n    type = RankTwoScalarAux\n    rank_two_tensor = stress\n    variable = vonmises\n    scalar_type = VonMisesStress\n    execute_on = timestep_end\n    #   block = 0\n  []\n\n  [stress_xx]\n    type = RankTwoAux\n    rank_two_tensor = stress\n    variable = stress_xx\n    index_j = 0\n    index_i = 0\n    execute_on = timestep_end\n  []\n\n  [gss_phase0]\n    type = MaterialStdVectorAux\n    variable = phase0_gss\n    property = phase0_slip_resistance\n    index = 0\n    execute_on = timestep_end\n  []\n  [slip_inc_phase0]\n    type = MaterialStdVectorAux\n    variable = phase0_slip_increment\n    property = phase0_slip_increment\n    index = 0\n    execute_on = timestep_end\n  []\n  [gss_phase1]\n    type = MaterialStdVectorAux\n    variable = phase1_gss\n    property = phase1_slip_resistance\n    index = 0\n    execute_on = timestep_end\n  []\n  [slip_inc_phase1]\n    type = MaterialStdVectorAux\n    variable = phase1_slip_increment\n    property = phase1_slip_increment\n    index = 0\n    execute_on = timestep_end\n  []\n[]\n\n[BCs]\n  [symmy]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0\n  []\n  [symmx]\n    type = DirichletBC\n    variable = disp_x\n    boundary = left\n    value = 0\n  []\n  [tdisp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = right\n    function = '0.1*t'\n  []\n[]\n\n[Materials]\n  [elasticity_tensor_phase0]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '2.596e5 1.79e5 1.79e5 2.596e5 1.79e5 2.596e5 1.096e5 1.096e5 1.096e5'\n    fill_method = symmetric9\n    base_name = phase0\n  []\n  [stress_phase0]\n    type = ComputeMultipleCrystalPlasticityStress\n    crystal_plasticity_models = 'trial_xtalpl_phase0'\n    rtol = 1e-9\n    abs_tol = 1e-10\n    tan_mod_type = exact\n    base_name = phase0\n  []\n  [trial_xtalpl_phase0]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.txt\n    crystal_lattice_type = FCC\n    r = 1.0             \n    h = 6000            \n    t_sat = 598.5        \n    gss_a = 1.5         \n    ao = 0.001           \n    xm = 0.017             \n    gss_initial = 465.5  \n    base_name = phase0\n  []\n  [strain_phase0]\n    type = ComputeFiniteStrain\n    displacements = 'disp_x disp_y'\n    base_name = phase0\n    #    eigenstrain_names = eigenstrain2\n  []\n\n  [elasticity_tensor_phase1]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '2.596e5 1.79e5 1.79e5 2.596e5 1.79e5 2.596e5 1.096e5 1.096e5 1.096e5'\n    fill_method = symmetric9\n    euler_angle_1 = 0.0\n    euler_angle_2 = 0.0\n    euler_angle_3 = 0.0\n    base_name = phase1\n  []\n  [stress_phase1]\n    type = ComputeMultipleCrystalPlasticityStress\n    crystal_plasticity_models = 'trial_xtalpl_phase1'\n    rtol = 1e-9\n    abs_tol = 1e-10\n    tan_mod_type = exact\n    base_name = phase1\n  []\n  [trial_xtalpl_phase1]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.txt\n    crystal_lattice_type = FCC\n    r = 1.0             \n    h = 6000            \n    t_sat = 598.5        \n    gss_a = 1.5         \n    ao = 0.001           \n    xm = 0.017             \n    gss_initial = 465.5     \n    base_name = phase1\n  []\n\n  [strain_phase1]\n    type = ComputeFiniteStrain\n    displacements = 'disp_x disp_y'\n    base_name = phase1\n  []\n\n  # Switching functions for each phase\n  [h0]\n    type = SwitchingFunctionMultiPhaseMaterial\n    phase_etas = eta0\n    all_etas = 'eta0 eta1'\n    h_name = h0\n  []\n  [h1]\n    type = SwitchingFunctionMultiPhaseMaterial\n    phase_etas = eta1\n    all_etas = 'eta0 eta1'\n    h_name = h1\n  []\n\n  # Generate the global stress from the phase stresses\n  [global_stress]\n    type = MultiPhaseStressMaterial\n    phase_base = 'phase0 phase1'\n    h = 'h0  h1'\n  []\n[]\n\n[Kernels]\n  [eta0_dt]\n    type = TimeDerivative\n    variable = eta0\n  []\n  [eta1_dt]\n    type = TimeDerivative\n    variable = eta1\n  []\n  [TensorMechanics]\n    displacements = 'disp_x disp_y'\n  []\n[]\n\n[Postprocessors]\n  [phase0_pk2]\n    type = ElementAverageValue\n    variable = phase0_pk2\n  []\n  [phase0_fp_xx]\n    type = ElementAverageValue\n    variable = phase0_fp_xx\n  []\n  [phase0_e_xx]\n    type = ElementAverageValue\n    variable = phase0_e_xx\n  []\n  [phase1_pk2]\n    type = ElementAverageValue\n    variable = phase1_pk2\n  []\n  [phase1_fp_xx]\n    type = ElementAverageValue\n    variable = phase1_fp_xx\n  []\n  [phase1_e_xx]\n    type = ElementAverageValue\n    variable = phase1_e_xx\n  []\n  [vonmises]\n    type = ElementAverageValue\n    variable = vonmises\n    block = 'ANY_BLOCK_ID 0'\n  []\n  [stress_xx]\n    type = ElementAverageValue\n    variable = stress_xx\n  []\n  [phase0_gss]\n    type = ElementAverageValue\n    variable = phase0_gss\n  []\n  [phase0_slip_increment]\n    type = ElementAverageValue\n    variable = phase0_slip_increment\n  []\n  [phase1_gss]\n    type = ElementAverageValue\n    variable = phase1_gss\n  []\n  [phase1_slip_increment]\n    type = ElementAverageValue\n    variable = phase1_slip_increment\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu            superlu_dist          vinewtonrsls'\n\n  #  petsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -ksp_type -ksp_gmres_restart'\n  #  petsc_options_value = ' asm      2              lu            gmres     200'\n  l_max_its = 20\n  nl_max_its = 10\n  nl_rel_tol = 1.0e-8\n  nl_abs_tol = 1.0e-9\n\n  end_time = 21.50\n\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 5e-3\n    cutback_factor = 0.75\n    growth_factor = 1.2\n    optimal_iterations = 20\n  []\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = true\n  time_step_interval = 5\n  [console]\n    type = Console\n    time_step_interval = 5\n  []\n  [table]\n    type = CSV\n    execute_on = timestep_end\n    time_step_interval = 5\n  [] \n[]",
                  "url": "https://github.com/idaholab/moose/discussions/28086#discussioncomment-10032057",
                  "updatedAt": "2024-07-12T13:39:38Z",
                  "publishedAt": "2024-07-12T13:39:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Yulongggggg"
                          },
                          "bodyText": "Hi I got the same issue, have you figured it out ?",
                          "url": "https://github.com/idaholab/moose/discussions/28086#discussioncomment-12467728",
                          "updatedAt": "2025-03-11T22:57:27Z",
                          "publishedAt": "2025-03-11T22:57:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "I reduced the dt. And take off the mesh adaptability block if you have to reduce the computational time. And usually it takes 2-3 days for mine to enter the plastic region. Make sure your elastic constants are reasonable",
                          "url": "https://github.com/idaholab/moose/discussions/28086#discussioncomment-12467791",
                          "updatedAt": "2025-03-11T23:09:04Z",
                          "publishedAt": "2025-03-11T23:09:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Yulongggggg"
                          },
                          "bodyText": "I reduced the dt. And take off the mesh adaptability block if you have to reduce the computational time. And usually it takes 2-3 days for mine to enter the plastic region. Make sure your elastic constants are reasonable\n\nThank you! i tried but still not working. Do you know why this happening?",
                          "url": "https://github.com/idaholab/moose/discussions/28086#discussioncomment-12467939",
                          "updatedAt": "2025-03-11T23:37:56Z",
                          "publishedAt": "2025-03-11T23:37:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Emmanuel-324"
                  },
                  "bodyText": "Does your solution converge? And can I see your script?\n\nGet Outlook for iOS<https://aka.ms/o0ukef>\n\u2026\n________________________________\nFrom: Yulongggggg ***@***.***>\nSent: Tuesday, March 11, 2025 7:38:16 PM\nTo: idaholab/moose ***@***.***>\nCc: Adu-Gyamfi, Emmanuel ***@***.***>; Author ***@***.***>\nSubject: Re: [idaholab/moose] Stress strain curve not yielding (Discussion #28086)\n\n\nI reduced the dt. And take off the mesh adaptability block if you have to reduce the computational time. And usually it takes 2-3 days for mine to enter the plastic region. Make sure your elastic constants are reasonable\n\nThank you! i tried but still not working. Do you know why this happening?\n\n\u2014\nReply to this email directly, view it on GitHub<#28086 (reply in thread)>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/BCSA5FULAUQNU43AWG5OWVD2T5XWRAVCNFSM6AAAAABY2EANIKVHI2DSMVQWIX3LMV43URDJONRXK43TNFXW4Q3PNVWWK3TUHMYTENBWG44TGOI>.\nYou are receiving this because you authored the thread.Message ID: ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/28086#discussioncomment-12467952",
                  "updatedAt": "2025-03-11T23:40:03Z",
                  "publishedAt": "2025-03-11T23:40:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Yulongggggg"
                          },
                          "bodyText": "Thank you so much! Here's my code:\n[Mesh]\n  [line_1D]\n    type = GeneratedMeshGenerator\n    dim = 1\n    nx = 10\n    xmin = 0\n    xmax = 1\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x'\n[]\n\n[Variables]\n  [disp_x]\n    family = LAGRANGE\n    order = FIRST\n  []\n[]\n\n[Functions]\n  [compress_func]\n    type = ParsedFunction\n    expression = '50e6 * t'\n  []\n[]\n\n[Physics]\n  [SolidMechanics]\n    [QuasiStatic]\n      [all]\n        strain = SMALL\n        incremental = true\n        add_variables = true\n        generate_output = 'stress_xx strain_xx vonmises_stress PLASTIC_STRAIN_XX effective_plastic_strain'\n        material_output_family = MONOMIAL\n        material_output_order = FIRST\n      []\n    []\n  []\n[]\n\n[BCs]\n  [left_fix]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left'\n    value = 0.0\n  []\n  [right_pressure]\n    type = Pressure\n    variable = disp_x\n    boundary = right\n    function = 'compress_func'\n  []\n[]\n\n[ICs]\n  [ic_disp_x]\n    type = ConstantIC\n    variable = disp_x\n    value = 0.0\n  []\n[]\n\n[UserObjects]\n  [cohesion_obj]\n    type = SolidMechanicsHardeningConstant\n    value = 10e6\n  []\n  [phi_obj]\n    type = SolidMechanicsHardeningConstant\n    value = '35'\n    convert_to_radians = true\n  []\n  [psi_obj]\n    type = SolidMechanicsHardeningConstant\n    value = '5'\n    convert_to_radians = true\n  []\n  [dp_model]\n    type = SolidMechanicsPlasticDruckerPrager\n    mc_cohesion = 'cohesion_obj'\n    mc_friction_angle = 'phi_obj'\n    mc_dilation_angle = 'psi_obj'\n    yield_function_tolerance = '1e-10'\n    internal_constraint_tolerance = '1e-10'\n  []\n[]\n\n[Materials]\n  [elasticity]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 15e9\n    poissons_ratio = 0.2\n    block = 0\n  []\n  [drucker_prager]\n    type = ComputeMultiPlasticityStress\n    ep_plastic_tolerance = 1e-5\n    plastic_models = dp_model # Defined in UserObjects, Mohr-Coulomb yield surface\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  end_time = 1\n  dt = 0.001\n  # nl_abs_tol = 1e-30\n  # nl_rel_tol = 1e-50\n  # nl_max_its = 200\n[]\n\n[Outputs]\n  [Exodus]\n    type = Exodus\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28086#discussioncomment-12467961",
                          "updatedAt": "2025-03-11T23:42:26Z",
                          "publishedAt": "2025-03-11T23:41:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The stress and strain curve don't yield, there's only elastic part without the plastic part",
          "author": {
            "login": "Yulongggggg"
          },
          "bodyText": "Dear developers, I am trying to test the \"SolidMechanicsPlasticDruckerPrager\"; the problem is a bar having loading at the right side. When I am trying to plot the strain-stress curve, the curve never yield and just keeping elastic response. Here's my curve and I have attached my code below. And I am trying to avoid capped DP for now so I am using 'ComputeMultiPlasticityStress'",
          "url": "https://github.com/idaholab/moose/discussions/30078",
          "updatedAt": "2025-03-11T23:10:02Z",
          "publishedAt": "2025-03-11T23:05:10Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Yulongggggg"
                  },
                  "bodyText": "[Mesh]\n  [line_1D]\n    type = GeneratedMeshGenerator\n    dim = 1\n    nx = 10\n    xmin = 0\n    xmax = 1\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x'\n[]\n\n[Variables]\n  [disp_x]\n    family = LAGRANGE\n    order = FIRST\n  []\n[]\n\n[Functions]\n  [compress_func]\n    type = ParsedFunction\n    expression = '50e6 * t'\n  []\n[]\n\n[Physics]\n  [SolidMechanics]\n    [QuasiStatic]\n      [all]\n        strain = SMALL\n        incremental = true\n        add_variables = true\n        generate_output = 'stress_xx strain_xx vonmises_stress PLASTIC_STRAIN_XX effective_plastic_strain'\n        material_output_family = MONOMIAL\n        material_output_order = FIRST\n      []\n    []\n  []\n[]\n\n[BCs]\n  [left_fix]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left'\n    value = 0.0\n  []\n  [right_pressure]\n    type = Pressure\n    variable = disp_x\n    boundary = right\n    function = 'compress_func'\n  []\n[]\n\n[ICs]\n  [ic_disp_x]\n    type = ConstantIC\n    variable = disp_x\n    value = 0.0\n  []\n[]\n\n[UserObjects]\n  [cohesion_obj]\n    type = SolidMechanicsHardeningConstant\n    value = 10e6\n  []\n  [phi_obj]\n    type = SolidMechanicsHardeningConstant\n    value = '35'\n    convert_to_radians = true\n  []\n  [psi_obj]\n    type = SolidMechanicsHardeningConstant\n    value = '5'\n    convert_to_radians = true\n  []\n  [dp_model]\n    type = SolidMechanicsPlasticDruckerPrager\n    mc_cohesion = 'cohesion_obj'\n    mc_friction_angle = 'phi_obj'\n    mc_dilation_angle = 'psi_obj'\n    yield_function_tolerance = '1e-10'\n    internal_constraint_tolerance = '1e-10'\n  []\n[]\n\n[Materials]\n  [elasticity]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 15e9\n    poissons_ratio = 0.2\n    block = 0\n  []\n  [drucker_prager]\n    type = ComputeMultiPlasticityStress\n    ep_plastic_tolerance = 1e-5\n    plastic_models = dp_model # Defined in UserObjects, Mohr-Coulomb yield surface\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  end_time = 1\n  dt = 0.001\n  # nl_abs_tol = 1e-30\n  # nl_rel_tol = 1e-50\n  # nl_max_its = 200\n[]\n\n[Outputs]\n  [Exodus]\n    type = Exodus\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/30078#discussioncomment-12467779",
                  "updatedAt": "2025-03-11T23:09:04Z",
                  "publishedAt": "2025-03-11T23:05:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Docker builds no longer come with mpich version/.sif releases",
          "author": {
            "login": "nietzscheanmonkey"
          },
          "bodyText": "It appears that the idaholab/moose-dev:latest image no longer comes with mpich, only open-mpi. The last container to come with mpich is https://hub.docker.com/layers/idaholab/moose-dev/e930b1d/images/sha256-9e425c2df00f4a80f902a2e1672de06ecfbfaadb4c64281d77083e5471c4bc53\nIs this an intentional permanent change, or an oversight?\nAdditionally, #27377 indicates that .sifs may be made available. Is this still happening?\n@loganharbour",
          "url": "https://github.com/idaholab/moose/discussions/30077",
          "updatedAt": "2025-03-11T21:10:29Z",
          "publishedAt": "2025-03-11T21:10:29Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Performance issues running MOOSE on an HPC- how much (approximate) RAM should I need to use for a problem like this?",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "I am running a problem with a very fine mesh out of necessity, the mesh is about 260 MB large, and the nonlinear system has 1,865,010 degrees of freedom. According to the documentation, 1 CPU per 20,000 DOFs is good ballpark, but I haven't gotten my simulation to run.\nInitially, I did 1 node, 20 CPUs/node, 4G of memory/CPU. The simulation progressed passed \"setting up\", and output the initial residual (where everything is 0.000), and then failed with an OOM error.\nI increased the memory to 8G/CPU, but it still failed with an OOM error. I even changed the solve type from LU:\n  #petsc_options_iname = '-pc_type'\n  #petsc_options_value = 'lu'\n\nto an iterative solver:\n  petsc_options_iname = '-ksp_type -pc_type -pc_hypre_type -pc_factor_levels'\n  petsc_options_value = 'gmres hypre boomeramg 2'\n\nBut still got the OOM error.\nThen, following the CPU/DOF guideline, I requested 5 nodes, 20 CPUs/node, 4G Memory/CPU. This time, it also made it past \"setting up\" but never got to the initial residual evaluation:\nSetting Up........................................................................................................................................................................................................\n  Setting Up Undisplaced Mesh\n    Preparing Mesh.....................\n      Updating Mesh...                                                                   [^[[33m 23.89 s^[[39m] [^[[33m 1576 MB^[[39m]\n    Finished Preparing Mesh                                                              [^[[33m135.73 s^[[39m] [^[[33m 1576 MB^[[39m]\n  Finished Setting Up Undisplaced Mesh                                                   [^[[33m135.73 s^[[39m] [^[[33m 1576 MB^[[39m]\n  Initializing\n    Updating Because Mesh Changed\n      Updating Mesh.....                                                                 [^[[33m 31.64 s^[[39m] [^[[33m 1766 MB^[[39m]\n    Finished Updating Because Mesh Changed                                               [^[[33m 31.94 s^[[39m] [^[[33m 1778 MB^[[39m]\n    Currently Initializing Equation Systems............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................\n\nAfter which the job was cancelled for exceeding the time limit (ran it on a short partition, so 4 hours/job). I also increased the number of nodes and kept running into the same problem.\nI wanted to try increasing the time now, but was wondering if there is anything I'm missing that could help performance. Also, I ran a problem with a slightly less refined mesh (160MB, so I'm guessing it has ~half the DOFs) with the initial setup, i.e 1 node, 20 CPUs/node, 4G/CPU.\nP.S. The mesh changing is a bit confusing to me since this is a thermal simulation. Yes I used a custom kernel to write the heat equation in the frequency domain but it is not a simulation where the mesh should be \"displaced\" like the preamble says.",
          "url": "https://github.com/idaholab/moose/discussions/30019",
          "updatedAt": "2025-03-11T14:08:31Z",
          "publishedAt": "2025-03-04T19:33:14Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe switch to an iterative solver is a good idea, LU wont scale to 2M DOFs\nIt seems the initializationn is either very slow or hanging. Can you use a debugger after it has been running for a while to get the backtrace on a few of the processes? This will tell us what it is doing",
                  "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12405344",
                  "updatedAt": "2025-03-05T18:53:44Z",
                  "publishedAt": "2025-03-05T18:53:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "So I got rid of the singularity install and installed directly as in https://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html, there were several modules that I had to load through trial and error.\nI still got what is likely a memory error, i.e\nCurrently Executing\n  Performing Initial Setup\n    Building SemiLocalElemMap.......................                                     [^[[33m125.22 s^[[39m] [^[[33m 1050 MB^[[39m]\n  Finished Performing Initial Setup                                                      [^[[33m128.37 s^[[39m] [^[[33m 1050 MB^[[39m]\n\nPostprocessor Values:\n+----------------+---------------------+---------------------+\n| time           | integral_trans_imag | integral_trans_real |\n+----------------+---------------------+---------------------+\n|   0.000000e+00 |        0.000000e+00 |        0.000000e+00 |\n+----------------+---------------------+---------------------+\n\n\nPerforming automatic scaling calculation\n\n--------------------------------------------------------------------------\nPrimary job  terminated normally, but 1 process returned\na non-zero exit code. Per user-direction, the job has been aborted.\n--------------------------------------------------------------------------\n--------------------------------------------------------------------------\nmpiexec noticed that process rank 0 with PID 109102 on node qnode0003 exited on signal 11 (Segmentation fault).\n--------------------------------------------------------------------------\n\nSo it got much farther than before but still failed. I tried to create a debug executable and got these errors which I am guessing are system related? Is there any other way around this?\n/hpc/software/spack_v20d1/spack/opt/spack/linux-rhel7-x86_64/gcc-10.4.0/binutils-2.40-okoq6nzwtqt7zhwdxd4cpnyztmh6kdvb/bin/ld: cannot find -lmesh_dbg: No such file or directory\n/hpc/software/spack_v20d1/spack/opt/spack/linux-rhel7-x86_64/gcc-10.4.0/binutils-2.40-okoq6nzwtqt7zhwdxd4cpnyztmh6kdvb/bin/ld: cannot find -ltimpi_dbg: No such file or directory\n/hpc/software/spack_v20d1/spack/opt/spack/linux-rhel7-x86_64/gcc-10.4.0/binutils-2.40-okoq6nzwtqt7zhwdxd4cpnyztmh6kdvb/bin/ld: cannot find -lmesh_dbg: No such file or directory\n/hpc/software/spack_v20d1/spack/opt/spack/linux-rhel7-x86_64/gcc-10.4.0/binutils-2.40-okoq6nzwtqt7zhwdxd4cpnyztmh6kdvb/bin/ld: cannot find -ltimpi_dbg: No such file or directory\nLinking Library /projects/p32089/moose_projects/moose/modules/ray_tracing/lib/libray_tracing-dbg.la...\n/hpc/software/spack_v20d1/spack/opt/spack/linux-rhel7-x86_64/gcc-10.4.0/binutils-2.40-okoq6nzwtqt7zhwdxd4cpnyztmh6kdvb/bin/ld: cannot find -lmesh_dbg: No such file or directory\n/hpc/software/spack_v20d1/spack/opt/spack/linux-rhel7-x86_64/gcc-10.4.0/binutils-2.40-okoq6nzwtqt7zhwdxd4cpnyztmh6kdvb/bin/ld: cannot find -ltimpi_dbg: No such file or directory\ncollect2: error: ld returned 1 exit status\nmake: *** [/projects/p32089/moose_projects/moose/framework/moose.mk:408: /projects/p32089/moose_projects/moose/framework/contrib/pcre/libpcre-dbg.la] Error 1",
                          "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12449989",
                          "updatedAt": "2025-03-10T14:25:39Z",
                          "publishedAt": "2025-03-10T14:25:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "/hpc/software/spack_v20d1/spack/opt/spack/linux-rhel7-x86_64/gcc-10.4.0/binutils-2.40-okoq6nzwtqt7zhwdxd4cpnyztmh6kdvb/bin/ld: cannot find -lmesh_dbg: No such file or directory\n\nno these are not related. They are due to libmesh not being available in a debug build. How did you get libmesh installed?\nThrough a container? If so, that container does not seem to include the dbg build of libmesh.\nYou can add one by installing libmesh manually (though you might need petsc installed with a debug build too?)\ncd moose/scripts\nMETHOD=dbg ./update_and_rebuild_libmesh.sh\n\nthis needs to be run on a login node on INL HPC as compute nodes do not have access to the internet\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12450148",
                          "updatedAt": "2025-03-10T14:38:48Z",
                          "publishedAt": "2025-03-10T14:38:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Didn't use a container, I loaded these modules:\nmodule purge\nmodule load git\nmodule load gcc/12.3.0-gcc\nmodule load llvm/12.0.1-gcc-12.3.0\nmodule load python/3.9.16-gcc-12.3.0\nmodule load cmake/3.26.3-gcc-12.3.0\nmodule load mpi/openmpi-4.1.6rc2-gcc-12.3.0\nmodule load hdf5/1.14.1-2-gcc-12.3.0\nmodule load gmake/4.4.1-gcc-12.3.0\nmodule load flex/2.6.3-gcc-12.3.0\nmodule load bison/3.8.2-gcc-12.3.0\n\nand then ran the petsc, libmesh, and wasp scripts. I am running the libmesh script again in debug mode now.\nAnother thing I noticed is that when I try to run this simulation on multiple nodes, I get the error:\n --------------------------------------------------------------------------\nAn ORTE daemon has unexpectedly failed after launch and before\ncommunicating back to mpirun. This could be caused by a number\nof factors, including an inability to create a connection back\nto mpirun due to a lack of common network interfaces and/or no\nroute found between them. Please check network connectivity\n(including firewalls and network routing requirements).\n--------------------------------------------------------------------------\n\nIt only runs (and gives the segfault) when I run it on a single node with multiple CPUs",
                          "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12450356",
                          "updatedAt": "2025-03-10T14:53:10Z",
                          "publishedAt": "2025-03-10T14:51:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "and then ran the petsc, libmesh, and wasp scripts. I am running the libmesh script again in debug mode.\n\nyou might want to do\nMETHODS='dbg opt' ./update_and_rebuild_libmesh.sh",
                          "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12450377",
                          "updatedAt": "2025-03-10T14:53:25Z",
                          "publishedAt": "2025-03-10T14:53:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Another thing I noticed is that when I try to run this simulation on multiple nodes, I get the error:\n\ndid you load the same MPI modules?",
                          "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12450380",
                          "updatedAt": "2025-03-10T14:53:43Z",
                          "publishedAt": "2025-03-10T14:53:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "I submitted it as a batch job where I load the modules and then do mpiexec. Will the loaded modules not be loaded on each node when submitted in a batch script?",
                          "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12450409",
                          "updatedAt": "2025-03-10T14:55:34Z",
                          "publishedAt": "2025-03-10T14:55:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Will the loaded modules not be loaded on each node when submitted in a batch script?\n\nif they are loaded by the batch script then it's fine",
                          "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12450556",
                          "updatedAt": "2025-03-10T15:04:50Z",
                          "publishedAt": "2025-03-10T15:04:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Do you have any idea what else could be causing this ORTE Daemon Failure message when I try to use more than 1 node?\nAs for running in debug mode, I got this error:\n*** ERROR ***\n/projects/p32089/moose_projects/purple/FDTR_Simulation_Fourier/Steady_State_Formulation/FDTR_input_GibbsExcess_StepFunction_BesselRing_Fourier_Steady_theta_0_freq_1e6_x0_0.i:309.3:\nThe following error occurred in the BoundaryCondition 'heat_source_term_real' of type RingGaussianPumpBessel.\n\nThis boundary condition is being executed outside the domain of definition of its variable, on subdomain: 1\n\n\n*** ERROR ***\n/projects/p32089/moose_projects/purple/FDTR_Simulation_Fourier/Steady_State_Formulation/FDTR_input_GibbsExcess_StepFunction_BesselRing_Fourier_Steady_theta_0_freq_1e6_x0_0.i:309.3:\nThe following error occurred in the BoundaryCondition 'heat_source_term_real' of type RingGaussianPumpBessel.\n\nThis boundary condition is being executed outside the domain of definition of its variable, on subdomain: 1\n\nWhich is strange because this same code/BC object ran with a coarser mesh (but the coarser mesh was block-separated before using in MOOSE). There are block restricted variables in this code too, could it be that the partitioning in the mesh with SubdomainBoundingBoxGenerator accidentally put an element in two blocks or something like that?\nRunning in debug mode like this also created an output file: tmp_jit_zMznko.cc with the contents:\n#define _USE_MATH_DEFINES\n#include <cmath>\nextern \"C\" void f_93591b04b2664d70_dbg(double * ret, const double *params, const double *immed, const double eps) {\ndouble s[5];\ns[0] = immed[0];\ns[1] = params[0];\ns[0] *= s[1];\ns[1] = immed[1];\ns[2] = params[1];\ns[2] *= s[2];\ns[3] = params[2];\ns[3] *= s[3];\ns[2] += s[3];\ns[1] *= s[2];\ns[1] = std::exp(s[1]);\ns[0] *= s[1];\n*ret = s[0]; }",
                          "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12455381",
                          "updatedAt": "2025-03-10T23:28:42Z",
                          "publishedAt": "2025-03-10T23:28:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Confirmed that the errors I was seeing previously were a mesh issue... I created another mesh with even higher refinement, but structured it in a way that made it easier for SubdomainBoundingBoxGenerator and the OOM errors disappeared. The ORTE Daemon Failure errors stop showing up today (I didnt do anything differently) so I assume it must've just been a system issue. Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12457637",
                          "updatedAt": "2025-03-11T05:53:12Z",
                          "publishedAt": "2025-03-11T05:53:12Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "*** ERROR ***\n/projects/p32089/moose_projects/purple/FDTR_Simulation_Fourier/Steady_State_Formulation/FDTR_input_GibbsExcess_StepFunction_BesselRing_Fourier_Steady_theta_0_freq_1e6_x0_0.i:309.3:\nThe following error occurred in the BoundaryCondition 'heat_source_term_real' of type RingGaussianPumpBessel.\n\nThis boundary condition is being executed outside the domain of definition of its variable, on subdomain: 1\n\nThis is from the integrity check that checks that variables are defined near the boundaries that they hold a boundary condition onto.\nYou can turn this off but then you need to add skip_execution_outside_variable_domain to any integrated BC.\nMuch better to fix your mesh!\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/30019#discussioncomment-12462486",
                          "updatedAt": "2025-03-11T14:08:45Z",
                          "publishedAt": "2025-03-11T14:08:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Calculate/Measure Crack Length",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Dear all,\nIn the phase-field fracture simulation, how to calculate and output the crack length to a .csv file? Or how to do it in the post-processing? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/29835",
          "updatedAt": "2025-03-11T13:50:43Z",
          "publishedAt": "2025-02-07T16:10:38Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Are you using XFEM too?\nHow is the crack being simulated?",
                  "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12098093",
                  "updatedAt": "2025-02-07T19:24:31Z",
                  "publishedAt": "2025-02-07T19:24:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Hi~I'm using phase-field model in MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12098129",
                          "updatedAt": "2025-02-07T19:29:21Z",
                          "publishedAt": "2025-02-07T19:29:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "You could ElementIntegralMaterialProperty postprocessor to integrate the phase field material quantity over the domain and it will output that quantity to csv.  I don't know what the phase field quantitiy is but I think it varies between 0 and 1.  That would give the crack volume.  If its a variable then use the variable version of the postprocessor.",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12151306",
                          "updatedAt": "2025-02-11T20:00:56Z",
                          "publishedAt": "2025-02-11T20:00:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thanks. @lynnmunday With this integration, it gets the crack volume, but it's not necessarily the crack length, say when the crack phase-field is at low level (~0.3 or 0.5), it counts in the integral but does not contribute to the crack length (~0.9 or 1.0), right?",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12153692",
                          "updatedAt": "2025-02-11T21:48:23Z",
                          "publishedAt": "2025-02-11T21:48:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "You're right.  You could make a parsed material that is something like\n[./phasemap]\n  type = ParsedMaterial\n  property_name = stepped_phase\n  coupled_variables = 'phase'\n  expression = 'if(phase>0.9,1,0)'\n  outputs = exodus\n[]\n\nand integrate that.",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12154960",
                          "updatedAt": "2025-02-11T22:59:50Z",
                          "publishedAt": "2025-02-11T22:59:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thanks @lynnmunday It works!",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12168237",
                          "updatedAt": "2025-02-12T10:40:56Z",
                          "publishedAt": "2025-02-12T10:40:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@lynnmunday I have a follow-up question: I run a 2D simulation and use [ElementIntegralMaterialProperty] as said, what I get is the integral value of the 2d domain, something like the area value, but the crack length is 1d, right? How to treat it properly to get the length?",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12202581",
                          "updatedAt": "2025-02-14T15:50:30Z",
                          "publishedAt": "2025-02-14T15:50:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is there a boundary or block along the crack?",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12202594",
                          "updatedAt": "2025-02-14T15:51:50Z",
                          "publishedAt": "2025-02-14T15:51:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "The boundaries can be set for a simple expecting cracking path, but what if arbitrary crack propagation?",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12202637",
                          "updatedAt": "2025-02-14T15:54:55Z",
                          "publishedAt": "2025-02-14T15:54:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you dont have a boundary or a block, then most of the postprocessors / VPPs wont help you\nOne thing you can do is :\n\nuse an auxkernel to create an auxvariable field that measures the distance to the crack\nuse a mesh division on create regions based on the bins of that auxvariable\nhttps://mooseframework.inl.gov/source/meshdivisions/FunctorBinnedValuesDivision.html\nthen use a VPP to gather the integrals over those divisions\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/MeshDivisionFunctorReductionVectorPostprocessor.html\n\nnote here than Functor can be an auxvariable but cannot be a regular material property\nso you will neeed to also use a MaterialRealAux to convert the material property to an auxiliary variable",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12202760",
                          "updatedAt": "2025-02-14T16:01:36Z",
                          "publishedAt": "2025-02-14T16:01:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "Can you just divide by the crack thickness to get the length?  Isn't there some kind of phase field smoothing distance you could use for the thickness?",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12205428",
                          "updatedAt": "2025-02-14T20:49:09Z",
                          "publishedAt": "2025-02-14T20:49:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lyyc199586"
                  },
                  "bodyText": "I built a filter of Paraview to track the phase field crack tip, it is purely postprocessing in Paraview, you can have a look https://github.com/lyyc199586/pvfilters",
                  "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12462281",
                  "updatedAt": "2025-03-11T13:51:03Z",
                  "publishedAt": "2025-03-11T13:50:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}