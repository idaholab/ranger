{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMi0wNVQxMjowODoyMy0wNzowMM4ARqSz"
    },
    "edges": [
      {
        "node": {
          "title": "Nodal field question",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "Just a general finite element question, but maybe specifically for the MOOSE implementation.\nLet's say I have an auxiliary field variable, like temperature, defined at nodes. In a finite deformation mechanics model, do the values of my field variables interpolated to the quadrature points change/update on nonlinear iterations? The nodal values are not changing but the displacements, and therefore the shape of the element, can change as the step converges.",
          "url": "https://github.com/idaholab/moose/discussions/22885",
          "updatedAt": "2022-12-07T14:51:51Z",
          "publishedAt": "2022-12-06T00:16:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "In MOOSE/LibMesh, Nodal variables and their interpolants do not change with mesh deformation (on the same tessellation). Their gradients do.\nIn a more general setting of FEM, interpolants could change if you use some less common parametric mapping for element coordinates. But I've never seen that in MOOSE.",
                  "url": "https://github.com/idaholab/moose/discussions/22885#discussioncomment-4322898",
                  "updatedAt": "2022-12-06T12:56:34Z",
                  "publishedAt": "2022-12-06T12:56:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "ok, so shouldn't matter if I'm using displaced or undisplaed mesh to get the interpolated values at the qp's?",
                          "url": "https://github.com/idaholab/moose/discussions/22885#discussioncomment-4325835",
                          "updatedAt": "2022-12-06T18:17:36Z",
                          "publishedAt": "2022-12-06T18:17:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yep. It doesn't matter.",
                          "url": "https://github.com/idaholab/moose/discussions/22885#discussioncomment-4330040",
                          "updatedAt": "2022-12-07T07:08:04Z",
                          "publishedAt": "2022-12-07T07:07:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "\ud83d\udc4d",
                          "url": "https://github.com/idaholab/moose/discussions/22885#discussioncomment-4333833",
                          "updatedAt": "2022-12-07T14:51:38Z",
                          "publishedAt": "2022-12-07T14:51:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Why are the inelastic models inactivated after cracking in smeared cracking model?",
          "author": {
            "login": "xuxiaobei1995"
          },
          "bodyText": "Hi all,\nRecently I'm doing some work concerning the cracking. I read the codes in ComputeSmearedCrackingStress and find that the inelastic models are inactivated after the cracking happens. Does any one know the reason of this operation? How can I do to keep the inelastic models activated after cracking?\nBest Regards,\nXiaobei",
          "url": "https://github.com/idaholab/moose/discussions/22894",
          "updatedAt": "2022-12-07T07:48:26Z",
          "publishedAt": "2022-12-06T13:54:45Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc I think you wrote this object",
                  "url": "https://github.com/idaholab/moose/discussions/22894#discussioncomment-4324077",
                  "updatedAt": "2022-12-06T15:11:04Z",
                  "publishedAt": "2022-12-06T15:11:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Recently I'm doing some work concerning the cracking. I read the codes in ComputeSmearedCrackingStress and find that the inelastic models are inactivated after the cracking happens. Does any one know the reason of this operation?\n\nThere are many types of inelastic(plastic)-damage models:\nE-D\nE-D-P\nE-D-PD\nE-P-D\nE-P-PD\nwhere E, P, D, PD divide the state of the material into 4 categories\nE: purely elastic phase, little damage growth, no plastic flow\nP: purely plastic phase, mostly plastic deformation, small elastic deformation, little damage growth\nD: purely softening phase, a lot of damage growth, little plastic flow\nPD: a mix of plastic flow and damage softening\nWe happen to have implemented the E-P-D type, that's it. I believe there were good reasons for that choice.\n\nHow can I do to keep the inelastic models activated after cracking?\n\nNot that I know from an input file, no. But that ComputeMultipleInelasticStress or its alike is a complicated beast, there might be some magic parameter that allows you to do that.\nIf you are willing to modify the source, yes.",
                  "url": "https://github.com/idaholab/moose/discussions/22894#discussioncomment-4330124",
                  "updatedAt": "2022-12-07T07:20:55Z",
                  "publishedAt": "2022-12-07T07:20:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Hi hugary, In fact I found that the smeared cracking may not be suitable for my work. Anyway, thanks for your explanation!",
                          "url": "https://github.com/idaholab/moose/discussions/22894#discussioncomment-4330340",
                          "updatedAt": "2022-12-07T07:48:20Z",
                          "publishedAt": "2022-12-07T07:48:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[PorousFlow] why a small amount of rainfall flooded the model (PorousFlowSink)",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys, I'm working on the underground water modelling and want to add the rainfall into the model\nso here is a simple model (1km x 1km x 0.5 km 20^3 mesh) with 15% porosity and perm of 1e-15 m2\nhere are the BCs: basically (rho g h) at the 4 sides + rain at the top\nand the amount of rain basically is from a quick google search\n\"Australia has a very low annual average rainfall of 419 mm\"\nso 419 mm year-1 = 419* 1e-3 m3 m-2 year-1 = 419 kg m-2 year -1\nnote that my time unit is in YEARS\n  [./ini_pp]\n    type = ParsedFunction\n    value  = 9.81*1000*(500-z)\n  [../]\n\n     [./water_grad_left]\n       type = FunctionDirichletBC\n       variable = porepressure\n       boundary = 'left'\n       function = ini_pp\n       # save_in = fluxes_out\n     [../]\n\n     [./water_grad_right]\n       type = FunctionDirichletBC\n       variable = porepressure\n       boundary = 'right'\n       function = ini_pp\n        # save_in = fluxes_out\n     [../]\n\n     [./water_grad_top]\n       type = FunctionDirichletBC\n       variable = porepressure\n       boundary = 'top'\n       function = ini_pp\n        # save_in = fluxes_out\n     [../]\n\n     [./water_grad_bottom]\n       type = FunctionDirichletBC\n       variable = porepressure\n       boundary = 'bottom'\n       function = ini_pp\n        # save_in = fluxes_out\n     [../]\n\n          [rainfall_recharge]\n             type = PorousFlowSink\n             fluid_phase = 0\n             boundary = 'front'\n             variable = porepressure\n             flux_function = - 419\n             save_in = fluxes_out\n           []\n\nsimulation is run in steady-state, and here is the result:\n\nbut then when I change the perm to unrealistically high (1e-12 m2), this is what I got + the streamline move in a totally different way\n\nfeel like with an extremely high perm case more water is able to move out from the system (from top to bottom of the sides), but in a normal groundwater perm case, not all the water can move out from the system (streamline at the sides is minimal).\nnot sure if my PorousFlowSink flux_function is correct\n@WilkAndy I'm tagging you here since you are the porousflow expert\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/22867",
          "updatedAt": "2022-12-10T07:04:56Z",
          "publishedAt": "2022-12-05T05:07:07Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Hi @Traiwit - there is nothing wrong with your BCs if you believe that 419mm/year is entering the groundwater system.  However, that is likely unphysical.  Recently, we quantified recharge to the Australia's groundwater system - have a look at https://doi.org/10.25919/waky-s739 .   There you will see values much less than 419mm/year.  I don't know what area you're looking at, but a value of 10mm/year is more likely.\nThe reason this is a lot smaller than the rainfall is that most water ends up as runoff, or is evapotranspirated.  If you are doing any reasonably realistic groundwater modelling, your model should likely include regional groundwater flow (can be set by using appropriate Dirichlet BCs, for instance) as well as evapotranspiration (i would use https://mooseframework.inl.gov/source/bcs/PorousFlowHalfCubicSink.html , and you can find estimates of the \"pan evaporation\" online - eg at the BOM http://www.bom.gov.au/climate/change/about/evap_averagemaps.shtml ).",
                  "url": "https://github.com/idaholab/moose/discussions/22867#discussioncomment-4311828",
                  "updatedAt": "2022-12-05T10:26:45Z",
                  "publishedAt": "2022-12-05T10:26:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks for the answer @WilkAndy, if I understand correctly, IF i want to use only PorousFlowSink I need to consider: rainfall + evaporation and flow at the surface altogether right? and that would be 'surface recharge' data instead of just 'rainfall'",
                          "url": "https://github.com/idaholab/moose/discussions/22867#discussioncomment-4319239",
                          "updatedAt": "2022-12-06T03:35:46Z",
                          "publishedAt": "2022-12-06T03:35:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Yes, that is true, @Traiwit , but your model will likely quite rapidly fill up, if only your \"side\" boundary conditions are letting water out.  Also, it will likely not be possible if your topography is non-horizontal, as you will have natural seep points at the bottom of valleys, where you should let water out by using a PorousFlowPiecewiseLinearSink.",
                          "url": "https://github.com/idaholab/moose/discussions/22867#discussioncomment-4320404",
                          "updatedAt": "2022-12-06T07:33:29Z",
                          "publishedAt": "2022-12-06T07:33:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @WilkAndy\nNot sure how do I set PorousFlowPiecewiseLinearSink to the side to let water out WHILE maintaining the rho x g x h\nfor our real models, we define pwp at all the nodes on 4 sides including the mountain range from CSV > PiecewiseConstantFromCSV > BC.\n\n\nAlso nice that you brought up the non-horizontal topol, lets me explain the actual real model we are working on, it might not be related to what you mentioned, but you may find it interesting:\nYes, most of our topols are not completely flat, for example:\n\nwhere is orange surface is the pit with drainage BC\nand the topol BC just set so the water table is 10m under the top of the system\n[./drain]\ntype = PorousFlowPiecewiseLinearSinkBEH #exactly the same as PorousFlowPiecewiseLinearSink just add 1/element length to the equation\nvariable = porepressure\nboundary = 'DRAINSRFPIT'\npt_vals = '0 1e9'\nmultipliers = '0 1e9'\nflux_function = 1\nv = min_dist\nPT_shift = 0\nfluid_phase = 0\nuse_mobility = true\n[../]\n\n[./topol_linear]\ntype = PorousFlowPiecewiseLinearSink\nvariable = porepressure\nboundary = 'TOPOLSRF'\npt_vals = '-1e9 1e9'\nmultipliers = '-1e9 1e9'\nflux_function = 1\nv = min_dist\nPT_shift = -98100 #10m below surface\nfluid_phase = 0\n[../]\n\nIt has been working fine just like that, BUT for this particular problem/mine it has a cave area where the perm is high compared to the rest of the model\n\nhere is the result if I use the PorousFlowPiecewiseLinearSink for topol\n\nHence we are trying to use PorousFlowSink with real data to deal with this problem instead. I tried flux_function = -10 just to test it out, here is the result: (the system is drained too much but at the edge it still flooded with water)\n\n\nAt this current stage, I still don't know what to do, might try mixing PorousFlowPiecewiseLinearSink and PorousFlowSink to balance them out.\nPlease let me know if you have any idea on how to deal with this problem, otherwise, it's okay I find it quite overwhelming too.\nThank you!\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/22867#discussioncomment-4320774",
                          "updatedAt": "2022-12-06T08:30:52Z",
                          "publishedAt": "2022-12-06T08:30:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I only meant applying the PorousFlowPiecewiseLinearSink on the top of the model, not on its sides.  So, just like you've done with your drain (but over the entire topography, not just the pit).\nLet's discuss your topol_linear.... If the water table ever drops below 10m below the topography, you are adding water to the system, and if it is ever above this point, you're substracting water.   Is this really what you want?\nUsually, you'd have:\n\na constant recharge acting over the entire topography (PorousFlowSink with negative flux_function - of course this could vary spatially and temporally, but constant is clearly easier to parameterise!)\nseepage - this is just your drain but acting over the entire topography, which will remove water from any places that it accumulates\nevapotranspiration everywhere on the topography (PorousFlowHalfCubicSink)\n\nThese will control the porepressure so that is almost nowhere positive, and sits close to the root depth of the evapotranspiration in many places, and can be quite negative near the tops of hills.\nBy the way, one reason the half-cubic or half-gaussian are advantageous numerically, is because they are smooth and differentiable, unlike the straightforward PieceiwseLinearSink.  Also, the use_mobility might give you better understanding of what to use for flux_function, and the use_relperm might provide quicker numerical convergence.",
                          "url": "https://github.com/idaholab/moose/discussions/22867#discussioncomment-4321057",
                          "updatedAt": "2022-12-06T09:09:07Z",
                          "publishedAt": "2022-12-06T09:09:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "By the way, feel free to ring/email, @Traiwit .   I'd prefer to sort it out on this github discussion, because then future people can learn from it, but sometimes phonecalls are much more efficient!",
                          "url": "https://github.com/idaholab/moose/discussions/22867#discussioncomment-4321089",
                          "updatedAt": "2022-12-06T09:11:37Z",
                          "publishedAt": "2022-12-06T09:11:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks @WilkAndy, I will try to run more scenarios to gain more understanding of these BCs (mixing 2 or all of them), and then I will probs contact you tomorrow (Note that I'm in Sydney/AU time-zone)\nNote that we are running the problem in FullySat flow model for simplicity, which might give me less realistic results.\nThank you\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/22867#discussioncomment-4321173",
                          "updatedAt": "2022-12-06T09:23:02Z",
                          "publishedAt": "2022-12-06T09:23:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @WilkAndy here is some interesting finding:\nNot sure if you see above, drain and topol BCs have different pt_vals and multipliers\ndrain\npt_vals = '0 1e9'\nmultipliers = '0 1e9'\n\ntopol\npt_vals = '-1e9 1e9'\nmultipliers = '-1e9 1e9'\n\nSo rain4 and rain6 are pretty much the results we want, it seems like PorousFlowSink with flux_function = -10 doesn't do much\nNow I think I should narrow down to the controlling of the flux_function of topol, I don't have a specific value for it yet, I just know for drain I want the surface to be dry (flux_function as high as possible while the simulation still converges, right now 1 is good for all cases so far), However, for topol I've been using flux_function = 1 for the none-cave models (working fine so far), but yeh still need to figure out for this case.\n\nRegards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/22867#discussioncomment-4329190",
                          "updatedAt": "2022-12-07T04:02:33Z",
                          "publishedAt": "2022-12-07T04:02:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to output the assigned area to each node for integrated BCs?",
          "author": {
            "login": "garciapintado"
          },
          "bodyText": "As I understand, when saved (save_in=True), the values from integrated boundary condition objects (e.g. NeumannBC) give the flux assigned to each boundary node in the considered sideset, where each node is assigned an area.\nPlease, is there any direct way (which I am then missing) to output the nodal area assigned to each  of these BC nodes so one could get the flux per unit area?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/22878",
          "updatedAt": "2022-12-06T21:07:40Z",
          "publishedAt": "2022-12-05T18:00:23Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think the area around the node is baked into _JxW[0] for a kernel acting on a nodal variable.\nIt should be similar for a flux BC\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22878#discussioncomment-4318908",
                  "updatedAt": "2022-12-06T02:23:27Z",
                  "publishedAt": "2022-12-06T02:23:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "garciapintado"
                  },
                  "bodyText": "Thanks for answer, @GiudGiud . Sorry that I am not getting this.  As I've understood, I should create a Boundary restricted Nodal AuxKernel object (e.g., let\u2019s call it NodalAreaBC), inheriting from Auxkernel, and with computeValue as:\nReal\nNodalAreaBC::computeValue()\n{\n  if (isNodal())\n      return _JxW[0];\n  else\n      return _JxW[_qp];\n}\n\nWhich obviously is wrong as it does not work. That is, for an elemental auxiliary variable variable it outputs something proportional to the element size, but not quite the element area, and for a nodal auxiliary variable, as follows, it directly gives a segmentation error.\n[AuxVariables]\n  [node_area]\n    family = LAGRANGE\n    order = FIRST\n    #family = MONOMIAL\n    #order = CONSTANT\n  []\n[]\n\n[AuxKernels]\n  [node_area]\n    type = NodalAreaBC\n    variable = node_area\n    boundary = top\n  []\n[]\n\nCould you please advise further?",
                  "url": "https://github.com/idaholab/moose/discussions/22878#discussioncomment-4325232",
                  "updatedAt": "2022-12-06T18:09:09Z",
                  "publishedAt": "2022-12-06T17:17:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The behavior with the elemental variable is expected.\nDo you need this output in an auxiliary variable? Or can you use it on the fly in a calculation?\nWithout digging into it, I dont think the auxkernel will have the local nodal area computed at any point. I would expect boundary conditions (which will not allow you to output the quantity) to have it",
                          "url": "https://github.com/idaholab/moose/discussions/22878#discussioncomment-4325501",
                          "updatedAt": "2022-12-06T17:41:03Z",
                          "publishedAt": "2022-12-06T17:41:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "garciapintado"
                          },
                          "bodyText": "The point is that if I have an integratedBC for energy flux, whose output is, integrated for each node [J.s-1] through a boundary. This is nice as I can directly use also a postprocessor to get the nodal sum, and so the integrated energy flux [J.s-1] across all the boundary as a global value.\nSo far so good, but on the other hand, the element size along this boundary [with a rather high spatial variability] implies that plotting of this flux, as it is a product of the flux per unit area [J.m-2.s-1] ---what I would like to see in plots--- times the assigned nodal size [m2], is not so nice.\nThe only way I can think of doing this is by adding an Auxkernel, which would be calculated just once within MOOSE, indicating the corresponding nodal areas for the element boundaries. I could then later [out of MOOSE] divide the integratedBC saved_in value by the nodal areas.\nMaybe I'm missing an alternative?",
                          "url": "https://github.com/idaholab/moose/discussions/22878#discussioncomment-4325968",
                          "updatedAt": "2022-12-06T18:33:57Z",
                          "publishedAt": "2022-12-06T18:33:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you divide the integrated flux by the total surface area instead of the local nodal area?\nThe total area of a sideset is easy to get with a surface postprocessor",
                          "url": "https://github.com/idaholab/moose/discussions/22878#discussioncomment-4325995",
                          "updatedAt": "2022-12-06T18:36:45Z",
                          "publishedAt": "2022-12-06T18:36:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "garciapintado"
                          },
                          "bodyText": "Well, no. That would give the average flux intensity [J.m-2.s-1], but not the spatial distribution of the intensity (of course, the same units [J.m-2.s-1]).",
                          "url": "https://github.com/idaholab/moose/discussions/22878#discussioncomment-4326031",
                          "updatedAt": "2022-12-06T18:42:16Z",
                          "publishedAt": "2022-12-06T18:42:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "garciapintado"
                          },
                          "bodyText": "I've been for a few days trying to see if I was missing some MOOSE option for this. A \"promising\" object name was the auxkernel NodalVolumePD, from the peridynamics module , but it seems to be only for PD mesh objects.",
                          "url": "https://github.com/idaholab/moose/discussions/22878#discussioncomment-4326082",
                          "updatedAt": "2022-12-06T18:48:40Z",
                          "publishedAt": "2022-12-06T18:48:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "There is an user object called NodalArea. It may be what you are looking for.",
                  "url": "https://github.com/idaholab/moose/discussions/22878#discussioncomment-4326270",
                  "updatedAt": "2022-12-06T19:10:27Z",
                  "publishedAt": "2022-12-06T19:10:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "garciapintado"
                          },
                          "bodyText": "Right! In the contact module. It does not appear  listed in the Moose documentation Syntax Index, but it does within the documentation source list. I had completely missed it. I've just tried and works as expected! Many thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/22878#discussioncomment-4327016",
                          "updatedAt": "2022-12-06T21:07:36Z",
                          "publishedAt": "2022-12-06T21:07:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow: constant field of energy source",
          "author": {
            "login": "garciapintado"
          },
          "bodyText": "Hello,\nI am wondering if in PorousFlow there is someway to use the available kernels to add a constant field [spatially distributed] of heat as source term for the energy continuity equation. I can\u2019t see how\u2026",
          "url": "https://github.com/idaholab/moose/discussions/22896",
          "updatedAt": "2022-12-06T19:33:29Z",
          "publishedAt": "2022-12-06T17:36:25Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "garciapintado"
                  },
                  "bodyText": "Please forget this discussion, I see that HeatSource kernel from the Heat conduction module can be used for this purpose",
                  "url": "https://github.com/idaholab/moose/discussions/22896#discussioncomment-4326433",
                  "updatedAt": "2022-12-06T19:33:25Z",
                  "publishedAt": "2022-12-06T19:33:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A conjugate heat transfer problem about TH module.",
          "author": {
            "login": "Raven-pro"
          },
          "bodyText": "Hello developers!\nI am using the TH module to establish a conjugate heat transfer system where there is a 1D flow channel at the center, and there are two heat structures on each side.\nThe structure of the heat structure is the fuel as a heat source inside with cladding outside.\nSo the process is, the heat source generates heat, and the heat is conducted through the cladding, the flow takes away heat as its temperature increases.\nWhen the simulation reaches a steady state, the temperature distribution should be, the heat source having the highest temperature, and near the wall, the temperature is lower.\nHowever, the result is different from what it is supposed to be. I visualized it in the ParaView as below.\n\nSo, for each heat structure, the heat distribution is identical: the highest temperature on the left and the lowest on the right\nI have also attached my input file below. Can anybody help me with dealing with such a problem?\nT_in = 533.15            # K\n# m_dot_in = 1.3565      # kg/s\nm_dot_in = 0.96805       # kg/s\npress = 15.5e6           # Pa\n\n# plate channels parameters (x,y,z)\nplate_height = 0.75      # m\nplate_width = 0.0762     # m\nplate_thick = 0.00038    # m\n\n# core parameters\ncore_n_elems = 100\ncore_gap = 0.00228       # m\n\ntot_power = 2e9          # W/m3\n\n[GlobalParams]\n    initial_p = ${press}\n    initial_vel = 7\n    initial_T = ${T_in}\n    rdg_slope_reconstruction = full\n    closures = simple_closures\n    fp = water\n[]\n\n# [Functions]\n#     [power_func]\n#         type = ParsedFunction\n#         value = '1.570796326794897 * sin(z / 3.6576 * pi)'\n#     []\n# []\n\n[Functions]\n    [HeatFunction]\n      type = ParsedFunction\n      value = ${tot_power}\n    []\n[]\n\n# [AuxVariables]\n#     [power_density]\n#       family = MONOMIAL\n#       order = CONSTANT\n#       block = 'core_hs1:FUEL1 core_hs2:FUEL2'\n#     []\n# []\n\n# [AuxKernels]\n#     [mock_power_aux]\n#       type = FunctionAux\n#       variable = power_density\n#       function = HeatFunction\n#       block = 'core_hs1:FUEL1 core_hs2:FUEL2'\n#     []\n# []\n\n[Modules]\n    [FluidProperties]\n        [water]\n            type = StiffenedGasFluidProperties\n            gamma = 2.35\n            cv = 1816.0\n            q = -1.167e6\n            p_inf = 1.0e9\n            q_prime = 0\n        []\n    []\n[]\n\n[SolidProperties]\n    [cladding]\n        type = ThermalFunctionSolidProperties\n        rho = 2700.0\n        cp = 897\n        k = '131.25+t/8.33e2'\n    []\n\n    [fuel]\n        type = ThermalFunctionSolidProperties\n        rho = 6030.0\n        cp = '(0.892+0.00046*t-0.71*(0.749+0.00038*t))*1e3'\n        k = 50.7\n    []\n[]\n\n\n[Closures]\n    [simple_closures]\n        type = Closures1PhaseSimple\n    []\n[]\n########################Structure Material Prop#################\n[Materials]\n    [fuel-mat]\n      type = ADConstantDensityThermalSolidPropertiesMaterial\n      block = 'core_hs1:FUEL1 core_hs2:FUEL2'\n      sp = fuel\n      temperature = T_solid\n      T_ref = 300\n    []\n  \n    # [gap-mat]\n    #   type = ADGenericConstantMaterial\n    #   block = 'core_hs:GAP1 core_hs:GAP2'\n    #   prop_names = 'thermal_conductivity specific_heat density'\n    #   prop_values = '1.084498 1.0 1.0'\n    # []\n  \n    [clad-mat]\n      type = ADConstantDensityThermalSolidPropertiesMaterial\n      block = 'core_hs1:CLAD1 core_hs2:CLAD2'\n      sp = cladding\n      temperature = T_solid\n      T_ref = 300\n    []\n[]\n\n[Components]\n########################Single Phase Flow#######################\n\n############################channel 1###########################\n    [inlet1]\n        type = InletMassFlowRateTemperature1Phase\n        input = 'core_chan1:in'\n        m_dot = ${m_dot_in}\n        T = ${T_in}\n    []\n\n    [core_chan1]\n        type = FlowChannel1Phase\n        position = '0 0 0'\n        orientation = '0 0 1'\n        length = ${plate_height}\n        n_elems = ${core_n_elems}\n        A = ${fparse plate_width * core_gap}\n        D_h = ${fparse 2 * plate_width * core_gap/(plate_width + core_gap)}\n        f = 0.16\n    []\n\n    [outlet1]\n        type = Outlet1Phase\n        input = 'core_chan1:out'\n        p = ${press}\n    []\n########################Heat Structure##########################\n\n############################Core HS1############################\n    [total_power1]\n        type = TotalPower\n        power = ${fparse tot_power * plate_height * plate_thick * plate_width}\n    []\n    [core_hs1]\n        type = HeatStructureCylindrical\n        position = '0 0 0'           \n        orientation = '0 0 1'\n        length = ${plate_height}\n        n_elems = ${core_n_elems}\n\n        names = 'CLAD1 FUEL1'       # pay attention to block\n        widths = '0.00038 0.00038'\n        # materials = 'steel'\n        n_part_elems = '10 10'      # radial elements\n        initial_T = 564.15\n    []\n\n    [core_heating1]\n        type = HeatSourceFromTotalPower\n        hs = core_hs1\n        regions = 'FUEL1'\n        power = total_power1\n        # power_shape_function = power_func\n    []\n\n    # [core_heating1]\n    #     type = HeatSourceFromPowerDensity\n    #     hs = core_hs1\n    #     regions = 'FUEL1'\n    #     # power_density = power_density\n    #     power = total_power\n    # []\n\n    [core_ht1]\n        type = HeatTransferFromHeatStructure1Phase\n        flow_channel = core_chan1\n        hs = core_hs1\n        hs_side = outer\n        P_hf = ${plate_width}\n        Hw = 50000\n    []\n\n############################Core HS2############################\n    [total_power2]\n        type = TotalPower\n        power = ${fparse tot_power * plate_height * plate_thick * plate_width}\n    []\n    [core_hs2]\n        type = HeatStructureCylindrical\n        position = '0 -0.00076 0'           \n        orientation = '0 0 1'\n        length = ${plate_height}\n        n_elems = ${core_n_elems}\n\n        names = 'CLAD2 FUEL2'       # pay attention to block\n        widths = '0.00038 0.00038'\n        # materials = 'steel'\n        n_part_elems = '10 10'      # radial elements\n        initial_T = 564.15\n    []\n\n    [core_heating2]\n        type = HeatSourceFromTotalPower\n        hs = core_hs2\n        regions = 'FUEL2'\n        power = total_power2\n        # power_shape_function = power_func\n    []\n\n    # [core_heating2]\n    #     type = HeatSourceFromPowerDensity\n    #     hs = core_hs2\n    #     regions = 'FUEL2'\n    #     # power_density = power_density\n    #     power = total_power\n    # []\n\n    [core_ht2]\n        type = HeatTransferFromHeatStructure1Phase\n        flow_channel = core_chan1\n        hs = core_hs2\n        hs_side = outer\n        P_hf = ${plate_width}\n        Hw = 50000\n    []\n########################End#####################################\n[]\n\n[Executioner]\n    type = Transient\n    start_time = 0\n    end_time = 100000\n    dt = 10000\n  \n    line_search = basic\n    solve_type = PJFNK\n  \n    nl_rel_tol = 1e-5\n    nl_abs_tol = 1e-5\n    nl_max_its = 5\n[]\n  \n[Outputs]\n    exodus = true\n  \n    [console]\n      type = Console\n      max_rows = 1\n      outlier_variable_norms = false\n    []\n    print_linear_residuals = false\n[]",
          "url": "https://github.com/idaholab/moose/discussions/22843",
          "updatedAt": "2022-12-06T14:24:06Z",
          "publishedAt": "2022-12-01T12:53:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou need to pass different sides in hs_side for the two heat transfer components I think.\nFrom the docs https://mooseframework.inl.gov/modules/thermal_hydraulics/source/components/HeatTransferFromHeatStructure1Phase.html\nYou have these options:\nEND, INNER, OUTER, START\nI think you want one to be 'inner' and the other to be outer.\nAm I understanding this right that one cylinder is the inner cylinder and the other the outer cylinder?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4287897",
                  "updatedAt": "2022-12-01T23:49:39Z",
                  "publishedAt": "2022-12-01T23:49:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Thanks, I tried to switch hs_side to inner, but the following warning came out.\n\nI don't know what inner and outer mean here. I want the heat to transfer from left to right in one cylinder and from right to left in the other cylinder, as the flow channel is at the center.\nBut the result seems that the heat can only transfer from left to right.",
                          "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4288739",
                          "updatedAt": "2022-12-02T02:42:41Z",
                          "publishedAt": "2022-12-02T02:42:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Am I sitting something wrong in my input file?",
                          "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4288746",
                          "updatedAt": "2022-12-02T02:44:13Z",
                          "publishedAt": "2022-12-02T02:44:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so the flow is between two cylinders that are NOT concentric? do you have a sketch of what the channel looks like?",
                          "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4289397",
                          "updatedAt": "2022-12-02T04:34:25Z",
                          "publishedAt": "2022-12-02T04:34:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "as to what the meaning of inner and outer are, these structures are cylinders, so it's the inner/outer surfaces of a cylinder that has a hole inside if inner_radius > 0",
                          "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4289449",
                          "updatedAt": "2022-12-02T04:47:15Z",
                          "publishedAt": "2022-12-02T04:47:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Yes, the cylinders are not concentric, they are parallel with the flow in the middle. The sketch is as below.\n\nCan TH module achieve such conjugate heat transfer?",
                          "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4289502",
                          "updatedAt": "2022-12-02T05:00:24Z",
                          "publishedAt": "2022-12-02T05:00:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it can\nI think something is wrong with your positioning of each structure. They overlap and touch and it seems wrong\n\none heat structure is at y = -0.0076 and is 0.0076 * 2 wide so it touches y=0\nthe channel is at y=0\nthe other heat structure is at y=0 so it overlaps with the channel and it s also 0.0076*2 wide so it overlaps with the other heat structure.\n\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4293535",
                          "updatedAt": "2022-12-02T15:31:29Z",
                          "publishedAt": "2022-12-02T15:31:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "I don't get it, I thought the first heat structure is 0.0076 wide(2 * 0.0038).\nBecause the channel is at y = 0, and the left edge of the second structure just touches the channel.\nThe left edge of the first structure is -0.0076, so the right edge of it touches the channel as well.\nI don't think there is overlapping. Did I miss something?",
                          "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4297415",
                          "updatedAt": "2022-12-03T04:36:59Z",
                          "publishedAt": "2022-12-03T04:36:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The plot you showed seems to show the two heat structures are touching, when you want the space for the channel in between?",
                          "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4297434",
                          "updatedAt": "2022-12-03T04:53:54Z",
                          "publishedAt": "2022-12-03T04:53:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "The channel(the blue part) is 1D, and is in the middle of two heat structures(the red parts are fuels, and the orange parts are claddings).\nAs the channel is 1D, and I thought the heat structures should touch the channel(I don't know if that's true), so the right side of the left hs and the left side of the right hs touch the same flow channel, and it seems they touch each other.",
                          "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4297524",
                          "updatedAt": "2022-12-03T05:52:07Z",
                          "publishedAt": "2022-12-03T05:52:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I can see that in the sketch. In the exodus output you pasted first, is every component where it should be?\nThis just looks like an output issue at this point. We only output the RZ part of the cylinder, and the one you want to see in the figure is the symmetric with regards to the Z axis of this RZ figure.",
                          "url": "https://github.com/idaholab/moose/discussions/22843#discussioncomment-4299418",
                          "updatedAt": "2022-12-03T15:50:04Z",
                          "publishedAt": "2022-12-03T15:50:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "plane stress J2 plasticity - affine deformation - material properties at Gauss Points",
          "author": {
            "login": "gsoim"
          },
          "bodyText": "Hi all,\nI am trying to solve a simple 2D problem for two different material properties: a) plane stress elasticity and b) plane stress J2 plasticity. I would like to ask if it is possible to:\n\nDefine different material properties at each Gauss point, using elem_type=QUAD4 (i.e. Young's modulus for the linear elastic model or yield stress for the elasto-plastic model) and\nImpose affine deformation on the boundaries in the input file (*.i) that uses a matrix multiplied by the coords at each boundary, that I already have as an input (practically it's the DefGrad that I already have from an upper-scale model analysis using Abaqus).\nI have seen in the examples/tutorials several J2 plasticity problems for 3D, but I guess there is no problem for the plane stress case, right??\n\nThank you very much in advance.\nBest,\nGeorge",
          "url": "https://github.com/idaholab/moose/discussions/22888",
          "updatedAt": "2023-02-04T07:20:03Z",
          "publishedAt": "2022-12-06T02:34:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Define different material properties at each Gauss point, using elem_type=QUAD4 (i.e. Young's modulus for the linear elastic model or yield stress for the elasto-plastic model) and\n\n\nYes, all material properties are defined per qp by default.\n\n\nImpose affine deformation on the boundaries in the input file (*.i) that uses a matrix multiplied by the coords at each boundary, that I already have as an input (practically it's the DefGrad that I already have from an upper-scale model analysis using Abaqus).\n\n\nYes, use the Global Strain system or the Homogenization system.\n\n\nI have seen in the examples/tutorials several J2 plasticity problems for 3D, but I guess there is no problem for the plane stress case, right??\n\n\nWe typically impose plane stress conditions weakly. Check out the Weak Plane Stress system.\nThere is a search button at the top left corner of the homepage. If that doesn't lead you to where you want, check out this page: https://mooseframework.inl.gov/modules/tensor_mechanics/index.html",
                  "url": "https://github.com/idaholab/moose/discussions/22888#discussioncomment-4322780",
                  "updatedAt": "2022-12-06T12:43:29Z",
                  "publishedAt": "2022-12-06T12:43:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "writableCoupledValue with NodalUO",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "I am trying to use writableCoupledValue with a NodalUO. Below is an example code. In the input file, I set an auxvariable to an initial condition of 100 and have a simple NodalUO that should change all the values to 1(if I am using this correctly). Instead, the exodus file just shows that the aux variable stays at 100. My actual code has me changing a few variables at the beginning of a time step so that why I want to use the NodalUO.\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    elem_type = QUAD4\n  []\n[]\n\n[Problem]\n  kernel_coverage_check = false\n  material_coverage_check = false\n  solve = false\n[]\n\n[AuxVariables]\n  [change]\n    initial_condition = 100\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  dt = 1\n  num_steps = 2\n[]\n\n[UserObjects]\n  [change_var]\n    type = NodeUOWriteableTest\n    variable_to_change = change\n    execute_on = TIMESTEP_END\n    force_preaux = true\n  []\n[]\n[Outputs]\n  [exo]\n    type = Exodus\n    file_base = nodal_uo_test/file\n  []\n[]\n\n\n#include \"NodeUOWriteableTest.h\"\n\nregisterMooseObject(\"insectApp\", NodeUOWriteableTest);\n\nInputParameters\nNodeUOWriteableTest::validParams()\n{\n  InputParameters params = NodalUserObject::validParams();\n  params.addRequiredCoupledVar(\"variable_to_change\", \"\");\n\n  params.addClassDescription(\"\");\n  return params;\n}\n\nNodeUOWriteableTest::NodeUOWriteableTest(const InputParameters & parameters)\n  : NodalUserObject(parameters), _variable_to_change(writableCoupledValue(\"variable_to_change\"))\n{\n}\n\nvoid\nNodeUOWriteableTest::execute()\n{\n  _variable_to_change[_qp] = 1.0;\n}\n\n\n#pragma once\n\n#include \"MooseTypes.h\"\n#include \"NodalUserObject.h\"\n\n/**\n */\nclass NodeUOWriteableTest : public NodalUserObject\n{\npublic:\n  static InputParameters validParams();\n\n  NodeUOWriteableTest(const InputParameters & parameters);\n\n  virtual void initialize() override{};\n  virtual void execute() override;\n  virtual void finalize() override{};\n  virtual void threadJoin(const UserObject & /* uo*/) override{};\n  virtual void initialSetup() override{};\n\nprivate:\n  VariableValue & _variable_to_change;\n};",
          "url": "https://github.com/idaholab/moose/discussions/22875",
          "updatedAt": "2022-12-05T21:02:16Z",
          "publishedAt": "2022-12-05T16:26:23Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Hm, looks like that API function is only tested from within an AuxKernel, not wuthin a NodalUO (where it would make a ton of sense!)",
                  "url": "https://github.com/idaholab/moose/discussions/22875#discussioncomment-4315026",
                  "updatedAt": "2022-12-05T16:32:47Z",
                  "publishedAt": "2022-12-05T16:32:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "My guess would be that the AuxSystem solution vector is not properly closed in or after the NodalUO loop.",
                          "url": "https://github.com/idaholab/moose/discussions/22875#discussioncomment-4315036",
                          "updatedAt": "2022-12-05T16:33:37Z",
                          "publishedAt": "2022-12-05T16:33:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Good to know, so there might a simple stopgap of closing the AuxSystem solution vector in finalize(). I prefer not to have to move this into an auxkernel. I'll see if I find anything.",
                          "url": "https://github.com/idaholab/moose/discussions/22875#discussioncomment-4315063",
                          "updatedAt": "2022-12-05T16:36:19Z",
                          "publishedAt": "2022-12-05T16:36:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "You'll need to do something like this: https://github.com/idaholab/moose/blob/next/framework/src/loops/ComputeNodalAuxVarsThread.C#L105-L110\nwhich will require compiling a list of aux variables that can be written to.",
                          "url": "https://github.com/idaholab/moose/discussions/22875#discussioncomment-4317050",
                          "updatedAt": "2022-12-05T20:51:27Z",
                          "publishedAt": "2022-12-05T20:51:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Thanks for finding that snippet!\nI may directly change the values in the solution vector. For my use case, I need to change the \"old\" values of variables.  In ElementSubdomainModifier::setOldAndOlderSolutionsForMovedNodes it shows how an ElementUO can change the old values by directly modifying the entire solution vector. I created a member in Coupleable called writableCoupledValueOld, hoping it would work out of the box for variables, not just auxvariables. If you can think of any other way to change \"old\" values of variables let me know, but for the purpose of this discussion post, I will mark it answered.",
                          "url": "https://github.com/idaholab/moose/discussions/22875#discussioncomment-4317130",
                          "updatedAt": "2022-12-05T21:02:13Z",
                          "publishedAt": "2022-12-05T21:02:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Displaced qp coordinates available in a material? (specific to AbaqusUMATStress)",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "In AbaqusUMATStress, the coordinates of the quadrature points on the undisplaced mesh are passed in here. To match Abaqus, these would need to be the coordinates on the displaced mesh. Is this information available in this particular Material? Maybe the displacements (interpolated to the qp) can be determined based on other available quantities?\n@dschwen @recuero @GiudGiud",
          "url": "https://github.com/idaholab/moose/discussions/22835",
          "updatedAt": "2023-01-03T23:55:07Z",
          "publishedAt": "2022-11-30T21:14:55Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Dumb question, use_displaced_mesh = true doesn't work here, does it?",
                  "url": "https://github.com/idaholab/moose/discussions/22835#discussioncomment-4278844",
                  "updatedAt": "2022-11-30T23:56:34Z",
                  "publishedAt": "2022-11-30T23:56:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if it doesnt, displacements are easy to get from\nparams.addRequiredCoupledVar(\"displacements\", \"disp variables\");\n\n_disp(coupledValues(\"displacements\")),\n\nthen you can displace or un-displace at will\nBut it should work (and if not, I m curious where I am wrong below).\nThe way it happens is: use_displaced_mesh is set to true in the material params\nthe FEProblem sees this and sets the material's problem as the displacedProblem\n  if (_displaced_problem && parameters.get<bool>(\"use_displaced_mesh\"))\n  {\n    parameters.set<SubProblem *>(\"_subproblem\") = _displaced_problem.get();\n    _reinit_displaced_elem = true;\n  }\n\nthe displacedProblem holds a displaced system. The displaced system holds the assembly.\nThe q_points are retrieved from the assembly through a FEBase then a FEMap which ultimately gets it from the mesh.\nThe mesh is the displaced mesh as the displaced system gets the mesh from the displaced problem.\n/* end deep dive, I was curious */",
                          "url": "https://github.com/idaholab/moose/discussions/22835#discussioncomment-4279185",
                          "updatedAt": "2022-12-01T01:00:00Z",
                          "publishedAt": "2022-12-01T00:59:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "@hugary1995 Wish it were that easy, but no dice.\n*** ERROR ***\nThe parameter 'Materials/umat/use_displaced_mesh' is a private parameter and should not be used in an input file.\n\nLet me try what @GiudGiud suggested.",
                          "url": "https://github.com/idaholab/moose/discussions/22835#discussioncomment-4283321",
                          "updatedAt": "2022-12-01T13:24:32Z",
                          "publishedAt": "2022-12-01T13:23:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "We probably should unsuppress the use_displaced_mesh parameter in AbaqusUMATStress. @dschwen @recuero what do you think?",
                          "url": "https://github.com/idaholab/moose/discussions/22835#discussioncomment-4283390",
                          "updatedAt": "2022-12-01T13:34:02Z",
                          "publishedAt": "2022-12-01T13:34:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Looks like it's suppressed in ComputeStressBase, which AbaqusUMATStress inherits from, which throws an error if set.\n  if (getParam<bool>(\"use_displaced_mesh\"))                                                                                                                                                    \n    mooseError(\"The stress calculator needs to run on the undisplaced mesh.\");\n\nNot sure if that's supposed to be carried to derived classes.",
                          "url": "https://github.com/idaholab/moose/discussions/22835#discussioncomment-4283498",
                          "updatedAt": "2022-12-01T13:47:28Z",
                          "publishedAt": "2022-12-01T13:47:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Going with @GiudGiud 's first suggestion. Will submit a PR...",
                          "url": "https://github.com/idaholab/moose/discussions/22835#discussioncomment-4316384",
                          "updatedAt": "2022-12-05T19:13:06Z",
                          "publishedAt": "2022-12-05T19:13:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I believe that should work. May need to regold some tests.",
                          "url": "https://github.com/idaholab/moose/discussions/22835#discussioncomment-4316410",
                          "updatedAt": "2022-12-05T19:18:16Z",
                          "publishedAt": "2022-12-05T19:18:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "minor questions",
          "author": {
            "login": "Oops-Qiao"
          },
          "bodyText": "Hi colleagues,\nI have 2 minor questions regarding the kernel in moose\nhttps://github.com/idaholab/moose/blob/next/modules/porous_flow/src/kernels/PorousFlowAdvectiveFlux.C\n\nwhere is the pressure gradient term in this kernal since I see this kernel is developed for this term with the link https://mooseframework.inl.gov/falcon/source/kernels/PorousFlowAdvectiveFlux.html\nI always see the residual part in kernal starting with ::computeQpResidual().\nHowever, in this kernal mentioned above, it uses\nPorousFlowAdvectiveFlux::mobility\nDoes this mean that we can change the name after :: ?\n\nThank you\nJerry",
          "url": "https://github.com/idaholab/moose/discussions/22876",
          "updatedAt": "2022-12-06T08:31:22Z",
          "publishedAt": "2022-12-05T16:49:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Oops-Qiao"
                  },
                  "bodyText": "@GiudGiud :)",
                  "url": "https://github.com/idaholab/moose/discussions/22876#discussioncomment-4315194",
                  "updatedAt": "2022-12-05T16:51:07Z",
                  "publishedAt": "2022-12-05T16:51:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe pressure gradient is added by the base class\nhttps://github.com/idaholab/moose/blob/next/modules/porous_flow/src/kernels/PorousFlowDarcyBase.C\nWe can't change the name after ::, but the computeQpResidual is implemented in the base class, then it may call routines such as mobility() etc that are defined in the derived classes\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22876#discussioncomment-4315781",
                  "updatedAt": "2022-12-05T17:58:40Z",
                  "publishedAt": "2022-12-05T17:58:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Hello\nThe pressure gradient is added by the base class https://github.com/idaholab/moose/blob/next/modules/porous_flow/src/kernels/PorousFlowDarcyBase.C\nWe can't change the name after ::, but the computeQpResidual is implemented in the base class, then it may call routines such as mobility() etc that are defined in the derived classes\nGuillaume\n\nHi Guillaume,\nThanks a lot for your answer. However, if we take look at the base class, line 510\nhttps://github.com/idaholab/moose/blob/next/modules/porous_flow/src/kernels/PorousFlowDarcyBase.C, there is another definition for mobility.\nPorousFlowDarcyBase::mobility(unsigned nodenum, unsigned phase) const\n{\nreturn _fluid_density_node[nodenum][phase] / _fluid_viscosity[nodenum][phase];\n}\nSo I am wondering how do you identify the mobility used in the base class is from the other rountines.\nlike PorousFlowAdvectiveFlux::mobility, line 40.\nhttps://github.com/idaholab/moose/blob/next/modules/porous_flow/src/kernels/PorousFlowAdvectiveFlux.C#L40\nThank you again.\nJerry",
                          "url": "https://github.com/idaholab/moose/discussions/22876#discussioncomment-4316307",
                          "updatedAt": "2022-12-05T19:02:53Z",
                          "publishedAt": "2022-12-05T19:02:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The derived class definition always takes precedence over the base class implementation, even in calls to mobility() from routines in the main class.\nThe only way to access the main class's definition (when it s overriden by a derived class) is to explicitly call\nPorousFlowDarcyBase::mobility() instead of mobility()",
                          "url": "https://github.com/idaholab/moose/discussions/22876#discussioncomment-4316351",
                          "updatedAt": "2022-12-05T19:08:23Z",
                          "publishedAt": "2022-12-05T19:08:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}