{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMS0wNVQwMToxNjowNS0wNjowMM4AN8iF"
    },
    "edges": [
      {
        "node": {
          "title": "Summation of Element",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Hello, I have a question about built-in Kernel or Postprocessor in MOOSE.\nI want to sum values stored (assigned) in all Elements.\nIs there any proper Kernel or Postprocessor (or AuxKernel? ) for this?\nI tried to find an appropriate one through Syntax, however I didn't know which one is right for me.\nThanks!\nSincerely,\nHokon Kim",
          "url": "https://github.com/idaholab/moose/discussions/19274",
          "updatedAt": "2022-06-14T06:58:51Z",
          "publishedAt": "2021-11-02T11:47:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you want a sum with no quadrature? Like not an integration? I m afraid we don't have that already in the framework.\nA sum would be a single value, so it would be a postprocessor.\nIf all your elements are the same shape you can use an ElementIntegralVariablePostprocessor since the integral and the sum are the same\nhttps://mooseframework.inl.gov/source/postprocessors/ElementIntegralVariablePostprocessor.html\nIf all your elements have the same number of nodes, you can use a NodalSum, as this does not do an integration, just sums the values on each node, which for the right type of variable will just be equal to the element value. Then you can divide the result by the number of nodes per element.\nWe would absolutely support it if you wanted to add an ElementSum post processor to the framework.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1576815",
                  "updatedAt": "2022-06-14T06:59:00Z",
                  "publishedAt": "2021-11-02T15:19:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "For example, above image is the 3D microstructure that had Elements(colored as Black points).\n(I do not know how many elements or nodes exists, how could I know this?)\nI just want to sum values(colored as red) on black points at each (time) step.\n-> I didn't give all numbers on black points, but values are assigned on all Elements\nIs it possible to compute this summation?",
                          "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1576983",
                          "updatedAt": "2022-06-14T06:59:01Z",
                          "publishedAt": "2021-11-02T15:37:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "number of elements and nodes is output at code startup / you can know it from the mesh using a viewer\nno not as a summation unless you are in one of the special cases I mentioned.\nYou d need to write a new post processor if not",
                          "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1577184",
                          "updatedAt": "2022-06-14T06:59:26Z",
                          "publishedAt": "2021-11-02T16:09:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Here is the mesh information that I used recently.\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          3\n  Spatial Dimension:       3\n  Nodes:                   \n    Total:                 1021076\n    Local:                 9296\n  Elems:                   \n    Total:                 5708148\n    Local:                 47605\n  Num Subdomains:          4\n  Num Partitions:          120\n  Partitioner:             metis\n\nI think I need to write a new post-processor for what I want.\nWhat am I supposed to do?\nThanks for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1577627",
                          "updatedAt": "2022-06-14T06:59:25Z",
                          "publishedAt": "2021-11-02T17:23:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would start from ElementIntegralVariablePP (so copy it to ElementSum, then modify it)\nand instead of summing on the quadrature with weights, I would only sum if qp = 0 with a weight of 1",
                          "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1577687",
                          "updatedAt": "2022-07-05T06:11:22Z",
                          "publishedAt": "2021-11-02T17:34:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "So, you mean I need to write a new Post-Processor like I made Custom kernels or interfacekernels for my application.\nAlso, it would be good to start from copying ElementsIntegralVariablePP as ElementSum(Custom Post processor for my application).\nAm I right on track?",
                          "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1577752",
                          "updatedAt": "2022-07-05T06:11:22Z",
                          "publishedAt": "2021-11-02T17:47:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes on both counts",
                          "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1577760",
                          "updatedAt": "2022-07-05T06:11:22Z",
                          "publishedAt": "2021-11-02T17:49:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "once you've created it I d be down to have it in the framework, not just in your app though",
                          "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1577768",
                          "updatedAt": "2022-07-05T06:12:42Z",
                          "publishedAt": "2021-11-02T17:49:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "I copied and pasted the ElementIntegralVariablePP.C and ElementIntegralVariablePP.h from MOOSE framework PP folder.\nand replace ElementIntegralVariablePP with ElementSumPP.\nBut, still I have no idea about implementing this part \"instead of summing on the quadrature with weights, I would only sum if qp = 0 with a weight of 1\" below.\nReal\nElementSumPostprocessor::computeQpIntegral()\n{\n  return _u[_qp];\n}\n\nElementSumPostprocessor.zip",
                          "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1577935",
                          "updatedAt": "2022-07-05T06:12:42Z",
                          "publishedAt": "2021-11-02T18:15:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the weight isn't in computeQpIntegral it s in computeIntegral I think\nIn computeQpIntegral, for selecting a Qp, you can just have:\nif _qp == 0\nreturn _u[_qp];\nelse\nreturn 0\nNote that I am assuming that the variable is constant over ELEMENTS and that you want one value per element.\nFrom your drawing it looks like you want a NodalSum ??",
                          "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1577950",
                          "updatedAt": "2022-07-05T06:12:43Z",
                          "publishedAt": "2021-11-02T18:19:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Okay, I think I need to give you more detail.\nwhat I want is to sum values in Elements (specifically, \"Auxiliary variable\", not \"Variable\").\nDepending on summation, I would control the \"Material property\" gradually.\nFor NodalSum that you commented previously, my mesh does not have equal numbers for Node and Element.\n(If all your elements have the same number of nodes, you can use a NodalSum)\nSo, I considered writing the new PP like you said to me.\nReal\nElementSumPostprocessor::computeQpIntegral()\n{\n  if _qp == 0{\n    return _u[_qp];\n  }\n  else{\n    return 0;\n  }\n}",
                          "url": "https://github.com/idaholab/moose/discussions/19274#discussioncomment-1578025",
                          "updatedAt": "2022-07-05T06:12:45Z",
                          "publishedAt": "2021-11-02T18:32:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to split a input.i file into seperate parts for better mangement?",
          "author": {
            "login": "ZhigangPu"
          },
          "bodyText": "Dear,\nAs my project grows larger, my input file has hundreds of lines.  It becomes more and more complicated to manage.\nI wonder is there any way to split a input file into some smaller input file containing different parts? Then we can \"include\" different parts into a \"main\" input file to assemble them together. I think that is a good way to manage larger projects.\nThanks\nzhigang",
          "url": "https://github.com/idaholab/moose/discussions/19306",
          "updatedAt": "2024-06-01T22:22:56Z",
          "publishedAt": "2021-11-06T07:23:40Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "This is currently a work in progress. See #9755 for more information.\nYou can also use the Action System (see https://mooseframework.inl.gov/source/actions/Action.html; sorry the documentation isn't very useful at the moment) to systematically build objects from more simplified input.",
                  "url": "https://github.com/idaholab/moose/discussions/19306#discussioncomment-1599553",
                  "updatedAt": "2024-06-01T22:22:56Z",
                  "publishedAt": "2021-11-06T15:37:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "includes are still a WIP.\nActions are a great idea for your application, to simplify the syntax for users.\nAnother option is to split the input file into multiple files and provide them on the command line like this:\n./my-app-opt -i file1.i file2.i ...\nthe files are then merged together",
                          "url": "https://github.com/idaholab/moose/discussions/19306#discussioncomment-1599682",
                          "updatedAt": "2024-06-01T22:23:16Z",
                          "publishedAt": "2021-11-06T16:29:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ZhigangPu"
                          },
                          "bodyText": "thanks very much! I'll try that!",
                          "url": "https://github.com/idaholab/moose/discussions/19306#discussioncomment-1601992",
                          "updatedAt": "2024-06-01T22:22:56Z",
                          "publishedAt": "2021-11-07T15:01:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "./my-app-opt -i file1.i file2.i ...\nthe files are then merged together\n\nHi @GiudGiud, so we can have a separated object for each file and run them together in a single line? for example ./my-app-opt -i mesh.i controls.i constraints.i ??\na quick note: @loganharbour @GiudGiud This 'include' would be very helpful for our workflow too, as each of our full-scale simulation objects (BCs, Materials, Controls) has more than 2000 lines, not to mention 100000+ lines from nodal constraints.\nCannot wait to see it :)\nThanks guys!\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/19306#discussioncomment-1603045",
                          "updatedAt": "2024-06-01T22:22:56Z",
                          "publishedAt": "2021-11-07T23:15:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@Traiwit as was discussed on the other post, 100k lines input is problematic. Please make sure to use an action or a different kind of constraint if you don't want to spend dozens of hours just parsing the input file at startup.\nI actually have not tried more than two input files merged. I ll try tomorrow.",
                          "url": "https://github.com/idaholab/moose/discussions/19306#discussioncomment-1603769",
                          "updatedAt": "2024-06-01T22:23:01Z",
                          "publishedAt": "2021-11-08T05:46:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yeah so it works to merge more than 2 inputs. Not sure why I couldnt remember that yesterday.",
                          "url": "https://github.com/idaholab/moose/discussions/19306#discussioncomment-1606591",
                          "updatedAt": "2024-06-01T22:23:06Z",
                          "publishedAt": "2021-11-08T15:18:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@GiudGiud Awesome! I tried that on my simulation and it works fine too, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/19306#discussioncomment-1609547",
                          "updatedAt": "2024-06-01T22:23:07Z",
                          "publishedAt": "2021-11-09T01:48:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error for output_centroids",
          "author": {
            "login": "KaijieNing"
          },
          "bodyText": "Hi,  everyone,\nI am trying to get the centroids of the grains by FeatureVolumeVectorPostprocessor. I followed the MOOSE instruction and added execute_on = 'timestep_begin' & output_centroids = true. But it did not work and showed the error as below.  How to solve it?\n[./grain_volumes]\ntype = FeatureVolumeVectorPostprocessor\nflood_counter = grain_center\nexecute_on = 'timestep_begin'\noutput_centroids = true\n[../]",
          "url": "https://github.com/idaholab/moose/discussions/17965",
          "updatedAt": "2023-02-17T11:37:08Z",
          "publishedAt": "2021-05-30T04:13:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "This could be a bug. The error indicates that the output you desire already exists. What input block is your snippet in: [Postprocessors] or [UsersObjects]?",
                  "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-811387",
                  "updatedAt": "2023-02-17T11:37:11Z",
                  "publishedAt": "2021-06-01T14:44:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KaijieNing"
                          },
                          "bodyText": "The input file that I modified was from (modules/phase_field/test/tests/rigidbodymotion/grain_motion.i).\nI tried either [Postprocessors] or [UsersObjects] but neither worked.\nWhat could be possible to get the output for Centroids? Thanks very much.\n[Postprocessors] #or [UserObjects]\n[./grain_center]\ntype = GrainTracker\nvariable = eta\noutputs = none\ncompute_var_to_feature_map = true\nexecute_on = 'timestep_begin'\n[../]\n[]\n[VectorPostprocessors]\n[./grain_volumes]\ntype = FeatureVolumeVectorPostprocessor\nflood_counter = grain_center\nexecute_on = 'timestep_begin'\noutput_centroids = true\n[../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-811518",
                          "updatedAt": "2023-12-19T17:47:38Z",
                          "publishedAt": "2021-06-01T15:08:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Can you provide a minimum input file that show the error?",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-816134",
                          "updatedAt": "2023-12-19T17:47:40Z",
                          "publishedAt": "2021-06-02T14:17:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KaijieNing"
                          },
                          "bodyText": "To keep it short, here is the input file for test purposes. You will need to enable PhaseField Module to run it.\nMany thanks.\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 25\n  ny = 15\n  nz = 0\n  xmax = 50\n  ymax = 25\n  zmax = 0\n  elem_type = QUAD4\n[]\n\n[Variables]\n  [./c]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./w]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./eta]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n[Kernels]\n  [./c_res]\n    type = SplitCHParsed\n    variable = c\n    f_name = F\n    kappa_name = kappa_c\n    w = w\n    args = eta\n  [../]\n  [./w_res]\n    type = SplitCHWRes\n    variable = w\n    mob_name = M\n  [../]\n  [./time]\n    type = CoupledTimeDerivative\n    variable = w\n    v = c\n  [../]\n\n  [./eta_dot]\n    type = TimeDerivative\n    variable = eta\n  [../]\n  [./acint_eta]\n    type = ACInterface\n    variable = eta\n    mob_name = M\n    args = c\n    kappa_name = kappa_eta\n  [../]\n  [./acbulk_eta]\n    type = AllenCahn\n    variable = eta\n    mob_name = M\n    f_name = F\n    args = c\n  [../]\n[]\n\n[Materials]\n  [./pfmobility]\n    type = GenericConstantMaterial\n    prop_names = 'M    kappa_c  kappa_eta'\n    prop_values = '5.0  2.0      0.1'\n  [../]\n  [./free_energy]\n    type = DerivativeParsedMaterial\n    args = 'c eta'\n    constant_names = 'barr_height  cv_eq'\n    constant_expressions = '0.1          1.0e-2'\n    function = 16*barr_height*(c-cv_eq)^2*(1-cv_eq-c)^2+(c-eta)^2\n    derivative_order = 2\n  [../]\n[]\n\n[Postprocessors]\n  [./grain_center]\n    type = GrainTracker\n    variable = eta\n    outputs = none\n    compute_var_to_feature_map = true\n    execute_on = 'timestep_begin'\n  [../]\n\n[]\n\n[VectorPostprocessors]\n  [./grain_volumes]\n    type = FeatureVolumeVectorPostprocessor\n    flood_counter = grain_center\n    execute_on = 'timestep_begin'\n    output_centroids = true\n  [../]\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  dt = 0.2\n  num_steps = 4\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n[ICs]\n  [./rect_c]\n    y2 = 20.0\n    y1 = 5.0\n    inside = 1.0\n    x2 = 30.0\n    variable = c\n    x1 = 10.0\n    type = BoundingBoxIC\n  [../]\n  [./rect_eta]\n    y2 = 20.0\n    y1 = 5.0\n    inside = 1.0\n    x2 = 30.0\n    variable = eta\n    x1 = 10.0\n    type = BoundingBoxIC\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-817356",
                          "updatedAt": "2023-02-17T11:37:16Z",
                          "publishedAt": "2021-06-02T18:20:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any news on this @aeslaughter @KaijieNing ?",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-977122",
                          "updatedAt": "2023-05-14T21:22:42Z",
                          "publishedAt": "2021-07-08T00:43:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "No. I need to try this out. I wonder if @permcody or @dschwen has an insight, since this if from the grain tracking system?",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-985690",
                          "updatedAt": "2023-05-14T21:22:42Z",
                          "publishedAt": "2021-07-09T14:57:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tonkmr"
                          },
                          "bodyText": "I am getting the same error and I have several projects that need to use this capability. Has anyone looked into it yet @aeslaughter @permcody @dschwen ?",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-1217019",
                          "updatedAt": "2023-05-14T21:22:42Z",
                          "publishedAt": "2021-08-21T18:10:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Yeah, clearly a bug. The declareVector(\"centroid_x\"); call is in FeatureVolumeVectorPostprocessor::execute() instead of in the constructor. That causes it to be redeclared over and over.",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-1217032",
                          "updatedAt": "2023-05-14T21:22:42Z",
                          "publishedAt": "2021-08-21T18:17:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Fix is up at #18672",
                  "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-1217098",
                  "updatedAt": "2023-05-14T21:22:42Z",
                  "publishedAt": "2021-08-21T18:55:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ykvishal"
                          },
                          "bodyText": "Is this working for anyone? I am getting following error:\n\n*** ERROR ***\nThe following error occurred in the object \"grain_volumes\", of type \"FeatureVolumeVectorPostprocessor\".\n\n\nWhile declaring a VectorPostprocessor value with the name \"centroid_x\",\na Reporter with the same name has already been declared.\n\n\nVectorPostprocessor \"grain_volumes/centroid_x\":\nType:\nstd::vector\nProducer:\nFeatureVolumeVectorPostprocessor \"grain_volumes\"\nContext type:\nReporterGeneralContext<std::vector >\nConsumer(s):\nNone\n\nI installed MOOSE last week and my input file is\ngrain_growth_2D_graintrackerwithCentroid.i.txt\nThank you.\nVishal",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-1607120",
                          "updatedAt": "2023-05-14T21:22:42Z",
                          "publishedAt": "2021-11-08T16:28:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KaijieNing"
                          },
                          "bodyText": "Your input file was good. I was able to run it and had all the outputs. Best.",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-1607311",
                          "updatedAt": "2023-05-14T21:22:52Z",
                          "publishedAt": "2021-11-08T16:59:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ykvishal"
                          },
                          "bodyText": "Thanks for the confirmation! Then something strange is happening my moose installation.",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-1607379",
                          "updatedAt": "2023-05-14T21:22:52Z",
                          "publishedAt": "2021-11-08T17:10:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KaijieNing"
                          },
                          "bodyText": "You can update your MOOSE and try it again.",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-1607551",
                          "updatedAt": "2023-05-14T21:22:52Z",
                          "publishedAt": "2021-11-08T17:39:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ykvishal"
                          },
                          "bodyText": "Yes, I installed MOOSE last week. However, I also added one old PR (related to grain growth initial condition) prior to make command, and it may have caused some problem. I will try again without this PR and see what happens. Thanks for the suggestion.",
                          "url": "https://github.com/idaholab/moose/discussions/17965#discussioncomment-1607617",
                          "updatedAt": "2023-05-14T21:22:53Z",
                          "publishedAt": "2021-11-08T17:47:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can MOOSE compute local volume of Element?",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Hello, I have a question about computing local volume of Element in MOOSE.\nIf possible, I'd like to compute local volume of Element and store the value.\nAre there proper ways to do this or any tips?\nI appreciate your help.\nSincerely,\nHokon Kim",
          "url": "https://github.com/idaholab/moose/discussions/19305",
          "updatedAt": "2022-11-07T05:23:39Z",
          "publishedAt": "2021-11-05T20:19:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "There's a few ways to do this - but funny enough, I have a need for this capability at the very moment. I'll put up a PR shortly with the object.",
                  "url": "https://github.com/idaholab/moose/discussions/19305#discussioncomment-1599589",
                  "updatedAt": "2022-11-07T05:23:40Z",
                  "publishedAt": "2021-11-06T15:52:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "It is provided as _current_elem_volume",
                  "url": "https://github.com/idaholab/moose/discussions/19305#discussioncomment-1599608",
                  "updatedAt": "2022-11-07T05:23:40Z",
                  "publishedAt": "2021-11-06T15:58:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "See #19308 for the new object.",
                  "url": "https://github.com/idaholab/moose/discussions/19305#discussioncomment-1599663",
                  "updatedAt": "2022-11-07T05:23:47Z",
                  "publishedAt": "2021-11-06T16:18:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "As far as I understand, \"VolumeAux\" is added (available) in the latest MOOSE framework.\nTo use this latest object, I need to update the MOOSE, right?\n(I'm using MOOSE on HPC, so I need a help from technical support team for update)",
                          "url": "https://github.com/idaholab/moose/discussions/19305#discussioncomment-1603006",
                          "updatedAt": "2022-11-07T05:23:49Z",
                          "publishedAt": "2021-11-07T22:52:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes you need to update MOOSE to have access to it. It's in since Saturday on the master branch",
                          "url": "https://github.com/idaholab/moose/discussions/19305#discussioncomment-1603783",
                          "updatedAt": "2022-11-07T05:23:51Z",
                          "publishedAt": "2021-11-08T05:49:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow - init stress when restarting",
          "author": {
            "login": "Nuriacor"
          },
          "bodyText": "Hi,\nI have a two step simulation with PorousFlow module. I first run my model in steady state and the restart the variables in a second stage to run transient conditions. As shown here (https://mooseframework.inl.gov/modules/porous_flow/restart.html)\nThe model is HM coupled, I'm restarting porepressure and the displacements. I notice that at the beginning (time zero) all variables are zero. Then, in the first time step, variables values are set, but the porepressure is not quite the same that in my steady state output, which generates unwanted dynamic at the beginning of my simulation.\nAfter modifying things for a while it came to my mind that my initial stress may be set wrong. For now I have set ComputeEigenstrainFromInitialStress with a function that depends on density and depth (as in this tutorial https://mooseframework.inl.gov/modules/porous_flow/coal_mining.html).\nIs the initial stress messing my transient simulation? Or is it something else?\nThanks in advance.\nNuria",
          "url": "https://github.com/idaholab/moose/discussions/19281",
          "updatedAt": "2022-10-24T22:20:35Z",
          "publishedAt": "2021-11-02T17:58:54Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Initial stress is a little more complicated than initial porepressure.  The first step of debugging this should be to remove the \"M\" coupling, and see if you can set the porepressure to exactly the steady-state value.  Eg, look at porous_flow/examples/flow_through_fractured_media/fine_thick_fracture_transient.i.  Don't simply assume everything has worked OK if the results look OK in paraview, since often porepressure equilibrates very quickly during the first step of your transient simulation.   Instead, actually check all the significant figures of porepressure somewhere, using, eg, a PointValue Postprocessor.\nThen we can get on to the stresses....\na",
                  "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1578609",
                  "updatedAt": "2022-10-24T22:20:41Z",
                  "publishedAt": "2021-11-02T20:33:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Nuriacor"
                          },
                          "bodyText": "Hi,\nThanks for your help. I did what you suggest, I also studied the fine_thick_fracture_transient.i example. But I could not debug my problem.\nThe H coupled model works fine, so the problem may come from the HM coupling. See test_H_steady.i and test_H_transient.i files.\nIn the HM model, the pressure difference between the transient and the steady solution is small, but increases significantly when I set different permeability in the layers. Please see test_HM_steady.i and test_HM_transient.i files.\nI also noticed that when I run the simulation in parallel the number of nonlinear and linear steps increases. At the point that is faster to run in only one core.\nhttps://github.com/Nuriacor/porousflow_tests\nThanks again!\nNuria",
                          "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1580700",
                          "updatedAt": "2022-10-24T22:20:42Z",
                          "publishedAt": "2021-11-03T08:54:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I'm up to my eyeballs in some other work, sorry for being so tardy in replying - i don't think i'll get to this today, but it seems as if something like the stress is not being set correctly, as you already know!",
                          "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1591164",
                          "updatedAt": "2023-02-09T14:48:21Z",
                          "publishedAt": "2021-11-04T20:44:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Oh, i just had a quick look.  You need to set your ini_stress_yy from the steady-state file.  You probably don't want to set the disp_x and disp_y from the steadystate file.",
                          "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1591180",
                          "updatedAt": "2023-02-09T14:48:38Z",
                          "publishedAt": "2021-11-04T20:47:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Nuriacor"
                          },
                          "bodyText": "Thanks!! So do I need to output the yy stress in the steady simulation and then imported in the transient and assign it to a function?",
                          "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1593647",
                          "updatedAt": "2023-02-09T14:48:38Z",
                          "publishedAt": "2021-11-05T08:53:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Yea, you need to transfer all the stress components (but prob the off-diagonal ones are all zero) into the transient simulation",
                          "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1602764",
                          "updatedAt": "2023-02-09T14:48:38Z",
                          "publishedAt": "2021-11-07T20:40:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Nuriacor"
                  },
                  "bodyText": "@WilkAndy I went around this with one single simulation file and using Controls to change the BCs. Thanks!\nI think that would be interesting to know why my simulation was behaving like that.\nCheers!",
                  "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1588150",
                  "updatedAt": "2023-02-09T14:48:57Z",
                  "publishedAt": "2021-11-04T12:02:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Nuriacor"
                          },
                          "bodyText": "And I am also curios to know why more cores increase the nonlinear steps.",
                          "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1588176",
                          "updatedAt": "2023-02-09T14:48:57Z",
                          "publishedAt": "2021-11-04T12:07:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "This is almost definitely because the linear solver is crappier.  You're choosing\n   petsc_options_iname = '-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap'\n    petsc_options_value = 'gmres      asm      lu           NONZERO                   2             '\n\nwhich will give the exact solution for 1 processor, but for many it'll only give an approximate solution to Ax=b.  Look at https://mooseframework.inl.gov/modules/porous_flow/solvers.html for some more choices.",
                          "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1591192",
                          "updatedAt": "2023-02-09T14:48:59Z",
                          "publishedAt": "2021-11-04T20:50:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @WilkAndy,\ni've been using Hypre / BoomerAMG for my full-scale hydro simulation (5m+ elements)\n\n    petsc_options_iname = '-pc_type -pc_hypre_type -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_agg_nl  -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_max_levels  -pc_hypre_boomeramg_coarsen_type   -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_P_max -pc_hypre_boomeramg_truncfactor'\n    petsc_options_value = 'hypre    boomeramg 0.7 4 5 25 HMIS  ext+i 2 0.3'\n\nany comment on this one? I find it's the fastest so far.",
                          "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1592707",
                          "updatedAt": "2023-02-09T14:49:12Z",
                          "publishedAt": "2021-11-05T04:24:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "looks good to me!  i've used hypre/boomeramg with good results.",
                          "url": "https://github.com/idaholab/moose/discussions/19281#discussioncomment-1592749",
                          "updatedAt": "2023-02-09T14:49:12Z",
                          "publishedAt": "2021-11-05T04:37:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mesh adaptivity problem for multi-scale grain growth simulation",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nRecently, I used the bulit-in grain growth model in moose to conduct multi-scale bicrystal simulation, where the grain size is 20\u03bcm and the grain boudary (GB) width is 15nm. The model mesh diagram at the time step 3 and 7 are as follow,\n\n\nHowever, we found that there are some problems with the subdivided grid after using the mesh adaptive technology. For example, the grid in the green box is finer than the grid in the bule box at the Time Step 3, as show in Fig.1. According to our understanding from the bicrystal grain growth simulation in the nanometer scale, the grid at the GB should be of uniform size. This problm is more obvious in the yellow box in Fig.2, and the change of gr0 at the GB is shown in the figure below,\n\nMoreover, this is the code for the mesh adaptivity technology I used,\n  [./Adaptivity]\n    initial_adaptivity = 7\n    cycles_per_step = 2 # The number of adaptivity cycles per step\n    refine_fraction = 0.5 # The fraction of elements or error to refine.\n    coarsen_fraction = 0.05\n    max_h_level = 10\n  [../]\nIn general, our question is why the grid adaptation is so strange in the process of GB migration. How to better use the mesh adaptive technology in moose to realize such a multi-scale grain growth simulation?\nAny suggestions or recommendations to fix the problem would be greatly appreciated.\nThank you\nWei",
          "url": "https://github.com/idaholab/moose/discussions/19275",
          "updatedAt": "2022-06-15T22:34:49Z",
          "publishedAt": "2021-11-02T13:06:15Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat did you use as the Indicator for this Adaptivity?\nThat will determine how refinement decisions are made.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19275#discussioncomment-1576674",
                  "updatedAt": "2022-06-15T22:34:55Z",
                  "publishedAt": "2021-11-02T15:04:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "I just referred to the mesh adaptivity part in grain_growth_2D_graintracker.i, and I did  not specify the Indicator and marker. So I don't know how the refinement is determined from the *.i file.\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/19275#discussioncomment-1579461",
                          "updatedAt": "2022-06-15T22:34:58Z",
                          "publishedAt": "2021-11-03T01:07:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think this is the default error estimator (eg indicator of where to refine)\nhttps://libmesh.github.io/doxygen/classlibMesh_1_1KellyErrorEstimator.html\nYou should look at these pages and choose the one you want to use:\nhttps://mooseframework.inl.gov/syntax/Adaptivity/Indicators/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/19275#discussioncomment-1579535",
                          "updatedAt": "2022-06-15T22:35:00Z",
                          "publishedAt": "2021-11-03T01:34:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Yeah, I modified my input file, GG_Custom_Indicators.i based on the webpage you shared and GrandPotentialPlanarGrowth.i. The code that contains the adaptation is as,\n[Adaptivity]\n initial_steps = ${my_number_adaptivity}\n max_h_level = ${my_number_adaptivity}\n initial_marker = err_eta\n marker = err_bnds\n[./Markers]\n   [./err_eta]\n     type = ErrorFractionMarker\n     coarsen = 0.3\n     refine = 0.5\n     indicator = ind_eta\n   [../]\n   [./err_bnds]\n     type = ErrorFractionMarker\n     coarsen = 0.3\n     refine = 0.5\n     indicator = ind_bnds\n   [../]\n [../]\n [./Indicators]\n   [./ind_eta]\n     type = GradientJumpIndicator\n     variable = gr0\n    [../]\n    [./ind_bnds]\n      type = GradientJumpIndicator\n      variable = bnds\n   [../]\n [../]\n[]\nIn addition, I also created the GG_default_adaptive.i using the default adaptive technolohy. The code that contains the adaptation is as follows,\n  [./Adaptivity]\n    initial_adaptivity = ${my_number_adaptivity} # 5\n    cycles_per_step = 2 # The number of adaptivity cycles per step\n    refine_fraction = 0.5 # The fraction of elements or error to refine.\n    coarsen_fraction = 0.05\n    max_h_level = 8\n  [../]\n[]\nThen, the mesh results of the two adaptive mesh setting are shown below,\n\nBy comparing the two adaptive grid methods, I think that the custom adaptive grid division (fig.1) is not as perfect as the default grid adaptive method (fig.2). Although the first calculation only took 4.29 minutes, the second calculation took 15.45 minutes. Moreover, the circular grian-time curve of the two simultion outputs is the same,\n\nSo my final question is how to modify my GG_Custom_Indicators.i to make the quality of the adaptive grid better without spending as much time as GG_default_adaptive.i.\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/19275#discussioncomment-1593190",
                          "updatedAt": "2022-06-15T22:34:56Z",
                          "publishedAt": "2021-11-05T07:15:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "are the number of elements similar in both runs?\nTo spend less time you usually want to limit the number of elements. So run less adaptivity steps and set a lower max refinement.\nYou will also want to turn on the perf_graph = true in Outputs to see what is actually using the simulation time.",
                          "url": "https://github.com/idaholab/moose/discussions/19275#discussioncomment-1595910",
                          "updatedAt": "2022-07-05T08:33:32Z",
                          "publishedAt": "2021-11-05T15:34:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "The number of grids initially set is the same, but the first uses bnds as indicators, and the second uses default indicators. However, the first mesh adaptive effect is not as good as the second one, so I would like to ask how to better set Indicators to improve the mesh quality after mesh adaptive division.",
                          "url": "https://github.com/idaholab/moose/discussions/19275#discussioncomment-1599004",
                          "updatedAt": "2022-07-05T08:33:33Z",
                          "publishedAt": "2021-11-06T11:49:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is very problem dependent.\nYou need to determine what you consider the \"error\" to be, and use that as a criteria for refinement.\nI was saying that the two refinement results dont seem to have the same number of elements, so that s where the runtime difference comes from. If you want the \"better\" refinement to be cheaper, you ll have to limit the number of levels / tune the parameters",
                          "url": "https://github.com/idaholab/moose/discussions/19275#discussioncomment-1599686",
                          "updatedAt": "2022-07-05T08:33:29Z",
                          "publishedAt": "2021-11-06T16:32:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "OK, Thank you for your timely response!\nPerhaps, I need to further modify my indicators block and control the number of elements within an acceptable range.",
                          "url": "https://github.com/idaholab/moose/discussions/19275#discussioncomment-1600628",
                          "updatedAt": "2022-07-05T08:33:30Z",
                          "publishedAt": "2021-11-07T02:09:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Contact modeling with mutiple surfaces",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I am running a simulation with contact modeling. I have defined motion for a single particle that may interact with one of 10 surfaces in time. I am getting the following error:\nERROR: negative Jacobian -3.29043e-24 at point (x,y,z)=(0.016665, 0.013855, 0.0204749) in element 33771\nStack frames: 37\nWhat should be my focus to help eliminate this particular error?",
          "url": "https://github.com/idaholab/moose/discussions/19304",
          "updatedAt": "2022-10-13T18:20:50Z",
          "publishedAt": "2021-11-05T18:29:43Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "The error points to an inverted element. It's not straightforward to know what best to do here without more information, this error can be caused by a multitude of issues. If you know your contact settings are good, I would try reducing the time step.",
                  "url": "https://github.com/idaholab/moose/discussions/19304#discussioncomment-1597389",
                  "updatedAt": "2022-10-13T18:20:50Z",
                  "publishedAt": "2021-11-05T21:06:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would also go look at that element at the beginning of the simulation and keep tracking it in the exodus output, see how its shape evolves. Maybe the starting shape is pretty skewed, maybe it looks fine then gets squished flat in contact\nthe Jacobian is really really small so I think it s likely to have been flattened",
                          "url": "https://github.com/idaholab/moose/discussions/19304#discussioncomment-1599702",
                          "updatedAt": "2022-10-13T18:20:50Z",
                          "publishedAt": "2021-11-06T16:41:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to output TimeDerivative value instead of output residual of it?",
          "author": {
            "login": "ZhigangPu"
          },
          "bodyText": "Dear,\nI wonder how to output time derivative like dx/dt instead of directly using the save_in parameter to output residual of the time derivative kernel?\nThanks\nzhigang",
          "url": "https://github.com/idaholab/moose/discussions/19292",
          "updatedAt": "2022-11-30T20:19:20Z",
          "publishedAt": "2021-11-04T04:03:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNot sure we have that somewhere. But you could use an auxkernel to save that in an auxvariable.\nJust use coupledDot routine.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19292#discussioncomment-1586232",
                  "updatedAt": "2023-02-27T23:33:46Z",
                  "publishedAt": "2021-11-04T04:41:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ZhigangPu"
                          },
                          "bodyText": "Thanks, I will try that.",
                          "url": "https://github.com/idaholab/moose/discussions/19292#discussioncomment-1598415",
                          "updatedAt": "2023-02-27T23:33:50Z",
                          "publishedAt": "2021-11-06T07:09:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "outputting flux (volume flux and mass flux) [PorousFlow]",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\njust wondering, is there a MOOSE object that can calculate flux within the domain?\nI see we have PorousFlowDarcyVelocityComponent which outputting the velocity via AuxVariable/AuxKernel\nhttps://mooseframework.inl.gov/source/auxkernels/PorousFlowDarcyVelocityComponent.html\nbut what about volume flux (m3/s) or mass flux (kg/s)? I'm aware that it might need to be calculated at the surfaces of each element since it has 'A' in its equation.\nDo I need to write my own kernel/object for this? but it's quite standard, I believe MOOSE must have it somewhere.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/19235",
          "updatedAt": "2022-07-29T01:52:42Z",
          "publishedAt": "2021-10-28T12:14:40Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I d use a VolumetricFlowRate from the Navier Stokes module for an external (to the variable) boundary\nhttps://mooseframework.inl.gov/source/postprocessors/VolumetricFlowRate.html\nFor an internal sideset\nhttps://mooseframework.inl.gov/source/postprocessors/InternalVolumetricFlowRate.html\nEDIT\nFor porous flow, does any of the postprocessors listed here work for you:\nhttps://mooseframework.inl.gov/modules/porous_flow/additional_objects.html\nseems https://mooseframework.inl.gov/source/postprocessors/PorousFlowPlotQuantity.html can measure fluxes\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19235#discussioncomment-1554366",
                  "updatedAt": "2022-07-29T01:52:48Z",
                  "publishedAt": "2021-10-28T17:19:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There s also a diffusive Flux posptrocessor. Depends on what fluxes you have.\nSince you are using porous flow, the porous flow postprocessors should be tried first",
                          "url": "https://github.com/idaholab/moose/discussions/19235#discussioncomment-1554369",
                          "updatedAt": "2022-07-29T01:53:00Z",
                          "publishedAt": "2021-10-28T17:20:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud,\nThank you for pointing out all these helpful objects.\nUnfortunately, they don't seem to be what I wanted, I think I need to discuss with my team further before proceeding on this.\nThe best bet right now is to take the Darcy vel at each element and multiply it by the average surface area of each element.\nI will get back if I have a better idea about this.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/19235#discussioncomment-1567178",
                          "updatedAt": "2022-07-29T01:53:00Z",
                          "publishedAt": "2021-10-31T23:11:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "It depends on the BC you're using on that boundary (if any: perhaps there are none because it's an internal boundary or because it's a no-flow boundary)\n\nif one of the PorousFlowSinks then you use a save_in to save the contribution to an AuxVariable, then a NodalSum to sum all the contributions.  There are examples of this in the test suite.\nOtherwise, you can probably use a PorousFlowOutflowBC and a save_in to record the flux.   I'm sorry that this is rather convoluted, and i've been meaning to address this for some time, but to record the flux you'll probably need two BCs of this type, one with multiplier = 1 and one with multiplier = -1.  That means the contributions to the residual will sum to zero (these BCs will actually \"do nothing\") but you can save_in for the multiplier = 1 version only, hence recording the flux.  Ugly.... sorry.\n\na",
                  "url": "https://github.com/idaholab/moose/discussions/19235#discussioncomment-1567214",
                  "updatedAt": "2022-07-25T02:35:30Z",
                  "publishedAt": "2021-10-31T23:24:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks @WilkAndy, yes I'm using one of PorousFlowSinks, I will give it a go.\nSo I should expect the results to be the total flux of the particular surface, right?\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/19235#discussioncomment-1567255",
                          "updatedAt": "2022-07-25T02:35:30Z",
                          "publishedAt": "2021-10-31T23:50:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Yes, that is correct.  The NodalSum will be the flux by definition.  Have a look at porous_flow/test/tests/sinks/PorousFlowPiecewiseLinearSink_BC_eg1.i for an example.",
                          "url": "https://github.com/idaholab/moose/discussions/19235#discussioncomment-1567363",
                          "updatedAt": "2022-07-25T02:35:44Z",
                          "publishedAt": "2021-11-01T00:53:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Nuriacor"
                          },
                          "bodyText": "@WilkAndy does InternalVolumetricFlowRate work in PorousFlow? If not, is there something similar?",
                          "url": "https://github.com/idaholab/moose/discussions/19235#discussioncomment-1596073",
                          "updatedAt": "2022-07-25T02:35:45Z",
                          "publishedAt": "2021-11-05T16:00:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Traveling Wave Solution for Double Obstacle Potential",
          "author": {
            "login": "Mascsu"
          },
          "bodyText": "Hello, everyone\nI want to use MOOSE to solve the phase-field model with double obstacle potential. The equations are as following:\n\nThe free energy density is defined by Eqs.(64) and (65), the governing equation is Eq.(66) and the parameters are expressed by Eq.(70) where eta, sigma, mu and delta_g are input parameters of materials. (The test values are eta = 6, sigma = mu = 1.0, delta_g = 0.05.)  The reference is from: https://iopscience.iop.org/article/10.1088/0965-0393/17/7/073001/pdf (I. Steinbach, Modell. Phase-field models in materials science. Modelling and Simulation in Materials Science and Engineering. 17(7) (2009) 073001.).\nI did not find a suitable built-in kernel to solve this problem. The built-in kernels in phase-field module used double well potential. I have tried to write the custom kernel for double obstacle potential:\n\nwrite a kernel inherited from \"ADTimeDerivative\" kernel to deal with the left-hand side in Eq.(66);\nwrite a kernel inherited from \"ADKernel\" kernel to deal with the first term in the right-hand side;\nwrite a kernel inherited from \"ADKernelValue\" kernel to deal with 2nd and 3rd terms in the right-hand side.\n\nIt did not work. However, I have used the same way to solve the equations with double well potential successfully.\nCould anyone help me solve this equation?\nThanks,\nSa Ma",
          "url": "https://github.com/idaholab/moose/discussions/19253",
          "updatedAt": "2022-06-18T06:12:15Z",
          "publishedAt": "2021-10-29T01:33:36Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nis there any way you could solve a simpler equation first, then build from there?\nLike what s pretty likely is that there is an issue with one of your kernels, and only by doing this progressively and verifying against known solutions can you know that everything's right.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1556661",
                  "updatedAt": "2022-06-18T06:12:17Z",
                  "publishedAt": "2021-10-29T04:28:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Mascsu"
                          },
                          "bodyText": "Hello\nThanks for your answer.\nI have tried to solve the equation with double well potential and it was successful. But when I used the same way to solve the equation with double obstacle potential, it failed. The only difference between these two equations is the local free energy.\nThis is the equation with double well potential:\n\nand this is the equation with double obstacle potential:\n\nSo, I want to know if any built-in kernel could handle the phase-field model with double obstacle potential. If there is no built-in kernel, could you give me some suggestions how to solve the equations.\nThank you,\nSa Ma",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1558026",
                          "updatedAt": "2022-06-18T06:12:18Z",
                          "publishedAt": "2021-10-29T09:59:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok I dont know the answer to that so we ll ping @laagesen.\nCan you try turning sqrt(phi ( 1 - phi) ) into sqrt(phi ( 1 - phi) + 1e-16) ? The singularity of the square root could be messing with AD",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1559770",
                          "updatedAt": "2022-06-18T06:12:18Z",
                          "publishedAt": "2021-10-29T15:36:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Mascsu"
                          },
                          "bodyText": "Thanks for your answer,. I have tried turning sqrt(phi ( 1 - phi) ) into sqrt(phi ( 1 - phi) + 1e-16), but it did not work.",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1568235",
                          "updatedAt": "2022-06-18T22:09:05Z",
                          "publishedAt": "2021-11-01T07:40:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hi Sa Ma - the double obstacle potential is difficult to implement using any code that uses an implicit solution method, including MOOSE. The reason is that most implementation use a free energy that shoots up to infinity outside the range 0 < phi < 1. This huge discontinuity in the free energy makes it very difficult to solve with an implicit method. As far as I know, all codes that use this formulation are explicit codes. MOOSE does have the capability to solve time steps explicitly, but to be totally honest it is not that well suited to phase-field models with the double obstacle potential. That is one of the reasons why we don't have any kernels/materials in the framework for this problem.\nWhat is the physical problem you are interested in? We have alternative formulations that may be able to accomplish what you want to do already implemented.",
                  "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1560076",
                  "updatedAt": "2022-06-18T22:09:05Z",
                  "publishedAt": "2021-10-29T16:33:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There's an explicit time integrator in MOOSE.\nhttps://mooseframework.inl.gov/source/timeintegrators/ActuallyExplicitEuler.html\nbut maybe it doesnt work with phase field?",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1561337",
                          "updatedAt": "2022-06-18T22:09:15Z",
                          "publishedAt": "2021-10-29T21:45:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "It probably does work, but no one has tried it for phase-field that I know of. The problem is that the stability limit for explicit time steps will prevent you from taking large time steps, so the problem will run slowly. Most phase-field problems are much better suited to implicit time integration schemes, but the double obstacle potential is an exception.\nIf others have tried the explicit time integrator on phase-field problems, please chime in.",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1561367",
                          "updatedAt": "2022-06-18T22:09:15Z",
                          "publishedAt": "2021-10-29T21:57:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Mascsu"
                          },
                          "bodyText": "Hello, thanks for your answer!\nI want to solve the phase-field model with finite interface dissipation. Different from kks model, this model could deal with the non-equilibrium phase transition. In the model, the double obstacle potential is used. Here is the website of the paper: https://www.sciencedirect.com/science/article/pii/S1359645412000730.\nMaybe I have two ways to deal with the problem.\n(I) I can replace the origin double obstacle potential with the double well poential and re-derive the phase-field model. But I am not sure whether the implicit algorithm could successfully solve the compostion field equation, which includes strongly non-linear terms. The equations are as following\n\n(II) I can try the explicit time integrator. I have used the finite difference method (FDM) to solve the phase-field model with double obstacle potential. I need to cutoff the unphysical value (if phi < 0, make phi = 0; else if phi >1, make phi = 1) when I use the FDM. I am not sure how to make sure the value of phi always between 0 and 1 in MOOOSE framework.\nThanks,\nSa Ma",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1568318",
                          "updatedAt": "2022-06-18T22:09:18Z",
                          "publishedAt": "2021-11-01T08:06:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nFor (II) you can use the Bounds or the Dampers system to keep the value between 0 and 1\nhttps://mooseframework.inl.gov/source/auxkernels/ConstantBoundsAux.html\nhttps://mooseframework.inl.gov/source/dampers/BoundingValueElementDamper.html\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1570697",
                          "updatedAt": "2023-04-13T03:18:43Z",
                          "publishedAt": "2021-11-01T14:55:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "I'd recommend starting with the Bounds system, some people have used this for phase-field fracture modeling with success. Please let us know how it goes! You may not need explicit time stepping if you can use Bounds successfully.",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1571830",
                          "updatedAt": "2022-08-26T20:59:56Z",
                          "publishedAt": "2021-11-01T18:24:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Mascsu"
                          },
                          "bodyText": "Thanks for your answers!\nI have used the Bounds system (ConstantBoundsAux) and implicit time stepping, and the results agree well with the analytical solution.",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1574461",
                          "updatedAt": "2022-08-26T20:59:56Z",
                          "publishedAt": "2021-11-02T08:08:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Very interesting, and thanks for letting us know! Tagging @dschwen FYI",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1576444",
                          "updatedAt": "2022-08-26T20:59:56Z",
                          "publishedAt": "2021-11-02T14:27:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Good to know. It would be really cool if you could contribute your code back. It would make a great example for the use of the double obstacle potential together with the bounds system. We can help you get everything in shape if you make a pull request.",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1576592",
                          "updatedAt": "2022-08-26T20:59:56Z",
                          "publishedAt": "2021-11-02T14:51:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Mascsu"
                          },
                          "bodyText": "I have made a pull request. Next, I will try to solve the phase-field model with finite interface dissipation.\nhttps://www.sciencedirect.com/science/article/pii/S1359645412000730.",
                          "url": "https://github.com/idaholab/moose/discussions/19253#discussioncomment-1593192",
                          "updatedAt": "2022-08-26T20:59:56Z",
                          "publishedAt": "2021-11-05T07:16:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}