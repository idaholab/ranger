{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wMy0xN1QxMjo0NDo0NC0wNjowMM4AI_eL"
    },
    "edges": [
      {
        "node": {
          "title": "Access information on failed time step in Predictor class",
          "author": {
            "login": "matthiasneuner"
          },
          "bodyText": "Predictors like SimplePredictor are a great tools for increasing the simulation speed.\nHowever, in certain situations it should be possible to omit a prediction.\nFor instance, if a time step is reduced according to a request by a material model (e.g., plasticity requires a smaller time step),\nno prediction should be made in the new, reduced time step. Currently, the prediction is also applied in the new, reduced time step. If the direction of the prediction is not reasonable, this can be the death of a simulation since it may result in an (infinite) request of smaller time steps by the material.\nI was looking for a possibility to request information within the Predictor class wether the current time step is a repeated time step or not. However, I could find nothing helpful.\nIs there any possibility get information about a potential repetition of a time step?\nThank you and best regards, Matthias",
          "url": "https://github.com/idaholab/moose/discussions/16628",
          "updatedAt": "2022-10-04T22:10:47Z",
          "publishedAt": "2021-01-07T14:06:33Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad Do you have any insight on this?",
                  "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-267268",
                  "updatedAt": "2023-01-07T17:45:04Z",
                  "publishedAt": "2021-01-07T15:51:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "Have you actually verified that the predictor is run again?  I could have sworn that we just left the (partially solved) solution there from the previous attempt (because that sometimes actually works as a \"predictor\" for the failed step).\nWhat you might be seeing is actually the opposite of this: the predictor may need to be run after the failed step (but with the new timestep).",
                  "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-267831",
                  "updatedAt": "2023-01-07T17:45:04Z",
                  "publishedAt": "2021-01-07T20:52:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "matthiasneuner"
                          },
                          "bodyText": "Good question! I definitively observe some kind of endless loop of smaller time step requests caused by some invalid initial guesses. I will verify the actual cause of the invalid guesses. If the origin is the partially solved guess, is there any possibility to deactivate this feature?",
                          "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-268424",
                          "updatedAt": "2023-01-07T17:45:04Z",
                          "publishedAt": "2021-01-08T06:02:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "matthiasneuner"
                  },
                  "bodyText": "Hello, so the predictor is definitely called directly in the cut back time step.\nI verified it by making a dummy material which constantly requests a smaller time step ( if _t - _dt > 0.5 )\n(Please ignore the designation MarmotMaterial, this is not related to the MOOSE application MARMOT.)\nAs you can see, also in the reduced time steps the SimplePredictor is called, as indicated by the message 'Applying predictor with scale factor = 1':\nTime Step 5, time = 0.5, dt = 0.1                                                                                                                                                                                                                      \n  Applying predictor with scale factor = 1                                                                                                                                                                                                             \n 0 Nonlinear |R| = 1.009537e-08                                                                                                                                                                                                                        \n  Linear solve converged due to CONVERGED_RTOL iterations 35                                                                                                                                                                                           \n 1 Nonlinear |R| = 7.100492e-11                                                                                                                                                                                                                        \nNonlinear solve converged due to CONVERGED_FNORM_ABS iterations 1                                                                                                                                                                                      \n Solve Converged!                                                                                                                                                                                                                                      \n                                                                                                                                                                                                                                                       \nPostprocessor Values:                                                                                                                                                                                                                                  \n+----------------+----------------+                                                                                                                                                                                                                    \n| time           | bot_react_y    |                                                                                                                                                                                                                    \n+----------------+----------------+                                                                                                                                                                                                                    \n|   0.000000e+00 |   0.000000e+00 |                                                                                                                                                                                                                    \n|   1.000000e-01 |  -2.184054e+01 |                                                                                                                                                                                                                    \n|   2.000000e-01 |  -4.368110e+01 |                                                                                                                                                                                                                    \n|   3.000000e-01 |  -6.552164e+01 |                                                                                                                                                                                                                    \n|   4.000000e-01 |  -8.736219e+01 |                                                                                                                                                                                                                    \n|   5.000000e-01 |  -1.092027e+02 |                                                                                                                                                                                                                    \n+----------------+----------------+                                                                                                                                                                                                                    \n                                                                                                                                                                                                                                                       \n                                                                                                                                                                                                                                                       \nTime Step 6, time = 0.6, dt = 0.1                                                                                                                                                                                                                      \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \ninducing failure                                                                                                                                                                                                                                       \n0 0 0 0 0 0                                                                                                                                                                                                                                            \n  Applying predictor with scale factor = 1                                                                                                                                                                                                             \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \nNonlinear solve did not converge due to DIVERGED_FUNCTION_DOMAIN iterations 0                                                                                                                                                                          \ninducing failure                                                                                                                                                                                                                                       \n1.91342e-05 -4.67289e-06 -4.82314e-06 1.8302e-06 -7.0505e-09 8.8664e-09                                                                                                                                                                                \n Solve Did NOT Converge!                                                                                                                                                                                                                               \nAborting as solve did not converge                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                       \nSolve failed, cutting timestep.                                                                                                                                                                                                                        \n                                                                                                                                                                                                                                                       \nTime Step 6, time = 0.55, dt = 0.05                                                                                                                                                                                                                    \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \ninducing failure                                                                                                                                                                                                                                       \n0 0 0 0 0 0                                                                                                                                                                                                                                            \n  Applying predictor with scale factor = 1                                                                                                                                                                                                             \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \nNonlinear solve did not converge due to DIVERGED_FUNCTION_DOMAIN iterations 0                                                                                                                                                                          \ninducing failure                                                                                                                                                                                                                                       \n9.56711e-06 -2.33644e-06 -2.41157e-06 9.15099e-07 -3.52525e-09 4.4332e-09                                                                                                                                                                              \n Solve Did NOT Converge!                                                                                                                                                                                                                               \nAborting as solve did not converge                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                       \nSolve failed, cutting timestep.                                                                                                                                                                                                                        \n                                                                                                                                                                                                                                                       \nTime Step 6, time = 0.525, dt = 0.025                                                                                                                                                                                                                  \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \ninducing failure                                                                                                                                                                                                                                       \n0 0 0 0 0 0                                                                                                                                                                                                                                            \n  Applying predictor with scale factor = 1                                                                                                                                                                                                             \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \nNonlinear solve did not converge due to DIVERGED_FUNCTION_DOMAIN iterations 0                                                                                                                                                                          \ninducing failure                                                                                                                                                                                                                                       \n9.56711e-06 -2.33644e-06 -2.41157e-06 9.15099e-07 -3.52525e-09 4.4332e-09                                                                                                                                                                              \n Solve Did NOT Converge!                                     \nAborting as solve did not converge                           \n\nThe 6 numerical numbers are the strain increment.\nWhat I am currently wondering about is the zero strain increment, which means that the material is evaluated always with a zero strain increment before the predictor comes into play. Accordingly, the material throws 2(!) exceptions before the time step is cut back.",
                  "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-283595",
                  "updatedAt": "2023-01-07T17:45:04Z",
                  "publishedAt": "2021-01-15T06:25:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Is this solved?",
                  "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-494169",
                  "updatedAt": "2023-12-11T23:54:01Z",
                  "publishedAt": "2021-03-17T15:05:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Looking in Predictor.C, there is a parameter called skip_after_failed_timestep. This defaults to false, but it sounds like you should set this to true in your Predictor input file block. I believe this is what you were looking for?",
                  "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-495919",
                  "updatedAt": "2023-12-11T23:54:01Z",
                  "publishedAt": "2021-03-17T21:59:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "matthiasneuner"
                          },
                          "bodyText": "Yes, this one was implemented by me after opening this thread ;-) .",
                          "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-496805",
                          "updatedAt": "2023-12-11T23:54:05Z",
                          "publishedAt": "2021-03-18T06:10:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Haha excellent!",
                          "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-498880",
                          "updatedAt": "2023-12-11T23:54:06Z",
                          "publishedAt": "2021-03-18T15:07:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Linear decomposition of displacement field in computational homogenization",
          "author": {
            "login": "tairoon1"
          },
          "bodyText": "Hi everyone,\nIn first-order computational homogenization, the displacement is typically decomposed into a mean field u_bar and a fluctuation field w(X), i.e.\nu(X) = u_bar(X) + w(X).\nu_bar is actually fully defined everywhere on the domain with u_bar = (F_bar-I) X, where F_bar is given and I is the identity matrix, and w(X) is periodic on the boundaries. So, one is interested in finding the fluctuation field w(X).\nIs it possible to do that inside TensorMechanics module and if yes, how would one write the Input file to do that?\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/17369",
          "updatedAt": "2022-06-11T17:11:58Z",
          "publishedAt": "2021-03-18T11:24:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @tairoon1\nI don't think such homogenisation method is already implemented in moose,\nbut it can definitely be implemented by solving for two independent variables u and w.\nSomething similar has been done in this repository:\nhttps://github.com/lanl/tardigrade-micromorphic-element\nBest Regards,\nNicol\u00f2 Grilli",
                  "url": "https://github.com/idaholab/moose/discussions/17369#discussioncomment-498230",
                  "updatedAt": "2022-06-11T17:11:58Z",
                  "publishedAt": "2021-03-18T13:20:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "Dear Nicol\u00f2,\nThanks for your quick reply. So does that mean, it is not yet possible to use MOOSE for such application? Are there any plans to support such a feature in the future?\nBest regards",
                          "url": "https://github.com/idaholab/moose/discussions/17369#discussioncomment-498758",
                          "updatedAt": "2022-06-11T17:12:19Z",
                          "publishedAt": "2021-03-18T14:40:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Output elastic energy",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Hello MOOSE users,\nIn the poly_grain_growth_2D_eldrforce.i input file, how to add a sub-module in the Auxkernel module to make the output cloud image file (*.e) show elastic energy?\nAnd, the kernel responsible for elastic energy used in this input file is ACGrGrElasticDrivingForce, and the Residual is calculated as follows\uff0c\n    case Residual: return 0.5 * D_stress.doubleContraction(strain); // Compute the deformation energy driving force\nVery grateful for help!\nBest Regards\nWei Peng",
          "url": "https://github.com/idaholab/moose/discussions/17330",
          "updatedAt": "2022-06-09T08:21:46Z",
          "publishedAt": "2021-03-16T14:33:47Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "Perhaps you could add an ElasticEnergyMaterial (documentation). From there you could output the material property directly to the exodus file by setting outputs = exodus in the ElasticEnergyMaterial block, or you could use an AuxKernel like MaterialRealAux (documentation) to sample the elastic energy material.",
                  "url": "https://github.com/idaholab/moose/discussions/17330#discussioncomment-489131",
                  "updatedAt": "2022-06-17T15:27:18Z",
                  "publishedAt": "2021-03-16T14:56:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you for your answer, The problem has been solved.\nI added sub-blocks to the materals block, the code is as follows,\n[./elasticenergy] type = GGElasticEnergyMaterial args = 'gr1 gr2' outputs = exodus [../]\nAfter that, F is displayed in the *.e file, which represents elastic energy.\nThanks again for your help.\nWei Peng",
                          "url": "https://github.com/idaholab/moose/discussions/17330#discussioncomment-496423",
                          "updatedAt": "2022-06-17T15:27:18Z",
                          "publishedAt": "2021-03-18T01:36:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mortar interface flux match",
          "author": {
            "login": "srinath-chakravarthy"
          },
          "bodyText": "A question for all the mortar experts. I am trying to mimic the interfacefluxmatch with mortar. For some reason i am encountering convergence issues with this. I am using ADMortar. Please see below my implementation. Any help will be appreciated.\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/* \n * File:   EqualNormalFluxConstraint.C\n * Author: srinath\n * \n * Created on January 28, 2021, 1:21 PM\n */\n\n#include \"EqualNormalFluxConstraint.h\"\n\n#include \"SubProblem.h\"\n#include \"FEProblem.h\"\n\nregisterMooseObject(\"electro_chemo_mechApp\", EqualNormalFluxConstraint);\n\nInputParameters\nEqualNormalFluxConstraint::validParams()\n{\n  InputParameters params = ADMortarConstraint::validParams();\n  params.addClassDescription(\n      \"EqualNormalFluxConstraint enforces continuity of a gradient component between secondary and \"\n      \"primary sides of a mortar interface using lagrange multipliers\");\n  params.addParam<MaterialPropertyName>(\n      \"primary_mat_prop\",\n      \"diffusivity\",\n      \"The material property name providing the quantity to equilibrate on the primary side\");\n  params.addParam<MaterialPropertyName>(\n      \"secondary_mat_prop\",\n      \"diffusivity\",\n      \"The material property name providing the quantity to equilibrate on the secondary side\");\n  params.addParam<bool>(\"primary_tensor\", false, \"Is the material property tensor_valued\");\n  params.addParam<bool>(\"secondary_tensor\", false, \"Is the material property tensor_valued\");\n  \n  return params;\n}\n\nEqualNormalFluxConstraint::EqualNormalFluxConstraint(const InputParameters & parameters)\n  : ADMortarConstraint(parameters),\n  _primary_tensor(getParam<bool>(\"primary_tensor\")),\n  _secondary_tensor(getParam<bool>(\"secondary_tensor\")),\n  _primary_mat_prop_real(!_primary_tensor ? &getNeighborADMaterialProperty<Real>(\"primary_mat_prop\"):nullptr),\n  _secondary_mat_prop_real(!_secondary_tensor ? &getADMaterialProperty<Real>(\"secondary_mat_prop\"):nullptr),\n  _primary_mat_prop_tensor(_primary_tensor ? &getNeighborADMaterialProperty<RealTensorValue>(\"primary_mat_prop\"):nullptr),\n  _secondary_mat_prop_tensor(_secondary_tensor ? &getADMaterialProperty<RealTensorValue>(\"secondary_mat_prop\"):nullptr)\n\n{\n}\n\nADReal\nEqualNormalFluxConstraint::computeQpResidual(Moose::MortarType mortar_type)\n{\n       \n  switch (mortar_type)\n  {\n    case Moose::MortarType::Secondary:\n      return _lambda[_qp] * _test_secondary[_i][_qp]; \n    case Moose::MortarType::Primary:\n      return _lambda[_qp] * _test_primary[_i][_qp];\n    case Moose::MortarType::Lower:\n    {\n        ADRealVectorValue gradup; \n        ADRealVectorValue gradus;\n        auto residual = _lambda[_qp] * _test[_i][_qp];\n        if (_has_primary)\n        {\n            if (!_primary_tensor)\n                gradup = (*_primary_mat_prop_real)[_qp] * _grad_u_primary[_qp];\n            else\n                gradup = (*_primary_mat_prop_tensor)[_qp] * _grad_u_primary[_qp];\n            if (!_secondary_tensor)\n                gradus = (*_secondary_mat_prop_real)[_qp] * _grad_u_secondary[_qp];\n            else\n                gradus = (*_secondary_mat_prop_tensor)[_qp] * _grad_u_secondary[_qp];\n                \n            residual = ((gradup - gradus) * _normals[_qp]  + _lambda[_qp]) * _test[_i][_qp];\n        }\n                    \n        return residual;\n    }\n    default:\n      return 0;\n  }\n}",
          "url": "https://github.com/idaholab/moose/discussions/16880",
          "updatedAt": "2022-06-02T06:20:00Z",
          "publishedAt": "2021-02-03T21:47:01Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc who can I tag on mortar problems?\nThanks",
                  "url": "https://github.com/idaholab/moose/discussions/16880#discussioncomment-494354",
                  "updatedAt": "2022-06-02T06:26:57Z",
                  "publishedAt": "2021-03-17T15:48:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "@lindsayad",
                          "url": "https://github.com/idaholab/moose/discussions/16880#discussioncomment-495580",
                          "updatedAt": "2022-06-02T06:26:58Z",
                          "publishedAt": "2021-03-17T20:25:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@srinath-chakravarthy I believe you need a difference in sign between your Secondary and Primary residual. Right now you are applying the same sign. For something like heat transport for example that would mean that you are applying a heat sink on both sides of the interface (if lambda is positive) or a heat source on both sides of the interface (if lambda is negative).",
                  "url": "https://github.com/idaholab/moose/discussions/16880#discussioncomment-495936",
                  "updatedAt": "2022-06-02T06:27:05Z",
                  "publishedAt": "2021-03-17T22:07:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The GapConductanceConstraint class in the heat_conduction module applies continuity of heat flux across a mortar interface. You can see the difference in signs between primary and secondary residuals",
                          "url": "https://github.com/idaholab/moose/discussions/16880#discussioncomment-495940",
                          "updatedAt": "2022-06-02T06:27:10Z",
                          "publishedAt": "2021-03-17T22:09:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Well I shouldn't really say \"continuity of heat flux\". I should say that the heat flux is the same on either side of the interface and we are setting that flux equal to \"k * (T_primary - T_secondary) / gap\" through the use of the Lagrange Multiplier",
                          "url": "https://github.com/idaholab/moose/discussions/16880#discussioncomment-495979",
                          "updatedAt": "2022-06-02T06:27:11Z",
                          "publishedAt": "2021-03-17T22:12:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Buckling?",
          "author": {
            "login": "jmhospers"
          },
          "bodyText": "Hello everyone,\nI am looking at MOOSE for structural engineering applications, where we now use commercial applications. For many use cases, the high cost is not warranted and I want an alternative. MOOSE appears very capable for linear/plastic applications. However, I cannot find a capability for (linear bifurcation) buckling calculations? It must be possible, anyone here ever done this?",
          "url": "https://github.com/idaholab/moose/discussions/17328",
          "updatedAt": "2022-08-10T14:11:49Z",
          "publishedAt": "2021-03-16T12:49:11Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "MOOSE currently doesn't have an arc-length solver. Contributions are always welcome.",
                  "url": "https://github.com/idaholab/moose/discussions/17328#discussioncomment-488840",
                  "updatedAt": "2022-08-10T14:11:49Z",
                  "publishedAt": "2021-03-16T14:01:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jmhospers"
                          },
                          "bodyText": "I was hoping there was some obscure way to call the eigensolvers. I don't feel like my math/coding would be up to scrap at the moment.",
                          "url": "https://github.com/idaholab/moose/discussions/17328#discussioncomment-488912",
                          "updatedAt": "2022-08-10T14:11:49Z",
                          "publishedAt": "2021-03-16T14:14:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Oh sorry! I misunderstood your question. MOOSE can definitely solve eigenvalue problems. Maybe use this page https://mooseframework.inl.gov/source/executioners/NonlinearEigen.html as a starting point.",
                          "url": "https://github.com/idaholab/moose/discussions/17328#discussioncomment-488965",
                          "updatedAt": "2022-08-10T14:12:23Z",
                          "publishedAt": "2021-03-16T14:25:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@sapitts Do you have any information you could add about tensor mechanics?",
                  "url": "https://github.com/idaholab/moose/discussions/17328#discussioncomment-495670",
                  "updatedAt": "2022-08-10T14:12:23Z",
                  "publishedAt": "2021-03-17T20:43:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "I don't have anything to add beyond what @hugary1995 has already posted about eigensolvers. @bwspenc would be a better bet for column buckling model recommendations",
                          "url": "https://github.com/idaholab/moose/discussions/17328#discussioncomment-495870",
                          "updatedAt": "2022-08-10T14:12:23Z",
                          "publishedAt": "2021-03-17T21:40:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "unable to run tests on the combined module and simulations input files do not run!",
          "author": {
            "login": "Ali-toghraee"
          },
          "bodyText": "Hello all,\nI am trying to install the new version of MOOSE with conda. The tests did not run at first but I did the following and the moose tests passed.\nconda deactivate\nmodule purge\nconda activate moose\ncd /path to my moose folder/\ngit clean -xfd # warning... this will delete any unsaved commits if you have any\ncd test\nmake -j #my cpu core numbers\n./run_tests\nNow, to run my simulations, I made the executable in combined module folder(combined-opt). However the tests for that did not run leaving errors as below:\n(base) atoghraee@ME-DESKTOP102: ~/ projects02/moose/modules/combined$ conda activate moose\n(moose) atoghraee@ME-DESKTOP102: / projects02 / moose/ modules/ combined$ ./ run_tests -j 90\nBuilding and linking hit...\nfailed to import pyhit - try running \"make hit\" in the $MOOSE_DIR/test directory.\n(moose) atoghraee@ME-DESKTOP102:/ projects02/ moose/modules / combined$\nI should mention that I already have a moose from 2019 in the projects folder, So to install the new moose I just created another folder under projects02",
          "url": "https://github.com/idaholab/moose/discussions/17292",
          "updatedAt": "2022-07-20T15:26:22Z",
          "publishedAt": "2021-03-11T21:23:20Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt looks like you are missing pyhit. Could you please install it with conda install moose-pyhit\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17292#discussioncomment-491038",
                  "updatedAt": "2022-07-20T15:26:26Z",
                  "publishedAt": "2021-03-16T21:32:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "I don't think we have a moose-pyhit package in conda.",
                          "url": "https://github.com/idaholab/moose/discussions/17292#discussioncomment-495634",
                          "updatedAt": "2022-07-20T15:26:27Z",
                          "publishedAt": "2021-03-17T20:40:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "You might be running into a PYTHONPATH problem, make sure you don't have it set to something that points it to the projects/moose location. Also, make sure you don't have $MOOSE_DIR set incorrectly for where you are working.",
                  "url": "https://github.com/idaholab/moose/discussions/17292#discussioncomment-495651",
                  "updatedAt": "2022-07-20T15:26:27Z",
                  "publishedAt": "2021-03-17T20:42:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Also make sure you have the conda environment loaded.",
                          "url": "https://github.com/idaholab/moose/discussions/17292#discussioncomment-495655",
                          "updatedAt": "2022-07-20T15:26:28Z",
                          "publishedAt": "2021-03-17T20:42:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "'Compute Strain Increment Based Stress' for Steady-State problem",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi MOOSE users,\nI have question regarding 'Compute Strain Increment Based Stress' for steady-state simulation\n\nultimately, I want my appliccation to work as follow, where I can change the value of C and strain at any particular block\n\nSo, the question is how do I define stress_old, strain_mech, strain_mech_old from an output file from the previous steady-state step?\nHere in I attached the previous step output file generator (grav_redo.i)\nand currect step .i file with Compute Strain Increment Based Stress (grav_redo_later.i)\ntensor mech elastic equli.zip\nThank you for your time.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/17326",
          "updatedAt": "2022-09-09T13:25:06Z",
          "publishedAt": "2021-03-16T04:38:12Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Traiwit\nIn general, every MaterialProperty defined in the code can be initialised from a previous file.\nFor instance we add the following in the [AuxVariables] block of the restart input file to initialise a stress component:\n[./stress_xx]\norder = CONSTANT\nfamily = MONOMIAL\ninitial_from_file_var = stress_xx\ninitial_from_file_timestep = 620\n[../]\nWe have to do this for all the components.\nIf the above block is used, the standard initialisation in the material object is skipped.\nYou will need to do that for your: stress_old, strain_mech, strain_mech_old\nSo in general, if you want to restart a material model, you need to define in the initial input file\nall the material properties that must keep the memory of the previous simulation (both in AuxVariables and AuxKernels),\nthen in the restart file, you define them again, both in AuxVariables and AuxKernels,\nand you have to initialise them as in the example above. You need to do this for all components\nof all MaterialProperty that must keep memory in your simulation.\nSome MaterialProperty are like history variables and need to be initialised, others may not be history variables.\nThis you need to determine yourself.\nDon't forget to check parent classes of your material objects, as they may contain some of the MaterialProperty\nthat must be initialised.\nTrust this helps.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-487848",
                  "updatedAt": "2022-09-09T13:25:42Z",
                  "publishedAt": "2021-03-16T10:04:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @ngrilli,\nFirst of all, thank you for always helping me out, I really appreciate your help!\nI will give it a go and keep you updated.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-488281",
                          "updatedAt": "2022-09-09T13:26:42Z",
                          "publishedAt": "2021-03-16T12:02:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Sidenote: I wish there are more examples of the steady-state problem, as transient doesn't suit my objective.\nIt can be easily done using for-loop in python/matlab, but solving tensor-mechanical problems there is also difficult",
                  "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-488283",
                  "updatedAt": "2022-09-09T13:27:18Z",
                  "publishedAt": "2021-03-16T12:03:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "You might also consider looking into the restart and recovery capability for MOOSE simulations. More information here. I've used the restart capability successfully in quasi-static / transient simulations, although I have never tried it in a steady state tensor mechanics simulation, and the option may be of use here too",
                  "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-491224",
                  "updatedAt": "2022-09-09T13:27:18Z",
                  "publishedAt": "2021-03-16T22:34:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @sapitts, yes I am using the 'restart' for the Variable (disp_x,y,z) but it cannot call the higher-order Auxvariable for some reason, Auxvariable constant/monomial can be imported with no issue using initial_from_file_var.",
                          "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-492087",
                          "updatedAt": "2022-10-20T13:28:19Z",
                          "publishedAt": "2021-03-17T05:24:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "@aeslaughter is there a MOOSE developer that could help with this question about restart with higher order monomial variables?",
                          "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-494426",
                          "updatedAt": "2022-10-20T13:28:19Z",
                          "publishedAt": "2021-03-17T16:03:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "@loganharbour @friedmud Do either of you know how to help?",
                          "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-495569",
                          "updatedAt": "2022-10-20T13:28:19Z",
                          "publishedAt": "2021-03-17T20:22:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Runtime Error \"ERROR: no system number 0 found!\"",
          "author": {
            "login": "AngeloCass"
          },
          "bodyText": "I have developed a C++ routine that makes use of a MOOSE application to execute a model with varying parameter sets. This routine uses MPI to iterate through different parameter sets in parallel. The routine works as expected on my local machine, but when trying to test on the HPC cluster that I am using, I get the error shown in the subject line. I will attach a text file containing the output with errors.\nError.txt",
          "url": "https://github.com/idaholab/moose/discussions/17350",
          "updatedAt": "2021-05-06T17:20:09Z",
          "publishedAt": "2021-03-17T16:07:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "AngeloCass"
                  },
                  "bodyText": "I forgot to ask this directly, but if anyone has suggestions or solutions for this please let me know! Thanks!",
                  "url": "https://github.com/idaholab/moose/discussions/17350#discussioncomment-494448",
                  "updatedAt": "2021-03-17T16:11:36Z",
                  "publishedAt": "2021-03-17T16:11:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "Can you share the problem (input) you're running?",
                  "url": "https://github.com/idaholab/moose/discussions/17350#discussioncomment-494488",
                  "updatedAt": "2021-03-17T16:20:19Z",
                  "publishedAt": "2021-03-17T16:19:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AngeloCass"
                          },
                          "bodyText": "I will attach the input file to this reply. Some of the values in the GlobalParams block are overwritten with command line inputs by the C++ routine at runtime. Also, the Outputs block file base is defined unique to each execution through a command line input.\nInput.txt",
                          "url": "https://github.com/idaholab/moose/discussions/17350#discussioncomment-494547",
                          "updatedAt": "2021-03-17T16:35:02Z",
                          "publishedAt": "2021-03-17T16:35:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "Hopefully you are aware that we have native capability for doing this: https://mooseframework.inl.gov/modules/stochastic_tools/index.html",
                  "url": "https://github.com/idaholab/moose/discussions/17350#discussioncomment-495556",
                  "updatedAt": "2021-03-17T20:18:10Z",
                  "publishedAt": "2021-03-17T20:17:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Load nemesis output files into SolutionUserObject",
          "author": {
            "login": "zhang-rite"
          },
          "bodyText": "Hi,\nNow another problem related to distributed mesh is how to read the series of nemesis output files (e.g., e..) into a SolutionUserObject for the initial condition in next run? Is there a function for this available? Or for converting nemesis output to an exodus file.\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/17226",
          "updatedAt": "2023-03-15T15:25:48Z",
          "publishedAt": "2021-03-04T08:26:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@loganharbour can you please answer this or tag someone knowledgeable about nemesis",
                  "url": "https://github.com/idaholab/moose/discussions/17226#discussioncomment-495156",
                  "updatedAt": "2023-03-15T15:25:48Z",
                  "publishedAt": "2021-03-17T18:39:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "SolutionUserObject doesn't support Nemesis, so to do this correctly that would need to be added. You can use Paraview to convert the Nemesis files to a single Exodus. You can even limit the output to a certain variable. Of course, if the mesh is very large that will probably give you memory problems.",
                  "url": "https://github.com/idaholab/moose/discussions/17226#discussioncomment-495535",
                  "updatedAt": "2023-03-15T15:25:59Z",
                  "publishedAt": "2021-03-17T20:15:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Plotting Yield locus",
          "author": {
            "login": "Aayush-T"
          },
          "bodyText": "Hi everyone,\nI am new to Moose, I wanted to make a Yield surface for a biaxial loading case. I have calculated stress and strain but can not find a way for finding equivalent plastic strain. I tried using the value of stresses at t=10 sec and then calculate principal stresses from them to plot the graph for different displacement values, but the graph is not right. Can anyone help with it? The code and graph\n\nis attached below.\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  elem_type = QUAD4\n  displacements = 'disp_x disp_y'\n  nx = 1\n  ny = 1\n[]\n\n[Variables]\n  [./disp_x]\n  [../]\n  [./disp_y]\n  [../]\n[]\n\n[GlobalParams]\n  volumetric_locking_correction = true\n[]\n\n[AuxVariables]\n  [./stress_yy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./stress_xx]\n  order = CONSTANT\n  family = MONOMIAL\n  [../]\n  [./stress_xy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e_yy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e_xx]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e_xy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./fp_yy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./gss]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./euler1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./euler2]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./euler3]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[Functions]\n  [./tdisp]\n    type = ParsedFunction\n    value = 0.001*t\n  [../]\n  [./rdisp]\n  type = ParsedFunction\n  value = 0.001*t\n[../]\n[]\n\n[UserObjects]\n  [./prop_read]\n    type = ElementPropertyReadFile\n    prop_file_name = 'euler_ang_file.txt'\n    # Enter file data as prop#1, prop#2, .., prop#nprop\n    nprop = 3\n    read_type = element\n  [../]\n[]\n\n[AuxKernels]\n  [./stress_yy]\n    type = RankTwoAux\n    variable = stress_yy\n    rank_two_tensor = stress\n    index_j = 1\n    index_i = 1\n    execute_on = timestep_end\n  [../]\n  [./e_yy]\n    type = RankTwoAux\n    variable = e_yy\n    rank_two_tensor = lage\n    index_j = 1\n    index_i = 1\n    execute_on = timestep_end\n  [../]\n  [./stress_xx]\n    type = RankTwoAux\n    variable = stress_xx\n    rank_two_tensor = stress\n    index_j = 0\n    index_i = 0\n    execute_on = timestep_end\n  [../]\n  [./e_xx]\n    type = RankTwoAux\n    variable = e_xx\n    rank_two_tensor = lage\n    index_j = 0\n    index_i = 0\n    execute_on = timestep_end\n  [../]\n  [./e_xy]\n    type = RankTwoAux\n    variable = e_xy\n    rank_two_tensor = lage\n    index_j = 1\n    index_i = 0\n    execute_on = timestep_end\n  [../]\n  [./stress_xy]\n    type = RankTwoAux\n    variable = stress_xy\n    rank_two_tensor = stress\n    index_j = 1\n    index_i = 0\n    execute_on = timestep_end\n  [../]\n  [./fp_yy]\n    type = RankTwoAux\n    variable = fp_yy\n    rank_two_tensor = fp\n    index_j = 1\n    index_i = 1\n    execute_on = timestep_end\n  [../]\n  [./gss]\n    type = MaterialStdVectorAux\n    variable = gss\n    property = state_var_gss\n    index = 0\n    execute_on = timestep_end\n  [../]\n  [./euler1]\n    type = MaterialRealVectorValueAux\n    variable = euler1\n    property = Euler_angles\n    component = 0\n    execute_on = timestep_end\n  [../]\n  [./euler2]\n    type = MaterialRealVectorValueAux\n    variable = euler2\n    property = Euler_angles\n    component = 1\n    execute_on = timestep_end\n  [../]\n  [./euler3]\n    type = MaterialRealVectorValueAux\n    variable = euler3\n    property = Euler_angles\n    component = 2\n    execute_on = timestep_end\n  [../]\n[]\n\n[BCs]\n  [./fix_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    value = 0\n  [../]\n  [./fix_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0\n  [../]\n  [./tdisp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = top\n    function = tdisp\n  [../]\n#  [./rdisp]\n#    type = FunctionDirichletBC\n#    variable = disp_x\n#    boundary = right\n#    function = rdisp\n#  [../]\n[]\n\n[UserObjects]\n  [./slip_rate_gss]\n    type = CrystalPlasticitySlipRateGSS\n    variable_size = 12\n    slip_sys_file_name = input_slip_sys.txt\n    num_slip_sys_flowrate_props = 2\n    flowprops = '1 4 0.001 0.1 5 8 0.001 0.1 9 12 0.001 0.1'\n    uo_state_var_name = state_var_gss\n  [../]\n  [./slip_resistance_gss]\n    type = CrystalPlasticitySlipResistanceGSS\n    variable_size = 12\n    uo_state_var_name = state_var_gss\n  [../]\n  [./state_var_gss]\n    type = CrystalPlasticityStateVariable\n    variable_size = 12\n    groups = '0 4 8 12'\n    group_values = '60.8 60.8 60.8'\n    uo_state_var_evol_rate_comp_name = state_var_evol_rate_comp_gss\n    scale_factor = 1.0\n  [../]\n  [./state_var_evol_rate_comp_gss]\n    type = CrystalPlasticityStateVarRateComponentGSS\n    variable_size = 12\n    hprops = '1.0 541.5 109.8 2.5'\n    uo_slip_rate_name = slip_rate_gss\n    uo_state_var_name = state_var_gss\n  [../]\n[]\n\n[Materials]\n  [./crysp]\n    type = FiniteStrainUObasedCP\n    stol = 1e-2\n    tan_mod_type = exact\n    uo_slip_rates = 'slip_rate_gss'\n    uo_slip_resistances = 'slip_resistance_gss'\n    uo_state_vars = 'state_var_gss'\n    uo_state_var_evol_rate_comps = 'state_var_evol_rate_comp_gss'\n  [../]\n  [./strain]\n    type = ComputeFiniteStrain\n    displacements = 'disp_x disp_y'\n  [../]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '1.684e5 1.214e5 1.214e5 1.684e5 1.214e5 1.684e5 0.754e5 0.754e5 0.754e5'\n    fill_method = symmetric9\n    read_prop_user_object = prop_read\n  [../]\n[]\n\n[Postprocessors]\n  [./stress_yy]\n    type = ElementAverageValue\n    variable = stress_yy\n  [../]\n  [./stress_xx]\n    type = ElementAverageValue\n    variable = stress_xx\n  [../]\n  [./e_xy]\n    type = ElementAverageValue\n    variable = e_xy\n  [../]\n  [./e_yy]\n    type = ElementAverageValue\n    variable = e_yy\n  [../]\n  [./e_xx]\n    type = ElementAverageValue\n    variable = e_xx\n  [../]\n  [./stress_xy]\n    type = ElementAverageValue\n    variable = stress_xy\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  dt = 0.01\n  solve_type = 'PJFNK'\n\n  petsc_options_iname = -pc_hypre_type\n  petsc_options_value = boomerang\n  nl_abs_tol = 1e-10\n  nl_rel_step_tol = 1e-10\n  dtmax = 10.0\n  nl_rel_tol = 1e-10\n  dtmin = 0.01\n  num_steps = 1000\n  nl_abs_step_tol = 1e-10\n[]\n\n[Outputs]\n  exodus = true\n   csv = true\n[]\n\n[Kernels]\n  [./TensorMechanics]\n    displacements = 'disp_x disp_y'\n    use_displaced_mesh = true\n  [../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/16839",
          "updatedAt": "2022-06-10T14:44:28Z",
          "publishedAt": "2021-01-30T07:05:19Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Aayush-T"
                  },
                  "bodyText": "The block letter part is not part of the code and was commented by me, I forgot to remove it while pasting the code here!",
                  "url": "https://github.com/idaholab/moose/discussions/16839#discussioncomment-322881",
                  "updatedAt": "2022-06-24T09:22:36Z",
                  "publishedAt": "2021-01-30T07:07:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Aayush-T\nIf you use the crystal plasticity model,\nthe scalar cumulative plastic strain is calculated and the variable is called \"_acc_slip\" in the code.\nTherefore, you can add an auxiliary variable like:\n[./acc_slip]\norder = CONSTANT\nfamily = MONOMIAL\n[../]\nand corresponding AuxKernel:\n[./acc_slip]\ntype = MaterialRealAux\nvariable = acc_slip\nproperty = acc_slip\nexecute_on = timestep_end\n[../]\nNot sure which quantity you are looking for exactly.\nIf you want something like Mises plastic strain, then you can output the components\nof the plastic deformation gradients using for instance:\n[./fp_xy]\norder = CONSTANT\nfamily = MONOMIAL\n[../]\nand\n[./fp_xy]\ntype = RankTwoAux\nvariable = fp_xy\nrank_two_tensor = fp\nindex_j = 1\nindex_i = 0\nexecute_on = timestep_end\n[../]\nThen you can calculate equivalent plastic strain with the expression you like using the paraview \"calculator\" filter.\nHope this helps\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/16839#discussioncomment-324607",
                  "updatedAt": "2022-06-24T09:22:36Z",
                  "publishedAt": "2021-01-31T07:42:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Aayush-T"
                          },
                          "bodyText": "Yes, actually I was looking for ways to get the equivalent plastic strain values from the moose itself and output in the csv file as I could not find any direct function in moose that does it. Thanks for such a prompt response.\nRegards,\nAayush Trivedi\nIIT Bombay",
                          "url": "https://github.com/idaholab/moose/discussions/16839#discussioncomment-372507",
                          "updatedAt": "2022-06-24T09:22:36Z",
                          "publishedAt": "2021-02-16T06:03:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "This should really be possible by setting the appropriate scalar_type in the RankTwoScalarAux .  If it isn't currently possible, you (or someone), should add that functionality for future users.",
                          "url": "https://github.com/idaholab/moose/discussions/16839#discussioncomment-375087",
                          "updatedAt": "2022-06-24T09:22:36Z",
                          "publishedAt": "2021-02-16T21:01:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Aayush-T"
                          },
                          "bodyText": "I am trying to add this. Also, the _acc_slip is not working in the dual-phase crysp case that I am using. If anyone else is able to do that, please do post or I will update it.",
                          "url": "https://github.com/idaholab/moose/discussions/16839#discussioncomment-427113",
                          "updatedAt": "2022-06-24T09:22:36Z",
                          "publishedAt": "2021-03-03T20:20:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}