{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNS0xNVQyMTo0NTo1MS0wNjowMM4AM1jx"
    },
    "edges": [
      {
        "node": {
          "title": "ADMatDiffusion vs MatDiffusion",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "Hello,\nI am new to moose and a little confused with the differences between ADMatDiffusion and MatDiffusion. ADMatDiffusion uses the automatic differentiation system to calculate the Jacobian and MatDiffusion calculates the Jacobian directly inside the kernel. In both systems you can very the diffusivity as a function of args a, b, c, ... but what about u? My guess is that if you wanted the diffusitivity to very with u or a coupled variable such as temperature you would need to use ADMatDiffusion, is this correct?",
          "url": "https://github.com/idaholab/moose/discussions/17864",
          "updatedAt": "2023-02-03T00:17:50Z",
          "publishedAt": "2021-05-17T22:13:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think for MatDiffusion, the derivative with respect to u or the non-linear variables of the diffusivity are actually already included in the kernel definition. You can have a look at MatDiffusionBase.h for the Jacobian computation.\nSo with MatDiffusion, as long as you define the derivatives of the diffusivities in your materials, you could still get the perfect Jacobian.\nIf you don't want to work on implementing the derivatives of your material properties, just use the AD version.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17864#discussioncomment-750356",
                  "updatedAt": "2023-02-03T00:17:50Z",
                  "publishedAt": "2021-05-17T23:17:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Phase field (crystal) question",
          "author": {
            "login": "mangerij"
          },
          "bodyText": "I have a request from some colleagues to model something, but I am unsure where to look for the tools:\nThe system starts initially amorphous and has some small perhaps randomly placed nucleation centers that form a specific (cubic) crystalline phase. In the interface region, there may be some pyrochlore crystallites that comprise an \"intermediate\" phase.\nThe nucleation centers essentially grow until they fill the computational domain and we get a number of different grains/grain sizes based on the temperature profile the evolution sees.\nIs such a model implemented in MOOSE, the modules, or any external apps? Is this \"phase field crystal\"?",
          "url": "https://github.com/idaholab/moose/discussions/17794",
          "updatedAt": "2022-06-14T14:01:37Z",
          "publishedAt": "2021-05-11T07:28:43Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@SudiptaBiswas Can you please help?",
                  "url": "https://github.com/idaholab/moose/discussions/17794#discussioncomment-729378",
                  "updatedAt": "2022-06-14T14:01:36Z",
                  "publishedAt": "2021-05-12T14:11:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "I wouldn't call this phase-field crystal. PFC models represent the local atomic structure with a continuous order parameter that is analogous to local density. The length scale is much smaller than typical phase-field models because PFC attempts to resolve the local atomic structure, whereas in phase-field modeling we coarse-grain the atomic structure.\nWhat you are describing sounds more like a phase transformation problem. It seems similar to a solidification problem, except that rather than transforming from the liquid phase to multiple grains of a solid phase, you are transforming from an amorphous phase to multiple grains of a crystalline (solid) phase. In both situations, there is a driving force in the free energy that is causing the phase transformation. I'm not sure offhand how the intermediate phase in the interface would affect things.\nSo setting aside the intermediate phase for the moment, to model this you would want to be able to represent the amorphous phase (a single order parameter for this should suffice) and multiple grains of the crystalline phase. One question I have is whether there is any difference in chemical composition between the amorphous and crystalline phases? (I am guessing not but just thought I would double check.)",
                  "url": "https://github.com/idaholab/moose/discussions/17794#discussioncomment-740671",
                  "updatedAt": "2022-06-14T14:01:37Z",
                  "publishedAt": "2021-05-14T23:36:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "Yeah, there is no difference in chemical composition, the material just has three different phases that evolve from amorphous to a full grain structure via small nucleation centers. The tertiary phase can be ignored for now.\nSo where are these \"phase transformation\" models in the modules? Is there an input file I can work off of?\nthanks!",
                          "url": "https://github.com/idaholab/moose/discussions/17794#discussioncomment-748731",
                          "updatedAt": "2022-06-14T14:01:38Z",
                          "publishedAt": "2021-05-17T15:48:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "I don't think we have the capability to set up the interface as a third material. I agree with Larry, the two-phase problem can be handled with existing phase transformation models.",
                  "url": "https://github.com/idaholab/moose/discussions/17794#discussioncomment-740692",
                  "updatedAt": "2022-06-14T14:01:41Z",
                  "publishedAt": "2021-05-14T23:49:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "So we don't have any examples that do exactly this situation in the repo now. It is probably closest to the solidification examples here:\nhttps://github.com/idaholab/moose/tree/next/modules/phase_field/examples/anisotropic_interfaces\nI would probably start with the grand potential formulation for a binary alloy here:\nhttps://github.com/idaholab/moose/blob/next/modules/phase_field/examples/anisotropic_interfaces/GrandPotentialSolidification.i\nSo for this problem, you won't need the evolution equations for chemical potential, since you aren't tracking a solute species. You also likely don't need interfacial energy anisotropy. What you are wanting to do is actually pretty similar to a grain growth model, except that there is an energetic driving force that makes the crystalline phase more energetically favorable than the amorphous phase. So from this example, you would need to add multiple order parameters for the crystalline phase rather than the single phase as in this example.\nFor more details on the formulation of the models described above please see:\nhttps://journals.aps.org/pre/abstract/10.1103/PhysRevE.98.023309\nAgain you won't need solute species evolution so there is a lot of stuff you won't need, but I think this is the most straightforward way to go from what is currently in the MOOSE repo. You may be better off writing your own evolutions equations by simplifying what is in the paper, then using existing kernels and materials to implement it. That should be doable with no new code.",
                  "url": "https://github.com/idaholab/moose/discussions/17794#discussioncomment-749007",
                  "updatedAt": "2022-06-14T14:01:41Z",
                  "publishedAt": "2021-05-17T16:54:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Thermal contact",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi All\nHopefully a quick one, I'm busy putting together some MOOSE examples, and I'm trying a thermo-mechanical example. In my case I have two steel bodies close to one another, which eventually do get into quite a lot of contact, but weirdly heat is not conducted across this contact. This is contrary to my expectation, my kernels are as follows\n[Kernels]\n  [heat-conduction]\n    type = ADHeatConduction\n    variable = temperature\n  []\n  [heat-conduction-dt]\n    type = ADHeatConductionTimeDerivative\n    variable = temperature\n  []\n  [TensorMechanics]\n     displacements = 'disp_x disp_y disp_z'\n     generate_output = 'strain_xx strain_yy strain_zz vonmises_stress'\n     eigenstrain_names = 'steel-eigenstrain'\n     use_automatic_differentiation = true\n   []\n[]\n\nand my materials\n[Materials]\n  [steel]\n    type = ADGenericConstantMaterial\n    prop_names = 'density'\n    prop_values = '7800'\n  []\n  [steel-conduction]\n    type = ADHeatConductionMaterial\n    specific_heat = 420.0\n    thermal_conductivity = 45.0\n  []\n  [steel-elasticity]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 210e9\n    poissons_ratio = 0.33\n  []\n  [steel-thermal-expansion]\n    type = ADComputeThermalExpansionEigenstrain\n    stress_free_temperature = 293.15\n    thermal_expansion_coeff = 1.8e-3 # K^-1\n    temperature = temperature\n    eigenstrain_name = 'steel-eigenstrain'\n  []\n  [steel-strain] #We use small deformation mechanics\n    type = ADComputeSmallStrain\n    displacements = 'disp_x disp_y disp_z'\n    eigenstrain_names = 'steel-eigenstrain'\n  []\n  [steel-stress] #We use linear elasticity\n    type = ADComputeLinearElasticStress\n  []\n[]\n\nThe documentation states that ADHeatConduction uses the displaced mesh by default, as does ADHeatConductionTimeDerivative, is there another non-obvious thing I'm missing? I had presumed, perhaps wrongly that using the displaced mesh means that this would include the impact of contact to heat transfer.",
          "url": "https://github.com/idaholab/moose/discussions/17804",
          "updatedAt": "2022-06-11T10:33:31Z",
          "publishedAt": "2021-05-11T20:15:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "Might not be what you're looking for, but have you looked at ThermalContactAction? The source documentation linked within isn't complete, but there should be plenty of gap_heat_transfer tests in the Heat Conduction module that use the ThermalContact block to look at how to use it. I believe it sets up the objects you need to model the heat across the gap and as the spheres come into contact.",
                  "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-725831",
                  "updatedAt": "2022-06-11T10:34:07Z",
                  "publishedAt": "2021-05-11T20:33:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "I will second the recommendation to use the ThermalContact action; without this additional action your simulation will not have the boundary conditions, auxvariables, etc necessary to model the heat transfer between the two surfaces. The following input file snippet should give you an idea of what to look for in the examples Casey mentioned:\n[ThermalContact]\n  [upper_plunger_powder_thermal]\n    type = GapHeatTransfer\n    primary = plunger_bottom\n    secondary = compact_top\n    variable = temperature\n    quadrature = true\n    emissivity_primary = 0.85\n    emissivity_secondary = 0.85\n    gap_conductivity = 5\n    normal_smoothing_distance = 0.1 # as with mechanical contact this is a normalized distance. A value between 0-0.5 is recommended\n  []\n[]\n\nThe values for emissivity and gap conductivity should be adjusted for your metal and surrounding medium (air?), respectively",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-726209",
                          "updatedAt": "2022-06-11T10:34:08Z",
                          "publishedAt": "2021-05-11T22:10:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Here are two screenshots of the paired_temperature variable, weirdly I get something paired on the wrong side of the left hand cup.\n\n\nI presume thats not meant to happen?",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-729690",
                          "updatedAt": "2022-06-11T10:34:25Z",
                          "publishedAt": "2021-05-12T15:12:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Do you have the entire outer side of the left cup set as a single sideset? If yes, I'd recommend splitting the front (or non handle) and back (or handle) into two separate sidesets and then using only the front sideset as the secondary boundary in the thermal contact action",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-729777",
                          "updatedAt": "2022-06-11T10:34:34Z",
                          "publishedAt": "2021-05-12T15:30:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "I think I can report a bug here, in serial it runs more or less fine, but in parallel it does the first iteration and hangs (presumably forever?) my patience only lasted an hour.",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-730029",
                          "updatedAt": "2022-06-11T10:34:45Z",
                          "publishedAt": "2021-05-12T16:03:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "Seeking some clarification, Andy - so you're making it past the first nonlinear iteration, but it never starts the linear iterations? Do you have print_linear_residuals = true in your Output block? I'm curious if you're even making it to the linear solve, or if the linear iterations are just heinously slow (the limit on those before failure is 10000 by default...).\nTagging @bwspenc and @recuero as well since they have more experience with contact in general than I do.",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-730238",
                          "updatedAt": "2022-06-11T10:34:45Z",
                          "publishedAt": "2021-05-12T16:44:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Sorry that wasn't particularly clear, it does one complete non-linear iteration cycle and decides it can't converge, there's the usual stuff about reasons in this case -ve element jacobians, a picture paints a thousand words;\nime Step 1, time = 5, dt = 5\nComputing initial residual ..                                                              [  3.55 s]\n 0 Nonlinear |R| = 1.364630e+08\n      0 Linear |R| = 1.364630e+08\n      1 Linear |R| = 6.148194e+07\n      2 Linear |R| = 1.916627e+07\n 1 Nonlinear |R| = 1.916615e+07\n      0 Linear |R| = 1.916615e+07\n      1 Linear |R| = 1.905225e+07\n      2 Linear |R| = 1.887285e+07\n      3 Linear |R| = 1.473170e+07\n      4 Linear |R| = 1.126639e+07\n      5 Linear |R| = 8.901916e+06\n      6 Linear |R| = 8.599173e+06\n      7 Linear |R| = 6.498452e+06\n      8 Linear |R| = 4.120288e+06\n      9 Linear |R| = 2.986503e+06\n     10 Linear |R| = 2.380091e+06\n  Elem Information\n   id()=233, unique_id()=54803, processor_id()=2\n   type()=TET4\n   dim()=3\n   n_nodes()=4\n    0  Node id()=35, processor_id()=2, Point=(x,y,z)=(-0.0238769, 0.153157, 0.0277344)\n    DoFs=(0/0/55564) (0/1/55565) (0/2/55566) (0/3/55567) (1/0/1395796) (1/6/2011928) (1/7/2011929) (1/8/2011930) \n    1  Node id()=52, processor_id()=2, Point=(x,y,z)=(-0.0282003, 0.0764364, 0.0211529)\n    DoFs=(0/0/55572) (0/1/55573) (0/2/55574) (0/3/55575) (1/0/1395798) (1/6/2011934) (1/7/2011935) (1/8/2011936) \n    2  Node id()=238, processor_id()=2, Point=(x,y,z)=(-0.0160709, 0.218499, 0.0311491)\n    DoFs=(0/0/55992) (0/1/55993) (0/2/55994) (0/3/55995) (1/0/1395903) (1/6/2012249) (1/7/2012250) (1/8/2012251) \n    3  Node id()=22, processor_id()=2, Point=(x,y,z)=(-0.0247321, 0.191576, 0.0145954)\n    DoFs=(0/0/55528) (0/1/55529) (0/2/55530) (0/3/55531) (1/0/1395787) (1/6/2011901) (1/7/2011902) (1/8/2011903) \n   n_sides()=4\n    neighbor(0)=nullptr\n    neighbor(1)=77\n    neighbor(2)=751\n    neighbor(3)=487\n   hmin()=0.0327698, hmax()=0.142929\n   volume()=-9.51207e-07\n   active()=1, ancestor()=0, subactive()=0, has_children()=0\n   parent()=nullptr\n   level()=0, p_level()=0\n   refinement_flag()=DO_NOTHING\n   p_refinement_flag()=DO_NOTHING\n   DoFs=(1/1/1405118) (1/1/1405119) (1/1/1405120) (1/1/1405121) (1/2/1405122) (1/2/1405123) (1/2/1405124) (1/2/1405125) (1/3/1405126) (1/3/1405127) (1/3/1405128) (1/3/1405129) (1/4/1405130) (1/4/1405131) (1/4/1405132) (1/4/1405133) (1/5/1405134) (1/5/1405135) (1/5/1405136) (1/5/1405137) (1/9/2032876) (1/10/2032877) \nERROR: negative Jacobian -5.70724e-06 at point (x,y,z)=(-0.0234386, 0.149589, 0.0270887) in element 233\n[2] /home/adavis/opt/moose/scripts/../libmesh/src/fe/fe_map.C, line 1172, compiled Apr 29 2021 at 15:01:50\n  Elem Information\n   id()=894, unique_id()=55464, processor_id()=3\n   type()=TET4\n   dim()=3\n   n_nodes()=4\n    0  Node id()=68, processor_id()=3, Point=(x,y,z)=(-0.00571363, 0.174668, -0.013127)\n    DoFs=(0/0/83352) (0/1/83353) (0/2/83354) (0/3/83355) (1/0/2093599) (1/6/2709401) (1/7/2709402) (1/8/2709403) \n    1  Node id()=87, processor_id()=3, Point=(x,y,z)=(-0.00487295,  0.16173, -0.0150198)\n    DoFs=(0/0/83404) (0/1/83405) (0/2/83406) (0/3/83407) (1/0/2093612) (1/6/2709440) (1/7/2709441) (1/8/2709442) \n    2  Node id()=37, processor_id()=3, Point=(x,y,z)=(-0.0114475, 0.160955, -0.0171646)\n    DoFs=(0/0/83272) (0/1/83273) (0/2/83274) (0/3/83275) (1/0/2093579) (1/6/2709341) (1/7/2709342) (1/8/2709343) \n    3  Node id()=38, processor_id()=3, Point=(x,y,z)=(-0.00870645, 0.163973, -0.0108696)\n    DoFs=(0/0/83276) (0/1/83277) (0/2/83278) (0/3/83279) (1/0/2093580) (1/6/2709344) (1/7/2709345) (1/8/2709346) \n   n_sides()=4\n    neighbor(0)=nullptr\n    neighbor(1)=928\n    neighbor(2)=140\n    neighbor(3)=800\n   hmin()=0.00607842, hmax()=0.0154024\n   volume()=-7.07529e-08\n   active()=1, ancestor()=0, subactive()=0, has_children()=0\n   parent()=nullptr\n   level()=0, p_level()=0\n   refinement_flag()=DO_NOTHING\n   p_refinement_flag()=DO_NOTHING\n   DoFs=(1/1/2109006) (1/1/2109007) (1/1/2109008) (1/1/2109009) (1/2/2109010) (1/2/2109011) (1/2/2109012) (1/2/2109013) (1/3/2109014) (1/3/2109015) (1/3/2109016) (1/3/2109017) (1/4/2109018) (1/4/2109019) (1/4/2109020) (1/4/2109021) (1/5/2109022) (1/5/2109023) (1/5/2109024) (1/5/2109025) (1/9/2729638) (1/10/2729639) \nERROR: negative Jacobian -4.24518e-07 at point (x,y,z)=(-0.00645255, 0.170232, -0.014091) in element 894\n[3] /home/adavis/opt/moose/scripts/../libmesh/src/fe/fe_map.C, line 1172, compiled Apr 29 2021 at 15:01:50\n  Elem Information\n   id()=176653, unique_id()=231223, processor_id()=6\n   type()=TET4\n   dim()=3\n   n_nodes()=4\n    0  Node id()=49493, processor_id()=6, Point=(x,y,z)=(0.00223491, 0.141798, 0.0260217)\n    DoFs=(0/0/187964) (0/1/187965) (0/2/187966) (0/3/187967) (1/0/4191506) (1/6/4818997) (1/7/4818998) (1/8/4818999) \n    1  Node id()=43886, processor_id()=6, Point=(x,y,z)=(-0.000790227, 0.155327, 0.0271245)\n    DoFs=(0/0/183072) (0/1/183073) (0/2/183074) (0/3/183075) (1/0/4190283) (1/6/4815328) (1/7/4815329) (1/8/4815330) \n    2  Node id()=43889, processor_id()=6, Point=(x,y,z)=(-0.0153427, 0.193478, 0.0226232)\n    DoFs=(0/0/183084) (0/1/183085) (0/2/183086) (0/3/183087) (1/0/4190286) (1/6/4815337) (1/7/4815338) (1/8/4815339) \n    3  Node id()=43887, processor_id()=6, Point=(x,y,z)=(0.000263416,  0.15793, 0.029059)\n    DoFs=(0/0/183076) (0/1/183077) (0/2/183078) (0/3/183079) (1/0/4190284) (1/6/4815331) (1/7/4815332) (1/8/4815333) \n   n_sides()=4\n    neighbor(0)=nullptr\n    neighbor(1)=201467\n    neighbor(2)=201461\n    neighbor(3)=186463\n   hmin()=0.00340966, hmax()=0.0546935\n   volume()=-4.67776e-09\n   active()=1, ancestor()=0, subactive()=0, has_children()=0\n   parent()=nullptr\n   level()=0, p_level()=0\n   refinement_flag()=DO_NOTHING\n   p_refinement_flag()=DO_NOTHING\n   DoFs=(1/1/4509593) (1/1/4509594) (1/1/4509595) (1/1/4509596) (1/2/4509597) (1/2/4509598) (1/2/4509599) (1/2/4509600) (1/3/4509601) (1/3/4509602) (1/3/4509603) (1/3/4509604) (1/4/4509605) (1/4/4509606) (1/4/4509607) (1/4/4509608) (1/5/4509609) (1/5/4509610) (1/5/4509611) (1/5/4509612) (1/9/4853784) (1/10/4853785) \nERROR: negative Jacobian -2.80666e-08 at point (x,y,z)=(-0.00103069, 0.152227, 0.0256917) in element 176653\n[6] /home/adavis/opt/moose/scripts/../libmesh/src/fe/fe_map.C, line 1172, compiled Apr 29 2021 at 15:01:50\n\nthen it just sits. Before adding thermal contact, this calculations would do this -ve Jacobian, but it would just move on to the next iteration with a smaller timestep. This one just sits. Here is the example in serial\nOutputting exodus \n.                                                                                          [  2.55 s]\n\nTime Step 1, time = 5, dt = 5\nComputing initial residual ......................                                          [ 23.46 s]\nUpdating displaced mesh                                                                    [  1.08 s]\n 0 Nonlinear |R| = 1.364630e+08\nUpdating displaced mesh \n\n*** Warning ***\nWarning in PenetrationLocator. Penetration is not detected for one or more secondary nodes. This could be because those secondary nodes simply do not project to faces on the primary surface. However, this could also be because contact should be enforced on those nodes, but the faces that they project to are outside the contact patch, which will give an erroneous result. Use appropriate options for 'patch_size' and 'patch_update_strategy' in the Mesh block to avoid this issue. Setting 'patch_update_strategy=iteration' is recommended because it completely avoids this potential issue. Also note that this warning is printed only once, so a similar situation could occur multiple times during the simulation but this warning is printed only at the first occurrence.\n                                                                   [  1.53 s]\n      0 Linear |R| = 1.364630e+08\n      1 Linear |R| = 1.422522e-05\nUpdating displaced mesh                                                                    [  1.06 s]\n 1 Nonlinear |R| = 2.373806e+03\nUpdating displaced mesh                                                                    [  1.42 s]\n      0 Linear |R| = 2.373806e+03\n      1 Linear |R| = 9.458785e-04\n  Elem Information\n   id()=154587, unique_id()=209157, processor_id()=0\n   type()=TET4\n   dim()=3\n   n_nodes()=4\n    0  Node id()=35972, processor_id()=0, Point=(x,y,z)=(0.00256496, -0.0720505, 0.00114209)\n    DoFs=(0/0/143888) (0/1/143889) (0/2/143890) (0/3/143891) (1/0/35972) (1/6/5036166) (1/7/5036167) (1/8/5036168) \n    1  Node id()=41084, processor_id()=0, Point=(x,y,z)=(-0.0127279, -0.0697743, -0.00545712)\n    DoFs=(0/0/164336) (0/1/164337) (0/2/164338) (0/3/164339) (1/0/41084) (1/6/5051502) (1/7/5051503) (1/8/5051504) \n    2  Node id()=36174, processor_id()=0, Point=(x,y,z)=(-0.0127669, -0.0696714, 0.00706641)\n    DoFs=(0/0/144696) (0/1/144697) (0/2/144698) (0/3/144699) (1/0/36174) (1/6/5036772) (1/7/5036773) (1/8/5036774) \n    3  Node id()=36176, processor_id()=0, Point=(x,y,z)=(-0.00637909, -0.0725568, 0.00348699)\n    DoFs=(0/0/144704) (0/1/144705) (0/2/144706) (0/3/144707) (1/0/36176) (1/6/5036778) (1/7/5036779) (1/8/5036780) \n   n_sides()=4\n    neighbor(0)=nullptr\n    neighbor(1)=159289\n    neighbor(2)=179480\n    neighbor(3)=203799\n   hmin()=0.00787029, hmax()=0.0168108\n   volume()=-6.02689e-08\n   active()=1, ancestor()=0, subactive()=0, has_children()=0\n   parent()=nullptr\n   level()=0, p_level()=0\n   refinement_flag()=DO_NOTHING\n   p_refinement_flag()=DO_NOTHING\n   DoFs=(1/1/3146310) (1/1/3146311) (1/1/3146312) (1/1/3146313) (1/2/3146314) (1/2/3146315) (1/2/3146316) (1/2/3146317) (1/3/3146318) (1/3/3146319) (1/3/3146320) (1/3/3146321) (1/4/3146322) (1/4/3146323) (1/4/3146324) (1/4/3146325) (1/5/3146326) (1/5/3146327) (1/5/3146328) (1/5/3146329) (1/9/5401134) (1/10/5401135) \nERROR: negative Jacobian -3.61613e-07 at point (x,y,z)=(-0.00254292, -0.0712752, 0.000882316) in element 154587\nStack frames: 37\n0: libMesh::print_trace(std::ostream&)\n1: libMesh::MacroFunctions::report_error(char const*, int, char const*, char const*)\n2: libMesh::FEMap::compute_single_point_map(unsigned int, std::vector<double, std::allocator<double> > const&, libMesh::Elem const*, unsigned int, std::vector<libMesh::Node const*, std::allocator<libMesh::Node const*> > const&, bool)\n3: libMesh::FEMap::compute_affine_map(unsigned int, std::vector<double, std::allocator<double> > const&, libMesh::Elem const*)\n4: libMesh::FE<3u, (libMesh::FEFamily)2>::reinit(libMesh::Elem const*, std::vector<libMesh::Point, std::allocator<libMesh::Point> > const*, std::vector<double, std::allocator<double> > const*)\n5: libMesh::FE<3u, (libMesh::FEFamily)2>::reinit(libMesh::Elem const*, unsigned int, double, std::vector<libMesh::Point, std::allocator<libMesh::Point> > const*, std::vector<double, std::allocator<double> > const*)\n6: Assembly::reinitFEFace(libMesh::Elem const*, unsigned int)\n7: Assembly::reinit(libMesh::Elem const*, unsigned int)\n8: GeometricSearchData::updateQuadratureNodes(unsigned int)\n9: GeometricSearchData::update(GeometricSearchData::GeometricSearchType)\n10: DisplacedProblem::updateMesh(bool)\n11: FEProblemBase::computeResidualTags(std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n12: FEProblemBase::computeResidualInternal(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n13: FEProblemBase::computeResidualSys(libMesh::NonlinearImplicitSystem&, libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&)\n14: ComputeResidualFunctor::residual(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, libMesh::NonlinearImplicitSystem&)\n15: libmesh_petsc_snes_residual\n16: SNESComputeFunction\n17: /home/adavis/opt/moose/petsc/arch-moose/lib/libpetsc.so.3.14(+0xbd87b2) [0x7f59f8db67b2]\n18: SNESLineSearchApply\n19: /home/adavis/opt/moose/petsc/arch-moose/lib/libpetsc.so.3.14(+0xc3c908) [0x7f59f8e1a908]\n20: SNESSolve\n21: libMesh::PetscNonlinearSolver<double>::solve(libMesh::SparseMatrix<double>&, libMesh::NumericVector<double>&, libMesh::NumericVector<double>&, double, unsigned int)\n22: libMesh::NonlinearImplicitSystem::solve()\n23: TimeIntegrator::solve()\n24: NonlinearSystem::solve()\n25: FEProblemBase::solve()\n26: FEProblemSolve::solve()\n27: PicardSolve::solveStep(double, double&, double, double&, bool, std::set<unsigned long, std::less<unsigned long>, std::allocator<unsigned long> > const&)\n28: PicardSolve::solve()\n29: TimeStepper::step()\n30: Transient::takeStep(double)\n31: Transient::execute()\n32: MooseApp::executeExecutioner()\n33: MooseApp::run()\n34: /home/adavis/opt/moose/modules/combined/combined-opt() [0x4032ab]\n35: __libc_start_main\n36: /home/adavis/opt/moose/modules/combined/combined-opt() [0x4034ee]\n[0] /home/adavis/opt/moose/scripts/../libmesh/src/fe/fe_map.C, line 1172, compiled Apr 29 2021 at 15:01:50\nWe caught a libMesh error in FEProblemBase\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 1\n Solve Did NOT Converge!\nAborting as solve did not converge\nUpdating displaced mesh                                 [  1.18 s]\nUpdating displaced mesh                                                                    [  1.13 s]\n\n\nNotice this time we got the warning about penetration that we didn't get in the serial run, and we got an extra bit of stack trace. Maybe in the parallel run it gets stuck generating the stack trace?",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-732535",
                          "updatedAt": "2022-06-11T10:34:52Z",
                          "publishedAt": "2021-05-13T07:47:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "That might be what's happening, so we should work on getting the serial run as good as we can before going back to parallel. If it's doing this without thermal contact, let's remove that and try a couple things:\n\nWhat happens when you apply the suggestion in the warning? patch_update_strategy=iteration I'm curious if the system thinking it should have made contact when it hasn't is causing the issue.\nHave you tried running this in a debugger to run a stack trace that way?",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-734060",
                          "updatedAt": "2022-06-11T10:35:23Z",
                          "publishedAt": "2021-05-13T14:20:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "So in serial it runs 'fine' we get through a number of failed step due to -ve jacbobians, then then timestep is small enough for the simulation to take 3 or 4 successful complete non-linear iterations. Either way, in parallel, the simulation just stops after the first time step.",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-737827",
                          "updatedAt": "2022-06-11T10:35:23Z",
                          "publishedAt": "2021-05-14T10:26:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "The negative Jacobians are a little bit troublesome, and do think it could be contributing to your parallel problems (stalling or getting hung up while doing the reporting and attempting to deal with it). Did you try either of the suggestions I gave? I'd really want to see if we could get a GDB/LLDB stack trace on that to supplement the info the standard trace is giving.",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-738806",
                          "updatedAt": "2022-06-11T10:35:23Z",
                          "publishedAt": "2021-05-14T14:46:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Maybe, but in other problems its worked absolutely fine",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-748035",
                          "updatedAt": "2022-06-11T10:35:23Z",
                          "publishedAt": "2021-05-17T13:12:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Help with contact",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "I've been playing unsuccessfully with contact for a few days now, its seems that for a given contact problem if I'm using displacement based input, i.e. I drive the bodies into contact by enforcing a time based displacment things generally work fine. When I come to do this with a force instead, I have immediate convergence failures. Could someone confirm the steps I should go through to turn a displacement based problem, into a force based problem?\nTake the example in modules/contact/test/tests/ring_contact, i turned this into a force based example and I have immediate convergence fails and -ve jacobians, usually the elements become hugely deformed (presumably) since they have a very large -ve y coordinate, e.g.\n  Elem Information\n   id()=0, unique_id()=322, processor_id()=0\n   type()=HEX20\n   dim()=3\n   n_nodes()=20\n    0  Node id()=0, processor_id()=0, Point=(x,y,z)=(       2, -3.78525e+15,      0.5)\n    DoFs=(0/0/0) (0/1/1) (0/2/2) (1/0/0) (1/1/1) (1/2/2) \n    1  Node id()=1, processor_id()=0, Point=(x,y,z)=(       2, -3.78525e+15,     -0.5)\n    DoFs=(0/0/3) (0/1/4) (0/2/5) (1/0/3) (1/1/4) (1/2/5) \n    2  Node id()=2, processor_id()=0, Point=(x,y,z)=(-211.815, -3.78525e+15,     -0.5)\n    DoFs=(0/0/6) (0/1/7) (0/2/8) (1/0/6) (1/1/7) (1/2/8) \n    3  Node id()=3, processor_id()=0, Point=(x,y,z)=(-216.919, -3.78525e+15,      0.5)\n    DoFs=(0/0/9) (0/1/10) (0/2/11) (1/0/9) (1/1/10) (1/2/11) \n    4  Node id()=4, processor_id()=0, Point=(x,y,z)=(0.694593, -3.78525e+15,      0.5)\n    DoFs=(0/0/12) (0/1/13) (0/2/14) (1/0/12) (1/1/13) (1/2/14) \n    5  Node id()=5, processor_id()=0, Point=(x,y,z)=(0.694593, -3.78525e+15,     -0.5)\n    DoFs=(0/0/15) (0/1/16) (0/2/17) (1/0/15) (1/1/16) (1/2/17) \n    6  Node id()=6, processor_id()=0, Point=(x,y,z)=(  -497.9, -3.78525e+15,     -0.5)\n    DoFs=(0/0/18) (0/1/19) (0/2/20) (1/0/18) (1/1/19) (1/2/20) \n    7  Node id()=7, processor_id()=0, Point=(x,y,z)=(-494.795, -3.78525e+15,      0.5)\n    DoFs=(0/0/21) (0/1/22) (0/2/23) (1/0/21) (1/1/22) (1/2/23) \n    8  Node id()=8, processor_id()=0, Point=(x,y,z)=(       2, -3.78525e+15, -1.71438)\n    DoFs=(0/0/24) (0/1/25) (0/2/26) (1/0/24) (1/1/25) (1/2/26) \n    9  Node id()=9, processor_id()=0, Point=(x,y,z)=(-84.9996, -3.78525e+15,     -0.5)\n    DoFs=(0/0/27) (0/1/28) (0/2/29) (1/0/27) (1/1/28) (1/2/29) \n    10  Node id()=10, processor_id()=0, Point=(x,y,z)=(-214.509, -3.78525e+15,  1.47086)\n    DoFs=(0/0/30) (0/1/31) (0/2/32) (1/0/30) (1/1/31) (1/2/32) \n    11  Node id()=11, processor_id()=0, Point=(x,y,z)=(-86.2479, -3.78525e+15,      0.5)\n    DoFs=(0/0/33) (0/1/34) (0/2/35) (1/0/33) (1/1/34) (1/2/35) \n    12  Node id()=12, processor_id()=0, Point=(x,y,z)=( 1.36808, -3.78525e+15,      0.5)\n    DoFs=(0/0/36) (0/1/37) (0/2/38) (1/0/36) (1/1/37) (1/2/38) \n    13  Node id()=13, processor_id()=0, Point=(x,y,z)=( 1.36808, -3.78525e+15,     -0.5)\n    DoFs=(0/0/39) (0/1/40) (0/2/41) (1/0/39) (1/1/40) (1/2/41) \n    14  Node id()=14, processor_id()=0, Point=(x,y,z)=(-369.114, -3.78525e+15,     -0.5)\n    DoFs=(0/0/42) (0/1/43) (0/2/44) (1/0/42) (1/1/43) (1/2/44) \n    15  Node id()=15, processor_id()=0, Point=(x,y,z)=(-367.026, -3.78525e+15,      0.5)\n    DoFs=(0/0/45) (0/1/46) (0/2/47) (1/0/45) (1/1/46) (1/2/47) \n    16  Node id()=16, processor_id()=0, Point=(x,y,z)=(0.694593, -3.78525e+15,  1.09482)\n    DoFs=(0/0/48) (0/1/49) (0/2/50) (1/0/48) (1/1/49) (1/2/50) \n    17  Node id()=17, processor_id()=0, Point=(x,y,z)=(-256.926, -3.78525e+15,     -0.5)\n    DoFs=(0/0/51) (0/1/52) (0/2/53) (1/0/51) (1/1/52) (1/2/53) \n    18  Node id()=18, processor_id()=0, Point=(x,y,z)=(-496.338, -3.78525e+15, -1.46908)\n    DoFs=(0/0/54) (0/1/55) (0/2/56) (1/0/54) (1/1/55) (1/2/56) \n    19  Node id()=19, processor_id()=0, Point=(x,y,z)=(-258.382, -3.78525e+15,      0.5)\n    DoFs=(0/0/57) (0/1/58) (0/2/59) (1/0/57) (1/1/58) (1/2/59) \n\nI did this using a nodal kernel on my real problem, and a body force on this one. Maybe I'm missing something fundamental?",
          "url": "https://github.com/idaholab/moose/discussions/17780",
          "updatedAt": "2022-07-12T14:04:47Z",
          "publishedAt": "2021-05-09T14:53:02Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad Can you help out please?",
                  "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-729551",
                  "updatedAt": "2022-07-12T14:04:56Z",
                  "publishedAt": "2021-05-12T14:40:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Looks like this is kinematic node-face contact. I think @bwspenc or maybe @recuero are better resources for this",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-729897",
                          "updatedAt": "2022-07-12T14:04:54Z",
                          "publishedAt": "2021-05-12T15:39:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "First thing I'd check is if you have rigid body modes in your problem. That can potentially happen when you go from controlling a body's displacement to just applying a force.",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-730035",
                          "updatedAt": "2022-07-12T14:04:56Z",
                          "publishedAt": "2021-05-12T16:04:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Not for the ring contact problem, but my 'real' problem I did fix the displacement of the moving body in the y direction to make sure it would move only down and out and nothing perpendicular, you would recommend a further constraint?",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-730057",
                          "updatedAt": "2022-07-12T14:04:56Z",
                          "publishedAt": "2021-05-12T16:07:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "If I understand well, you are fixing the directions perpendicular to the motion, so that makes sense to me. I'd also check that you are not getting rigid body rotations. Finally, when you apply the force, I'd make sure the surfaces are into contact. You can make this happen by using MOOSE's controls. You use displacement control until the bodies come (slightly) into contact, then, switch to force control.",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-730401",
                          "updatedAt": "2022-07-12T14:06:00Z",
                          "publishedAt": "2021-05-12T17:29:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Ah \"I'd make sure the surfaces are into contact. You can make this happen by using MOOSE's controls. You use displacement control until the bodies come (slightly) into contact, then, switch to force control.\" this could well be it, I have a large (by contact standards - 10 cm or so) between my components, which are fine when displaced. Its not clear how I would switch between displacement control and force control?",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-731014",
                          "updatedAt": "2022-07-12T14:06:04Z",
                          "publishedAt": "2021-05-12T20:44:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "You can define both the displacement BC and an external force. Then, when in contact, disable the displacement BC, and the body will be driven solely by the external force. A partial example below, documentation on MOOSE controls system here.\n  [period0]\n    type = TimePeriod\n    disable_objects = 'BCs::top_disp_z'\n    start_time = '1.0' \n    end_time = '70.0'\n    execute_on = 'initial timestep_begin linear nonlinear timestep_end'\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-731092",
                          "updatedAt": "2022-07-12T14:06:00Z",
                          "publishedAt": "2021-05-12T21:10:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Ah ok, thats helpful. A little painful though if there are lots of contacts, if we have a complex system, we often only have force based constraints, conceptually, driven displacements as a function of time are equivalent to the accelerations right? Shouldn't it be possible to determine the displacement given a force (acceleration)?",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-737894",
                          "updatedAt": "2022-07-12T14:06:02Z",
                          "publishedAt": "2021-05-14T10:41:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "driven displacements as a function of time are equivalent to the accelerations right?\n\nAre you referring to dynamics? In dynamics, if you apply a force, you'll get corresponding nodal accelerations and, given enough proximity between the bodies in contact, everything would work out. If you apply a force in quasi-static simulations, and there are rigid bodies in the system, results aren't usually good.\n\nShouldn't it be possible to determine the displacement given a force (acceleration)?\n\nIf you have contact, then you'll need to use contact formulations to determine the states and displacements of the nodes in contact.",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-748396",
                          "updatedAt": "2022-07-12T14:06:39Z",
                          "publishedAt": "2021-05-17T14:34:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to install MOOSE on ARM64 HPC with Fujitsu A64FX cpu?",
          "author": {
            "login": "zhang-rite"
          },
          "bodyText": "Hi MOOSE developer,\nIs there a method for installing MOOSE on ARM64 HPC with Fujitsu A64FX CPU?\nFor the ARM64 architecture, the options for compiling may need to change but I don't know how to do it. I have tried following the installation guide hpc_install_moose but not successful.\nThe HPC has a Fujitsu compiler \"Fujitsu Development Studio\".\nGCC 11 may also work but I haven't tested it yet.\nDoes anyone have the experience? or give any suggestion? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/17855",
          "updatedAt": "2022-11-07T16:53:10Z",
          "publishedAt": "2021-05-17T08:50:08Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "We have no instructions for supporting ARM, but several folks over the years have successfully built MOOSE on such an architecture (Raspberry Pi, Beaglebone, etc). Almost always it will be about building everything from scratch (GCC, MPICH, their dependencies, etc). And when you do hit a failure along the way, you take those errors and look them up on the internet for a possible solution. Your google-fu will be tested!\nIt will certainly be an adventure, with no quick path forward...",
                  "url": "https://github.com/idaholab/moose/discussions/17855#discussioncomment-747970",
                  "updatedAt": "2022-11-07T16:53:10Z",
                  "publishedAt": "2021-05-17T12:58:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "I've built it on the cavium thunder x2, and it was fine, just stick to the gcc toolchain and I think you'll be fine.",
                          "url": "https://github.com/idaholab/moose/discussions/17855#discussioncomment-747999",
                          "updatedAt": "2022-11-07T16:53:10Z",
                          "publishedAt": "2021-05-17T13:04:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Shikhar installed MOOSE on an ARM 64 architecture and explained the steps in this thread\n#17416",
                  "url": "https://github.com/idaholab/moose/discussions/17855#discussioncomment-748307",
                  "updatedAt": "2022-11-07T16:53:44Z",
                  "publishedAt": "2021-05-17T14:15:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Simple subdomain remeshing",
          "author": {
            "login": "dealmeidavf"
          },
          "bodyText": "Hello,\nThis x-direction subdomain partition of the mesh\n[Mesh]\n  [generated_mesh]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 4\n    ny = 4\n  []\n  [block1]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 1\n    bottom_left = '0 0 0'\n    top_right = '0.5 1 0'\n    input = generated_mesh\n  []\n  [block2]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 2\n    bottom_left = '0.5 0 0'\n    top_right = '1 1 0'\n    input = block1\n  []\n[]\n\nleaves the blocks with equal number of elements (2x4). How do I change the number of elements in the x direction for each block?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/17853",
          "updatedAt": "2022-07-19T19:27:30Z",
          "publishedAt": "2021-05-16T19:25:49Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The Cartesian mesh generator will do both block assignment and specifying the number of elements for each block.\nhttps://mooseframework.inl.gov/source/meshgenerators/CartesianMeshGenerator.html\nOr are you asking for the general mesh case?",
                  "url": "https://github.com/idaholab/moose/discussions/17853#discussioncomment-745471",
                  "updatedAt": "2022-07-19T19:27:31Z",
                  "publishedAt": "2021-05-16T19:39:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dealmeidavf"
                          },
                          "bodyText": "Thanks. I will check this option. I have been using SubdomainBoundingBoxGenerator for problems with interfaces as this is used in the examples. I suppose the CartesianMeshGenerator can also be used but I have not seen an example of interface problems using it.\nYes the question was for Cartesian meshes as generated by GeneratedMeshGenerator.",
                          "url": "https://github.com/idaholab/moose/discussions/17853#discussioncomment-745623",
                          "updatedAt": "2022-07-19T19:27:31Z",
                          "publishedAt": "2021-05-16T20:55:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dealmeidavf"
                          },
                          "bodyText": "It seems that CartesianMeshGenerator does not accept an elem_type parameter as GeneratedMeshGenerator does, therefore I can't use it with second order finite elements. I guess the way to do this is to create two meshes using GeneratedMeshGenerator and stitch them together?",
                          "url": "https://github.com/idaholab/moose/discussions/17853#discussioncomment-745777",
                          "updatedAt": "2022-07-19T19:27:38Z",
                          "publishedAt": "2021-05-16T22:29:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you can make it second order by specifying second_order = true under Mesh, so\n[Mesh]\n  second_order = true\n  [cmg]\n    type = CartesianMeshGenerator\n ...\n\ncould you please try that?\nStitching two meshes can also work",
                          "url": "https://github.com/idaholab/moose/discussions/17853#discussioncomment-746294",
                          "updatedAt": "2022-07-19T19:27:32Z",
                          "publishedAt": "2021-05-17T04:19:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dealmeidavf"
                          },
                          "bodyText": "I created two meshes with GeneratedMeshGenerator and stitched them with StitchedMeshGenerator.\nThanks for the help.",
                          "url": "https://github.com/idaholab/moose/discussions/17853#discussioncomment-748198",
                          "updatedAt": "2022-10-10T17:01:35Z",
                          "publishedAt": "2021-05-17T13:49:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "XCode 12.4 resulting in \"Clang frontend command failed due to signal compilation error\"",
          "author": {
            "login": "JoshuaHalsted"
          },
          "bodyText": "Hello,\nI am also having the same issues. However, when I uninstalled XCode 12.5 and installed XCode 12.4, I get essentially the same problem. I made sure that XCode was installed properly and was able to open the application.\nI've attached the complete output message when I try to run the \"make -j 4\" command as specified in the tutorial.\nThanks,\nJosh\nUsing HIT from /Users/joshhalsted/projects/moose/framework/contrib/hit\nCompiling C++ (in opt mode) /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.C...\nIn file included from /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.C:2:\nIn file included from /Users/joshhalsted/projects/moose/framework/src/linesearches/LineSearch.C:10:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/LineSearch.h:12:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/MooseObject.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/InputParameters.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/MooseUtils.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/HashMap.h:13:\nIn file included from /Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include/libmesh/threads.h:24:\nIn file included from /Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include/libmesh/libmesh_common.h:36:\nIn file included from /Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:85:\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/stdlib.h:142:34: error: unknown type name 'ldiv_t'\ninline _LIBCPP_INLINE_VISIBILITY ldiv_t div(long __x, long __y) _NOEXCEPT {\n^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/stdlib.h:143:12: error: no member named 'ldiv' in the global namespace\nreturn ::ldiv(__x, __y);\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/stdlib.h:146:34: error: unknown type name 'lldiv_t'\ninline _LIBCPP_INLINE_VISIBILITY lldiv_t div(long long __x,\n^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/stdlib.h:148:12: error: no member named 'lldiv' in the global namespace\nreturn ::lldiv(__x, __y);\n~~^\nIn file included from /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.C:2:\nIn file included from /Users/joshhalsted/projects/moose/framework/src/linesearches/LineSearch.C:10:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/LineSearch.h:12:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/MooseObject.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/InputParameters.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/MooseUtils.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/HashMap.h:13:\nIn file included from /Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include/libmesh/threads.h:24:\nIn file included from /Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include/libmesh/libmesh_common.h:36:\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:99:9: error: no member named 'size_t' in the global namespace\nusing ::size_t;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib\ud83d\udcaf9: error: no member named 'div_t' in the global namespace\nusing ::div_t;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:101:9: error: no member named 'ldiv_t' in the global namespace\nusing ::ldiv_t;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:103:9: error: no member named 'lldiv_t' in the global namespace\nusing ::lldiv_t;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:105:9: error: no member named 'atof' in the global namespace\nusing ::atof;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:106:9: error: no member named 'atoi' in the global namespace\nusing ::atoi;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:107:9: error: no member named 'atol' in the global namespace\nusing ::atol;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:109:9: error: no member named 'atoll' in the global namespace\nusing ::atoll;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:111:9: error: no member named 'strtod' in the global namespace\nusing ::strtod;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:112:9: error: no member named 'strtof' in the global namespace\nusing ::strtof;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:113:9: error: no member named 'strtold' in the global namespace\nusing ::strtold;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:114:9: error: no member named 'strtol' in the global namespace\nusing ::strtol;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:116:9: error: no member named 'strtoll' in the global namespace\nusing ::strtoll;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:118:9: error: no member named 'strtoul' in the global namespace\nusing ::strtoul;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:120:9: error: no member named 'strtoull' in the global namespace\nusing ::strtoull;\n~~^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace, preprocessed source, and associated run script.\nStack dump:\n0. Program arguments: x86_64-apple-darwin13.4.0-clang++ -march=core2 -mtune=haswell -std=gnu++17 -DNDEBUG -Wall -Wextra -DADFPARSER_INCLUDES=\"-I/Users/joshhalsted/projects/moose/framework/include/utils -I/Users/joshhalsted/projects/moose/framework/include/base -I/Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include\" -DMOOSE_TEST_ENABLED -march=core2 -mtune=haswell -mssse3 -ftree-vectorize -fPIC -fstack-protector-strong -O2 -pipe -stdlib=libc++ -fvisibility-inlines-hidden -std=c++14 -fmessage-length=0 -isystem /Users/joshhalsted/opt/anaconda3/envs/moose/include -O2 -felide-constructors -Qunused-arguments -Wunused-parameter -Wunused -fopenmp -DMETHOD=opt -Werror=return-type -Werror=reorder -Woverlength-strings -I/Users/joshhalsted/projects/moose/framework/build/header_symlinks -I/Users/joshhalsted/projects/moose/framework/contrib/boost/include -I/Users/joshhalsted/projects/moose/framework/contrib/json/include -I/Users/joshhalsted/projects/moose/framework/contrib/json/include/nlohmann -I/Users/joshhalsted/projects/moose/framework/contrib/mtwist/include -I/Users/joshhalsted/projects/moose/framework/contrib/pcre/include -I/Users/joshhalsted/projects/moose/framework/contrib/pugixml/include -I/Users/joshhalsted/projects/moose/framework/contrib/tinydir/include -I/Users/joshhalsted/projects/moose/framework/contrib/gtest -I/Users/joshhalsted/projects/moose/framework/contrib/hit -I/Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include -I/Users/joshhalsted/opt/anaconda3/envs/moose/libmesh-vtk/include/vtk-6.3 -D_THREAD_SAFE -pthread -I/Users/joshhalsted/opt/anaconda3/envs/moose/include -I/Users/joshhalsted/opt/anaconda3/envs/moose//include -I/Users/joshhalsted/projects/moose/test/build/header_symlinks -I/Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include -I/Users/joshhalsted/opt/anaconda3/envs/moose/libmesh-vtk/include/vtk-6.3 -D_THREAD_SAFE -pthread -I/Users/joshhalsted/opt/anaconda3/envs/moose/include -I/Users/joshhalsted/opt/anaconda3/envs/moose//include -MMD -MP -MF /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.x86_64-apple-darwin13.4.0.opt.lo.d -MT /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.x86_64-apple-darwin13.4.0.opt.lo -c /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.C -fno-common -DPIC -o /Users/joshhalsted/projects/moose/framework/build/unity_src/.libs/linesearches_Unity.x86_64-apple-darwin13.4.0.opt.o -I/Users/joshhalsted/opt/anaconda3/envs/moose/include\nparser at end of file\n0 libLLVM-11.dylib 0x000000010d212c16 llvm::sys::PrintStackTrace(llvm::raw_ostream&) + 54\n1 libLLVM-11.dylib 0x000000010d211a08 llvm::sys::RunSignalHandlers() + 248\n2 libLLVM-11.dylib 0x000000010d212142 llvm::sys::CleanupOnSignal(unsigned long) + 258\n3 libLLVM-11.dylib 0x000000010d13a24e CrashRecoverySignalHandler(int) + 206\n4 libsystem_platform.dylib 0x00007fff2053dd7d _sigtramp + 29\n5 libclang-cpp.11.dylib 0x0000000109cde075 clang::EvaluatedExprVisitorBase<std::__1::add_pointer, (anonymous namespace)::DeferredDiagnosticsEmitter>::VisitStmt(clang::Stmt*) + 133\n6 libclang-cpp.11.dylib 0x0000000109703c5f clang::ASTContext::getBaseElementType(clang::QualType) const + 47\n7 libclang-cpp.11.dylib 0x0000000109cdd56a clang::StmtVisitorBase<std::__1::add_pointer, (anonymous namespace)::DeferredDiagnosticsEmitter, void>::Visit(clang::Stmt*) + 1418\n8 libclang-cpp.11.dylib 0x0000000109cde075 clang::EvaluatedExprVisitorBase<std::__1::add_pointer, (anonymous namespace)::DeferredDiagnosticsEmitter>::VisitStmt(clang::Stmt*) + 133\n9 libclang-cpp.11.dylib 0x0000000109cde075 clang::EvaluatedExprVisitorBase<std::__1::add_pointer, (anonymous namespace)::DeferredDiagnosticsEmitter>::VisitStmt(clang::Stmt*) + 133\n10 libclang-cpp.11.dylib 0x0000000109cde075 clang::EvaluatedExprVisitorBase<std::__1::add_pointer, (anonymous namespace)::DeferredDiagnosticsEmitter>::VisitStmt(clang::Stmt*) + 133\n11 libclang-cpp.11.dylib 0x0000000109cdcaef (anonymous namespace)::DeferredDiagnosticsEmitter::checkFunc(clang::SourceLocation, clang::FunctionDecl*) + 1695\n12 libclang-cpp.11.dylib 0x0000000109cd2bbb clang::Sema::emitDeferredDiags() + 379\n13 libclang-cpp.11.dylib 0x0000000109cd1e40 clang::Sema::ActOnEndOfTranslationUnitFragment(clang::Sema::TUFragmentKind) + 576\n14 libclang-cpp.11.dylib 0x0000000109cd2e59 clang::Sema::ActOnEndOfTranslationUnit() + 345\n15 libclang-cpp.11.dylib 0x00000001096e5de3 clang::Parser::ParseTopLevelDecl(clang::OpaquePtrclang::DeclGroupRef&, bool) + 1267\n16 libclang-cpp.11.dylib 0x000000010962970d clang::ParseAST(clang::Sema&, bool, bool) + 525\n17 libclang-cpp.11.dylib 0x000000010af0b5b8 clang::FrontendAction::Execute() + 104\n18 libclang-cpp.11.dylib 0x000000010ae9c721 clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) + 2145\n19 libclang-cpp.11.dylib 0x000000010af7d06e clang::ExecuteCompilerInvocation(clang::CompilerInstance*) + 1998\n20 x86_64-apple-darwin13.4.0-clang++ 0x00000001094d8d53 cc1_main(llvm::ArrayRef<char const*>, char const*, void*) + 2131\n21 x86_64-apple-darwin13.4.0-clang++ 0x00000001094d6e35 ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&) + 357\n22 libclang-cpp.11.dylib 0x000000010ab376c7 void llvm::function_ref<void ()>::callback_fn<clang::driver::CC1Command::Execute(llvm::ArrayRef<llvm::Optionalllvm::StringRef >, std::__1::basic_string<char, std::__1::char_traits, std::__1::allocator >, bool) const::$_1>(long) + 23\n23 libLLVM-11.dylib 0x000000010d139fda llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) + 218\n24 libclang-cpp.11.dylib 0x000000010ab36a65 clang::driver::CC1Command::Execute(llvm::ArrayRef<llvm::Optionalllvm::StringRef >, std::__1::basic_string<char, std::__1::char_traits, std::__1::allocator >, bool) const + 405\n25 libclang-cpp.11.dylib 0x000000010ab03cf1 clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&) const + 433\n26 libclang-cpp.11.dylib 0x000000010ab0426c clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::__1::pair<int, clang::driver::Command const*> >&) const + 140\n27 libclang-cpp.11.dylib 0x000000010ab1ddec clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::1::pair<int, clang::driver::Command const*> >&) + 428\n28 x86_64-apple-darwin13.4.0-clang++ 0x00000001094d67c8 main + 10264\n29 libdyld.dylib 0x00007fff20513f3d start + 1\nclang-11: error: clang frontend command failed due to signal (use -v to see invocation)\nclang version 11.0.0\nTarget: x86_64-apple-darwin13.4.0\nThread model: posix\nInstalledDir: /Users/joshhalsted/opt/anaconda3/envs/moose/bin\nclang-11: note: diagnostic msg:\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\nPreprocessed source(s) and associated run script(s) are located at:\nclang-11: note: diagnostic msg: /var/folders/qr/b09rm3rs6hz9c18pp3_301jm0000gn/T/linesearches_Unity-9916ec.cpp\nclang-11: note: diagnostic msg: /var/folders/qr/b09rm3rs6hz9c18pp3_301jm0000gn/T/linesearches_Unity-9916ec.sh\nclang-11: note: diagnostic msg: Crash backtrace is located in\nclang-11: note: diagnostic msg: /Users/joshhalsted/Library/Logs/DiagnosticReports/clang-11.crash\nclang-11: note: diagnostic msg: (choose the .crash file that corresponds to your crash)\nclang-11: note: diagnostic msg:\nmake: *** [/Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.x86_64-apple-darwin13.4.0.opt.lo] Error 1\n(moose) Joshs-MacBook-Air:test joshhalsted$",
          "url": "https://github.com/idaholab/moose/discussions/17850",
          "updatedAt": "2022-06-23T21:58:17Z",
          "publishedAt": "2021-05-15T23:23:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "JoshuaHalsted"
                  },
                  "bodyText": "I was able to resolve the problem. I had to dig around my drive using OmniDiskSweeper to find any evidence that a previous version of XCode was being used (even though I had uninstalled it and the CommandLineTools prior). There was a folder called \"Xcode\" in the /Library/Developer/CommandLineTools path, which I deleted (I didn't previously) and, upon full installation of 12.4, was able to successfully run the tests.",
                  "url": "https://github.com/idaholab/moose/discussions/17850#discussioncomment-743533",
                  "updatedAt": "2022-10-04T04:45:42Z",
                  "publishedAt": "2021-05-16T05:01:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "This is good to know! Thank you for posting!",
                          "url": "https://github.com/idaholab/moose/discussions/17850#discussioncomment-747979",
                          "updatedAt": "2022-10-04T04:45:45Z",
                          "publishedAt": "2021-05-17T13:00:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Adding a kernel with two or more variables",
          "author": {
            "login": "iampham"
          },
          "bodyText": "Hello,\nI've been trying to implement the following expression into my residual:\n\nwhere phi_i is the main \"variable\" in the sense of what you'd put in a default MOOSE kernel. However, I want to find the variational derivative of a function with respect to another variable phi_j, and add the term into the same residual that acts on the variable phi_i. These parameters are individually defined in the Variables system.\nAdding the variational derivative of F with respect to phi_i is already implemented in MOOSE's PhaseField module (AllenCahn.c). However, I believe I need to create my own file to add the variational derivative of F with respect to phi_j into the residual. This process doesn't seem trivial to me because I'm not familiar with what the constructors for a kernel do when they take variables as input.\nI have two questions regarding this process.\n\nDoes MOOSE create a unique residual for each variable defined in the variables system? Or do they get added into some global residual?\nHow can I add an additional variable as input into the kernel? If I do this, how can I refer to it in the .C file? For instance, a variable in a kernel usually gets referred to as _var.name(). If I add a second variable variable2, is there a get function that I can easily use?\n\nI've been poring through the documentation for an answer, but this seems like enough of an edge case to make it difficult to find. If you have a link to the relevant documentation, please let me know it!\nThank you for your help!\nEDIT: Just in case anybody stumbles across this problem, I found an additional useful page that describes how MOOSE variables work: https://mooseframework.inl.gov/source/variables/MooseVariableBase.html",
          "url": "https://github.com/idaholab/moose/discussions/17524",
          "updatedAt": "2022-06-15T14:05:10Z",
          "publishedAt": "2021-04-07T02:09:58Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "I will try answering your questions:\n\nresidual vector is composed of parts of number of variables, each for a primal (with respect to auxiliary) variable.\nnormal kernel can only evaluate residual contributions on local elements for one variable, specified by variable parameter. If you want a kernel to operate on multiple variables, you can consider array variable/kernel (documented here: https://mooseframework.inl.gov/source/variables/ArrayMooseVariable.html).\n\nHope these help.",
                  "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-582339",
                  "updatedAt": "2022-06-17T14:01:51Z",
                  "publishedAt": "2021-04-08T00:06:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "iampham"
                          },
                          "bodyText": "Thank you for the answer! I took a look at the documentation and I think this is what I had in mind.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-585040",
                          "updatedAt": "2022-06-17T14:01:53Z",
                          "publishedAt": "2021-04-08T13:53:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "It is good that I find this discussion. I'm thinking about implemeningt a tensor mechanics kernel. In my case, I need disp_x, disp_y and disp_z as a vector together. I had a look of the current tensor mechanics kernel StressDivergenceTensors.C. It basically handles disp_x, disp_y and disp_z separately. The function computeOffDiagJacobian is used 9 times for each element for the combination of 3 variables disp_x, disp_y, and disp_z. It seems to be not the optimal way to do it and it also does not fit my need.\nWith the new Arraykernel, it seems to be a better kernel type for tensor mechanics. I should be able to implement my case. Is this the intension of this type of kernel? @YaqiWang",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-693960",
                          "updatedAt": "2022-06-17T14:02:17Z",
                          "publishedAt": "2021-05-04T15:37:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "We developed ArrayKernel for operating array variables that can potentially have hundreds of components. But I think it can find usages for with a few or several components. It can make relevant codes organized together thus easier to maintain. Even with a small number of components, we do not see performance degradation. So I think you can go ahead.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-694126",
                          "updatedAt": "2022-06-17T14:02:24Z",
                          "publishedAt": "2021-05-04T16:01:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "Another questions: What is the difference between ArrayKernel and VectorKernel?  Is the variable used by them be used by things like BCs, Pressure, etc.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-694129",
                          "updatedAt": "2023-02-08T13:08:17Z",
                          "publishedAt": "2021-05-04T16:02:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Array kernels require array variables whose components must be in the same family and order. Vector kernels require a vector variable in a specific type with number of components being space dimension. I think vector kernels are designed for some specific problems, @lindsayad can possibly answer this better. We have BCs, kernels, etc. for both array and vector variables.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-694160",
                          "updatedAt": "2023-02-08T13:08:28Z",
                          "publishedAt": "2021-05-04T16:10:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@dzheng-conti I think you should use VectorKernel for vector version ofStressDivergenceTensors  because that is supposed to work with VectorVariable.  You can take a look at INSADMomentumViscous on how VectorKernel can be used.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-694162",
                          "updatedAt": "2023-02-08T13:08:28Z",
                          "publishedAt": "2021-05-04T16:11:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "Thanks a lot! @YaqiWang  @jiangwen84",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-694178",
                          "updatedAt": "2023-02-08T13:08:29Z",
                          "publishedAt": "2021-05-04T16:13:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "I had a look of the VectorKernal and ArrayKernal examples and I had another questions need your help.\nMy question is that can I use one component of a Vector or Array variable for the scalerKernel (scalerClass).\nIn tensormechanics module, there are many Classes defined for things like material models, pressure loads, contact etc. They all expect scaler (LAGRANGE) variables, say disp_x, disp_y, and disp_z. If I write a VectorKernel for  StressVivergenceTensors, it expects a vector (LAGRANGE_VEC) variable, say disp. If I want to use the already defined Classes in combination of my new VectorKernel, how can I let Moose know that disp_x, disp_y, and disp_z are the three components of disp?",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-719468",
                          "updatedAt": "2023-02-08T13:08:31Z",
                          "publishedAt": "2021-05-10T16:38:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I'd have to see your weak form to really understand what you want to do. But you can always create a vector in your computeQpResidual statement from scalar components like so:\nRealVectorValue disp_vec(_disp_x[_qp], _disp_y[_qp], _disp_z[_qp]);",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-725383",
                          "updatedAt": "2023-02-08T13:08:38Z",
                          "publishedAt": "2021-05-11T18:34:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "@lindsayad. Thanks for the reply. I will try to explain what I mean with an example.\nCurrently in TensorMechanics module, all the classes are using standard variables. To do a simulation with gravity load for example, the input file is something like (I show the input file without using action)\n[Variables]\n  [./disp_x]\n    family = LAGRANGE\n  [../]\n  [./disp_y]\n    family = LAGRANGE\n  [../]\n  [./disp_z]\n    family = LAGRANGE\n  [../]\n[]\n[Kernels]\n  [elements_x]\n    type = StressDivergenceTensors\n    component = 0\n    variable = disp_x\n  []\n  [elements_y]\n    type = StressDivergenceTensors\n    component = 1\n    variable = disp_y\n  []\n  [elements_z]\n    type = StressDivergenceTensors\n    component = 2\n    variable = disp_z\n  []\n  [gravity_z]\n    type = Gravity\n    variable = disp_z\n    value = -1.0e-3\n    function = load\n  []\n[]\n\nThree standard variables are defined to representing the displacement vector. The variables are then used for StressDivergenceTensor and for Gravity. For one element, the computerOffDiagJacobian of StressDivergenceTensor is used 9 times (loops i_var=disp_x, disp_y, disp_z and j_var=disp_x, disp_y, disp_z) to compute the full jacobian. In other words, for Hex8 element, the full jacobian is a 24x24 matrix. Each call of  computerOffDiagJacobian  generates only an 8x8 submatrix of the full jacobian.\nFor my case,  I cannot compute the 8x8 submatrix for disp_x if disp_y and disp_z is not available. I need disp_x, disp_y and disp_z together so that I can calculate the 24x24 full jacobian in one call of computeJacobian.  I thought that I can write a VectorStressDivergenceTensor.  Then the input file can become something like\n[Variables]\n  [./dispvec]\n    family = LAGRANGE_VEC\n  [../]\n[]\n\n[Kernels]\n  [elements]\n    type = VectorStressDivergenceTensors\n    variable = dispvec\n  []\n[]\n\nThe full jacobian can be calculated with one call of computeJacobian since all three components are represented by dispvec\nMy problem come from the things like the Gravity kernel. There, variable= expects a standard variable representing displacement in one (say z) direction. With vector kernel, my displacement is defined as vector variable. Is there a way to pass one component of the vector variable dispvec to the Gravity kernel which needs a standard variable?\n[Variables]\n  [./dispvec]\n    family = LAGRANGE_VEC\n  [../]\n[]\n[Kernels] \n  ...\n  [gravity_z]\n    type = Gravity\n    variable = ? ## what should be here?\n    value = -1.0e-3\n    function = load\n  []\n[]\n\nWithout this function, it seems to me that I cannot use a vector kernel in combination of other classes in the TensorMechanics module which use standard variable. There are many of them (Gravity, Pressure, Contact, etc.) already defined. It is a lot of work if we have to rewrite them to use vector variable.\nIn fact, it should be also fine if we can use 3 standard variables instead of a vector variable for VectorKernel. Libmesh example \"examples/systems_of_equations/systems_of_equations_ex7\" seems did it this way.\nThanks for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-729213",
                          "updatedAt": "2023-02-08T13:08:39Z",
                          "publishedAt": "2021-05-12T13:36:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MultiApp Transfer to nearest node only",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hi everyone,\n@lynnmunday , @cbolisetti , @rpodgorney , KT and I are working on simulating flow through fractured porous media using a MultiApp approach.  In this work, the \"fracture\" is a 2D mesh living within the \"matrix\", which is a 3D mesh.  The fracture nodes/elements don't usually conform with the matrix nodes/elements.\nI can pass information from the matrix to the fracture using, eg, MultiAppNearestNodeTransfer or MultiAppInterpolationTransfer.  These Transfers put a value at each node of the fracture mesh from the nearest node of the matrix mesh (or interpolate a few matrix values in the case of InterpolationTransfer).\nI need to pass information from the fracture to the matrix.  Physically, heat is flowing from the fracture to the matrix.  Each node of the fracture should pass information (heat) to one node of the matrix only : the matrix node nearest to the fracture node.  Using a MultiAppNearestNodeTransfer does not achieve this, for all nodes of the matrix get a value (heat) from their nearest fracture node.  There are other possibilities that would also work, for instance, passing information from each of the fracture nodes to nodes of the matrix element that contains the fracture node.  I also have to be careful that many fracture nodes may be close to a single matrix node (in which case the transferred thing - heat energy - would have to be summed, just like putting lots of DiracKernels inside a single element).  But before considering these subtleties, i wanted to ask:\nDoes MOOSE or one of its Apps have anything like this, or can you see another approach that would work ?\na",
          "url": "https://github.com/idaholab/moose/discussions/17806",
          "updatedAt": "2022-06-13T23:58:08Z",
          "publishedAt": "2021-05-12T00:45:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "vincentlaboure"
                  },
                  "bodyText": "Would MultiApps/*/bounding_box_padding help with your need?",
                  "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-729297",
                  "updatedAt": "2022-06-13T23:58:14Z",
                  "publishedAt": "2021-05-12T13:57:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thanks @vincentlaboure - this might be the kind of thing i'm looking for.  I couldn't get it to work as desired in simple cases, but, regardless, in complicated-mesh cases, i suspected the \"padding\" and \"inflation\" would have to be dependent on the matrix mesh.  Eg, some of the fracture nodes might be very close to a matrix node, meaning the padding&inflation needs to be small for them, while other fracture nodes would need more padding&inflation because they're a long distance from any matrix node",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-731128",
                          "updatedAt": "2022-06-13T23:58:15Z",
                          "publishedAt": "2021-05-12T21:20:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@WilkAndy I had a similar (though different in a way) problem, need to compute and pass back and forth traction stresses from matrix elements to frac elements and the other way around (slip modelling). What I did was to compute (via an UO, but can be done in a Multiapp as well) a map among those and use that for passing the information.  In my case all is comforming, that is there are max 2 3D elements per each 2D elements, and the geometry does not change, but the map could be extended to more complicated cases (I fill in vectors of ids) and for evolving geometries (by running the map during run time and not on initialization as I am doing). The only caveat here is that my mapping is not 100% thread safe and so far works only on serial meshes (did not have enough time/man power to generalize it). In case I could share my piece of code (would be lovely to have it smarten). Hope this helps, mauro",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-732909",
                          "updatedAt": "2022-06-13T23:58:15Z",
                          "publishedAt": "2021-05-13T09:29:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thank @mcacace , that could be good.  The team is meeting in about 12 hours and we'll discuss this in detail - i'll get back to you if we end up needing this feature.",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-732940",
                          "updatedAt": "2022-06-13T23:58:16Z",
                          "publishedAt": "2021-05-13T09:38:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Does DiracKernel work? It seems you have considered it but I am curious why it doesn't satisfy your needs.",
                  "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-733694",
                  "updatedAt": "2022-06-13T23:58:15Z",
                  "publishedAt": "2021-05-13T12:59:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "We are using the porousFlowHeatMassTransfer kernel where we apply the temperature difference between the fracture and matrix times a heat transfer coefficient.  It is easy to pass the temperature back and forth between the apps but if we use the diracKernel, we would need to compute a heat flux and pass that.  Maybe we could compute that from the temperature difference in the same way. Would you suggest making a diracKernel for each node on the subapp and passing that point along with a flux to the main app using a reporter?",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-735922",
                          "updatedAt": "2022-06-13T23:58:16Z",
                          "publishedAt": "2021-05-13T21:54:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Lynn, it doesn't have to be all that complicated. I took a look at PorousFlowHeatMassTransfer, basically all you want is a coupled variable v which is temperature or whatever information from the lower dimensional domain, right? There is a very simple trick to do that. It is very similar to an L2-projection, but you replace the source term with discrete approximations using DiracKernel.\nI quickly put together a test in moose, and it is performing well. I first manufacture a field (suppose that is the information from the lower dimensional domain), then I sample the field value at N points and reconstruct the field onto the matrix mesh using this trick. Some results are here:\n\nI am only using 20 elements in the matrix mesh, and with 64 sampling points from the lower dimensional domain, the error is already negligible. That corresponds to 2~3 points per element, which is pretty cheap. If you think this could work, we can discuss offline.",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736167",
                          "updatedAt": "2022-06-13T23:58:16Z",
                          "publishedAt": "2021-05-13T23:37:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Per our discussion, this is input file I used:\n[Mesh]\n  [gmg]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmax = 20\n    ymax = 1\n    nx = 20\n    ny = 1\n  []\n[]\n[Variables]\n  [T]\n  []\n[]\n[Kernels]\n  [react]\n    type = Reaction\n    variable = T\n  []\n[]\n[DiracKernels]\n  [projection]\n    type = VectorPostprocessorPointSource\n    variable = T\n    vector_postprocessor = data\n  []\n[]\n[VectorPostprocessors]\n  [data]\n    type = CSVReader\n    csv_file = data_${N}.csv\n    outputs = none\n  []\n  [T]\n    type = LineValueSampler\n    variable = T\n    start_point = '0 0.5 0'\n    end_point = '20 0.5 0'\n    num_points = 200\n    sort_by = x\n  []\n[]\n[Executioner]\n  type = Steady\n[]\n[Outputs]\n  file_base = T_${N}\n  [csv]\n    type = CSV\n    execute_vector_postprocessors_on = FINAL\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736210",
                          "updatedAt": "2022-06-13T23:58:17Z",
                          "publishedAt": "2021-05-14T00:02:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "@WilkAndy I think @hugary1995 method will be really easy to try out and I think its probably going to work better than a nodal transfer",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736244",
                          "updatedAt": "2022-10-18T18:24:20Z",
                          "publishedAt": "2021-05-14T00:15:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "How is this going to work for complicated fractures?  As i understand it, each fracture node becomes a DiracKernel in the matrix.  So it looks like you have to pre-define the position of each fracture (or fracture node), which will be difficult and annoying for users.  Also difficult when mesh adaptivity is used?",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736284",
                          "updatedAt": "2022-10-18T18:24:20Z",
                          "publishedAt": "2021-05-14T00:31:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "No, you only need to sample temperature at each quadrature points in the fracture mesh, then transfer the VPP to the main app. In main app, you only need ONE DiracKernel.",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736364",
                          "updatedAt": "2022-10-18T18:24:20Z",
                          "publishedAt": "2021-05-14T01:19:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "How do you sample the temperature at each qp of the fracture?  I'm thinking of a fracture with crazy geometry that can't be written as a simple function, so the qps will be thousands/millions of \"random\" points in space.  I think something is missing from my understanding - perhaps i don't understand how the matrix app knows where those points qps are.",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736383",
                          "updatedAt": "2022-10-18T18:24:20Z",
                          "publishedAt": "2021-05-14T01:31:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yeah we should back off a little bit...\nIn your original post, you were mentioning a 2D mesh representing \"fracture\". I was assuming there is a temperature field on your fracture mesh, and you are using the difference between the temperature on the fracture and the temperature on the matrix mesh to drive some transfer (which happens in your main app, i.e. on the matrix mesh).\nDid I understand something wrong?",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736422",
                          "updatedAt": "2022-10-18T18:24:20Z",
                          "publishedAt": "2021-05-14T01:55:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "This is correct.  The difficulty we're struggling with is that the 2D fracture physically transfers heat energy only to the 3D matrix elements that contain the 2D fracture nodes.  We can do that in two ways\n\nTransfer heat energy from the 2D fracture to the appropriate 3D matrix elements\nTransfer temperature information from the 2D fracture to the appropriate 3D matrix elements, and (this is the easy bit) let the matrix app figure out how much heat-energy that corresponds to.\n\nI believe your approach would Transfer the information to an appropriate DiracKernel in the matrix app.  But i don't know how this DiracKernel or VectorPostprocessor knows the positions of the fracture nodes or quadpoints.  What am I missing?",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736443",
                          "updatedAt": "2022-10-18T18:24:30Z",
                          "publishedAt": "2021-05-14T02:06:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay we are close. In the subapp (fracture mesh), you need to have a VPP or reporter that loop over all elements, sample the field (be it temperature or heat energy, or whatever) at each quadrature point (scaled appropriately with element volume), and store the location of the qp together with the sampled value in the VPP with the structure like:\nx,      y,       z,      value\n2.85,   0.52,    0.02,   0.826\n2.11,   3.13,    9.72,   11.96\n......\n\nThen you can use MultiAppVectorPostprocessorTransfer to transfer the data of the VPP from the subapp to the main app.\nIn the main app, you will use a structure similar to the input file I pasted above to reconstruct the sampled field from the subapp.\nIn the main app, you always only need one VectorPostprocessorPointSource DiracKernel. This DiracKernel will read information from the VPP, apply point sources at all points that you provided.\nI think it'll actually be easier to just sample and transfer the heat energy. Because, if you were to transfer temperature from fracture mesh to matrix mesh, you will end up with mostly zero temperature in the elements that do not intersect with the fracture mesh. You can probably do some smart things about that though, like only evaluating your PorousFlowHeatMassTransfer kernel on elements that intersect with the fracture mesh? But anyways, choosing what to transfer from subapp to main app is up to you, what I am describing is a general way of transferring information.",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736480",
                          "updatedAt": "2022-10-18T18:24:42Z",
                          "publishedAt": "2021-05-14T02:26:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Let's take further discussion to issues #17854 or #17835, whichever is appropriate",
                  "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-745928",
                  "updatedAt": "2022-06-13T23:58:22Z",
                  "publishedAt": "2021-05-17T00:17:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Not converged][Print Variable]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear moose users,\nI would like to know if there is any way to print variables that did not converge during the calculation?\nI want to analyze which variable causes the problem of convergence in my numerical model.\nBest regrads,\nQ",
          "url": "https://github.com/idaholab/moose/discussions/17837",
          "updatedAt": "2021-05-31T05:26:36Z",
          "publishedAt": "2021-05-14T04:56:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "simopier"
                  },
                  "bodyText": "Hi,\nYou can add the following block to your input file to see the residual for each variable of your model.\n[Debug]\n  show_var_residual_norms = true\n[../]\n\nIf the residuals are very different from each other, you might consider using scaling factors for your variables to help the convergence. It would look something like this:\n[Variables]\n  [./variable_1]\n    scaling = 1e3\n  [../]\n  [./variable_2]\n     scaling = 1\n  [../]\n[]\n\nYou might also benefit from automatic scaling. You can find information here. It consists of adding these lines in your executioner block:\nautomatic_scaling = true\ncompute_scaling_once = false\nverbose = true\n\nI hope that helps!",
                  "url": "https://github.com/idaholab/moose/discussions/17837#discussioncomment-738783",
                  "updatedAt": "2021-05-14T14:41:26Z",
                  "publishedAt": "2021-05-14T14:41:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Dear simopier,\nIt helps me a lot!\nThank you for your advice!\nBest regards,\nQ",
                          "url": "https://github.com/idaholab/moose/discussions/17837#discussioncomment-743428",
                          "updatedAt": "2021-05-16T03:45:51Z",
                          "publishedAt": "2021-05-16T03:45:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}