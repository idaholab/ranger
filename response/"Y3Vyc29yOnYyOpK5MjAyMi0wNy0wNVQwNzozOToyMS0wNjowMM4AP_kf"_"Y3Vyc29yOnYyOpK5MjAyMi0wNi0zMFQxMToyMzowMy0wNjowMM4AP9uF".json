{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNi0zMFQxMToyMzowMy0wNjowMM4AP9uF"
    },
    "edges": [
      {
        "node": {
          "title": "About block in moose",
          "author": {
            "login": "Gallasd"
          },
          "bodyText": "I study radiative heat transfer and want to use rays to calculate viewfactors.\nBecause the current moose does not support meshless yet, I need to create a fluid domain to assist in the  viewfactors calculation.However, the fluid domain is a vacuum, and there is no convection and heat conduction of the fluid.\nI checked several examples that come with moose, for example,'moose\\modules\\heat_conduction\\test\\tests\\radiation_transfer_action\\radiative_transfer_action_external_boundary_ray_tracing.i'\n[Variables]\n[temperature]\nblock = 0\n[]\n[]\n[Kernels]\n[heat_conduction]\ntype = HeatConduction\nvariable = temperature\nblock = 0\ndiffusion_coefficient = 5\n[]\n[]\nHere I think it is only heat conduction at block_0, but I found that there is temperature in block_1 in paraview,as shown in the figure\n\nSo I want to confirm with you, whether heat conduction is performed in block_1, and whether the temperature of the elements on both sides of block_1 is the reason for interpolation",
          "url": "https://github.com/idaholab/moose/discussions/21498",
          "updatedAt": "2022-07-05T13:35:53Z",
          "publishedAt": "2022-07-05T08:55:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHeat conduction is not performed in block 1, as you block-restricted it to 0\nThe only thing you are seeing seems to be the nodal values of temperatures on the boundary between block 0 and block 1.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21498#discussioncomment-3085149",
                  "updatedAt": "2022-07-05T13:34:08Z",
                  "publishedAt": "2022-07-05T13:34:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Gallasd"
                          },
                          "bodyText": "ok i see what you mean thanks a lot",
                          "url": "https://github.com/idaholab/moose/discussions/21498#discussioncomment-3085155",
                          "updatedAt": "2022-07-05T13:35:50Z",
                          "publishedAt": "2022-07-05T13:35:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unsuccessful convergence of the phase field coupled with the elastic energy",
          "author": {
            "login": "biaogxb"
          },
          "bodyText": "",
          "url": "https://github.com/idaholab/moose/discussions/21356",
          "updatedAt": "2022-07-21T23:47:45Z",
          "publishedAt": "2022-06-20T08:55:44Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Only if you show us your input file, then someone might help you with it :)",
                  "url": "https://github.com/idaholab/moose/discussions/21356#discussioncomment-3003346",
                  "updatedAt": "2022-06-22T15:27:00Z",
                  "publishedAt": "2022-06-22T15:26:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "I have revised my questions. I would appreciate it if you could give me some suggestions\uff01\uff1a\uff09",
                          "url": "https://github.com/idaholab/moose/discussions/21356#discussioncomment-3006573",
                          "updatedAt": "2022-06-23T02:17:51Z",
                          "publishedAt": "2022-06-23T02:17:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "About inp mesh import problem",
          "author": {
            "login": "Gallasd"
          },
          "bodyText": "Hello,\nI don't know if I haven't understood how to import meshes in inp format into moose.\nInitially I was only working on one geometry model and moose didn't recognize the node set I defined.By consulting other people's examples, I found that I can add this code to identify node sets\n' construct_side_list_from_node_list=true'\nIn the follow-up, I need to consider multiple models, and moose reports an error, saying that importing multiple parts is not yet supported.I tried to define the element set, but my element set is not recognized in the block.\nI don't know how to make moose recognize my block, can you help me, thank you very much!\nThe reason why I consider defining the unit set to represent the block is because when I build a single model study, the elemtent set is defined, and the block can be seen in the paraview.\n\n\nBut it is not recognized in moose",
          "url": "https://github.com/idaholab/moose/discussions/21493",
          "updatedAt": "2022-07-21T23:47:37Z",
          "publishedAt": "2022-07-04T13:24:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe Abaqus file mesh reader is actually inherited from libmesh.\nYou may look at the code there to see what it does\nhttps://libmesh.github.io/doxygen/classlibMesh_1_1AbaqusIO.html#a4935543726ef7a56278f486d2904f423\notherwise you may want to ask in the libmesh discussions\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21493#discussioncomment-3081275",
                  "updatedAt": "2022-07-05T02:24:00Z",
                  "publishedAt": "2022-07-05T02:24:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Gallasd"
                          },
                          "bodyText": "I want to ask you, does the block in moose correspond to the unit set in abaqus? If this is uncertain, I can't find the direction I should go to solve",
                          "url": "https://github.com/idaholab/moose/discussions/21493#discussioncomment-3081375",
                          "updatedAt": "2022-07-05T02:45:50Z",
                          "publishedAt": "2022-07-05T02:45:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "looking at the code it seems to correspond to \"elset\"\nI dont see any reference to unit sets there",
                          "url": "https://github.com/idaholab/moose/discussions/21493#discussioncomment-3081807",
                          "updatedAt": "2022-07-05T04:46:32Z",
                          "publishedAt": "2022-07-05T04:46:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Steady state converges but transient does not in CFD",
          "author": {
            "login": "sychang2021"
          },
          "bodyText": "Hi, moose experts.\nUsually transient algorithms are more stable than steady ones in CFD, but I have encountered a problem that the steady state can converge but the transient cannot converge.\nThis is a 2D problem. There is a solid rectangular inner heat source with two rectangular channels on both sides through which liquid flows to conduct heat. The boundary conditions are inlet temperature, inlet velocity and outlet pressure, as well as the presence or absence of slip boundary conditions at the solid-liquid interface(the velocity is 0 at the boundaries of the flow channels).\n\nI ran a steady state simulation first, and the simulation was converging.\n\nBut when I added a time term to each of the three equations, the simulation didn't converge. The time step of the transient simulation is 1e-6s.\n\nTo describe the problem more clearly, I put the steady-state and transient input files here. The only difference between steady state and transient is the addition of a time term to the transient Kernels block.\nSTEADY\n[Mesh]\n  file = '2layers_2d.msh'\n[]\n\n[Variables]\n  [./T]\n    initial_condition = 300\n  [../]\n  [./velocity]\n    family = LAGRANGE_VEC\n    block = 'outer'\n  [../]\n  [./p]\n    order = FIRST\n    family = LAGRANGE\n    block = 'outer'\n  [../]\n[]\n\n[ICs]\n  [./initial_velocity]\n    type = VectorConstantIC\n    x_value = 0\n    y_value = 1.5\n    z_value = 0\n    variable = velocity\n  [../]\n  [./initial_p]\n    type = FunctionIC\n    variable = p\n    function = ini_p\n  [../]\n[]\n\n[Kernels]\n  [./mass]\n    type = INSADMass\n    variable = p\n  [../]\n  [./mass_pspg]\n    type = INSADMassPSPG\n    variable = p\n  [../]\n\n  [./momentum_convection]\n    type = INSADMomentumAdvection\n    variable = velocity\n  [../]\n  [./momentum_viscous]\n    type = INSADMomentumViscous\n    variable = velocity\n  [../]\n  [./momentum_pressure]\n    type = INSADMomentumPressure\n    variable = velocity\n    pressure = p\n    integrate_p_by_parts = true\n  [../]\n  [./momentum_gravity]\n    type = INSADGravityForce\n    variable = velocity\n    gravity = '0 -9.81 0'\n    block = 'outer'\n  [../]\n  [./momentum_supg]\n    type = INSADMomentumSUPG\n    variable = velocity\n    velocity = velocity\n    block = 'outer'\n  [../]\n\n  [./temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    block = 'outer'\n    thermal_conductivity = 'k'\n  [../]\n  [./temperature_advection]\n    type = INSADEnergyAdvection\n    variable = T\n    block = 'outer'\n  [../]\n  [./temperature_supg]\n    type = INSADEnergySUPG\n    variable = T\n    velocity = velocity\n    block = 'outer'\n  [../]\n\n  [./solid_temperature]\n    type = ADHeatConduction\n    variable = T\n    block = 'inner'\n    thermal_conductivity = 'k'\n  [../]\n  [./heat_source]\n    type = HeatSource\n    value = 1e9\n    variable = T\n    block = 'inner'\n  [../]\n[]\n\n[InterfaceKernels]\n  [./convection_heat_transfer]\n    type = ConjugateHeatTransfer\n    variable = T\n    T_fluid = T\n    neighbor_var = 'T'\n    boundary = 'inner_wall'\n    htc = 'htc'\n  [../]\n[]\n\n[BCs]\n  [./inlet_Tl]\n    type = DirichletBC\n    variable = T\n    boundary = 'outer_bottom'\n    value = 300\n  [../]\n  [./inlet_velocity]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'outer_bottom'\n    function_y = 1.5\n  [../]\n  [./outlet_p]\n    type = DirichletBC\n    variable = p\n    boundary = 'outer_top'\n    value = 0\n  [../]\n\n  [./no_slip]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'inner_wall outer_wall'\n    function_y = 0\n  [../]\n[]\n\n[Materials]\n  [./fluid_mat]\n    type = ADGenericConstantMaterial\n    prop_names = 'rho mu cp k'\n    prop_values = '10311 0.0061 152 8.8'\n    block = 'outer'\n  [../]\n  [./solid_mat]\n    type = ADGenericConstantMaterial\n    prop_names = 'rho cp k'\n    prop_values = '11085 238 5.95'\n    block = 'inner'\n  [../]\n  [./ins_mat]\n    type = INSADStabilized3Eqn\n    velocity = velocity\n    pressure = p\n    temperature = T\n    block='outer'\n  [../]\n  [./htc]\n    type = ADGenericFunctionMaterial\n    prop_names = htc\n    prop_values = htc_function\n  [../]\n[]\n\n[Functions]\n  [./htc_function]\n    type = ParsedFunction\n    value = '9e4'\n  [../]\n  [./ini_p]\n    type = ParsedFunction\n    value = '11085*9.81*(0.9-y)'\n  [../]\n[]\n\n[Preconditioning]\n  [Newton_SMP]\n    type = SMP\n    full = true\n    solve_type = 'NEWTON'\n  []\n[]\n\n[Executioner]\n  type = Steady\n  automatic_scaling = true\n  nl_rel_tol = 1e-8\n  l_tol = 1e-6\n  l_max_its = 500\n  nl_max_its = 200\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -ksp_gmres_restart'\n  petsc_options_value = 'lu       superlu_dist                  50'\n[]\n\n[VectorPostprocessors]\n  [./mid_T]\n    type = LineValueSampler\n    variable = 'T'\n    start_point = '0 0 0'\n    end_point = '0 0.9 0'\n    num_points = 91\n    sort_by = y\n  []\n[]\n\n[Outputs]\n  perf_graph = true\n  print_linear_residuals = false\n  csv = true\n  execute_on = 'timestep_end'\n  exodus = true\n  file_base = 'steady_0'\n[]\n\nTRANSIENT\n[Mesh]\n  file = '2layers_2d.msh'\n[]\n\n[Variables]\n  [./T]\n    initial_condition = 300\n  [../]\n  [./velocity]\n    family = LAGRANGE_VEC\n    block = 'outer'\n  [../]\n  [./p]\n    order = FIRST\n    family = LAGRANGE\n    block = 'outer'\n  [../]\n[]\n\n[ICs]\n  [./initial_velocity]\n    type = VectorConstantIC\n    x_value = 0\n    y_value = 1.5\n    z_value = 0\n    variable = velocity\n  [../]\n  [./initial_p]\n    type = FunctionIC\n    variable = p\n    function = ini_p\n  [../]\n[]\n\n[Kernels]\n  [./mass]\n    type = INSADMass\n    variable = p\n  [../]\n  [./mass_pspg]\n    type = INSADMassPSPG\n    variable = p\n  [../]\n\n  [./momentum_time]\n    type = INSADMomentumTimeDerivative\n    variable = velocity\n  [../]\n  [./momentum_convection]\n    type = INSADMomentumAdvection\n    variable = velocity\n  [../]\n  [./momentum_viscous]\n    type = INSADMomentumViscous\n    variable = velocity\n  [../]\n  [./momentum_pressure]\n    type = INSADMomentumPressure\n    variable = velocity\n    pressure = p\n    integrate_p_by_parts = true\n  [../]\n  [./momentum_gravity]\n    type = INSADGravityForce\n    variable = velocity\n    gravity = '0 -9.81 0'\n    block = 'outer'\n  [../]\n  [./momentum_supg]\n    type = INSADMomentumSUPG\n    variable = velocity\n    velocity = velocity\n    block = 'outer'\n  [../]\n\n  [./temperature_time]\n    type = INSADHeatConductionTimeDerivative\n    variable = T\n    block = 'outer'\n  [../]\n  [./temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    block = 'outer'\n    thermal_conductivity = 'k'\n  [../]\n  [./temperature_advection]\n    type = INSADEnergyAdvection\n    variable = T\n    block = 'outer'\n  [../]\n  [./temperature_supg]\n    type = INSADEnergySUPG\n    variable = T\n    velocity = velocity\n    block = 'outer'\n  [../]\n\n  [./solid_temperature_time]\n    type = ADHeatConductionTimeDerivative\n    variable = T\n    block = 'inner'\n    density_name = 'rho'\n    specific_heat = 'cp'\n  [../]\n  [./solid_temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    block = 'inner'\n    thermal_conductivity = 'k'\n  [../]\n  [./heat_source]\n    type = HeatSource\n    value = 1e9\n    variable = T\n    block = 'inner'\n  [../]\n[]\n\n[InterfaceKernels]\n  [./convection_heat_transfer]\n    type = ConjugateHeatTransfer\n    variable = T\n    T_fluid = T\n    neighbor_var = 'T'\n    boundary = 'inner_wall'\n    htc = 'htc'\n  [../]\n[]\n\n[BCs]\n  [./inlet_Tl]\n    type = DirichletBC\n    variable = T\n    boundary = 'outer_bottom'\n    value = 300\n  [../]\n  [./inlet_velocity]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'outer_bottom'\n    function_y = 1.5\n  [../]\n  [./outlet_p]\n    type = DirichletBC\n    variable = p\n    boundary = 'outer_top'\n    value = 0\n  [../]\n\n  [./no_slip]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'inner_wall outer_wall'\n    function_y = 0\n  [../]\n[]\n\n[Materials]\n  [./fluid_mat]\n    type = ADGenericConstantMaterial\n    prop_names = 'rho mu cp k'\n    prop_values = '10311 0.0061 152 8.8'\n    block = 'outer'\n  [../]\n  [./solid_mat]\n    type = ADGenericConstantMaterial\n    prop_names = 'rho cp k'\n    prop_values = '11085 238 5.95'\n    block = 'inner'\n  [../]\n  [./ins_mat]\n    type = INSADStabilized3Eqn\n    velocity = velocity\n    pressure = p\n    temperature = T\n    block='outer'\n  [../]\n  [./htc]\n    type = ADGenericFunctionMaterial\n    prop_names = htc\n    prop_values = htc_function\n  [../]\n[]\n\n[Functions]\n  [./htc_function]\n    type = ParsedFunction\n    value = '9e4'\n  [../]\n  [./ini_p]\n    type = ParsedFunction\n    value = '11085*9.81*(0.9-y)'\n  [../]\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n    solve_type = 'NEWTON'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 100\n  dt = 1e-6\n  petsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -sub_pc_factor_levels -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      2               ilu          4                     NONZERO'\n  line_search = 'none'\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-10\n  automatic_scaling = true\n[]\n\n[Postprocessors]\n  [./max_T_inner]\n    type = ElementExtremeValue\n    variable = T\n    value_type = max\n    block = 'inner'\n  [../]\n  [./max_T_outer]\n    type = ElementExtremeValue\n    variable = T\n    value_type = max\n    block = 'outer'\n  [../]\n  [./min_T_inner]\n    type = ElementExtremeValue\n    variable = T\n    value_type = min\n    block = 'inner'\n  [../]\n  [./min_T_outer]\n    type = ElementExtremeValue\n    variable = T\n    value_type = min\n    block = 'outer'\n  [../]\n  [./average_T_inner]\n    type = ElementAverageValue\n    variable = T\n    block = 'inner'\n  [../]\n  [./average_T_outer]\n    type = ElementAverageValue\n    variable = T\n    block = 'outer'\n  [../]\n[]\n\n[Outputs]\n  perf_graph = true\n  print_linear_residuals = false\n  [./exodus]\n    type = Exodus\n    file_base = 'transient_0'\n    execute_on = 'FINAL'\n  [../]\n[]\n\nThis is mesh file.\n2layers_2d.zip",
          "url": "https://github.com/idaholab/moose/discussions/21488",
          "updatedAt": "2022-07-05T02:09:04Z",
          "publishedAt": "2022-07-03T02:18:04Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou seem to have changed the preconditioning quite a bit as well.\nFor the steady state you use a direct solve, lu.\nFor the transient you use something more scalable, asm-lu, but also not as good at converging under any conditions.\nCould you please try lu for the transient too?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21488#discussioncomment-3071530",
                  "updatedAt": "2022-07-03T04:08:37Z",
                  "publishedAt": "2022-07-03T04:08:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sychang2021"
                          },
                          "bodyText": "I\u2019ve replaced\n  petsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -sub_pc_factor_levels -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      2               ilu          4                     NONZERO'\n\nwith\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -ksp_gmres_restart'\n  petsc_options_value = 'lu       superlu_dist                  50'\n\nBut simulation still does not converge.",
                          "url": "https://github.com/idaholab/moose/discussions/21488#discussioncomment-3071596",
                          "updatedAt": "2022-07-03T04:52:14Z",
                          "publishedAt": "2022-07-03T04:52:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sychang2021"
                          },
                          "bodyText": "You are right, Guillaume! The root of the problem is preconditioning. I replace the original Executioner block with the following one, then it runs well.\n[Executioner]\n  type = Transient\n  num_steps = 100\n  dt = 1e-6\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-10\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n  nl_max_its = 30\n  l_max_its = 100\n[]\n\nBut I don't understand why PETSc options are set like this. Can you briefly explain it to me? I also want to learn how to set PETSc options, do you have any suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/21488#discussioncomment-3071836",
                          "updatedAt": "2022-07-03T06:45:14Z",
                          "publishedAt": "2022-07-03T06:45:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The PETSc manual is the best reference for petsc options we have very basic documentation here otherwise\nhttps://mooseframework.inl.gov/syntax/Preconditioning/\nhttps://mooseframework.inl.gov/source/executioners/Steady.html\nhttps://mooseframework.inl.gov/application_development/hypre.html\nLU is direct solve method, so it's more robust than iterative solves, but it also does not scale very well with the size of the problem",
                          "url": "https://github.com/idaholab/moose/discussions/21488#discussioncomment-3081232",
                          "updatedAt": "2022-07-05T02:07:24Z",
                          "publishedAt": "2022-07-05T02:07:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sychang2021"
                          },
                          "bodyText": "Thank you for your advice. I'll learn it carefully.",
                          "url": "https://github.com/idaholab/moose/discussions/21488#discussioncomment-3081239",
                          "updatedAt": "2022-07-05T02:09:04Z",
                          "publishedAt": "2022-07-05T02:09:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "About eigenstrain in RSPHERICAL coord_type",
          "author": {
            "login": "Xfengrui"
          },
          "bodyText": "Hi,\nI'm trying to use coord_type = RSPHERICAL to solve a 1D hollow sphere problem.\nThe mesh info is\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    xmin = 2e-3\n    xmax = 3e-3\n    nx = 1\n[]\n\nI wish the the thickness of the sphere shell increase from 1mm to 1.1mm. So I gave a eigenstrain of '0.1 0.1 .0.1' as follows:\n  [./eigen]\n    type = ComputeEigenstrain\n    eigen_base = '0.1 0.1 0.1'\n    eigenstrain_name = eigenstrain\n    outputs = exodus\n  [../]\n\nHowever, the thickness of the shell after the calculation became 1.2mm rather than 1.1mm.\nI then give the same eigenstrain to a solid sphere with r=1e-3, and the radius of the sphere increased to 1.1mm as expected.  I'm now wondering if I gave a wrong eigenstrain for the hollow sphere in view of the coord_type = RSPHERICAL  ?\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    xmin = 0    #solid sphere with r=1e-3\n    xmax = 1e-3\n    nx = 1\n[]",
          "url": "https://github.com/idaholab/moose/discussions/21475",
          "updatedAt": "2022-07-21T23:47:21Z",
          "publishedAt": "2022-07-01T03:24:31Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWell what is the analytical result for this?\nAlso only one element in the mesh? Are you supposed to get the exact solution with just one?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3061073",
                  "updatedAt": "2022-07-01T04:37:20Z",
                  "publishedAt": "2022-07-01T04:37:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Xfengrui"
                          },
                          "bodyText": "Thanks for your reply.\nIn sphere coord type, strain_rr = du_rr / dr, thus the analytical result for this should be about 1.1mm from my point of view. And the solid sphere case has proved it.\nI also have tried to use more elements but it didn't change the results.",
                          "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3061120",
                          "updatedAt": "2022-07-01T04:52:02Z",
                          "publishedAt": "2022-07-01T04:52:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What is the spatial extent of the 1D hollow shell after you apply the strain? Like the new xmin and xmax?",
                          "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3061143",
                          "updatedAt": "2022-07-01T04:55:57Z",
                          "publishedAt": "2022-07-01T04:55:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Xfengrui"
                          },
                          "bodyText": "I gave a fixed boundary condition for \"left\", so the new xmin = 2e-3  and xmax= 3.2e-3.\nFor the solid sphere, the new xmin = 0 and xmax = 1.1e-3.",
                          "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3061196",
                          "updatedAt": "2022-07-01T05:13:24Z",
                          "publishedAt": "2022-07-01T05:13:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think strain for a shell would be dr / r so since r is 2e-3, the dr should be 0.1 * 2e-3 not 0.1 * 1e-3\nfound a cool video about it\nhttps://www.youtube.com/watch?v=7t9t4Sotl8U",
                          "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3061227",
                          "updatedAt": "2022-07-01T05:23:45Z",
                          "publishedAt": "2022-07-01T05:23:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Xfengrui"
                          },
                          "bodyText": "Sorry, I'm not sure I have understood it.\nr=2e-3 for inner radius, r=3e-3 for outer radius. In the case that inner radius is fixed,  dr shoud be 3e-4 for the outer?",
                          "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3062026",
                          "updatedAt": "2022-07-01T07:58:15Z",
                          "publishedAt": "2022-07-01T07:58:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think the formula takes the inner radius for r",
                          "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3064251",
                          "updatedAt": "2022-07-01T13:31:33Z",
                          "publishedAt": "2022-07-01T13:31:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Xfengrui"
                          },
                          "bodyText": "Thanks for your help! I think you are correct in the case of free BCs. And the elongation should be (0.13e-3-0.12e-3)=0.1e-3.\nHere I imposed a Dirichlet BC for inner side and the problem seem to be much more complicated according to @hugary1995 .",
                          "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3076475",
                          "updatedAt": "2022-07-04T08:40:04Z",
                          "publishedAt": "2022-07-04T08:40:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "This is actually an interesting question (plus it's boring here at the airport...), so I decided to write it down:\nThe strain measure we have in tensor_mechanics for large deformation is notionally the logarithmic strain\n\nwhere\n\nSay the r-displacement is u, then the total strain is\n\nSubtracting the diagonal eigenstrain you get the mechanical strain as\n\nLet Young's modulus be E, and poisson's ratio be 0 to make my life easier. The stress is\n\nNext, the linear momentum balance is\n\nwhich has become a second order nonlinear ordinary differential equation that I don't know how to solve analytically. So I'll stop here. But I think this is enough to convince you that the problem isn't as simple as it looks like.\nA couple of remarks here:\n\nTo get what you want, you'll need to make many simplifications. If you make the small strain assumption, and use Poisson's ratio = 0, and do not impose any Dirichlet boundary conditions, the elongation will be exactly the eigenstrain times the thickness of the hollow sphere, spot on.\nIf the Poisson's ratio gets larger, the elongation will be larger due to z and theta contributions, which is the so-called Poisson's effect.\nIf you are additionally imposing a Dirichlet BC on the inner surface, you are effectively applying a traction on that surface, which will make the solution further away from your guess.\n\nIt seems to me that you doing all of the above: large deformation, using a nonzero Poisson's ratio, and imposing a Dirichlet BC, which makes the problem very difficult (analytically, not numerically). (Although I know it seems to be pretty straightforward...) Not to mention the fact that we are doing a specific form of objective integration, and using a specific hypoelasticity model -- all of that complicates the picture.",
                  "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3067913",
                  "updatedAt": "2022-07-02T06:43:00Z",
                  "publishedAt": "2022-07-02T06:27:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Oh, and a minor correction after inspecting the math, if you use small strain, and remove all the Dirichlet BCs, then the Poisson's ratio actually won't affect the result in this specific case.\nFor example, if you have a domain [2e-3, 3e-3], then using strain = SMALL in the TM action, (or ComputeRSphericalSmallStrain), and don't impose any Dirichet BCs, the displacements are always gonna be 2e-4 and 3e-4 at the left and the right nodes, with an eigenstrain of 0.1, regardless of the value of the Poisson's ratio.",
                          "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3067934",
                          "updatedAt": "2022-07-02T06:39:37Z",
                          "publishedAt": "2022-07-02T06:39:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Xfengrui"
                          },
                          "bodyText": "Thanks a lot!\nI moved the DirichletBCs  and the elongation obtained was 0.1mm as I expected. And I think that the elongation was much larger than 0.1 mm before is mainly due to the \"traction\" as you said.  Thanks for your helpful suggestions.\nHowever, here comes another problem. The case I mentioned above is somewhat simplified. In a real situation, the sphere have a three -layers structure, and the growth occurs at the middle layer (which means that the two side of the layer are both affected by the other layers). To get a exact elongation of the middle layer will be tricky then.\nWhat's more, it's not very clear for me about whether the eigenstrain models in Cartesian coordinates (for example, thermal expansions) are still suitable for Spherical coordinates for hollow sphere cases in view that we will get different elongations.",
                          "url": "https://github.com/idaholab/moose/discussions/21475#discussioncomment-3076364",
                          "updatedAt": "2022-07-04T08:25:36Z",
                          "publishedAt": "2022-07-04T08:25:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Questions about Heat Transfer Calculation Boundaries",
          "author": {
            "login": "Gallasd"
          },
          "bodyText": "I have a question, for a physics problem, suppose the surface of an object needs to impose two boundary conditions, such as radiation and heat flow boundary, although radiation is also a heat flow.\nFor radiation, I use FunctionRadiativeBC.For heat flow, and I use NeumannBC,but getting error of duplicate boundary.\nTherefore, I consider whether it is necessary to build a function boundary to convert radiation into heat flow,then add them together to calculate. I try to use FunctionNeumannBC.But it is found that the function can only be related to space and time, not temperature.\nSo I don't know how to deal with this kind of problem that needs to impose two boundary conditions.Whether the kernel needs to be modified.\nThank you for reading, I hope you can help me.",
          "url": "https://github.com/idaholab/moose/discussions/21387",
          "updatedAt": "2022-07-04T03:30:19Z",
          "publishedAt": "2022-06-23T03:48:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe Neumann BC is not meant to be combined, it must provide all of the flux. Use the convective heat flux BC instead\nhttps://mooseframework.inl.gov/source/bcs/CoupledConvectiveHeatFluxBC.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21387#discussioncomment-3007285",
                  "updatedAt": "2022-06-23T05:20:11Z",
                  "publishedAt": "2022-06-23T05:19:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Gallasd"
                          },
                          "bodyText": "Hello\nI'm sorry I didn't understand you,\nCoupledConvectiveHeatFluxBC, as I understand it,  is possible to use vector coupling to compute the heat flux for multi-phase fluids.The heat flow here is actually q in the usual sense, not convection.I see the introduction of the boundary, the temperature is first order, which is not consistent with the calculation of radiation.\nI hope you can provide me with a more detailed answer, thank you for your help",
                          "url": "https://github.com/idaholab/moose/discussions/21387#discussioncomment-3008133",
                          "updatedAt": "2022-06-23T07:55:11Z",
                          "publishedAt": "2022-06-23T07:55:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Look at this input that has both on different boundaries. But seems to work to add radiation on the convective boundary\nhttps://github.com/idaholab/moose/blob/next/modules/heat_conduction/test/tests/radiative_bcs/ad_function_radiative_bc.i\n[BCs]\n  [top_right]\n    type = ADConvectiveHeatFluxBC\n    variable = temp\n    boundary = top_right\n    T_infinity = 300.0\n    heat_transfer_coefficient = 3.0\n  []\n  [bot_right]\n    type = ADFunctionRadiativeBC\n    variable = temp\n    boundary = bot_right\n    # htc/(stefan-boltzmann*4*T_inf^3)\n    emissivity_function = '3/(5.670367e-8*4*300*300*300)'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21387#discussioncomment-3013903",
                          "updatedAt": "2022-06-23T22:54:45Z",
                          "publishedAt": "2022-06-23T22:54:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Gallasd"
                  },
                  "bodyText": "hello\nI'm glad you've been paying attention to this issue, because of some things I didn't reply to you right away, I'm very sorry\nThe study you provided should use a radiation study instead of convection by simplifying it. In the calculation example, the convection condition is applied to the top_right, and the simplified radiation is applied to the bot_right. I think this is still one boundary corresponding to one boundary condition, and it does not solve the problem of applying two working conditions to one boundary.\nI checked all the heat-related boundaries provided by moose's official website and found that no similar boundaries are provided\n\nAmong them, the fourth order corresponds to radiation, the first order corresponds to convection, and C corresponds to constant heat flux density.",
                  "url": "https://github.com/idaholab/moose/discussions/21387#discussioncomment-3020955",
                  "updatedAt": "2022-06-25T02:46:59Z",
                  "publishedAt": "2022-06-25T02:46:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Well first it really woudlnt be hard to add this particular boundary condition for your needs. We're talking 10 minutes of coding max here.\nSecondly, while the input i linked does indeed use radiation and convection on different boundaries, you can add a second radiation condition on the same boundary as the convective one and it still works.",
                          "url": "https://github.com/idaholab/moose/discussions/21387#discussioncomment-3021018",
                          "updatedAt": "2022-06-25T03:25:19Z",
                          "publishedAt": "2022-06-25T03:25:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Gallasd"
                          },
                          "bodyText": "I solved the problem, one geometry bound can impose different bounds, thanks for your help",
                          "url": "https://github.com/idaholab/moose/discussions/21387#discussioncomment-3075119",
                          "updatedAt": "2022-07-04T03:30:12Z",
                          "publishedAt": "2022-07-04T03:30:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Boundary conditions at the interface when a fluid flows vertically over a solid surface",
          "author": {
            "login": "sychang2021"
          },
          "bodyText": "Hello everyone!\nI am trying to solve a problem of liquid flowing in a vertical pipe. There is an obstacle in the pipe, and the liquid flows in the area between the pipe and the obstacle. But I can't solve the correct pressure field and velocity field. I think there may be a problem with the velocity boundary conditions on the surface of the liquid and the obstacle. Shouldn't the boundary conditions of the fluid and solid interface be Neumann boundary conditions, but other boundary conditions? Are there any similar cases in MOOSE that I can learn from?",
          "url": "https://github.com/idaholab/moose/discussions/21466",
          "updatedAt": "2022-07-01T13:11:46Z",
          "publishedAt": "2022-06-30T15:17:26Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDoes the pipe only case work as expected? Are you getting the expected pressure drop then?\nWhat discretization are you using for Navier Stokes for this problem? FE? INS? INSAD?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21466#discussioncomment-3061270",
                  "updatedAt": "2022-07-01T05:33:19Z",
                  "publishedAt": "2022-07-01T05:33:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sychang2021"
                          },
                          "bodyText": "INSAD. I have found the problem. I forgot to add no-slip boundary conditions to the walls of solids and fluids. Adding this boundary condition gives reasonable results. thank you for your reply.",
                          "url": "https://github.com/idaholab/moose/discussions/21466#discussioncomment-3064099",
                          "updatedAt": "2022-07-01T13:11:47Z",
                          "publishedAt": "2022-07-01T13:11:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How mesh density is partitioned in GeneratedMesh\uff1f",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nRecently I created an initial microstructure of gradient nano-grains for grain growth and used GeneratedMesh for uniform meshing. Under the condition that the grain mesh of the surface layer of Level 1 is guaranteed to be reasonable (see figure.(c)), it also causes the grain grid of the coarse-grained layer of level 3 to be excessively dense (see figure.(d)), which makes dofs extremely high.\n\nFigure: (a) Initial microstructure of gradient nano-grains (GNGs) by PolycrystalVoronoi object, (b) Global meshing graph, (c) Enlarged view of meshing at Level 1 fine-grained layer, (d) Enlarged view of meshing at Level 3 coarse-grained layer.\nSo what I'm asking now is if there is a way to use GeneratedMesh or similar meshing tool to use different mesh densities at different levels or regions.\nAny suggestions or recommendations to fix the problem would be greatly appreciated.\nThank you\nWei",
          "url": "https://github.com/idaholab/moose/discussions/21426",
          "updatedAt": "2022-07-01T01:55:59Z",
          "publishedAt": "2022-06-27T03:24:39Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHow are the different regions defined? Cartesian regions? Or have you defined subdomains?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21426#discussioncomment-3028393",
                  "updatedAt": "2022-06-27T03:26:44Z",
                  "publishedAt": "2022-06-27T03:26:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Should be a Cartesian coordinate area. Specifically, I want to divide three areas or more according to different y-axis coordinates, by the way I modified my figure.",
                          "url": "https://github.com/idaholab/moose/discussions/21426#discussioncomment-3028412",
                          "updatedAt": "2022-06-27T03:33:18Z",
                          "publishedAt": "2022-06-27T03:33:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "and this is the mesh setup I'm using now,\nmy_nx = 25 # 30 94\nmy_xmax = 886 # 1200 3760 400e-1 nm\nmy_ny = 25 # 30 94 \nmy_ymax = 886 # 1200 3760 400e-1 nm\n[Mesh]\n  # Mesh block.  Meshes can be read in or automatically generated\n  type = GeneratedMesh\n  dim = 2 # Problem dimension\n  nx = ${my_nx} # Number of elements in the x-direction\n  ny = ${my_ny} # Number of elements in the y-direction\n  xmin = 0    # minimum x-coordinate of the mesh\n  xmax = ${my_xmax} # 1000 maximum x-coordinate of the mesh 2000-400 400 1600\n  ymin = 0    # minimum y-coordinate of the mesh\n  ymax = ${my_ymax} # 1000 maximum y-coordinate of the mesh\n  elem_type = QUAD4  # Type of elements used in the mesh\n  uniform_refine = 0 # Initial uniform refinement of the mesh\n\n  parallel_type = distributed # Periodic BCs distributed replicated\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21426#discussioncomment-3028417",
                          "updatedAt": "2022-06-27T03:35:14Z",
                          "publishedAt": "2022-06-27T03:35:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This mesh generator will let you set different mesh fineness in different cartesian regions\nhttps://mooseframework.inl.gov/source/meshgenerators/CartesianMeshGenerator.html\nI ll just mention that if you assign blocks to regions you can also perform selective block refinements (sideset is also an option, with another MG)\nusing this\nhttps://mooseframework.inl.gov/source/meshgenerators/RefineBlockGenerator.html",
                          "url": "https://github.com/idaholab/moose/discussions/21426#discussioncomment-3028418",
                          "updatedAt": "2022-06-27T03:36:01Z",
                          "publishedAt": "2022-06-27T03:35:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Ok, thanks for your answer, I will try it.",
                          "url": "https://github.com/idaholab/moose/discussions/21426#discussioncomment-3028497",
                          "updatedAt": "2022-06-27T04:05:43Z",
                          "publishedAt": "2022-06-27T04:05:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "hi, @GiudGiud. According to your suggestion, I used CartesianMeshGenerator and SideSetsBetweenSubdomainsGenerator to refine the mesh, the code and mesh figure are as follows,\n\nHowever, passing RefineBlockGenerator in this way does not meet my needs very well. Specifically, I want to be able to set nx and ny belonging to each block like in GeneratedMesh, is this possible?\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/21426#discussioncomment-3037177",
                          "updatedAt": "2022-06-28T06:48:12Z",
                          "publishedAt": "2022-06-28T06:48:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThe refineblockGenerator only does uniform refinement currently.\nIf you want custom nx and ny you may set them directly for each block in the Cartesian mesh generator.\nI recommend using parsed expressions if you want to functionalize this mesh as a function of a few refinement parameters\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21426#discussioncomment-3041156",
                          "updatedAt": "2022-06-28T15:21:39Z",
                          "publishedAt": "2022-06-28T15:21:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Yeah, I solved this problem by modifying max_h_level, the effect is as follows.\n\nThank you so much.\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/21426#discussioncomment-3060473",
                          "updatedAt": "2022-07-01T01:55:13Z",
                          "publishedAt": "2022-07-01T01:55:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to include damage in plasticity model?",
          "author": {
            "login": "tstepan333"
          },
          "bodyText": "I'm trying to simulate a tensile test for plastic material. As a first step, I implemented a plasticity model using ComputeMultiPlasticityStress and UserObjects to define the hardening function. My goal is to capture the effect of damage on stress and stiffness. What type of material do I need to use to define a damage index?",
          "url": "https://github.com/idaholab/moose/discussions/19539",
          "updatedAt": "2022-06-30T23:01:17Z",
          "publishedAt": "2021-12-03T21:58:11Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @tstepan333\nIf you want to couple phase field damage model with plasticity model, you will need to define your own material class.\nYou can see an example here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainUObasedCPDamageVol.C\nwhere I couple phase field damage with crystal plasticity.\nTest cases are available here:\nhttps://github.com/ngrilli/c_pfor_am/tree/main/test/tests/CPDamage\nThe idea is that you need to define the free energy and derivatives that are needed\nin the phase field model for damage.\nThe approach is documented here:\nhttps://aip.scitation.org/doi/abs/10.1063/1.5109761\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-1749668",
                  "updatedAt": "2022-06-06T12:14:37Z",
                  "publishedAt": "2021-12-04T17:21:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "In case you want to use smeared cracking model, you can use ComputeSmearedCrackingStress in conjunction with any inelastic models, e.g., plasticity and creep. You can also implement your own damage models following the smeared cracking models.\nTo use this, the plasticity and creep need to be defined as StressUpdate models which are a bit different than the UO based plasticity models. For more information, please look at https://mooseframework.inl.gov/source/materials/ComputeMultipleInelasticStress.html",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-1749737",
                          "updatedAt": "2022-06-06T12:14:42Z",
                          "publishedAt": "2021-12-04T17:44:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tstepan333"
                          },
                          "bodyText": "@jiangwen84 Thank you for your help. Could you clarify what the UO-based plasticity model means?",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-1817421",
                          "updatedAt": "2022-06-06T12:14:43Z",
                          "publishedAt": "2021-12-15T21:45:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@jiangwen84 Thank you for your help. Could you clarify what the UO-based plasticity model means?\n\nThe UserObject-based plasticity models you used. In MOOSE, we have both UO-based and stress-update based plasticity models.",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-1817460",
                          "updatedAt": "2022-06-06T12:14:43Z",
                          "publishedAt": "2021-12-15T21:55:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tstepan333"
                          },
                          "bodyText": "Hi @jiangwen84, I need your help.\nI am getting errors when using plasticity and the smeared crack model.\n\nIn my model, the plate stretches in the x-direction, and cracks form in the y-direction.\nDo I need to specify both plasticity and smeared crack model in ComputeMultipleInelasticStress?",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-1964083",
                          "updatedAt": "2022-06-28T18:51:30Z",
                          "publishedAt": "2022-01-13T17:19:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "@tstepan333 in the future can you please post plain text not as a screenshot and instead in a code block (see https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/creating-and-highlighting-code-blocks)\nIt will then display as :\n*** ERROR ***\nThe following...\n\nBy pasting text directly, it makes it searchable for future users experiencing the same issue.",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-1964429",
                          "updatedAt": "2022-06-28T18:51:34Z",
                          "publishedAt": "2022-01-13T18:04:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@tstepan333 ComputeSmearedCrackingStress derives from ComputeMultipleInelasticStress. So you only need ComputeSmearedCrackingStress in the input file.",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-1987523",
                          "updatedAt": "2022-06-28T18:51:39Z",
                          "publishedAt": "2022-01-18T03:34:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "whitewalker63"
                          },
                          "bodyText": "@ngrilli @jiangwen84  I\u2019m using the ComputeMultipleinelasticstress class to compute the stress state of multiple inelastic models based on the RadialreturnStressupdate. Each of my inelastic models (which are child classes of the RadialReturnCreepStressUpdateBase) has a damage parameter/variable. How do I get the damage variable into these inelastic models? If I have to use the computeSmearedCrackingStress, do I have to first include (or call) the ScalarDamageBase in each of these inelastic modules?",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-3059974",
                          "updatedAt": "2022-06-30T23:01:18Z",
                          "publishedAt": "2022-06-30T23:01:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "karthigesut"
                  },
                  "bodyText": "@ngrilli I have a question to ask. If i want to do a damage model (crystal plasticity) on MOOSE FRAMEWORK, can i import the microstructure from NEPER? or MOOSE has the capability to create a synthetic microstructure like what NEPER and DREAM3D can do?\nThank you.\nkarthi",
                  "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-1856950",
                  "updatedAt": "2022-06-06T12:15:12Z",
                  "publishedAt": "2021-12-22T08:17:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "@karthigesut\nAn example of importing Neper .msh file to run a polycrystal simulation is here:\nhttps://github.com/ngrilli/c_pfor_am/tree/main/test/tests/neper\nHope this helps,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-1872543",
                          "updatedAt": "2022-06-06T12:15:12Z",
                          "publishedAt": "2021-12-26T17:36:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "karthigesut"
                          },
                          "bodyText": "@ngrilli Thanks sir.",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-1878063",
                          "updatedAt": "2022-06-06T12:15:12Z",
                          "publishedAt": "2021-12-28T08:49:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "karthigesut"
                          },
                          "bodyText": "@ngrilli is there any free training for moose framework software? i would like to join if there is any.\nThank you.\nKarthi",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-2521401",
                          "updatedAt": "2022-06-06T12:15:12Z",
                          "publishedAt": "2022-04-07T07:22:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThere's the tutorial video on the website\nhttps://mooseframework.inl.gov/index.html\nand we may stream a live training in June, we're still organizing this.  it ll be advertised.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-2524495",
                          "updatedAt": "2022-06-19T20:20:51Z",
                          "publishedAt": "2022-04-07T14:57:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "karthigesut"
                          },
                          "bodyText": "@GiudGiud thanks for your reply.\nI would be happy if you can confirm the date of the training earlier. I presume its a free training.\nThank you sir.\nKarthi",
                          "url": "https://github.com/idaholab/moose/discussions/19539#discussioncomment-2527851",
                          "updatedAt": "2022-06-19T20:20:52Z",
                          "publishedAt": "2022-04-08T02:21:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "where is mixedProductIlJk in RankTwoTensorImplementation.h",
          "author": {
            "login": "howietu0601"
          },
          "bodyText": "Hi, I just upgraded my moose from the version half years ago, but realize lots of changes happened and my own development is totally messed up now. I used \"mixedProductIlJk\" in my code which was in RankTwoTensorImplementation.h before but not now; how can I solve this issue? Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/21467",
          "updatedAt": "2022-06-30T17:29:00Z",
          "publishedAt": "2022-06-30T15:58:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ajacquey"
                  },
                  "bodyText": "Hi,\nI had the same experience a few days ago.\nIt seems that some functions (such as mixedProductXxXx) have been replaced by a more general approach using usingTensorIndices from MooseTypes (see framework/include/utils/MooseTypes.h)\nFirst, you define the indices:\nusingTensorIndices(i_, j_, k_, l_);\n\nAnd then the equivalent (someone please correct me if I'm wrong) for two RankTwoTensor a and b:\na.mixedProductIkJl(b) becomes a.times<i_, k_, j_, l_>(b)\na.mixedProductJkIl(b) becomes a.times<j_, k_, i_, l_>(b)\na.mixedProductIlJk(b) becomes a.times<i_, l_, j_, k_>(b)\nand so on...\nHope that helps.",
                  "url": "https://github.com/idaholab/moose/discussions/21467#discussioncomment-3058298",
                  "updatedAt": "2022-06-30T17:23:04Z",
                  "publishedAt": "2022-06-30T17:23:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}