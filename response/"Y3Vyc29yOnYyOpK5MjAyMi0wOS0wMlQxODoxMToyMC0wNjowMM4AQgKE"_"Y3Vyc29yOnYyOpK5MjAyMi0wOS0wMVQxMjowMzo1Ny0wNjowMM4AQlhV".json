{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOS0wMVQxMjowMzo1Ny0wNjowMM4AQlhV"
    },
    "edges": [
      {
        "node": {
          "title": "Radial displacement asymmetry in cylinder thermomechanical coupling when using displaced mesh",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, MOOSE experts.\nIn thermomechanical coupling, the size of the mesh changes when the object is thermally expanded, and the change in the mesh also affects the temperature field. When I set use_displaced_mesh=true in all blocks, the distribution of disp_x is not symmetric about the x-axis. Likewise, the distribution of disp_y is not symmetric about the y-axis.\n\n\nThen I set use_displaced_mesh=false, the rest of the input file is not modified. The output disp_x and disp_y are symmetric about the x and y axes.\n\n\nWhy are disp_x and disp_y not symmetrical when use_displaced_mesh=true is set? And I've found that the default value of use_displaced_mesh varies in different objects. For example, the default value of use_displaced_mesh for ADHeatConductionTimeDerivative is true, while that for ADCoupledForce is false. Should I set use_displaced_mesh=true for all objects if I want to simulate thermal coupling as accurately as possible?\nAll input and output files are attached.\nuse_displaced_mesh_true.zip\nuse_displaced_mesh_false.zip",
          "url": "https://github.com/idaholab/moose/discussions/21858",
          "updatedAt": "2022-09-02T23:52:52Z",
          "publishedAt": "2022-08-16T14:20:43Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@recuero",
                  "url": "https://github.com/idaholab/moose/discussions/21858#discussioncomment-3407481",
                  "updatedAt": "2022-08-16T15:06:35Z",
                  "publishedAt": "2022-08-16T15:06:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think this was answered somewhere else. Be mindful of solid body modes/rotations was the conclusion",
                          "url": "https://github.com/idaholab/moose/discussions/21858#discussioncomment-3539872",
                          "updatedAt": "2022-09-02T20:09:55Z",
                          "publishedAt": "2022-09-02T20:09:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Yeah, @hugary1995 has solved this problem.#21878 (comment)",
                          "url": "https://github.com/idaholab/moose/discussions/21858#discussioncomment-3540625",
                          "updatedAt": "2022-09-02T23:52:53Z",
                          "publishedAt": "2022-09-02T23:52:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Checkpoints and Restarts Using Vector Variables",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I am implementing the use of restart from a known steady state solution. I have run into a problem with loading the variable velocity which in my app is defined as a vector variable. My new solution will require the use of the velocity defined as vector variable as well, since the kernels are setup to use the variable velocity. Upon using the restart method defined in a previous message listed below I find that the variable listed in the solutions .e file are for each component of velocity and not velocity itself.\nHow do I formulate my argument to read in the velocity components without having to redefine them in the kernels that now currently use the velocity vector function? I appear to be stuck in a do-loop for doing a restart.\n\"you may use either the checkpoint or exodus restart systems to achieve this.\nThe checkpoint system requires you to keep the exact same variables between both simulations. The exodus one is a little more lenient but you ll have to be careful to restart everything you need\nhttps://mooseframework.inl.gov/application_usage/restart_recover.html\"",
          "url": "https://github.com/idaholab/moose/discussions/21998",
          "updatedAt": "2022-09-29T16:28:40Z",
          "publishedAt": "2022-09-02T18:39:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Checkpoint would be more appropriate for a vector variable. I havent done restart with vector variables.\nYou could probably make the exodus restart work going through these two objects\nhttps://mooseframework.inl.gov/source/ics/VectorFunctionIC.html\nhttps://mooseframework.inl.gov/source/functions/SolutionFunction.html\nbut I've never done it either",
                  "url": "https://github.com/idaholab/moose/discussions/21998#discussioncomment-3539726",
                  "updatedAt": "2022-09-02T19:44:19Z",
                  "publishedAt": "2022-09-02T19:44:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Since the pressure drop establishes the velocity, maybe an initial solution for pressure distribution will provide a good start point for the velocity determination? I'm just trying to reduce the number of iterations needed to get to an initial transient solution from the established steady state solution.",
                          "url": "https://github.com/idaholab/moose/discussions/21998#discussioncomment-3539819",
                          "updatedAt": "2022-09-02T19:58:58Z",
                          "publishedAt": "2022-09-02T19:58:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Typically you ll want to initialize both velocity and pressure when you can.\nIf you are running into issues with that, you can ramp up the boundary conditions or ramp down the viscsity over a few seconds of the transient to initialize",
                          "url": "https://github.com/idaholab/moose/discussions/21998#discussioncomment-3539855",
                          "updatedAt": "2022-09-02T20:07:06Z",
                          "publishedAt": "2022-09-02T20:07:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error when running in debug mode DGKernel",
          "author": {
            "login": "ambehnam"
          },
          "bodyText": "Hi everyone,\nI have an input file of a 2 dimensional model including TotalLagrangianStressDivergence kernel and my DGkernel. When I run it in dubug mode, I get the following error:\nAssertion `_current_subdomain_id == _current_elem->subdomain_id()' failed\ncurrent subdomain has been set incorrectly\nat /home/abehnam/Repositories/moose6/framework/src/base/Assembly.C, line 1969 \n\nBut, when I run it in opt mode, the analysis converges quickly. I was wondering what may cause this error in debug mode?\nIt is noticeable that, in my DGKernel, I pass \"const Assembly&  _assembly\" as input argument to a utility class that computes some penalty tensors. However, even in the cases where that part of the code is not executed, I get the same error in debug mode.\nThanks a lot,\nAmir\nThe input file is pasted below:\n[Mesh]\n  [./gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 2\n    xmax = 2\n    ny = 1\n    ymax = 1\n    elem_type = QUAD4\n  [../]\n  [gen_mod]\n    type = MoveNodeGenerator\n    input = gen\n    node_id = '2'\n    new_position = '1.05 1 0'\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n  large_kinematics = false\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n[]\n\n[Modules]\n  [TensorMechanics]\n    [Master]\n      [all]\n        strain = FINITE\n        new_system = true\n        add_variables = true\n        formulation = TOTAL\n        volumetric_locking_correction = false\n        generate_output = 'cauchy_stress_xx cauchy_stress_yy cauchy_stress_xy '\n                          'mechanical_strain_xx mechanical_strain_yy mechanical_strain_xy'                 \n      []\n    []\n  []\n[] \n\n[DGKernels]\n  [./vmns_x]\n    type = VMNSDGKernelSimple\n    variable = disp_x\n    component = 0\n    nis_flag = -1\n    trac_type = 'simple'\n  [../]\n  [./vmns_y]\n    type = VMNSDGKernelSimple\n    variable = disp_y\n    component = 1\n    nis_flag = -1\n    trac_type = 'simple'\n  [../]\n[]\n\n[Materials]\n  [elastic_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 190000.0\n    poissons_ratio = 0.3\n  []\n  [compute_stress]\n    type = ComputeLagrangianLinearElasticStress\n  []\n[]\n\n[BCs]\n  [left]\n    type = DirichletBC\n    preset = true\n    variable = disp_x\n    boundary = left\n    value = 0.0\n  []\n  [bottom]\n    type = DirichletBC\n    preset = true\n    variable = disp_y\n    boundary = bottom\n    value = 0.0\n  []\n  [right]\n    type = DirichletBC\n    preset = true\n    variable = disp_x\n    boundary = right\n    value = 0.1\n  []\n[]\n\n[Executioner]\n  type = Steady\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu superlu_dist'\n  solve_type = NEWTON\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/21897",
          "updatedAt": "2022-09-29T16:28:53Z",
          "publishedAt": "2022-08-19T13:11:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPassing _assembly to a utility does seem a little too deep into the APIs. What attributes are you needing from this?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21897#discussioncomment-3432216",
                  "updatedAt": "2022-08-19T14:55:08Z",
                  "publishedAt": "2022-08-19T14:55:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ambehnam"
                          },
                          "bodyText": "Hi Guillaume. The attributes I need are as follows:\n_current_elem(_assembly.elem()),\n_neighbor_elem(_assembly.neighbor()),\n_current_side(_assembly.side()),\n_neighbor_side(_assembly.neighborSide())\nPreviously I was using InterfaceMaterial and InterfaceKernel and these attributes were available in InterfaceMaterial. In DGKernel, the first 3 are available in  DGKernelBase, but the last one is not available. So I  used _assembly as input to access all of them.\nThanks,\nAmir",
                          "url": "https://github.com/idaholab/moose/discussions/21897#discussioncomment-3432854",
                          "updatedAt": "2022-08-19T16:06:00Z",
                          "publishedAt": "2022-08-19T16:05:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont understand how you can hit this assert when there is no other block ID on the domain.\nCan you add a print statement to see what the two values are?",
                          "url": "https://github.com/idaholab/moose/discussions/21897#discussioncomment-3539828",
                          "updatedAt": "2022-09-02T20:01:03Z",
                          "publishedAt": "2022-09-02T20:01:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Implementing temperature dependent properties with ComputeThermalExpansionEigenstrain",
          "author": {
            "login": "mstapelberg"
          },
          "bodyText": "Hello!\nI am new to MOOSE and writing a thermal stress solver and noticed that the ComputeThermalExpansionEigenstrain function seems to only support material properties supplied as a double. This is according to the documentation : https://mooseframework.inl.gov/source/materials/ComputeThermalExpansionEigenstrain.html\nIs there any way without writing a custom kernel to incorporate temperature dependent material properties for this? I couldn't find an example on the website or in the github repo that implements temperature dependent material properties with ComputeThermalExpansionEigenstrain.\nI am defining material properties in the following way:\n#Tungsten material property from Every et. al                                                                                                                                                                         \n[tungsten_cte]                                                                                                                                                                                                        \n    type = ADPiecewiseLinearInterpolationMaterial                                                                                                                                                                       \n    x = '302.6132 604.5381 1006.5577 1409.3495 1813.4927 2212.3270 2617.8215 3025.5359 3440.6828'                                                                                                                       \n    y = '4.4792e-06 4.7614e-06 5.0436e-06 5.4587e-06 6.1062e-06 6.8532e-06 7.7332e-06 8.9949e-06 11.5351e-06'                                                                                                           \n    property = tungsten_cte                                                                                                                                                                                             \n    variable = T                                                                                                                                                                                                        \n    block = 1                                                                                                                                                                                                           \n[]             \n\nAnd then trying to use them to compute the thermal expansion eigenstrain like so:\n[tungsten_cte_eigenstrain]                                                                                                                                                                                            \n    type = ADComputeThermalExpansionEigenstrain                                                                                                                                                                         \n    temperature = T                                                                                                                                                                                                     \n    thermal_expansion_coeff = tungsten_cte                                                                                                                                                                              \n    stress_free_temperature = 773.15                                                                                                                                                                                    \n    eigenstrain_name = thermal_expansion                                                                                                                                                                                \n    block = 1                                                                                                                                                                                                           \n[]                    \n\nThe current error message I get is the following:\n*** Info ***\nTensorMechanics Action: selecting 'incremental finite strain' formulation.\n\n\n*** ERROR ***\n/home/myless/projects/qt_therm_stress/runfiles/oleg_edits/temp_three_block.i:192: invalid float syntax for parameter: Materials/tungsten_cte_eigenstrain/thermal_expansion_coeff=tungsten_cte\n/home/myless/projects/qt_therm_stress/runfiles/oleg_edits/temp_three_block.i:200: invalid float syntax for parameter: Materials/tungsten_thermal/specific_heat=tungsten_specific_heat\n/home/myless/projects/qt_therm_stress/runfiles/oleg_edits/temp_three_block.i:199: invalid float syntax for parameter: Materials/tungsten_thermal/thermal_conductivity=tungsten_thermal_conductivity\n/home/myless/projects/qt_therm_stress/runfiles/oleg_edits/temp_three_block.i:276: invalid float syntax for parameter: Materials/vanadium_cte_eigenstrain/thermal_expansion_coeff=vanadium_cte\n/home/myless/projects/qt_therm_stress/runfiles/oleg_edits/temp_three_block.i:284: invalid float syntax for parameter: Materials/vanadium_thermal/specific_heat=vanadium_specific_heat\n/home/myless/projects/qt_therm_stress/runfiles/oleg_edits/temp_three_block.i:283: invalid float syntax for parameter: Materials/vanadium_thermal/thermal_conductivity=vanadium_thermal_conductivity\n\n\nStack frames: 10\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&)\n3: Parser::parse(std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&)\n4: MooseApp::setupOptions()\n5: MooseApp::run()\n6: main\n7: /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7f96287e7d90]\n8: __libc_start_main\n9: ../../qt_therm_stress-opt(+0x33ef) [0x5574577dc3ef]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n\n\nMoose was also updated on 2022/08/04.\nThanks,\nMyles\nCan upload complete input file if needed.",
          "url": "https://github.com/idaholab/moose/discussions/21785",
          "updatedAt": "2022-09-02T20:05:25Z",
          "publishedAt": "2022-08-05T14:07:53Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@recuero @dschwen",
                  "url": "https://github.com/idaholab/moose/discussions/21785#discussioncomment-3348185",
                  "updatedAt": "2022-08-08T10:12:14Z",
                  "publishedAt": "2022-08-08T10:12:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "You can compute all of those using ParsedMaterial and ComputeVariableDependentEigenstrain. That would give you the most flexibility for your formulation.",
                  "url": "https://github.com/idaholab/moose/discussions/21785#discussioncomment-3539776",
                  "updatedAt": "2022-09-02T19:51:59Z",
                  "publishedAt": "2022-09-02T19:51:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to calculate the uncertainty of the total energy calculated by MOOSE?",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nHow can I calculate the uncertainty of the total energy calculated by MOOSE?\nIn my MOOSE input files, I used the following commands to calculate the total energy.\n\nIs there a function in MOOSE that can automatically calculate the uncertainty of the total energy?\nThank you.\nBest,",
          "url": "https://github.com/idaholab/moose/discussions/21814",
          "updatedAt": "2022-09-29T16:29:43Z",
          "publishedAt": "2022-08-10T00:14:35Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can do parametric studies on your uncertain parameters then examine the free energy using the stochastic module\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21814#discussioncomment-3539743",
                  "updatedAt": "2022-09-02T19:47:19Z",
                  "publishedAt": "2022-09-02T19:47:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "An error occurred during software installation",
          "author": {
            "login": "zhangyu3230"
          },
          "bodyText": "(moose) zhangyu@AZY:/mnt/c/For_MOOSE/projects/moose/test$ make -j 4.3\nCommand 'make' not found, but can be installed with:\nsudo apt install make        # version 4.3-4.1build1, or\nsudo apt install make-guile  # version 4.3-4.1build1\n(moose) zhangyu@AZY:/mnt/c/For_MOOSE/projects/moose/test$",
          "url": "https://github.com/idaholab/moose/discussions/21997",
          "updatedAt": "2022-09-29T16:32:24Z",
          "publishedAt": "2022-09-02T03:47:55Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "What's the result of running conda list? Paste text only, please. Do not include screenshots.",
                  "url": "https://github.com/idaholab/moose/discussions/21997#discussioncomment-3536193",
                  "updatedAt": "2022-09-02T12:41:08Z",
                  "publishedAt": "2022-09-02T12:41:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Proper weak form",
          "author": {
            "login": "Leni-Yeo"
          },
          "bodyText": "Good morning,\nI am trying to figure out what the weak form from the last part (kernel) in \"New phase-field model for polycrystalline systems with anisotropic grain boundary properties\" from \"Nele Moelans\" would look like: -m\u25bd .  (\u2211_(j\u2260i) ((\u2202\u03b3_ij)/(\u2202\u25bd\u03b7_i )) \u03b7_i^2  \u03b7_j^2)\n\nI think the weak form should be : ( ( (-1) * m * 2 * \u03b7_i * grad(\u03b7_i) * (\u2202\u03b3_ij)/(\u2202\u25bd\u03b7_i ) * \u2211_(j\u2260i)  \u03b7_j^2 ) , \u03c8 )\nI am taking everything outside the gradient as constants and doing \u25bd . \u03b7_i^2 =  \u03b7_i * grad(\u03b7_i)  +  \u03b7_i * grad(\u03b7_i) =  2 * \u03b7_i * grad(\u03b7_i)\nI am not sure if I am correct on that. If anyone has some insight, please advise since I am relatively new to phase field.\nThank you in advance.",
          "url": "https://github.com/idaholab/moose/discussions/21937",
          "updatedAt": "2022-09-29T16:33:10Z",
          "publishedAt": "2022-08-25T17:15:26Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthe derivation of the weak form looks too short. There seems to be many more terms in your base equation than in your result\nFeel free to paste a step by step derivation and we could point you to potential issues\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21937#discussioncomment-3491260",
                  "updatedAt": "2022-08-28T04:18:56Z",
                  "publishedAt": "2022-08-28T00:12:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Leni-Yeo"
                          },
                          "bodyText": "Good afternoon,\nThank you for the reply and sorry for the delay in response.\nI redid the derivation and corrected a mistake I  found. I attached the new derivation. Please give your inputs on it whenever you can.\nThank you in advance.!\nLast Kernel Derivation.pdf",
                          "url": "https://github.com/idaholab/moose/discussions/21937#discussioncomment-3529936",
                          "updatedAt": "2022-09-01T19:17:32Z",
                          "publishedAt": "2022-09-01T19:17:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont see the grad (eta_i^2) in your initial equation? I see grad(eta_i^2 eta_j^2)?\nalso why is there only one term in your derivation?\nIs this the only term you care about?",
                          "url": "https://github.com/idaholab/moose/discussions/21937#discussioncomment-3530068",
                          "updatedAt": "2022-09-01T19:37:19Z",
                          "publishedAt": "2022-09-01T19:37:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Leni-Yeo"
                          },
                          "bodyText": "I assumed the summation of eta_j^2 and the fraction (partial derivative) to come out from under the gradient operator as constants so that the the gradient operator only applies to eta_i^2. I thought that would be the case since only the ith order parameter is considered each time. I might be wrong there. ???",
                          "url": "https://github.com/idaholab/moose/discussions/21937#discussioncomment-3530195",
                          "updatedAt": "2022-09-01T19:58:37Z",
                          "publishedAt": "2022-09-01T19:58:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is eta_j not a variable?\nthere are off-diagonal terms as well in the Jacobian, so eta_j being in the equation for eta_i will mean some of these contributions",
                          "url": "https://github.com/idaholab/moose/discussions/21937#discussioncomment-3530578",
                          "updatedAt": "2022-09-01T20:52:31Z",
                          "publishedAt": "2022-09-01T20:52:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Leni-Yeo"
                  },
                  "bodyText": "I see. I guess I will try again. Please advise whenever you can. Thank you!\n\u2026\nOn Thu, Sep 1, 2022, 3:52 PM Guillaume Giudicelli ***@***.***> wrote:\n is eta_j not a variable?\n there are off-diagonal terms as well in the Jacobian, so eta_j being in\n the equation for eta_i will mean some of these contributions\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21937 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ASUM7YWQSDJU7FANQZ43CA3V4EJRVANCNFSM57T4X5NA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/21937#discussioncomment-3530754",
                  "updatedAt": "2022-09-01T21:22:00Z",
                  "publishedAt": "2022-09-01T21:21:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I recommend you lean hard on the examples in the phase field module. Try to identify models that are similar to what you are doing.\nAlso you should just leverage automatic differentiation if you can. Then you wont have to worry about coding up a jacobian, just the residual",
                          "url": "https://github.com/idaholab/moose/discussions/21937#discussioncomment-3530866",
                          "updatedAt": "2022-09-01T21:44:34Z",
                          "publishedAt": "2022-09-01T21:44:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Leni-Yeo"
                  },
                  "bodyText": "Will do. Thank you!\n\u2026\nOn Thu, Sep 1, 2022, 4:44 PM Guillaume Giudicelli ***@***.***> wrote:\n I recommend you lean hard on the examples in the phase field module. Try\n to identify models that are similar to what you are doing.\n\n Also you should just leverage automatic differentiation if you can. Then\n you wont have to worry about coding up a jacobian, just the residual\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21937 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ASUM7YSRC3PDSVEFHTKWFJTV4EPUXANCNFSM57T4X5NA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/21937#discussioncomment-3531367",
                  "updatedAt": "2022-09-01T23:21:36Z",
                  "publishedAt": "2022-09-01T23:21:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "NumSideQPs and NumElemQPs",
          "author": {
            "login": "Flolaffel"
          },
          "bodyText": "Hello,\nI was trying to experiment with the Quadrature-Block a bit and wanted to check the resulting number of QPs with NumSideQPs and NumElemQPs but it seems like my application can't find the objects. The error I get is\n*** ERROR ***\nA 'NumSideQPs' is not a registered object.\n\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\n\nI guess it's because the .C files are located in the moose/test folder rather than in some module folder. But I don't quite know how to use the MOOSE_LIBRARY_PATH environment variable to resolve that issue. What do I have to do to access said objects?",
          "url": "https://github.com/idaholab/moose/discussions/21987",
          "updatedAt": "2022-09-01T21:20:19Z",
          "publishedAt": "2022-09-01T16:45:33Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think they are test objects. You ll have to pass the allow-test-objects flag to use them\nI think you ll need to add the BUILD_TEST_OBJECTS boolean in the makefile too.\nand possibly just move the source from moose/test to your repo in last resort",
                  "url": "https://github.com/idaholab/moose/discussions/21987#discussioncomment-3528932",
                  "updatedAt": "2022-09-01T16:54:09Z",
                  "publishedAt": "2022-09-01T16:54:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "The MOOSE documentation only shows the flag --disallow-test-objects. Doesn't that imply that --allow-test-objects is the default?\nI tried BUILD_TEST_OBJECTS := yes in my Makefile but it didn't help. I also tried BUILD_TEST_OBJECTS_LIB := yes because that command is used in the moose_test-opt Makefile. Didn't help either.\n\nI also copied the files in my repo but had no success with that either. Which is kind of confusing.\nWhat else can I try?",
                          "url": "https://github.com/idaholab/moose/discussions/21987#discussioncomment-3529642",
                          "updatedAt": "2022-09-01T18:33:38Z",
                          "publishedAt": "2022-09-01T18:32:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "move the test source files in your app then recompile",
                          "url": "https://github.com/idaholab/moose/discussions/21987#discussioncomment-3530032",
                          "updatedAt": "2022-09-01T19:30:21Z",
                          "publishedAt": "2022-09-01T19:30:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "That's what I meant when I said\nI also copied the files in my repo but had no success with that either. Which is kind of confusing. (and recompiled my app afterwards)\nStill not working.",
                          "url": "https://github.com/idaholab/moose/discussions/21987#discussioncomment-3530254",
                          "updatedAt": "2022-09-01T20:07:23Z",
                          "publishedAt": "2022-09-01T20:07:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Re-register them to your application. Not mooseTestApp. See the source file at the top",
                          "url": "https://github.com/idaholab/moose/discussions/21987#discussioncomment-3530293",
                          "updatedAt": "2022-09-01T20:13:15Z",
                          "publishedAt": "2022-09-01T20:13:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "I can't quite follow. You mean copy the .C into intro/src and the .h into intro/include and then recompile with make, right? Because that's what I did and it doesn't work.",
                          "url": "https://github.com/idaholab/moose/discussions/21987#discussioncomment-3530344",
                          "updatedAt": "2022-09-01T20:20:35Z",
                          "publishedAt": "2022-09-01T20:20:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "modify them too\nopen the source you ll see the call to register to MooseTestApp",
                          "url": "https://github.com/idaholab/moose/discussions/21987#discussioncomment-3530348",
                          "updatedAt": "2022-09-01T20:21:28Z",
                          "publishedAt": "2022-09-01T20:21:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Ok well that worked. Thanks!\nIn case anyone with equally slim knowledge of C++ stumbles across this in the future:\nI copied the files in question to my own app. Then I had to change registerMooseObject(\"MooseTestApp\", NumSideQPs); to registerMooseObject(\"introTestApp\", NumSideQPs); and run my input with the --allow-test-objects flag. Modifications to the Makefile are not necessary for this workaround to work.",
                          "url": "https://github.com/idaholab/moose/discussions/21987#discussioncomment-3530641",
                          "updatedAt": "2022-09-01T21:02:34Z",
                          "publishedAt": "2022-09-01T21:02:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if enough users need these objects we can move them outside of the test objects and into the official objects. Please let us know, future readers of this thread",
                          "url": "https://github.com/idaholab/moose/discussions/21987#discussioncomment-3530655",
                          "updatedAt": "2022-09-01T21:05:37Z",
                          "publishedAt": "2022-09-01T21:05:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Relevant executioner params for inelastic materials problems",
          "author": {
            "login": "AndrewFalkowski"
          },
          "bodyText": "In trying to incorporate inelastic stress responses in my models, I've run into a number issues with convergence stability. The example input files included under the material docs for inelastic stress computation tend to have more sophisticated executioner blocks (example). I am wondering if there is any information on relevant executioner params (or considerations) for improving convergence in solving inelastic stress problems with creep and/or plastic deformation? Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/21973",
          "updatedAt": "2022-09-29T16:33:15Z",
          "publishedAt": "2022-08-30T17:44:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@hugary1995 @dschwen",
                  "url": "https://github.com/idaholab/moose/discussions/21973#discussioncomment-3512565",
                  "updatedAt": "2022-08-30T21:13:06Z",
                  "publishedAt": "2022-08-30T21:13:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I wonder if we don't already have a page talking about solvers in the tensor mechanics module. Anyways, here are some general considerations:\n\nThe non AD kernels/materials in the old system give inaccurate Jacobian, hence you are better off using PJFNK.\nThe AD kernels/materials give exact Jacobian, so Newton should perform better.\nFor preconditioner, a direct solver will generally perform the best if you have enough memory. If memory is a concern, you should use an iterative solver. Hyper/boomeramg is a very effective iterative solver for plasticity/creep problems.\n\nLet us know which route you want to take, and we can provide more details regarding settings and solver parameters.",
                  "url": "https://github.com/idaholab/moose/discussions/21973#discussioncomment-3522188",
                  "updatedAt": "2022-08-31T22:58:15Z",
                  "publishedAt": "2022-08-31T22:58:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AndrewFalkowski"
                          },
                          "bodyText": "Thank you this was helpful. Assuming I am using the AD kerneIs, what would be the best approach for modeling plasticity and creep in a multi-material composite subject to thermal strains with materials exhibiting temperature dependent properties? And would you use different solver setup if you were solving plasticity or creep alone?\nAlso, could you elaborate a little more or point me to a resource discussing direct solver vs. iterative solver options?\nThanks",
                          "url": "https://github.com/idaholab/moose/discussions/21973#discussioncomment-3529564",
                          "updatedAt": "2022-09-01T18:18:46Z",
                          "publishedAt": "2022-09-01T18:18:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "A direct solver can be specified by\npetsc_option_iname = '-pc_type'\npetsc_option_value = 'lu'\nThen choose your favorite parallel implementation of the matrix factorization package using -mat_factor_solver_package, typically your options are superlu_dist, mumps and strumpack.\nHypre/Boomeramg is documented here https://mooseframework.inl.gov/application_development/hypre.html\n\nAssuming I am using the AD kerneIs, what would be the best approach for modeling plasticity and creep in a multi-material composite subject to thermal strains with materials exhibiting temperature dependent properties? And would you use different solver setup if you were solving plasticity or creep alone?\n\nThis depends on the material. If the solid softens with temperature increase, then the nature of the problem won't change much compared to plasticity alone. Hence you can use similar options for the iterative solver.\nIf the solid hardens with temperature increase, then you'll be dealing with a potentially non-convex system. The usual path forward is\n\nlagging the temperature, or\nusing fixed point iteration, or\nusing a solver that handles local nonconvexity, e.g. trust-region or CG.",
                          "url": "https://github.com/idaholab/moose/discussions/21973#discussioncomment-3529731",
                          "updatedAt": "2022-09-01T18:54:54Z",
                          "publishedAt": "2022-09-01T18:45:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Well, actually in most cases there is heat loss due to thermal softening, and you are back to an easy, convex problem, hence you probably don't need the \"usual path forward\" methods...",
                          "url": "https://github.com/idaholab/moose/discussions/21973#discussioncomment-3529752",
                          "updatedAt": "2022-09-01T18:48:37Z",
                          "publishedAt": "2022-09-01T18:48:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AndrewFalkowski"
                          },
                          "bodyText": "Ah ok that makes a lot of sense. I seem to be getting a more stable solve, but I think my tolerances are off as I am having trouble with nonlinear convergence. How (and under what block) should one go about setting these tolerances? I was reading through this page, but I'm still not sure about the general application of these.",
                          "url": "https://github.com/idaholab/moose/discussions/21973#discussioncomment-3530100",
                          "updatedAt": "2022-09-01T19:41:58Z",
                          "publishedAt": "2022-09-01T19:41:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AndrewFalkowski"
                          },
                          "bodyText": "Realized this might be because I am near a steady state, but general advice on setting those tolerances would be appreciated.",
                          "url": "https://github.com/idaholab/moose/discussions/21973#discussioncomment-3530281",
                          "updatedAt": "2022-09-01T20:10:53Z",
                          "publishedAt": "2022-09-01T20:10:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Strange Translation/Jittering Artifact in Phase Field Model",
          "author": {
            "login": "aclin4"
          },
          "bodyText": "I've encountered some strange behavior with one of my phase field models that I was wondering if anyone else has come across before. It's a fairly standard 2-phase (1 order parameter) 3-species (2 concentration variables) WBM model. In the two-phase region of my model, I observe the expected phase separation behavior, but it seems that my model seems to jitter randomly, translating in the x-direction after separating.\nHave anyone ever seen this before or have any idea of what could be causing this?\nThanks,\nAlbert",
          "url": "https://github.com/idaholab/moose/discussions/21972",
          "updatedAt": "2022-09-29T16:33:45Z",
          "publishedAt": "2022-08-30T17:20:58Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@SudiptaBiswas @laagesen",
                  "url": "https://github.com/idaholab/moose/discussions/21972#discussioncomment-3512560",
                  "updatedAt": "2022-08-30T21:12:33Z",
                  "publishedAt": "2022-08-30T21:12:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "That is weird. What boundary conditions are you using for all the variables? The behavior of the psi=1 phase on the LHS seems a little weird and I'm wondering if there may be some inconsistency in the BCs.\nAlso, what are your solver settings? You are approaching a steady-state condition at the end, so the Transient Executioner may struggle to converge the problem as you approach the steady-state. If you've increased nl_rel_tol to deal with this, that could potentially cause problems. Usually if you want to run a problem all the way to steady-state, it's best to set an absolute solver tolerance using nl_abs_tol = 1e-11 or something along those lines. There are fancier ways to do this in MOOSE, but that has usually worked well for me in the past.",
                          "url": "https://github.com/idaholab/moose/discussions/21972#discussioncomment-3519040",
                          "updatedAt": "2022-08-31T15:26:36Z",
                          "publishedAt": "2022-08-31T15:26:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Also I assume the variable here is a non-conserved order parameter because it doesn't look like it is being conserved (volume fraction seems to increase at the end). But, for a coupled model that may indicate that there is a problem with volume conservation with one of your conserved variables. I would add a postprocessor to integrate each of your concentration variables at each time step and make sure they are being conserved.",
                          "url": "https://github.com/idaholab/moose/discussions/21972#discussioncomment-3519065",
                          "updatedAt": "2022-08-31T15:29:26Z",
                          "publishedAt": "2022-08-31T15:29:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aclin4"
                          },
                          "bodyText": "Hi Larry,\nYou're right that the order parameter shown here is non-conserved; it's just evolving the phase fraction to accommodate concentration-enriched and depleted phases. I've checked that the concentration variables are indeed conserved throughout the simulation.\nFor all the variables, I'm using periodic boundary conditions:\n[BCs]\n  [./Periodic]\n    [./all]\n      variable = 'c_cr c_ni psi w_ni w_cr'\n      auto_direction = 'x y'\n    [../]\n  [../]\n[]\n\nwhich is probably why there is an additional interface that appears on the left side of the simulation cell.\nAs for the Executioner settings, it seems that all the parameters are already pretty close to what you've suggested.\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu      superlu_dist'\n  line_search = 'none'\n\n  nl_max_its = 20\n  l_max_its = 20\n  l_tol = 1e-12\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-12\n  end_time = 1e15\n  #dtmax = 1e6\n  dtmin = 2e-20\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1e-3\n    cutback_factor = 0.5\n    growth_factor = 1.25\n    optimal_iterations = 12\n  [../]\n[]\n\nI thought it may be due to the way I set up my mesh adaptivity:\n[Adaptivity]\n  marker = combo\n  max_h_level = 2\n  [./Indicators]\n    [./psiind]\n      type = GradientJumpIndicator\n      variable = psi\n    [../]\n    [./Niind]\n      type = GradientJumpIndicator\n      variable = c_ni\n    [../]\n    [./Crind]\n      type = GradientJumpIndicator\n      variable = c_cr\n    [../]\n    [./wNiind]\n      type = GradientJumpIndicator\n      variable = w_ni\n    [../]\n    [./wCrind]\n      type = GradientJumpIndicator\n      variable = w_cr\n    [../]\n  [../]\n  [./Markers]\n   [./combo]\n     type = ComboMarker\n     markers =  'psierror cnierror ccrerror wcrerror wnierror'\n   [../]\n    [./psierror]\n      type = ErrorFractionMarker\n      coarsen = 0.2\n      indicator = psiind\n      refine = 0.7\n    [../]\n    [./cnierror]\n      type = ErrorFractionMarker\n      coarsen = 0.2\n      indicator = Niind\n      refine = 0.7\n    [../]\n    [./ccrerror]\n      type = ErrorFractionMarker\n      coarsen = 0.2\n      indicator = Crind\n      refine = 0.7\n    [../]\n    [./wcrerror]\n      type = ErrorFractionMarker\n      coarsen = 0.2\n      indicator = wCrind\n      refine = 0.7\n    [../]\n    [./wnierror]\n      type = ErrorFractionMarker\n      coarsen = 0.2\n      indicator = wNiind\n      refine = 0.7\n    [../]\n  [../]\n[]\n\nDoes that seem reasonable to you?\nThanks,\nAlbert",
                          "url": "https://github.com/idaholab/moose/discussions/21972#discussioncomment-3529006",
                          "updatedAt": "2022-09-01T17:09:28Z",
                          "publishedAt": "2022-09-01T17:03:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "I think you might have too many different markers/indicators. It could be refinement/coarsening is happening too frequently based on different interfacial widths for different variables and how the settings interact with them. It could be that excessive coarsening/refinement is causing the interfaces to move when you are suddenly solving the governing equations on a different grid, especially if the amount of refinement changes a lot between time steps. I would try solving the problem without mesh refinement to see if that makes the problem go away. Also I'd make sure your concentration variables are conserved based on what I observed before about the volume fraction.",
                          "url": "https://github.com/idaholab/moose/discussions/21972#discussioncomment-3529463",
                          "updatedAt": "2022-09-01T18:03:58Z",
                          "publishedAt": "2022-09-01T18:03:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}