{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wOS0yOVQwOTo1OTo0NC0wNjowMM4AVraK"
    },
    "edges": [
      {
        "node": {
          "title": "Console printout",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "All,\nI am using the method shown below for the console printout.  In this manner, the log information for all processors used for a run is printed in the console output file; namely, the same printout is repeated as many as processors used.  Is there any way the log information for only one processor is printed without repeating the log information for the rest of the processors?\nPlease help.\nS. Thomas\n[Outputs]\n       . \n       .\n  [./console]\n    type = Console\n    output_file = true\n  [../]\n       .\n       .\n[ ]",
          "url": "https://github.com/idaholab/moose/discussions/25632",
          "updatedAt": "2023-10-03T01:11:42Z",
          "publishedAt": "2023-09-29T22:04:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt should already be that way.\nWhat does the header say at the top of the simulation for the number of processes?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25632#discussioncomment-7148793",
                  "updatedAt": "2023-09-29T22:24:38Z",
                  "publishedAt": "2023-09-29T22:24:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you, Guillaume.\nIt reads\nParallelism:\nNum Processors: 6\nNum Threads:      1\nDoes this help?\nS. Thomas",
                          "url": "https://github.com/idaholab/moose/discussions/25632#discussioncomment-7148959",
                          "updatedAt": "2023-09-29T22:55:51Z",
                          "publishedAt": "2023-09-29T22:55:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok this is normal.\nYou should not get output from each process in this configuration. Unless you pass --keep-co\u00fbt on the command line you should only see output from rank 0",
                          "url": "https://github.com/idaholab/moose/discussions/25632#discussioncomment-7149392",
                          "updatedAt": "2023-09-30T01:21:11Z",
                          "publishedAt": "2023-09-30T01:21:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you, Guillaume.\nYes that is true for the printout on the \"console.\"  My question is the printout in the console output \"file\" as \"output_file = true.\"  Is it supposed that the same printout is repeated as many as processors used in the output file?\nI apologize that I confused you.\nPlease help.\nS. Thomas",
                          "url": "https://github.com/idaholab/moose/discussions/25632#discussioncomment-7167315",
                          "updatedAt": "2023-10-02T16:38:19Z",
                          "publishedAt": "2023-10-02T16:38:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah ok I guess that doesnt work?\ndo this instead:\n--keep-cout --redirect-stdout and that will redirect the console output to a bunch of files",
                          "url": "https://github.com/idaholab/moose/discussions/25632#discussioncomment-7167329",
                          "updatedAt": "2023-10-02T16:40:05Z",
                          "publishedAt": "2023-10-02T16:40:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you, Guillaume.\nI think Linux commend \">\" works.\nS. Thomas",
                          "url": "https://github.com/idaholab/moose/discussions/25632#discussioncomment-7168872",
                          "updatedAt": "2023-10-02T19:45:26Z",
                          "publishedAt": "2023-10-02T19:45:26Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Grain boundary misorientation",
          "author": {
            "login": "mdh23rct"
          },
          "bodyText": "Dear MOOSE experts,\nI am simulating a grain growth problem using phase field. For that, I am using this tutorial of MOOSE:\n# This initializes a polycrystal from random seeds at each node\n# Mesh adaptivity and time step adaptivity are used\n# Grain tracker is started once the grain structure is established\n##########################\n[Mesh]\n  # Mesh block.  Meshes can be read in or automatically generated\n  type = GeneratedMesh\n  dim = 2 # Problem dimension\n  nx = 40 # Number of elements in the x-direction\n  ny = 40 # Number of elements in the y-direction\n  xmax = 1000 # maximum x-coordinate of the mesh\n  ymax = 1000 # maximum y-coordinate of the mesh\n  elem_type = QUAD4 # Type of elements used in the mesh\n  uniform_refine = 2 # Initial uniform refinement of the mesh\n\n  parallel_type = replicated # Periodic BCs\n[]\n\n[GlobalParams]\n  # Parameters used by several kernels that are defined globally to simplify input file\n  op_num = 10 # Number of grains\n  var_name_base = gr # Base name of grains\n[]\n\n[Modules]\n  [PhaseField]\n    [GrainGrowth]\n    []\n  []\n[]\n\n[ICs]\n  [PolycrystalICs]\n    [PolycrystalRandomIC]\n      random_type = discrete\n    []\n  []\n[]\n\n[AuxVariables]\n  # Dependent variables\n  [./unique_grains]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./var_indices]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./bnds]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n[AuxKernels]\n  # AuxKernel block, defining the equations used to calculate the auxvars\n  [unique_grains]\n    type = FeatureFloodCountAux\n    variable = unique_grains\n    flood_counter = grain_tracker\n    field_display = UNIQUE_REGION\n    execute_on = 'initial timestep_end'\n  []\n  [var_indices]\n    type = FeatureFloodCountAux\n    variable = var_indices\n    flood_counter = grain_tracker\n    field_display = VARIABLE_COLORING\n    execute_on = 'initial timestep_end'\n  []\n  [./BndsCalc]\n    type = BndsCalcAux\n    variable = bnds\n  [../]\n[]\n\n[BCs]\n  # Boundary Condition block\n  [Periodic]\n    [top_bottom]\n      auto_direction = 'x y' # Makes problem periodic in the x and y directions\n    []\n  []\n[]\n\n[Materials]\n  [CuGrGr]\n    # Material properties\n    type = GBEvolution # Quantitative material properties for copper grain growth.  Dimensions are nm and ns\n    GBmob0 = 2.5e-6 # Mobility prefactor for Cu from Schonfelder1997\n    GBenergy = 0.708 # GB energy for Cu from Schonfelder1997\n    Q = 0.23 # Activation energy for grain growth from Schonfelder 1997\n    T = 450 # Constant temperature of the simulation (for mobility calculation)\n    wGB = 14 # Width of the diffuse GB\n  []\n[]\n\n[UserObjects]\n  [grain_tracker]\n    type = GrainTracker\n    tracking_step = 20 #Tracking is delayed until the polycrystalline structure is established\n  []\n[]\n###################################\n\nUsing these code, I would like to read the GB misorientation during the grain growth. I am seeing, for that one way is using:\n  [./GB_type]\n    # The new developed Miso Bnds Aux Kernel\n    type = ComputeGBMisorientationType\n    ebsd_reader = ebsd_reader\n    grain_tracker = grain_tracker\n    output_properties = 'gb_type'\n    outputs = exodus\n  [../]\n\nHowever, ComputeGBMisorientationType implements an ebsd reader, which is not for the grain growth code aforementioned. So is there any other way to determine the GB misorientation, while using these grain growth code?\nI would appreciate your advice.\nBest regards.",
          "url": "https://github.com/idaholab/moose/discussions/25635",
          "updatedAt": "2023-10-02T14:55:55Z",
          "publishedAt": "2023-09-30T15:33:36Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen @amjokisaari",
                  "url": "https://github.com/idaholab/moose/discussions/25635#discussioncomment-7152737",
                  "updatedAt": "2023-09-30T17:38:19Z",
                  "publishedAt": "2023-09-30T17:38:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "@simopier do you have enough experience from helping your intern over the summer to help answer this question?",
                  "url": "https://github.com/idaholab/moose/discussions/25635#discussioncomment-7166136",
                  "updatedAt": "2023-10-02T14:55:55Z",
                  "publishedAt": "2023-10-02T14:55:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ICs From CSV",
          "author": {
            "login": "gj19866"
          },
          "bodyText": "Hi there,\nStill new to MOOSE and getting used to what it has built-in to help!\nI am trying to set up the initial conditions of a variable from a CSV.\nIs there a 'best' way to do this?\nI am currently using the PropertyReadFile user object, to write a function using PiecewiseConstantFromCSV, and then writing that to an IC using FunctionIC.\nI'm sure there must be a better way to do this!\nFor reference the reason I think I need to use a CSV is because there are two variables, x and y, and x^2+y^2=1, and I want x to be random between -1 to 1, so I have written a python script to write a .csv.\nIt would also be cool to know if I could use something else in MOOSE to solve the whole problem!\nThanks,\nGillian",
          "url": "https://github.com/idaholab/moose/discussions/25638",
          "updatedAt": "2023-10-02T11:43:47Z",
          "publishedAt": "2023-10-01T22:39:29Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can also write your IC object directly in C++. You can either read a CSV directly there or even generate the initial condition there too\nThe 3 objects route you are using right now is fine. It's just that way to make sure that only one object has to read the CSV file.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25638#discussioncomment-7160174",
                  "updatedAt": "2023-10-02T00:18:48Z",
                  "publishedAt": "2023-10-02T00:18:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "\u00d2h amazing! In that case I'll leave it how it is for now, then I can always optimise later!\nThank you Guillamue,\nGillian",
                          "url": "https://github.com/idaholab/moose/discussions/25638#discussioncomment-7163839",
                          "updatedAt": "2023-10-02T11:04:01Z",
                          "publishedAt": "2023-10-02T11:04:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MultiAppGeneralFieldShapeEvaluationTransfer Bug?",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "Very weird difference in results, below. I am using a transfer to have it so where every node \"under\" the main mesh should be 1 or else 0. The answer changes whether I use allow_renumbering = false or commented it out.  I only had allow_renumbering = false because of a debugging issue. MWE is below.\nallow_renumbering = false\n\nallow_renumbering = false commented out\n\nmain.i\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n[Problem]\n  kernel_coverage_check = false\n  material_coverage_check = false\n[]\n[Mesh]\n\n  # allow_renumbering = false\n  [gen]\n    type = ConcentricCircleMeshGenerator\n    radii = 0.05\n    num_sectors = 2\n    rings = 1\n    has_outer_square = off\n    preserve_volumes = true\n  []\n  [side]\n    type = SideSetsAroundSubdomainGenerator\n    block = 1\n    input = gen\n    new_boundary = \"embedded\"\n  []\n  [trans]\n    type = TransformGenerator\n    input = side\n    transform = TRANSLATE\n    vector_value = '0.20 0.2 0'\n  []\n  # [new_bound]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = side\n  #   bottom_left = ' -5 -5 -5'\n  #   top_right = '5 5 5'\n  #   new_boundary = all\n  # []\n[]\n\n[Variables]\n  [disp_x]\n\n  []\n  [disp_y]\n\n  []\n[]\n\n[AuxVariables] # variables that are calculated for output\n  [solid_indicator]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 1.0\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  end_time = 100\n  dt = 100\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_ksp_ew'\n  petsc_options_iname = '-pc_type -pc_hypre_type '\n  petsc_options_value = 'hypre    boomeramg'\n  nl_max_its = 500\n  l_max_its = 500\n  nl_abs_tol = 1e-7\n  nl_rel_tol = 1e-7\n  fixed_point_rel_tol = 1e-4\n  fixed_point_abs_tol = 1e-3\n  fixed_point_max_its = 3\n  # dont keep this\n  accept_on_max_fixed_point_iteration = true\n  snesmf_reuse_base = false\n  fixed_point_min_its = 1\n  line_search = 'none'\n  auto_advance = false\n\n[]\n\n[Outputs]\n  [exo]\n    type = Exodus\n    additional_execute_on = \"FINAL\"\n  []\n\n[]\n\n[MultiApps]\n  [fluid_domain]\n    type = TransientMultiApp\n    execute_on = \"INITIAL TIMESTEP_END\"\n    input_files = rec.i\n    keep_solution_during_restore = false\n  []\n[]\n\n[Transfers]\n  [push_indicator]\n    type = MultiAppGeneralFieldShapeEvaluationTransfer\n    # Transfer from the sub-app from this app\n    to_multi_app = fluid_domain\n    # The name of the variable in this app\n    source_variable = solid_indicator\n    # The name of the auxiliary variable in the sub-app\n    variable = indicator\n    # execute_on = 'INITIAL  TIMESTEP_END'\n    displaced_source_mesh = true\n    greedy_search = true\n  []\n\n[]\n\n\n\nrec.i\n[Mesh]\n  construct_side_list_from_node_list = true\n  [gen]\n    type = GeneratedMeshGenerator\n    xmin = 0\n    xmax = 2.5\n    ymin = 0\n    ymax = 0.4\n    nx = 120\n    ny = 20\n    # nx = 1250\n    # ny = 100\n    dim = 2\n  []\n  [new_elem]\n    type = SubdomainBoundingBoxGenerator\n    input = gen\n    block_id = 3\n    bottom_left = '0.185 0.18 -0.1'\n    top_right = '0.21 0.23 0.1'\n  []\n  [side]\n    type = SideSetsAroundSubdomainGenerator\n    input = new_elem\n    new_boundary = moving_solid\n    block = 3\n  []\n[]\n\n[Problem]\n  kernel_coverage_check = false\n  material_coverage_check = false\n[]\n\n[Variables]\n\n  [dummy]\n  []\n[]\n\n[AuxVariables]\n  [indicator]\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  dt = 100\n  line_search = 'l2'\n  nl_abs_tol = 1e-6\n  nl_rel_tol = 1e-8\n  nl_max_its = 30\n  l_max_its = 100\n  auto_advance = false\n  [TimeIntegrator]\n    type = ImplicitEuler\n  []\n\n[]\n\n[Outputs]\n  [exo]\n    type = Exodus\n    additional_execute_on = \"FINAL\"\n  []\n[]\n\n[Preconditioning]\n  active = 'SMP'\n  [SMP]\n    type = SMP\n    full = true\n    # petsc_options_iname = ' -pc_type -pc_factor_mat_solver_package -pc_factor_shift_type -pc_factor_shift_amount'\n    # petsc_options_value = ' lu       mumps NONZERO 1e-14'\n    petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap -sub_pc_factor_shift_type -sub_pc_factor_shift_amount'\n    petsc_options_value = ' asm      200                 preonly       lu           2               NONZERO              1e-15'\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/25637",
          "updatedAt": "2023-10-02T00:49:08Z",
          "publishedAt": "2023-10-01T17:20:56Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is run in parallel right?\nIf you output_process_domains in Debug block, is the boundary between domains nearby?\nDoes:\n\nincreasing the size of the bounding box (with the bbox_factor)\nusing greedy_search (using that parameter's name)\n\nhelp stabilize it?\nThe allow_renumbering = false is the right answer right?",
                  "url": "https://github.com/idaholab/moose/discussions/25637#discussioncomment-7158891",
                  "updatedAt": "2023-10-01T18:01:51Z",
                  "publishedAt": "2023-10-01T18:01:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "also is the transfer outputting a warning by any chance?",
                          "url": "https://github.com/idaholab/moose/discussions/25637#discussioncomment-7158903",
                          "updatedAt": "2023-10-01T18:03:41Z",
                          "publishedAt": "2023-10-01T18:03:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Not run in parallel, and no warning even when run on debug.\nI did try to increase size of bbox but no change. What do you mean about parameter name for greedy search?",
                          "url": "https://github.com/idaholab/moose/discussions/25637#discussioncomment-7159112",
                          "updatedAt": "2023-10-01T18:45:55Z",
                          "publishedAt": "2023-10-01T18:44:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "When  allow_renumbering = false is commented out, that is the correct answer.",
                          "url": "https://github.com/idaholab/moose/discussions/25637#discussioncomment-7159137",
                          "updatedAt": "2023-10-01T18:52:45Z",
                          "publishedAt": "2023-10-01T18:52:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh how recent is this moose? we fixed a bug last week, I did not think it had affected anyone for ShapeEvaluation but it was in its base class",
                          "url": "https://github.com/idaholab/moose/discussions/25637#discussioncomment-7159225",
                          "updatedAt": "2023-10-01T19:14:46Z",
                          "publishedAt": "2023-10-01T19:14:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "On Petsc 3.19 so atleast whenever that change was made, but I will pull the latest branch to make sure it's all up to date.",
                          "url": "https://github.com/idaholab/moose/discussions/25637#discussioncomment-7159240",
                          "updatedAt": "2023-10-01T19:18:46Z",
                          "publishedAt": "2023-10-01T19:18:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Tested on the latest branch, still has the incorrect answer with allow_renumbering = false.",
                          "url": "https://github.com/idaholab/moose/discussions/25637#discussioncomment-7159678",
                          "updatedAt": "2023-10-01T21:21:49Z",
                          "publishedAt": "2023-10-01T21:21:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok thanks for checking. Do you have a MWE?",
                          "url": "https://github.com/idaholab/moose/discussions/25637#discussioncomment-7160178",
                          "updatedAt": "2023-10-02T00:19:16Z",
                          "publishedAt": "2023-10-02T00:19:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "The first post has two input files to copy. They created the pictures posted.",
                          "url": "https://github.com/idaholab/moose/discussions/25637#discussioncomment-7160282",
                          "updatedAt": "2023-10-02T00:49:08Z",
                          "publishedAt": "2023-10-02T00:49:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "General Contact Question",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi, quick one I think, with regards to contact, when surfaces are considered being in contact, would that impact all variables? I.e. would the solution of different physics/variables also be impacted other than those for displacements? For example, If I were doing a mechanical-electrical coupling, would the contact that is done mechanically allow 'current' to flow? Or would that have to be enabled elsewhere?",
          "url": "https://github.com/idaholab/moose/discussions/25630",
          "updatedAt": "2023-10-01T20:23:05Z",
          "publishedAt": "2023-09-29T20:09:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo unless you define the mortar contact for these variables too. Which should be possible in quite the same way? Depends what the numerical scheme looks like\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25630#discussioncomment-7148221",
                  "updatedAt": "2023-09-29T20:34:39Z",
                  "publishedAt": "2023-09-29T20:34:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Right, if you want some physics across a mortar interface, whether in contact or not, you will have to code that physics in a mortar constraint object",
                          "url": "https://github.com/idaholab/moose/discussions/25630#discussioncomment-7148607",
                          "updatedAt": "2023-09-29T21:45:09Z",
                          "publishedAt": "2023-09-29T21:45:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Ok, for now if I didnt, could I do that all natively with MOOSE input syntax? I have a niche use case where, I would like to apply a Neumann boundary condition on the nodes that are contact, that I presume would be possible writing my own App, but would that possible with a 'no code' solution?",
                          "url": "https://github.com/idaholab/moose/discussions/25630#discussioncomment-7150234",
                          "updatedAt": "2023-09-30T07:21:59Z",
                          "publishedAt": "2023-09-30T07:21:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is this an equal gradient type of situation? We have this constraint\nhttps://mooseframework.inl.gov/moose/source/constraints/EqualGradientConstraint.html\nor is there a jump due to different diffusivities or some interface resistance?",
                          "url": "https://github.com/idaholab/moose/discussions/25630#discussioncomment-7151315",
                          "updatedAt": "2023-09-30T12:13:57Z",
                          "publishedAt": "2023-09-30T12:13:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Yes it would be equal gradient, basically its to mimic the source of friction due to the two entities being in contact, whilst one of them is rotating.",
                          "url": "https://github.com/idaholab/moose/discussions/25630#discussioncomment-7159315",
                          "updatedAt": "2023-10-01T19:43:45Z",
                          "publishedAt": "2023-10-01T19:43:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The mechanical friction has its own sets of constraints iirc.\n@recuero will know.\nSo the problem is mechanical frictional contact + electrical contact?",
                          "url": "https://github.com/idaholab/moose/discussions/25630#discussioncomment-7159326",
                          "updatedAt": "2023-10-01T19:46:52Z",
                          "publishedAt": "2023-10-01T19:46:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Equal gradient and contact mechanics aren't necessarily analogous. For the same contact pressure, you could get very different gradients in the two bodies in contact, which would depend on the material models.",
                          "url": "https://github.com/idaholab/moose/discussions/25630#discussioncomment-7159460",
                          "updatedAt": "2023-10-01T20:20:08Z",
                          "publishedAt": "2023-10-01T20:20:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Yes, Coulomb friction has its own set of constraints.",
                          "url": "https://github.com/idaholab/moose/discussions/25630#discussioncomment-7159463",
                          "updatedAt": "2023-10-01T20:20:46Z",
                          "publishedAt": "2023-10-01T20:20:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "just mechanical friction + thermal, I was using electrical as an analogue, but I would be interested in electrical-mechanical contact in another downstream application. I did search the documentation and objects for 'friction' and stuff related to temperature, as it really the DT due to heat from friction im intersted in\n\u2026\nOn Oct 1 2023, at 8:47 pm, Guillaume Giudicelli ***@***.***> wrote:\n\n\n The mechanical friction has its own sets of constraints iirc.\n @recuero ***@***.***/0?redirect=https%3A%2F%2Fgithub.com%2Frecuero&recipient=cmVwbHkrQUFTVFVTU0pXM0s3RjYyU0VNNVVKUEdERTM3VE5FVkJNWEhBQVZXREJNQHJlcGx5LmdpdGh1Yi5jb20%3D) will know.\n So the problem is mechanical frictional contact + electrical contact?\n\n\n \u2014\n Reply to this email directly, view it on GitHub ***@***.***/1?redirect=https%3A%2F%2Fgithub.com%2Fidaholab%2Fmoose%2Fdiscussions%2F25630%23discussioncomment-7159326&recipient=cmVwbHkrQUFTVFVTU0pXM0s3RjYyU0VNNVVKUEdERTM3VE5FVkJNWEhBQVZXREJNQHJlcGx5LmdpdGh1Yi5jb20%3D), or unsubscribe ***@***.***/2?redirect=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAASTUSTZAOLTDFRWRFT4CWLX5HCDNANCNFSM6AAAAAA5M6DG4M&recipient=cmVwbHkrQUFTVFVTU0pXM0s3RjYyU0VNNVVKUEdERTM3VE5FVkJNWEhBQVZXREJNQHJlcGx5LmdpdGh1Yi5jb20%3D).\n You are receiving this because you authored the thread.",
                  "url": "https://github.com/idaholab/moose/discussions/25630#discussioncomment-7159352",
                  "updatedAt": "2023-10-01T19:51:17Z",
                  "publishedAt": "2023-10-01T19:51:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "That's seems doable. You can compute the energy dissipated due to friction (maybe via an auxiliary kernel) and then use it as a heat source term?",
                          "url": "https://github.com/idaholab/moose/discussions/25630#discussioncomment-7159473",
                          "updatedAt": "2023-10-01T20:23:05Z",
                          "publishedAt": "2023-10-01T20:23:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Writing a postprocessor kernel to calculate the kinetic energy",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello everyone,\nI am trying to write a new kernel similar to the LevelSetVolume. I want it to calculate the volume integral of the kinetic energy inside the c=0 contour. I am doing the following, but I see this error.\n\nmissing required parameter 'Postprocessors/Total_KE/vel_x'\n\tDoc String: \"The x-axis velocity\"\n\n#pragma once\n\n// MOOSE includes\n#include \"ElementVariablePostprocessor.h\"\n\n/**\n * Postprocessor to compute the area/volume inside and outside of a level set contour.\n */\nclass LevelSetVolumeKE : public ElementVariablePostprocessor\n{\npublic:\n  static InputParameters validParams();\n\n  LevelSetVolumeKE(const InputParameters & parameters);\n\n  virtual void initialize() override;\n  virtual void finalize() override;\n  virtual void execute() override;\n  virtual Real getValue() override;\n  virtual void threadJoin(const UserObject & y) override;\n  virtual void computeQpValue() override{};\n\nprotected:\n  /// The accumulated volume to return as a PostprocessorValue\n  Real _volume;\n\n  /// The level set contour to consider for computing inside vs. outside of the volume\n  const Real & _threshold;\n\n  /// Flag for triggering the internal volume calculation\n  const bool _inside;\n  const VariableValue & _u_vel;\n  const VariableValue & _v_vel;\n  const VariableValue & _w_vel;\n};\n\n#include \"LevelSetVolumeKE.h\"\n\nregisterMooseObject(\"LevelSetApp\", LevelSetVolumeKE);\n\nInputParameters\nLevelSetVolumeKE::validParams()\n{\n  InputParameters params = ElementVariablePostprocessor::validParams();\n  params.addClassDescription(\n      \"Compute the area or volume of the region inside or outside of a level set contour.\");\n  params.addParam<Real>(\n      \"threshold\", 0.0, \"The level set threshold to consider for computing area/volume.\");\n\n  MooseEnum loc(\"inside=0 outside=1\", \"inside\");\n  params.addParam<MooseEnum>(\"location\", loc, \"The location of the area/volume to be computed.\");\n  params.addRequiredCoupledVar(\"vel_x\", \"The x-axis velocity\");\n  params.addCoupledVar(\"vel_y\", 0, \"The y-axis velocity\");\n  params.addCoupledVar(\"vel_z\", 0, \"The z-axis velocity\");\n  return params;\n}\n\nLevelSetVolumeKE::LevelSetVolumeKE(const InputParameters & parameters)\n  : ElementVariablePostprocessor(parameters),\n    _threshold(getParam<Real>(\"threshold\")),\n    _inside(getParam<MooseEnum>(\"location\") == \"inside\"),\n    _u_vel(coupledValue(\"u\")),\n    _v_vel(_mesh.dimension() >= 2 ? coupledValue(\"v\") : _zero),\n    _w_vel(_mesh.dimension() == 3 ? coupledValue(\"w\") : _zero)\n{\n}\n\nvoid\nLevelSetVolumeKE::initialize()\n{\n  _volume = 0;\n}\n\nvoid\nLevelSetVolumeKE::execute()\n{\n  Real cnt = 0;\n  Real n = _u.size();\n\n  // Perform the check for inside/outside outside the qp loop for speed\n  if (_inside)\n  {\n    for (_qp = 0; _qp < n; ++_qp)\n      if (_u[_qp] <= _threshold)\n        cnt++;\n  }\n  else\n  {\n    for (_qp = 0; _qp < n; ++_qp)\n      if (_u[_qp] > _threshold)\n        cnt++;\n  }\n  _volume += cnt / n * _current_elem_volume * 0.5 * (_u_vel[_qp]*_u_vel[_qp]+_v_vel[_qp]*_v_vel[_qp]+_w_vel[_qp]*_w_vel[_qp]);\n}\n\nvoid\nLevelSetVolumeKE::finalize()\n{\n  gatherSum(_volume);\n}\n\nReal\nLevelSetVolumeKE::getValue()\n{\n  return _volume;\n}\n\nvoid\nLevelSetVolumeKE::threadJoin(const UserObject & y)\n{\n  const LevelSetVolumeKE & pps = static_cast<const LevelSetVolumeKE &>(y);\n  _volume += pps._volume;\n}",
          "url": "https://github.com/idaholab/moose/discussions/25633",
          "updatedAt": "2023-09-30T23:23:50Z",
          "publishedAt": "2023-09-29T22:36:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nLooks like you are adding a required coupled variable parameter to specify the X axis, but then in the input file this parameter is missing?\nHow are you using this object in the input file?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7149400",
                  "updatedAt": "2023-09-30T01:25:12Z",
                  "publishedAt": "2023-09-30T01:25:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "[./Total_KE]\n    type = LevelSetVolumeKE\n    threshold = 0.0\n    u = vel_x\n    v = vel_y\n    variable = c\n\n    location = outside\n\n    execute_on = 'initial timestep_end'\n  [../]",
                          "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7149495",
                          "updatedAt": "2023-09-30T02:11:32Z",
                          "publishedAt": "2023-09-30T02:11:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You called the parameter vel_x not u?",
                          "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7149518",
                          "updatedAt": "2023-09-30T02:20:14Z",
                          "publishedAt": "2023-09-30T02:20:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Yes, the main variable name in the input file is vel_x.",
                          "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7149523",
                          "updatedAt": "2023-09-30T02:21:29Z",
                          "publishedAt": "2023-09-30T02:21:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes but you set the u parameter instead of the vel_x parameter\nTry vel_x = vel_x for th\u00e9 parameter",
                          "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7149559",
                          "updatedAt": "2023-09-30T02:35:19Z",
                          "publishedAt": "2023-09-30T02:35:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Thanks, it fixed the issue and now it is running.\nHowever, it just returns zero means that postprocessor is not working correctly. I know that velocity field is correctly calculated. Is it the correct way to calculate the integral of  (0.5*velocity^2)d(volume)?",
                          "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7149632",
                          "updatedAt": "2023-09-30T03:15:27Z",
                          "publishedAt": "2023-09-30T03:15:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No it doesn't look right.\nYou re writing the computeIntegral function instead of just the Qp term, e.g. the computeQpIntegral function\nI would look at another postprocessor that does an integral for an example",
                          "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7149662",
                          "updatedAt": "2023-09-30T03:35:15Z",
                          "publishedAt": "2023-09-30T03:35:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "ElementIntegralVariablePostprocessor is the right one which needs modification. It needs to get the phase field variable (c) and then perform integration only inside of the c=0 contour quadrature points, not the whole domain. Is this possible? I would highly appreciate it if I can get some help for this.",
                          "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7153355",
                          "updatedAt": "2023-09-30T20:43:16Z",
                          "publishedAt": "2023-09-30T20:43:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "where does c=0 happen? on the quadrature points in an element, or really anywhere within the elements?",
                          "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7153398",
                          "updatedAt": "2023-09-30T20:54:51Z",
                          "publishedAt": "2023-09-30T20:54:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "I think the quadrature points since mesh is pretty fine in that region.\nFor example, I use levelsetvolume kernel to calculate the volume inside c=0 contour and it works very well.\nHere some images to show the mesh and c=0 contour.",
                          "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7153454",
                          "updatedAt": "2023-09-30T21:09:51Z",
                          "publishedAt": "2023-09-30T21:09:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if it's just on the 'inside' of the contour, it's still a volume right?\ncould you just modify computeQpIntegral to do:\nif (c[qp] > 0)\nreturn 0;\nso you only count when c <= 0",
                          "url": "https://github.com/idaholab/moose/discussions/25633#discussioncomment-7153615",
                          "updatedAt": "2023-09-30T22:05:43Z",
                          "publishedAt": "2023-09-30T22:05:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Create primary-secondary interface pair from disconnected mesh",
          "author": {
            "login": "chunhuizhao478"
          },
          "bodyText": "Hi all, I try to seek for other options without using \"BreakMeshByBlockGenerator\" to handle interface calculations:\nI generate two mesh block (0 - top(grey), 1 - bottom(red) ) as follows\n[Mesh]\n    [generated0]\n        type = GeneratedMeshGenerator\n        dim = 2\n        nx = 201\n        ny = 200\n        xmin = -10050\n        xmax = 10050\n        ymin = 0\n        ymax = 10000\n        boundary_name_prefix = pillar1\n    []\n    [rename_block0]\n        type = RenameBoundaryGenerator\n        input = generated0\n        old_boundary = '0 1 2 3'\n        new_boundary = 'block0_bottom block0_right block0_left block0_top'\n    []\n    [block0_id]\n        type = SubdomainIDGenerator\n        input = rename_block0\n        subdomain_id = 0\n    []\n    [generated1]\n        type = GeneratedMeshGenerator\n        dim = 2\n        nx = 201\n        ny = 200\n        xmin = -10050\n        xmax = 10050\n        ymin = -10000\n        ymax = 0\n        boundary_name_prefix = pillar2\n        boundary_id_offset = 4\n    []\n    [rename_block1]\n        type = RenameBoundaryGenerator\n        input = generated1\n        old_boundary = '4 5 6 7'\n        new_boundary = 'block1_bottom block1_right block1_left block1_top'\n    []\n    [block1_id]\n        type = SubdomainIDGenerator\n        input = rename_block1\n        subdomain_id = 1\n    []\n    [collect]\n        type = MeshCollectionGenerator\n        inputs = 'block0_id block1_id'\n    []\n[]\n\n\nNow I would like to do calculations based on the two boundaries in the center, I know I could extract boundary information from both sides by using a InterfaceMaterial or InterfaceKernel, but in order to achieve it, I need to somehow assign primary-secondary information to link the two interfaces (like creating a \"Block0_Block1\" in what BreakMeshByBlockGenerator could achieve by splitting the single mesh, here I already have two interfaces), I'm not sure if it is feasible to do or not.",
          "url": "https://github.com/idaholab/moose/discussions/25627",
          "updatedAt": "2023-09-29T22:22:59Z",
          "publishedAt": "2023-09-29T16:32:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "SideSetsBetweenSubdomainsGenerator is what I used in the first interface kernel examples I created",
                  "url": "https://github.com/idaholab/moose/discussions/25627#discussioncomment-7148788",
                  "updatedAt": "2023-09-29T22:23:00Z",
                  "publishedAt": "2023-09-29T22:22:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about the return type for computeQpResidual",
          "author": {
            "login": "Wolke926"
          },
          "bodyText": "I want to add an additional term in NS equation. In my kernel, if the return type should be ADReal but my equation is a vector, how do I add the index component part? Do you know if there are any examples I can refer to?\n\nInputParameters\nSurfaceTension::validParams()\n{\nInputParameters params = ADKernel::validParams();\nparams.addClassDescription(\"Add surface tension term in NS equation\");\nparams.addCoupledVar(\"u\", \"velocity\");\nparams.addCoupledVar(\"w\", \"the coupled chemical potential\");\nparams.addCoupledVar(\"phi\", \"the coupled order parameter\");\n\nreturn params;\n}\n\nSurfaceTension::SurfaceTension(const InputParameters & parameters)\n: ADKernel(parameters),\n_op(adCoupledValue (\"phi\")),\n_grad_w(adCoupledGradient (\"w\"))\n{\n}\n\nADReal\nSurfaceTension::computeQpResidual()\n{\nreturn _op[_qp] * _grad_w[_qp] * _test[_i][_qp]; //the grad_w should be split into x,y,z component\n}",
          "url": "https://github.com/idaholab/moose/discussions/25497",
          "updatedAt": "2023-09-29T21:20:55Z",
          "publishedAt": "2023-09-18T15:26:35Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf u (the velocity) is a vector variable, you need to be using a VectorKernel base class, so here an ADVectorKernel\nthen the computeQpResidual will be an ADRealVectorValue return type\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7036389",
                  "updatedAt": "2023-09-18T15:31:31Z",
                  "publishedAt": "2023-09-18T15:31:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "So the included header file is dependent on the variable's type?\nI tried ADRealVectorValue but there are still some errors.\n\n.h file:\n#pragma once\n\n#include \"ADVectorKernel.h\"\n\nclass SurfaceTension : public ADVectorKernel\n{\npublic:\nstatic InputParameters validParams();\n\nSurfaceTension(const InputParameters & parameters);\n\nprotected:\n\nvirtual ADRealVectorValue computeQpResidual() override;\n\nconst ADVariableValue & _op;\nconst ADVariableGradient & _grad_w;\n\n};\n\n.c file:\n#include \"ADSurfaceTension.h\"\n\nregisterMooseObject(\"testApp\", SurfaceTension);\n\nInputParameters\nSurfaceTension::validParams()\n{\nInputParameters params = ADVectorKernel::validParams();\nparams.addClassDescription(\"Add surface tension term in NS equation\");\nparams.addCoupledVar(\"u\", \"velocity\");\nparams.addCoupledVar(\"w\", \"the coupled chemical potential\");\nparams.addCoupledVar(\"phi\", \"the coupled order parameter\");\n\nreturn params;\n}\n\nSurfaceTension::SurfaceTension(const InputParameters & parameters)\n: ADVectorKernel(parameters),\n_op(adCoupledValue (\"phi\")),\n_grad_w(adCoupledGradient (\"w\"))\n{\n}\n\nADRealVectorValue\nSurfaceTension::computeQpResidual()\n{\nreturn _op[_qp] * _grad_w[_qp] * _test[_i][_qp];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7036752",
                          "updatedAt": "2023-09-18T16:06:43Z",
                          "publishedAt": "2023-09-18T16:04:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah ok I was wrong.\nIt's still an ADReal, even for a vector variable",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7036786",
                          "updatedAt": "2023-09-18T16:07:02Z",
                          "publishedAt": "2023-09-18T16:07:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "So I still have to split the grad_w into different components? Otherwise, the return type can not be consistent.",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7036845",
                          "updatedAt": "2023-09-18T16:13:03Z",
                          "publishedAt": "2023-09-18T16:13:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "No you should not be doing anything with components. You could look at INSADMomentumPressure as an example that uses the gradient of a scalar in the momentum equation",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7037033",
                          "updatedAt": "2023-09-18T16:28:41Z",
                          "publishedAt": "2023-09-18T16:28:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so if you look at ADVectorKernel.h you see we just include ADKernel.h\nthat's because a template for an ADKernel is used, and instantiated with a vector for ADVectorKernels\nyou look at _test and see that it's\n  const ADTemplateVariableTestValue<T> & _test;\n\nT is a vector here. This template is defined in MooseTypes.h\ntemplate <typename T>\nusing ADTemplateVariableTestValue = typename OutputTools<T>::VariableTestValue;\n\nthen higher in that file:\n  typedef MooseArray<std::vector<OutputShape>> VariableTestValue;\n\n(OutputShape is T)\nso you are dealing here with an array of vectors of vectors.\nso _test[_i][_qp], with two indexings, is a vector now\nand grad_w times this vector is a scalar",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7037314",
                          "updatedAt": "2023-09-18T16:58:14Z",
                          "publishedAt": "2023-09-18T16:54:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "Thank you guys, I just modified my code like INSADMomentumPressure and successfully compiled it without error.\nBut I am still curious why are we using _coord_sys and _rz_radial_coord? Besides, why should we integrate p by parts? Namely this part of the code:\nADReal\nINSADMomentumPressure::computeQpResidual()\n{\n  if (_integrate_p_by_parts)\n\n  {\n    ADReal residual = -_p[_qp] * _grad_test[_i][_qp].tr();\n    if (_coord_sys == Moose::COORD_RZ)\n    {\n      const auto r_component_residual = -_p[_qp] / _ad_q_point[_qp](_rz_radial_coord);\n      ADRealVectorValue rz_residual;\n      rz_residual(_rz_radial_coord) = r_component_residual;\n      residual += rz_residual * _test[_i][_qp];\n    }\n    return residual;\n  }\n  else\n    return _test[_i][_qp] * _grad_p[_qp];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7038266",
                          "updatedAt": "2023-09-18T19:38:30Z",
                          "publishedAt": "2023-09-18T18:54:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For rz, if you compute grad P in cylindrical coordinates with an integration by parts you ll see this extra term\nFor integration by parts, it s a modeling decision. The BC are different depending on whether you integrated by parts or not.\nI cant remember which one is easier but feel free to look through the BC code",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7038300",
                          "updatedAt": "2023-09-18T18:58:40Z",
                          "publishedAt": "2023-09-18T18:58:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "Compared to INSADMomentumPressure,  I have an additional order parameter part, so I multiplied _op in the following code:\nIs that right?\nADReal\nADSurfaceTension::computeQpResidual()\n{\n  if (_integrate_w_by_parts)\n  {\n    ADReal residual = - _w[_qp] * `_op[_qp]*` _grad_test[_i][_qp].tr();\n    if (_coord_sys == Moose::COORD_RZ)\n    {\n      const auto r_component_residual = -_w[_qp] * `_op[_qp]` / _ad_q_point[_qp](_rz_radial_coord);\n      ADRealVectorValue rz_residual;\n      rz_residual(_rz_radial_coord) = r_component_residual;\n      residual += rz_residual  *  _test[_i][_qp];\n    }\n    return residual;\n  }\n else\nreturn `_op[_qp]` * _grad_w[_qp] * _test[_i][_qp];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7038579",
                          "updatedAt": "2023-09-18T19:38:19Z",
                          "publishedAt": "2023-09-18T19:37:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "looks fine to me",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7038601",
                          "updatedAt": "2023-09-18T19:39:42Z",
                          "publishedAt": "2023-09-18T19:39:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "Hi GiudGiud,\nWhen I compiled this new kernel and added it to my input file, there is a problem:\n\nhere is the input file part using my new kernel:\n[./surface_L]\n type = ADSurfaceTension\n variable = velocity\n op = eta_L\n w = w_1\n integrate_w_by_parts = true\n[../]",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7145656",
                          "updatedAt": "2023-09-29T15:11:56Z",
                          "publishedAt": "2023-09-29T15:10:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Wolke926"
                  },
                  "bodyText": "Actually, I have already added integrate_w_by_parts in this list\nregisterMooseObject(\"testApp\", ADSurfaceTension);\n\nInputParameters\nADSurfaceTension::validParams()\n{\nInputParameters params = ADVectorKernel::validParams();\nparams.addClassDescription(\"Add surface tension term in NS equation\");\nparams.addRequiredCoupledVar(\"w\", \"the coupled chemical potential\");\nparams.addRequiredCoupledVar(\"op\", \"the coupled order parameter\");\n params.addParam<bool>(\n      \"integrate_w_by_parts\", true, \"Whether to integrate the chemical potential term by parts\");\nreturn params;\n}\n\nADSurfaceTension::ADSurfaceTension(const InputParameters & parameters)\n: ADVectorKernel(parameters), \n_integrate_w_by_parts(getParam<bool>(\"integrate_w_by_parts\")),\n_w(adCoupledValue (\"w\")),\n_grad_w(adCoupledGradient (\"w\")),\n_op(adCoupledValue (\"op\")),\n_coord_sys(_assembly.coordSystem()),\n_rz_radial_coord(_mesh.getAxisymmetricRadialCoord())\n{\n     auto & obj_tracker = const_cast<INSADObjectTracker &>(\n      _fe_problem.getUserObject<INSADObjectTracker>(\"ins_ad_object_tracker\"));\n  for (const auto block_id : blockIDs())\n    obj_tracker.set(\"integrate_w_by_parts\", _integrate_w_by_parts, block_id);\n}\n\nADReal\nADSurfaceTension::computeQpResidual()\n{\n  if (_integrate_w_by_parts)\n  {\n    ADReal residual = - _w[_qp] * _op[_qp]* _grad_test[_i][_qp].tr();\n    if (_coord_sys == Moose::COORD_RZ)\n    {\n      const auto r_component_residual = -_w[_qp] * _op[_qp] / _ad_q_point[_qp](_rz_radial_coord);\n      ADRealVectorValue rz_residual;\n      rz_residual(_rz_radial_coord) = r_component_residual;\n      residual += rz_residual  *  _test[_i][_qp];\n    }\n    return residual;\n  }\n else\nreturn _op[_qp] * _grad_w[_qp] * _test[_i][_qp];\n}",
                  "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7146419",
                  "updatedAt": "2023-09-29T16:38:05Z",
                  "publishedAt": "2023-09-29T16:33:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "why this\n     auto & obj_tracker = const_cast<INSADObjectTracker &>(\n      _fe_problem.getUserObject<INSADObjectTracker>(\"ins_ad_object_tracker\"));\n  for (const auto block_id : blockIDs())\n    obj_tracker.set(\"integrate_w_by_parts\", _integrate_w_by_parts, block_id);",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7146469",
                          "updatedAt": "2023-09-29T16:39:13Z",
                          "publishedAt": "2023-09-29T16:39:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If you really want this included in stabilization and to compute the object's residuals in the INSAD materials then you will need to add this parameter to the INSADObjectTracker's parameters",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7148426",
                          "updatedAt": "2023-09-29T21:13:50Z",
                          "publishedAt": "2023-09-29T21:13:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok but it's integrate p by parts for that object not w",
                          "url": "https://github.com/idaholab/moose/discussions/25497#discussioncomment-7148483",
                          "updatedAt": "2023-09-29T21:20:56Z",
                          "publishedAt": "2023-09-29T21:20:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ADFunctorElementalAux misbehaving?",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi I've found a weird issue, maybe I'm using it wrong. Maybe we can figure out if this is a bug, but also a better way to do what I actually want to do would be useful too.\nlibMesh terminating:\nElement type not supported:TET4\nStack frames: 34\n0: libMesh::print_trace(std::ostream&)\n1: libMesh::MacroFunctions::report_error(char const*, int, char const*, char const*, std::ostream&)\n2: libMesh::QGauss::init_2D(libMesh::ElemType, unsigned int)\n3: libMesh::FE<3u, (libMesh::FEFamily)0>::reinit(libMesh::Elem const*, std::vector<libMesh::Point, std::allocator<libMesh::Point> > const*, std::vector<double, std::allocator<double> > const*)\n4: Function::determineElemXYZ(std::tuple<libMesh::Elem const*, unsigned int, libMesh::QBase const*> const&) const\n5: Function::evaluate(std::tuple<libMesh::Elem const*, unsigned int, libMesh::QBase const*> const&, Moose::StateArg const&) const\n6: Moose::ADWrapperFunctor<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, unsigned long, MetaPhysicL::NWrapper<600ul> >, true> >::evaluate(std::tuple<libMesh::Elem const*, unsigned int, libMesh::QBase const*> const&, Moose::StateArg const&) const\n7: Moose::FunctorBase<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, unsigned long, MetaPhysicL::NWrapper<600ul> >, true> >::operator()(std::tuple<libMesh::Elem const*, unsigned int, libMesh::QBase const*> const&, Moose::StateArg const&) const\n8: Moose::FunctorEnvelope<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, unsigned long, MetaPhysicL::NWrapper<600ul> >, true> >::evaluate(std::tuple<libMesh::Elem const*, unsigned int, libMesh::QBase const*> const&, Moose::StateArg const&) const\n9: Moose::FunctorBase<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, unsigned long, MetaPhysicL::NWrapper<600ul> >, true> >::operator()(std::tuple<libMesh::Elem const*, unsigned int, libMesh::QBase const*> const&, Moose::StateArg const&) const\n10: FunctorElementalAuxTempl<true>::computeValue()\n11: AuxKernelTempl<double>::compute()\n12: ComputeElemAuxBcsThread<AuxKernelTempl<double> >::operator()(libMesh::StoredRange<MooseMesh::const_bnd_elem_iterator, BndElement const*> const&)\n13: void libMesh::Threads::parallel_reduce<libMesh::StoredRange<MooseMesh::const_bnd_elem_iterator, BndElement const*>, ComputeElemAuxBcsThread<AuxKernelTempl<double> > >(libMesh::StoredRange<MooseMesh::const_bnd_elem_iterator, BndElement const*> const&, ComputeElemAuxBcsThread<AuxKernelTempl<double> >&)\n14: void AuxiliarySystem::computeElementalVarsHelper<AuxKernelTempl<double> >(MooseObjectWarehouse<AuxKernelTempl<double> > const&)\n15: AuxiliarySystem::computeElementalVars(MooseEnumItem)\n16: AuxiliarySystem::compute(MooseEnumItem)\n17: FEProblemBase::computeResidualTags(std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n18: FEProblemBase::computeResidualInternal(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n19: FEProblemBase::computeResidualSys(libMesh::NonlinearImplicitSystem&, libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&)\n20: NonlinearSystem::solve()\n21: FEProblemBase::solve(unsigned int)\n22: FEProblemSolve::solve()\n23: FixedPointSolve::solveStep(double&, double&, std::set<unsigned long, std::less<unsigned long>, std::allocator<unsigned long> > const&)\n24: FixedPointSolve::solve()\n25: TimeStepper::step()\n26: Transient::takeStep(double)\n27: Transient::execute()\n28: MooseApp::executeExecutioner()\n29: MooseApp::run()\n30: main\n31: /lib64/libc.so.6(+0x27550) [0x7f0c9e44a550]\n32: __libc_start_main\n33: /home/adavis/opt/moose/moose/modules/combined/combined-opt() [0x4044f5]\n[0] ../src/quadrature/quadrature_gauss_2D.C, line 1299, compiled Jun 19 2023 at 15:34:30\n\nThe whole input is here\n[Mesh]\n  type = FileMesh\n  file = 'break-disk.e'\n  patch_size = 80\n  patch_update_strategy = auto\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n  \n[Variables]\n  [disp_x]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [disp_y]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [disp_z]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [temp]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [temp_in_C]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [stress_xx_nodal]\n    order = FIRST\n    family = MONOMIAL\n  []\n  [strain_xx_nodal]\n    order = FIRST\n    family = MONOMIAL\n  []\n  [stress_yy_nodal]\n    order = FIRST\n    family = MONOMIAL\n  []\n  [strain_yy_nodal]\n    order = FIRST\n    family = MONOMIAL\n  []\n  [stress_zz_nodal]\n    order = FIRST\n    family = MONOMIAL\n  []\n  [strain_zz_nodal]\n    order = FIRST\n    family = MONOMIAL\n  []\n  [vonmises_nodal]\n    order = FIRST\n    family = MONOMIAL\n  []\n  [heat_flux]\n    order = FIRST\n    family = MONOMIAL\n  []\n[]\n\n[ICs]\n  [temp-initial]\n    type = ConstantIC\n    variable = temp\n    value = 293.15\n  []\n[]\n  \n[Kernels]\n  [TensorMechanics] \n     displacements = 'disp_x disp_y disp_z'\n     generate_output = 'strain_xx strain_yy strain_zz vonmises_stress'\n     eigenstrain_names = 'eigenstrain'\n     use_automatic_differentiation = true\n  []\n[]\n\n[AuxKernels]\n  [K_to_C]\n    type = ParsedAux\n    variable = 'temp_in_C'\n    function = 'temp - 273.15'\n    args = 'temp'\n  []\n  [stress_xx]\n    type = ADRankTwoAux\n    rank_two_tensor = stress\n    variable = stress_xx_nodal\n    index_i = 0\n    index_j = 0\n  []\n  [strain_xx]\n    type = ADRankTwoAux\n    rank_two_tensor = total_strain\n    index_i = 0\n    index_j = 0\n    variable = strain_xx_nodal\n  []\n  [stress_yy]\n    type = ADRankTwoAux\n    rank_two_tensor = stress\n    variable = stress_yy_nodal\n    index_i = 1\n    index_j = 1\n  []  \n  [strain_yy]\n    type = ADRankTwoAux\n    rank_two_tensor = total_strain\n    variable = strain_yy_nodal\n    index_i = 1\n    index_j = 1\n  []\n  [stress_zz]\n    type = ADRankTwoAux\n    rank_two_tensor = stress\n    variable = stress_zz_nodal\n    index_i = 2\n    index_j = 2\n  []\n  [strain_zz]\n    type = ADRankTwoAux\n    rank_two_tensor = total_strain\n    variable = strain_zz_nodal\n    index_i = 2\n    index_j = 2\n  []\n  [vonmises]\n    type = ADRankTwoScalarAux\n    rank_two_tensor = stress\n    variable = vonmises_nodal\n    scalar_type = VonMisesStress\n  []\n  [calc-heat-flux]\n    type = ADFunctorElementalAux\n    functor = breaking-heat-flux\n    variable = heat_flux\n    boundary = 'break-pad-surface'\n  []\n[]\n\n[Postprocessors]\n  [stress_on_plate]\n    type = SideAverageValue\n    variable = stress_zz_nodal\n    boundary = break-pad-surface\n  []\n  [heat_flux]\n    type = SideAverageValue\n    variable = heat_flux\n    boundary = break-pad-surface\n  []\n[]\n  \n[Functions]\n   [304ss_thermal-expansion]\n    # Data from prebuilt material library\n    # for material\n    type = PiecewiseLinear\n    x = '293.15 323.15 373.15 423.15 473.15 523.15 573.15 623.15 673.15 723.15 773.15 823.15 873.15 923.15 973.15 1023.15 1073.15 1123.15 1173.15 122\n3.15 1273.15'\n    y = '15.3 15.5 15.9 16.2 16.6 16.9 17.2 17.5 17.8 18.0 18.3 18.5 18.7 18.9 19.0 19.2 19.3 19.5 19.6 19.7 19.7'\n    scale_factor = 1e-6\n  []\n  [speed]\n    type = ADParsedFunction  \n    # seeing as the model is centred on the axis, rotating around z\n    # radius = sqrt(x**2 + y**2)\n    expression = 'w*sqrt(x^2 + y^2)'\n    symbol_names = 'w'\n    symbol_values = '${angular_velocity_r}'\n  []\n  [breaking-heat-flux]\n    type = ADParsedFunction\n    expression = 'abs(sigma)*mu*v*0.5'\n    symbol_names = 'sigma mu v'\n    symbol_values = 'stress_on_plate 0.4 speed'\n  []\n  [304ss_tc]\n    # Data from prebuilt material library\n    # for material\n    type = PiecewiseLinear\n    x = '293.15 323.15 373.15 423.15 473.15 523.15 573.15 623.15 673.15 723.15 773.15 823.15 873.15 923.15 973.15 1023.15 1073.15'\n    y = '14.28 14.73 15.48 16.23 16.98 17.74 18.49 19.24 19.99 20.74 21.49 22.24 22.99 23.74 24.49 25.25 26.0'\n  []\n  [304ss_sh]\n    # Data from prebuilt material library\n    # for material\n    type = PiecewiseLinear\n    x = '293.15 323.15 373.15 423.15 473.15 523.15 573.15 623.15 673.15 723.15 773.15 823.15 873.15 923.15 973.15 1023.15 1073.15'\n    y = '472.0 485.0 501.0 512.0 522.0 530.0 538.0 546.0 556.0 567.0 578.0 590.0 601.0 610.0 615.0 615.0 607.0'\n  []  \n[]\n\n[BCs]\n  [zero-displacment-y]\n    type = ADDirichletBC\n    variable = disp_y\n    boundary = 'break-pad-fixed'\n    value = 0.0\n  []\n  [zero-displacment-z]\n    type = ADDirichletBC\n    variable = disp_z\n    boundary = 'rotation-axis'\n    value = 0.0\n  []\n  [rotation-bc-x]\n    type = DisplacementAboutAxis\n    boundary = 'rotation-axis'\n    function = '${angular_velocity}*t'\n    angle_units = degrees\n    axis_origin = '0. 0. 0.'\n    axis_direction = '0. 0. 1.0'\n    component = 0\n    variable = disp_x\n  []\n  [rotation-bc-y]\n    type = DisplacementAboutAxis\n    boundary = 'rotation-axis'\n    function = '${angular_velocity}*t'\n    angle_units = degrees\n    axis_origin = '0. 0. 0.'\n    axis_direction = '0. 0. 1.0'\n    component = 1\n    variable = disp_y\n  []\n  [driven-displacement-z]\n    type = ADDirichletBC\n    variable = disp_z\n    boundary = 'break-pad-fixed'\n    value = 1e-4\n  []\n[]\n\n[Contact]\n  [contact-disk-pad]\n    model = frictionless\n    penalty = 1e7\n    secondary = 'break-pad-surface'\n    primary = 'break-disk-surface'\n  []\n[]\n\n#[ThermalContact]\n#  [thermal_contact]\n#    type = GapHeatTransfer\n#    variable = temp\n#    primary = 'break-pad-surface'\n#    secondary = 'break-disk-surface'\n#    emissivity_primary = 0\n#    emissivity_secondary = 0\n#    gap_conductivity = 0.1\n#    gap_geometry_type = PLATE\n#  []\n#[]\n  \n[Materials]\n  [304ss-density]\n    type = ADPiecewiseLinearInterpolationMaterial\n    x = '293.15 323.15 373.15 423.15 473.15 523.15 573.15 623.15 673.15 723.15 773.15 823.15 873.15 923.15 973.15 1023.15 1073.15'\n    y = '7930.0 7919.0 7899.0 7879.0 7858.0 7837.0 7815.0 7793.0 7770.0 7747.0 7724.0 7701.0 7677.0 7654.0 7630.0 7606.0 7582.0'\n    property = 'density'\n    variable = temp\n  []\n  [304ss-youngs_modulus]\n    # Data from prebuilt material library\n    # for material\n    type = ADPiecewiseLinearInterpolationMaterial\n    x = '293.15 373.15 423.15 473.15 523.15 573.15 623.15 673.15 723.15 773.15 823.15 873.15 923.15 973.15'\n    y = '200.0 193.0 189.0 185.0 180.0 176.0 172.0 168.0 164.0 159.0 155.0 151.0 147.0 142.0'\n    scale_factor = 1e9\n    variable = temp\n    property = '304ss-youngs_modulus'\n  []\n  [304ss-elasticity]\n    type = ADComputeVariableIsotropicElasticityTensor\n    youngs_modulus = 304ss-youngs_modulus\n    poissons_ratio = 0.33\n  []\n  [304ss-heat]\n    type = ADHeatConductionMaterial\n    temp = temp\n    specific_heat_temperature_function = '304ss_sh'\n    thermal_conductivity_temperature_function = '304ss_tc'\n  []\n  [304ss-thermal_strain]\n    type = ADComputeMeanThermalExpansionFunctionEigenstrain\n    thermal_expansion_function = '304ss_thermal-expansion'\n    thermal_expansion_function_reference_temperature = 293.15\n    stress_free_temperature = 293.15\n    temperature = temp\n    eigenstrain_name = eigenstrain\n  []\n  [304ss-strain] #We use small deformation mechanics\n    type = ADComputeSmallStrain\n    displacements = 'disp_x disp_y disp_z'\n    eigenstrain_names = 'eigenstrain'\n  []\n  [304ss-stress] #We use linear elasticity\n    type = ADComputeLinearElasticStress\n  []\n[]\n\n[Executioner]\n  automatic_scaling = true\n  solve_type = 'NEWTON'\n  type = Transient\n  start_time = 0\n  dt = 0.1\n  end_time = 10\n  line_search = none\n  nl_abs_tol = 1e-6\n  nl_rel_tol = 1e-8\n  l_tol = 1e-6\nl_max_its = 100\n  nl_max_its = 10\n  petsc_options_iname = '-pc_type -pc_hypre_type -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_interp_typ\ne '\n  petsc_options_value = '   hypre      boomeramg                                  0.7                             HMIS                           ext+\ni '\n[]\n  \n[Outputs]\n  exodus = true\n[]\n\nWhat I'm actually trying to do is evaluate a function and have its average value be a postprocessor, so I can see if my function is being popoulated correctly, is there a better way?",
          "url": "https://github.com/idaholab/moose/discussions/25629",
          "updatedAt": "2023-09-29T20:37:06Z",
          "publishedAt": "2023-09-29T18:45:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n  [calc-heat-flux]\n    type = ADFunctorElementalAux\n    functor = breaking-heat-flux\n    variable = heat_flux\n    boundary = 'break-pad-surface'\n  []\n\nI think that s the problem.\nYou're using a first order monomial on a boundary with the functor interface and the current implementation of that functor argument is going to something that is not supported by the variable type on this element type.\nEither that or we dont support linear monomials on tet4 but I dont see why\nI think you could do the same thing with a FunctionAux and it would work?",
                  "url": "https://github.com/idaholab/moose/discussions/25629#discussioncomment-7147755",
                  "updatedAt": "2023-09-29T19:20:49Z",
                  "publishedAt": "2023-09-29T19:20:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "I missed FunctionAux - thats exactly what I wanted!",
                          "url": "https://github.com/idaholab/moose/discussions/25629#discussioncomment-7148066",
                          "updatedAt": "2023-09-29T20:07:50Z",
                          "publishedAt": "2023-09-29T20:07:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We should error for boundary restriction of this object. I've created #25631 to indicate that",
                          "url": "https://github.com/idaholab/moose/discussions/25629#discussioncomment-7148233",
                          "updatedAt": "2023-09-29T20:37:07Z",
                          "publishedAt": "2023-09-29T20:37:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Help understanding differences between \"BreakBoundaryOnSubdomainGenerator\" and \"BreakMeshByBlockGenerator\"",
          "author": {
            "login": "chunhuizhao478"
          },
          "bodyText": "Hi all, as posted in #24189, the distributed mesh option for \"BreakMeshByBlockGenerator\" is not available. I'm seeking for other option (\"BreakBoundaryOnSubdomainGenerator\" + \"SideSetsBetweenSubdomainsGenerator\") to achieve similar things as \"BreakMeshByBlockGenerator\"  but allow distributed mesh option. I have a hard time understanding the differences, for example, I created mesh using both ways:\nmethod 1:\n[Mesh]\n    [./msh]\n        type = GeneratedMeshGenerator\n        dim = 2\n        nx = 201\n        ny = 200\n        xmin = -10050\n        xmax = 10050\n        ymin = -10000\n        ymax = 10000\n    [../]\n    [./new_block]\n        type = ParsedSubdomainMeshGenerator\n        input = msh\n        combinatorial_geometry = 'y<0'\n        block_id = 1\n    []\n    #add \"Block0_Block1\" and \"Block1_Block0\" interfaces\n    [./split]\n        type = BreakMeshByBlockGenerator\n        input = new_block\n        split_interface = true\n        add_interface_on_two_sides = true\n    []\n[]\n\nmethod 2:\n[Mesh]\n    [generated1]\n        type = GeneratedMeshGenerator\n        dim = 2\n        nx = 201\n        ny = 200\n        xmin = -10050\n        xmax = 10050\n        ymin = -10000\n        ymax = 10000\n    []\n    [./new_block]\n        type = ParsedSubdomainMeshGenerator\n        input = generated1\n        combinatorial_geometry = 'y<0'\n        block_id = 1\n    []\n    [break_boundary]\n        type = BreakBoundaryOnSubdomainGenerator\n        input = new_block\n    []\n    [interface]\n        type = SideSetsBetweenSubdomainsGenerator\n        input = break_boundary\n        primary_block = 0\n        paired_block = 1\n        new_boundary = 'Block0_Block1'\n    []\n    [interface2]\n        type = SideSetsBetweenSubdomainsGenerator\n        input = interface\n        primary_block = 1\n        paired_block = 0\n        new_boundary = 'Block1_Block0'\n    []\n[]\n\nAnd would like to apply some boundary conditions along the two interfaces using Explicit Time Stepping.\n[BCs]\n    #assign displacement boundary condition\n    [./matchval_primary_x]\n        type = MatchedValueBC\n        variable = disp_x\n        v = disp_plus_scaled_x\n        boundary = 'Block0_Block1'\n    []\n    [./matchval_secondary_x]\n        type = MatchedValueBC\n        variable = disp_x\n        v = disp_minus_scaled_x\n        boundary = 'Block1_Block0'\n    []\n    [./matchval_primary_y]\n        type = MatchedValueBC\n        variable = disp_y\n        v = disp_plus_scaled_y\n        boundary = 'Block0_Block1'\n    []\n    [./matchval_secondary_y]\n        type = MatchedValueBC\n        variable = disp_y\n        v = disp_minus_scaled_y\n        boundary = 'Block1_Block0'\n    []\n[]\n\nAs I tested, there are differences in the interfaces created by the two methods , but it troubles me to fully understand the discrepancies. So thank advance for anyone who is willing to help!",
          "url": "https://github.com/idaholab/moose/discussions/25624",
          "updatedAt": "2023-09-29T15:59:59Z",
          "publishedAt": "2023-09-28T22:47:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nsidesets are oriented. A side in a sideset is an element and a side index. So it's oriented away from that element.\nIf you want the opposite orientation, you take the neigjbor element and the side index for the first element\nThat's why there's two possible definitions, with two different normals, what \"looks\" the same in the exodus output",
                  "url": "https://github.com/idaholab/moose/discussions/25624#discussioncomment-7139396",
                  "updatedAt": "2023-09-28T23:35:46Z",
                  "publishedAt": "2023-09-28T23:35:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi Guid, thanks for your reply. I think my question is a bit misleading, I understand the orientation of block0_block1 and block1_block0 are different, my question is do I get the same two interfaces by using breakmeshbyblock or breakboundyonsudomain, so the difference between the two generator is what I want to know, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/25624#discussioncomment-7139435",
                          "updatedAt": "2023-09-28T23:46:32Z",
                          "publishedAt": "2023-09-28T23:46:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in BMBBYMG:\nA new sideset identifying the new interface is added, and it is always linked to elements belonging to blocks with the lower ID.\n\nso just make sure the primary block in the BreakMeshByBoundary always is the block with the lowest ID",
                          "url": "https://github.com/idaholab/moose/discussions/25624#discussioncomment-7139460",
                          "updatedAt": "2023-09-28T23:53:45Z",
                          "publishedAt": "2023-09-28T23:53:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "chunhuizhao478"
                  },
                  "bodyText": "I think I find a answer to my question in the earlier post:\n#23955 (reply in thread)\nBreakMeshByBlockGenerator : split the mesh\nBreakBoundaryOnSubdomainGenerator : create a new sideset",
                  "url": "https://github.com/idaholab/moose/discussions/25624#discussioncomment-7146140",
                  "updatedAt": "2023-09-29T15:59:45Z",
                  "publishedAt": "2023-09-29T15:59:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}