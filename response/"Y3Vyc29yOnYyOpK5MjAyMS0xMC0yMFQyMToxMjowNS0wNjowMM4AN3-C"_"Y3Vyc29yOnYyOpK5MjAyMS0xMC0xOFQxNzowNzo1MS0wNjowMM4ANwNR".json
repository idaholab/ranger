{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMC0xOFQxNzowNzo1MS0wNjowMM4ANwNR"
    },
    "edges": [
      {
        "node": {
          "title": "Cumulative function input every unit of time?",
          "author": {
            "login": "LukeFisherUKAEA"
          },
          "bodyText": "I have an initial condition function defined in a .csv file (e.g. a Gaussian) which is read in using the PiecewiseBilinear function.  I would like this function to be added to the system every time increment (e.g. 1 second), as a cumulative input to a variable.  For context, I am looking at modelling ion implantation and transport in a material, using a specific implantation profile.\nHas anyone succeeded in making this work?  As far as I am aware there is no functionality to \"activate\" a new input every unit time from the PiecewiseBilinear (or other .csv input) function, so I have been looking to see if there are other kernels that achieve this.  Any advice would be much appreciated.\nIt may be better to define this profile as a function within MOOSE, rather than reading in and interpolating from a .csv - this would also be possible.",
          "url": "https://github.com/idaholab/moose/discussions/19157",
          "updatedAt": "2022-10-10T19:49:43Z",
          "publishedAt": "2021-10-20T10:21:42Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Can you store the output of the function into an aux variable, then use an AccumulateAux to the accumulation in another variable ? https://mooseframework.inl.gov/source/auxkernels/AccumulateAux.html",
                  "url": "https://github.com/idaholab/moose/discussions/19157#discussioncomment-1508513",
                  "updatedAt": "2022-10-10T19:49:43Z",
                  "publishedAt": "2021-10-20T13:42:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "LukeFisherUKAEA"
                          },
                          "bodyText": "This looks promising, thanks, although it does return an error stating that the variable I am assigning the accumulation to \"does not exist in this system\".  Additionally, do you know if there is a way to control the rate of accumulation, i.e. time between input \"pulses\", if you like?",
                          "url": "https://github.com/idaholab/moose/discussions/19157#discussioncomment-1508786",
                          "updatedAt": "2022-10-10T19:50:06Z",
                          "publishedAt": "2021-10-20T14:21:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you paste your auxvariables block and your auxkernels block here please?\nAuxKernels can't act on anything else than auxiliary variables.\nNot natively. If you want to make a PR to add a function parameter to AccumulateAux for a rate that would be great.\nIf not, you can also use the SelfAux to save an old copy of the variable, then use a ParsedAux to do the accumulation with a rate",
                          "url": "https://github.com/idaholab/moose/discussions/19157#discussioncomment-1508825",
                          "updatedAt": "2022-10-10T19:50:07Z",
                          "publishedAt": "2021-10-20T14:29:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LukeFisherUKAEA"
                          },
                          "bodyText": "That'll be the issue, as i've just discovered with some experimenting - that AuxKernels will only act on AuxVariables and not non-linear variables.  I'll see what I can do with the ParsedAux.",
                          "url": "https://github.com/idaholab/moose/discussions/19157#discussioncomment-1508867",
                          "updatedAt": "2022-10-10T19:50:07Z",
                          "publishedAt": "2021-10-20T14:36:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If you are dealing with a nonlinear variable, you need to add a source term. If you tell us the equation you are solving, we can advise you which kernel to use.",
                  "url": "https://github.com/idaholab/moose/discussions/19157#discussioncomment-1511628",
                  "updatedAt": "2022-10-10T19:50:46Z",
                  "publishedAt": "2021-10-21T01:46:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Is the memory usage dependent on the number of objects within the input file?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nI'm wondering if the memory usage is dependent on the number of objects within the input file?\nI was testing my hydro simulation on a large and complex mesh (5mill elements/1.3mill nodes).\nwhen I run the Steady-state test, I could run it with 20+ cores mpi (with 256gb RAM workstation), but then when I tried to run it with transient mode, with 120+ BCs objects and 120+ Control objects (the input file is shown below), the memory usage blew up and I couldn't run it with more than 10 cores mpi.\nBC block\n     [./drain_DRAINSRF_CUMSRFSET_Y2020_M07]\n     type = PorousFlowPiecewiseLinearSinkTC\n     variable = porepressure\n     boundary = 'DRAINSRF_CUMSRFSET_Y2020_M07'\n     pt_vals = '0 1e9'\n     multipliers = '0 1e9'\n     flux_function = 1e5\n     v = min\n      use_mobility = true\n      fluid_phase = 0\n     [../]\n     [./drain_DRAINSRF_CUMSRFSET_Y2020_M11]\n     type = PorousFlowPiecewiseLinearSinkTC\n     variable = porepressure\n     boundary = 'DRAINSRF_CUMSRFSET_Y2020_M11'\n     pt_vals = '0 1e9'\n     multipliers = '0 1e9'\n     flux_function = 1e5\n     v = min\n      use_mobility = true\n      fluid_phase = 0\n     [../]\nControl block\n    [water_grad_drain_DRAINSRF_CUMSRFSET_Y2020_M07]\n    type = ConditionalFunctionEnableControl\n    enable_objects = 'BCs::drain_DRAINSRF_CUMSRFSET_Y2020_M07'\n    conditional_function = 'if(t=5,1,0)'\n    execute_on = 'initial timestep_begin'\n    []\n    [water_grad_drain_DRAINSRF_CUMSRFSET_Y2020_M11]\n    type = ConditionalFunctionEnableControl\n    enable_objects = 'BCs::drain_DRAINSRF_CUMSRFSET_Y2020_M11'\n    conditional_function = 'if(t=6,1,0)'\n    execute_on = 'initial timestep_begin'\n    []\n\nFrom #18930 I remember @GiudGiud mentioned that:\n\nNot all systems in MOOSE are scalable, and MOOSE generally should not scale well with the input file length because every object is created by every process. Then based on the mesh distribution only some of the objects remain active locally.\n\nSo if that's the case, how should I work around this?\nIs it possible to modify the name/value within the block at each time step?\nfor example\nt =1 \n    boundary = 'DRAINSRF_CUMSRFSET_Y2020_M11'\n    enable_objects = 'BCs::drain_DRAINSRF_CUMSRFSET_Y2020_M07'\n    conditional_function = 'if(t=5,1,0)'\nt = 2 \n    boundary = 'DRAINSRF_CUMSRFSET_Y2020_M11'\n    enable_objects = 'BCs::drain_DRAINSRF_CUMSRFSET_Y2020_M11'\n    conditional_function = 'if(t=6,1,0)'\n\nI guess this could be done via Action, but would this solve the problem?\nThis is because at some point we would need to work with more than 500+ control/bc object, overcoming this issue at early stage would be nice.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/19144",
          "updatedAt": "2022-06-21T16:43:07Z",
          "publishedAt": "2021-10-19T01:21:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "Every processor holds its own set of kernels/bcs, etc. I think on average a kernel or a bc cost about 200kB memory (this number may not be very accurate). If we have 500 objects, the memory used for storing these objects on each processor would be 500*200kB=100MB. This memory is not scalable and an overhead. We met the situation in radiation transport and we ended up re-implement the kernels with array variable/kernel, which significantly reduced the number of kernels. I think MOOSE block restriction can introduce significant memory overhead as well if you have lots of mesh blocks (subdomains). In such cases, you may want to consider minimizing the number of mesh blocks by merging some of them without affecting your calculation if possible. Same applies to mesh boundaries. Unfortunately I cannot provide exact numbers to support my solutions here but that should give you a rough idea. Not sure if the latest live print capability can show you where the memory hot spots are. Another useful parameter is Debug/show_actions that can print the memory usage at the beginning of each action. Hope these help.",
                  "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1499405",
                  "updatedAt": "2022-06-21T16:43:08Z",
                  "publishedAt": "2021-10-19T01:35:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think the show_actions log will be important here. 25 gb per rank seems very excessive.",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1499542",
                          "updatedAt": "2022-06-21T16:43:13Z",
                          "publishedAt": "2021-10-19T02:28:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi guys, I'm sending part that the memory is blowing up below, i think it mainly comes from the 400,000 constraints blocks that I got in the action that i created @GiudGiud\na quick note that, I think this mesh I'm using has 1500 subdomains\n[DBG][ACT] TASK ( execute_mesh_generators) TYPE (           ExecuteMeshGenerators) NAME (                ) Memory usage 167MB\n..............................................\n[DBG][ACT] TASK (       recover_meta_data) TYPE (      SetupRecoverFileBaseAction) NAME (                ) Memory usage 4796MB\n[DBG][ACT] TASK (           set_mesh_base) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 4796MB\n[DBG][ACT] TASK (     attach_geometric_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 4796MB\n[DBG][ACT] TASK (               init_mesh) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 4796MB\n[DBG][ACT] TASK (            prepare_mesh) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 4796MB\n[DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (    porepressure) Memory usage 5269MB\n[DBG][ACT] TASK (          add_constraint) TYPE (                           MPCbe) NAME (           MPCbe) Memory usage 5269MB\n.\n.\n.\nStill Setting Up............\n[DBG][ACT] TASK (     add_preconditioning) TYPE (       SetupPreconditionerAction) NAME (             SMP) Memory usage 19236MB\n[DBG][ACT] TASK (           ready_to_init) TYPE (                     EmptyAction) NAME (                ) Memory usage 19236MB\n[DBG][ACT] TASK (           setup_dampers) TYPE (              SetupDampersAction) NAME (                ) Memory usage 19236MB\n[DBG][ACT] TASK (    setup_residual_debug) TYPE (        SetupResidualDebugAction) NAME (           Debug) Memory usage 19236MB\n[DBG][ACT] TASK (         copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (    porepressure) Memory usage 19236MB\n[DBG][ACT] TASK (          add_aux_kernel) TYPE (            MaterialOutputAction) NAME (                ) Memory usage 19545MB\n[DBG][ACT] TASK (  coupling_functor_check) TYPE (      CouplingFunctorCheckAction) NAME (coupling_functor_check) Memory usage 19545MB\n[DBG][ACT] TASK (            init_problem) TYPE (               InitProblemAction) NAME (                ) Memory usage 19545MB\n\n  Initializing\n    Updating Because Mesh Changed\n      Updating Mesh..\n        Building Node List                                                               [ 10.50 s] [    1 MB]\n        Finished Building Boundary Elements List                                         [  9.16 s] [    0 MB]\n      Still Updating Mesh.                                                               [ 53.11 s] [    1 MB]\n    Finished Updating Because Mesh Changed                                               [ 53.52 s] [  127 MB]\n      Building Node To Elem Map                                                          [  8.43 s] [  304 MB]\n    Still Initializing Equation Systems.....                                             [ 52.58 s] [ 3800 MB]\n[DBG][ACT] TASK (             add_control) TYPE (                AddControlAction) NAME (water_grad_drain_DRAINSRF_CUMSRFSET_Y2012) Memory usage 24030MB\n[DBG][ACT] TASK (             add_control) TYPE (                AddControlAction) NAME (water_grad_drain_DRAINSRF_CUMSRFSET_Y2015) Memory usage 24030MB\n[DBG][ACT] TASK (             add_control) TYPE (                AddControlAction) NAME (water_grad_drain_DRAINSRF_CUMSRFSET_Y2019) Memory usage 24031MB\n[DBG][ACT] TASK (             add_control) TYPE (                AddControlAction) NAME (water_grad_drain_DRAINSRF_CUMSRFSET_Y2020_M07) Memory usage 24031MB\n\nso mesh generator 167 > 4800\nconstraints 5250 > 19000\nInitProblemAction 19000 > 24000\nYeah @GiudGiud looks like it's ~25GB per rank which is mainly from constraints (guess nothing I can do about this unless there is a way to optimise it)",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1499663",
                          "updatedAt": "2022-06-21T16:43:13Z",
                          "publishedAt": "2021-10-19T03:24:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So 5GB roughly for the mesh, and 5GB for the equation system. Then 14GB for the constraints.\nExcept the first two can be split among all processes, while the last one currently is not.\nReworking the constraint to work with a single constraint dealing with large lists of nodes is an option, but it will require modifying the routines handling the contribution to residuals & jacobian.\nI think the easier option here would be to modify your constraints Action to make it only add constraints that are local to each process. So pass a mesh argument to this action and look for the nodes in the local mesh (mesh.get_active_node_ptr_range or something like that) and only add if the constraint is local or partially local to each process.",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1499678",
                          "updatedAt": "2022-06-21T16:43:18Z",
                          "publishedAt": "2021-10-19T03:31:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Except the first two can be split among all processes, while the last one currently is not\n\nwhat do you mean by 'split among all processes', I thought this 5 5 14 gbs are per core already.\n\nI think the easier option here would be to modify your constraints Action to make it only add constraints that are local to each process. So pass a mesh argument to this action and look for the nodes in the local mesh (mesh.get_active_node_ptr_range or something like that) and only add if the constraint is local or partially local to each process.\n\n@GiudGiud I reckon this is the ideal solution, if we do this, let's say we have 10 local meshes, then it will only be 1.4gbs per core? Is there any example of doing this?\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1505330",
                          "updatedAt": "2022-06-21T16:43:51Z",
                          "publishedAt": "2021-10-20T00:11:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not that I know of. @rwcarlsen do you know anyone doing that?\nRoughly. It wont be perfectly split since some constraints will be split between two domains. But it should be pretty close",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1505338",
                          "updatedAt": "2022-06-21T16:43:54Z",
                          "publishedAt": "2021-10-20T00:15:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We've chatted about it and one thing you ll have to be mindful of is not to repartition during the simulation. There may be other difficulties if you end up with a process with 0 constraint, so make sure to have at least one on each process, even if it s inactive (because it uses nodes that are not on the process' mesh)",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1510958",
                          "updatedAt": "2022-06-21T16:43:55Z",
                          "publishedAt": "2021-10-20T21:34:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mesh file for input",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Hello, I have a question about mesh file for input.\nAfter running a moose, I can export the output file as *.e format, and\nmoose supports *.e file as a mesh(https://mooseframework.inl.gov/source/mesh/FileMesh.html).\nWhat I am curious about is \"if *.e file itself includes several results (e.g., t=0, result1, t=0.1, result2, t=0.2, result 3,...)\",\nhow can I use a mesh at a specific time step?\n(for example, I got a *.e file includes 8 results (time steps), but I want to use the mesh at time step 4)\nI appreciate your help.\nSincerely,\nHokon Kim",
          "url": "https://github.com/idaholab/moose/discussions/19097",
          "updatedAt": "2022-07-09T08:28:00Z",
          "publishedAt": "2021-10-13T22:25:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @hokonkim\nIf what you mean is that you want to use a \"deformed\" mesh from a mechanics simulation,\nthen the way to go is the restart option:\nhttps://mooseframework.inl.gov/application_usage/restart_recover.html\nYou can import the displacement variables from a previous simulation at the last time step\nand then you run a new simulation based on that initial displacement/deformation.\nYou can see an example of restart a mechanics simulation in my github, using the SolutionUserObject:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/DeleteElementsRestart/DummyVarRestart.i\nOtherwise if you read the mesh from an .e file, you will always get the mesh from which the previous simulation started,\nif you don't reinitialise the displacement,\nI may be wrong in the case of mesh refinement.\nIf you are not talking about mechanics simulations,\nthen I am not sure what you mean.\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1473767",
                  "updatedAt": "2022-07-07T04:43:56Z",
                  "publishedAt": "2021-10-13T23:15:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "I was taking a look at what you suggested.\nWhat I want to do is \"using deformed mesh after applying postprocessor\"\nSpecifically, at first input file..\n[Materials]\n  [./tpbActivity]\n    type  = ParsedMaterial\n    block = 'PT_TPB_TET4'\n    f_name = 'tpbActivity_S0'\n    postprocessor_names = 'j_YSZ_bottom Poisoned'\n    function = 'if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818), 4818)'\n    args = 'aux_eta_tpb'\n  [../]\n[]    \n\nAfter the first input file, I expected an output file which includes the deformed (postprocessor applied) mesh.\nSo, I made another input file to use this deformed mesh like below.\n[Mesh]\n  [./file]\n    type = FileMeshGenerator\n    file = outputs/tpb_gan0108_2021-10-15-00:26-04.e\n  [../]\n[]\n\n[Materials]\n  [./tpbActivity]\n    type  = ParsedMaterial\n    block = 'PT_TPB_TET4'\n    f_name = 'tpbActivity_S0'\n    function = '4818'\n  [../]\n[]\n\n[UserObjects]\n  [./soln]\n    type = SolutionUserObject\n    mesh = outputs/tpb_gan0108_2021-10-15-00:26-04.e\n    timestep = 'LATEST'\n  [../]\n[]\n\nBut, I'm stuck on how to initialize the \"tpbActivity\" from the previous output file.\nHow can I fix this problem?\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1480960",
                          "updatedAt": "2022-07-07T04:43:59Z",
                          "publishedAt": "2021-10-15T06:20:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What is tpbActivity_S0 ? It's a function that is constant or comes from the previous solution?",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1483441",
                          "updatedAt": "2022-07-07T04:44:02Z",
                          "publishedAt": "2021-10-15T15:12:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "tpbActivity(named as \u201ctpbActivity_S0) is an assigned material property.\nDepending on a certain condition, it would be either activated or deactivated.\nInitializing material property from previous simulation is what I need, I think.",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1483527",
                          "updatedAt": "2022-07-07T04:44:02Z",
                          "publishedAt": "2021-10-15T15:29:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah my bad ParsedMaterial args are not clear. I ll rework that\nYou can use the Controls system to activate / deactivate blocks or control their value.\nhttps://mooseframework.inl.gov/syntax/Controls/index.html\nYou could use a SolutionFunction if the function can be initialized from a field/variable that is defined in the previous simulation\nhttps://mooseframework.inl.gov/source/functions/SolutionFunction.html",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1483860",
                          "updatedAt": "2022-07-09T08:29:03Z",
                          "publishedAt": "2021-10-15T16:43:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Is there a way to store Material properties (ParsedMaterial) and use stored material properties as initial value?\nI tried to store the material properties (MaterialRealAux), but it didn't work...\nI think, if I can store the material property as variable (or aux_variable), then I could use SolutionUserObject...\nAdditionally...(part of input)\nI tried to run an application as below.. but, it didn't work...\nAs far as I know, Output of Material properties is enabled by setting the \"outputs\" parameter.\nCan I extract this value from output(*.e) file and import to another input file?\nWhat will be the best solution for me?\n[Functions]\n  [./aux_eta_tpb_ic]\n    type = SolutionFunction\n    solution = soln_aux_eta_tpb\n  [../]\n[]\n\n[Materials]\n  [./tpbActivity]\n    type  = ParsedMaterial\n    block = 'PT_TPB_TET4'\n    f_name = 'tpbActivity_S0'\n    function = 'if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818), 4818)'\n    args = 'aux_eta_tpb'\n    postprocessor_names = 'j_YSZ_bottom Poisoned'\n    outputs = exodus\n  [../]\n[]\n\n[UserObjects]\n  [./soln_aux_eta_tpb]\n    type = SolutionUserObject\n    mesh = outputs/tpb_gan0108_2021-10-15-18:38-25.e\n    timestep = 'LATEST'\n    system_variables = aux_eta_tpb\n  [../]\n[]\n\n[AuxVariables]\n  [./prev_aux_eta_tpb]\n  [../]\n[]\n\n[AuxKernels]\n  [./soln_eta_tpb]\n    type = SolutionAux\n    solution = soln_aux_eta_tpb\n    variable = prev_aux_eta_tpb\n    direct = true\n    execute_on = 'initial'\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1485972",
                          "updatedAt": "2022-07-09T08:29:03Z",
                          "publishedAt": "2021-10-16T06:00:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can do that., just use a MaterialRealAux to save the material property to an AuxVariable, then it will be saved to the solution file.\nAn other option, a little convoluted, is to save it to exodus (through an aux variable as well, but then you can use outputs='exodus' in the material property) then use that system to reload that into a variable, then into the material property",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1487013",
                          "updatedAt": "2023-09-26T17:36:33Z",
                          "publishedAt": "2021-10-16T14:51:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "When I used MaterialRealAux like below\n[Functions]\n  [./tpbActivity]\n    type  = ParsedMaterial\n    block = 'PT_TPB_TET4'\n    f_name = 'tpbActivity_S0'\n    function = 'if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818), 4818)'\n    args = 'aux_eta_tpb'\n    postprocessor_names = 'j_YSZ_bottom Poisoned'\n    # Make values see at output(*.e) file\n    outputs = exodus\n  [../]\n[]\n\n[AuxVariables]\n  [./cp_tpbActivity_S0]\n  [../]\n[]\n\n[AuxKernels]\n  [./copy_tpbActivity_S0]\n    type = MaterialRealAux\n    property = 'tpbActivity_S0'\n    variable = cp_tpbActivity_S0\n    execute_on = 'initial'\n  [../]\n[]\n\nI got an error like this.\n*** ERROR ***\nThe following error occurred in the object \"copy_tpbActivity_S0\", of type \"MaterialRealAux\".\nNodal AuxKernel 'copy_tpbActivity_S0' attempted to reference material property 'property'\nConsider using an elemental auxiliary variable for 'cp_tpbActivity_S0'.\nAlso, when I tried another way (using exodus file), 'tpbActivity_S0' cannot be specificed..\nI can see the 'tpbActivity_S0' in the output file, but I cannot use that name through SolutionUserObject.\nDid I miss something?",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1487493",
                          "updatedAt": "2023-09-26T17:36:33Z",
                          "publishedAt": "2021-10-16T17:36:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Now, I got a previous \"tpbActivity_S0\" with the input below.\n[UserObjects]\n  [./soln_tpbActivity_S0]\n    type = SolutionUserObject\n    mesh = outputs/tpb_gan0108_2021-10-15-18:38-25.e\n    timestep = 'LATEST'\n    system_variables = tpbActivity_S0\n  [../]\n[]\n\n[AuxVariables]\n  [./prev_tpbActivity_S0]\n    # Specifies the family of FE shape functions to use for this variable.\n    # If the variable family is MONOMIAL then the AuxKernel will behave as an elemental.\n    # Especially, Material property is \"elemental\", not \"nodal\".\n    family = MONOMIAL\n    order = CONSTANT\n    block = 'PT_TPB_TET4'\n  [../]\n[]\n\n[AuxKernels]\n  [./soln_tpbActivity]\n    type = SolutionAux\n    solution = soln_tpbActivity_S0\n    variable = prev_tpbActivity_S0\n    direct = true\n    execute_on = 'initial'\n  [../]\n[]\n\nI am still struggling to initialize material property with \"prev_tpbActivity_S0\".\nI want to use the \"prev_tpbActivity_S0\" as initial material property condition, and\napply the function( 'if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818), 4818)' ) depending on time step.\nI have no idea how to apply both (material initialization & apply function)....\nbecause\n*** ERROR ***\nInvalid function\nif(time_check = 0, prev_tpbActivity_S0, if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818)))\naux_eta_tpb,prev_tpbActivity_S0,time_check,j_YSZ_bottom,Poisoned\nin ParsedMaterialHelper.\nIllegal number of parameters to function\nAre there any tips for me?\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1487911",
                          "updatedAt": "2023-09-26T17:36:36Z",
                          "publishedAt": "2021-10-16T20:59:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So for your first message, last part:\nthe solutionUO and the exodus are completely separate ways of restarting. When needed (and it should be avoidable most of the time) you can restart some fields using one and others using the other, but they act very separately. See more info here:\nhttps://mooseframework.inl.gov/application_usage/restart_recover.html\nFor the second message,\ncan you paste your ParsedMaterial block here? To check the other arguments.\nIt seems one of your if statements is missing an argument, they should all have 3 arguments\nif(time_check = 0, prev_tpbActivity_S0, if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818), MISSING option))",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1491463",
                          "updatedAt": "2022-12-08T21:00:07Z",
                          "publishedAt": "2021-10-18T05:25:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Here are some parts of input file.\n\n\nUse original mesh + \"previous result from output(exodus) file\"\n[Mesh]\n  [./file]\n    type = FileMeshGenerator\n    file = outputs/original.inp\n  [../]\n[]\n\n[Materials]\n  [./tpbActivity]\n    type  = ParsedMaterial\n    block = 'PT_TPB_TET4'\n    f_name = 'tpbActivity_S0'\n    # function = 'if(prev_tpbActivity_S0 > 0, if(-j_YSZ_bottom > 1, if(aux_eta_tpb > 0.163 * 0.92, 0, 4818) 4818), 0)'\n    function = 'if(prev_tpbActivity_S0 > 0, if(aux_eta_tpb > Poisoned, 0, 4818), 0)'\n    args = 'aux_eta_tpb prev_tpbActivity_S0'\n    postprocessor_names = 'Poisoned'\n    # Make values see at output(*.e) file\n    outputs = exodus\n  [../]\n[]\n\n[UserObjects]\n  [./soln_tpbActivity_S0]\n    type = SolutionUserObject\n    mesh = outputs/tpb_gan0108_2021-10-15-18:38-25.e\n    timestep = 'LATEST'\n    system_variables = tpbActivity_S0\n  [../]\n[]\n\n\n[AuxVariables]\n  [./aux_eta_tpb]\n    block = 'PT_TPB_TET4'\n  [../]\n\n  [./prev_tpbActivity_S0]\n    # Specifies the family of FE shape functions to use for this variable.\n    # If the variable family is MONOMIAL then the AuxKernel will behave as an elemental.\n    # Especially, Material property is \"elemental\", not \"nodal\".\n    family = MONOMIAL\n    order = CONSTANT\n    block = 'PT_TPB_TET4'\n  [../]\n[]\n\n[AuxKernels]\n  [./eta_tpb]\n    type = ParsedAux\n    variable = aux_eta_tpb\n    block = 'PT_TPB_TET4'\n    function = '-R * T / 4 / F * log(7e-21 / p_O2) - (phi_LSM - phi_YSZ + 0.03607)'\n    constant_names = 'R T F'\n    constant_expressions = '8.3144598 1073 96485.33289' # (J/K/mol), (K), (C/mol)\n    args = 'p_O2 phi_LSM phi_YSZ'\n  [../]\n\n  [./soln_tpbActivity]\n    type = SolutionAux\n    solution = soln_tpbActivity_S0\n    variable = prev_tpbActivity_S0\n    direct = true\n    execute_on = 'initial'\n  [../]\n[]\n\n[Postprocessors]\n  [./eta_total]\n    type = FunctionValuePostprocessor\n    function = 'funcOverpotential'\n    outputs = 'console csv'\n  [../]\n\n  [./Poisoned]\n    type = ParsedPostprocessor\n    function = 'eta_total * 0 + poison * 0.92' # If you want to control the standard for poisoning, then change the number (0 ~ 1.0)\n    pp_names = 'eta_total'\n    constant_names = 'poison'\n    constant_expressions = '0.163'\n    outputs = 'console csv'\n  [../]\n[]\n\n\n\nThis was the best that I can do now.\nStill, I wonder if the function in ParsedMaterial can use the function (commented out).\nI tried.. but it didn't work (MOOSE didn't allow several if statements and several parameters..)\nAre there ways to use several parameters or if-statement?\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1503979",
                          "updatedAt": "2023-02-01T13:52:43Z",
                          "publishedAt": "2021-10-19T17:42:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Handling AuxVariable and Problem compatible with multiprocessing/threading",
          "author": {
            "login": "bielsnohr"
          },
          "bodyText": "I am in the process of creating a MultiApp to call an external program, and the SubApp (contains a class inheriting from ExternalProblem) is meant to both run the external program and then read from the HDF5 file that the program generates. I am currently working on the reading from the HDF5. Some values from this HDF5 are read in, used in some calculations, and then the result is to be stored in an AuxVariable that is passed up to the MainApp. I have a few questions in relation to syncing the results to this AuxVariable.\nI want to check that the AuxVariable is present and of the correct family and order, which I do with the following at the top of the syncSolutions() class method:\n  // _problem_system is initialised to getAuxiliarySystem() in the class constructor\n  if (!_problem_system.hasVariable(_sync_to_var_name))\n  {\n    throw MooseException(\"AuxVariable \" + _sync_to_var_name +\n                         \" from input file is not present in the AuxiliarySystem. Make sure you \"\n                         \"have declared the AuxVariables block.\");\n  }\n  MooseVariableFieldBase & fi_heat_fluxes =\n      _problem_system.getVariable(_restartable_tid, _sync_to_var_name);\n\n  if (fi_heat_fluxes.isNodal() || fi_heat_fluxes.feType().order != 1)\n  {\n    throw MooseException(\"MooseVariable passed to AscotProblem is nodal or of order >1. It must be \"\n                         \"elemental and order 1.\");\n  }\nThere are two things that bother me about this. First, the use of MooseVariableFieldBase which my IDE says is the only valid option. Is that really the correct type for an AuxVariable? Second, the need to pass a thread ID to the getVariable() method. I am currently passing _restartable_tid, but I am not sure if this is really what I want? This makes me suspect that I am only getting a portion of the AuxVariable, and so I will need to take that into consideration when getting the values calculated from the HDF5 file (indexed by mesh element).\nThe latter question exposed a confusion in my understanding of how MOOSE handles multiprocessing and multithreading. I understand the that underlying libMesh System and Mesh are handled in a distributed manner, but I don't know whether the the MOOSE class objects are handled in the same way. In other words, is there a ExternalProblem-based object that lives in each process/thread, such that when a call is made to ExternalProblemObject.syncSolutions() this is executed on each process/thread?",
          "url": "https://github.com/idaholab/moose/discussions/19146",
          "updatedAt": "2022-06-26T03:57:19Z",
          "publishedAt": "2021-10-19T12:01:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFor your first question:\nMooseVariableFieldBase is pretty high up in the inheritance chain. If you know it'll be a FE variable you can likely use MooseVariableFEBase. But you can also just write auto and let the compiler figure it out\nFor your second question:\nThere is an ExternalProblem on each process. Thread-wise I dont know. I suspect not. Someone needs to write a comprehensive threading documentation in MOOSE. Do you really need to use threads though? Distributed memory is usually better in MOOSE.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19146#discussioncomment-1505135",
                  "updatedAt": "2022-06-26T03:57:20Z",
                  "publishedAt": "2021-10-19T22:48:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bielsnohr"
                          },
                          "bodyText": "But you can also just write auto and let the compiler figure it out\n\nYes, I realised this whilst looking at some other code in the MOOSE library after I posted. auto is my friend I always forget \ud83d\ude1b\n\nThere is an ExternalProblem on each process.\n\nFrom looking as some other programs, this is what I was beginning to suspect. Thank you.\n\nDo you really need to use threads though? Distributed memory is usually better in MOOSE.\n\nNope, don't need threads particularly, just wondering what I should pass to get the variable. @friedmud 's answer clears that up.",
                          "url": "https://github.com/idaholab/moose/discussions/19146#discussioncomment-1507071",
                          "updatedAt": "2022-06-26T03:57:21Z",
                          "publishedAt": "2021-10-20T09:11:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "Just pass 0 for the thread ID in this case.\nThe ExternalProblem class is not \"threaded\" (meaning that only one instance of it exists - no matter how many threads you are using).  Therefore it's \"on thread 0\".",
                  "url": "https://github.com/idaholab/moose/discussions/19146#discussioncomment-1505909",
                  "updatedAt": "2022-06-26T03:57:27Z",
                  "publishedAt": "2021-10-20T03:54:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bielsnohr"
                          },
                          "bodyText": "Thank you, that clears my thread ID question up.",
                          "url": "https://github.com/idaholab/moose/discussions/19146#discussioncomment-1507037",
                          "updatedAt": "2022-06-26T03:57:27Z",
                          "publishedAt": "2021-10-20T09:04:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Non local stress update",
          "author": {
            "login": "albiedahal"
          },
          "bodyText": "Hi all,\nI am trying to implement a nonlocal return mapping algorithm for inelastic stress update as per this paper. The figure attached outlines the stress update algorithm for the nonlocal approach.\n\nThe values of the plastic multiplier for all of the quadrature points are coupled and calculated simultaneously (Ref Equations 33, 34, and 41). As far as I know, traditional (local) stress update materials in MOOSE compute plastic strain at a quadrature point independent of the stress state of the other quadrature points, which does not work for this approach. Except for the return map, the solution method is no different from the standard finite element method, so I need to update the stresses at the quadrature points globally and store those values for the kernels to consume.  Any pointers or suggestions on how and where to start would be highly appreciated.\nKind regards,\nAlbert",
          "url": "https://github.com/idaholab/moose/discussions/19003",
          "updatedAt": "2022-06-10T14:45:35Z",
          "publishedAt": "2021-10-04T22:34:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "which paper?",
                  "url": "https://github.com/idaholab/moose/discussions/19003#discussioncomment-1427219",
                  "updatedAt": "2022-06-10T14:45:59Z",
                  "publishedAt": "2021-10-04T22:51:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "albiedahal"
                          },
                          "bodyText": "Sorry for that. I have linked the paper now.",
                          "url": "https://github.com/idaholab/moose/discussions/19003#discussioncomment-1427223",
                          "updatedAt": "2022-06-10T14:45:59Z",
                          "publishedAt": "2021-10-04T22:54:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "So in MOOSE we loop over elements to compute material properties, e.g. stress and strain.\nThe method called at each element is computeProperties. Within this method, we loop over quadrature points, and at each quadrature point, we call computeQpProperties. So you do have access to this sort of non-local information within the computeProperties method. We do this routinely for stuff like volumetric locking correction. You can take a look at ComputeSmallStrain::computeProperties() for example.\nThe stress update classes derive from StressUpdateBase, which has the method setQp that allows you to set the current quadrature point. This could also be useful when implementing this non-local method.",
                          "url": "https://github.com/idaholab/moose/discussions/19003#discussioncomment-1427568",
                          "updatedAt": "2022-06-10T14:46:01Z",
                          "publishedAt": "2021-10-05T01:10:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@albiedahal    Thanks for the paper. Unfortunately, we do not have the access to that paper :-(\nDoes all integration points in this algorithm refer to the quadrature points within a single element or all elements? If it is for a single element, @hugary1995 's suggestion is what you should follow. If it evolves multiple elements, we need to read the paper and give you other suggestions.",
                          "url": "https://github.com/idaholab/moose/discussions/19003#discussioncomment-1427972",
                          "updatedAt": "2022-06-10T14:46:01Z",
                          "publishedAt": "2021-10-05T04:12:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "albiedahal"
                          },
                          "bodyText": "@hugary1995 Thank you for the reply. I need to loop over the quadrature points of all the elements in the domain, not just at a particular element. I don't think computeProperties allows me to do that?\n@jiangwen84 I have updated the link to a google drive link which should be accessible now. The all integration points in the algorithm refers to all the quadrature points in the domain over all elements.",
                          "url": "https://github.com/idaholab/moose/discussions/19003#discussioncomment-1431177",
                          "updatedAt": "2022-07-26T01:27:12Z",
                          "publishedAt": "2021-10-05T16:19:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@albiedahal app developers usually write an implementation for computeQpProperties. But if you want to compute the matprop at all qps together, you can re-implement computeProperties. It s in Material.C it s not very complicated\nEDIT this is a little hacky, hence the dislike",
                          "url": "https://github.com/idaholab/moose/discussions/19003#discussioncomment-1498933",
                          "updatedAt": "2022-07-26T01:27:12Z",
                          "publishedAt": "2021-10-18T22:17:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "albiedahal"
                          },
                          "bodyText": "@GiudGiud Thank you, I'll definitely look into that. I am having a hard time figuring the qp indexes and the prop ids in the computeProperties as I do not have much programming background/experience.",
                          "url": "https://github.com/idaholab/moose/discussions/19003#discussioncomment-1505341",
                          "updatedAt": "2022-07-26T01:27:12Z",
                          "publishedAt": "2021-10-20T00:17:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Can you explain what the \"nonlocal internal variables\" are?",
                  "url": "https://github.com/idaholab/moose/discussions/19003#discussioncomment-1499477",
                  "updatedAt": "2022-06-10T14:46:02Z",
                  "publishedAt": "2021-10-19T02:02:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "albiedahal"
                          },
                          "bodyText": "@dschwen the non local variables in this algorithm is the non local plastic strain increment (or the plastic multiplier)  $\\tilde{\\kappa}$. The non local plastic strain increment for ith quadrature point in the domain includes weighted contributions of the local plastic strains $\\kappa$ of all quadrature points in the domain (Eq. 33). The a_ij in is the non-local weight and w_j is the quadrature rule weight. The yield function (Eq. 34) in this case is not satisfied explicitly at each quadrature points locally, but more in a distributed sense by specifying a tolerance $\\delta_f$.",
                          "url": "https://github.com/idaholab/moose/discussions/19003#discussioncomment-1505340",
                          "updatedAt": "2022-06-29T06:22:32Z",
                          "publishedAt": "2021-10-20T00:17:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Setting options from command line",
          "author": {
            "login": "doquang"
          },
          "bodyText": "I would like to turn off the color output when running an app. The command given by -h saying: \"--no-color Disable coloring of all Console outputs.\" does not work. For example,\n./moose_test-opt --no-color -i tests/kernels/simple_diffusion/simple_diffusion.i has no effect.\nI only success by setting it via the input file\n[Outputs]\n  color = false\n[]",
          "url": "https://github.com/idaholab/moose/discussions/19149",
          "updatedAt": "2022-05-31T14:50:15Z",
          "publishedAt": "2021-10-19T14:17:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhen you used no color you must have received the following warning:\n\n*** Warning, This code is deprecated and will be removed in future versions:\nThe --no-color flag is deprecated. Use '--color off' instead.\n\n--color off worked for me\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19149#discussioncomment-1502805",
                  "updatedAt": "2022-05-31T14:50:20Z",
                  "publishedAt": "2021-10-19T14:21:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "doquang"
                  },
                  "bodyText": "Oh, sorry, It showed up on the very first lines that I missed.",
                  "url": "https://github.com/idaholab/moose/discussions/19149#discussioncomment-1502833",
                  "updatedAt": "2022-05-31T14:50:23Z",
                  "publishedAt": "2021-10-19T14:25:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "AD equivalent to ParsedMaterial?",
          "author": {
            "login": "LukeFisherUKAEA"
          },
          "bodyText": "Hello,\nIs there an existing Automatic Differentiation equivalent to ParsedMaterial within the framework?  I am moving to an ADKernel-based simulation but need to solve the issue of ADKernels requiring ADMaterialProperties.  Alternatively, this may require modification of existing Material blocks to declare ADMaterialProperty values?\nThanks for the help.",
          "url": "https://github.com/idaholab/moose/discussions/19132",
          "updatedAt": "2024-03-30T17:43:08Z",
          "publishedAt": "2021-10-18T12:51:30Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ABallisat"
                  },
                  "bodyText": "ADParsedMaterial does exist but it is not explicitly in the docs, it is defined in here:\nhttps://github.com/idaholab/moose/blob/master/framework/src/materials/ParsedMaterial.C\nI have found this in a few places throughout MOOSE, in general if it does not appear in the docs I check the source code as it may already be there.",
                  "url": "https://github.com/idaholab/moose/discussions/19132#discussioncomment-1496185",
                  "updatedAt": "2024-03-30T17:44:39Z",
                  "publishedAt": "2021-10-18T14:20:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@lindsayad do you think we should add some standardized text to class that is doubled up between AD and non AD?\nOr prefer doubling up the documentation?\nIs there an issue where people discussed this? i looked at the AD PR and the AD issue #5658, could not find it",
                          "url": "https://github.com/idaholab/moose/discussions/19132#discussioncomment-1497390",
                          "updatedAt": "2024-09-09T21:37:55Z",
                          "publishedAt": "2021-10-18T16:39:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The bool is_ad idiom developed separately from all the primary AD work. It's been an idiom that's really taken off because of developers who want to maintain both regular and AD versions of classes with minimal effort, which I applaud them for. But I'm not surprised that there is no mention of this in the original AD issue or PR because I never envisioned it really.\nI think it would be good to somehow indicate in the documentation all the concrete types that arise from a class template. That could definitely help our users",
                          "url": "https://github.com/idaholab/moose/discussions/19132#discussioncomment-1497506",
                          "updatedAt": "2024-03-30T17:44:39Z",
                          "publishedAt": "2021-10-18T16:56:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@LukeFisherUKAEA ADParsedMaterial should be the answer here as @ABallisat suggested. Please let us know if there are any issues with that.",
                          "url": "https://github.com/idaholab/moose/discussions/19132#discussioncomment-1497551",
                          "updatedAt": "2024-03-30T17:44:41Z",
                          "publishedAt": "2021-10-18T17:03:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "In case it's of interest, ADParsedMaterial was added in #15331 in reference to #15207",
                          "url": "https://github.com/idaholab/moose/discussions/19132#discussioncomment-1497578",
                          "updatedAt": "2024-03-30T17:44:41Z",
                          "publishedAt": "2021-10-18T17:06:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok raising an issue to keep track of this\n#19137",
                          "url": "https://github.com/idaholab/moose/discussions/19132#discussioncomment-1497640",
                          "updatedAt": "2024-03-30T17:44:50Z",
                          "publishedAt": "2021-10-18T17:14:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LukeFisherUKAEA"
                          },
                          "bodyText": "Thanks all - this is what I was looking for.",
                          "url": "https://github.com/idaholab/moose/discussions/19132#discussioncomment-1500475",
                          "updatedAt": "2024-03-30T17:44:50Z",
                          "publishedAt": "2021-10-19T07:27:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Linking external libraries across different modules",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nI linked an external library (mfront) to the tensor mechanics module. All worked fine and my tests did run with success. Now, I would like to combine this module with others (e. g. porous flow and navier stokes). Would it be enough to activate the module or should I add all relevant flags somewhere specific. I am saying this since a first attempt to make porous flow threw a linking error while making the tensor mechanics module (all external calls are no longer valid). Need to say that I added all flags to the make file of tensor mechanics.\nThanks for any feedback,\nMauro",
          "url": "https://github.com/idaholab/moose/discussions/18834",
          "updatedAt": "2022-09-18T17:16:31Z",
          "publishedAt": "2021-09-15T22:40:40Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Should be enough to activate the module in your makefile for your applications.\nIf you are running with the modules directly, you may want to use the combined module",
                  "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1363432",
                  "updatedAt": "2022-09-18T17:16:36Z",
                  "publishedAt": "2021-09-21T17:08:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "linking errors are common if you havent cleaned your repository of pre-compiled objects before re-compiling with different sets of modules",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1363434",
                          "updatedAt": "2022-09-18T18:10:39Z",
                          "publishedAt": "2021-09-21T17:09:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Sorry to reopen this post (BTW, thanks @GiudGiud for the reply), but even after retrying - force cleaning and remake the combined module, I am still facing the same problem.\nIf I compile the tensor mechanics module directly all works fine, however if I try to compile it via the combined module I keep receiving errors for undefined references to specific calls of the external library I want to link. Not sure, what is wrong.\nAs always, any help would be appreciated.\nThanks,\nMauro\nFor the sake of completeness, these are the additional flags I required (added to the makefile):\nADDITIONAL_CPPFLAGS += -I/home/cacace/snippets/MFrontGenericInterfaceSupport/include/\nADDITIONAL_LIBS += -L/home/cacace/snippets/MFrontGenericInterfaceSupport/build/src/ -lMFrontGenericInterface",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1459788",
                          "updatedAt": "2022-09-18T18:10:39Z",
                          "publishedAt": "2021-10-11T15:32:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you please paste the error message?\nDid you make clobberall before compiling the combined module?",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1459848",
                          "updatedAt": "2022-09-18T18:10:40Z",
                          "publishedAt": "2021-10-11T15:43:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "I did force make clobberall before recompiling, but it did not work.\nAttached the screenshot of the error.",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1459863",
                          "updatedAt": "2022-09-18T18:10:40Z",
                          "publishedAt": "2021-10-11T15:46:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "All function related to the mgis library are undefined...",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1459869",
                          "updatedAt": "2022-09-18T17:16:36Z",
                          "publishedAt": "2021-10-11T15:47:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you save all your work (git commit) then run git clean -xfd in the repo",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1459954",
                          "updatedAt": "2022-09-18T17:16:36Z",
                          "publishedAt": "2021-10-11T16:05:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@GiudGiud Thanks! I will try and let you know.",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1460047",
                          "updatedAt": "2022-09-18T17:16:36Z",
                          "publishedAt": "2021-10-11T16:20:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this flag is a little weird btw\nADDITIONAL_LIBS += -L/home/cacace/snippets/MFrontGenericInterfaceSupport/build/src/\nI d expect a lib/ folder not a src/folder",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1460143",
                          "updatedAt": "2022-09-18T17:16:36Z",
                          "publishedAt": "2021-10-11T16:37:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "anilkunwar"
                          },
                          "bodyText": "@mcacace  I am curious to know whether you can access the individual modules from external user app. When did you create your external app if you have created one . I have encountered some issues with the newly created (created few months ago) external app. I do not see the necessity to compile the individual modules as long as the user app can access them externally through compilation.  Previously it was recommended to  use the modules through an external app outside the framework, and so I had never compiled the individual modules themselves. Recently,  when  an older external app (created before 2020) compiled on top of recently installed MOOSE  could not  access all of the modules  of MOOSE, I first tried to compile the individual modules by jumping into the modules directory inside the moose directory and I have never been successful with the combined module. so I choose to compile ( individualmodulename := yes in the Makefile) of the external app and it has been successful in accessing phase field, navier stokes, heat conduction, tensor mechanics and xfem modules.\nThis explanation is associated with moose installation in Ubuntu 20.04 in conda environment.  ALL_MODULES := yes is still working fine in the same older app compiled on top of MOOSE framework  installed in the previous Moose environment based installation in Ubuntu 18.04 OS.",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1461370",
                          "updatedAt": "2022-09-18T17:19:50Z",
                          "publishedAt": "2021-10-11T21:52:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "anilkunwar"
                  },
                  "bodyText": "when I use ALL_MODULES :=yes, I also get the linking error for the POROUS_FLOW. For now I am using ALL_MODULES :=no and specifying the other linkable modules only\nPHASE_FIELD :=yes\nNAVIER_STOKES :=yes\n...\nPOROUS_FLOW :=no\n...\n\n\nIn my case, even after the test runs successful with the executable of app, i cannot run the input file that uses objects from these compiled modules.",
                  "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1363651",
                  "updatedAt": "2022-09-18T17:20:01Z",
                  "publishedAt": "2021-09-21T17:53:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "@mcacace It seems to me a better approach would be to create your own app, and link the new library there. Your change to tensormechanics is unlikely to ever get merged into moose, and you'll be stuck rebasing your branch for all eternity. In https://github.com/idaholab/magpie we link a few external libraries successfully.",
                  "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1461457",
                  "updatedAt": "2022-09-18T17:20:01Z",
                  "publishedAt": "2021-10-11T22:25:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@dschwen I also think that creating a simple app could solve the issue - indeed I already have the mfront library linked to another app we developed. I will discuss with my colleague, who is interested to make use of tensormechanics and porous flow, to see whether he is fine with it. BTW, the mfront library is an interesting one, and it does more or less the same as per the umat interface in the module - maybe it would be worth considering as an alternative.",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1462737",
                          "updatedAt": "2022-09-18T17:20:03Z",
                          "publishedAt": "2021-10-12T07:14:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "It does look interesting, however it is licensed under the GPL, which is incompatible with MOOSE's LGPL license. :-(",
                          "url": "https://github.com/idaholab/moose/discussions/18834#discussioncomment-1499490",
                          "updatedAt": "2022-09-18T17:20:03Z",
                          "publishedAt": "2021-10-19T02:11:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Segfault with MultiApps and --recover",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "I've made a test that runs without --recover.   But when i use ./run_tests --recover i get a segfault\nmatrix_app.i is the main App which uses TransientMultiApp\nfracture_app is the subApp\n\n\nOne thing i notice is that there are no checkpoint files associated with fracture_app: there is only matrix_app_out_cp.  Is this expected?   But even if i make those checkpoint files manually, i still get a segfault.\n\n\nHere is a snipped version of the output:\n\n\n/Users/wil04q/projects/moose/modules/porous_flow/> ./run_tests --dbg --re=3dFra --recover --heavy\nexamples/multiapp_fracture_flow/3dFracture.matrix_part1 .............................................. RUNNING\nexamples/multiapp_fracture_flow/3dFracture.matrix_part1 ..................................... [FINISHED] PART1\nexamples/multiapp_fracture_flow/3dFracture.matrix: Working Directory: /Users/wil04q/projects/moose/modules/porous_flow/examples/multiapp_fracture_flow/3dFracture\nexamples/multiapp_fracture_flow/3dFracture.matrix: Running command: /Users/wil04q/projects/moose/modules/porous_flow/porous_flow-dbg -i matrix_app.i Executioner/end_time=1 --recover --recoversuffix cpr --error --error-unused --error-override --no-gdb-backtrace\nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: *** Info ***\nexamples/multiapp_fracture_flow/3dFracture.matrix: Using matrix_app_out_cp/0001 for recovery.\nexamples/multiapp_fracture_flow/3dFracture.matrix: Creating MultiApp fracture_app of type PorousFlowTestApp of level 1 and number 0:\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: Running App: main\nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: Framework Information:\nexamples/multiapp_fracture_flow/3dFracture.matrix: MOOSE Version:           git commit 86b7dc01ee on 2021-07-08\n\nexamples/multiapp_fracture_flow/3dFracture.matrix: Execution Information:\nexamples/multiapp_fracture_flow/3dFracture.matrix:   Executioner:             Transient\nexamples/multiapp_fracture_flow/3dFracture.matrix:   TimeStepper:             IterationAdaptiveDT\nexamples/multiapp_fracture_flow/3dFracture.matrix:   Solver Mode:             NEWTON\nexamples/multiapp_fracture_flow/3dFracture.matrix:   PETSc Preconditioner:    lu \nexamples/multiapp_fracture_flow/3dFracture.matrix:   MOOSE Preconditioner:    SMP\nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: Initializing All MultiApps\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: Running App: fracture_app0\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: Parallelism:\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Num Processors:          1\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Num Threads:             1\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: Mesh: \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Parallel Type:           replicated\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Mesh Dimension:          2\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Spatial Dimension:       3\n\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: Execution Information:\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Executioner:             Transient\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   TimeStepper:             IterationAdaptiveDT\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Solver Mode:             NEWTON\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   PETSc Preconditioner:    asm \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   MOOSE Preconditioner:    SMP\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: *** Info ***\nexamples/multiapp_fracture_flow/3dFracture.matrix: Using matrix_app_out_cp/0001 for recovery.\nexamples/multiapp_fracture_flow/3dFracture.matrix: Creating MultiApp fracture_app of type PorousFlowTestApp of level 1 and number 0:\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: Running App: main\nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: Framework Information:\nexamples/multiapp_fracture_flow/3dFracture.matrix: MOOSE Version:           git commit 86b7dc01ee on 2021-07-08\n\nexamples/multiapp_fracture_flow/3dFracture.matrix: Execution Information:\nexamples/multiapp_fracture_flow/3dFracture.matrix:   Executioner:             Transient\nexamples/multiapp_fracture_flow/3dFracture.matrix:   TimeStepper:             IterationAdaptiveDT\nexamples/multiapp_fracture_flow/3dFracture.matrix:   Solver Mode:             NEWTON\nexamples/multiapp_fracture_flow/3dFracture.matrix:   PETSc Preconditioner:    lu \nexamples/multiapp_fracture_flow/3dFracture.matrix:   MOOSE Preconditioner:    SMP\nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: Initializing All MultiApps\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: Running App: fracture_app0\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: Parallelism:\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Num Processors:          1\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Num Threads:             1\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: Mesh: \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Parallel Type:           replicated\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Mesh Dimension:          2\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Spatial Dimension:       3\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Nodes:                   \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:     Total:                 681\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:     Local:                 681\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Elems:                   \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:     Total:                 1221\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:     Local:                 1221\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Num Subdomains:          10\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Num Partitions:          1\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: Nonlinear System:\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Num DOFs:                1362\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Num Local DOFs:          1362\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Variables:               { \"frac_P\" \"frac_T\" } \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Finite Element Types:    \"LAGRANGE\" \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Approximation Orders:    \"FIRST\" \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: Auxiliary System:\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Num DOFs:                17916\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Num Local DOFs:          17916\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Variables:               { \"darcy_vel_x\" \"darcy_vel_y\" \"darcy_vel_z\" \"heat_transfer_coefficient\" } { \"transferred_matrix_T\" \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:                              \"joules_per_s\" } { \"normal_dirn_x\" \"normal_dirn_y\" \"normal_dirn_z\" \"enclosing_element_normal_length\" \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:                              \"enclosing_element_normal_thermal_cond\" \"aperture\" \"perm_times_app\" \"density\" \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:                              \"viscosity\" } \"insitu_pp\" \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Finite Element Types:    \"MONOMIAL\" \"LAGRANGE\" \"MONOMIAL\" \"LAGRANGE\" \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Approximation Orders:    \"CONSTANT\" \"FIRST\" \"CONSTANT\" \"FIRST\" \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: Execution Information:\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Executioner:             Transient\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   TimeStepper:             IterationAdaptiveDT\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   Solver Mode:             NEWTON\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   PETSc Preconditioner:    asm \nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0:   MOOSE Preconditioner:    SMP\nexamples/multiapp_fracture_flow/3dFracture.matrix: fracture_app0: \nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix: Exit Code: -11\nexamples/multiapp_fracture_flow/3dFracture.matrix: ################################################################################\nexamples/multiapp_fracture_flow/3dFracture.matrix: Tester failed, reason: CRASH\nexamples/multiapp_fracture_flow/3dFracture.matrix: \nexamples/multiapp_fracture_flow/3dFracture.matrix ................................... [recover] FAILED (CRASH)\n\n\nRunning through lldb gives:\n\n(lldb) bt\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)\n  * frame #0: 0x0000000101276427 libmoose-opt.0.dylib`void dataLoad<unsigned int, MaterialProperties>(std::__1::basic_istream<char, std::__1::char_traits<char> >&, HashMap<unsigned int, MaterialProperties>&, void*) + 295\n    frame #1: 0x00000001012762c9 libmoose-opt.0.dylib`void dataLoad<libMesh::Elem const*, HashMap<unsigned int, MaterialProperties> >(std::__1::basic_istream<char, std::__1::char_traits<char> >&, HashMap<libMesh::Elem const*, HashMap<unsigned int, MaterialProperties> >&, void*) + 169\n    frame #2: 0x00000001012760d4 libmoose-opt.0.dylib`RestartableData<MaterialPropertyStorage>::load(std::__1::basic_istream<char, std::__1::char_traits<char> >&) + 36\n    frame #3: 0x00000001013a9080 libmoose-opt.0.dylib`RestartableDataIO::deserializeRestartableData(std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, RestartableDataValuePair, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, RestartableDataValuePair> > > const&, std::__1::basic_istream<char, std::__1::char_traits<char> >&, std::__1::unordered_set<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) + 400\n    frame #4: 0x00000001013aad80 libmoose-opt.0.dylib`RestartableDataIO::restoreBackup(std::__1::shared_ptr<Backup>, bool) + 640\n    frame #5: 0x0000000101962a0c libmoose-opt.0.dylib`MooseApp::restore(std::__1::shared_ptr<Backup>, bool) + 124\n    frame #6: 0x000000010196f237 libmoose-opt.0.dylib`MooseApp::restoreCachedBackup() + 103\n    frame #7: 0x0000000101219635 libmoose-opt.0.dylib`FEProblemBase::initialSetup() + 5189\n    frame #8: 0x0000000100f9ff64 libmoose-opt.0.dylib`Transient::init() + 1396\n    frame #9: 0x00000001013f46a9 libmoose-opt.0.dylib`TransientMultiApp::setupApp(unsigned int, double) + 553\n    frame #10: 0x00000001013f443a libmoose-opt.0.dylib`TransientMultiApp::initialSetup() + 186\n    frame #11: 0x0000000101219809 libmoose-opt.0.dylib`FEProblemBase::initialSetup() + 5657\n    frame #12: 0x0000000100f9ff64 libmoose-opt.0.dylib`Transient::init() + 1396\n    frame #13: 0x000000010196250b libmoose-opt.0.dylib`MooseApp::executeExecutioner() + 75\n    frame #14: 0x00000001019638be libmoose-opt.0.dylib`MooseApp::run() + 3262\n    frame #15: 0x000000010000fb9e porous_flow-opt`main + 142\n    frame #16: 0x00007fff71d9bcc9 libdyld.dylib`start + 1\n    frame #17: 0x00007fff71d9bcc9 libdyld.dylib`start + 1\n\n\n\nWithout the MultiApp, both the main and subapp can --recover fine.\n\n\nThe input files are actually in #18294, but you won't be able to run them before #18235 is merged.  Once that happens, I'll rebase and then you'll see my #18294 start to fail the recover tests.",
          "url": "https://github.com/idaholab/moose/discussions/18295",
          "updatedAt": "2022-06-16T00:09:57Z",
          "publishedAt": "2021-07-09T06:33:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Andy\nI probably cant help on this system but I ll ask some questions to understand the issue better\n\nmatrix_app_out_cp should be a folder that contains the checkpoint files (0001, xdr stuff if i recall). Does it not?\nFrom the logs it looks like some material properties are involved in the crash. Is there anything special about those properties? Vectors? AD?\n\nIs there any way you could use the debug version to generate the lldb backtrace? The line numbers would help\nWith any luck you may even hit an assert that will tell us what s happening\n5) @loganharbour could you please merge #18235 ? Looks like they addressed the comments\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18295#discussioncomment-986070",
                  "updatedAt": "2022-06-16T00:10:02Z",
                  "publishedAt": "2021-07-09T16:47:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Other comments:\nfor 1)  this is expected.  The results for the sub app are saved in the main app checkpoint\nI would double check your input file to look for something that does not support recover. There are a few objects. We should be capturing this more gracefully so it s worth identifying what object is messing up",
                          "url": "https://github.com/idaholab/moose/discussions/18295#discussioncomment-1427402",
                          "updatedAt": "2022-06-16T00:10:02Z",
                          "publishedAt": "2021-10-05T00:02:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@WilkAndy can we close this? Is this still an issue?\nI can see one test in #18294 that is set to recover = false but it s a subapp input file tested on its own it seems so it's not the problem?",
                  "url": "https://github.com/idaholab/moose/discussions/18295#discussioncomment-1498981",
                  "updatedAt": "2022-06-16T00:10:03Z",
                  "publishedAt": "2021-10-18T22:33:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "This is still a problem.  The recover = false test (in moose/modules/porous_flow/examples/multiapp_fracture_flow/3dFracture) still crashes.\nYes, it is very likely that it is a Material problem - PorousFlow has these \"nodal Material\" things.\nBut, nevertheless, both the main and sub Apps can --recover when run by themselves.  It is only when in a MultiApp situation that things don't work.",
                          "url": "https://github.com/idaholab/moose/discussions/18295#discussioncomment-1499271",
                          "updatedAt": "2022-06-16T00:10:03Z",
                          "publishedAt": "2021-10-19T00:37:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "The result of\nlldb -- /Users/wil04q/projects/moose/modules/porous_flow/porous_flow-dbg -i matrix_app.i Executioner/end_time=1 --recover --recoversuffix cpr\n\nis\nLikely cause: p.&p accessed 0x0\n(lldb) bt\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)\n  * frame #0: 0x00000001040c0aaf libmoose-dbg.0.dylib`void dataLoad<PropertyValue>(stream=0x0000000116c2b240, p=0x0000000118fd2bd0, (null)=0x0000000114081618) at MaterialProperty.h:93:6\n    frame #1: 0x00000001040c07e5 libmoose-dbg.0.dylib`void loadHelper<PropertyValue*>(stream=0x0000000116c2b240, data=0x0000000118fd2bd0, context=0x0000000114081618) at DataIO.h:791:3\n    frame #2: 0x00000001040c070e libmoose-dbg.0.dylib`void dataLoad<PropertyValue*>(stream=0x0000000116c2b240, v=size=6, context=0x0000000114081618) at DataIO.h:486:5\n    frame #3: 0x00000001040c0685 libmoose-dbg.0.dylib`void loadHelper<PropertyValue*>(stream=0x0000000116c2b240, data=size=6, context=0x0000000114081618) at DataIO.h:799:3\n    frame #4: 0x00000001040c0653 libmoose-dbg.0.dylib`void dataLoad<MaterialProperties>(stream=0x0000000116c2b240, v=0x0000000118fd2ba8, context=0x0000000114081618) at MaterialProperty.h:421:3\n    frame #5: 0x00000001040c0615 libmoose-dbg.0.dylib`void loadHelper<MaterialProperties>(stream=0x0000000116c2b240, data=0x0000000118fd2ba8, context=0x0000000114081618) at DataIO.h:791:3\n    frame #6: 0x00000001040c05d6 libmoose-dbg.0.dylib`void dataLoad<unsigned int, MaterialProperties>(stream=0x0000000116c2b240, m=0x0000000118fd2b58, context=0x0000000114081618) at DataIO.h:609:5\n    frame #7: 0x00000001040c0555 libmoose-dbg.0.dylib`void loadHelper<unsigned int, MaterialProperties>(stream=0x0000000116c2b240, data=0x0000000118fd2b58, context=0x0000000114081618) at DataIO.h:847:3\n    frame #8: 0x00000001040c04e6 libmoose-dbg.0.dylib`void dataLoad<libMesh::Elem const*, HashMap<unsigned int, MaterialProperties> >(stream=0x0000000116c2b240, m=0x0000000117280d50, context=0x0000000114081618) at DataIO.h:609:5\n    frame #9: 0x00000001040c0408 libmoose-dbg.0.dylib`void dataLoad<MaterialPropertyStorage>(stream=0x0000000116c2b240, storage=0x0000000117280db0, context=0x0000000114081618) at MaterialPropertyStorage.h:331:3\n    frame #10: 0x00000001040c03c5 libmoose-dbg.0.dylib`void loadHelper<MaterialPropertyStorage>(stream=0x0000000116c2b240, data=0x0000000117280db0, context=0x0000000114081618) at DataIO.h:791:3\n    frame #11: 0x00000001040bf826 libmoose-dbg.0.dylib`RestartableData<MaterialPropertyStorage>::load(this=0x0000000117280cf0, stream=0x0000000116c2b240) at RestartableData.h:172:3\n    frame #12: 0x00000001043b7f62 libmoose-dbg.0.dylib`RestartableDataIO::deserializeRestartableData(this=0x00007ffeefbf61a8, restartable_data=size=48, stream=0x0000000116c2b240, filter_names=size=0) at RestartableDataIO.C:173:35\n    frame #13: 0x00000001043ba71c libmoose-dbg.0.dylib`RestartableDataIO::restoreBackup(this=0x00007ffeefbf61a8, backup=std::__1::shared_ptr<Backup>::element_type @ 0x0000000116c2b108 strong=4 weak=1, for_restart=false) at RestartableDataIO.C:384:7\n    frame #14: 0x0000000104e9e2d9 libmoose-dbg.0.dylib`MooseApp::restore(this=0x0000000116974018, backup=std::__1::shared_ptr<Backup>::element_type @ 0x0000000116c2b108 strong=4 weak=1, for_restart=false) at MooseApp.C:1142:8\n    frame #15: 0x0000000104eac095 libmoose-dbg.0.dylib`MooseApp::restoreCachedBackup(this=0x0000000116974018) at MooseApp.C:1982:3\n    frame #16: 0x0000000103fe3d78 libmoose-dbg.0.dylib`FEProblemBase::initialSetup(this=0x0000000113841c18) at FEProblemBase.C:1019:12\n    frame #17: 0x0000000103aaac9b libmoose-dbg.0.dylib`Transient::init(this=0x0000000113840c18) at Transient.C:242:12\n    frame #18: 0x0000000104429c3a libmoose-dbg.0.dylib`TransientMultiApp::setupApp(this=0x000000011406ae18, i=0, (null)=0) at TransientMultiApp.C:652:7\n    frame #19: 0x00000001044298b8 libmoose-dbg.0.dylib`TransientMultiApp::initialSetup(this=0x000000011406ae18) at TransientMultiApp.C:171:7\n    frame #20: 0x0000000103fec733 libmoose-dbg.0.dylib`MooseObjectWarehouse<MultiApp>::initialSetup(this=0x0000000115018708, tid=0) const at MooseObjectWarehouse.h:154:13\n    frame #21: 0x0000000103fe4e1f libmoose-dbg.0.dylib`FEProblemBase::initialSetup(this=0x0000000115016e18) at FEProblemBase.C:1048:17\n    frame #22: 0x0000000103aaac9b libmoose-dbg.0.dylib`Transient::init(this=0x0000000115022a18) at Transient.C:242:12\n    frame #23: 0x0000000104e9d302 libmoose-dbg.0.dylib`MooseApp::executeExecutioner(this=0x0000000116895018) at MooseApp.C:1062:19\n    frame #24: 0x0000000104ea047f libmoose-dbg.0.dylib`MooseApp::run(this=0x0000000116895018) at MooseApp.C:1292:5\n    frame #25: 0x000000010000ef07 porous_flow-dbg`main(argc=7, argv=0x00007ffeefbfdc38) at main.C:33:8\n    frame #26: 0x00007fff6af62cc9 libdyld.dylib`start + 1\n    frame #27: 0x00007fff6af62cc9 libdyld.dylib`start + 1\n(lldb)",
                          "url": "https://github.com/idaholab/moose/discussions/18295#discussioncomment-1499349",
                          "updatedAt": "2022-06-16T00:10:02Z",
                          "publishedAt": "2021-10-19T01:08:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some Questions on Coupling SPPARKS and MyTrim Modules in Magpie",
          "author": {
            "login": "mcrossover97"
          },
          "bodyText": "Hi there,\nI am trying to understand how exactly the coupling of SPPARKS and MyTrim with Magpie works. I have several questions:\n\nWhen compiling SPPARKS and MyTrim, a bunch of .lo and .d files are created. I assume that they are object files that will be used to make libmagpie-opt files in the lib folder. Am I correct? If so, what is the difference between .lo and .d files? One can understand from spparks.mk and mytrim.mk files that .lo  and .d files are labeled as ADDITIONAL_APP_OBJECTS and ADDITIONAL_APP_DEPS, respectively. However, it seems that when I delete the following line which is used to make .d files, .d files will not be created and yet no error comes up during compilation:\n\nADDITIONAL_APP_DEPS += $(patsubst %.C, %.$(obj-suffix).d, $(mytrim_srcfiles))\nWhat are they for and are they even necessary?\n\n\nFrom my understanding, when compiling a module, all .c and .cpp files used in that module should be compiled. However, for example, in the MyTrim module, only files that are in the module main folder (MYTRIM_DIR) are made into object files while there is another .c files in the $(MYTRIM_DIR)/shim folder (point.c) that seems to go uncompiled. Anyway, it looks like files that are in this folder (point.c, point.h, and pow.h) aren't doing anything. This is because, when I delete the codes within these 3 files, the program will be compiled without error although simconf.h in $(MYTRIM_DIR) seems to be using the point class. What am I missing here?\n\n\nI don't have GSL and fftw3 installed. Shouldn't it cause an error when compiling? Where GSL and fftw3 are used?\n\n\nWhat does ADDITIONAL_CPPFLAGS += -DMYTRIM_ENABLED in the magpie.mk file do? If I delete this line, I encounter a compilation error.\n\n\nIt seems like MyTrim uses CMake to generate a makefile as we can see the CMakeLists.txt in the main folder. However, I think that this file doesn't impact compilation. How does our compiler understand what procedures to follow to compile a program without using CMake to generate a makefile? For example, if a package uses C++17 features, I think we can set this in the CMake file which in turn generates a Makefile that is told to compile based on C++17. How do we set stuff like this in our makefiles without CMake?\n\n\nI know probably my questions are full of insufficient, wrong, and misguiding terminologies due to my lack of knowledge in computer engineering. I hope I have been able to express what I mean. I would be really appreciative if someone could clear things up for me. Thanks for your help and support,\nMohammad",
          "url": "https://github.com/idaholab/moose/discussions/18986",
          "updatedAt": "2022-09-13T16:07:16Z",
          "publishedAt": "2021-10-03T08:16:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cticenhour who is in charge of Magpie?",
                  "url": "https://github.com/idaholab/moose/discussions/18986#discussioncomment-1427405",
                  "updatedAt": "2022-09-13T16:07:27Z",
                  "publishedAt": "2021-10-05T00:04:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "@dschwen are you still in charge of Magpie?",
                          "url": "https://github.com/idaholab/moose/discussions/18986#discussioncomment-1427594",
                          "updatedAt": "2022-09-13T16:07:29Z",
                          "publishedAt": "2021-10-05T01:26:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@snschune @recuero",
                          "url": "https://github.com/idaholab/moose/discussions/18986#discussioncomment-1498936",
                          "updatedAt": "2022-09-13T16:07:29Z",
                          "publishedAt": "2021-10-18T22:18:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Me",
                          "url": "https://github.com/idaholab/moose/discussions/18986#discussioncomment-1499044",
                          "updatedAt": "2022-09-13T16:07:29Z",
                          "publishedAt": "2021-10-18T22:59:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "1 ..d files are dependency files. We use the compiler supplied dependency resolution to enable recompiling only what needs to be recompiled.\nOur build system makes heavy use of libtool; .lo files contain information for building a .so.\n2. You are missing that myTRIM is a submodule in Magpie, and it is also intended to be compiled as a standalone program. The files you mention contain shims for objects that MOOSE provides, but are absent (and need to come from somewhere) when building myTRIM as a standalone code.\n3. GSL and FFTW3 are optional dependencies. If you look closer in the Makefiles you'll see -D defines that are checked using #ifdefs which disable certain classes in Magpie if those libs are not available\n4. what I just said ^\n5. See my answer to 2. CMake is only used when building a standalone version of myTRIM",
                  "url": "https://github.com/idaholab/moose/discussions/18986#discussioncomment-1499067",
                  "updatedAt": "2022-09-20T03:08:42Z",
                  "publishedAt": "2021-10-18T23:06:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}