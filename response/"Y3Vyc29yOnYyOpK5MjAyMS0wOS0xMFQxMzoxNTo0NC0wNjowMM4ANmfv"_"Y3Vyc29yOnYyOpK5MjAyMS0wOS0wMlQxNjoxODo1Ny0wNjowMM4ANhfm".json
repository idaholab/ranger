{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wOS0wMlQxNjoxODo1Ny0wNjowMM4ANhfm"
    },
    "edges": [
      {
        "node": {
          "title": "Elasticity tensor for 3D cylinder mesh",
          "author": {
            "login": "MartimSalgado"
          },
          "bodyText": "Are the principal directions 1,2,3 for C_{ijkl} associated with material coordinates or the global xyz cartesian reference? If we are modeling a 3D cylinder mesh, the elasticity tensor should be defined in terms of cylindrical coordinates and not global xyz.",
          "url": "https://github.com/idaholab/moose/discussions/18679",
          "updatedAt": "2022-06-27T12:42:50Z",
          "publishedAt": "2021-08-23T12:26:15Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "So you are asking for a nonhomogeneous anisotropic elasticity tensor. That is doable -- in moose you can define material properties per qp however you like.",
                  "url": "https://github.com/idaholab/moose/discussions/18679#discussioncomment-1222121",
                  "updatedAt": "2022-06-27T12:42:50Z",
                  "publishedAt": "2021-08-23T12:31:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "MartimSalgado"
                          },
                          "bodyText": "@hugary1995 Thanks. I'm saying that this is a relatively common tensor mechanics problem (I'm modelling a fibrous composite material) and there should be an easy way of telling MOOSE that we are defining [C] in terms of a cylindrical coordinate system.",
                          "url": "https://github.com/idaholab/moose/discussions/18679#discussioncomment-1222347",
                          "updatedAt": "2022-06-27T12:42:59Z",
                          "publishedAt": "2021-08-23T13:14:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yes, it should be pretty straightforward to implement. In your app, create a material that defines the elasticity tensor. You can request information about the coordinate system, e.g. center axis direction, center axis point, etc., from the user by defining input parameters. You can then transform the current point _q_point[_qp] into the cylindrical coordinates, and define the elasticity tensor from that.\nYou can watch the workshop video on the moose homepage for how to create an app and write a custom material.",
                          "url": "https://github.com/idaholab/moose/discussions/18679#discussioncomment-1222932",
                          "updatedAt": "2022-06-27T12:43:03Z",
                          "publishedAt": "2021-08-23T15:05:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MartimSalgado"
                          },
                          "bodyText": "@hugary1995 that does seem like a straightforward approach. Need to get more into the _q_point transformation.\nI've started developing a ComputeElasticityTensor child material ('ComputeFromCylindricalElasticityTensor'). My approach is to rotate Cijkl twice - once for coordinate transformation, another to take into account each transversely isotropic ply's orientation - and then assign it to the elasticity tensor. Here's the thing: I'm not getting accurate results - quantitatively, since C_ij values do not correspond with the material being modeled, and qualitatively (for instance, C_33 varies with (x,y) for a given ply). Do you see anything wrong with my computeQpElasticityTensor?\nPS: I haven't programmed this appropriately, yet, I'm just testing to get results. I assume that the layup of plies is made by rotating the radial direction axis and that the z-axis is aligned with the cylinder's axis.\nComputeFromCylindricalElasticityTensor.zip",
                          "url": "https://github.com/idaholab/moose/discussions/18679#discussioncomment-1268978",
                          "updatedAt": "2022-06-27T12:43:04Z",
                          "publishedAt": "2021-09-01T22:41:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MartimSalgado"
                          },
                          "bodyText": "Maybe it would be even better to develop Stress divergence equations kernels for the r-theta-z coordinated system. If I understood correctly, MOOSE only allows to model 2D or 1D problems using polar coordinates, right?",
                          "url": "https://github.com/idaholab/moose/discussions/18679#discussioncomment-1270728",
                          "updatedAt": "2022-11-14T04:08:04Z",
                          "publishedAt": "2021-09-02T09:18:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MartimSalgado"
                          },
                          "bodyText": "Hey @hugary1995, have you managed to look into this?",
                          "url": "https://github.com/idaholab/moose/discussions/18679#discussioncomment-1295230",
                          "updatedAt": "2022-11-14T04:08:04Z",
                          "publishedAt": "2021-09-08T09:23:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Maybe it would be even better to develop Stress divergence equations kernels for the r-theta-z coordinated system. If I understood correctly, MOOSE only allows to model 2D or 1D problems using polar coordinates, right?\n\nThose already exist",
                          "url": "https://github.com/idaholab/moose/discussions/18679#discussioncomment-1296798",
                          "updatedAt": "2022-11-14T04:08:04Z",
                          "publishedAt": "2021-09-08T15:18:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MartimSalgado"
                          },
                          "bodyText": "Thanks @dschwen!\nI've read the  ADStressDivergenceRZTensors page and it seems that it only works for axisymmetric problems (equations are shown for 2-D, z and r). What I meant by developing the kernel is to obtain the stress divergence for the full 3D problem.\nI forgot to mention that I do not have axisymmetric BCs",
                          "url": "https://github.com/idaholab/moose/discussions/18679#discussioncomment-1308254",
                          "updatedAt": "2022-11-14T04:08:05Z",
                          "publishedAt": "2021-09-10T18:44:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "regenerating *.i file from *_outfile.e file",
          "author": {
            "login": "DomenicoCFD"
          },
          "bodyText": "Hi All,\nI would like to regenerate the input file of MOOSE if only the _outfile.e is given. This is because I would expect to modify the input file and therefore I may well loose the track of all the input that I provided in MOOSE for a particular _outfile.e MOOSE result file.\nA similar feature does exist in ANSYS so eventually MOOSE does have a similar thing.\nI would really appreciate your help on this.\nKind Regards,",
          "url": "https://github.com/idaholab/moose/discussions/18789",
          "updatedAt": "2023-09-26T17:50:28Z",
          "publishedAt": "2021-09-08T13:19:32Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "The input file is actually stored in the exodus output as a data block. You can reveal some of it on the command line using strings my_out.e. Note that this is a reconstructed input with all default parameters inserted by MOOSE.",
                  "url": "https://github.com/idaholab/moose/discussions/18789#discussioncomment-1296248",
                  "updatedAt": "2023-09-26T17:50:28Z",
                  "publishedAt": "2021-09-08T13:26:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "You can extract the text properly with the ncdump command from netcdf (the Exodus II fileformat is based on netcdf)",
                          "url": "https://github.com/idaholab/moose/discussions/18789#discussioncomment-1296274",
                          "updatedAt": "2023-09-26T17:50:28Z",
                          "publishedAt": "2021-09-08T13:29:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "ncdump -v info_records my_out.e",
                          "url": "https://github.com/idaholab/moose/discussions/18789#discussioncomment-1296280",
                          "updatedAt": "2023-09-26T17:50:47Z",
                          "publishedAt": "2021-09-08T13:30:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "DomenicoCFD"
                          },
                          "bodyText": "Hi,\nMany thanks for your direction. Following your instruction, it seems that the \"ncdump\" option does give a better format than \"strings\". Other than that, is there a command line which returns the .i file ready to be rerun in MOOSE?\nI look forward to hearing from you.\nKind Regards,\nDomenico",
                          "url": "https://github.com/idaholab/moose/discussions/18789#discussioncomment-1301246",
                          "updatedAt": "2023-09-26T17:50:49Z",
                          "publishedAt": "2021-09-09T12:25:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "No single command. I suppose we could write a python script though. There is likely some post processing required though before passing the extracted input back to moose. Things like\ninactive                     = (no_default)\n\nor\n  \"    constant_properties          = \\'1 3.17e+07 0.32 0 3.17e+07 0.32 1000 6.67...\",\n  \"e-06 100 1e-08 5000 4 0.02 0\\'\",\n\n(which uses ... to mark a broken string)\nneed special treatment.",
                          "url": "https://github.com/idaholab/moose/discussions/18789#discussioncomment-1302803",
                          "updatedAt": "2023-09-26T17:51:08Z",
                          "publishedAt": "2021-09-09T17:00:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Hi\nyou can check Matlab ncread(), see this discussion #17852.",
                          "url": "https://github.com/idaholab/moose/discussions/18789#discussioncomment-1303477",
                          "updatedAt": "2023-09-26T17:51:14Z",
                          "publishedAt": "2021-09-09T19:25:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "On the computation of the sensitivities",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nThis topic is a follow-up to the topic in #18464 where we seek a way to compute the gradient of a cost functional w.r.t material parameter.\nLet's consider the diffusion equation with spatial heterogenous diffusivity, the final discretized form would be of the form A(m) u=b where m is the material parameters (the diffusivity).\nTo invert for the diffusivities m, given measured data d , the reconstruction process seeks minimizing a cost functional, which can be written as J(m)=0.5 (Pu-d)^T (Pu-d), where P is a projection operator to project u to the location of the measurements d.\nThe ith element in the gradient vector g_i = \u2202J(m)/\u2202m_i = (\u2202u/\u2202m_i)^T (Pu-d)  . This means, for M number of parameters, computing g requires M evaluation of (\u2202u/\u2202m_i ) which means M forward solves. This is very expensive especially when the problem is parameterized such that each finite element has a different material parameter (i.e. the diffusivity in this example).\nOne way to circumvent this is to expand (\u2202u/\u2202m_i), this yields g_i=u^T  (\u2202A/\u2202m_i)^T v with v=(A^T)^(-1) P^T (d-Pu(m)). This means, we only need one forward solve to compute v, then we need to evaluate the sparse matrix-vector multiplication(\u2202A/\u2202m_i)^T v which will result in a sparse vector to be inner-product with u in  g_i=u^T  (\u2202A/\u2202m_i)^T v .\nSo, we no longer need M forward solves and just need one. Now the whole effort is to get u^T (\u2202A/\u2202m_i)^T v  within moose.\nI have some plan and I need evaluation, and/or suggestions on how to improve it.\n1-Solve for u, then use the results to solve for v.\n2- Have a map of diffusivity_vs._element, where each diffusivity parameter id has a pointer to the corresponding finite element.\n3- In a third input file, have auxkernel to postprocessu^T  (\u2202A/\u2202m_i)^T v  where the material is defined as constant function = 1 because we only have the diffusivity and we took the derivative with respect to it.\n4- repeat 3 for all M paramters!\nComputing (\u2202A/\u2202m_i)^T v  is not clear for me since we need to compute it for a given diffusivity_id and repeat that for all diffusivities M .\nAny hint specifically on the mapping part (parameter id vs. elements) and on how to post-process in point 3?",
          "url": "https://github.com/idaholab/moose/discussions/18784",
          "updatedAt": "2022-07-25T09:43:41Z",
          "publishedAt": "2021-09-07T17:20:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "@aaelmeli\nIn (1), is v the solution to the adjoint equation?  I would use something like a the dirac kernel reporterPointSource to apply the projection in your adjoint solve.  You can read your misfit into this using a csvReader vector postprocessor.\nCan you do material inversion for the much simpler case where the entire block has a single unknown diffusivity?  I would start with this since it will require a new auxkernel to compute the gradient term mentioned in #18464    Once that works, you could make a more complicated problem where the diffusivity is a parameterized function of some spatial dimension?\nI think an optimization problem where every element has a different diffusivity will be hard to solve and will require Tikhonov regularization.  I'm not sure how you can create this map of element to diffusivity.  I think @Traiwit has asked about a similar capability, maybe they can give you some advice on having a material property that is different in each element in this disucssion #18727\nIf you were going to take approach 4, we have the simplex algorithm in Tao working.  We are in the process of getting our optimization code approved for release.  I think this will take another month but at that point you could use and develop that code.\nAre you going to use something like python to do your optimization and do the data transfers using files?",
                  "url": "https://github.com/idaholab/moose/discussions/18784#discussioncomment-1292868",
                  "updatedAt": "2022-07-25T09:43:39Z",
                  "publishedAt": "2021-09-07T19:33:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aaelmeli"
                  },
                  "bodyText": "In (1), is v the solution to the adjoint equation?\n\nyes, it is.\n\nCan you do material inversion for the much simpler case where the entire block has a single unknown diffusivity? I would start with this since it will require a new auxkernel to compute the gradient term mentioned in #18464 Once that works, you could make a more complicated problem where the diffusivity is a parameterized function of some spatial dimension?\n\nYes, that is probably better and what I should start with. In this regard, I had some questions,\na-Regarding the input file/s, based on what you suggested in your reply on (1), we can compute u and v using two different input files, Am I correct?\nthen to compute  u^T (\u2202A/\u2202m_i)^T v , we need to have another additional input file (so we would have 3 input files to compute g_i), Am I correct?\nb- Do you mean by new auxkernel that I need to implement a new auxkernel that takes u and v from previous run as input, and compute u^T (\u2202A/\u2202m_i)^T v? or do we have something to reuse in moose?\nc- In the input file where we want to compute u^T (\u2202A/\u2202m_i)^T v, since this term is just matrix_vector multiplication and inner product of the result with u, so there is no solve is required, my question now, is it possible to have dummy kernel and dummy variable and explicitly tell moose not to solve the linear system of equations?\n\nI think an optimization problem where every element has a different diffusivity will be hard to solve and will require Tikhonov regularization. I'm not sure how you can create this map of element to diffusivity. I think @Traiwit has asked about a similar capability, maybe they can give you some advice on having a material property that is different in each element in this disucssion #18727\n\nI have implemented this approach for 2D wave-equation inversion in frequency domain and the results were quite well. Now, I am using moose in order to do a similar thing but in 3D efficiently.\nRegarding parameter_vs_elements map, I have design my in-house code to have a map of parameterId_vs_elements, for example, given the parameter_id, it returns a vector of pointers to the finite elements associated with that parameter. However, because of my little experience with moose, I was not sure if this was possible or not, maybe they have something more elegant and more efficient.\n\nIf you were going to take approach 4, we have the simplex algorithm in Tao working. We are in the process of getting our optimization code approved for release. I think this will take another month but at that point, you could use and develop that code.\n\nThat will be very helpful especially when I do wave equation inversion in 3D.\n\nAre you going to use something like python to do your optimization and do the data transfers using files?\n\nYes, my initial thought is to have something working to test a research idea and not worry much about the efficiency. So, I am going to link Matlab with moose. I will use Matlab's optimization routines for the optimization and communicate with moose through files. these files are: one contains the parameters at the kth iteration, the other one contains the value of the cost function and the gradient vector (computed in moose).",
                  "url": "https://github.com/idaholab/moose/discussions/18784#discussioncomment-1293363",
                  "updatedAt": "2022-07-25T09:43:36Z",
                  "publishedAt": "2021-09-07T21:25:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "I've done something similar to this where I was using matlab to do the optimization. I've attached two input files to this that I used for the forward and adjoint input files.  These input fils were used for for load inversion for a point source so it is was much simpler than the material inversion problem because the adjoint variable was my gradient, I didn't need to compute a gradient term.\nTo solve u^T (\u2202A/\u2202m_i)^T v    I think you will run the forward problem, save the primary variable (u) to an exodus file and then read that exodus file into the adjoint problem, read u into a auxvariable using a userObject.  Then in the adjoint problem, use a parsedAuxKernel to multiply the adjoint variable, v, by u.  Then use a postprocessor to sum all of this up across all of the elements.\nI used something like this for a convective boundary condition where temperature_forward is the solution field from teh forward problem:\n[AuxVariables]\n  [temperature_forward]\n  []\n  [T2]\n  []\n[]\n[AuxKernels]\n  [TT]\n    type = ParsedAux\n    args = 'temperature temperature_forward'\n    variable = T2\n    function = 'temperature*(100-temperature_forward)'\n  []\n[]\n\n[Variables]\n  [temperature]\n  []\n[]\n\n[Postprocessors]\n  [adjoint_pt_0]\n    type = SideIntegralVariablePostprocessor\n    variable = T2\n    boundary = left\n  []\n[]\n\nI saw this discussion #18790\nand they are computing material properties on one app and passing them to the subapp.  Maybe if you grep for ADMaterialRealAux you might find a place where it is being used in a material.  something like that might work in place of the material to element map you need.",
                  "url": "https://github.com/idaholab/moose/discussions/18784#discussioncomment-1298478",
                  "updatedAt": "2022-07-25T09:43:57Z",
                  "publishedAt": "2021-09-08T22:21:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "This is the forward input file:\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 1.0\n    ymin = 0\n    ymax = 2.0\n    elem_type = QUAD4\n    nx = 10\n    ny = 20\n  []\n[]\n\n[Variables]\n  [temperature]\n  []\n[]\n\n[Kernels]\n  [heat_conduction]\n    type = ADHeatConduction\n    variable = temperature\n  []\n[]\n\n[DiracKernels]\n  [force_0]\n    type = ReporterPointSource\n    variable = 'temperature'\n    value_name = 'csv_reader/value'\n    x_coord_name = csv_reader/x\n    y_coord_name = csv_reader/y\n    z_coord_name = csv_reader/z\n  []\n[]\n\n[BCs]\n  [top]\n    type = DirichletBC\n    variable = temperature\n    boundary = top\n    value = 0\n  []\n  [bottom]\n    type = DirichletBC\n    variable = temperature\n    boundary = bottom\n    value = 0\n  []\n  [left]\n    type = DirichletBC\n    variable = temperature\n    boundary = left\n    value = 0\n  []\n  [right]\n    type = DirichletBC\n    variable = temperature\n    boundary = right\n    value = 0\n  []\n[]\n\n[Materials]\n  [steel]\n    type = ADGenericConstantMaterial\n    prop_names = thermal_conductivity\n    prop_values = .5\n  []\n[]\n\n[Problem]\n  type = FEProblem\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[VectorPostprocessors]\n  [temperatures]\n    type = NodalValueSampler\n    variable = temperature\n    block = '0'\n    sort_by = id\n    outputs = fullResponseVector\n  []\n  [csv_reader]\n    type = CSVReader\n    csv_file = 'zForwardInput/inputForces.csv'\n  []\n[]\n\n[Outputs]\n  [exodus]\n    file_base = 'zForwardOutput/out'\n    type = Exodus\n    execute_on = final\n  []\n  [fullResponseVector]\n    file_base = 'zForwardOutput/all'\n    type = CSV\n    execute_vector_postprocessors_on = final\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/18784#discussioncomment-1298484",
                  "updatedAt": "2022-07-25T09:44:27Z",
                  "publishedAt": "2021-09-08T22:23:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "I had to paste them in, I couldn't figure out how to attach them.",
                          "url": "https://github.com/idaholab/moose/discussions/18784#discussioncomment-1298487",
                          "updatedAt": "2022-08-15T09:01:10Z",
                          "publishedAt": "2021-09-08T22:25:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "this is the adjoint input file:\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 1.0\n    ymin = 0\n    ymax = 2.0\n    elem_type = QUAD4\n    nx = 10\n    ny = 20\n  []\n[]\n\n[Variables]\n  [temperature]\n  []\n[]\n\n[Kernels]\n  [heat_conduction]\n    type = ADHeatConduction\n    variable = temperature\n  []\n[]\n\n[DiracKernels]\n  [force_0]\n    type = ReporterPointSource\n    variable = temperature\n    value_name = csv_reader/value \n    x_coord_name = csv_reader/x\n    y_coord_name = csv_reader/y\n    z_coord_name = csv_reader/z\n  []\n[]\n\n[BCs]\n  [top]\n    type = DirichletBC\n    variable = temperature\n    boundary = top\n    value = 0\n  []\n  [bottom]\n    type = DirichletBC\n    variable = temperature\n    boundary = bottom\n    value = 0\n  []\n  [left]\n    type = DirichletBC\n    variable = temperature\n    boundary = left\n    value = 0\n  []\n  [right]\n    type = DirichletBC\n    variable = temperature\n    boundary = right\n    value = 0\n  []\n[]\n\n[Materials]\n  [steel]\n    type = ADGenericConstantMaterial\n    prop_names = thermal_conductivity\n    prop_values = .5\n  []\n[]\n\n[Problem]\n  type = FEProblem\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[VectorPostprocessors]\n  [temperatures]\n    type = NodalValueSampler\n    variable = temperature\n    block = '0'\n    sort_by = id\n    outputs = fullResponseVector\n  []\n  [csv_reader]\n    type = CSVReader\n    csv_file = 'zAdjointInput/inputForces.csv'\n    # execute_on = initial\n  []\n[]\n\n[Outputs]\n  [exodus]\n    file_base = 'zAdjointOutput/out'\n    type = Exodus\n    execute_on = final\n  []\n  [fullResponseVector]\n    file_base = 'zAdjointOutput/all'\n    type = CSV\n    execute_vector_postprocessors_on = final\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/18784#discussioncomment-1298486",
                  "updatedAt": "2022-08-15T09:01:10Z",
                  "publishedAt": "2021-09-08T22:24:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mesh splitting",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "Hello,\nI would like to ask about distributed mesh a couple of questions,\nFirst the original problem: Using larger mesh (more elements) with 24 independent variables with 3 subapps uses more than 100gb of memory.\nWhat I am trying to do: use mesh splitting so that it doesnt copy the whole mesh for each processor.\nmpiexec -np 24 app-opt -i inputFile.i --split-mesh 24,48,144 --split-file foo.cpr\nmpiexec -np 24 app-opt -i inputFile.i --use-split --split-file foo.cpr\n\n\nProblem:\nError:\n*** ERROR ***\nThe following error occurred in the object \"PostProcessorValue\", of type \"NodalVariableValue\".\n\nNodalVariableValue should only be used when node renumbering is disabled.\n\nThis solution did nothing:\n[Mesh]\n  [./msh]\n    type = FileMeshGenerator\n    file = ../../test.exo\n    dim = 3\n    **allow_renumbering = false**\n  []\n  [./sidesets]\n    type = SideSetsFromNormalsGenerator\n    input = msh\n    normals = '0 0 1\n    0 0 -1\n    0 1 0\n    0 -1 0\n    1 0 0\n    -1 0 0'\n    fixed_normal = true\n    new_boundary = 'top1 bottom1 front1 back1 right1 left1'\n  []\n  [./ns1]\n    type = ExtraNodesetGenerator\n    input = sidesets\n    new_boundary = 'nodeset1'\n    nodes = '1'\n  [../]\n[]\n\nI these variables were not essential in calculations. So I commented them out for now... but now I get this problem:\n4[22] ./include/libmesh/remote_elem.h, line \n[120, compiled Aug  2 2021 at 10:45:35\n\n\n*** ERROR ***\nError: not implemented!\n\nThis happens in the subapp.\nNo idea where to go from here unfortunately, would appreciate any suggestions.",
          "url": "https://github.com/idaholab/moose/discussions/18785",
          "updatedAt": "2022-10-20T17:03:59Z",
          "publishedAt": "2021-09-07T19:22:04Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYour issue is that the Mesh generators are basically ignored when a split mesh is loaded this way (using the --use-split).\nI will rework the documentation for that soon. In the mean time you could use --distributed-mesh and no split. Splits are typically for very very large runs where IO matters a lot. For 24 processes, you are just trying to distribute the mesh not reduce file system IO\nYou can still use split with a FileMeshGenerator (the documentation I ll be writing) but for the file argument you need to specify the 'foo.cpr' folder.\nHope this helps\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18785#discussioncomment-1293001",
                  "updatedAt": "2022-10-20T17:04:09Z",
                  "publishedAt": "2021-09-07T20:01:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I re-read your post. You definitely want to be using --distributed-mesh instead of splitting meshes.",
                          "url": "https://github.com/idaholab/moose/discussions/18785#discussioncomment-1293085",
                          "updatedAt": "2023-07-27T15:19:23Z",
                          "publishedAt": "2021-09-07T20:18:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "I'll give that a shot, but any idea on how to solve the last problem? it started showing up after testing with mesh splitting...\n4[22] ./include/libmesh/remote_elem.h, line \n[120, compiled Aug  2 2021 at 10:45:35\n\n\n*** ERROR ***\nError: not implemented!\n\nI tried recompiling all\nmake clobberall\nmake -j8\n\ndoesnt seem to work.",
                          "url": "https://github.com/idaholab/moose/discussions/18785#discussioncomment-1294401",
                          "updatedAt": "2022-10-20T17:04:10Z",
                          "publishedAt": "2021-09-08T06:04:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We'd need a backtrace to see which function is not implemented. Libmesh is supposed to provide one, but maybe not on asserts.\nIf you could run the code in a debugger and place a breakpoint on MPI_Abort that should work to get a backtrace",
                          "url": "https://github.com/idaholab/moose/discussions/18785#discussioncomment-1294421",
                          "updatedAt": "2022-12-09T02:18:48Z",
                          "publishedAt": "2021-09-08T06:13:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "Thank you! I managed to get it to work, it was unrelated to the original problem. As for --distributed-mesh it worked like a charm. I guess splitting method would work just as well.\nI have a couple of follow up questions,\n\nwould using more subapps require more memory?\nwhen do you consider the problem large enough to use splitting, since i'm only using 24 cores for debugging/testing/setting up the simulation but have access to more computational resources. when does splitting is more advantageous than distributed mesh.\nNot sure exactly the technical differences between distributed mesh and splitting it, so they might be the same thing, so I'd just like to clarify the difference. from what I understood, the mesh can get very large that it wont fit in the RAM, that's when you use pre-splitting. which might be handy to set up for the problem .\n\nAgain, thanks for the very helpful support.",
                          "url": "https://github.com/idaholab/moose/discussions/18785#discussioncomment-1295919",
                          "updatedAt": "2022-12-09T02:18:48Z",
                          "publishedAt": "2021-09-08T12:15:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "Would like to add to this is that I had to add to the mesh block allow_renumbering = false to calculate the Nodal post-processors, and for my subapp I used clone_master_mesh = true in the subapp block\nMesh:\n[Mesh]\n  [./msh]\n    type = FileMeshGenerator\n    file = ../../test.exo\n    dim = 3\n    allow_renumbering = false\n  []\n  [./sidesets]\n    type = SideSetsFromNormalsGenerator\n    input = msh\n    normals = '0 0 1\n    0 0 -1\n    0 1 0\n    0 -1 0\n    1 0 0\n    -1 0 0'\n    fixed_normal = true\n    new_boundary = 'top1 bottom1 front1 back1 right1 left1'\n  []\n  [./ns1]\n    type = ExtraNodesetGenerator\n    input = sidesets\n    new_boundary = 'nodeset1'\n    nodes = '1'\n  [../]\n  allow_renumbering = false # This is the one that worked\n[]\n\nMultiapp:\n[MultiApps]\n  [./cstests_sub]\n    type = TransientMultiApp\n    positions = '0 0 0'\n    input_files = csTests_sub.i\n    execute_on = 'initial timestep_end'\n    clone_master_mesh = true\n  [../]\n[] \n\nCorrect me if this is not the case for using clone_master_mesh or if better solution exists.",
                          "url": "https://github.com/idaholab/moose/discussions/18785#discussioncomment-1296231",
                          "updatedAt": "2023-04-13T20:41:05Z",
                          "publishedAt": "2021-09-08T13:22:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If the subapps are using the same mesh as the main app, clone_master_mesh is great for that.\n\nYes. More subapps will use more memory usually. In your case, if all subapps are defining variables on the same mesh as the main app, then that takes up memory.\nSee this page for more info on splitting.  https://mooseframework.inl.gov/syntax/Mesh/splitting.html\nExpensive mesh work and lots of processors (like >100) on a slow file system make splitting beneficial",
                          "url": "https://github.com/idaholab/moose/discussions/18785#discussioncomment-1296870",
                          "updatedAt": "2022-12-09T02:18:54Z",
                          "publishedAt": "2021-09-08T15:32:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Something wrong with the offical website?",
          "author": {
            "login": "ZhigangPu"
          },
          "bodyText": "Dear,\nIt seems that the offcial website of MOOSE (https://mooseframework.inl.gov/) has crashed? I can not access the website this morning til now.\nDoes that happen to you?",
          "url": "https://github.com/idaholab/moose/discussions/18787",
          "updatedAt": "2021-09-08T14:00:26Z",
          "publishedAt": "2021-09-08T05:59:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Yep, i agree",
                  "url": "https://github.com/idaholab/moose/discussions/18787#discussioncomment-1294398",
                  "updatedAt": "2021-09-08T06:03:08Z",
                  "publishedAt": "2021-09-08T06:02:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere are a few technical difficulties on some websites at the lab. We'll keep you posted once we know more.\nYou can build the website locally in the mean time. In the doc/ of your app: python moosedocs.py build --serve\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18787#discussioncomment-1294427",
                  "updatedAt": "2021-09-08T06:15:50Z",
                  "publishedAt": "2021-09-08T06:15:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ZhigangPu"
                          },
                          "bodyText": "Wow, so cool, thanks very much!\nZhigang",
                          "url": "https://github.com/idaholab/moose/discussions/18787#discussioncomment-1294447",
                          "updatedAt": "2021-09-08T06:20:11Z",
                          "publishedAt": "2021-09-08T06:20:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Should be up and working now.",
                          "url": "https://github.com/idaholab/moose/discussions/18787#discussioncomment-1296044",
                          "updatedAt": "2021-09-08T12:39:45Z",
                          "publishedAt": "2021-09-08T12:39:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ZhigangPu"
                          },
                          "bodyText": "Yes, indeed, thanks for your effort!",
                          "url": "https://github.com/idaholab/moose/discussions/18787#discussioncomment-1296411",
                          "updatedAt": "2021-09-08T14:00:16Z",
                          "publishedAt": "2021-09-08T14:00:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cellular Growth | Solidification Modeling",
          "author": {
            "login": "rl3fz"
          },
          "bodyText": "Hello Everyone!\nI'm looking to simulate cellular growth during solidification. Does MOOSE have any kernels that would be particularly helpful here? I'm familiar with the grand potential examples, but I'm looking for more control over the direction/orientation (and if possible, type) of the growth.\nAny and all advice would be greatly appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/18717",
          "updatedAt": "2022-06-17T08:08:17Z",
          "publishedAt": "2021-08-27T15:04:37Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen",
                  "url": "https://github.com/idaholab/moose/discussions/18717#discussioncomment-1269245",
                  "updatedAt": "2022-06-17T08:08:17Z",
                  "publishedAt": "2021-09-02T00:48:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "Grand potential-based solidification model is what we have that can be used here. You will be able to control orientation and growth type by selecting appropriate interfacial properties.",
                  "url": "https://github.com/idaholab/moose/discussions/18717#discussioncomment-1278210",
                  "updatedAt": "2022-06-17T08:08:19Z",
                  "publishedAt": "2021-09-03T17:15:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "Got it, thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18717#discussioncomment-1290973",
                          "updatedAt": "2022-06-17T08:08:20Z",
                          "publishedAt": "2021-09-07T13:15:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Converting what you get from auxvariables/auxkernels into material objects/BCs calculation?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys\nHow do you convert what you get from auxvariables/auxkernels into material objects/ BCs?\nI want to use the minimum length obtained from ElementLengthAux to calculate drainage (PorousFlowSink), is there any example, where should I start?\nI want to add it here (PorousFlowSink.C)\nReal\nPorousFlowSinkTC::computeQpResidual()\n{\n  Real flux = _test[_i][_qp] * multiplier();\n  if (_use_mobility)\n  {\n    const Real k =\n        ((*_permeability)[_qp] * _normals[_qp]) * _normals[_qp]; // do not upwind permeability\n    flux *= (*_fluid_density_node)[_i][_ph] * k / (*_fluid_viscosity)[_i][_ph]; ***********HERE************\n  }\n\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/18774",
          "updatedAt": "2022-07-26T00:52:43Z",
          "publishedAt": "2021-09-06T01:18:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont know about that file in particular but you can use either or both material properties and auxiliary variables in boundary conditions.\nThis object already seems to use material properties so you can look at it for its use of the MaterialPropertyInterface. For coupling in auxiliary variables you can look at the CoupledForce kernel and its use of the Coupleable interface.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18774#discussioncomment-1284163",
                  "updatedAt": "2022-07-26T00:52:49Z",
                  "publishedAt": "2021-09-06T02:14:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud, which would be easier?\n\nAuxvariable > material > BCs\nAuxvariable > BCs\n\nI'm still not sure how to call what I got from ElementLengthAux to PorousFlowSink.C\nThe example below is how density and viscosity (material object) are called\n    _fluid_density_node(_has_mobility ? &getMaterialProperty<std::vector<Real>>(\n                                            \"PorousFlow_fluid_phase_density_nodal\")\n                                      : nullptr),\n    _dfluid_density_node_dvar(_has_mobility ? &getMaterialProperty<std::vector<std::vector<Real>>>(\n                                                  \"dPorousFlow_fluid_phase_density_nodal_dvar\")\n                                            : nullptr),\n    _fluid_viscosity(_has_mobility\n                         ? &getMaterialProperty<std::vector<Real>>(\"PorousFlow_viscosity_nodal\")\n                         : nullptr),\n    _dfluid_viscosity_dvar(_has_mobility ? &getMaterialProperty<std::vector<std::vector<Real>>>(\n                                               \"dPorousFlow_viscosity_nodal_dvar\")\n                                         : nullptr),\n\nis there something like getAuxvariable? also is there a documentary on this stuff? I think I should read more about MOOSE .C and .h file before I start doing stuff like this.\nThank you\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18774#discussioncomment-1284451",
                          "updatedAt": "2022-07-26T00:52:50Z",
                          "publishedAt": "2021-09-06T05:02:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Auxvariable > BCs for sure.\nFor AuxVariable there is the Coupleable interface. Here's the constructor from CoupledForce (a kernel) where an auxvariable can be coupled in:\nCoupledForce::CoupledForce(const InputParameters & parameters)\n  : Kernel(parameters), _v_var(coupled(\"v\")), **_v(coupledValue(\"v\")),** _coef(getParam<Real>(\"coef\"))\n{\n  if (_var.number() == _v_var)\n    mooseError(\"Coupled variable 'v' needs to be different from 'variable' with CoupledForce, \"\n               \"consider using the CoefReaction kernel or something similar\");\n}\n\nthen the value of the coupled variable (here _v) is obtained with _v[_qp]\nThe variable can also be obtained (instead of the value) using the coupled() routine, but i dont think you need this here.",
                          "url": "https://github.com/idaholab/moose/discussions/18774#discussioncomment-1284461",
                          "updatedAt": "2022-08-03T13:46:45Z",
                          "publishedAt": "2021-09-06T05:07:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are you retrieving the aux variable from the same domain the boundary condition is applied in?\nOr does it 'live' on the other side?",
                          "url": "https://github.com/idaholab/moose/discussions/18774#discussioncomment-1284465",
                          "updatedAt": "2022-08-03T13:46:46Z",
                          "publishedAt": "2021-09-06T05:08:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@GiudGiud Thank you very much. The auxvariable is obtained from the same domain.\nThe original PorousFlowSink equation is basically darcy's law, but I want to use Abaqus equation for the drainage instead\n\nhttps://abaqus-docs.mit.edu/2017/English/SIMACAEPRCRefMap/simaprc-c-porousflow.htm\nApparently, the c can be calculated using modified ElementLengthAux\nAnyways, I will look into this further by calling auxvariable via  _v(coupledValue(\"v\") then add _v[_qp] into the equation I mentioned above. I will keep you updated, I really appreciate all your help\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18774#discussioncomment-1284560",
                          "updatedAt": "2022-08-12T08:23:34Z",
                          "publishedAt": "2021-09-06T05:59:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "it's working now, thank you! @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/18774#discussioncomment-1288878",
                          "updatedAt": "2022-08-12T08:23:42Z",
                          "publishedAt": "2021-09-07T03:42:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to use Cubit to create a 2D or QUAD9 Element",
          "author": {
            "login": "alexchen4ai"
          },
          "bodyText": "Hi, I am using cubit to create the mesh for Moose. I download the Cubit-learn version and it seems that there is no option for 2D mesh generation. Also, I can't find the option to adjust the type of elements. For example, use QUAD9 element so that we could use second order interpolation. Can anyone help with this?",
          "url": "https://github.com/idaholab/moose/discussions/18742",
          "updatedAt": "2023-09-25T14:22:00Z",
          "publishedAt": "2021-08-31T16:47:58Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHere are examples using the python API to generate a 2D mesh (there might be better ones in the documentation btw)\nhttps://github.com/idaholab/virtual_test_bed/tree/main/msfr/mesh\nhttps://github.com/idaholab/virtual_test_bed/blob/main/pbfhr/meshes/generate_core_with_reflectors.py\nAnd selecting quad9 is done here\nhttps://cubit.sandia.gov/15.5/help_manual/WebHelp/finite_element_model/exodus/exodus2_file_specification.htm\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18742#discussioncomment-1261382",
                  "updatedAt": "2023-09-25T14:22:00Z",
                  "publishedAt": "2021-08-31T18:08:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you. This works perfectly.",
                          "url": "https://github.com/idaholab/moose/discussions/18742#discussioncomment-1283246",
                          "updatedAt": "2023-09-25T14:22:03Z",
                          "publishedAt": "2021-09-05T18:30:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Design sensitivity analysis (derivative of results w.r. to parameters)",
          "author": {
            "login": "WulfHans"
          },
          "bodyText": "The derivative of results (e.g. displacements) with respect to parameters (e.g. material parameters) is often needed for parameter identification or optimization. Instead of multiple calls to the FE program and using finite differences (costly!), there is an alternative method that calculates these sensitivities directly in the FE code.\nThe method boils down to: After computing the convergent solution for the current time-step, you have to solve another system with the same system matrix but a different right hand side. If a decomposition is used for solving, it can be re-used resulting in minimal overhead. The additional right-hand-side contains the derivative of the constitutive law w.r.t. the parameter - this has to be provided by an additional subroutine or computed numerically.\nThis method has been implemented in several reasearch FE programs under various names like semi-analytical sensitivity analysis. Recently, it has been implemented in ABAQUS as well under the name \"Design sensitivity analysis\":\nhttps://classes.engineering.wustl.edu/2009/spring/mase5513/abaqus/docs/v6.6/books/stm/default.htm?startat=ch02s18ath57.html\nUnfortunately, ABAQUS does not allow any modifications to the process and is very limited in the choice of material laws. Concerning the homegrown FE codes ... I believe it is time to move to something larger and more professional.\nThe main questions are: Can this be done with MOOSE with a reasonable effort? Is the framework well-suited for this type of modification? Has someone attempted something similar already?\nThe very rough path to implementation looks like:\n\ndefine additional field variables for each derivative (should easy via variable tag)\ncreate an additional interface that represents the derivative of the constitutive law w.r.t. the parameters\ncompute the RHS using this interface (this might be very similar to existing functions)\nMake sure that the equation system is solved again for each parameter with the new right-hand-sides, after NEWTON converged (my first idea is that you might use a custom class derived from Executioner for this)\n\nAny hints concerning this plan are very welcome as well, especially which are the places to start off and which functionality can be easily reused.",
          "url": "https://github.com/idaholab/moose/discussions/18464",
          "updatedAt": "2022-06-18T12:02:42Z",
          "publishedAt": "2021-07-28T16:47:50Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n@friedmud has this been done before?\n@lindsayad what's your best guess on effort level for this?\nI don't see any road blocks in the path to implementation. We can compute variable derivatives. We would initalize a new simulation with the result of the previous one rather than try to do both parts in a single input file and re-use the Jacobian (not really worth the additional complications imo).\nWe can compute derivatives of the consistutive laws wrt variables using automatic differentiation, but also can declare derivative material properties and write the derivatives manually for those (if other parameters are involved).\nWhat do you mean precisely by RHS here? Which terms?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1088723",
                  "updatedAt": "2022-06-18T12:03:22Z",
                  "publishedAt": "2021-07-29T20:10:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WulfHans"
                          },
                          "bodyText": "Thanks for the affirmative replies already!\nConcerning the questions:\nThe RHS in this case is essentially the normal RHS, but derived by the parameter. For the mechanical problem, its nodal forces derived by the parameter (thats why it is often called pseudo-load). It contains two terms, that describe essentially describe\na) how much does the force directly change due to change in stress and\nb) how much does does it indirectly change by changing the solution\nwhen applying a variation to a parameter.\nAt the end, the integrals look very similar to the computation of the normal RHS, but with the derivates wrt the parameters instead.\nI could write down some equations (is some LaTeX supported here?), but in fact the Abaqus manual linked above nicely describes it as well, without too much overhead.\nBtw: If there are some state variables (internal variables of the constitutive law), these need to be stored and retrieved as well. This should be no big problem, right?",
                          "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1090884",
                          "updatedAt": "2022-06-18T12:03:24Z",
                          "publishedAt": "2021-07-30T10:37:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "If we indeed do this using forward mode automatic differentiation, then all state variables would cary along the derivative w.r.t. the design parameter anyways. I'm not sure there'd even be this special treatment of the RHS. Maybe I'm being overly naive, but in my mind adding the additional parameter derivative entries should make then get carried through the entire solution pretty much automatically.\n@lynnmunday can probably comment more (he's the PI on the project).",
                          "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1093771",
                          "updatedAt": "2022-06-18T12:03:32Z",
                          "publishedAt": "2021-07-31T06:23:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "@WulfHans We have implemented a system to solve inverse optimization problems for parameter estimation using the adjoint method to compute the gradient.  We only did this for force inversion and haven't completed it for material identification.\nWe are also doing this for discrete measurement points and have not done this for the whole solution field.  Are you only interested in the gradient part of this?  I think that is all you need to compute the sensitivity.\nI think @GiudGiud idea on how to compute this sensitivity might work.  To get the gradient at each node, you need something like the patchrecovery auxKernel that can multiply the derivative of the material property with the gradients of the shape functions.  This will need to be done for all of the elements touching the node.  I think I was told a userObject could also do this.  This new nodal value will then need to be multiplied by the nodal solution from the forward problem to get the gradient.  I think this is the right.\nLike @dschwen mentions, we will eventually compute this gradient with automatic differentiation.",
                          "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1121519",
                          "updatedAt": "2022-06-18T12:03:32Z",
                          "publishedAt": "2021-08-02T17:43:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Hi @lynnmunday,\nI have the same problem setting, i.e material identification given discrete responses and utilizing the adjoint formulation to compute the gradient (a derivative of the objective (cost) functional w.r.t material properties). So, if possible, I need some hints on the implementations from you since I think we almost have the same problem.\nsummary of the problem:\nI am defining the spatial distribution of the material properties through an ASCII file (coordinates and material property value). The spatial material distribution is defined such that each material pixel includes one or more finite elements.\nTo compute the gradient vector, each element of the gradient vector will involve computing the derivative of the constitutive equation w.r.t the corresponding material parameter. The computation of the constitutive equation w.r.t that corresponding material parameter would result in a very sparse matrix (nonzero only at the dofs that are located inside that parameter \"pixel\"). So, I was wondering if you could give some pointers on the implementation part of the gradient, in particular, what functions can be reused from moose, and what kernels/interfaces should be implemented.\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1269671",
                          "updatedAt": "2022-08-18T14:31:01Z",
                          "publishedAt": "2021-09-02T04:15:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "@aaelmeli This current pr is for the patchrecovery auxkernel and userobjects:  #18721 (review)\nI think we need something like this to compute the gradients.\nTo compute this sensitivity at each node you need to be able to compute the following contribitution from each element that touches that node:\nnodal_sensitivty = element_integral (grad_shapefunction*grad_forwardSolution)\nI don't think nodal aux_kernels have access to element data like shape functions.  That is why @hugary1995 added a userObject in the above pr.  He is computing a nodal flux (i.e. nodal stress) based on the element data which is kind of what you need to do.  So Gary's nodal patch recovery could compute grad_forwardSolution at the node but we need to also also include in this integral the multiplication by the derivative of the shape function.   Maybe this will be easy to do now that Gary has added the patch recovery capability.  I haven't had time to look at it.  I think the sensitivity will be simpler than patchRecovery because Gary is also solving a least squares problem and we don't need that.",
                          "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1273035",
                          "updatedAt": "2022-08-18T14:31:01Z",
                          "publishedAt": "2021-09-02T16:44:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Hey Lynn, two possibly dumb questions:\n\nwhy do we need spatial gradients of material properties?\nwhy do we need those gradients at the nodes?",
                          "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1273202",
                          "updatedAt": "2022-08-18T14:31:02Z",
                          "publishedAt": "2021-09-02T17:15:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Hey Lynn, two possibly dumb questions:\n\nwhy do we need spatial gradients of material properties?\nI can reply on this question: in material identification inverse problems (like for example subsurface imaging, biomedical imaging) we are interested in determining the material properties and its spatial distribution. By sending and tracking sound/electromagnetic waves, that inversion was possible. the goal then is to minimize the difference between the measured wavefield and simulated wave field. So, it is optimization problem where the parameters are the material properties and its spatial distribution. Given an objective (cost) functional of your choice, we then need to compute the derivative of that cost functional w.r.t material properties. This requires computing the derivative of the constitutive equation w.r.t the material properties.\nI hope this answers the question.",
                          "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1273783",
                          "updatedAt": "2022-08-18T14:31:02Z",
                          "publishedAt": "2021-09-02T19:22:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay I see. Then you want to use nodal path recovery to get the gradient of material property at quadrature points. To be honest, I think that's pretty difficult to implement for general constitutive laws. If it ever gets implemented in moose, I think it will be using what @dschwen proposed below #18464 (reply in thread) .",
                          "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1273992",
                          "updatedAt": "2022-08-18T14:31:02Z",
                          "publishedAt": "2021-09-02T20:10:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "These manual gradients wouldn't be too bad to implement for some simple problems like linear elasticity.  I agree that Daniels approach will be better but I think that might not be ready for a while.  This would be a good check for what Daniel does and would let us work on some other parts of the optimization code while we wait.\nSome more information about the optimization code is available in section 3 of this milestone report:\nhttps://www.osti.gov/biblio/1812088-enhanced-mechanical-property-evaluation-using-innovative-data-analytics-capability",
                          "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1274507",
                          "updatedAt": "2022-08-18T14:31:02Z",
                          "publishedAt": "2021-09-02T23:07:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "We have an LDRD where this is on our schedule for the beginning of the coming fiscal year.",
                  "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1088733",
                  "updatedAt": "2022-06-18T12:03:33Z",
                  "publishedAt": "2021-07-29T20:14:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "We basically need the ability to add custom entries to the AD derivative vector. This could be done by using scalar variables to represent the design parameters for example.",
                          "url": "https://github.com/idaholab/moose/discussions/18464#discussioncomment-1088823",
                          "updatedAt": "2022-06-18T12:52:50Z",
                          "publishedAt": "2021-07-29T20:41:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unable to find appropriate mortar segment during linear search!",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I have developed a contact model, and I get the following error when I run the code:\nUnable to find appropriate mortar segment during linear search!\nIs this type of error due to the distance of the colliding parts from each other, or maybe a time stepping issue?",
          "url": "https://github.com/idaholab/moose/discussions/18724",
          "updatedAt": "2022-06-02T06:09:32Z",
          "publishedAt": "2021-08-29T16:10:31Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@jbadger95 @lindsayad",
                  "url": "https://github.com/idaholab/moose/discussions/18724#discussioncomment-1251741",
                  "updatedAt": "2022-06-02T06:09:32Z",
                  "publishedAt": "2021-08-30T02:33:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jbadger95"
                  },
                  "bodyText": "I'm going to need more info about your setup, can you provide your input file?",
                  "url": "https://github.com/idaholab/moose/discussions/18724#discussioncomment-1254828",
                  "updatedAt": "2022-06-02T06:09:34Z",
                  "publishedAt": "2021-08-30T15:45:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Yes. Thank you for taking a look.\nParticleCladdClash.e.txt\nParticleCladdClash.i.txt",
                          "url": "https://github.com/idaholab/moose/discussions/18724#discussioncomment-1262857",
                          "updatedAt": "2022-06-02T06:09:35Z",
                          "publishedAt": "2021-09-01T02:15:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jbadger95"
                  },
                  "bodyText": "Sorry for the delay, I've been tied up with some other things but I have an answer! The problem is that you have nodes on your primary surface that project to exactly the same place on the secondary surface (mortar subdivides secondary elements where primary elements project so it's trying to subdivide twice at the same point). The problem is where your bottom and sides meet. To fix this you can change your geometry, I'd probably extend the side rectangles to the bottom of the bottom rectangle then merge the all surfaces before you generate your mesh. Alternatively you could leave a small gap between the bottom and sides so that the nodes at the corners don't coincide.\nWe can probably address this case in the source to avoid problems in the future but for now your best bet is just to modify geometry  so there are no redundant nodes.",
                  "url": "https://github.com/idaholab/moose/discussions/18724#discussioncomment-1274384",
                  "updatedAt": "2022-06-02T06:09:35Z",
                  "publishedAt": "2021-09-02T22:18:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}