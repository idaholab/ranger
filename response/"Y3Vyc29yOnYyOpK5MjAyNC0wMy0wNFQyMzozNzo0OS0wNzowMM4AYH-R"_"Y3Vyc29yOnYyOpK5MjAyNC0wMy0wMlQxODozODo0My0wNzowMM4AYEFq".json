{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wMy0wMlQxODozODo0My0wNzowMM4AYEFq"
    },
    "edges": [
      {
        "node": {
          "title": "How to realize calculation while excavation?",
          "author": {
            "login": "lei123abc"
          },
          "bodyText": "At present, I want to excavate a tunnel. How can I calculate the stress around the tunnel while digging? For example, after digging the tunnel for three meters, calculate the stress around it once, and then after digging another three meters, calculate the stress, and repeat the cycle. If I want to achieve the above process, I need How to do it.",
          "url": "https://github.com/idaholab/moose/discussions/26962",
          "updatedAt": "2024-03-05T02:53:12Z",
          "publishedAt": "2024-03-05T02:47:40Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "IncompressibleFluidProperties interest?",
          "author": {
            "login": "garcs2"
          },
          "bodyText": "Hello,\nPer my previous discussion post I have now successfully implemented a routine to derive pressure from v and e (v -> rho -> T -> h then p = rho * (h-e)). However, I've now ran into an issue with implementing the e_from_v_h routine, since there's no way to backtrack pressure from any of those quantities. To this end, I was curious if there was any interest for me to create a IncompressibleFluidProperties Moose Object that only takes in temperature for most quantities, but pressure for quantities such as internal energy. From looking at the fluidproperties it doesn't seem that this would be redundant but of course would like other opinions.",
          "url": "https://github.com/idaholab/moose/discussions/26856",
          "updatedAt": "2024-03-04T20:02:25Z",
          "publishedAt": "2024-02-21T17:47:09Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont know that a new base class for fluid properties will solve your problem. It seems like it would need to inherit from the current ones to be accessible in the current fluid flow solvers.\nI think what you want to do is implement the fluid solver that does not rely on quantities you cannot compute. Then all fluid properties can be queried with the existing calls even if 'pressure' is set to a dummy value for example\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26856#discussioncomment-8547556",
                  "updatedAt": "2024-02-21T18:48:55Z",
                  "publishedAt": "2024-02-21T18:48:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "garcs2"
                          },
                          "bodyText": "Hi Guillaume,\nThank you for the response! When you say \"implement a fluid solver that does not rely on quantities you cannot compute\", where exactly would that correspond within the input file? Are you suggesting to change the fluid property type and use a substitute such as simplefluidproperties?",
                          "url": "https://github.com/idaholab/moose/discussions/26856#discussioncomment-8667701",
                          "updatedAt": "2024-03-04T14:40:52Z",
                          "publishedAt": "2024-03-04T14:40:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nNo changing the fluid properties is an option and you can consider it.\nYou can fit SimpleFP or StiffenedGasFP to be close to the fluid you are modeling, over a limited range of T, P.\nI was thinking of implementing a solver that does not rely on (v, e) but uses (p,T) in every equation\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/26856#discussioncomment-8668090",
                          "updatedAt": "2024-03-04T15:09:14Z",
                          "publishedAt": "2024-03-04T15:09:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "garcs2"
                          },
                          "bodyText": "Hi Guillaume,\nI'm sorry I believe I need more clarification. So when you are referring to solver you are meaning going to the source file (NaKFluidProperties.C) and adjusting all the properties to take only pressure and temperature in every equation?\nI think I am confused since when I was originally trying to adopt the THM example to utilize NaK, all of the properties as functions of (p,T) were already implemented but would still get an error thrown at me per the first discussion post. So after I implemented that function, I would still get errors thrown for properties that were not implemented as functions of (v,e) that I then implemented myself (T, c, cp, cv, k, mu). My point is, NaKFluidProperties.C already has properties in terms of (p,T) so I'm not sure what I can do to circumvent getting errors thrown at me if that makes sense.",
                          "url": "https://github.com/idaholab/moose/discussions/26856#discussioncomment-8668961",
                          "updatedAt": "2024-03-04T16:10:52Z",
                          "publishedAt": "2024-03-04T16:10:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nNo I mean re-writing the components in THM to use P,T instead of v,e\nIt s not a small task. But for incompressible fluids, I dont have another idea.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/26856#discussioncomment-8670023",
                          "updatedAt": "2024-03-04T17:41:20Z",
                          "publishedAt": "2024-03-04T17:41:20Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Soft tissue deformation",
          "author": {
            "login": "mshtx-mdacc"
          },
          "bodyText": "Howdy,\nI'm going to try and use MOOSE to model soft tissue deformation where the tissue acts similar to fluid saturated poroelastic medium. Biot's theory of biphasic consolidation is used to represent the deformation behavior of the tissue.  A snippet of the paper I'm referencing is shown here:\n\nAre the kernels already in MOOSE sufficient or will I need to create my own? I've looked through a lot of the documentation, but there's so much to digest! I thought the Tensor Mechanics module would be useful, but I am unsure.\nCheers,\nMSH",
          "url": "https://github.com/idaholab/moose/discussions/26955",
          "updatedAt": "2024-03-04T16:15:13Z",
          "publishedAt": "2024-03-04T14:18:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe tensor mechanics module can be an example for how to discretize this div u_vec terms.\nFirst identify which variables you want to solve for. I think displacements and pressure?\nthen look at finding a kernel for each term in isolation which use the right variable and let you specify the coefficients you want. I dont think the TM uses shear modulus much but I m not that familiar with that code.\nSame, I dont think pressure is used much in that module. It s used a lot for geo-mechanic studies so it would appear in those kernels\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26955#discussioncomment-8668558",
                  "updatedAt": "2024-03-04T15:39:11Z",
                  "publishedAt": "2024-03-04T15:39:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mshtx-mdacc"
                          },
                          "bodyText": "Yes, I would be solving for displacement and pressure. Thank you for the direction.\nMSH",
                          "url": "https://github.com/idaholab/moose/discussions/26955#discussioncomment-8668708",
                          "updatedAt": "2024-03-04T16:53:27Z",
                          "publishedAt": "2024-03-04T15:50:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "This page goes over the porous flow mechanics coupling in the porous_flow module:\nhttps://mooseframework.inl.gov/modules/porous_flow/tutorial_04.html\nThe porous_flow module uses actions to set up kernels and materials and it is useful to use the\nhttps://mooseframework.inl.gov/moose/source/problems/DumpObjectsProblem.html\nto find out what it is creating.",
                  "url": "https://github.com/idaholab/moose/discussions/26955#discussioncomment-8669027",
                  "updatedAt": "2024-03-04T16:15:14Z",
                  "publishedAt": "2024-03-04T16:15:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to implement explicit phase field solving?",
          "author": {
            "login": "Yasunaoka"
          },
          "bodyText": "Hi all, I have recently been working on implementing a simulation of an impact fracture problem through the coupling of tensor mechanics and phase field. After weeks of struggling with the phase field not converging (reference #26728 ), I decided to try to transform the implicit solution of the phase field into an explicit solution by referring to the tensor mechanics module.\n\n[GlobalParams]\n  implicit = false\n[]\n\n\n[TimeIntegrator]\n  type = CentralDifference\n  solve_type = lumped\n[]\n\n\nhowever the calculations did not turn out as expected: although the mechanics module did calculate and pass the driving force to the phase field module, however, the phase field module did not return any results.\n\nIf an implicit solution is used (i.e., the two code blocks above are deleted), the correct result can be obtained.So something must have gone wrong in between.Here is a link to my input file\nhttps://github.com/Yasunaoka/moose/tree/master/modules/combined/problem\nDoes anyone know how to implement explicit phase field solving? Any suggestions are greatly appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/26929",
          "updatedAt": "2024-03-04T13:45:50Z",
          "publishedAt": "2024-02-29T08:48:06Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you try a simpler explicit time integrator? Like a 1st order explicit euler?\nCentral difference has been coded for specific types of solves iirc\n@laagesen",
                  "url": "https://github.com/idaholab/moose/discussions/26929#discussioncomment-8637611",
                  "updatedAt": "2024-03-01T02:29:21Z",
                  "publishedAt": "2024-03-01T02:29:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Yasunaoka"
                          },
                          "bodyText": "Hi, thanks for the advice, although both the ExplicitEuler and ExplicitMidpoint integrators failed, but ActuallyExplicitEuler is working fine for me.",
                          "url": "https://github.com/idaholab/moose/discussions/26929#discussioncomment-8666933",
                          "updatedAt": "2024-03-04T13:45:45Z",
                          "publishedAt": "2024-03-04T13:45:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Is it possible to have IC (via SolutionUserObject) for all the timesteps",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "So normally we'd do the IC block like this (below), for the IC solution at T=0\n### ################################################################### #######\n### INITIAL CONDITIONS\n### ################################################################### #######\n\n[ICs]\n  [ic_porepressure_L1]\n    type = FunctionIC\n    variable = porepressure_L1\n    function = fcn_pw_from_prev_results\n  []\n[]\n[Functions]\n  [fcn_pw_from_prev_results]\n    type = SolutionFunction\n    from_variable = porepressure_L1\n    solution = uobj_prev_results\n  []\n[]\n[UserObjects]\n  [uobj_prev_results]\n    type = SolutionUserObject\n    mesh = 'OUTPUTExodus/XXXX2023_HR01_F001.e'\n    # execute_on = 'INITIAL'\n    # sytem_variables = porepressure_L1   ### THIS CAUSED AN ERROR: 'unused parameter'\n    timestep = 'LATEST'\n  []\n[]\n\nNow I'm wondering if we could have IC for all the timesteps (we have .e for all the timesteps), the reason being that the whole simulation take so long to converge (50+ NL steps), but we just want to adjust a bit of BC for the new run, so it doesn't have to go through long NL steps again\nI suspect it gotta have something to do with [Controls] but still haven't found anything that might work.\nThank you!\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/26949",
          "updatedAt": "2024-03-04T03:09:14Z",
          "publishedAt": "2024-03-04T00:41:23Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUse the IC for the first run\nFor every subsequent runs use a bunch of SolutionIC and a solutionUO loading the solution from the first run\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26949#discussioncomment-8660895",
                  "updatedAt": "2024-03-04T01:06:31Z",
                  "publishedAt": "2024-03-04T01:06:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud\nhttps://mooseframework.inl.gov/source/ics/SolutionIC.html\nThank you! so I need to have 1 SolutionIC and 1 solutionUO  per each time step and use [Controls] to control it?",
                          "url": "https://github.com/idaholab/moose/discussions/26949#discussioncomment-8660947",
                          "updatedAt": "2024-03-04T01:15:22Z",
                          "publishedAt": "2024-03-04T01:15:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Umm actually no you can't do that. I thought you were using separate simulations.\nIf you are using a single simulation, then the fields are not re initialized between each time step.\nSo where do you want this starting guess to come from?",
                          "url": "https://github.com/idaholab/moose/discussions/26949#discussioncomment-8661224",
                          "updatedAt": "2024-03-04T02:05:29Z",
                          "publishedAt": "2024-03-04T02:05:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "I thought you were using separate simulations.\n\nI also could do this but it would take 2 hrs just to set up (even before solving), the mesh has 18mil element :'(\nyeh, that's what I wondering, if it possible, lets say I have all the .e solution from the previous run (I save each timestep result to each .e). but I want to adjust some BC (just a lil bit) for the next run\nhow can I use each .e from the previous run to be the initial guess for each timestep of the new run (at timestep_begin).",
                          "url": "https://github.com/idaholab/moose/discussions/26949#discussioncomment-8661284",
                          "updatedAt": "2024-03-04T02:12:49Z",
                          "publishedAt": "2024-03-04T02:12:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think what you want is a SolutionPredictor\nIt would use the solution user object every time step to set the initial guess for the nonlinear variables.\nPredictors are the system of choice for changing initial guesses in my understanding. We generally have only used them for the Predictor Corrector scheme but this seems like a fitting use.",
                          "url": "https://github.com/idaholab/moose/discussions/26949#discussioncomment-8661565",
                          "updatedAt": "2024-03-04T03:09:15Z",
                          "publishedAt": "2024-03-04T03:09:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Reproducing mug.e mesh file in 'Example 1: As Simple as it Gets' with Gmsh",
          "author": {
            "login": "kurtenkera"
          },
          "bodyText": "I'm trying to reproduce 'Example 1: As Simple as it Gets' (https://mooseframework.inl.gov/getting_started/examples_and_tutorials/examples/ex01_inputfile.html), but by creating the mug.e mesh file parametrically (i.e., without a GUI) with Gmsh in a Python script. I'm doing this because I plan to use Gmsh to mesh up more complex geometries parametrically when using MOOSE in the future, so I want to test my use of Gmsh + MOOSE on this simple example. But as I have never actually generated a finite element mesh before, I have a few questions:\n\nHow can I view the mug.e mesh in the format seen below? I have tried simply reading the mug.e file into Paraview but couldn't reproduce the same figure below (which clearly shows the meshed cylinder whose elements are cube-shaped)?\n\n\n\nWill it be crucial that I create a cylinder with the same number of elements and also the same cube-shaped elements as seen above if I want to reproduce the same results? I ask this because currently I have created a cylinder (yet to be hollowed out) in Gmsh with tetrahedron-shaped elements (see below), and I feel like even once I hollow out the cylinder, the results mightn't be identical because the elements have different shapes?\n\n\n\nWhere can I find out how specifically the mug.e file was created (i.e. it should have been created using CUBIT from Sandia National Laboratories if it is a .e file no?) and any associated code if the mug.e file was produced with a `parametric meshing' approach?\n\nThanks in advance!",
          "url": "https://github.com/idaholab/moose/discussions/26950",
          "updatedAt": "2024-03-04T02:07:52Z",
          "publishedAt": "2024-03-04T01:31:54Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "1 paraview should be fine to visualize software. It has plenty of options, you can do a lot of things with it\n2 within the limit of fine refinement you should get the same results between tets and hexes.",
                  "url": "https://github.com/idaholab/moose/discussions/26950#discussioncomment-8661235",
                  "updatedAt": "2024-03-04T02:07:03Z",
                  "publishedAt": "2024-03-04T02:07:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I don't know who generated the mug mesh. This is probably a pretty generic problem so i would check the manual and the examples of cubit to see if it s not included there",
                          "url": "https://github.com/idaholab/moose/discussions/26950#discussioncomment-8661241",
                          "updatedAt": "2024-03-04T02:07:52Z",
                          "publishedAt": "2024-03-04T02:07:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to transfer a vector field or its components",
          "author": {
            "login": "QuangDom"
          },
          "bodyText": "Dear MOOSE Team,\nI am working with INSAD module, and would like to transfer the velocity (velocity in INSAD is a vector\nfield) into a sub-app. When I am using MultiAppProjectionTransfer, I got this error:\nsub0: *** ERROR ***\nsub0: The following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\nsub0: \nsub0: No standard variable named vel found. Did you specify a vector variable when you meant to specify a standard variable?\n\nIs there any transfer support this purpose? Or is there anyway to transfer the components of velocity (velocity_x, velocity_y)  separately?\nThanks in advance,\n/ Quang",
          "url": "https://github.com/idaholab/moose/discussions/20110",
          "updatedAt": "2024-03-04T01:27:32Z",
          "publishedAt": "2022-01-23T16:26:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo vector/array variable transfers is not uniformly supported. It's a project of ours.\nFor now,  you'll need to transfer the components separately,\n\n\nuse a vector component aux to store each component in a separate auxvariable\nhttps://mooseframework.inl.gov/source/auxkernels/VectorVariableComponentAux.html\n\n\nuse the transfer you want on each component aux-variable\n\n\ntwo scenarios:\n\n\n\nif you need this in a regular variable form (so each component is its own variable), then you can use what you just transferred\nif you need this back in vector form, then we need to create a vector equivalent of this: https://mooseframework.inl.gov/source/auxkernels/BuildArrayVariableAux.html.\nWe currently dont have this for for your use case.\n\nIt should not be too hard to make though.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20110#discussioncomment-2035826",
                  "updatedAt": "2022-06-23T14:00:41Z",
                  "publishedAt": "2022-01-24T17:00:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "PengWei97"
                  },
                  "bodyText": "Hi @GiudGiud,\nI had the same problem, whether the vector auxVariable at each nodel in main-app can be transferred via some transfer into the sub-app. Or, so far, there is still no suitable transfer object to solve this problem.\nAny help would be greatly appreciated!\nThanks,\nWei",
                  "url": "https://github.com/idaholab/moose/discussions/20110#discussioncomment-8650802",
                  "updatedAt": "2024-03-02T10:19:54Z",
                  "publishedAt": "2024-03-02T10:19:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou ll need to decompose the vector variable into its components and reform it after\nWe have very few transfers that support vector variables\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/20110#discussioncomment-8660749",
                          "updatedAt": "2024-03-04T00:35:28Z",
                          "publishedAt": "2024-03-04T00:35:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Ok, thanks a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/20110#discussioncomment-8661036",
                          "updatedAt": "2024-03-04T01:27:32Z",
                          "publishedAt": "2024-03-04T01:27:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Use AD or non-AD material properties in building material object",
          "author": {
            "login": "chunhuizhao478"
          },
          "bodyText": "Hi all, I tried to modify an ADComputeLinearElasticStress material object, because the computation will depend heavily on the AD, is it the best practice to keep every additional variable as ADMaterialProperty? For example, I may pass multiple constant values, coupled variable (when I modify ComputeLinearElasticStress before), should I make them all becomes ADMaterialProperty or not? Thanks for your suggestions",
          "url": "https://github.com/idaholab/moose/discussions/26942",
          "updatedAt": "2024-03-03T04:14:10Z",
          "publishedAt": "2024-03-01T18:09:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt s more a matter of what the consumers of these material properties expect.\nIf they are coded to receive AD properties you ll have to make even constants be AD material properties.\nThere are often two options for the consumers of these properties. So you can use the one that works with non AD types where appropriate\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26942#discussioncomment-8646930",
                  "updatedAt": "2024-03-01T19:10:24Z",
                  "publishedAt": "2024-03-01T19:10:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "chunhuizhao478"
                  },
                  "bodyText": "I encounter solver not converged error after implementation, I wonder if what I did here is correct, basically I would like to modify the elasticity tensor to have some damage, here are the code I have currently:\n//template <typename RankTwoTensor, typename R4, typename Real>\nvoid\nADComputeDamageBreakageStress::computeQpStress()\n{\n\n  /* \n  compute alpha and B parameters\n  */\n \n  if ( _t == 0.0 ){\n    setupInitial(); \n    //initialize lambda, shear_modulus, gamma_damaged\n    //alpha_damagedvar, B, eps_p, eps_e, eps_total, sts_total, I1, I2, xi,\n    //shear_wave_speed, pressure_wave_speed    \n  }\n  else{\n\n    //alpha, B are updated\n    ADReal alpha_out = _alpha_in[_qp];\n    ADReal B_out = _B_in[_qp];\n\n    //grad_alpha\n    ADReal alpha_grad_x = _alpha_grad_x[_qp];\n    ADReal alpha_grad_y = _alpha_grad_y[_qp];\n    ADReal alpha_grad_z = _alpha_grad_z[_qp];\n    ADReal D = _D;\n\n    //save alpha and B\n    _alpha_damagedvar[_qp] = _alpha_in[_qp];\n    _B[_qp] = _B_in[_qp];\n\n    /*\n    update modulus\n    */\n\n    //lambda, shear_modulus, gamma_damaged are updated\n    ADReal lambda_out = _lambda_o;\n    ADReal shear_modulus_out = _shear_modulus_o + alpha_out * _xi_0 * _gamma_damaged_r;\n    ADReal gamma_damaged_out = alpha_out * _gamma_damaged_r;\n\n    //save\n    _lambda[_qp] = lambda_out;\n    _shear_modulus[_qp] = shear_modulus_out;\n    _gamma_damaged[_qp] = gamma_damaged_out;  \n\n    /*\n      compute strain\n    */  \n\n    //eps_p, eps_e, eps_total are updated\n    //Retrieve parameter values\n    //strain: total, viscoelastic\n    ADRankTwoTensor eps_total_change = _mechanical_strain[_qp];\n    ADRankTwoTensor eps_total_change_old = _mechanical_strain_old[_qp];\n    ADRankTwoTensor eps_total_change_inc = eps_total_change - eps_total_change_old;\n\n    //get total strain (add increment)\n    ADRankTwoTensor eps_total = _eps_total_old[_qp] + eps_total_change_inc;\n\n    //take the viscoelastic strain from the previous time step\n    ADRankTwoTensor eps_viscoelastic = _eps_p_old[_qp];\n      \n    //take updated parameters\n    ADReal lambda = lambda_out;\n    ADReal shear_modulus = shear_modulus_out;\n    ADReal gamma_damaged = gamma_damaged_out;\n    ADReal B = B_out;\n\n    //Define components\n    ADReal eps11p_pre = eps_viscoelastic(0,0);\n    ADReal eps22p_pre = eps_viscoelastic(1,1);\n    ADReal eps33p_pre = eps_viscoelastic(2,2);\n    ADReal eps12p_pre = eps_viscoelastic(0,1);\n    ADReal eps13p_pre = eps_viscoelastic(0,2);\n    ADReal eps23p_pre = eps_viscoelastic(1,2);\n    ADReal eps11t = eps_total(0,0);\n    ADReal eps22t = eps_total(1,1);\n    ADReal eps33t = eps_total(2,2);\n    ADReal eps12t = eps_total(0,1);\n    ADReal eps13t = eps_total(0,2);\n    ADReal eps23t = eps_total(1,2);\n\n    //compute elastic strain\n    ADReal eps11e = eps11t - eps11p_pre;\n    ADReal eps22e = eps22t - eps22p_pre;\n    ADReal eps33e = eps33t - eps33p_pre;\n    ADReal eps12e = eps12t - eps12p_pre;\n    ADReal eps13e = eps13t - eps13p_pre;\n    ADReal eps23e = eps23t - eps23p_pre;  \n\n    //represent I1 I2 xi using elastic strain\n    ADReal I1 = eps11e + eps22e + eps33e;\n    ADReal I2 = eps11e * eps11e + eps22e * eps22e + eps33e * eps33e + 2 * eps12e * eps12e + 2 * eps13e * eps13e + 2 * eps23e * eps23e;\n    ADReal xi = I1 / std::sqrt(I2);  \n\n    //Represent sigma (solid(s) + granular(b))\n    ADReal sigma11_s = ( lambda - gamma_damaged / xi ) * I1 + ( 2 * shear_modulus - gamma_damaged * xi ) * eps11e;\n    ADReal sigma11_b = ( 2 * _a2 + _a1 / xi + 3 * _a3 * xi ) * I1 + ( 2 * _a0 + _a1 * xi - _a3 * std::pow(xi,3) ) * eps11e;\n    ADReal sigma22_s = ( lambda - gamma_damaged / xi ) * I1 + ( 2 * shear_modulus - gamma_damaged * xi ) * eps22e;\n    ADReal sigma22_b = ( 2 * _a2 + _a1 / xi + 3 * _a3 * xi ) * I1 + ( 2 * _a0 + _a1 * xi - _a3 * std::pow(xi,3) ) * eps22e;\n    ADReal sigma33_s = ( lambda - gamma_damaged / xi ) * I1 + ( 2 * shear_modulus - gamma_damaged * xi ) * eps33e;\n    ADReal sigma33_b = ( 2 * _a2 + _a1 / xi + 3 * _a3 * xi ) * I1 + ( 2 * _a0 + _a1 * xi - _a3 * std::pow(xi,3) ) * eps33e;\n    ADReal sigma12_s = ( 2 * shear_modulus - gamma_damaged * xi ) * eps12e;\n    ADReal sigma12_b = ( 2 * _a0 + _a1 * xi - _a3 * std::pow(xi,3) ) * eps12e;\n    ADReal sigma13_s = ( 2 * shear_modulus - gamma_damaged * xi ) * eps13e;\n    ADReal sigma13_b = ( 2 * _a0 + _a1 * xi - _a3 * std::pow(xi,3) ) * eps13e;\n    ADReal sigma23_s = ( 2 * shear_modulus - gamma_damaged * xi ) * eps23e;\n    ADReal sigma23_b = ( 2 * _a0 + _a1 * xi - _a3 * std::pow(xi,3) ) * eps23e;  \n\n    //Represent total stress\n    ADReal sigma11_t = (1 - B) * sigma11_s + B * sigma11_b;\n    ADReal sigma22_t = (1 - B) * sigma22_s + B * sigma22_b;\n    ADReal sigma33_t = (1 - B) * sigma33_s + B * sigma33_b;\n    ADReal sigma12_t = (1 - B) * sigma12_s + B * sigma12_b;\n    ADReal sigma13_t = (1 - B) * sigma13_s + B * sigma13_b;\n    ADReal sigma23_t = (1 - B) * sigma23_s + B * sigma23_b;\n\n    //Represent deviatoric stress\n    ADReal sigma_d11 = sigma11_t - 1/3 * (sigma11_t + sigma22_t + sigma33_t);\n    ADReal sigma_d22 = sigma22_t - 1/3 * (sigma11_t + sigma22_t + sigma33_t);\n    ADReal sigma_d33 = sigma33_t - 1/3 * (sigma11_t + sigma22_t + sigma33_t);\n    ADReal sigma_d12 = sigma12_t;\n    ADReal sigma_d13 = sigma13_t;\n    ADReal sigma_d23 = sigma23_t;\n\n    //Compute plastic strain increment\n    ADReal eps11p_inc = _dt * _C_g * std::pow(B,_m1) * std::pow(sigma_d11,_m2);\n    ADReal eps22p_inc = _dt * _C_g * std::pow(B,_m1) * std::pow(sigma_d22,_m2);\n    ADReal eps33p_inc = _dt * _C_g * std::pow(B,_m1) * std::pow(sigma_d33,_m2);\n    ADReal eps12p_inc = _dt * _C_g * std::pow(B,_m1) * std::pow(sigma_d12,_m2);\n    ADReal eps13p_inc = _dt * _C_g * std::pow(B,_m1) * std::pow(sigma_d13,_m2);\n    ADReal eps23p_inc = _dt * _C_g * std::pow(B,_m1) * std::pow(sigma_d23,_m2);\n\n    //save data\n    //viscoelastic strain\n    ADRankTwoTensor eps_p_out;\n    eps_p_out(0,0) = eps11p_pre + eps11p_inc;\n    eps_p_out(1,1) = eps22p_pre + eps22p_inc;\n    eps_p_out(0,1) = eps12p_pre + eps12p_inc;\n    eps_p_out(1,0) = eps12p_pre + eps12p_inc;\n    eps_p_out(0,2) = eps13p_pre + eps13p_inc;\n    eps_p_out(2,0) = eps13p_pre + eps13p_inc;\n    eps_p_out(1,2) = eps23p_pre + eps23p_inc;\n    eps_p_out(2,1) = eps23p_pre + eps23p_inc;\n    eps_p_out(2,2) = eps33p_pre + eps33p_inc;\n    _eps_p[_qp] = eps_p_out;\n\n    //elastic strain\n    ADRankTwoTensor eps_e_out;\n    ADReal eps11e_out = eps11t - ( eps11p_pre + eps11p_inc );\n    ADReal eps22e_out = eps22t - ( eps22p_pre + eps22p_inc );\n    ADReal eps33e_out = eps33t - ( eps33p_pre + eps33p_inc );\n    ADReal eps12e_out = eps12t - ( eps12p_pre + eps12p_inc );\n    ADReal eps13e_out = eps13t - ( eps13p_pre + eps13p_inc );\n    ADReal eps23e_out = eps23t - ( eps23p_pre + eps23p_inc );\n    eps_e_out(0,0) = eps11e_out;\n    eps_e_out(1,1) = eps22e_out;\n    eps_e_out(0,1) = eps12e_out;\n    eps_e_out(1,0) = eps12e_out;\n    eps_e_out(0,2) = eps13e_out;\n    eps_e_out(2,0) = eps13e_out;\n    eps_e_out(1,2) = eps23e_out;\n    eps_e_out(2,1) = eps23e_out;\n    eps_e_out(2,2) = eps33e_out;\n    _eps_e[_qp] = eps_e_out;\n\n    //total strain\n    ADRankTwoTensor eps_total_out;\n    eps_total_out(0,0) = eps11t;\n    eps_total_out(1,1) = eps22t;\n    eps_total_out(0,1) = eps12t;\n    eps_total_out(1,0) = eps12t;\n    eps_total_out(0,2) = eps13t;\n    eps_total_out(2,0) = eps13t;\n    eps_total_out(1,2) = eps23t;\n    eps_total_out(2,1) = eps23t;\n    eps_total_out(2,2) = eps33t;\n    _eps_total[_qp] = eps_total_out;\n\n    /*\n      compute I1 I2 xi\n    */\n\n    //I1, I2, xi are updated\n    \n    ADReal I1_out = eps11e_out + eps22e_out + eps33e_out;\n    ADReal I2_out = eps11e_out * eps11e_out + eps22e_out * eps22e_out + eps33e_out * eps33e_out + 2 * eps12e_out * eps12e_out + 2 * eps13e_out * eps13e_out + 2 * eps23e_out * eps23e_out;\n    ADReal xi_out = I1_out / std::sqrt(I2_out);\n\n    //save\n    _I1[_qp] = I1_out;\n    _I2[_qp] = I2_out;\n    _xi[_qp] = xi_out; \n\n    //compute stress\n    //sts_total, stress are updated\n    //feed total stress\n    ADRankTwoTensor stress_total_out;\n    stress_total_out(0,0) = ( 1 - B ) * ( ( lambda - gamma_damaged / xi_out ) * I1_out + ( 2 * shear_modulus - gamma_damaged * xi_out ) * eps11e_out ) + B * ( ( 2 * _a2 + _a1 / xi_out + 3 * _a3 * xi_out ) * I1_out + ( 2 * _a0 + _a1 * xi_out - _a3 * std::pow(xi_out,3) ) * eps11e_out );\n    stress_total_out(1,1) = ( 1 - B ) * ( ( lambda - gamma_damaged / xi_out ) * I1_out + ( 2 * shear_modulus - gamma_damaged * xi_out ) * eps22e_out ) + B * ( ( 2 * _a2 + _a1 / xi_out + 3 * _a3 * xi_out ) * I1_out + ( 2 * _a0 + _a1 * xi_out - _a3 * std::pow(xi_out,3) ) * eps22e_out );\n    stress_total_out(2,2) = ( 1 - B ) * ( ( lambda - gamma_damaged / xi_out ) * I1_out + ( 2 * shear_modulus - gamma_damaged * xi_out ) * eps33e_out ) + B * ( ( 2 * _a2 + _a1 / xi_out + 3 * _a3 * xi_out ) * I1_out + ( 2 * _a0 + _a1 * xi_out - _a3 * std::pow(xi_out,3) ) * eps33e_out );\n    stress_total_out(0,1) = ( 1 - B ) * ( ( 2 * shear_modulus - gamma_damaged * xi_out ) * eps12e_out ) + B * ( ( 2 * _a0 + _a1 * xi_out - _a3 * std::pow(xi_out,3) ) * eps12e_out );\n    stress_total_out(1,0) = ( 1 - B ) * ( ( 2 * shear_modulus - gamma_damaged * xi_out ) * eps12e_out ) + B * ( ( 2 * _a0 + _a1 * xi_out - _a3 * std::pow(xi_out,3) ) * eps12e_out );\n    stress_total_out(0,2) = ( 1 - B ) * ( ( 2 * shear_modulus - gamma_damaged * xi_out ) * eps13e_out ) + B * ( ( 2 * _a0 + _a1 * xi_out - _a3 * std::pow(xi_out,3) ) * eps13e_out );\n    stress_total_out(2,0) = ( 1 - B ) * ( ( 2 * shear_modulus - gamma_damaged * xi_out ) * eps13e_out ) + B * ( ( 2 * _a0 + _a1 * xi_out - _a3 * std::pow(xi_out,3) ) * eps13e_out );\n    stress_total_out(1,2) = ( 1 - B ) * ( ( 2 * shear_modulus - gamma_damaged * xi_out ) * eps23e_out ) + B * ( ( 2 * _a0 + _a1 * xi_out - _a3 * std::pow(xi_out,3) ) * eps23e_out );\n    stress_total_out(2,1) = ( 1 - B ) * ( ( 2 * shear_modulus - gamma_damaged * xi_out ) * eps23e_out ) + B * ( ( 2 * _a0 + _a1 * xi_out - _a3 * std::pow(xi_out,3) ) * eps23e_out );\n\n    //_sts_total[_qp] = stress_total_out;\n\n    //feed stress change (relative to initial condition) to system\n    //ADRankTwoTensor stress_out;\n    //ADRankTwoTensor stress_initial = _static_initial_stress_tensor[_qp];\n    // stress_out(0,0) = stress_total_out(0,0) - stress_initial(0,0);\n    // stress_out(1,1) = stress_total_out(1,1) - stress_initial(1,1);\n    // stress_out(2,2) = stress_total_out(2,2) - stress_initial(2,2);\n    // stress_out(0,1) = stress_total_out(0,1) - stress_initial(0,1);\n    // stress_out(1,0) = stress_total_out(1,0) - stress_initial(1,0);\n    // stress_out(0,2) = stress_total_out(0,2) - stress_initial(0,2);\n    // stress_out(2,0) = stress_total_out(2,0) - stress_initial(2,0);\n    // stress_out(1,2) = stress_total_out(1,2) - stress_initial(1,2);\n    // stress_out(2,1) = stress_total_out(2,1) - stress_initial(2,1);\n\n    // stress = C * e\n    _stress[_qp] = stress_total_out;\n\n    // Assign value for elastic strain, which is equal to the mechanical strain\n    _elastic_strain[_qp] = _mechanical_strain[_qp];\n  }\n}",
                  "url": "https://github.com/idaholab/moose/discussions/26942#discussioncomment-8655245",
                  "updatedAt": "2024-03-03T03:10:52Z",
                  "publishedAt": "2024-03-03T03:10:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "It gives me a feeling that I have to directly equate stress with strain _stress[_qp] = _elasticity_tensor[_qp] * _mechanical_strain[_qp], what I have above I pass values multiple times, is this a critical issue when using AD object?",
                          "url": "https://github.com/idaholab/moose/discussions/26942#discussioncomment-8655391",
                          "updatedAt": "2024-03-03T04:14:11Z",
                          "publishedAt": "2024-03-03T04:14:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Kinematic vs Mortar Thermal-Mechanical Contact",
          "author": {
            "login": "naabwxt"
          },
          "bodyText": "I am trying to benchmark using kinematic vs mortar for a mechanical contact in a coupled TM model. It is my understanding that the GapHeatTransfer function does not do well with penetration of the surfaces, so I am trying kinematic vs mortar for the mechanical contact.\nWhen using the kinematic contact, the solution progresses well and doesn't seem to have an issue converging. When simply changing the formulation = kinematic to formulation = mortar the solve does not even solve the first nonlinear iteration. The linear iteration residuals drop by only a small amount and always reach the max number of iterations.\nIs there more that needs to be changed when switching to the mortar contact formulation? This is also 3-D if that matters.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/26879",
          "updatedAt": "2024-03-03T02:20:43Z",
          "publishedAt": "2024-02-23T18:40:03Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc @jiangwen84",
                  "url": "https://github.com/idaholab/moose/discussions/26879#discussioncomment-8573414",
                  "updatedAt": "2024-02-23T22:22:09Z",
                  "publishedAt": "2024-02-23T22:22:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "3D mortar has been exercised significantly less than 2D mortar. Could you share an input, whether publicly or privately? It would make it easier to comment on what the issue might potentially be",
                  "url": "https://github.com/idaholab/moose/discussions/26879#discussioncomment-8595787",
                  "updatedAt": "2024-02-26T17:42:08Z",
                  "publishedAt": "2024-02-26T17:42:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "naabwxt"
                          },
                          "bodyText": "contact.zip\nI have attached a version of the input file...when you say it hasn't been exercised is that due to something in particular with 3d and mortar, its not the right thing to use or something else? I don't have any particular need to use mortar, its just reading through the documentation and some other conversations lead me to believe it is the \"better\" formulation especially for TM contact.",
                          "url": "https://github.com/idaholab/moose/discussions/26879#discussioncomment-8595972",
                          "updatedAt": "2024-02-26T17:58:32Z",
                          "publishedAt": "2024-02-26T17:58:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "3D mortar has been exercised less mostly because it was added later since the needs at the time for BISON were primarily two-dimensional and the mortaring is more difficult to implement in 3D.\nIn theory 3D mortar should be a great choice, but there are definitely complexities. The default mortar treatment uses Lagrange multipliers which introduces zero-diagonals in the matrix. Algebraic multigrid (AMG) can't handle such zero-diagonals well. Looking at your first nonlinear iteration, the linear residuals appear to be dropping pretty slowly, which is consistent with AMG not doing well. If I use LU the linear solves (and the nonlinear solve) looks good but it is very slow since LU does not scale well into the hundreds of thousand dofs.\nThe mechanics folks have recently worked on penalty mortar as well as augmented lagrange mortar. These techniques do not introduce the zero-diagonals like Lagrange multipliers do and are much better candidates for AMG. This input created by @recuero demonstrates how to setup augmented Lagrange contact. Sadly @recuero has left us, but @dschwen added the augmented Lagrange capability in #24349 so he should be another good resource",
                          "url": "https://github.com/idaholab/moose/discussions/26879#discussioncomment-8601780",
                          "updatedAt": "2024-02-27T07:48:41Z",
                          "publishedAt": "2024-02-27T07:46:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "naabwxt"
                          },
                          "bodyText": "Thanks for the background on this. One question with the penalty mortar and the augmented...do they both still provide the zero penetration of kinematic/mortar? My experience with using the gap heat transfer BCs seem to really struggle with penetration that penalty would allow.\nYeah, the LU is not going to be a workable solution given the size of the problems I would like to scale this to.",
                          "url": "https://github.com/idaholab/moose/discussions/26879#discussioncomment-8617941",
                          "updatedAt": "2024-02-28T12:36:38Z",
                          "publishedAt": "2024-02-28T12:36:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The example Augmented lagrange input I linked to before uses LU. This input uses Augmented Lagrange with algebraic multigrid. So that would be a better example to look at.  Augmented Lagrange does allow non-zero penetration, however, you can control the allowed penetration using the Contact/al_penetration_tolerance parameter.\nWe did work on a Variable Condensation Preconditioner (VCP) that was supposed to allow use of iterative preconditioning (like algebraic multigrid) with Lagrange multipliers (perfect constraint enforcement). However, I don't see any tests in the contact module that employ that preconditioner with algebraic multigrid for frictional contact (although I see one for frictionless here). Maybe @dewenyushu can comment on the potential of using VCP with frictional contact",
                          "url": "https://github.com/idaholab/moose/discussions/26879#discussioncomment-8623453",
                          "updatedAt": "2024-02-28T21:44:05Z",
                          "publishedAt": "2024-02-28T21:44:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Thanks @lindsayad for bringing me in the discussion.\nI had VCP working for a multi-physics problem (in Bison) with a considerable size that involves frictional mortar contact in 3D. It showed pretty significant computational benefits back then. However, we could not get AMG to work well with VCP on frictional mortar contact. We still needed to use LU under VCP.",
                          "url": "https://github.com/idaholab/moose/discussions/26879#discussioncomment-8647699",
                          "updatedAt": "2024-03-01T20:50:54Z",
                          "publishedAt": "2024-03-01T20:50:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Any hypotheses why AMG wasn't working?\nI also think it would be interesting to explore Schur-complement based field splits for solving LM-based contact, with the LM dofs in contact isolated in the Schur complement block and all other dofs including displacements and non-contact LM dofs in the non-Schur complement split. I think it has the potential of being very effective, but it would take some implementation work to make it happen. We would need to incorporate the LMs and gap into the MOOSE PETSc DM for determining the field decomposition. We would also need to figure out the optimal preconditioner for the Schur complement. For Stokes flow, which is also symmetric, the pressure mass matrix is spectrally equivalent, but in that case the off-diagonal blocks are formed from $\\nabla p$ and $\\nabla \\cdot \\vec{v}$ whereas in contact the off-diagonal blocks are simply $\\pm \\vec{\\lambda}$ and $\\pm \\vec{d}$",
                          "url": "https://github.com/idaholab/moose/discussions/26879#discussioncomment-8648192",
                          "updatedAt": "2024-03-01T22:02:12Z",
                          "publishedAt": "2024-03-01T22:02:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Any hypotheses why AMG wasn't working?\n\nIt is reported that after condensing the LMs, the system matrix is not necessarily friendly to AMG preconditioners (https://onlinelibrary.wiley.com/doi/full/10.1002/nme.6680). That is, that condensing out the LMs does not make the system \"contact property-free\" in a way.",
                          "url": "https://github.com/idaholab/moose/discussions/26879#discussioncomment-8655091",
                          "updatedAt": "2024-03-03T02:20:43Z",
                          "publishedAt": "2024-03-03T02:20:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Are Building and Testing MOOSE required every time I update Conda and MOOSE repository?",
          "author": {
            "login": "kurtenkera"
          },
          "bodyText": "I'm trying to develop a MOOSE-app at the moment. Every week I am updating the MOOSE repository and Conda by following the steps seen below:\n\nI then return to my application, and run the following to re-build and test it:\ncd ~/projects/YourAppName\nmake clobberall\nmake -j 6\n./run_tests -j 6\n\nThis is my question: Do I need to re-build and test MOOSE itself by following the steps below every time I update the MOOSE repository and Conda? Or is it enough simply re-build and test my application as seen above? In other words, are we only required to execute the build and testing of MOOSE below when we first download the MOOSE repository? I need to know as building and testing MOOSE using the steps below is very time consuming, and I'd rather not do it every time I update Conda and the MOOSE repository! Thanks in advance!",
          "url": "https://github.com/idaholab/moose/discussions/26948",
          "updatedAt": "2024-03-03T01:38:43Z",
          "publishedAt": "2024-03-03T01:35:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "You do not need to jump through all those hoops every week. Pay attention of the version of the moose conda packages is actually increased. If not, there's no need to do a clobberall. Testing is up to you. It should not be necessary, but if you want to run a simulation and want to rely on the results, it is recommended that you run the test suite to see if there are any problems with your installation.",
                  "url": "https://github.com/idaholab/moose/discussions/26948#discussioncomment-8654982",
                  "updatedAt": "2024-03-03T01:38:44Z",
                  "publishedAt": "2024-03-03T01:38:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}