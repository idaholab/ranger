{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMS0wMlQxODo0NDo0NS0wNjowMM4AcDf0"
    },
    "edges": [
      {
        "node": {
          "title": "problem loading mesh from msh file",
          "author": {
            "login": "RWTHLHK"
          },
          "bodyText": "I generated a msh file using Neper. But weirdly, the boundary name in the msh file can never be identified. I always get the error: the following node sets (ids) do not exist on the mesh: y0 (105). But I check in the msh file, boundary y0 indeed exists.\n[BCs]\n[symmy]\ntype = DirichletBC\nvariable = uy\nboundary = y0\nvalue = 0\n[]\n[symmx]\ntype = DirichletBC\nvariable = ux\nboundary = x0\nvalue = 0\n[]\n[symmz]\ntype = DirichletBC\nvariable = uz\nboundary = z0\nvalue = 0\n[]\n[tdisp]\ntype = FunctionDirichletBC\nvariable = uz\nboundary = z1\nfunction = 0.01*t\n[]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/29008",
          "updatedAt": "2024-11-05T20:03:57Z",
          "publishedAt": "2024-11-05T17:49:12Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nis it a sideset in this msh file instead of a nodeset?\nif so you can use this to convert it:\nhttps://mooseframework.inl.gov/source/meshgenerators/NodeSetsFromSideSetsGenerator.html",
                  "url": "https://github.com/idaholab/moose/discussions/29008#discussioncomment-11158275",
                  "updatedAt": "2024-11-05T18:27:57Z",
                  "publishedAt": "2024-11-05T18:27:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "thanks! I just found BoundingBoxNodeSetGenerator can also do the job.",
                          "url": "https://github.com/idaholab/moose/discussions/29008#discussioncomment-11159004",
                          "updatedAt": "2024-11-05T20:03:58Z",
                          "publishedAt": "2024-11-05T20:03:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Constraining dependent node on LinearNodalConstraint",
          "author": {
            "login": "TheBEllis"
          },
          "bodyText": "Hi MOOSE team,\nI have a question about the behaviour of LinearNodalConstraint. I have a problem where I am trying to constraint the average displacement of the nodes on a boundary to 0. I have been trying to use a LinearNodalConstraint for this.\nI have a central dependent (or secondary as the LinearNodalConstraint calls it) node in the middle of the cylindrical boundary, with all the nodes on the boundary acting as the independent (Primary) nodes. The weightings for all of the nodes are equal to 1/(# of nodes). Therefore the displacement at the dependent node should be.\n$$\\Sigma u_i w_i = u_{dependent}$$\nMy question is, if I use a DirichletBC to prescribe the displacement of the dependent node to 0, will that then force,\n$$\\Sigma u_i w_i = 0$$\nIt feels wrong to prescribe the displacement of a dependent node, that DOF seems like it would have to be removed twice from the system. MOOSE will happily solve the problem, but I don't know what it is doing behind the scenes and whether it is at all what I am actually trying to do.\nI have also tried using a lagrange multiplier approach to constraint the average displacement but the extra lagrange multiplier variables made preconditioning a pain.\nAny help or insight is greatly appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/28945",
          "updatedAt": "2024-11-05T10:22:50Z",
          "publishedAt": "2024-10-28T13:35:41Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@lindsayad",
                  "url": "https://github.com/idaholab/moose/discussions/28945#discussioncomment-11078867",
                  "updatedAt": "2024-10-28T19:15:28Z",
                  "publishedAt": "2024-10-28T19:15:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "TheBEllis"
                  },
                  "bodyText": "Since I posted this I have become aware that constraining the dependent node is a no go.",
                  "url": "https://github.com/idaholab/moose/discussions/28945#discussioncomment-11153078",
                  "updatedAt": "2024-11-05T10:22:51Z",
                  "publishedAt": "2024-11-05T10:22:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Apply velocity boundary condition in an impact problem.",
          "author": {
            "login": "zuckarm"
          },
          "bodyText": "hi all,\ni wanted to know what are the different methods i can use to apply a velocity boundary condition to a particular boundary in the domain?\nso far i am aware of PresetVelocity as one option.",
          "url": "https://github.com/idaholab/moose/discussions/28942",
          "updatedAt": "2024-11-05T05:50:06Z",
          "publishedAt": "2024-10-28T05:52:16Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can use DirichletBCs too. It depends on the rest of the simulation setup. Are you using the Dynamic Solid Mechanics Physics?",
                  "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11081771",
                  "updatedAt": "2024-10-29T02:30:12Z",
                  "publishedAt": "2024-10-29T02:30:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zuckarm"
                          },
                          "bodyText": "Yes i am using DynamicStressDivergenceTensors and InterialForce Kernels, along with TestNewmarkTI AuxKernels for velocity and acceleration. Can you please show an example of prescribing velocity boundary condition using FunctionDirichletBC?",
                          "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11082520",
                          "updatedAt": "2024-10-29T04:44:28Z",
                          "publishedAt": "2024-10-29T04:44:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "There are multiple ways to setup the solid dynamics in MOOSE. IIRC, if you set it up similar to solid_mechanics/test/tests/capped_weak_plane/pull_and_shear.i then the way the InertialForce, velocity and acceleration is calculated you can apply a true initial condition. In this case the velocity is an AuxVariable that is calculated at timestep_end so if you set up  initial condition on the velocity and/or an auxkernel that executes on initial you should be able to apply this velocity IC.",
                          "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11086571",
                          "updatedAt": "2024-10-29T12:17:38Z",
                          "publishedAt": "2024-10-29T12:17:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zuckarm"
                          },
                          "bodyText": "hi @maxnezdyur\ni looked through the input file you mentioned and i had a few questions:\n\n\ni have a ramped velocity boundary condition which is acting throughout the simulation time. is it possible to define this ramped function and then use it in an AuxKernel defined for velocity?\n\n\nThe AuxKernels for velocity and acceleration are of the Newmark type. but i am interested in explicit time integration. what other AuxKernels can i use?\n\n\nI am ultimately trying to solve a coupled problem: dynamic solid mechanics + phase field fracture model. so far, i have not seen any such type of problems solved in MOOSE. could you direct me to any such tutorials, if there are any?\n\n\nthanks",
                          "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11095305",
                          "updatedAt": "2024-10-30T04:45:52Z",
                          "publishedAt": "2024-10-30T04:45:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Well first I misread you initial problem statement. For impact problems, I am used to IC on velocity so that's why I focused on IC so much. Let me answer your question this time!\n\nIf you use PresetVelocity BC it has a function option, so that allows you to presibe the velocity as a function from the start.\nSince you don't need to set IC (aka they are set to 0) then don't use the auxkernels I sent you before and go back to what you first had.\nI think the best resource for what you want is in RACCOON, I don't know if they have any tutorials for solid dynamics but worth a look.",
                          "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11098642",
                          "updatedAt": "2024-10-30T10:29:16Z",
                          "publishedAt": "2024-10-30T10:29:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zuckarm"
                          },
                          "bodyText": "thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11150381",
                          "updatedAt": "2024-11-05T05:50:07Z",
                          "publishedAt": "2024-11-05T05:50:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Installing libmesh fails due to missing tirpc",
          "author": {
            "login": "aturner-epcc"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nI am trying to install MOOSE from source on a CPU-based HPE Cray EX system (UK National Supercomputing Service, ARCHER2) and running into problems at the step to install libmesh. Following instructions at:\nhttps://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html\nI use:\nmodule load PrgEnv-gnu\nmodule load cray-python\nmodule load cmake\n\n./update_and_rebuild_libmesh.sh CC=cc CXX=CC FC=ftn\n\n(cc, 'CCandftnare the compiler wrappers within the Cray programming environement, equivalent tompif90` etc. on other clusters.)\nI get the following error:\nchecking for built-in XDR support... no\nchecking for XDR support in /usr/include/tirpc... no\nconfigure: error: *** XDR was not found, but --enable-xdr-required was specified.\n\nIndeed, that path does not exist on the system:\nauser@ln03:|~> ls /usr/include/tirpc\nls: cannot access '/usr/include/tirpc': No such file or directory\n\nI found the source for libtirpc on the internet at: https://www.linuxfromscratch.org/blfs/view/svn/basicnet/libtirpc.html and installed it myself at: /work/z19/z19/auser/software/MOOSE/libtirpc using the same compilers I am using for libmessh (and MOOSE).\nI then added the following options to libmesh ./configure:\n--with-xdr-include=/work/z19/z19/auser/software/MOOSE/libtirpc/include/tirpc\n--with-xdr-libname=/work/z19/z19/auser/software/MOOSE/libtirpc/lib/libtirpc.so\n\nretrying the configure gives:\nchecking for XDR support in /work/z19/z19/auser/software/MOOSE/libtirpc/include/tirpc... no\nconfigure: error: *** XDR was not found, but --enable-xdr-required was specified.\n\nAny idea how I get past this issue?\n(Optional) code in question / simulation log / errors\nNo response\nEncountering Errors? Please include diagnostic output\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/28924",
          "updatedAt": "2024-11-04T17:26:03Z",
          "publishedAt": "2024-10-24T08:10:46Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you install libtirpc-devel ?\nUsually the cluster administrators will do that one for you",
                  "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11037914",
                  "updatedAt": "2024-10-24T08:13:56Z",
                  "publishedAt": "2024-10-24T08:13:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aturner-epcc"
                          },
                          "bodyText": "Thanks for the quick reply, much appreciated. System adminstrators will not generally change the login node image or install dev packages for requirements for individual user software (as that way madness lies, you could end up having to install extra things all the time as root when your service has over 3000 users as ARCHER2 does). Starting expectation is that dependencies can be satified in user space. Is there no way of satisfying this dependency from a user space install?\nI see I could also install it using Spack:\nhttps://packages.spack.io/package.html?name=libtirpc\nbut I assume this would be the same as my manual install. Why can't libmesh use an install of libtirpc that has not been installed by root?",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11038414",
                          "updatedAt": "2024-10-24T08:51:32Z",
                          "publishedAt": "2024-10-24T08:50:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You most likely can, I just never have.\nMy question was mostly did you install the devel version of that library",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11038633",
                          "updatedAt": "2024-10-24T09:07:10Z",
                          "publishedAt": "2024-10-24T09:07:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aturner-epcc"
                          },
                          "bodyText": "Ah, sorry, misunderstood! My local libtirpc install was from source so includes all headers and library files:\nauser@ln04:/work/z19/z19/auser/software/MOOSE> ls libtirpc\netc  include  lib  share\nauser@ln04:/work/z19/z19/auser/software/MOOSE> ls libtirpc/lib/\nlibtirpc.la  libtirpc.so  libtirpc.so.3  libtirpc.so.3.0.0  pkgconfig\nauser@ln04:/work/z19/z19/auser/software/MOOSE> ls libtirpc/include/tirpc/\nnetconfig.h  rpc  rpcsvc",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11038923",
                          "updatedAt": "2024-10-24T09:35:26Z",
                          "publishedAt": "2024-10-24T09:35:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@roystgnr it seems xdr is still missing. Is there another library we should be installing?",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11039910",
                          "updatedAt": "2024-10-24T11:15:53Z",
                          "publishedAt": "2024-10-24T11:15:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you just want to get moving you can modify update_and_rebuild_libmesh to remove the need for xdr. This won't affect anything in moose iirc (since we switched to ascii checkpoint)",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11039928",
                          "updatedAt": "2024-10-24T11:17:18Z",
                          "publishedAt": "2024-10-24T11:17:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "In the future posting config.log would be helpful so we can see exactly why something isn't being detected.\nThis time, though, it's unfortunately already clear.  From libmesh_optional_packages.m4, \"Note that we currently do not provide a way to specify a library PATH, but that could potentially be added.\"  The --with-xdr-libname=foorpc lets you try to link to libfoorpc.so instead of libtirpc.so if you have a different third-party RPC library, but for some reason we seem to be still assuming that the library is in your libs path already.\nYou can try --with-xdr-include=/work/z19/z19/auser/software/MOOSE/libtirpc/include/tirpc LIBS='-L /work/z19/z19/auser/software/MOOSE/libtirpc/lib/ -Wl,-rpath -Wl,/work/z19/z19/auser/software/MOOSE/libtirpc/lib/' (assuming those flags work for your compiler and linker; looks like your OS is SUSE-based so probably?)\nI'll see if I can fix it in libMesh but it'll be a few weeks until that gets downstream to MOOSE.  In the meantime I'd also agree that (if my LIBS hack doesn't work) just disabling binary XDR is a decent workaround.  IMHO .xda.gz has always been a strictly better option.",
                  "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11043064",
                  "updatedAt": "2024-10-24T16:06:26Z",
                  "publishedAt": "2024-10-24T16:06:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aturner-epcc"
                          },
                          "bodyText": "@roystgnr @GiudGiud Thanks both for the helpful suggestions. For the moment, I have gone with disablign XDR support. If it turns out that is critical for people then I may revisit this.",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11049630",
                          "updatedAt": "2024-10-25T08:08:19Z",
                          "publishedAt": "2024-10-25T08:08:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sounds good thanks for letting us know.",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11081818",
                          "updatedAt": "2024-10-29T02:39:43Z",
                          "publishedAt": "2024-10-29T02:39:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "The configure option you need, in libMesh/libmesh#3985, just went into libMesh.  We should have it available in MOOSE in a week or two.",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11145438",
                          "updatedAt": "2024-11-04T17:26:04Z",
                          "publishedAt": "2024-11-04T17:26:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fullupwind about conservative like-advection",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear MOOSE Developers.\nI am solving this problem:\n$\\frac{\\partial p}{\\partial t}+\\nabla\u2022[(1-p)p\\overrightarrow{v}-\\nu\\nabla p]=0$\nin which $p$ is variable, $\\overrightarrow{v}$ is velocity about temperature, $\\nu$ is a diffusion coefficient.\nI would like to creat Fulupwind kernel to compute $\\nabla\u2022(1-p)p\\overrightarrow{v}$, and there is ConservativeAdvection and a disscusion.\nTo be more comprehensive, I paste all the code below\n#pragma once\n#include \"Kernel.h\"\n\n/*\nadcection-diffusion of pores\nthis is advection part\n$\\bigtriangledown \\dot [(1 - p) p \\vec{v}]$\n*/\n\nclass PoreAdvection : public Kernel\n{\npublic:\n  PoreAdvection(const InputParameters & parameters);\n\n  static InputParameters validParams();\n\nprotected:\n  virtual Real computeQpResidual() override;\n  virtual Real computeQpJacobian() override;\n  virtual void computeResidual() override;\n  virtual void computeJacobian() override;\n  RealVectorValue velocity() const; // m/s\n\n  const enum class UpwindType { none, full } _upwinding;\n  enum class JacRes\n  {\n    CALCULATE_RESIDUAL = 0,\n    CALCULATE_JACOBIAN = 1\n  };\n  const VariableValue & _u_nodal;\n  std::vector<bool> _upwind_node;\n  std::vector<Real> _dtotal_mass_out;\n\nprivate:\n  const VariableValue & _temperature;\n  const VariableGradient & _temperature_grad;\n  const VariableValue & _plutonium_concentration;\n  Real negSpeedQp() const;\n  void fullUpwind(JacRes res_or_jac);\n};\n#include \"PoreAdvection.h\"\n\nregisterMooseObject(\"MiracleApp\", PoreAdvection);\n\nInputParameters\nPoreAdvection::validParams()\n{\n  InputParameters params = Kernel::validParams();\n  params.addRequiredCoupledVar(\"temperature\", \"the MOX temperature in K\");\n  params.addCoupledVar(\"plutonium_concentration\", \"the plutonium concentration in range 0 - 1\");\n  MooseEnum upwinding(\"none full\", \"none\");\n  params.addParam<MooseEnum>(\"upwinding\", upwinding, \"the upwinding type\");\n\n  return params;\n}\n\nPoreAdvection::PoreAdvection(const InputParameters & parameters)\n  : Kernel(parameters),\n    _temperature(coupledValue(\"temperature\")),\n    _temperature_grad(coupledGradient(\"temperature\")),\n    _plutonium_concentration(coupledValue(\"plutonium_concentration\")),\n    _upwinding(getParam<MooseEnum>(\"upwinding\").getEnum<UpwindType>()),\n    _u_nodal(_var.dofValues()),\n    _upwind_node(0),\n    _dtotal_mass_out(0)\n{\n}\n\nRealVectorValue\nPoreAdvection::velocity() const\n{\n  RealVectorValue pore_grad = 0; //[K/m]\n  if (_plutonium_concentration[_qp] == 0)\n    pore_grad = 4 * _temperature_grad[_qp];\n  else // MOX\n    pore_grad = 5 * _temperature_grad[_qp];\n\n  Real molecules_volume = 0;              //[m^3]\n  if (_plutonium_concentration[_qp] == 0) // from THE KINETICS OF PORE MOVEMENT IN UOz FUEL RODS\n  {\n    molecules_volume =\n        6.023e23 * 270e-3 /\n        (1e3 * 10.97 /\n         (0.998 + 6.395e-6 * _temperature[_qp] + 3.543e-9 * std::pow(_temperature[_qp], 2) +\n          3e-12 * std::pow(_temperature[_qp], 3)));\n  }\n  else // MOX\n  {\n    Real puo2_mole_fraction =\n        _plutonium_concentration[_qp] / 274. /\n        (_plutonium_concentration[_qp] / 274. + (1 - _plutonium_concentration[_qp] / 270.));\n    Real uo2_mole_fraction =\n        (1 - _plutonium_concentration[_qp]) / 270. /\n        (_plutonium_concentration[_qp] / 274. + (1 - _plutonium_concentration[_qp]) / 270.);\n    molecules_volume =\n        0.25 * std::pow(puo2_mole_fraction * 5.396e-10 + uo2_mole_fraction * 5.470e-10, 3);\n  }\n\n  Real fuel_number_density = 5e17;   //[m^-3]\n  Real gas_number_density = 2.46e25; //[m^-3]\n  Real equivalent_mass = 1 / ((1 / 28.e-3 + 1 / 270e-3) * 6.023e23);//[kg]\n  Real diffusion_coeff =\n      3. / 8. * 1. /\n      (libMesh::pi * (fuel_number_density + gas_number_density) * std::pow(4.33e-10, 2)) *\n      std::sqrt(libMesh::pi * Boltzmann_constant * _temperature[_qp] / (2 *\n equivalent_mass));//[m^2/s]\n\n  RealVectorValue velocity = molecules_volume * diffusion_coeff * molecules_volume_dT * pore_grad;\n  Real universal_gas_constant = 8.31446261815324; //[J/mol/K]\n  Real Boltzmann_constant = 1.380649e-23;         //[J/K]\n  Real Avogadro_constant = 6.02214179e23;         //[molecules/mol]\n  Real corros_section_avg = 3e-10;                //[m^2]\n  Real uo2_molecules = 5e17;                      //[molecules/m^3]\n  Real He_molecules = 2.46e25;                    //[molecules/m^3]\n  Real He_molar = 4.0026020e-3;                   //[kg/mol]\n  Real uo2_molar = 270.03e-3;                     //[kg/mol]\n  Real diffusion_coeff =\n      std::sqrt(8 * universal_gas_constant * _temperature[_qp] / libMesh::pi) /\n      (3 * libMesh::pi * std::pow(corros_section_avg, 2) * (He_molecules + uo2_molecules)) *\n      std::sqrt((He_molar + uo2_molar) / (He_molar * uo2_molar)); //[m^2/s]\n  Real pre_factor_pressure = 0;\n  Real vaporization = 0;\n\n  if (_temperature[_qp] < 2000)\n  {\n    pre_factor_pressure = 0.1 * std::exp(33.785);\n    vaporization = 5.98e5;\n  }\n  else if (_temperature[_qp] < 2200)\n  {\n    pre_factor_pressure = 0.1 * std::exp(34.107);\n    vaporization = 6.17e5;\n  }\n  else\n  {\n    pre_factor_pressure = 0.1 * std::exp(35.813);\n    vaporization = 6.35e5;\n  }\n  Real vapour_pressure =\n      pre_factor_pressure * std::exp(-vaporization / universal_gas_constant / _temperature[_qp]);\n\n  // transport velocity in SI [m/s]\n  Real uo2_density =\n      1e3 * 10.97 /\n      (0.988 + 6.395e-6 * _temperature[_qp] + 3.543e-9 * std::pow(_temperature[_qp], 2) +\n       3e-12 * std::pow(_temperature[_qp], 3)); //[kg/m^3]\n  // material_flow = -D/kT *dp  velocity = -material_flow * \\omega\n  RealVectorValue material_flow = -diffusion_coeff / (Boltzmann_constant * _temperature[_qp]) *\n                                  vapour_pressure * vaporization /\n                                  (universal_gas_constant * std::pow(_temperature[_qp], 2)) * 4 *\n                                  _temperature_grad[_qp]; //[1/m^2s])\n\n  Real molecular_volume_uo2 = uo2_molar / (uo2_density * Avogadro_constant); //[m^3]\n  RealVectorValue velocity = -material_flow * molecular_volume_uo2;\n\n  RealVectorValue velocity_sens =\n      5.006e-12 *\n      (0.988 + 6.395e-6 * _temperature[_qp] + 3.543e-9 * std::pow(_temperature[_qp], 2) +\n       3e-12 * std::pow(_temperature[_qp], 3)) *\n      std::pow(_temperature[_qp], -2.5) * vaporization * vapour_pressure * _temperature_grad[_qp];\n  return velocity_sens;\n}\n\nReal\nPoreAdvection::computeQpResidual()\n{\n  return -_grad_test[_i][_qp] * (_u[_qp] - _u[_qp] * _u[_qp]) * velocity();\n}\n\nReal\nPoreAdvection::computeQpJacobian()\n{\n  return -_grad_test[_i][_qp] * (_phi[_j][_qp] - 2 * _u[_qp] * _phi[_j][_qp]) * velocity();\n}\n\nReal\nPoreAdvection::negSpeedQp() const\n{\n  return -_grad_test[_i][_qp] * velocity();\n}\n\nvoid\nPoreAdvection::computeResidual()\n{\n  switch (_upwinding)\n  {\n    case UpwindType::none:\n      Kernel::computeResidual();\n      break;\n    case UpwindType::full:\n      fullUpwind(JacRes::CALCULATE_RESIDUAL);\n      break;\n  }\n}\n\nvoid\nPoreAdvection::computeJacobian()\n{\n  switch (_upwinding)\n  {\n    case UpwindType::none:\n      Kernel::computeJacobian();\n      break;\n\n    case UpwindType::full:\n      fullUpwind(JacRes::CALCULATE_JACOBIAN);\n      break;\n  }\n}\n\nvoid\nPoreAdvection::fullUpwind(JacRes res_or_jac)\n{\n  // The number of nodes in the element\n  const unsigned int num_nodes = _test.size();\n\n  // Even if we are computing the Jacobian we still need to compute the outflow from each node to\n  // see which nodes are upwind and which are downwind\n  prepareVectorTag(_assembly, _var.number());\n\n  if (res_or_jac == JacRes::CALCULATE_JACOBIAN)\n    prepareMatrixTag(_assembly, _var.number(), _var.number());\n\n  // Compute the outflux from each node and store in _local_re\n  // If _local_re is positive at the node, mass (or whatever the Variable represents) is flowing out\n  // of the node\n  _upwind_node.resize(num_nodes);\n  for (_i = 0; _i < num_nodes; ++_i)\n  {\n    for (_qp = 0; _qp < _qrule->n_points(); _qp++)\n      _local_re(_i) += _JxW[_qp] * _coord[_qp] * negSpeedQp();\n    _upwind_node[_i] = (_local_re(_i) >= 0.0);\n  }\n\n  // Variables used to ensure mass conservation\n  Real total_mass_out = 0.0;\n  Real total_in = 0.0;\n  if (res_or_jac == JacRes::CALCULATE_JACOBIAN)\n    _dtotal_mass_out.assign(num_nodes, 0.0);\n\n  for (unsigned int n = 0; n < num_nodes; ++n)\n  {\n    if (_upwind_node[n])\n    {\n      if (res_or_jac == JacRes::CALCULATE_JACOBIAN)\n      {\n        if (_test.size() == _phi.size())\n          /* u at node=n depends only on the u at node=n, by construction.  For\n           * linear-lagrange variables, this means that Jacobian entries involving the derivative\n           * will only be nonzero for derivatives wrt variable at node=n.  Hence the\n           * (n, n) in the line below.  The above \"if\" statement catches other variable types\n           * (eg constant monomials)\n           */\n          _local_ke(n, n) += _local_re(n) * (1.0 - 2.0 * _u_nodal[n]);\n\n        _dtotal_mass_out[n] += _local_ke(n, n);\n      }\n      _local_re(n) *= _u_nodal[n] * (1.0 - _u_nodal[n]);\n      total_mass_out += _local_re(n);\n    }\n    else                        // downwind node\n      total_in -= _local_re(n); // note the -= means the result is positive\n  }\n\n  // Conserve mass over all phases by proportioning the total_mass_out mass to the inflow nodes,\n  // weighted by their local_re values\n  for (unsigned int n = 0; n < num_nodes; ++n)\n  {\n    if (!_upwind_node[n]) // downwind node\n    {\n      if (res_or_jac == JacRes::CALCULATE_JACOBIAN)\n        for (_j = 0; _j < _phi.size(); _j++)\n        {\n          Real factor = 1.0;\n          if (_j < num_nodes && _upwind_node[_j])\n            factor = (1.0 - 2.0 * _u_nodal[_j]);\n          _local_ke(n, _j) += _local_re(n) * _dtotal_mass_out[_j] * factor / total_in;\n        }\n      _local_re(n) *= total_mass_out / total_in;\n    }\n  }\n\n  // Add the result to the residual and jacobian\n  if (res_or_jac == JacRes::CALCULATE_RESIDUAL)\n  {\n    accumulateTaggedLocalResidual();\n\n    if (_has_save_in)\n    {\n      Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n      for (const auto & var : _save_in)\n        var->sys().solution().add_vector(_local_re, var->dofIndices());\n    }\n  }\n\n  if (res_or_jac == JacRes::CALCULATE_JACOBIAN)\n  {\n    accumulateTaggedLocalMatrix();\n\n    if (_has_diag_save_in)\n    {\n      unsigned int rows = _local_ke.m();\n      DenseVector<Number> diag(rows);\n      for (unsigned int i = 0; i < rows; i++)\n        diag(i) = _local_ke(i, i);\n\n      Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n      for (const auto & var : _diag_save_in)\n        var->sys().solution().add_vector(diag, var->dofIndices());\n    }\n  }\n}\nwhen I run this, I find the results are more oscillation and instability.\n\n\nHow did I fix this problem? I am not very familiar with upwind finite element.\nThank you very much in advance for your help.\nZhaohao Wang",
          "url": "https://github.com/idaholab/moose/discussions/28995",
          "updatedAt": "2024-11-04T13:52:41Z",
          "publishedAt": "2024-11-04T09:43:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI am not that familiar either. The kernel you listed is a good reference.\nI would attempt to separate this kernel in 3 parts and only upwind one of them at a time to see which one is causing the oscillations\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28995#discussioncomment-11142619",
                  "updatedAt": "2024-11-04T13:26:03Z",
                  "publishedAt": "2024-11-04T13:26:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Yes, I also thought this method. Three part is good. I also read the Ref in the ConservativeAdvection, Umm, hard to understand the method. So does anyone know of a way to do this? I don't want my code to be too verbose.",
                          "url": "https://github.com/idaholab/moose/discussions/28995#discussioncomment-11142910",
                          "updatedAt": "2024-11-04T13:52:41Z",
                          "publishedAt": "2024-11-04T13:52:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "What is the default operation precision in MOOSE?",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nWhat is the default operation precision in MOOSE?\nHow many digits after the decimal point?\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/21799",
          "updatedAt": "2024-11-04T09:19:10Z",
          "publishedAt": "2022-08-08T15:37:50Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe use double precision for floating point numbers.\n\nHow many digits after the decimal point?\n\nIt's not that simple. Very grossly simplifying, 16, but please read more about this topic. (google floating point precision)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-3351249",
                  "updatedAt": "2022-08-08T16:56:00Z",
                  "publishedAt": "2022-08-08T16:55:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ahzeeshan"
                  },
                  "bodyText": "In my solution, I have one variable that can take values from 1e16 to 1 and another that can vary from 1e-33 to 1. How can I increase the moose precision during installation to accommodate these variables?",
                  "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11131681",
                  "updatedAt": "2024-11-02T22:45:26Z",
                  "publishedAt": "2024-11-02T22:45:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nYou'll need to start by modifying the petsc install to increase precision there\nhttps://petsc.org/release/faq/#can-i-run-petsc-with-extended-precision\nThen set LIBMESH_DEFAULT_QUADRUPLE_PRECISION when compiling libmesh.\nThe MOOSE should adapt to the precision chosen in libmesh.\nBut this is not tested, so you'll need to adapt the code in a few places to get it to compile. It should not be too difficult however.",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11131714",
                          "updatedAt": "2024-11-02T22:54:17Z",
                          "publishedAt": "2024-11-02T22:54:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would first try to get the simulations working with the double precision. It's not because the variable values can vary over a large range that:\n\nall of the range is utilized\neven if all of the range is utilized, it can very well be that the matrix is still well conditioned and you get a workable solution",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11131721",
                          "updatedAt": "2024-11-02T22:55:35Z",
                          "publishedAt": "2024-11-02T22:55:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ahzeeshan"
                          },
                          "bodyText": "All of the variable range is utilized because the variable will have two values at the boundaries.\nI have tried running it with default precision but get convergence problems. The code has a parameter V that can be varied - this parameter determines the range of values of the two variables. When V is low, the range of variables is smaller and I am able to get convergence. When I increase V, the solution does not converge. This is why I think it might have to do with precision.",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11132486",
                          "updatedAt": "2024-11-03T04:36:10Z",
                          "publishedAt": "2024-11-03T04:36:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It could be that.\nOr it could be a conditioning issue. See the troubleshooting failed solves instructions to see how to get the condition number of the matrix",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11132579",
                          "updatedAt": "2024-11-03T05:09:25Z",
                          "publishedAt": "2024-11-03T05:09:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ahzeeshan"
                          },
                          "bodyText": "Thanks for the suggestion. You are right, the condition number is very large - it becomes >1e11 after the first 3-4 non-linear iterations. I am using automatic scaling for all variables. Since scaling didn't help, is there any other approach to solve this issue? Will increasing precision help?",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11138390",
                          "updatedAt": "2024-11-04T03:53:13Z",
                          "publishedAt": "2024-11-04T03:53:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would try manual scaling as that can be more robust.\nThen you could split the domain with multiple variables that cover each different parts of the range of possible values, tied together using interface kernels, so that you can apply scaling independently to each part of the range",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11140191",
                          "updatedAt": "2024-11-04T09:19:10Z",
                          "publishedAt": "2024-11-04T09:19:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Small time steps",
          "author": {
            "login": "ashishdhole"
          },
          "bodyText": "Hello!\nI have made this kernel where if g = 0 then it is same as ACGrGrPoly (Grain Growth Kernel). when I compare the two I see different values and also the timesteps are very small by using this kernel. Is there anything I am missing. Any suggestion will be appreciated. I am struggling to get this thing done. but the time steps are so small that it is taking more than 5-6 days to finish half of the simulation.\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nRealGradient\nAdvanceFrictionPressure::nablaLPsi()\n{\n  // sum is the product rule gradient \\f$ \\nabla (L\\psi) \\f$\n  RealGradient sum = _L[_qp] * _grad_test[_i][_qp];\n\n  return sum;\n}\n\nRealGradient\nAdvanceFrictionPressure::kappaNablaLPsi()\n{\n  return _kappa[_qp] * nablaLPsi();\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    return _L[_qp] * ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) -\n                      (3 * sgn * g * _sigma[_qp] * op * SumOPj));\n  }\n\n  return 0;\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    return _L[_qp] * ((_phi[_j][_qp] * (_mu[_qp] * (3.0 * op * op - 1.0 + 3 * SumOPj))) -\n                      (_phi[_j][_qp] * 3 * _sigma[_qp] * sgn * g * SumOPj));\n  }\n\n  return 0;\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPj = 0.0;\n  Real SumOPGj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      const Real dDFDOP =\n          _phi[_j][_qp] * ((_mu[_qp] * 2.0 * _gamma[_qp] * op * 2.0 * other_ops[i]) -\n                           sgn * ((3 * g * _sigma[_qp] * op)));\n\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return _L[_qp] * _test[_i][_qp] * dDFDOP;\n      else\n        return 0;\n    }\n\n  return 0;\n}\n\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/28797",
          "updatedAt": "2024-11-03T19:56:44Z",
          "publishedAt": "2024-10-07T10:52:22Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHave you run the Jacobian analyser to make sure the Jacobian is correct?\nhttps://mooseframework.inl.gov/moose/application_usage/failed_solves.html\nIf it s not correct that would make taking large time steps difficult",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10866977",
                  "updatedAt": "2024-10-07T12:26:11Z",
                  "publishedAt": "2024-10-07T12:26:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "You are right. The Jacobian seems to be wrong.\nRunning input with executable pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is wrong (off by 52.3 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.2 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 71.0 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 66.6 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.2 %)\n  (1,1) On-diagonal Jacobian is wrong (off by 50.8 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 72.2 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.0 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 71.0 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 72.2 %)\n  (2,2) On-diagonal Jacobian is wrong (off by 46.0 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 67.4 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 66.6 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 67.4 %)\n  (3,3) On-diagonal Jacobian is wrong (off by 43.8 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is inexact (off by 4.411 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 64.1 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.4 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.0 %)\n  (1,1) On-diagonal Jacobian is wrong (off by 27.3 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 68.3 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.5 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 64.0 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.3 %)\n  (2,2) On-diagonal Jacobian is inexact (off by 2.146 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.3 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 65.4 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.5 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 65.3 %)\n  (3,3) On-diagonal Jacobian is slightly off (by 0.000113 %)\n\nBut in the code it looks fine. Can you suggest me what is wrong in the jacobian here?\nThank you",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10871980",
                          "updatedAt": "2024-10-07T18:47:37Z",
                          "publishedAt": "2024-10-07T18:47:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you must have forgotten to include off diagonal terms in your custom kernel.\nyou could start your kernels again (write a new set, and preface the name with AD) using automatic differentiation and automartically the Jacobian would be correct",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10872063",
                          "updatedAt": "2024-10-07T18:57:02Z",
                          "publishedAt": "2024-10-07T18:57:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "ok let me try that.\nThank you very much. I will get back to you.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10872176",
                          "updatedAt": "2024-10-07T19:09:44Z",
                          "publishedAt": "2024-10-07T19:09:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "One small doubt. Do I have to define my variables and properties with AD As shown below?\nyou said\nprotected:\n  virtual ADReal computeQpResidual();\n  const ADVariableValue & _g;\n  const unsigned int _op_num;\n  const std::vector<const ADVariableValue *> _vals;\n  const ADMaterialProperty<Real> & _mu;\n  const ADMaterialProperty<Real> & _sigma;\n  const ADMaterialProperty<Real> & _gamma;\n  /// Mobility\n  const ADMaterialProperty<Real> & _prop_L;\n  /// Mobility property name\n  const MaterialPropertyName & _name_L;\n\n  /// Interfacial parameter\n  const ADMaterialProperty<Real> & _kappa;\n\nyou said\n\nwrite a new set, and preface the name with AD\n\nHere does name means Kernel name?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10873169",
                          "updatedAt": "2024-10-07T21:11:36Z",
                          "publishedAt": "2024-10-07T21:11:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the name is AdvanceFrictionPressure\nyes you would need to use every single property as ADMaterial properties\nif that is too much work, then implement computeQpOffDiagJacobian in your kernels instead",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10873200",
                          "updatedAt": "2024-10-07T21:16:22Z",
                          "publishedAt": "2024-10-07T21:16:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I have added an offdiagonaljacobian to my code\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    if (jvar == _vals_var[i])\n    {\n      // Derivative of Sumopj\n      const Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      const Real dSumOPGj = _phi[_j][_qp];\n      const Real dDFDOP =\n          (_mu[_qp] * 2.0 * _gamma[_qp] * op * dSumOPj) - (_sigma[_qp] * 3.0 * g * op * dSumOPGj);\n\n      // get the coupled variable jvar is referring to\n      const unsigned int cvar = mapJvarToCvar(jvar);\n\n      // dsum is the derivative \\f$ \\frac\\partial{\\partial \\eta} \\left( \\nabla (L\\psi) \\right) \\f$\n      RealGradient dsum =\n          ((*_dkappadarg[cvar])[_qp] * _L[_qp] + _kappa[_qp] * (*_dLdarg[cvar])[_qp]) *\n          _phi[_j][_qp] * _grad_test[_i][_qp];\n      if (total_abs > friction_energy_abs)\n      {\n        return (_L[_qp] * _test[_i][_qp] * dDFDOP) + _grad_u[_qp] * dsum;\n      }\n      else\n      {\n        return 0;\n      }\n    }\n  }\n\n  return 0.0;\n}\n\nbut I am still getting\nRunning input with executable pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is wrong (off by 45.0 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.2 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 71.0 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 66.6 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.2 %)\n  (1,1) On-diagonal Jacobian is wrong (off by 43.8 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 72.2 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.0 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 71.0 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 72.2 %)\n  (2,2) On-diagonal Jacobian is wrong (off by 39.9 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 67.4 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 66.6 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 67.4 %)\n  (3,3) On-diagonal Jacobian is wrong (off by 36.2 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is inexact (off by 4.804 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 64.2 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.8 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.0 %)\n  (1,1) On-diagonal Jacobian is wrong (off by 25.7 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 69.7 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.6 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 64.2 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 69.7 %)\n  (2,2) On-diagonal Jacobian is inexact (off by 2.328 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.6 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 65.8 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.6 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 65.6 %)\n\nwhat is wrong with my offdiagonal jacobian. I am trying to add the jacobian of ACGrGrPoly and ACInterface.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10875112",
                          "updatedAt": "2024-10-08T03:42:33Z",
                          "publishedAt": "2024-10-08T03:42:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you remove your kernel, do you get correct off-diagonals ? just checking",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10875134",
                          "updatedAt": "2024-10-08T03:47:28Z",
                          "publishedAt": "2024-10-08T03:47:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "This is basically same as ACGrGrPoly\nReal\nAdvanceFrictionPressure::AdvanceFrictionPressure::computeQpResidual()\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  // Sum all other order parameters\n  Real SumOPj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n    SumOPj += other_ops[i] * other_ops[i];\n\n  return _L[_qp] * _mu[_qp] * (op * op * op - op + 2.0 * _gamma[_qp] * op * SumOPj);\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  // Sum all other order parameters\n  Real SumOPj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n    SumOPj += other_ops[i] * other_ops[i];\n\n  return _L[_qp] * _mu[_qp] * (_phi[_j][_qp] * (3.0 * op * op - 1.0 + 2.0 * _gamma[_qp] * SumOPj));\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      // Derivative of Sumopj\n      const Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      const Real dDFDOP = _mu[_qp] * 2.0 * _gamma[_qp] * op * dSumOPj;\n\n      return _L[_qp] * _test[_i][_qp] * dDFDOP;\n    }\n\n  return 0.0;\n}\n\nI am getting\nRunning input with executable pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.2 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 71.0 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 66.6 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.2 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 72.2 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.0 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 71.0 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 72.2 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 67.4 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 66.6 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 67.4 %)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 64.2 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.8 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.0 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 69.7 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.6 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 64.2 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 69.7 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.6 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 65.8 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.6 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 65.6 %)\n\nBut if I run the simulation with actual ACGrGrPoly that is available in moose\nI get this\nRunning input with executable pfubc-opt ...\n\nNo errors detected. :-)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000688 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001599 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001263 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.004878 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000382 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001707 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001477 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000295 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000132 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000076 %)",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10875187",
                          "updatedAt": "2024-10-08T03:57:42Z",
                          "publishedAt": "2024-10-08T03:57:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "well I think this is pretty clear. Something is wrong in your off-diagonals still.\nIt's clearly for the coupling between grains.\nThere seems to be this 2/3rd factor involved, as if 2/3 of the term was missing",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10875319",
                          "updatedAt": "2024-10-08T04:26:53Z",
                          "publishedAt": "2024-10-08T04:26:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "does _gamma depend on the other grain concentrations? what about _mu and _L?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10875332",
                          "updatedAt": "2024-10-08T04:29:58Z",
                          "publishedAt": "2024-10-08T04:29:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello,\nSo meanwhile I made another Kernel that is derived from ACGrGrPoly (Another grain growth kernel in the MOOSE).\nfollowing is the kernel I made (FPACGrGrPoly)\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"FPACGrGrPoly.h\"\n#include \"Kernel.h\"\n\nregisterMooseObject(\"PhaseFieldApp\", FPACGrGrPoly);\n\nInputParameters\nFPACGrGrPoly::validParams()\n{\n  InputParameters params = ACGrGrBase::validParams();\n  params.addClassDescription(\"Grain-Boundary model poly-crystalline interface Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  params.addCoupledVar(\"g\", 0.0, \"Friction pressure\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  return params;\n}\n\nFPACGrGrPoly::FPACGrGrPoly(const InputParameters & parameters)\n  : ACGrGrBase(parameters),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\"))\n{\n}\n\nReal\nFPACGrGrPoly::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nFPACGrGrPoly::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nReal\nFPACGrGrPoly::computeDFDOP(PFFunctionType type)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  // Calculate either the residual or Jacobian of the grain growth free energy\n  switch (type)\n  {\n    case Residual:\n    {\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return (_mu[_qp] * (op * op * op - op + 2.0 * _gamma[_qp] * op * SumOPj)) -\n               (sgn * _sigma[_qp] * 3 * g * op * SumOPGj);\n      else\n        return 0;\n    }\n\n    case Jacobian:\n    {\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return (_mu[_qp] * (_phi[_j][_qp] * (3.0 * op * op - 1.0 + 2.0 * _gamma[_qp] * SumOPj))) -\n               (sgn * _phi[_j][_qp] * _sigma[_qp] * 3 * g * SumOPGj);\n      else\n        return 0;\n    }\n\n    default:\n      mooseError(\"Invalid type passed in\");\n  }\n}\n\nReal\nFPACGrGrPoly::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPj = 0.0;\n  Real SumOPGj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      const Real dDFDOP =\n          _phi[_j][_qp] * ((_mu[_qp] * 2.0 * _gamma[_qp] * op * 2.0 * other_ops[i]) -\n                           sgn * ((3 * g * _sigma[_qp] * op)));\n\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return _L[_qp] * _test[_i][_qp] * dDFDOP;\n      else\n        return 0;\n    }\n\n  return 0;\n}\n\nIt is also there in the repository. Now the only issue I am facing here is this term\nReal total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n\nIf I introduce any term related to it say it is sgn variable or the if() condition inside Residual and Jacobian, I am getting segmentation fault. I tried many times to find the traces of error but not able to get any resolution. Although when I don't use anything related to 'total' the code works fine. I think\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]\n\nThis particular variables are the problem. Somehow the kernel is not able to take it well. If you can suggest me anything to make it work it will be great.\nI have added all the files to the repository.\n(Note: to run FPACGrGrPoly a small change in AdvanceFrictionPressureKernelAction is to be made. I have made a comment in this action file where the changes need to be made. )\nLooking forward to hearing from you.\nThank you.\nAshish",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10900828",
                  "updatedAt": "2024-10-10T07:41:47Z",
                  "publishedAt": "2024-10-10T07:41:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "didnt we go over this in another post?\nCan you please link it here so i can look if we had made some progress on this or if it was still an open question",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10903165",
                          "updatedAt": "2024-10-10T11:25:31Z",
                          "publishedAt": "2024-10-10T11:25:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "This is that post\n#28048\nBut it was not resolved and then I started working with different approach.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10906988",
                          "updatedAt": "2024-10-10T17:28:03Z",
                          "publishedAt": "2024-10-10T17:25:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "is this is what is causing issue\nKernelGrad\n\nDerive from this base class if your residual is of the form\n\n(\u2026,\u2207\u03c8i)\n(\u2026,\u2207\u03c8i\u200b)\n\ni.e. if the test function \u2207\u03c8i\u2207\u03c8i\u200b (_grad_test[_i][_qp]) can be factored out.\nDerived classes\n\nOverride\n\n    precomputeQpResidual() instead of computeQpResidual() (do not multiply by _grad_test[_i][_qp]).\n\n    precomputeQpJacobian() instead of computeQpJacobian() (do not multiply by _grad_test[_i][_qp])\n\n    computeOffDiagJacobian still has to be implemented as if deriving from Kernel.\n\nNote that precomputeQpResidual() and precomputeQpJacobian() return a RealGradient type. \n\nthe _grad_test[_i][_qp] is causing problem. I think I narrowed it down to this particular equation. Now we only have to figure out how to replace it or use it some other way.\nThank you",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10907726",
                          "updatedAt": "2024-10-10T18:55:31Z",
                          "publishedAt": "2024-10-10T18:55:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Hello,\nI am sorry to bother you like this, But were you able to see my code?\nJust for the reference I am using this paper to replicate the work.\n10.1088/0965-0393/20/6/065008\nLooking forward to hearing from you.\nThank you",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10909751",
                          "updatedAt": "2024-10-11T00:29:35Z",
                          "publishedAt": "2024-10-11T00:29:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont think the new kernel is derived from KernelGrad. In fact it is derived from an interface templated with KernelValue.\nThis is in itself a problem, because KernelValue multiplies the residual by _test[_qp] and you do not seem to be taking that into account in your kernel definition, as you multiply by grad_test[_qp]\nIf you need to multiply by grad_test due to the form of the equation, it looks like you will need to modify all the base classes of your new kernel",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910277",
                          "updatedAt": "2024-10-11T02:06:05Z",
                          "publishedAt": "2024-10-11T02:06:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Let's focus again on the issue for this post\nIn the computeQpOffJacobian, the last line I m pasting is wrong\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPj = 0.0;\n  Real SumOPGj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPj += other_ops[i];\n\nit should be\n SumOPGj += other_ops[i];\n\nwith this change, do you get a numerically correct Jacobian ?",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910296",
                  "updatedAt": "2024-10-11T02:10:00Z",
                  "publishedAt": "2024-10-11T02:09:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "No I have tried that. It shows jacobian off by 65%",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910308",
                          "updatedAt": "2024-10-11T02:11:56Z",
                          "publishedAt": "2024-10-11T02:11:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "well you still need to fix it.\nThe rest of the expression is wrong too\n      const Real dDFDOP =\n          _phi[_j][_qp] * ((_mu[_qp] * 2.0 * _gamma[_qp] * op * 2.0 * other_ops[i]) -\n                           sgn * ((3 * g * _sigma[_qp] * op)));\n\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return _L[_qp] * _test[_i][_qp] * dDFDOP;\n\nshould likely just be\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n          return _test[_i][_qp] * _phi[_j][_qp] * (_L[_qp] * _mu[_qp] * 3 * op -\n                                                                             3 * sgn * g * _sigma[_qp] * op);\n\n\nI might have made mistakes too, so feel free to re-derive it.\nI dont see why:\n\ngamma only comes in for the off diagonal of the Jacobian\nwhere the 2 * other_op is coming from ? there is no sum_OPj * sum_Opj term in the residual?\nwhy _test[_i][_qp] does not appear in the residual? This kernel is derived from the Kernel base class, not from KernelValue",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910380",
                          "updatedAt": "2024-10-11T02:29:40Z",
                          "publishedAt": "2024-10-11T02:25:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The rest of the expression is wrong too\n\nI have taken this equation from ACGrGrPoly.C\nReal\nACGrGrPoly::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      // Derivative of Sumopj\n      const Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      const Real dDFDOP = _mu[_qp] * 2.0 * _gamma[_qp] * op * dSumOPj;\n\n      return _L[_qp] * _test[_i][_qp] * dDFDOP;\n    }\n\n  return 0.0;\n}\n\nBecause the new term is only subtracted from this , I used the same format.\n\n\ngamma only comes in for the off diagonal of the Jacobian\n\n\ngamma is defined as materials' property and remain constant. in this case gamma = 1.5, that why I replaced 2*gamma = 3 in off diagonal. no other reason\n\n\nwhere the 2 * other_op is coming from ? there is no sum_OPj * sum_Opj term in the residual?\n\n\nin residual\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n   Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\nSo op is the variable that this kernel is acting upon, other_op is the coupled variable (Other order parameters other than op)0\n\"2*other_op\"  you are probably talking about in the off diagonal jacobian, where the residual is differentiated by other order paramater than op.\nin short 2*other_op is basically differentiating SumOPj wrt other_op,\ndSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\nsimilarly\ndSumOPGj = _phi[_j][_qp];\n(as there is only one other_op) in SumOPGj\n\n\nwhy _test[_i][_qp] does not appear in the residual? This kernel is derived from the Kernel base class, not from KernelValue\n\n\nI am not sure about this but my kernel is derived from ACGrGrPoly, and in that kernel, residual is not multiplied by _test[_i][_qp]\n.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910452",
                          "updatedAt": "2024-10-11T02:40:22Z",
                          "publishedAt": "2024-10-11T02:40:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910534",
                          "updatedAt": "2024-10-11T02:54:55Z",
                          "publishedAt": "2024-10-11T02:54:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "running with _test[_qp] in residual and jacobian I get\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is wrong (off by 30.8 %)\n\nKernel for variable 'gr1':\n  (1,1) On-diagonal Jacobian is wrong (off by 30.1 %)\n\nKernel for variable 'gr2':\n  (2,2) On-diagonal Jacobian is wrong (off by 26.7 %)\n\nKernel for variable 'gr3':\n  (3,3) On-diagonal Jacobian is wrong (off by 23.8 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is questionable (off by 7.98 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001379 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003005 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000703 %)\n\nKernel for variable 'gr1':\n  (1,1) On-diagonal Jacobian is questionable (off by 8.50 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.002580 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000827 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001760 %)\n  (2,2) On-diagonal Jacobian is inexact (off by 4.173 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000586 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000881 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.178644 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000943 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.007045 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.036686 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.410310 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003030 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.041288 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.125067 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.031103 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.046662 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.043043 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003851 %)\n\nGreat improvement but I think there is still something missing\nHere is the updated kernel for your reference\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nRealGradient\nAdvanceFrictionPressure::nablaLPsi()\n{\n  // sum is the product rule gradient \\f$ \\nabla (L\\psi) \\f$\n  RealGradient sum = _L[_qp] * _grad_test[_i][_qp];\n\n  return sum;\n}\n\nRealGradient\nAdvanceFrictionPressure::kappaNablaLPsi()\n{\n  return _kappa[_qp] * nablaLPsi();\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * (_kappa[_qp] * _grad_test[_i][_qp]);\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    return _L[_qp] * _test[_i][_qp] *\n           ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) -\n            (3 * sgn * g * _sigma[_qp] * op * SumOPj));\n  }\n\n  return 0;\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * (_kappa[_qp] * _grad_test[_i][_qp]);\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    return _L[_qp] * _test[_i][_qp] *\n           ((_phi[_j][_qp] * (_mu[_qp] * (3.0 * op * op - 1.0 + 3 * SumOPj))) -\n            (_phi[_j][_qp] * 3 * _sigma[_qp] * sgn * g * SumOPj));\n  }\n\n  return 0;\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPj = 0.0;\n  Real SumOPGj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * (_kappa[_qp] * _grad_test[_i][_qp]);\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return _L[_qp] * _test[_i][_qp] * _phi[_j][_qp] *\n               ((_mu[_qp] * 3.0 * op * 2.0 * other_ops[i]) - sgn * ((3 * g * _sigma[_qp] * op)));\n      else\n        return 0;\n    }\n\n  return 0;\n}\n\nI am sure I am missing something here.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910584",
                          "updatedAt": "2024-10-11T03:04:11Z",
                          "publishedAt": "2024-10-11T03:04:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok this explains a few things. I forgot that sum was quadratic.\nSo now the on diagonal must have mistakes.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910624",
                          "updatedAt": "2024-10-11T03:09:35Z",
                          "publishedAt": "2024-10-11T03:09:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Please make sure to update the repository. I ll check it tomorrow",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910641",
                          "updatedAt": "2024-10-11T03:11:18Z",
                          "publishedAt": "2024-10-11T03:11:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Sure. Thank you so much.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910643",
                          "updatedAt": "2024-10-11T03:12:18Z",
                          "publishedAt": "2024-10-11T03:12:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in your input file, did you make sure not to pass the variable of the kernel to the 'v' parameter?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10911138",
                          "updatedAt": "2024-10-11T04:50:32Z",
                          "publishedAt": "2024-10-11T04:50:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Yes. I think the AdvanceFrictionPressureKernelAction is taking care of that.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10911250",
                          "updatedAt": "2024-10-11T05:09:15Z",
                          "publishedAt": "2024-10-11T05:09:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello,\nyou were right about adding one by one the terms see where the problem is.\nI finally have it 99% done.\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  params.addParam<bool>(\"variable_L\",\n                        false,\n                        \"The mobility is a function of any MOOSE variable (if \"\n                        \"this is set to false L must be constant over the \"\n                        \"entire domain!)\");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _variable_L(getParam<bool>(\"variable_L\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _dLdop(getMaterialPropertyDerivative<Real>(\"mob_name\", _var.name())),\n    _d2Ldop2(getMaterialPropertyDerivative<Real>(\"mob_name\", _var.name(), _var.name())),\n    _dkappadop(getMaterialPropertyDerivative<Real>(\"kappa_name\", _var.name())),\n    _dLdarg(_n_args),\n    _d2Ldargdop(_n_args),\n    _d2Ldarg2(_n_args),\n    _dkappadarg(_n_args),\n    _gradarg(_n_args),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n  // Get mobility and kappa derivatives and coupled variable gradients\n  for (unsigned int i = 0; i < _n_args; ++i)\n  {\n    MooseVariable * ivar = _coupled_standard_moose_vars[i];\n    const VariableName iname = ivar->name();\n    if (iname == _var.name())\n    {\n      if (isCoupled(\"args\"))\n        paramError(\"args\",\n                   \"The kernel variable should not be specified in the coupled `args` parameter.\");\n      else\n        paramError(\"coupled_variables\",\n                   \"The kernel variable should not be specified in the coupled `coupled_variables` \"\n                   \"parameter.\");\n    }\n\n    _dLdarg[i] = &getMaterialPropertyDerivative<Real>(\"mob_name\", i);\n    _dkappadarg[i] = &getMaterialPropertyDerivative<Real>(\"kappa_name\", i);\n    _d2Ldargdop[i] = &getMaterialPropertyDerivative<Real>(\"mob_name\", iname, _var.name());\n\n    _gradarg[i] = &(ivar->gradSln());\n\n    _d2Ldarg2[i].resize(_n_args);\n    for (unsigned int j = 0; j < _n_args; ++j)\n      _d2Ldarg2[i][j] = &getMaterialPropertyDerivative<Real>(\"mob_name\", i, j);\n  }\n}\nvoid\nAdvanceFrictionPressure::initialSetup()\n{\n  validateCoupling<Real>(\"mob_name\");\n  validateCoupling<Real>(\"kappa_name\");\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_L[_qp] * (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj))) +\n               (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n  Real friction = _L[_qp] * 3 * _sigma[_qp] * op * SumOPGj;\n\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  // Real cond = 0;\n  // if (std::abs(total) > std::abs(friction))\n  //   cond = 1;\n\n  return (\n      (_test[_i][_qp] * (_L[_qp] * (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)))) -\n      (sgn * _test[_i][_qp] * _L[_qp] * 3 * _sigma[_qp] * g * op * SumOPGj) +\n      (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp])); // cond to be multiplied here\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_L[_qp] * (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj))) +\n               (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n  Real friction = _L[_qp] * 3 * _sigma[_qp] * op * SumOPGj;\n\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  // Real cond = 0;\n  // if (std::abs(total) > std::abs(friction))\n  //   cond = 1;\n\n  return ((_test[_i][_qp] *\n           (_L[_qp] * _phi[_j][_qp] * (_mu[_qp] * (3.0 * op * op - 1.0 + 3 * SumOPj)))) -\n          (sgn * _test[_i][_qp] * _L[_qp] * _phi[_j][_qp] * 3 * _sigma[_qp] * g * SumOPGj) +\n          (_grad_phi[_j][_qp] * _kappa[_qp] * _L[_qp] *\n           _grad_test[_i][_qp])); // cond to be multiplied here\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  const unsigned int cvar = mapJvarToCvar(jvar);\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    Real SumOPGj = 0.0;\n    Real SumOPj = 0.0;\n\n    for (unsigned int a = 0; a < _op_num; ++a)\n    {\n      SumOPj += other_ops[a] * other_ops[a];\n      SumOPGj += other_ops[a];\n    }\n\n    Real total = (_L[_qp] * (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj))) +\n                 (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n    Real friction = _L[_qp] * 3 * _sigma[_qp] * op * SumOPGj;\n\n    Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n    if (jvar == _vals_var[i])\n    {\n      const Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      const Real dSumOPGj = _phi[_j][_qp];\n\n      // Real cond = 0;\n      // if (std::abs(total) > std::abs(friction))\n      //   cond = 1;\n\n      const Real dDFDOP =\n          ((_mu[_qp] * 2.0 * _gamma[_qp] * op * dSumOPj) -\n           (sgn * 3 * _sigma[_qp] * g * op * dSumOPGj)); // cond to be multiplied here\n\n      return _L[_qp] * _test[_i][_qp] * dDFDOP;\n    }\n  }\n  return 0;\n}\n\nand jacobian debugger also says\nRunning input with executable ./pfubc-opt ...\n\nNo errors detected. :-)\n\nKernel for variable 'gr0':\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001899 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000302 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000355 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.002775 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000066 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.002453 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.002783 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000711 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.178644 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000945 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.007046 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.036677 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.410309 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003027 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.041293 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.125065 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.031111 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.046655 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.043043 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003850 %)\n\nBut a small problem. if you see the code there is a 'if' condition\nReal cond = 0;\nif (std::abs(total) > std::abs(friction))\n  cond = 1;\n\nI want to multiply them to the Residual, jacobian and offdiagonal jacobian.\nbut when I do that I get\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is questionable (off by 5.32 %)\n\nKernel for variable 'gr1':\n  (1,1) On-diagonal Jacobian is questionable (off by 6.31 %)\n\nKernel for variable 'gr2':\n  (2,2) On-diagonal Jacobian is questionable (off by 7.75 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is inexact (off by 3.461 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (0,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (0,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (1,1) On-diagonal Jacobian is inexact (off by 4.165 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (1,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (2,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (2,2) On-diagonal Jacobian is questionable (off by 5.04 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is inexact (off by 3.461 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (0,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (0,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (1,1) On-diagonal Jacobian is inexact (off by 4.165 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (1,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (2,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (2,2) On-diagonal Jacobian is questionable (off by 5.04 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nI am very close but I don't understand why this if condition should be the problem.\nthank you",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10920082",
                  "updatedAt": "2024-10-12T01:06:11Z",
                  "publishedAt": "2024-10-12T01:06:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so with this if condition, and only with it, do you get a wrong jacobian?\nin the jacobian diagonal you still have this extra term btw\n          (_grad_phi[_j][_qp] * _kappa[_qp] * _L[_qp] *\n           _grad_test[_i][_qp]));\n\nthe way you do the Off diagonal jacobian with the loop on i is not super efficient. you might as well just find the i such that var_vals[i] == jvar, then use that",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10920114",
                          "updatedAt": "2024-10-12T01:18:59Z",
                          "publishedAt": "2024-10-12T01:18:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Yes, only when I use the if condition I get wrong jacobian.\nThe extra term is basically interface gradient term required for grain growth simulation, so it is supposed to be there, that was the intention earlier but because I was facing lot of difficulties earlier, I used ACInterface and add that kernel through action. but this is way more cleaner and just need one kernel for everything.\ncan you suggest any other kernel for reference for off diagonal loop?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10920171",
                          "updatedAt": "2024-10-12T01:36:38Z",
                          "publishedAt": "2024-10-12T01:36:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the other classes derived from the same base class are probably good examples (though check for the type, Kernel or KernelValue)",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10920271",
                          "updatedAt": "2024-10-12T02:18:05Z",
                          "publishedAt": "2024-10-12T02:18:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This if condition is introducing a nonlinearity. I wonder if that's what we are seeing in the Jacobian check.\nCould you please try to make it a continuously varying function between 0 and 1 (for example using a sigmoid, arctan or 1 - 1/(1+x) )\nand see if the Jacobian is perfect again",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10920924",
                          "updatedAt": "2024-10-12T06:06:44Z",
                          "publishedAt": "2024-10-12T06:06:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The Idea is when total <= friction in the code, there should not be any grain boundary movement. that is the evolution of order parameter at that point should be zero. Hence the condition.\nBut as you suggested by using sigmoidal function\n  Real x = std::abs(total) - std::abs(friction);\n  Real cond = 1 - 1 / (1 + x);\n\nthe jacobian debugger shows this\n Running input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.204828 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 70.5 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 93.6 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 66.2 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 72.4 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.578476 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 97.8 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 63.6 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 89.8 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 97.6 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.413870 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 53.9 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.9 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 72.8 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 55.9 %)\n  (3,3) On-diagonal Jacobian is inexact (off by 1.691 %)\n\nKernel for variable 'gr0':\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000048 %)\n\nKernel for variable 'gr1':\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001300 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000302 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001172 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.000718 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000354 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001456 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.144207 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000194 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.011280 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.006697 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.040923 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001695 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.024055 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.027743 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.004141 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.005559 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.006752 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000002 %)\n\nUsing tan based sigmoid function\n      Real k = 1000.0;\n      Real cond = 0.5 * (1 + tanh(k * (std::abs(total) - std::abs(friction))));\n\nI am getting this\nRunning input with executable ./pfubc-opt ...\n\nNo errors detected. :-)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (0,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (0,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (1,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (1,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (2,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (2,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (0,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (0,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (1,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (1,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (2,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (2,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10921101",
                          "updatedAt": "2024-10-12T06:51:07Z",
                          "publishedAt": "2024-10-12T06:47:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "This was done using my previous code yesterday which works fine but is very slow. It has 150 grains, mesh size 25x25 uniform refine =3 and adaptivity on. It took me little over 3 hrs on 4 core laptop.\n\nyou can see grain growth but after some time the grain boundary movement stops.\n\n\n  \n    \n    \n\n    output.mov\n    \n  \n\n  \n\n  \n\n\nFor a large system like 6400 grains that I am working on, the time it takes is very large.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10921181",
                          "updatedAt": "2024-10-12T07:25:50Z",
                          "publishedAt": "2024-10-12T07:08:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For sigmoidal and the others you would also need to implement the derivatives of these functions for the on-diagonal and off-diagonal terms.\nIt would be good to see a perfect Jacobian when the 'if' is replaced by a smooth transition instead",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10923345",
                          "updatedAt": "2024-10-12T15:33:42Z",
                          "publishedAt": "2024-10-12T15:27:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "But cond is a scalar value.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10924379",
                          "updatedAt": "2024-10-12T18:49:53Z",
                          "publishedAt": "2024-10-12T18:49:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not here anymore, it depends on the order parameters and it comes into the residual",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10924431",
                          "updatedAt": "2024-10-12T18:57:34Z",
                          "publishedAt": "2024-10-12T18:57:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am VERY confused about it now.  Can we use the header file to put in condition just like in ACBulk in moose where precomputeresidual and precomputejacobians are calculated based on conuteqpresidulal in .C file?\nlike this\n\ntemplate <typename T>\nReal\nACBulk<T>::precomputeQpResidual()\n{\n  // Get free energy derivative from function\n  Real dFdop = computeDFDOP(Residual);\n\n  // Set residual\n  return _L[_qp] * dFdop;\n}\n\ntemplate <typename T>\nReal\nACBulk<T>::precomputeQpJacobian()\n{\n  // Get free energy derivative and Jacobian\n  Real dFdop = computeDFDOP(Residual);\n\n  Real JdFdop = computeDFDOP(Jacobian);\n\n  // Set Jacobian value using product rule\n  return _L[_qp] * JdFdop + _dLdop[_qp] * _phi[_j][_qp] * dFdop;\n}",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10924449",
                          "updatedAt": "2024-10-12T19:03:15Z",
                          "publishedAt": "2024-10-12T19:03:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello,\nSorry to bother you again with this. So I have reached to this so far\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.003549 %)\n\nKernel for variable 'gr1':\n  (1,1) On-diagonal Jacobian is slightly off (by 0.002575 %)\n\nKernel for variable 'gr2':\n  (2,2) On-diagonal Jacobian is slightly off (by 0.006727 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.653418 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003828 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000663 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000840 %)\n  (1,1) On-diagonal Jacobian is inexact (off by 1.093 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.005968 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000135 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001223 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.312387 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000332 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000833 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.184664 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000815 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.006085 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.034506 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.475991 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003644 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.030764 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.153011 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.028809 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.040603 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.047589 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003503 %)\n\nthe code is\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : JvarMapKernelInterface<Kernel>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n  Real friction = 3 * g * _sigma[_qp] * op * SumOPGj;\n\n  Real k = 100;\n  Real sgn = tanh(k * total);\n\n  ////////////////////\n  Real abs_total = std::abs(total);\n  Real abs_friction = std::abs(friction);\n\n  // Tanh-based smooth condition\n  Real alpha = 100;\n  Real tanh_term = tanh(alpha * (abs_total - abs_friction));\n  Real smooth_condition = 0.5 * (1.0 + tanh_term);\n  ////////////////////\n\n  Real Res = (_test[_i][_qp] * _L[_qp] *\n              ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj) -\n                (sgn * 3 * _sigma[_qp] * g * op * SumOPGj)))) +\n             (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n\n  // return Res;\n  return smooth_condition * Res;\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\n  Real friction = 3 * g * _sigma[_qp] * op * SumOPGj;\n\n  const Real k = 100;\n  Real sgn = tanh(k * total);\n\n  // Derivatives wrt op\n  Real dtotal_dopi = _mu[_qp] * (3 * pow(op, 2) - 1 + 3 * SumOPj) +\n                     (_grad_phi[_j][_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n  Real dfriction_dopi = 3 * g * _sigma[_qp] * SumOPGj;\n  Real dsgn_dopi = k * pow(1 / cosh(k * total), 2) * dtotal_dopi;\n\n  ////////////////////\n  Real abs_total = std::abs(total);\n  Real abs_friction = std::abs(friction);\n\n  // Tanh-based smooth condition\n  Real alpha = 100;\n  Real tanh_term = tanh(alpha * (abs_total - abs_friction));\n  Real smooth_condition = 0.5 * (1.0 + tanh_term);\n\n  // Sign of total and friction\n  Real sgn_total = (total > 0) - (total < 0);          // Sign function for total\n  Real sgn_friction = (friction > 0) - (friction < 0); // Sign function for friction\n\n  // Derivative of the smooth condition wrt op using tanh\n  Real dsmooth_condition_dopi = 0.5 * (1.0 - pow(tanh_term, 2)) * alpha *\n                                (sgn_total * dtotal_dopi - sgn_friction * dfriction_dopi);\n  ////////////////\n\n  Real Res = (_test[_i][_qp] * _L[_qp] *\n              ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj) -\n                (sgn * 3 * _sigma[_qp] * g * op * SumOPGj)))) +\n             (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n\n  // Calculate Jacobian\n  Real Jac = _L[_qp] * _test[_i][_qp] * _phi[_j][_qp] *\n                 (_mu[_qp] * (3 * pow(op, 2) - 1 + 3 * SumOPj) -\n                  ((3 * _sigma[_qp] * g * SumOPGj * sgn) +\n                   (3 * _sigma[_qp] * g * op * SumOPGj * dsgn_dopi))) +\n             (_grad_phi[_j][_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n\n  // return Jac;\n  return smooth_condition * Jac + dsmooth_condition_dopi * Res;\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  const unsigned int cvar = mapJvarToCvar(jvar);\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int a = 0; a < _op_num; ++a)\n  {\n    SumOPj += other_ops[a] * other_ops[a];\n    SumOPGj += other_ops[a];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n  Real friction = 3 * _sigma[_qp] * op * g * SumOPGj;\n\n  Real k = 100;\n  Real sgn = tanh(k * total);\n\n  Real Res = (_test[_i][_qp] * _L[_qp] *\n              ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj) -\n                (sgn * 3 * _sigma[_qp] * g * op * SumOPGj)))) +\n             (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      Real dSumOPGj = _phi[_j][_qp];\n\n      // Derivatives wrt opj\n      Real dtotal_dopj = _mu[_qp] * (3 * op * dSumOPj);\n      Real dfriction_dopj = 3 * _sigma[_qp] * g * op * dSumOPGj;\n      Real dsgn_dopj = k * pow(1 / cosh(k * total), 2) * dtotal_dopj;\n\n      ////////////////////\n      Real abs_total = std::abs(total);\n      Real abs_friction = std::abs(friction);\n\n      // Tanh-based smooth condition\n      Real alpha = 100;\n      Real tanh_term = tanh(alpha * (abs_total - abs_friction));\n      Real smooth_condition = 0.5 * (1.0 + tanh_term);\n\n      // Sign of total and friction\n      Real sgn_total = (total > 0) - (total < 0);          // Sign function for total\n      Real sgn_friction = (friction > 0) - (friction < 0); // Sign function for friction\n\n      // Derivative of the smooth condition wrt opj using tanh\n      Real dsmooth_condition_dopj = 0.5 * (1.0 - pow(tanh_term, 2)) * alpha *\n                                    (sgn_total * dtotal_dopj - sgn_friction * dfriction_dopj);\n      ////////////////\n\n      Real offJac =\n          _L[_qp] * _test[_i][_qp] *\n          ((3 * op * dSumOPj * _mu[_qp]) - (sgn * 3 * _sigma[_qp] * g * op * dSumOPGj +\n                                            3 * _sigma[_qp] * g * op * SumOPGj * dsgn_dopj));\n\n      // return offJac;\n      return smooth_condition * offJac + dsmooth_condition_dopj * Res;\n    }\n  return 0;\n}\n\nbut if I don't use the smooth_condition (commented return in residual,  Jacobian and offdiagonal jacobian)\nI get this\nRunning input with executable ./pfubc-opt ...\n\nNo errors detected. :-)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000750 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.007229 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000453 %)\n\nKernel for variable 'gr1':\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.010808 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000894 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.007855 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000597 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000806 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.184664 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000820 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.006076 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.034511 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.475956 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003645 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.030775 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.152983 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.028808 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.040599 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.047593 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003503 %)\n\nwhat exactly is on diagonal jacobian here. I need to look into it but I am not ale to find anything wrong at the moment. can you have a look at it.\nThank you so much\nAshish",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995739",
                  "updatedAt": "2024-10-20T11:29:13Z",
                  "publishedAt": "2024-10-20T11:28:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This looks much better.\nAll discrepancies are 1% or less roughly right?\nI think you can move on now. So check if you can take larger time steps now?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995865",
                          "updatedAt": "2024-10-20T11:58:26Z",
                          "publishedAt": "2024-10-20T11:58:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "ok let me try. I will get back. Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995870",
                          "updatedAt": "2024-10-20T11:59:35Z",
                          "publishedAt": "2024-10-20T11:59:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I don't think its working\n\n\n*** Warning, This code is deprecated and will be removed in future versions:\nPlease update your main.C to adapt new main function in MOOSE framework, see'test/src/main.C in MOOSE as an example of moose::main()'. \n\n\n\ufffd[36m\n*** Info ***\n'execute_on' parameter specified in [Outputs] block is ignored for object 'checkpoint'.\nDefine this object in its own sub-block of [Outputs] to modify its execution schedule.\ufffd[39m\n                                                                               [\ufffd[33m  2.78 s\ufffd[39m] [\ufffd[33m  254 MB\ufffd[39m]\nFramework Information:\nMOOSE Version:           git commit 30fe3abb9c on 2024-07-31\nLibMesh Version:         \nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1\nCurrent Time:            Sun Oct 20 05:07:25 2024\nExecutable Timestamp:    Sun Oct 20 04:58:36 2024\n\nCheckpoint:\n  Wall Time Interval:      Every 3600.000000 s\n  User Checkpoint:         Outputs/checkpoint\n  # Checkpoints Kept:      2\n  Execute On:              TIMESTEP_END \n\nParallelism:\n  Num Processors:          4\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           distributed\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   \n    Total:                 58081\n    Local:                 14641\n    Min/Max/Avg:           14400/14641/14520\n  Elems:                   \n    Total:                 57600\n    Local:                 14400\n    Min/Max/Avg:           14400/14400/14400\n  Num Subdomains:          1\n  Num Partitions:          4\n  Partitioner:             parmetis\n\nNonlinear System:\n  Num DOFs:                464648\n  Num Local DOFs:          117128\n  Num Constrained DOFs:    3848\n  Local Constrained DOFs:  8\n  Variables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" \"gr5\" \"gr6\" \"gr7\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                231362\n  Num Local DOFs:          58082\n  Num Constrained DOFs:    962\n  Local Constrained DOFs:  2\n  Variables:               \"bnds\" { \"unique_grains\" \"var_indices\" } \"phi\" \n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             SolutionTimeAdaptiveDT\n  TimeIntegrator:          BDF2\n  Solver Mode:             Preconditioned JFNK\n  PETSc Preconditioner:    hypre boomeramg \n\nCurrently Executing\n  Performing Initial Setup\n    Projecting Initial Solutions                                                         [\ufffd[33m  8.14 s\ufffd[39m] [\ufffd[33m  257 MB\ufffd[39m]\n  Finished Performing Initial Setup                                                      [\ufffd[33m 10.49 s\ufffd[39m] [\ufffd[33m  263 MB\ufffd[39m]\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = \ufffd[32m3.764685e+01\ufffd[39m\n      0 Linear |R| = \ufffd[32m3.764685e+01\ufffd[39m\n      1 Linear |R| = \ufffd[32m7.767453e-01\ufffd[39m\n      2 Linear |R| = \ufffd[32m9.018634e-02\ufffd[39m\n      3 Linear |R| = \ufffd[32m5.824438e-03\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m3.629343e+00\ufffd[39m\n      0 Linear |R| = \ufffd[32m3.629343e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m3.445646e+00\ufffd[39m\n      2 Linear |R| = \ufffd[32m1.739312e+00\ufffd[39m\n      3 Linear |R| = \ufffd[32m1.255872e+00\ufffd[39m\n      4 Linear |R| = \ufffd[32m9.459253e-01\ufffd[39m\n      5 Linear |R| = \ufffd[32m8.909423e-01\ufffd[39m\n      6 Linear |R| = \ufffd[32m7.407877e-01\ufffd[39m\n      7 Linear |R| = \ufffd[33m7.406761e-01\ufffd[39m\n      8 Linear |R| = \ufffd[32m6.656309e-01\ufffd[39m\n      9 Linear |R| = \ufffd[32m6.094072e-01\ufffd[39m\n     10 Linear |R| = \ufffd[33m6.091463e-01\ufffd[39m\n     11 Linear |R| = \ufffd[32m5.400718e-01\ufffd[39m\n     12 Linear |R| = \ufffd[32m3.886766e-01\ufffd[39m\n     13 Linear |R| = \ufffd[33m3.884649e-01\ufffd[39m\n     14 Linear |R| = \ufffd[33m3.696327e-01\ufffd[39m\n     15 Linear |R| = \ufffd[32m2.939678e-01\ufffd[39m\n     16 Linear |R| = \ufffd[32m2.768585e-01\ufffd[39m\n     17 Linear |R| = \ufffd[33m2.742878e-01\ufffd[39m\n     18 Linear |R| = \ufffd[32m2.087444e-01\ufffd[39m\n     19 Linear |R| = \ufffd[33m1.984259e-01\ufffd[39m\n     20 Linear |R| = \ufffd[32m1.657327e-01\ufffd[39m\n     21 Linear |R| = \ufffd[32m1.430778e-01\ufffd[39m\n     22 Linear |R| = \ufffd[32m1.334376e-01\ufffd[39m\n     23 Linear |R| = \ufffd[32m1.112005e-01\ufffd[39m\n     24 Linear |R| = \ufffd[33m1.111823e-01\ufffd[39m\n     25 Linear |R| = \ufffd[32m9.621404e-02\ufffd[39m\n     26 Linear |R| = \ufffd[32m9.086889e-02\ufffd[39m\n     27 Linear |R| = \ufffd[33m8.653964e-02\ufffd[39m\n     28 Linear |R| = \ufffd[33m8.406082e-02\ufffd[39m\n     29 Linear |R| = \ufffd[33m8.279928e-02\ufffd[39m\n     30 Linear |R| = \ufffd[33m8.178184e-02\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 2 Nonlinear |R| = \ufffd[32m8.956907e-01\ufffd[39m\n      0 Linear |R| = \ufffd[32m8.956907e-01\ufffd[39m\n      1 Linear |R| = \ufffd[33m8.956906e-01\ufffd[39m\n      2 Linear |R| = \ufffd[33m8.956883e-01\ufffd[39m\n      3 Linear |R| = \ufffd[33m8.956861e-01\ufffd[39m\n      4 Linear |R| = \ufffd[33m8.956839e-01\ufffd[39m\n      5 Linear |R| = \ufffd[33m8.956816e-01\ufffd[39m\n      6 Linear |R| = \ufffd[33m8.956794e-01\ufffd[39m\n      7 Linear |R| = \ufffd[33m8.956771e-01\ufffd[39m\n      8 Linear |R| = \ufffd[33m8.956749e-01\ufffd[39m\n      9 Linear |R| = \ufffd[33m8.956727e-01\ufffd[39m\n     10 Linear |R| = \ufffd[33m8.956704e-01\ufffd[39m\n     11 Linear |R| = \ufffd[33m8.956682e-01\ufffd[39m\n     12 Linear |R| = \ufffd[33m8.956660e-01\ufffd[39m\n     13 Linear |R| = \ufffd[33m8.956637e-01\ufffd[39m\n     14 Linear |R| = \ufffd[33m8.956615e-01\ufffd[39m\n     15 Linear |R| = \ufffd[33m8.956592e-01\ufffd[39m\n     16 Linear |R| = \ufffd[33m8.956570e-01\ufffd[39m\n     17 Linear |R| = \ufffd[33m8.956548e-01\ufffd[39m\n     18 Linear |R| = \ufffd[33m8.956525e-01\ufffd[39m\n     19 Linear |R| = \ufffd[33m8.956503e-01\ufffd[39m\n     20 Linear |R| = \ufffd[33m8.956481e-01\ufffd[39m\n     21 Linear |R| = \ufffd[33m8.956458e-01\ufffd[39m\n     22 Linear |R| = \ufffd[33m8.956436e-01\ufffd[39m\n     23 Linear |R| = \ufffd[33m8.956414e-01\ufffd[39m\n     24 Linear |R| = \ufffd[33m8.956391e-01\ufffd[39m\n     25 Linear |R| = \ufffd[33m8.956369e-01\ufffd[39m\n     26 Linear |R| = \ufffd[33m8.956346e-01\ufffd[39m\n     27 Linear |R| = \ufffd[33m8.956324e-01\ufffd[39m\n     28 Linear |R| = \ufffd[33m8.956302e-01\ufffd[39m\n     29 Linear |R| = \ufffd[33m8.956279e-01\ufffd[39m\n     30 Linear |R| = \ufffd[33m8.956257e-01\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 3 Nonlinear |R| = \ufffd[33m8.956905e-01\ufffd[39m\n      0 Linear |R| = \ufffd[32m8.956905e-01\ufffd[39m\n      1 Linear |R| = \ufffd[33m8.956904e-01\ufffd[39m\n      2 Linear |R| = \ufffd[33m8.954786e-01\ufffd[39m\n      3 Linear |R| = \ufffd[32m8.295185e-01\ufffd[39m\n      4 Linear |R| = \ufffd[33m8.021139e-01\ufffd[39m\n      5 Linear |R| = \ufffd[33m7.738469e-01\ufffd[39m\n      6 Linear |R| = \ufffd[33m7.716900e-01\ufffd[39m\n      7 Linear |R| = \ufffd[33m7.631383e-01\ufffd[39m\n      8 Linear |R| = \ufffd[33m7.438382e-01\ufffd[39m\n      9 Linear |R| = \ufffd[33m7.075148e-01\ufffd[39m\n     10 Linear |R| = \ufffd[32m6.658380e-01\ufffd[39m\n     11 Linear |R| = \ufffd[32m4.235387e-01\ufffd[39m\n     12 Linear |R| = \ufffd[33m4.116842e-01\ufffd[39m\n     13 Linear |R| = \ufffd[32m3.823932e-01\ufffd[39m\n     14 Linear |R| = \ufffd[32m3.126606e-01\ufffd[39m\n     15 Linear |R| = \ufffd[32m2.908851e-01\ufffd[39m\n     16 Linear |R| = \ufffd[33m2.866650e-01\ufffd[39m\n     17 Linear |R| = \ufffd[33m2.807683e-01\ufffd[39m\n     18 Linear |R| = \ufffd[32m2.661196e-01\ufffd[39m\n     19 Linear |R| = \ufffd[32m2.493560e-01\ufffd[39m\n     20 Linear |R| = \ufffd[33m2.430896e-01\ufffd[39m\n     21 Linear |R| = \ufffd[33m2.392249e-01\ufffd[39m\n     22 Linear |R| = \ufffd[32m2.218393e-01\ufffd[39m\n     23 Linear |R| = \ufffd[33m2.210137e-01\ufffd[39m\n     24 Linear |R| = \ufffd[33m2.135378e-01\ufffd[39m\n     25 Linear |R| = \ufffd[32m2.020795e-01\ufffd[39m\n     26 Linear |R| = \ufffd[33m2.013340e-01\ufffd[39m\n     27 Linear |R| = \ufffd[33m1.924127e-01\ufffd[39m\n     28 Linear |R| = \ufffd[32m1.825820e-01\ufffd[39m\n     29 Linear |R| = \ufffd[32m1.667472e-01\ufffd[39m\n     30 Linear |R| = \ufffd[33m1.646775e-01\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 4 Nonlinear |R| = \ufffd[32m6.777260e-01\ufffd[39m\n      0 Linear |R| = \ufffd[32m6.777260e-01\ufffd[39m\n      1 Linear |R| = \ufffd[32m2.884173e-01\ufffd[39m\n      2 Linear |R| = \ufffd[32m1.403607e-01\ufffd[39m\n      3 Linear |R| = \ufffd[32m1.087947e-01\ufffd[39m\n      4 Linear |R| = \ufffd[33m1.069581e-01\ufffd[39m\n      5 Linear |R| = \ufffd[33m1.062109e-01\ufffd[39m\n      6 Linear |R| = \ufffd[33m1.060233e-01\ufffd[39m\n      7 Linear |R| = \ufffd[33m1.047513e-01\ufffd[39m\n      8 Linear |R| = \ufffd[32m9.796113e-02\ufffd[39m\n      9 Linear |R| = \ufffd[32m8.406850e-02\ufffd[39m\n     10 Linear |R| = \ufffd[32m7.514669e-02\ufffd[39m\n     11 Linear |R| = \ufffd[33m7.266081e-02\ufffd[39m\n     12 Linear |R| = \ufffd[33m7.223395e-02\ufffd[39m\n     13 Linear |R| = \ufffd[32m6.819425e-02\ufffd[39m\n     14 Linear |R| = \ufffd[32m5.452372e-02\ufffd[39m\n     15 Linear |R| = \ufffd[32m4.658762e-02\ufffd[39m\n     16 Linear |R| = \ufffd[32m4.020397e-02\ufffd[39m\n     17 Linear |R| = \ufffd[33m4.001046e-02\ufffd[39m\n     18 Linear |R| = \ufffd[33m3.946197e-02\ufffd[39m\n     19 Linear |R| = \ufffd[32m3.542138e-02\ufffd[39m\n     20 Linear |R| = \ufffd[32m3.163193e-02\ufffd[39m\n     21 Linear |R| = \ufffd[32m2.904052e-02\ufffd[39m\n     22 Linear |R| = \ufffd[33m2.815327e-02\ufffd[39m\n     23 Linear |R| = \ufffd[32m2.463075e-02\ufffd[39m\n     24 Linear |R| = \ufffd[33m2.462958e-02\ufffd[39m\n     25 Linear |R| = \ufffd[33m2.429657e-02\ufffd[39m\n     26 Linear |R| = \ufffd[32m2.027283e-02\ufffd[39m\n     27 Linear |R| = \ufffd[32m1.826535e-02\ufffd[39m\n     28 Linear |R| = \ufffd[33m1.797220e-02\ufffd[39m\n     29 Linear |R| = \ufffd[33m1.753867e-02\ufffd[39m\n     30 Linear |R| = \ufffd[32m1.444272e-02\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 5 Nonlinear |R| = \ufffd[32m9.469957e-02\ufffd[39m\n      0 Linear |R| = \ufffd[32m9.469957e-02\ufffd[39m\n      1 Linear |R| = \ufffd[32m5.551551e-02\ufffd[39m\n      2 Linear |R| = \ufffd[32m4.357779e-02\ufffd[39m\n      3 Linear |R| = \ufffd[32m3.696999e-02\ufffd[39m\n      4 Linear |R| = \ufffd[32m3.234374e-02\ufffd[39m\n      5 Linear |R| = \ufffd[33m3.144135e-02\ufffd[39m\n      6 Linear |R| = \ufffd[32m2.247098e-02\ufffd[39m\n      7 Linear |R| = \ufffd[33m2.178075e-02\ufffd[39m\n      8 Linear |R| = \ufffd[32m1.970162e-02\ufffd[39m\n      9 Linear |R| = \ufffd[32m1.755335e-02\ufffd[39m\n     10 Linear |R| = \ufffd[32m1.603516e-02\ufffd[39m\n     11 Linear |R| = \ufffd[32m1.522744e-02\ufffd[39m\n     12 Linear |R| = \ufffd[33m1.493695e-02\ufffd[39m\n     13 Linear |R| = \ufffd[32m1.369856e-02\ufffd[39m\n     14 Linear |R| = \ufffd[32m1.214335e-02\ufffd[39m\n     15 Linear |R| = \ufffd[33m1.210103e-02\ufffd[39m\n     16 Linear |R| = \ufffd[32m1.099370e-02\ufffd[39m\n     17 Linear |R| = \ufffd[33m1.098430e-02\ufffd[39m\n     18 Linear |R| = \ufffd[33m1.071398e-02\ufffd[39m\n     19 Linear |R| = \ufffd[32m9.883785e-03\ufffd[39m\n     20 Linear |R| = \ufffd[33m9.828523e-03\ufffd[39m\n     21 Linear |R| = \ufffd[32m9.124156e-03\ufffd[39m\n     22 Linear |R| = \ufffd[33m9.014454e-03\ufffd[39m\n     23 Linear |R| = \ufffd[33m8.632032e-03\ufffd[39m\n     24 Linear |R| = \ufffd[33m8.437000e-03\ufffd[39m\n     25 Linear |R| = \ufffd[32m7.049509e-03\ufffd[39m\n     26 Linear |R| = \ufffd[33m7.038395e-03\ufffd[39m\n     27 Linear |R| = \ufffd[32m5.976451e-03\ufffd[39m\n     28 Linear |R| = \ufffd[33m5.953475e-03\ufffd[39m\n     29 Linear |R| = \ufffd[32m4.756918e-03\ufffd[39m\n     30 Linear |R| = \ufffd[33m4.655409e-03\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 6 Nonlinear |R| = \ufffd[32m5.055879e-02\ufffd[39m\n      0 Linear |R| = \ufffd[32m5.055879e-02\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.130905e-02\ufffd[39m\n      2 Linear |R| = \ufffd[33m1.102555e-02\ufffd[39m\n      3 Linear |R| = \ufffd[32m9.659015e-03\ufffd[39m\n      4 Linear |R| = \ufffd[33m9.626112e-03\ufffd[39m\n      5 Linear |R| = \ufffd[33m9.335340e-03\ufffd[39m\n      6 Linear |R| = \ufffd[32m8.558825e-03\ufffd[39m\n      7 Linear |R| = \ufffd[33m8.539813e-03\ufffd[39m\n      8 Linear |R| = \ufffd[32m6.505873e-03\ufffd[39m\n      9 Linear |R| = \ufffd[32m5.286782e-03\ufffd[39m\n     10 Linear |R| = \ufffd[32m4.466903e-03\ufffd[39m\n     11 Linear |R| = \ufffd[33m4.382467e-03\ufffd[39m\n     12 Linear |R| = \ufffd[32m3.272573e-03\ufffd[39m\n     13 Linear |R| = \ufffd[32m2.836778e-03\ufffd[39m\n     14 Linear |R| = \ufffd[33m2.727106e-03\ufffd[39m\n     15 Linear |R| = \ufffd[32m1.825536e-03\ufffd[39m\n     16 Linear |R| = \ufffd[32m1.251776e-03\ufffd[39m\n     17 Linear |R| = \ufffd[32m1.135239e-03\ufffd[39m\n     18 Linear |R| = \ufffd[32m1.027958e-03\ufffd[39m\n     19 Linear |R| = \ufffd[32m7.980705e-04\ufffd[39m\n 7 Nonlinear |R| = \ufffd[32m3.086312e-02\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m117.89 s\ufffd[39m] [\ufffd[33m  398 MB\ufffd[39m]\n\nOutlier Variable Residual Norms:\n  gr1: \ufffd[33m2.040915e-02\ufffd[39m\n  gr6: \ufffd[33m1.566724e-02\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n|   1.000000e-01 |   6.960100e+05 |   2.970342e+02 |   1.000000e-01 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nSteady-State Relative Differential Norm: 1.98569\n\n\nPerformance Graph:\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n|                                Section                               | Calls |   Self(s)  |   Avg(s)   |    %   | Mem(MB) |  Total(s)  |   Avg(s)   |    %   | Mem(MB) |\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n| pfubcApp (main)                                                      |     1 |      0.010 |      0.010 |   0.01 |       5 |    135.422 |    135.422 | 100.00 |     209 |\n|   Action::SetupMeshAction::Mesh::SetupMeshAction::act::setup_mesh    |     1 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n|   Action::SetupMeshAction::Mesh::SetupMeshAction::act::set_mesh_base |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.013 |      0.006 |   0.01 |       6 |\n|   FEProblem::computeUserObjects                                      |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n|   FEProblem::computeUserObjects                                      |     3 |      0.218 |      0.073 |   0.16 |       0 |      1.936 |      0.645 |   1.43 |       7 |\n|   FEProblem::outputStep                                              |     2 |      0.151 |      0.075 |   0.11 |       0 |      0.942 |      0.471 |   0.70 |      32 |\n|   Transient::PicardSolve                                             |     1 |      0.010 |      0.010 |   0.01 |       0 |    121.193 |    121.193 |  89.49 |      50 |\n|     FEProblem::computeUserObjects                                    |     8 |      0.280 |      0.035 |   0.21 |       0 |      3.198 |      0.400 |   2.36 |       0 |\n|     FEProblem::outputStep                                            |     3 |      0.004 |      0.001 |   0.00 |       0 |      0.004 |      0.001 |   0.00 |       0 |\n|     FEProblem::solve                                                 |     1 |      7.472 |      7.472 |   5.52 |      93 |    117.892 |    117.892 |  87.06 |     107 |\n|       FEProblem::computeJacobianInternal                             |     1 |      0.000 |      0.000 |   0.00 |       0 |      1.176 |      1.176 |   0.87 |       0 |\n|         FEProblem::computeUserObjects                                |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n|       FEProblem::computeJacobianInternal                             |     7 |      0.000 |      0.000 |   0.00 |       0 |     11.115 |      1.588 |   8.21 |      12 |\n|         FEProblem::computeUserObjects                                |    14 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n|       FEProblem::computeResidualInternal                             |   191 |      0.006 |      0.000 |   0.00 |       0 |     98.099 |      0.514 |  72.44 |       0 |\n|         FEProblem::computeUserObjects                                |   382 |      0.003 |      0.000 |   0.00 |       0 |      0.003 |      0.000 |   0.00 |       0 |\n|   Transient::final                                                   |     1 |      0.001 |      0.001 |   0.00 |       0 |      0.002 |      0.002 |   0.00 |       0 |\n|     FEProblem::computeUserObjects                                    |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n|     FEProblem::outputStep                                            |     1 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nFinished Executing                                                                       [\ufffd[33m132.63 s\ufffd[39m] [\ufffd[33m  345 MB\ufffd[39m]",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995924",
                          "updatedAt": "2024-10-20T12:10:39Z",
                          "publishedAt": "2024-10-20T12:10:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Try a Newton solve instead of PJFNK now that the Jacobian is fully correct\nAnd what preconditioners have you tried?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995980",
                          "updatedAt": "2024-10-20T12:21:44Z",
                          "publishedAt": "2024-10-20T12:21:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am using this\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = PJFNK #Preconditioned JFNK (default)\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n  steady_state_detection = true\n  steady_state_start_time = 0\n  steady_state_tolerance = 1e-8\n  automatic_scaling = true\n  compute_scaling_once = false\n  l_tol = 1.0e-3\n  l_abs_tol = 1e-3\n  l_max_its = 30\n  nl_abs_tol = 1e-3\n  nl_max_its = 30\n  nl_rel_tol = 1.0e-3\n  start_time = 0.0\n  #num_steps = 1\n  end_time = 150000\n  dtmin = 1e-20\n  [TimeStepper]\n    type = SolutionTimeAdaptiveDT\n    dt = 0.1\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995985",
                          "updatedAt": "2024-10-20T12:23:06Z",
                          "publishedAt": "2024-10-20T12:23:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "any suggestion on this other than Newton? with newton the calculations are faster and the timesteps are also increasing.\nBut computing Jacobian step is taking some time.\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 3.764832e+01\n\n    Computing Jacobian                                                                   [  8.28 s] [  489 MB]\n      0 Linear |R| = 3.764832e+01\n      1 Linear |R| = 1.891125e-01\n      2 Linear |R| = 1.255195e-03\n 1 Nonlinear |R| = 3.584128e+00\n    Computing Jacobian.                                                                  [ 12.18 s] [  836 MB]\n      0 Linear |R| = 3.584128e+00\n      1 Linear |R| = 4.056686e-02\n      2 Linear |R| = 7.565497e-04\n 2 Nonlinear |R| = 2.022486e-01\n    Computing Jacobian.                                                                  [ 11.70 s] [  893 MB]\n      0 Linear |R| = 2.022486e-01\n      1 Linear |R| = 1.214415e-03\n      2 Linear |R| = 2.182540e-05\n 3 Nonlinear |R| = 1.389606e-02\n Solve Converged!\n  Finished Solving                                                                       [ 39.28 s] [  491 MB]\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n|   1.000000e-01 |   6.960100e+05 |   2.970350e+02 |   1.000000e-01 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nSteady-State Relative Differential Norm: 1.98581\n\nTime Step 2, time = 0.21, dt = 0.11\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 1.406254e+01\n\n    Computing Jacobian.                                                                  [ 12.17 s] [  495 MB]\n      0 Linear |R| = 1.406254e+01\n      1 Linear |R| = 8.324495e-02\n      2 Linear |R| = 6.581188e-04\n 1 Nonlinear |R| = 9.325223e-01\n    Computing Jacobian.                                                                  [ 11.92 s] [  840 MB]\n      0 Linear |R| = 9.325223e-01\n      1 Linear |R| = 7.408165e-03\n      2 Linear |R| = 5.467525e-05\n 2 Nonlinear |R| = 6.586837e-02\n    Computing Jacobian.                                                                  [ 11.54 s] [  857 MB]\n      0 Linear |R| = 6.586837e-02\n      1 Linear |R| = 4.709918e-04\n 3 Nonlinear |R| = 4.471408e-03\n Solve Converged!\n  Finished Solving                                                                       [ 41.53 s] [  493 MB]\n\nOutlier Variable Residual Norms:\n  gr1: 2.239529e-03\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n|   1.000000e-01 |   6.960100e+05 |   2.970350e+02 |   1.000000e-01 |   3.000000e+02 |\n|   2.100000e-01 |   6.960100e+05 |   2.964918e+02 |   1.000000e-01 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10996196",
                          "updatedAt": "2024-10-20T13:14:38Z",
                          "publishedAt": "2024-10-20T13:14:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is it faster overall?\nBy how much?\nNext suggestions would be passing some options to hypre boomeramg to optimize the preconditioning",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10996387",
                          "updatedAt": "2024-10-20T13:58:01Z",
                          "publishedAt": "2024-10-20T13:58:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "No it didn't worked.\n\n\n*** Warning, This code is deprecated and will be removed in future versions:\nPlease update your main.C to adapt new main function in MOOSE framework, see'test/src/main.C in MOOSE as an example of moose::main()'. \n\nSetting Up\n  Uniformly Refining                                                                     [\ufffd[33m  9.38 s\ufffd[39m] [\ufffd[33m  210 MB\ufffd[39m]\n\n\ufffd[36m\n*** Info ***\n'execute_on' parameter specified in [Outputs] block is ignored for object 'checkpoint'.\nDefine this object in its own sub-block of [Outputs] to modify its execution schedule.\ufffd[39m\n  Initializing\n    Finished Initializing Equation Systems                                               [\ufffd[33m  2.53 s\ufffd[39m] [\ufffd[33m  422 MB\ufffd[39m]\n  Finished Initializing                                                                  [\ufffd[33m  2.64 s\ufffd[39m] [\ufffd[33m  422 MB\ufffd[39m]\nFinished Setting Up                                                                      [\ufffd[33m 15.12 s\ufffd[39m] [\ufffd[33m  422 MB\ufffd[39m]\nFramework Information:\nMOOSE Version:           git commit 30fe3abb9c on 2024-07-31\nLibMesh Version:         \nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1\nCurrent Time:            Sun Oct 20 07:01:41 2024\nExecutable Timestamp:    Sun Oct 20 06:58:17 2024\n\nCheckpoint:\n  Wall Time Interval:      Every 3600.000000 s\n  User Checkpoint:         Outputs/checkpoint\n  # Checkpoints Kept:      2\n  Execute On:              TIMESTEP_END \n\nParallelism:\n  Num Processors:          4\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           distributed\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   \n    Total:                 58081\n    Local:                 14641\n    Min/Max/Avg:           14400/14641/14520\n  Elems:                   \n    Total:                 57600\n    Local:                 14400\n    Min/Max/Avg:           14400/14400/14400\n  Num Subdomains:          1\n  Num Partitions:          4\n  Partitioner:             parmetis\n\nNonlinear System:\n  Num DOFs:                464648\n  Num Local DOFs:          117128\n  Num Constrained DOFs:    3848\n  Local Constrained DOFs:  8\n  Variables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" \"gr5\" \"gr6\" \"gr7\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                231362\n  Num Local DOFs:          58082\n  Num Constrained DOFs:    962\n  Local Constrained DOFs:  2\n  Variables:               \"bnds\" { \"unique_grains\" \"var_indices\" } \"phi\" \n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             IterationAdaptiveDT\n  TimeIntegrator:          BDF2\n  Solver Mode:             NEWTON\n  PETSc Preconditioner:    hypre boomeramg \n  MOOSE Preconditioner:    SMP\n\nCurrently Executing\n  Performing Initial Setup\n    Finished Projecting Initial Solutions                                                [\ufffd[33m  8.33 s\ufffd[39m] [\ufffd[33m  424 MB\ufffd[39m]\n  Finished Performing Initial Setup                                                      [\ufffd[33m 11.67 s\ufffd[39m] [\ufffd[33m  424 MB\ufffd[39m]\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = \ufffd[32m3.487374e+01\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  9.21 s\ufffd[39m] [\ufffd[33m  494 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m3.487374e+01\ufffd[39m\n      1 Linear |R| = \ufffd[33m3.487234e+01\ufffd[39m\n      2 Linear |R| = \ufffd[33m3.487167e+01\ufffd[39m\n      3 Linear |R| = \ufffd[33m3.484692e+01\ufffd[39m\n      4 Linear |R| = \ufffd[33m3.461484e+01\ufffd[39m\n      5 Linear |R| = \ufffd[33m3.389344e+01\ufffd[39m\n      6 Linear |R| = \ufffd[33m3.274277e+01\ufffd[39m\n      7 Linear |R| = \ufffd[33m3.196968e+01\ufffd[39m\n      8 Linear |R| = \ufffd[33m3.055167e+01\ufffd[39m\n      9 Linear |R| = \ufffd[32m2.745755e+01\ufffd[39m\n     10 Linear |R| = \ufffd[32m2.578958e+01\ufffd[39m\n     11 Linear |R| = \ufffd[32m2.259508e+01\ufffd[39m\n     12 Linear |R| = \ufffd[32m2.034590e+01\ufffd[39m\n     13 Linear |R| = \ufffd[32m1.621202e+01\ufffd[39m\n     14 Linear |R| = \ufffd[32m1.302885e+01\ufffd[39m\n     15 Linear |R| = \ufffd[32m9.475939e+00\ufffd[39m\n     16 Linear |R| = \ufffd[32m8.173800e+00\ufffd[39m\n     17 Linear |R| = \ufffd[32m6.624792e+00\ufffd[39m\n     18 Linear |R| = \ufffd[32m5.610338e+00\ufffd[39m\n     19 Linear |R| = \ufffd[33m5.375408e+00\ufffd[39m\n     20 Linear |R| = \ufffd[32m4.502182e+00\ufffd[39m\n     21 Linear |R| = \ufffd[33m4.373877e+00\ufffd[39m\n     22 Linear |R| = \ufffd[33m4.366864e+00\ufffd[39m\n     23 Linear |R| = \ufffd[33m4.225973e+00\ufffd[39m\n     24 Linear |R| = \ufffd[33m4.223300e+00\ufffd[39m\n     25 Linear |R| = \ufffd[33m4.135403e+00\ufffd[39m\n     26 Linear |R| = \ufffd[33m3.962511e+00\ufffd[39m\n     27 Linear |R| = \ufffd[32m3.524618e+00\ufffd[39m\n     28 Linear |R| = \ufffd[32m3.162077e+00\ufffd[39m\n     29 Linear |R| = \ufffd[32m2.787070e+00\ufffd[39m\n     30 Linear |R| = \ufffd[32m2.411693e+00\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 1 Nonlinear |R| = \ufffd[32m1.936228e+01\ufffd[39m\n    Computing Jacobian.                                                                  [\ufffd[33m 11.09 s\ufffd[39m] [\ufffd[33m  829 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.936228e+01\ufffd[39m\n      1 Linear |R| = \ufffd[33m1.936228e+01\ufffd[39m\n      2 Linear |R| = \ufffd[33m1.936228e+01\ufffd[39m\n      3 Linear |R| = \ufffd[33m1.936227e+01\ufffd[39m\n      4 Linear |R| = \ufffd[33m1.936224e+01\ufffd[39m\n      5 Linear |R| = \ufffd[33m1.936224e+01\ufffd[39m\n      6 Linear |R| = \ufffd[33m1.936223e+01\ufffd[39m\n      7 Linear |R| = \ufffd[33m1.936222e+01\ufffd[39m\n      8 Linear |R| = \ufffd[33m1.936222e+01\ufffd[39m\n      9 Linear |R| = \ufffd[33m1.936222e+01\ufffd[39m\n     10 Linear |R| = \ufffd[33m1.936221e+01\ufffd[39m\n     11 Linear |R| = \ufffd[33m1.936221e+01\ufffd[39m\n     12 Linear |R| = \ufffd[33m1.936221e+01\ufffd[39m\n     13 Linear |R| = \ufffd[33m1.936219e+01\ufffd[39m\n     14 Linear |R| = \ufffd[33m1.936218e+01\ufffd[39m\n     15 Linear |R| = \ufffd[33m1.936217e+01\ufffd[39m\n     16 Linear |R| = \ufffd[33m1.936216e+01\ufffd[39m\n     17 Linear |R| = \ufffd[33m1.936215e+01\ufffd[39m\n     18 Linear |R| = \ufffd[33m1.936214e+01\ufffd[39m\n     19 Linear |R| = \ufffd[33m1.936213e+01\ufffd[39m\n     20 Linear |R| = \ufffd[33m1.936212e+01\ufffd[39m\n     21 Linear |R| = \ufffd[33m1.936211e+01\ufffd[39m\n     22 Linear |R| = \ufffd[33m1.936210e+01\ufffd[39m\n     23 Linear |R| = \ufffd[33m1.936209e+01\ufffd[39m\n     24 Linear |R| = \ufffd[33m1.936208e+01\ufffd[39m\n     25 Linear |R| = \ufffd[33m1.936207e+01\ufffd[39m\n     26 Linear |R| = \ufffd[33m1.936206e+01\ufffd[39m\n     27 Linear |R| = \ufffd[33m1.936205e+01\ufffd[39m\n     28 Linear |R| = \ufffd[33m1.936204e+01\ufffd[39m\n     29 Linear |R| = \ufffd[33m1.936203e+01\ufffd[39m\n     30 Linear |R| = \ufffd[33m1.936202e+01\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 1\n\ufffd[31m Solve Did NOT Converge!\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m 43.57 s\ufffd[39m] [\ufffd[33m  503 MB\ufffd[39m]\nAborting as solve did not converge\n\nSolve failed, cutting timestep.\n\nTime Step 1, time = 0.05, dt = 0.05\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = \ufffd[32m3.312768e+01\ufffd[39m\n\n    Computing Jacobian\n\nthe jacobian test shows this\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.003549 %)\n\nKernel for variable 'gr1':\n  (1,1) On-diagonal Jacobian is slightly off (by 0.002575 %)\n\nKernel for variable 'gr2':\n  (2,2) On-diagonal Jacobian is slightly off (by 0.006727 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.653418 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003828 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000663 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000840 %)\n  (1,1) On-diagonal Jacobian is inexact (off by 1.093 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.005968 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000135 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001223 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.312387 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000332 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000833 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.184664 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000815 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.006085 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.034506 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.475991 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003644 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.030764 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.153011 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.028809 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.040603 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.047589 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003503 %)\n\nThe faster simulation was without smooth_condition.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10996405",
                          "updatedAt": "2024-10-20T14:05:09Z",
                          "publishedAt": "2024-10-20T14:05:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The on-diagonal is still showing slightly off.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10996431",
                          "updatedAt": "2024-10-20T14:09:46Z",
                          "publishedAt": "2024-10-20T14:09:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Some error is expected due to the way the Jacobian is computed during testing, using finite differencing.\nIf the smoothing does not help you can turn it off but you must keep the ajacobian correct to use Newton",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10997076",
                          "updatedAt": "2024-10-20T16:09:29Z",
                          "publishedAt": "2024-10-20T16:09:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "This is my residual\n  Real Res = _test[_i][_qp] * _L[_qp] *\n             ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n              (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]) -\n              (sgn * 3 * _sigma[_qp] * g * op * SumOPGj));\n\nhere _test and _grad_test are multiplied. and it happens in Jacobian also. Do I need to add override for both?",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11021197",
                  "updatedAt": "2024-10-22T19:19:06Z",
                  "publishedAt": "2024-10-22T19:19:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "_test multiplies grad_test? Never seen a weak form turn out with that\nare you following an example?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11023208",
                          "updatedAt": "2024-10-23T00:57:36Z",
                          "publishedAt": "2024-10-23T00:57:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "So, Residual of SimpleACInterface has _grad_test  (i.e. (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]))\nResidual of ACGrGrPoly has _test  (i.e.  (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)))\nI just wanted to sum these two so I can get the total variable (\nReal total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\n) which is total local free energy with gradient for my required condition.\nSo when I use it as a new residual for my new kernel it has both, _test and _grad_test.\nIn the kernel System page we have\n\nAnd thought it is common to have these two terms multiplied.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11023245",
                          "updatedAt": "2024-10-23T01:09:35Z",
                          "publishedAt": "2024-10-23T01:04:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello!\nDo you think I made it?\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001893 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.004703 %)\n\nKernel for variable 'gr1':\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.022568 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001990 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.016742 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.004244 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.009922 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.008009 %)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000174 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000069 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001472 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.015580 %)\n\nKernel for variable 'gr2':\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.008885 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000873 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.003285 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000551 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.008100 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.043051 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000211 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.002837 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.122815 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.024219 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000243 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.244533 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.001035 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000584 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.006769 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000082 %)",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11021732",
                  "updatedAt": "2024-10-22T20:32:26Z",
                  "publishedAt": "2024-10-22T20:32:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes this looks good",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11022762",
                          "updatedAt": "2024-10-22T23:25:30Z",
                          "publishedAt": "2024-10-22T23:25:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Great Thanks a lot.\nAshish",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11022783",
                          "updatedAt": "2024-10-22T23:28:25Z",
                          "publishedAt": "2024-10-22T23:28:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello!\nI made a few changes to the code and I am getting\nRunning input with executable ./pfubc-opt ...\n\nNo errors detected. :-)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000965 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000410 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000244 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.022107 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000763 %)\n\nKernel for variable 'gr2':\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.018285 %)\n\nKernel for variable 'gr3':\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.003120 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001017 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.006927 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.044368 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000239 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.005626 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.123996 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.030329 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000288 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.223532 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.001947 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000465 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.005491 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000106 %)\n\nbut I am still not getting good convergence\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   1.000000e+02 |   0.000000e+00 |   1.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 4.041805e+01\n      0 Linear |R| = 4.041805e+01\n      1 Linear |R| = 1.473850e+00\n      2 Linear |R| = 1.314554e-01\n      3 Linear |R| = 1.473827e-02\n 1 Nonlinear |R| = 3.175248e+01\n      0 Linear |R| = 3.175248e+01\n      1 Linear |R| = 1.061454e+00\n      2 Linear |R| = 9.082835e-02\n      3 Linear |R| = 1.495823e-02\n 2 Nonlinear |R| = 2.227933e+00\n      0 Linear |R| = 2.227933e+00\n      1 Linear |R| = 9.903840e-02\n      2 Linear |R| = 1.072282e-02\n      3 Linear |R| = 1.397335e-03\n 3 Nonlinear |R| = 6.974641e-01\n      0 Linear |R| = 6.974641e-01\n      1 Linear |R| = 2.633254e-02\n      2 Linear |R| = 2.894129e-03\n      3 Linear |R| = 3.809362e-04\n 4 Nonlinear |R| = 3.226597e-01\n      0 Linear |R| = 3.226597e-01\n      1 Linear |R| = 7.780427e-03\n      2 Linear |R| = 8.263551e-04\n 5 Nonlinear |R| = 8.940924e-02\n      0 Linear |R| = 8.940924e-02\n      1 Linear |R| = 1.954140e-03\n      2 Linear |R| = 1.797905e-04\n 6 Nonlinear |R| = 5.126629e-02\n      0 Linear |R| = 5.126629e-02\n      1 Linear |R| = 7.674661e-04\n 7 Nonlinear |R| = 1.378475e-02\n Solve Converged!\nCurrently Executing\n  Finished Solving                                                                       [ 22.06 s] [  308 MB]\n\nOutlier Variable Residual Norms:\n  gr2: 1.273284e-02\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   1.000000e+02 |   0.000000e+00 |   1.000000e+02 |\n|   1.000000e-01 |   4.840100e+05 |   9.858465e+01 |   0.000000e+00 |   1.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\neverything is right now, but don't know what is wrong. Can you please have a look at it?\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with thekernel \");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : JvarMapKernelInterface<Kernel>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\n  Real friction = 3 * g * _sigma[_qp] * op * SumOPGj;\n\n  Real k = 15;\n  Real sgn = tanh(k * total);\n\n  // std::cout << \"total = \" << total << \"sgn = \" << sgn << std::endl;\n\n  ////////////////////\n  Real abs_total = std::abs(total);\n  Real abs_friction = std::abs(friction);\n\n  // smooth condition\n  Real alpha = 20; // Adjust alpha for how sharp you want the transition\n\n  // Real smooth_condition = 1.0 / (1.0 + exp(-alpha * (abs_total - abs_friction - 0.306)));\n  // if (smooth_condition < 1e-3)\n  //   smooth_condition = 0.0;\n  Real tanh_term = tanh(alpha * (abs_total - abs_friction - 0.306));\n  Real smooth_condition = 0.5 * (1.0 + tanh_term);\n  if (smooth_condition < 1e-5)\n    smooth_condition = 0.0;\n  // std::cout << \"abs_total - abs_friction = \" << abs_total - abs_friction\n  //           << \"smooth_condition = \" << smooth_condition << std::endl;\n  ////////////////////\n\n  Real Res = ((_test[_i][_qp] * _mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n              (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]) -\n              (_test[_i][_qp] * sgn * 3 * _sigma[_qp] * g * op * SumOPGj));\n\n  return _L[_qp] * (smooth_condition * Res);\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\n  Real friction = 3 * g * _sigma[_qp] * op * SumOPGj;\n\n  const Real k = 15;\n  Real sgn = tanh(k * total);\n\n  // Derivatives wrt op\n  Real dtotal_dopi = _phi[_j][_qp] * _mu[_qp] * (3 * op * op - 1 + 3 * SumOPj) +\n                     (_grad_phi[_j][_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n  Real dfriction_dopi = _phi[_j][_qp] * 3 * g * _sigma[_qp] * SumOPGj;\n  Real dsgn_dopi = k * pow(1 / cosh(k * total), 2) * dtotal_dopi;\n\n  ////////////////////\n  Real abs_total = std::abs(total);\n  Real abs_friction = std::abs(friction);\n\n  // smooth condition\n  Real alpha = 20; // Adjust alpha for how sharp you want the transition\n  // Real smooth_condition = 1.0 / (1.0 + exp(-alpha * (abs_total - abs_friction - 0.306)));\n  // if (smooth_condition < 1e-3)\n  //   smooth_condition = 0.0;\n  Real tanh_term = tanh(alpha * (abs_total - abs_friction - 0.306));\n  Real smooth_condition = 0.5 * (1.0 + tanh_term);\n  if (smooth_condition < 1e-5)\n    smooth_condition = 0.0;\n  // Sign of total and friction\n  Real sgn_total = (total > 0) - (total < 0);          // Sign function for total\n  Real sgn_friction = (friction > 0) - (friction < 0); // Sign function for friction\n\n  // Derivative of the smooth condition wrt op\n  // Real dsmooth_condition_dopi = alpha * smooth_condition * (1.0 - smooth_condition) *\n  //                              (sgn_total * dtotal_dopi - sgn_friction * dfriction_dopi);\n  Real dsmooth_condition_dopi = 0.5 * (1.0 - pow(tanh_term, 2)) * alpha *\n                                (sgn_total * dtotal_dopi - sgn_friction * dfriction_dopi);\n  ////////////////\n\n  Real Res = ((_test[_i][_qp] * _mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n              (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]) -\n              (_test[_i][_qp] * sgn * 3 * _sigma[_qp] * g * op * SumOPGj));\n\n  // Calculate Jacobian\n  Real Jac = ((_test[_i][_qp] * _mu[_qp] * _phi[_j][_qp] * (3 * op * op - 1 + 3 * SumOPj)) +\n              (_grad_phi[_j][_qp] * _kappa[_qp] * _grad_test[_i][_qp]) -\n              ((_test[_i][_qp] * _phi[_j][_qp] * 3 * _sigma[_qp] * g * SumOPGj * sgn) +\n               (_test[_i][_qp] * 3 * _sigma[_qp] * g * op * SumOPGj * dsgn_dopi)));\n\n  return _L[_qp] * (smooth_condition * Jac + dsmooth_condition_dopi * Res);\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  const unsigned int cvar = mapJvarToCvar(jvar);\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int a = 0; a < _op_num; ++a)\n  {\n    SumOPj += other_ops[a] * other_ops[a];\n    SumOPGj += other_ops[a];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n  Real friction = 3 * _sigma[_qp] * op * g * SumOPGj;\n\n  Real k = 15;\n  Real sgn = tanh(k * total);\n\n  Real Res = ((_test[_i][_qp] * _mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n              (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]) -\n              (_test[_i][_qp] * sgn * 3 * _sigma[_qp] * g * op * SumOPGj));\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      Real dSumOPGj = _phi[_j][_qp];\n\n      // Derivatives wrt opj\n      Real dtotal_dopj = _mu[_qp] * (3 * op * dSumOPj);\n      Real dfriction_dopj = 3 * _sigma[_qp] * g * op * dSumOPGj;\n      Real dsgn_dopj = k * pow(1 / cosh(k * total), 2) * dtotal_dopj;\n\n      ////////////////////\n      Real abs_total = std::abs(total);\n      Real abs_friction = std::abs(friction);\n\n      // smooth condition\n      Real alpha = 20; // Adjust alpha for how sharp you want the transition\n      // Real smooth_condition = 1.0 / (1.0 + exp(-alpha * (abs_total - abs_friction - 0.306)));\n      // if (smooth_condition < 1e-3)\n      //   smooth_condition = 0.0;\n      Real tanh_term = tanh(alpha * (abs_total - abs_friction - 0.306));\n      Real smooth_condition = 0.5 * (1.0 + tanh_term);\n      if (smooth_condition < 1e-5)\n        smooth_condition = 0.0;\n      Real sgn_total = (total > 0) - (total < 0);          // Sign function for total\n      Real sgn_friction = (friction > 0) - (friction < 0); // Sign function for friction\n\n      // Derivative of the smooth condition wrt opj\n      // Real dsmooth_condition_dopj = alpha * smooth_condition * (1.0 - smooth_condition) *\n      //                              (sgn_total * dtotal_dopj - sgn_friction * dfriction_dopj);\n      Real dsmooth_condition_dopj = 0.5 * (1.0 - pow(tanh_term, 2)) * alpha *\n                                    (sgn_total * dtotal_dopj - sgn_friction * dfriction_dopj);\n      ////////////////\n\n      Real offJac = _test[_i][_qp] * ((_mu[_qp] * 3 * op * dSumOPj) -\n                                      (sgn * 3 * _sigma[_qp] * g * op * dSumOPGj +\n                                       3 * _sigma[_qp] * g * op * SumOPGj * dsgn_dopj));\n\n      return _L[_qp] * (smooth_condition * offJac + dsmooth_condition_dopj * Res);\n    }\n  return 0;\n}",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11033167",
                  "updatedAt": "2024-10-23T19:13:56Z",
                  "publishedAt": "2024-10-23T19:13:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is this PJFNK or Newton?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11034717",
                          "updatedAt": "2024-10-23T23:29:57Z",
                          "publishedAt": "2024-10-23T23:29:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The Jacobian debugger was made with NEWTON, The output shown above was using PJFNK",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11034723",
                          "updatedAt": "2024-10-23T23:33:30Z",
                          "publishedAt": "2024-10-23T23:31:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If it's converging look at improving the preconditioning or reducing the order parameter further\nIf it s not converging look at the troubleshooting failed solves page for more advice on debugging it. Notably the singular value check",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11042963",
                          "updatedAt": "2024-10-24T15:58:46Z",
                          "publishedAt": "2024-10-24T15:58:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am currently having 6500 grains and order parameters are 8. So I think I am already at the lowest number there. Coming to the convergence, I do get convergence but the time steps are little smaller.  For example one of the time steps\n\nThe time step here is 0.0069 and the time of simulation is 371.939 at 2132th time step and it took 12 hrs on 500 cores to reach here. Now with this speed, it is impossible to reach the time of 7e4 sec. so now I think I need to choose the solvers. But there are so many options. I don't know which to use. Because for every option I need to wait for 12 hrs where this small timesteps are appearing. I understand FEM methods are slower than Finite difference method. But this time step is really small.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11045945",
                          "updatedAt": "2024-10-24T22:08:07Z",
                          "publishedAt": "2024-10-24T22:08:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can use checkpoint to restart right when the problem appear. You should not need to wait 12 hours each time",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11046440",
                          "updatedAt": "2024-10-24T23:52:16Z",
                          "publishedAt": "2024-10-24T23:52:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ideally the nonlinear solver would be converging the simulations a little tighter than 1e-3 and would be able to take larger time steps.\nHowever if larger time steps are not possible, converging the solve tighter will slow down the solver further",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11081854",
                          "updatedAt": "2024-10-29T02:45:16Z",
                          "publishedAt": "2024-10-29T02:45:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am currently running two simulations with different tolerances. 1e-3  and 1e-6, I am finding that 1e-6 is much slower than 1e-3 and time steps are also larger for 1e-3. I can go upto 0.5 sec per timestep but I need to run this simulation for t=1e4 to see the significant effect of the model. Earlier work that I used as a reference was made and simulated in finite difference method and it was much faster than FEM used in MOOSE. I will definitely try to optimize the simulation conditions later. Thank you for all the help and patience.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11082366",
                          "updatedAt": "2024-10-29T04:23:09Z",
                          "publishedAt": "2024-10-29T04:23:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What time integrator have you tried? (specified using the 'scheme' parameter of the executioner)",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11087592",
                          "updatedAt": "2024-10-29T13:45:54Z",
                          "publishedAt": "2024-10-29T13:45:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "[Executioner]\n    type = Transient\n    scheme = bdf2\n    solve_type = PJFNK #Preconditioned JFNK (default)\n    petsc_options_iname = '-pc_type -pc_hypre_type -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths  -pc_hypre_boomeramg_max_levels  -pc_hypre_boomeramg_coarsen_type  -pc_hypre_boomeramg_interp_type  -pc_hypre_boomeramg_P_max  -pc_hypre_boomeramg_truncfactor'\n    petsc_options_value = 'hypre boomeramg  0.15 1 2 25 HMIS FF 1 0.3'\n    steady_state_detection = true\n    steady_state_start_time = 0\n    steady_state_tolerance = 1e-4\n    automatic_scaling = true\n    compute_scaling_once = false\n    l_tol = 1.0e-5\n    l_abs_tol = 1e-5\n    l_max_its = 50\n    nl_abs_tol = 1e-5\n    nl_max_its = 50\n    nl_rel_tol = 1.0e-5\n    start_time = 0.0\n    #num_steps = 2\n    end_time = 2000000\n    dtmin = 1e-20\n    #dt = 0.1\n    #[Adaptivity]\n    #  initial_adaptivity = 2\n    #  refine_fraction = 0.7\n    #  coarsen_fraction = 0.1\n    #  max_h_level = 4\n    #[]\n[TimeStepper]\n    type = IterationAdaptiveDT\n    cutback_factor = 0.1\n    growth_factor = 1.1\n    dt = 0.1\n    optimal_iterations = 8\n[]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11089298",
                          "updatedAt": "2024-10-29T15:55:01Z",
                          "publishedAt": "2024-10-29T15:54:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "How is bdf2 compared to implicit Euler?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11089446",
                          "updatedAt": "2024-10-29T16:00:15Z",
                          "publishedAt": "2024-10-29T16:00:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello,\nAfter trying everything I am still struggling to get the desired results.\nTime Step 10682, time = 4660.52, dt = 0.589581\nPre-SMO residual: 0.243836\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 2.443673e-01\n      0 Linear |R| = 2.443673e-01\n      1 Linear |R| = 1.803225e-01\n      2 Linear |R| = 6.084074e-02\n      3 Linear |R| = 2.740365e-02\n      4 Linear |R| = 1.318843e-02\n      5 Linear |R| = 6.770792e-03\n      6 Linear |R| = 3.678059e-03\n      7 Linear |R| = 2.161769e-03\n      8 Linear |R| = 1.231317e-03\n      9 Linear |R| = 7.032720e-04\n     10 Linear |R| = 3.503674e-04\n     11 Linear |R| = 1.708096e-04\n     12 Linear |R| = 8.314164e-05\n 1 Nonlinear |R| = 8.220388e-02\n      0 Linear |R| = 8.220388e-02\n      1 Linear |R| = 2.156492e-02\n      2 Linear |R| = 9.120701e-03\n      3 Linear |R| = 4.020085e-03\n      4 Linear |R| = 1.975502e-03\n      5 Linear |R| = 1.084695e-03\n      6 Linear |R| = 5.722968e-04\n      7 Linear |R| = 2.936753e-04\n      8 Linear |R| = 1.511231e-04\n      9 Linear |R| = 7.514336e-05\n 2 Nonlinear |R| = 1.725675e-02\n      0 Linear |R| = 1.725675e-02\n      1 Linear |R| = 4.358433e-03\n      2 Linear |R| = 1.801668e-03\n      3 Linear |R| = 6.793559e-04\n      4 Linear |R| = 2.876081e-04\n      5 Linear |R| = 1.122580e-04\n      6 Linear |R| = 4.996307e-05\n 3 Nonlinear |R| = 1.595820e-03\n      0 Linear |R| = 1.595820e-03\n      1 Linear |R| = 3.442125e-04\n      2 Linear |R| = 1.387527e-04\n      3 Linear |R| = 4.831790e-05\n 4 Nonlinear |R| = 6.045878e-05\n  Finished Solving                                                                       [ 24.32 s] [ 2124 MB]\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  gr3: 3.166659e-05\n  gr5: 3.894508e-05\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+\n:                :                :                :                :\n|   4.655210e+03 |   5.255854e+03 |   5.000000e-01 |   7.590000e+02 |\n|   4.655799e+03 |   5.255863e+03 |   5.000000e-01 |   7.590000e+02 |\n|   4.656389e+03 |   5.255862e+03 |   5.000000e-01 |   7.590000e+02 |\n|   4.656978e+03 |   5.255863e+03 |   5.000000e-01 |   7.590000e+02 |\n|   4.657568e+03 |   5.262798e+03 |   5.000000e-01 |   7.580000e+02 |\n|   4.658158e+03 |   5.262801e+03 |   5.000000e-01 |   7.580000e+02 |\n|   4.658747e+03 |   5.262800e+03 |   5.000000e-01 |   7.580000e+02 |\n|   4.659337e+03 |   5.262795e+03 |   5.000000e-01 |   7.580000e+02 |\n|   4.659926e+03 |   5.262800e+03 |   5.000000e-01 |   7.580000e+02 |\n|   4.660516e+03 |   5.262798e+03 |   5.000000e-01 |   7.580000e+02 |\n+----------------+----------------+----------------+----------------+\n\nSteady-State Relative Differential Norm: 0.00168314\n\nthe system now only have 758 grains yet the time step is so small.",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102703",
                  "updatedAt": "2024-10-30T16:42:54Z",
                  "publishedAt": "2024-10-30T16:42:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "have you tried a more aggressive growth?\n[TimeStepper]\n    type = IterationAdaptiveDT\n    cutback_factor = 0.5\n    growth_factor = 2\n    dt = 0.1\n    optimal_iterations = 10\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102747",
                          "updatedAt": "2024-10-30T16:45:38Z",
                          "publishedAt": "2024-10-30T16:45:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "yes. But the solution doesn't converge and ends up with same 0.5-0.8 per time step. also optimal iterations is not allowing the time step to increase further. it stays with same dt even after 10 iterations if optimal_iterations = 10.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102774",
                          "updatedAt": "2024-10-30T16:48:24Z",
                          "publishedAt": "2024-10-30T16:48:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am running this simulation for 4 days on 500 cores and I was only able to get\n\nThe simulation was supposed to come to halt after some time but the time it take to reach there is VERY LARGE.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102816",
                          "updatedAt": "2024-10-30T16:51:22Z",
                          "publishedAt": "2024-10-30T16:51:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what is the legend here?\nhow fine is the mesh again? Did you get improvements from AMR?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102908",
                          "updatedAt": "2024-10-30T16:59:07Z",
                          "publishedAt": "2024-10-30T16:59:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "If you look at my code I posted here there is a variable g (representing the friction pressure) The legend is that friction pressure, it is basically a resistance to grain growth driving pressure. As g increases the resistance increases and after sometime when the driving pressure is less than or equal to friction pressure the grain growth stops.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102926",
                          "updatedAt": "2024-10-30T17:01:04Z",
                          "publishedAt": "2024-10-30T17:01:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The mesh is fine such that I am getting at least 4-5 mesh points at the interface.  Adaptive meshing is good theoretically, but for large simulation I have seen that the time it takes to reconfigure the mesh is much larger than the actual iterations. And it happens after every time steps. so e.g. if one time step solve takes about 10 sec, then the adapting mesh step was taking more than 80-90 sec. It was way more slower then. So I removed the adapting step and after that I could reach to this time as shown in figure. otherwise it would have been half of what I got now.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102975",
                          "updatedAt": "2024-10-30T17:06:01Z",
                          "publishedAt": "2024-10-30T17:06:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Would it help to do it less often than every time step?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11104365",
                          "updatedAt": "2024-10-30T19:22:58Z",
                          "publishedAt": "2024-10-30T19:22:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Yes that was the reason I moved to non adaptive mesh,\nBut, How to do it? I don't think we can control that. Turning ON adaptive meshing will automatically introduce that step as grain boundary changes after every time step so are the nonlinear variables.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11104388",
                          "updatedAt": "2024-10-30T19:26:48Z",
                          "publishedAt": "2024-10-30T19:26:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I saw this in one of the other discussion. Does my problem comes under the same criteria where MOOSE is very slow? Just wondering! I am here trying to replicate what was done before in finite difference method. I understand there is always difference in two methods, but can you estimate the difference as I am very new in the field of FEM and phase field.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11104494",
                          "updatedAt": "2024-10-30T19:36:56Z",
                          "publishedAt": "2024-10-30T19:36:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No this kind of study does not apply to anything else than their one case. Besides no one has enough expertise in 5 different tools to perform good timing comparisons so even in that case it's not clear the conclusions would stand\nFEM will be more expensive than finite difference for sure, but it will handle unstructured meshes which should have less dispersion than a regular grid.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11104823",
                          "updatedAt": "2024-10-30T20:21:10Z",
                          "publishedAt": "2024-10-30T20:21:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello!\nIN the following kernel I just want to know if this is correct. If you see 'total' variable it has _grad_test[_qp]\nin residual we can see _test[_qp] multiplied by _grad_test[_qp].\nis this correct? can we multiply _test and _grad_test?\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\n  Real friction = 3 * g * _sigma[_qp] * op * SumOPGj;\n\n  Real k = 20;\n  Real sgn = std::tanh(k * total);\n  if (sgn > 0.5)\n    sgn = 1;\n  if (sgn < 0.5)\n    sgn = 0;\n\n  ////////////////////\n  Real abs_total = std::abs(total);\n  Real abs_friction = std::abs(friction);\n\n  // smooth condition\n  Real alpha = 40; // Adjust alpha for how sharp you want the transition\n\n  Real tanh_term = std::tanh(alpha * (abs_total - abs_friction - 0.15));\n  Real smooth_condition = 0.5 * (1.0 + tanh_term);\n  if (smooth_condition < 1e-4)\n    smooth_condition = 0;\n  // std::cout << \"difference\" << abs_total - abs_friction << std::endl;\n  // std::cout << \"condition\" << smooth_condition << std::endl;\n  ////////////////////\n\n  Real Res = (_test[_i][_qp] * ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) -\n                                (sgn * 3 * _sigma[_qp] * g * op * SumOPGj)) +\n              (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]));\n  // std::cout << \"Res\" << Res << std::endl;\n  return _L[_qp] * (smooth_condition * Res);\n}\n\nThank you",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132279",
                  "updatedAt": "2024-11-03T03:12:01Z",
                  "publishedAt": "2024-11-03T03:11:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is this correct? can we multiply _test and _grad_test?\n\nwe could in theory, but I don't see what weak format ends up with such a term. Maybe write down the derivation that gets you to this term",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132475",
                          "updatedAt": "2024-11-03T04:29:00Z",
                          "publishedAt": "2024-11-03T04:29:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132550",
                          "updatedAt": "2024-11-03T04:55:31Z",
                          "publishedAt": "2024-11-03T04:55:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So this is the strong form. Do you have the derivation of the weak form from the strong form?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132580",
                          "updatedAt": "2024-11-03T05:10:29Z",
                          "publishedAt": "2024-11-03T05:10:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Its a bit complecated but if you loot at hte second term of R, you see condition is multiplied with total, which has _grad_test",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132620",
                          "updatedAt": "2024-11-03T05:30:44Z",
                          "publishedAt": "2024-11-03T05:30:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I think the problem is in\nReal total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\nI just need the value of driving pressure (i.e. total, which is basically sum of residual of ACGrGrPoly and ACInterface) here but because of _grad_u[_qp] I have to use _grad_test[_qp]. if somehow I can make this term real without _grad_test[_qp] I think the problem can be solved.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132649",
                          "updatedAt": "2024-11-03T05:45:03Z",
                          "publishedAt": "2024-11-03T05:42:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Its a bit complecated but if you loot at hte second term of R, you see condition is multiplied with total, which has _grad_test\n\nI dont think that s quite right.\nIf you look at your strong form, you start with\ndeta/dt = condition (total - sign * friction)\nbut then you derive the weak form for condition, total, sign and friction separately. Which is not right, you should be deriving them for these two terms that are summed not for terms that are multiplied.\ndeta/dt = condition (total )  - (condition * sign * friction)",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11134222",
                          "updatedAt": "2024-11-03T12:56:38Z",
                          "publishedAt": "2024-11-03T12:56:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Hello!\nI changed my residual as you suggested\nReal Res = (smooth_condition * ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)))) +\n               (smooth_condition * ((_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]))) -\n               (smooth_condition * (sgn * 3 * _sigma[_qp] * g * op * SumOPGj));\n\nnow the Jacobian debugger shows\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.009893 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.008961 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.016752 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.009092 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.019589 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.012455 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.003363 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.019496 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.014487 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.016370 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.015753 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.016558 %)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000262 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000583 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000066 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001567 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000276 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.025711 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000180 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001715 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000576 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.036075 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.012293 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000645 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.003952 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.149484 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.004675 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001425 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.642942 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.004777 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001566 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.024350 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000094 %)",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11136235",
                          "updatedAt": "2024-11-03T19:40:06Z",
                          "publishedAt": "2024-11-03T19:39:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "could be good enough. Are convergence and results improved?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11136285",
                          "updatedAt": "2024-11-03T19:54:04Z",
                          "publishedAt": "2024-11-03T19:54:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I think so\n0p02I.txt\nIs this looking good?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11136293",
                          "updatedAt": "2024-11-03T19:56:45Z",
                          "publishedAt": "2024-11-03T19:56:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to embed a beam element in 3d solid elements?",
          "author": {
            "login": "xiekai-mc"
          },
          "bodyText": "I am trying to embed fibers (modeled with 1D beam elements later) in the matrix (3d solid elements), like this in Gmsh\n\nI have reviewed similar discussions #24887 and #24174, but I feel that they do not address this issue.\nI can generate 1D mesh and 3d mesh separately in Gmsh. For example\nSetFactory(\"OpenCASCADE\");\n//+\nBox(1) = {0, 0, 0, 1, 1, 1};\n//+\nPoint(9) = {0.2, 0.2, 0.2, 1.0};\n//+\nPoint(10) = {0.8, 0.8, 0.8, 1.0};\n//+\nLine(13) = {9, 10};\n//+\nCurve{13} In Volume{1};\n//+\nPhysical Curve(\"fiber\", 21) = {13};\nMesh.SaveAll = 0; \n\nMesh 3;\nSave \"fibers.msh\";\n\nPhysical Surface(\"left\", 13) = {1};\n//+\nPhysical Surface(\"right\", 14) = {2};\n//+\nPhysical Surface(\"top\", 15) = {4};\n//+\nPhysical Surface(\"bottom\", 16) = {3};\n//+\nPhysical Surface(\"front\", 17) = {6};\n//+\nPhysical Surface(\"back\", 18) = {5};\n//+\nPhysical Volume(\"block\", 20) = {1};\nMesh.SaveAll = 1; \n\nSave \"matrix.msh\";\n\nHowever, the 1D boundary \"fiber\" in the 3D mesh is not loaded using FileMeshGenerator.\nSo it seems I cannot use StitchedMeshGenerator either, because I cannot find the corresponding boundary positions between the two meshes.\nCould you provide any suggestions or hints? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/28680",
          "updatedAt": "2024-11-03T09:19:28Z",
          "publishedAt": "2024-09-21T23:07:26Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe Gmsh reader must not be supporting these mixed dimensional mesh if it is not working.\nHow did you check it is not loaded? What does the mesh summary show in the --mesh-only mode?\nThe StitchedMeshGenerator is a good idea. For that to work you will need to:\n\nload the two meshes in two FileMeshGenerator\ncreate nodeset(s) for the ends of the 1D mesh, both in the 1D mesh and the 3D mesh\nuse the nodesets for stitiching",
                  "url": "https://github.com/idaholab/moose/discussions/28680#discussioncomment-10717980",
                  "updatedAt": "2024-09-22T13:21:05Z",
                  "publishedAt": "2024-09-22T13:21:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jmeier"
                  },
                  "bodyText": "Dear @xiekai-mc ,\nThe MSH file format does not differentiate between \"sidesets\" and \"elements of lower dimensionality\". Your beam is embedded in volume elements - this is here considered as \"element of lower dimensionality\". So Moose needs a hint, if those lines are sidesets (default) or elements.\nYou can do that by (1) appending \"lower_dimensional_block\" to the name of the beam or (2) after the name (the second option looks nicer, but you have to edit the msh file):\n$MeshFormat\n4.1 0 8\n$EndMeshFormat\n$PhysicalNames\n...\n0 1 \"PointA\"                                          \u2190 sideset (node)\n1 2 \"topleftedge\"                                     \u2190 sideset (line)\n1 3 \"lineSignPole000_lower_dimensional_block\"         \u2190 block with beam-elements\n1 4 \"lineSignPole001\" lower_dimensional_block         \u2190 block with beam-elements\n2 5 \"BoundaryZMin\"                                    \u2190 sideset (surface)\n2 6 \"Sign\" lower_dimensional_block                    \u2190 block with shell-elements\n...\n\n(Do not copy the \u2190 block with beam-elements. This is just for illustration.)",
                  "url": "https://github.com/idaholab/moose/discussions/28680#discussioncomment-11133247",
                  "updatedAt": "2024-11-03T09:19:29Z",
                  "publishedAt": "2024-11-03T09:19:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A question about stiffness matrix, assembly and assembly order in MOOSE",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear MOOSE experts,\nI am writing this to inquire about stiffness matrix, assembly and assembly order in the framework.\nFirst, is there any documentation regarding the stiffness matrix (or LHS) and RHS in Navier-Stokes and Phase-Field modules?\nSecond, if someone couples the two, the framework forms the assembled matrix. But what would be the order? (Variables are velocity vector, pressure, order parameter and chemical potential). -mat_view gives the matrix data, but how about the order of nonlinear variables? Is there anyway to see the right-hand-side of the equations too or we can just see the stiffness matrix?\nThanks for your assistance.\nRegards,",
          "url": "https://github.com/idaholab/moose/discussions/28626",
          "updatedAt": "2024-11-03T01:53:39Z",
          "publishedAt": "2024-09-16T02:07:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nFirst, is there any documentation regarding the stiffness matrix (or LHS) and RHS in Navier-Stokes and Phase-Field modules?\n\nYes in the sense that all the kernels are documented for Navier Stokes, and many of them for phase field (but it's not complete yet there).\nThis tells you how we assemble the residual and Jacobian.\nIn most solves (linear finite volume being the exception I know), we dont form the RHS explicitly. If you want to create it, you can use the tagging system on each kernel that should contribute to it\nhttps://mooseframework.inl.gov/source/interfaces/TaggingInterface.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28626#discussioncomment-10659765",
                  "updatedAt": "2024-09-16T13:25:51Z",
                  "publishedAt": "2024-09-16T13:25:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Ok. I had a question regarding obtaining the stiffness matrix. Considering solving the transient implicit Phase-field in Split form (c order parameter, w chemical potential), -mat_view returns this matrix (it is the sparsity pattern). I reorder it in this way:[k_cc k_cw;k_wc k_ww][c;w]=[F_1;F_2].\nWhat exactly this matrix could be? I am asking this because stiffness matrix sdoes not contain time derivative terms. Am I right? But the figure has the dc/dt term contributions. Can this output be kind of sum of the mass and stiffenss matrix?",
                          "url": "https://github.com/idaholab/moose/discussions/28626#discussioncomment-10698249",
                          "updatedAt": "2024-09-19T22:00:44Z",
                          "publishedAt": "2024-09-19T22:00:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sorry forgot to reply.\nYes this is the Jacobian not the stiffness matrix. You would need to remove the time derivative terms at least.",
                          "url": "https://github.com/idaholab/moose/discussions/28626#discussioncomment-11132119",
                          "updatedAt": "2024-11-03T01:53:39Z",
                          "publishedAt": "2024-11-03T01:53:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problems reading material property in InterfaceKernel",
          "author": {
            "login": "bmurgas-LANL"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello Moose community,\nI am using a crystal plasticity model where I define material properties that I need to use inside a modified version of ConservativeAdvection kernel and InterfaceDiffusion interface kernel.\nWhen I read the property in the ConservativeAdvection kernel, the material properties are correct and have the same value computed in the crystal plasticity model.\nHowever,  when I read the material properties in the InterfaceDiffusion interface kernel the variables are set to zero. Do you know why this can happen?\nThis is the validParameters and constructor of the \"ConservativeDiffusion\" kernel:\nInputParameters\nConservativeAdvectionDislocation::validParams()\n{\n  InputParameters params = Kernel::validParams();\n  params.addClassDescription(\n      \"Conservative form of $\\\\nabla \\\\cdot \\\\vec{v} u$ which in its weak \"\n      \"form is given by: $(-\\\\nabla \\\\psi_i, \\\\vec{v} u)$. \"\n      \"Velocity is defined as a material property computed in DiscoFluxCPStressUpdate\");\n  MooseEnum upwinding_type(\"none full\", \"none\");\n  params.addParam<MooseEnum>(\"upwinding_type\",\n                             upwinding_type,\n                             \"Type of upwinding used.  None: Typically results in overshoots and \"\n                             \"undershoots, but numerical diffusion is minimized.  Full: Overshoots \"\n                             \"and undershoots are avoided, but numerical diffusion is large\");\n  MooseEnum dislocation_character(\"edge screw\", \"edge\");\n  params.addRequiredParam<MooseEnum>(\n      \"dislocation_character\", dislocation_character, \"Character of dislocation\");\n  MooseEnum dislocation_sign(\"positive negative\", \"positive\");\n  params.addRequiredParam<MooseEnum>(\"dislocation_sign\", dislocation_sign, \"Sign of dislocation\");\n  params.addRequiredParam<int>(\"slip_system_index\",\n                               \"Slip system index to get slip direction\"\n                               \"FCC: 1 to 12.\");\n  return params;\n}\n\n\nConservativeAdvectionDislocation::ConservativeAdvectionDislocation(\n    const InputParameters & parameters)\n  : Kernel(parameters),\n    _dislocationcharacter(\n        getParam<MooseEnum>(\"dislocation_character\").getEnum<DislocationCharacter>()),\n    _dislocationsign(getParam<MooseEnum>(\"dislocation_sign\").getEnum<DislocationSign>()),\n    _slip_direction_edge(getMaterialProperty<std::vector<RealVectorValue>>(\"slip_direction_edge\")),\n    _slip_plane_normalboth(\n        getMaterialProperty<std::vector<RealVectorValue>>(\"slip_plane_normalboth\")),\n    _slip_system_index(getParam<int>(\"slip_system_index\")),\n    _dislo_velocity_CP_edge(getMaterialProperty<std::vector<Real>>(\"dislo_velocity_edge\")),\n    _dislo_velocity_CP_screw(getMaterialProperty<std::vector<Real>>(\"dislo_velocity_screw\")),\n    _upwinding(getParam<MooseEnum>(\"upwinding_type\").getEnum<UpwindingType>()),\n    _u_nodal(_var.dofValues()),\n    _upwind_node(0),\n    _dtotal_mass_out(0)\n{\n}\n\nThis is the validParameters and constructor of the \"InterfaceDiffusion\" interface kernel:\nInputParameters\nInterfaceDiffusionDislocation::validParams()\n{\n  InputParameters params = InterfaceKernel::validParams();\n  params.addParam<Real>(\"density_critical\", 1.0,\"Critical density beyond which there will be dislocation transfer across Grain Boundary\"); \n  params.addParam<Real>(\"tau_critical\", 0.0,\"Critical resolved shear stres beyond which there will be dislocation transfer across Grain Boundary\");   \n  MooseEnum dislocation_character(\"edge screw\", \"edge\");\n  params.addParam<MooseEnum>(\"dislocation_character\", dislocation_character, \"Character of dislocation\");\n  MooseEnum dislocation_sign(\"positive negative\", \"positive\");\n  params.addParam<MooseEnum>(\"dislocation_sign\", dislocation_sign, \"Sign of dislocation\");\n  params.addRequiredParam<int>(\"slip_system_index\",\n                               \"Slip system index to get slip direction\"\n                               \"FCC: 1 to 12.\");\n  params.addRequiredParam<int>(\"slip_system_index_neighbor\",\n                               \"Slip system index to get slip direction of the neighbor\"\n                               \"FCC: 1 to 12.\");\n  params.addClassDescription(\n      \"The kernel is utilized to establish flux equivalence on an interface for dislocation\" \n      \"assuming a divergence free velocity.\");\n  return params;\n}\n\nInterfaceDiffusionDislocation::InterfaceDiffusionDislocation(const InputParameters & parameters)\n  : InterfaceKernel(parameters),\n    _density_critical(getParam<Real>(\"density_critical\")),\n    _tau_critical(getParam<Real>(\"tau_critical\")),\n    _slip_system_index(getParam<int>(\"slip_system_index\")),\n    _slip_system_index_neighbor(getParam<int>(\"slip_system_index_neighbor\")),\n    _dislo_velocity_CP_edge(getMaterialProperty<std::vector<Real>>(\"dislo_velocity_edge\")),\n    _dislo_velocity_CP_edge_neighbor(getNeighborMaterialProperty<std::vector<Real>>(\"dislo_velocity_edge\")),\n    _dislocationcharacter(getParam<MooseEnum>(\"dislocation_character\").getEnum<DislocationCharacter>()),\n    _dislocationsign(getParam<MooseEnum>(\"dislocation_sign\").getEnum<DislocationSign>()), \n    _slip_direction_edge(getMaterialProperty<std::vector<RealVectorValue>>(\"slip_direction_edge\")),\n    _slip_plane_normalboth(getMaterialProperty<std::vector<RealVectorValue>>(\"slip_plane_normalboth\")),\n    _slip_direction_edge_neighbor(getNeighborMaterialProperty<std::vector<RealVectorValue>>(\"slip_direction_edge\")),\n    _slip_plane_normalboth_neighbor(getNeighborMaterialProperty<std::vector<RealVectorValue>>(\"slip_plane_normalboth\")),\n    _tau(getMaterialProperty<std::vector<Real>>(\"applied_shear_stress\")),\n    _slip_resistance(getMaterialProperty<std::vector<Real>>(\"slip_resistance\"))\n{\n}\n\nIn the interface kernel, the only variable that is correct is _slip_resistance. The other variables are always set to zero. Can you please help me with this.\nThanks a lor for your help!\nBest,\nBrayan",
          "url": "https://github.com/idaholab/moose/discussions/28908",
          "updatedAt": "2024-11-03T00:44:45Z",
          "publishedAt": "2024-10-22T21:56:32Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou should share your input and the header as well for the interface kernel.\nThe interface kernel is set to act on an internal boundary between two subdomains right?",
                  "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11029868",
                  "updatedAt": "2024-10-23T14:00:05Z",
                  "publishedAt": "2024-10-23T14:00:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bmurgas-LANL"
                          },
                          "bodyText": "Hi @GiudGiud,\nThank you for the reply.\nThis is the repository I am working on: https://github.com/bmurgas-LANL/discopanther\nI declare the property in the file DiscoFluxCPStressUpdate.C\nFor simplicity, I created a copy of the interfacediffusion kernel named interfacediffusiontest in https://github.com/bmurgas-LANL/discopanther/blob/main/src/interfacekernels/InterfaceDiffusionTest.C\nIn this modified interfaceDiffusion kernel I just tried to read the _slip_direction_edge material property created in DiscoFluxCPStressUpdate.C .\nThis is the source file:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"InterfaceDiffusionTest.h\"\n\nregisterMooseObject(\"MooseApp\", InterfaceDiffusionTest);\n\nInputParameters\nInterfaceDiffusionTest::validParams()\n{\n  InputParameters params = InterfaceKernel::validParams();\n  params.addParam<MaterialPropertyName>(\"D\", \"D\", \"The diffusion coefficient.\");\n  params.addParam<MaterialPropertyName>(\n      \"D_neighbor\", \"D_neighbor\", \"The neighboring diffusion coefficient.\");\n  params.addClassDescription(\n      \"The kernel is utilized to establish flux equivalence on an interface for variables.\");\n  return params;\n}\n\nInterfaceDiffusionTest::InterfaceDiffusionTest(const InputParameters & parameters)\n  : InterfaceKernel(parameters),\n    _D(getMaterialProperty<Real>(\"D\")),\n    _D_neighbor(getNeighborMaterialProperty<Real>(\"D_neighbor\")),\n    _slip_direction_edge(getMaterialProperty<std::vector<RealVectorValue>>(\"slip_direction_edge\")),\n    _slip_plane_normalboth(\n        getMaterialProperty<std::vector<RealVectorValue>>(\"slip_plane_normalboth\"))\n{\n}\n\nReal\nInterfaceDiffusionTest::computeQpResidual(Moose::DGResidualType type)\n{\n  Real r = 0;\n\n  switch (type)\n  {\n    case Moose::Element:\n      r = _test[_i][_qp] * -_D_neighbor[_qp] * _grad_neighbor_value[_qp] * _normals[_qp];\n      break;\n\n    case Moose::Neighbor:\n      r = _test_neighbor[_i][_qp] * _D[_qp] * _grad_u[_qp] * _normals[_qp];\n      break;\n  }\n\n  return r;\n}\n\nReal\nInterfaceDiffusionTest::computeQpJacobian(Moose::DGJacobianType type)\n{\n  Real jac = 0;\n\n  switch (type)\n  {\n    case Moose::ElementElement:\n    case Moose::NeighborNeighbor:\n      break;\n\n    case Moose::NeighborElement:\n      jac = _test_neighbor[_i][_qp] * _D[_qp] * _grad_phi[_j][_qp] * _normals[_qp];\n      break;\n\n    case Moose::ElementNeighbor:\n      jac = _test[_i][_qp] * -_D_neighbor[_qp] * _grad_phi_neighbor[_j][_qp] * _normals[_qp];\n      break;\n  }\n\n  return jac;\n}\n\nAnd this is the header file:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#pragma once\n\n#include \"InterfaceKernel.h\"\n\n/**\n * DG kernel for interfacing diffusion between two variables on adjacent blocks\n */\nclass InterfaceDiffusionTest : public InterfaceKernel\n{\npublic:\n  static InputParameters validParams();\n\n  InterfaceDiffusionTest(const InputParameters & parameters);\n\nprotected:\n  virtual Real computeQpResidual(Moose::DGResidualType type) override;\n  virtual Real computeQpJacobian(Moose::DGJacobianType type) override;\n\n  const MaterialProperty<Real> & _D;\n  const MaterialProperty<Real> & _D_neighbor;\n\n  // dislocation velocities\n  // slip direction and normal element\n  const MaterialProperty<std::vector<RealVectorValue>> & _slip_direction_edge;\n  const MaterialProperty<std::vector<RealVectorValue>> & _slip_plane_normalboth;\n};\n\nIn this case, the two material properties are not correct. The value is always zero.\nThanks again for your help.\nBest,\nBrayan",
                          "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11031052",
                          "updatedAt": "2024-10-23T15:32:39Z",
                          "publishedAt": "2024-10-23T15:32:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bmurgas-LANL"
                          },
                          "bodyText": "I forgot the input file:\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh] \n  [./nepermesh]\n    type = FileMeshGenerator\n    file = '/Users/bmurgas/workspace/meshfiles/bar/px3-bar/px3_bar_hex8_cl16e-3.e'\n  [../]\n  [create_sideset]\n    type = SideSetsFromNodeSetsGenerator\n    input = nepermesh\n  []\n\n  # [./x0_modifier]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = nepermesh\n  #   new_boundary = x0\n  #   top_right = '0.1 1.1 0.35'\n  #   bottom_left = '-0.1 -0.1 -0.1'\n  # [../]\n  # [./y0_modifier]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = x0_modifier\n  #   new_boundary = y0\n  #   top_right = '1.1 0.1 0.35'\n  #   bottom_left = '-0.1 -0.1 -0.1'\n  # [../]\n  # [./z0_modifier]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = y0_modifier\n  #   new_boundary = z0\n  #   top_right = '1.1 1.1 0.1'\n  #   bottom_left = '-0.1 -0.1 -0.1'\n  # [../]\n  # [./x1_modifier]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = z0_modifier\n  #   new_boundary = x1\n  #   top_right = '1.1 1.1 0.35'\n  #   bottom_left = '0.9 -0.1 -0.1'\n  # [../]\n  # [./y1_modifier]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = x1_modifier\n  #   new_boundary = y1\n  #   top_right = '1.1 1.1 0.35'\n  #   bottom_left = '-0.1 0.9 -0.1'\n  # [../]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n# [Debug]\n#   #show_execution_order = 'ALWAYS'\n#   show_material_props = true\n#   show_var_residual_norms = true\n# []\n\n[Outputs]\n    file_base = method_Discoflux\n    csv = true\n    exodus = true\n    console = true\n[]\n\n[UserObjects]\n  [./prop_read]\n    type = PropertyReadFile\n    prop_file_name = '/Users/bmurgas/workspace/auxfiles/px3-bar-sp10-sp01.inp' #sxori-0-0-0.inp' #px3-bar-sp10-sp01.inp'\n    nprop = 3\n    read_type = block\n    nblock= 3\n  [../]\n[]\n\n[Variables]\n  [./disp_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./disp_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./disp_z]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  # DISLOCATION DENSITIES\n  ## POSITIVE EDGE\n  [./DD_EdgePositive_1]\n    order = FIRST\n    family = LAGRANGE\n    # [./InitialCondition]\n    #   type = FunctionIC\n    #   function = init_rho_edge_pos_1\n    #   # block = 1\n    # [../]\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_2]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_3]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_4]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_5]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_6]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_7]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_8]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_9]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_10]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_11]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_12]\n    order = FIRST\n    family = LAGRANGE\n    # [./InitialCondition]\n    #   type = ConstantIC\n    #   value = 0.5\n    # [../]\n    [./InitialCondition]\n      type = FunctionIC\n      function = init_rho_edge_pos_1\n      # block = 1\n    [../]\n  [../]\n  ## NEGATIVE EDGE\n  [./DD_EdgeNegative_1]\n    order = FIRST\n    family = LAGRANGE\n    # [./InitialCondition]\n    #   type = FunctionIC\n    #   function = init_rho_edge_neg_1\n    #   # block = 1\n    # [../]\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n      # block = 1\n    [../]\n  [../]\n  [./DD_EdgeNegative_2]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_3]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_4]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_5]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_6]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_7]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_8]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_9]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_10]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_11]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC \n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_12]\n    order = FIRST\n    family = LAGRANGE\n    # [./InitialCondition]\n    #   type = ConstantIC\n    #   value = 0.5\n    # [../]\n    [./InitialCondition]\n      type = FunctionIC\n      function = init_rho_edge_neg_1\n      # block = 1\n    [../]\n  [../]\n  # POSITIVE SCREW\n  [./DD_ScrewPositive_1]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_2]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_3]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_4]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_5]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_6]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_7]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_8]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_9]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_10]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_11]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_12]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  ## NEGATIVE Screw\n  [./DD_ScrewNegative_1]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_2]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_3]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_4]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_5]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_6]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_7]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_8]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_9]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_10]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_11]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_12]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n[]\n\n[Functions]\n  [./init_rho_edge_pos_1]\n    type = ParsedFunction\n    value = 'if(x>=0.24,1.0,0.0)*if(x<=0.40,1.0,0.0)*if(z>=0.08,1.0,0.0)*if(z<=0.24,1.0,0.0)*0.4+0.1'\n  [../]\n  [./init_rho_edge_neg_1]\n    type = ParsedFunction\n\t  value = 'if(x>=0.24,1.0,0.0)*if(x<=0.40,1.0,0.0)*if(z>=0.08,1.0,0.0)*if(z<=0.24,1.0,0.0)*0.4+0.1'\n  [../]\n  [./disp_load]\n    type = ParsedFunction\n    value = '0.1*t'\n  [../]\n[]\n\n[Kernels]\n  [./dot_DD_EdgePositive_1]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_1\n  [../]\n  # [./Advection_DD_EdgePositive_1]\n  #   type = ConservativeAdvectionDislocation\n  #   variable = DD_EdgePositive_1\n  #   upwinding_type = full\n  #   dislocation_character = edge\n  #   dislocation_sign = positive\n  #   slip_system_index = 1\n  # [../]\n  [./dot_DD_EdgePositive_2]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_2\n  [../]\n  #   [./Advection_DD_EdgePositive_2]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_2\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 2\n  #   [../]\n  [./dot_DD_EdgePositive_3]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_3\n  [../]\n  #   [./Advection_DD_EdgePositive_3]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_3\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 3\n  #   [../]\n  [./dot_DD_EdgePositive_4]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_4\n  [../]\n  #   [./Advection_DD_EdgePositive_4]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_4\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 4\n  #   [../]\n  [./dot_DD_EdgePositive_5]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_5\n  [../]\n  #   [./Advection_DD_EdgePositive_5]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_5\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 5\n  #   [../]\n  [./dot_DD_EdgePositive_6]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_6\n  [../]\n  #   [./Advection_DD_EdgePositive_6]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_6\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 6\n  #   [../]\n  [./dot_DD_EdgePositive_7]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_7\n  [../]\n  #   [./Advection_DD_EdgePositive_7]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_7\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 7\n  #   [../]\n  [./dot_DD_EdgePositive_8]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_8\n  [../]\n  #   [./Advection_DD_EdgePositive_8]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_8\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 8\n  #   [../]\n  [./dot_DD_EdgePositive_9]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_9\n  [../]\n  #   [./Advection_DD_EdgePositive_9]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_9\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 9\n  #   [../]\n  [./dot_DD_EdgePositive_10]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_10\n  [../]\n  #   [./Advection_DD_EdgePositive_10]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_10\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 10\n  #   [../]\n  [./dot_DD_EdgePositive_11]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_11\n  [../]\n  #   [./Advection_DD_EdgePositive_11]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_11\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 11\n  #   [../]\n  [./dot_DD_EdgePositive_12]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_12\n  [../]\n    [./Advection_DD_EdgePositive_12]\n      type = ConservativeAdvectionDislocation\n      variable = DD_EdgePositive_12\n      upwinding_type = full\n      dislocation_character = edge\n      dislocation_sign = positive\n      slip_system_index = 12\n    [../]\n  \n  [./dot_DD_EdgeNegative_1]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_1\n  [../]\n    # [./Advection_DD_EdgeNegative_1]\n    #   type = ConservativeAdvectionDislocation\n    #   variable = DD_EdgeNegative_1\n    #   upwinding_type = full\n    #   dislocation_character = edge\n    #   dislocation_sign = negative\n    #   slip_system_index = 1\n    # [../]\n  [./dot_DD_EdgeNegative_2]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_2\n  [../]\n  #   [./Advection_DD_EdgeNegative_2]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_2\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 2\n  #   [../]\n  [./dot_DD_EdgeNegative_3]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_3\n  [../]\n  #   [./Advection_DD_EdgeNegative_3]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_3\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 3\n  #   [../]\n  [./dot_DD_EdgeNegative_4]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_4\n  [../]\n  #   [./Advection_DD_EdgeNegative_4]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_4\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 4\n  #   [../]\n  [./dot_DD_EdgeNegative_5]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_5\n  [../]\n  #   [./Advection_DD_EdgeNegative_5]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_5\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 5\n  #   [../]\n  [./dot_DD_EdgeNegative_6]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_6\n  [../]\n  #   [./Advection_DD_EdgeNegative_6]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_6\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 6\n  #   [../]\n  [./dot_DD_EdgeNegative_7]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_7\n  [../]\n  #   [./Advection_DD_EdgeNegative_7]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_7\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 7\n  #   [../]\n  [./dot_DD_EdgeNegative_8]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_8\n  [../]\n  #   [./Advection_DD_EdgeNegative_8]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_8\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 8\n  #   [../]\n  [./dot_DD_EdgeNegative_9]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_9\n  [../]\n  #   [./Advection_DD_EdgeNegative_9]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_9\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 9\n  #   [../]\n  [./dot_DD_EdgeNegative_10]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_10\n  [../]\n  #   [./Advection_DD_EdgeNegative_10]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_10\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 10\n  #   [../]\n  [./dot_DD_EdgeNegative_11]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_11\n  [../]\n  #   [./Advection_DD_EdgeNegative_11]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_11\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 11\n  #   [../]\n  [./dot_DD_EdgeNegative_12]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_12\n  [../]\n    [./Advection_DD_EdgeNegative_12]\n      type = ConservativeAdvectionDislocation\n      variable = DD_EdgeNegative_12\n      upwinding_type = full\n      dislocation_character = edge\n      dislocation_sign = negative\n      slip_system_index = 12\n    [../]\n  \n  \n  [./dot_DD_ScrewPositive_1]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_1\n  [../]\n  [./dot_DD_ScrewPositive_2]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_2\n  [../]\n  [./dot_DD_ScrewPositive_3]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_3\n  [../]\n  [./dot_DD_ScrewPositive_4]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_4\n  [../]\n  [./dot_DD_ScrewPositive_5]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_5\n  [../]\n  [./dot_DD_ScrewPositive_6]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_6\n  [../]\n  [./dot_DD_ScrewPositive_7]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_7\n  [../]\n  [./dot_DD_ScrewPositive_8]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_8\n  [../]\n  [./dot_DD_ScrewPositive_9]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_9\n  [../]\n  [./dot_DD_ScrewPositive_10]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_10\n  [../]\n  [./dot_DD_ScrewPositive_11]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_11\n  [../]\n  [./dot_DD_ScrewPositive_12]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_12\n  [../]\n  \n  [./dot_DD_ScrewNegative_1]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_1\n  [../]\n  [./dot_DD_ScrewNegative_2]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_2\n  [../]\n  [./dot_DD_ScrewNegative_3]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_3\n  [../]\n  [./dot_DD_ScrewNegative_4]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_4\n  [../]\n  [./dot_DD_ScrewNegative_5]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_5\n  [../]\n  [./dot_DD_ScrewNegative_6]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_6\n  [../]\n  [./dot_DD_ScrewNegative_7]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_7\n  [../]\n  [./dot_DD_ScrewNegative_8]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_8\n  [../]\n  [./dot_DD_ScrewNegative_9]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_9\n  [../]\n  [./dot_DD_ScrewNegative_10]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_10\n  [../]\n  [./dot_DD_ScrewNegative_11]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_11\n  [../]\n  [./dot_DD_ScrewNegative_12]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_12\n  [../]\n[]\n\n[InterfaceKernels]\n  [./Intf_Avd_DD_EdgePositive_12_1]\n    type = InterfaceDiffusionTest\n    variable = DD_EdgePositive_12\n    neighbor_var = DD_EdgePositive_1\n    boundary = surface_GB\n    D = 1.0\n    D_neighbor = 1.0\n  [../]\n  # [./Intf_Avd_DD_EdgePositive_12_1]\n  #   type = InterfaceDiffusionDislocation\n  #   variable = DD_EdgePositive_12\n  #   slip_system_index = 12\n  #   neighbor_var = DD_EdgePositive_1\n  #   slip_system_index_neighbor = 1\n  #   dislocation_character = edge\n  #   dislocation_sign = positive\n  #   boundary = surface_GB\n  #   density_critical = 0.2\n  #   tau_critical = 2\n  # [../]\n  [./Intf_Avd_DD_EdgePositive_12_2]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_2\n    slip_system_index_neighbor = 2\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_3]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_3\n    slip_system_index_neighbor = 3\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_4]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_4\n    slip_system_index_neighbor = 4\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_5]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_5\n    slip_system_index_neighbor = 5\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_6]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_6\n    slip_system_index_neighbor = 6\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_7]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_7\n    slip_system_index_neighbor = 7\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_8]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_8\n    slip_system_index_neighbor = 8\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_9]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_9\n    slip_system_index_neighbor = 9\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_10]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_10\n    slip_system_index_neighbor = 10\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_11]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_11\n    slip_system_index_neighbor = 11\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_12]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_12\n    slip_system_index_neighbor = 12\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  # [./Intf_Avd_DD_EdgePositive_1_12]\n  #   type = InterfaceDiffusionDislocation\n  #   variable = DD_EdgePositive_1\n  #   slip_system_index = 1\n  #   neighbor_var = DD_EdgePositive_12\n  #   slip_system_index_neighbor = 12\n  #   dislocation_character = edge\n  #   dislocation_sign = positive\n  #   boundary = surface_GB\n  #   density_critical = 0.2\n  #   tau_critical = 2\n  # [../]\n  #   [./Intf_Avd_DD_EdgePositive_2_12]\n  #     type = InterfaceDiffusionDislocation\n  #     variable = DD_EdgePositive_2\n  #     slip_system_index = 2\n  #     neighbor_var = DD_EdgePositive_12\n  #     slip_system_index_neighbor = 12\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     boundary = surface_GB\n  #     density_critical = 0.2\n  #     tau_critical = 2\n  #   [../]\n  #     [./Intf_Avd_DD_EdgePositive_3_12]\n  #       type = InterfaceDiffusionDislocation\n  #       variable = DD_EdgePositive_3\n  #       slip_system_index = 3\n  #       neighbor_var = DD_EdgePositive_12\n  #       slip_system_index_neighbor = 12\n  #       dislocation_character = edge\n  #       dislocation_sign = positive\n  #       boundary = surface_GB\n  #       density_critical = 0.2\n  #       tau_critical = 2\n  #     [../]\n  #       [./Intf_Avd_DD_EdgePositive_4_12]\n  #         type = InterfaceDiffusionDislocation\n  #         variable = DD_EdgePositive_4\n  #         slip_system_index = 4\n  #         neighbor_var = DD_EdgePositive_12\n  #         slip_system_index_neighbor = 12\n  #         dislocation_character = edge\n  #         dislocation_sign = positive\n  #         boundary = surface_GB\n  #         density_critical = 0.2\n  #         tau_critical = 2\n  #       [../]\n  #         [./Intf_Avd_DD_EdgePositive_5_12]\n  #           type = InterfaceDiffusionDislocation\n  #           variable = DD_EdgePositive_5\n  #           slip_system_index = 5\n  #           neighbor_var = DD_EdgePositive_12\n  #           slip_system_index_neighbor = 12\n  #           dislocation_character = edge\n  #           dislocation_sign = positive\n  #           boundary = surface_GB\n  #           density_critical = 0.2\n  #           tau_critical = 2\n  #         [../]\n  #           [./Intf_Avd_DD_EdgePositive_6_12]\n  #             type = InterfaceDiffusionDislocation\n  #             variable = DD_EdgePositive_6\n  #             slip_system_index = 6\n  #             neighbor_var = DD_EdgePositive_12\n  #             slip_system_index_neighbor = 12\n  #             dislocation_character = edge\n  #             dislocation_sign = positive\n  #             boundary = surface_GB\n  #             density_critical = 0.2\n  #             tau_critical = 2\n  #           [../]\n  #             [./Intf_Avd_DD_EdgePositive_7_12]\n  #               type = InterfaceDiffusionDislocation\n  #               variable = DD_EdgePositive_7\n  #               slip_system_index = 7\n  #               neighbor_var = DD_EdgePositive_12\n  #               slip_system_index_neighbor = 12\n  #               dislocation_character = edge\n  #               dislocation_sign = positive\n  #               boundary = surface_GB\n  #               density_critical = 0.2\n  #               tau_critical = 2\n  #             [../]\n  #               [./Intf_Avd_DD_EdgePositive_8_12]\n  #                 type = InterfaceDiffusionDislocation\n  #                 variable = DD_EdgePositive_8\n  #                 slip_system_index = 8\n  #                 neighbor_var = DD_EdgePositive_12\n  #                 slip_system_index_neighbor = 12\n  #                 dislocation_character = edge\n  #                 dislocation_sign = positive\n  #                 boundary = surface_GB\n  #                 density_critical = 0.2\n  #                 tau_critical = 2\n  #               [../]\n  #                 [./Intf_Avd_DD_EdgePositive_9_12]\n  #                   type = InterfaceDiffusionDislocation\n  #                   variable = DD_EdgePositive_9\n  #                   slip_system_index = 9\n  #                   neighbor_var = DD_EdgePositive_12\n  #                   slip_system_index_neighbor = 12\n  #                   dislocation_character = edge\n  #                   dislocation_sign = positive\n  #                   boundary = surface_GB\n  #                   density_critical = 0.2\n  #                   tau_critical = 2\n  #                 [../]\n  #                   [./Intf_Avd_DD_EdgePositive_10_12]\n  #                     type = InterfaceDiffusionDislocation\n  #                     variable = DD_EdgePositive_10\n  #                     slip_system_index = 10\n  #                     neighbor_var = DD_EdgePositive_12\n  #                     slip_system_index_neighbor = 12\n  #                     dislocation_character = edge\n  #                     dislocation_sign = positive\n  #                     boundary = surface_GB\n  #                     density_critical = 0.2\n  #                     tau_critical = 2\n  #                   [../]\n  #                     [./Intf_Avd_DD_EdgePositive_11_12]\n  #                       type = InterfaceDiffusionDislocation\n  #                       variable = DD_EdgePositive_11\n  #                       slip_system_index = 11\n  #                       neighbor_var = DD_EdgePositive_12\n  #                       slip_system_index_neighbor = 12\n  #                       dislocation_character = edge\n  #                       dislocation_sign = positive\n  #                       boundary = surface_GB\n  #                       density_critical = 0.2\n  #                       tau_critical = 2\n  #                     [../]\n[]\n\n[AuxVariables]\n  [euler_angle_1]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [euler_angle_2]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [euler_angle_3]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[AuxKernels]\n  [euler_angle_1]\n    type = MaterialRealVectorValueAux\n    variable = euler_angle_1\n    property = updated_Euler_angle\n    component = 0\n    execute_on = 'initial final'\n  []\n  [euler_angle_2]\n    type = MaterialRealVectorValueAux\n    variable = euler_angle_2\n    property = updated_Euler_angle\n    component = 1\n    execute_on = 'initial final'\n  []\n  [euler_angle_3]\n    type = MaterialRealVectorValueAux\n    variable = euler_angle_3\n    property = updated_Euler_angle\n    component = 2\n    execute_on = 'initial final'\n  []\n[]\n\n[BCs]\n  ##############################################\n  # X : Left and Right\n  # Y : Bottom and Top\n  # Z : Back and Front\n  ##############################################\n  [./BC_X]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = 'x0'\n    # boundary = left\n    function = 0.0\n  [../]\n    [./BC_Y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'y0'\n    # boundary = bottom\n    function = 0.0\n  [../]\n    [./BC_Z]\n    type = FunctionDirichletBC\n    variable = disp_z\n    boundary = 'z0'\n    # boundary = back\n    function = 0.0\n  [../]\n\n  [./BC_Loading]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = 'x0 x1 '\n    # boundary = top\n    function = '0.001*x*t'\n  [../]\n\n  # [./BC_X0]\n  #   type = FunctionDirichletBC\n  #   variable = disp_x\n  #   boundary = 'x0 y0 z0'\n  #   function = 0.0\n  # [../]\n  # [./BC_Y0]\n  #   type = FunctionDirichletBC\n  #   variable = disp_y\n  #   boundary = 'x0 y0 z0'\n  #   function = 0.0\n  # [../]\n  # [./BC_Z0]\n  #   type = FunctionDirichletBC\n  #   variable = disp_z\n  #   boundary = 'x0 y0 z0'\n  #   function = 0.0\n  # [../]\n\n  # [./Periodic]\n  #   [./rho_edge_positive_1]\n  #     variable = 'DD_EdgePositive_1 DD_EdgePositive_2 DD_EdgePositive_3 DD_EdgePositive_4 DD_EdgePositive_5 DD_EdgePositive_6 DD_EdgePositive_7 DD_EdgePositive_8 DD_EdgePositive_9 DD_EdgePositive_10 DD_EdgePositive_11 DD_EdgePositive_12'\n  #     auto_direction = 'x y z'\n  #   [../]\n  #   [./rho_edge_negative]\n  #     variable = 'DD_EdgeNegative_1 DD_EdgeNegative_2 DD_EdgeNegative_3 DD_EdgeNegative_4 DD_EdgeNegative_5 DD_EdgeNegative_6 DD_EdgeNegative_7 DD_EdgeNegative_8 DD_EdgeNegative_9 DD_EdgeNegative_10 DD_EdgeNegative_11 DD_EdgeNegative_12'\n  #     auto_direction = 'x y z'\n  #   [../]\n  # [../] \n  \n[]\n\n[Physics/SolidMechanics/QuasiStatic/all]\n  strain = FINITE\n  add_variables = true\n  new_system = true\n  formulation = total\n  incremental = true\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '1.684e5 1.214e5 1.214e5 1.684e5 1.214e5 1.684e5 0.754e5 0.754e5 0.754e5'\n    fill_method = symmetric9\n    read_prop_user_object = prop_read\n  [../]\n  [stress_brass]\n    type = ComputeMultipleCrystalPlasticityStress\n    crystal_plasticity_models = 'CP_DiscoFlux'\n    tan_mod_type = exact\n  []\n  [./CP_DiscoFlux]\n    type = DiscoFluxCPStressUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = /Users/bmurgas/workspace/auxfiles/input_slip_sys.inp\n    lattice_friction = 15\n    Coeff_hardening = 0.85\n    slip_increment_tolerance = 2.0e-2 #2.0e-2 10.0\n    DD_EdgePositive_1 = DD_EdgePositive_1\n    DD_EdgePositive_2 = DD_EdgePositive_2\n    DD_EdgePositive_3 = DD_EdgePositive_3\n    DD_EdgePositive_4 = DD_EdgePositive_4\n    DD_EdgePositive_5 = DD_EdgePositive_5\n    DD_EdgePositive_6 = DD_EdgePositive_6\n    DD_EdgePositive_7 = DD_EdgePositive_7\n    DD_EdgePositive_8 = DD_EdgePositive_8\n    DD_EdgePositive_9 = DD_EdgePositive_9\n    DD_EdgePositive_10 = DD_EdgePositive_10\n    DD_EdgePositive_11 = DD_EdgePositive_11\n    DD_EdgePositive_12 = DD_EdgePositive_12\n    DD_EdgeNegative_1 = DD_EdgeNegative_1\n    DD_EdgeNegative_2 = DD_EdgeNegative_2\n    DD_EdgeNegative_3 = DD_EdgeNegative_3\n    DD_EdgeNegative_4 = DD_EdgeNegative_4\n    DD_EdgeNegative_5 = DD_EdgeNegative_5\n    DD_EdgeNegative_6 = DD_EdgeNegative_6\n    DD_EdgeNegative_7 = DD_EdgeNegative_7\n    DD_EdgeNegative_8 = DD_EdgeNegative_8\n    DD_EdgeNegative_9 = DD_EdgeNegative_9\n    DD_EdgeNegative_10 = DD_EdgeNegative_10\n    DD_EdgeNegative_11 = DD_EdgeNegative_11\n    DD_EdgeNegative_12 = DD_EdgeNegative_12\n    DD_ScrewPositive_1 = DD_ScrewPositive_1\n    DD_ScrewPositive_2 = DD_ScrewPositive_2\n    DD_ScrewPositive_3 = DD_ScrewPositive_3\n    DD_ScrewPositive_4 = DD_ScrewPositive_4\n    DD_ScrewPositive_5 = DD_ScrewPositive_5\n    DD_ScrewPositive_6 = DD_ScrewPositive_6\n    DD_ScrewPositive_7 = DD_ScrewPositive_7\n    DD_ScrewPositive_8 = DD_ScrewPositive_8\n    DD_ScrewPositive_9 = DD_ScrewPositive_9\n    DD_ScrewPositive_10 = DD_ScrewPositive_10\n    DD_ScrewPositive_11 = DD_ScrewPositive_11\n    DD_ScrewPositive_12 = DD_ScrewPositive_12\n    DD_ScrewNegative_1 = DD_ScrewNegative_1\n    DD_ScrewNegative_2= DD_ScrewNegative_2\n    DD_ScrewNegative_3 = DD_ScrewNegative_3\n    DD_ScrewNegative_4 = DD_ScrewNegative_4\n    DD_ScrewNegative_5 = DD_ScrewNegative_5\n    DD_ScrewNegative_6 = DD_ScrewNegative_6\n    DD_ScrewNegative_7 = DD_ScrewNegative_7\n    DD_ScrewNegative_8 = DD_ScrewNegative_8\n    DD_ScrewNegative_9 = DD_ScrewNegative_9\n    DD_ScrewNegative_10 = DD_ScrewNegative_10\n    DD_ScrewNegative_11 = DD_ScrewNegative_11\n    DD_ScrewNegative_12 = DD_ScrewNegative_12\n    print_state_variable_convergence_error_messages = true\n  [../]\n  [updated_euler_angle]\n    type = ComputeUpdatedEulerAngle\n    radian_to_degree = true\n  []\n[]\n\n[Postprocessors]\n  [euler_angle_1] \n    type = ElementAverageValue\n    variable = euler_angle_1\n  []\n  [euler_angle_2]\n    type = ElementAverageValue\n    variable = euler_angle_2\n  []\n  [euler_angle_3]\n    type = ElementAverageValue\n    variable = euler_angle_3\n  []\n[]\n\n[GlobalParams]\n    dislo_density_initial = 1.0e+05\n    C_multi =  0.0  #8.5e-06\n    C_trap =   0.0  #5.5e-03\n    C_m_ann =  0.0  #0.5\n    C_im_ann = 0.0 #0.5\n    burgers_vector_mag = 2.52e-07\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n\n  # solve_type = 'PJFNK'\n  # line_search = 'none'\n  # petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  # petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  # nl_abs_tol = 1e-5 \n  # nl_max_its = 10\n  # l_abs_tol = 1e-5\n  # l_max_its = 20\n\n  # solver used in cpam\n  solve_type = 'PJFNK'\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\n  petsc_options_value = 'hypre    boomeramg          31'\n  line_search = 'none'\n  l_max_its = 50\n  nl_max_its = 50\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-6\n  l_tol = 1e-8\n\n  dtmax = 0.2\n  dtmin = 0.000001\n  end_time = 100 #100\n  [./TimeStepper]\n    type = ConstantDT\n    dt = 0.2\n    growth_factor = 1.01\n  [../]\n[]\n\n[AuxVariables]\n  [./pk2_1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pk2_2]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pk2_3]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pk2_4]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pk2_5]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pk2_6]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_2]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_3]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_4]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_5]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_6]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./pk2_1] \n   type = RankTwoAux\n   variable = pk2_1\n   rank_two_tensor = stress\n   index_j = 0\n   index_i = 0\n  [../]\n  [./pk2_2] \n    type = RankTwoAux\n    variable = pk2_2\n    rank_two_tensor = stress\n    index_j = 1\n    index_i = 1\n  [../]\n  [./pk2_3] \n   type = RankTwoAux\n   variable = pk2_3\n   rank_two_tensor = stress\n   index_j = 2\n   index_i = 2\n  [../]\n  [./pk2_4] \n    type = RankTwoAux\n    variable = pk2_4\n    rank_two_tensor = stress\n    index_j = 0\n    index_i = 1\n  [../]\n  [./pk2_5] \n    type = RankTwoAux\n    variable = pk2_5\n    rank_two_tensor = stress\n    index_j = 0\n    index_i = 2\n  [../]\n  [./pk2_6] \n    type = RankTwoAux\n    variable = pk2_6\n    rank_two_tensor = stress\n    index_j = 1\n    index_i = 2\n  [../]\n  [./E_1]\n   type = RankTwoAux\n   variable = E_1\n   rank_two_tensor = total_strain\n   index_j = 0\n   index_i = 0\n  [../]\n  [./E_2] \n    type = RankTwoAux\n    variable = E_2\n    rank_two_tensor = total_strain\n    index_j = 1\n    index_i = 1\n  [../]\n  [./E_3] \n   type = RankTwoAux\n   variable = E_3\n   rank_two_tensor = total_strain\n   index_j = 2\n   index_i = 2\n  [../]\n  [./E_4] \n    type = RankTwoAux\n    variable = E_4\n    rank_two_tensor = total_strain\n    index_j = 0\n    index_i = 1\n  [../]\n  [./E_5] \n    type = RankTwoAux\n    variable = E_5\n    rank_two_tensor = total_strain\n    index_j = 0\n    index_i = 2\n  [../]\n  [./E_6] \n    type = RankTwoAux\n    variable = E_6\n    rank_two_tensor = total_strain\n    index_j = 1\n    index_i = 2\n  [../]\n[]\n\n[Postprocessors]\n  [./pk2_1]\n    type = ElementAverageValue\n    variable = pk2_1\n  [../]\n  [./pk2_2]\n    type = ElementAverageValue\n    variable = pk2_2\n  [../]\n  [./pk2_3]\n    type = ElementAverageValue\n    variable = pk2_3\n  [../]\n  [./pk2_4]\n    type = ElementAverageValue\n    variable = pk2_4\n  [../]\n  [./pk2_5]\n    type = ElementAverageValue\n    variable = pk2_5\n  [../]\n  [./pk2_6]\n    type = ElementAverageValue\n    variable = pk2_6\n  [../]\n  [./E_1]\n    type = ElementAverageValue\n    variable = E_1\n  [../]\n  [./E_2]\n    type = ElementAverageValue\n    variable = E_2\n  [../]\n  [./E_3]\n    type = ElementAverageValue\n    variable = E_3\n  [../]\n  [./E_4]\n    type = ElementAverageValue\n    variable = E_4\n  [../]\n  [./E_5]\n    type = ElementAverageValue\n    variable = E_5\n  [../]\n  [./E_6]\n    type = ElementAverageValue\n    variable = E_6\n  [../]\n[]\n\n# [AuxVariables]\n#   [./DD_EP_01]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_02]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_03]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_04]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_05]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_06]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_07]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_08]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_09]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_10]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_11]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_12]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n# []\n\n\n# [AuxKernels]\n#   [./DD_EP_01]\n#    type = MaterialRealAux\n#    variable = DD_EP_01\n#    property = DD_EdgePositive_1\n#   [../]\n#   [./DD_EP_02]\n#    type = MaterialRealAux\n#    variable = DD_EP_02\n#    property = DD_EdgePositive_2  \n#   [../]\n#   [./DD_EP_03]\n#    type = MaterialRealAux\n#    variable = DD_EP_03\n#    property = DD_EdgePositive_3\n#   [../]\n#   [./DD_EP_04]\n#    type = MaterialRealAux\n#    variable = DD_EP_04\n#    property = DD_EdgePositive_4\n#   [../]\n#   [./DD_EP_05]\n#    type = MaterialRealAux\n#    variable = DD_EP_05\n#    property = DD_EdgePositive_5\n#   [../]\n#   [./DD_EP_06]\n#    type = MaterialRealAux\n#    variable = DD_EP_06\n#    property = DD_EdgePositive_6\n#   [../]\n#   [./DD_EP_07]\n#    type = MaterialRealAux\n#    variable = DD_EP_07\n#    property = DD_EdgePositive_7\n#   [../]\n#   [./DD_EP_08]\n#    type = MaterialRealAux\n#    variable = DD_EP_08\n#    property = DD_EdgePositive_8\n#   [../]\n#   [./DD_EP_09]\n#    type = MaterialRealAux\n#    variable = DD_EP_09\n#    property = DD_EdgePositive_9\n#   [../]\n#   [./DD_EP_10]\n#    type = MaterialRealAux\n#    variable = DD_EP_10\n#    property = DD_EdgePositive_10\n#   [../]\n#   [./DD_EP_11]\n#    type = MaterialRealAux\n#    variable = DD_EP_11\n#    property = DD_EdgePositive_11\n#   [../]\n#   [./DD_EP_12]\n#    type = MaterialRealAux\n#    variable = DD_EP_12\n#    property = DD_EdgePositive_12\n#   [../]\n# []\n  \n\n# [AuxVariables]\n#   [./DD_EN_01]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_02]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_03]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_04]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_05]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_06]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_07]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_08]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_09]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_10]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_11]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_12]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n# []\n\n\n# [AuxKernels]\n#   [./DD_EN_01]\n#    type = MaterialRealAux\n#    variable = DD_EN_01\n#    property = DD_EdgeNegative_1\n#   [../]\n#   [./DD_EN_02]\n#    type = MaterialRealAux\n#    variable = DD_EN_02\n#    property = DD_EdgeNegative_2\n#   [../]\n#   [./DD_EN_03]\n#    type = MaterialRealAux\n#    variable = DD_EN_03\n#    property = DD_EdgeNegative_3\n#   [../]\n#   [./DD_EN_04]\n#    type = MaterialRealAux\n#    variable = DD_EN_04\n#    property = DD_EdgeNegative_4\n#   [../]\n#   [./DD_EN_05]\n#    type = MaterialRealAux\n#    variable = DD_EN_05\n#    property = DD_EdgeNegative_5\n#   [../]\n#   [./DD_EN_06]\n#    type = MaterialRealAux\n#    variable = DD_EN_06\n#    property = DD_EdgeNegative_6\n#   [../]\n#   [./DD_EN_07]\n#    type = MaterialRealAux\n#    variable = DD_EN_07\n#    property = DD_EdgeNegative_7\n#   [../]\n#   [./DD_EN_08]\n#    type = MaterialRealAux\n#    variable = DD_EN_08\n#    property = DD_EdgeNegative_8\n#   [../]\n#   [./DD_EN_09]\n#    type = MaterialRealAux\n#    variable = DD_EN_09\n#    property = DD_EdgeNegative_9\n#   [../]\n#   [./DD_EN_10]\n#    type = MaterialRealAux\n#    variable = DD_EN_10\n#    property = DD_EdgeNegative_10\n#   [../]\n#   [./DD_EN_11]\n#    type = MaterialRealAux\n#    variable = DD_EN_11\n#    property = DD_EdgeNegative_11\n#   [../]\n#   [./DD_EN_12]\n#    type = MaterialRealAux\n#    variable = DD_EN_12 \n#    property = DD_EdgeNegative_12\n#   [../]\n# []\n\n# [AuxVariables]\n#   [./DD_SP_01]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_02]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_03]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_04]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_05]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_06]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_07]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_08]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_09]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_10]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_11]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_12]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n# []\n\n\n# [AuxKernels]\n#   [./DD_SP_01]\n#    type = MaterialRealAux\n#    variable = DD_SP_01\n#    property = DD_ScrewPositive_1\n#   [../]\n#   [./DD_SP_02]\n#    type = MaterialRealAux\n#    variable = DD_SP_02\n#    property = DD_ScrewPositive_2\n#   [../]\n#   [./DD_SP_03]\n#    type = MaterialRealAux\n#    variable = DD_SP_03\n#    property = DD_ScrewPositive_3\n#   [../]\n#   [./DD_SP_04]\n#    type = MaterialRealAux\n#    variable = DD_SP_04\n#    property = DD_ScrewPositive_4\n#   [../]\n#   [./DD_SP_05]\n#    type = MaterialRealAux\n#    variable = DD_SP_05\n#    property = DD_ScrewPositive_5\n#   [../]\n#   [./DD_SP_06]\n#    type = MaterialRealAux\n#    variable = DD_SP_06\n#    property = DD_ScrewPositive_6\n#   [../]\n#   [./DD_SP_07]\n#    type = MaterialRealAux\n#    variable = DD_SP_07\n#    property = DD_ScrewPositive_7\n#   [../]\n#   [./DD_SP_08]\n#    type = MaterialRealAux\n#    variable = DD_SP_08\n#    property = DD_ScrewPositive_8\n#   [../]\n#   [./DD_SP_09]\n#    type = MaterialRealAux\n#    variable = DD_SP_09\n#    property = DD_ScrewPositive_9\n#   [../]\n#   [./DD_SP_10]\n#    type = MaterialRealAux\n#    variable = DD_SP_10 \n#    property = DD_ScrewPositive_10\n#   [../]\n#   [./DD_SP_11]\n#    type = MaterialRealAux\n#    variable = DD_SP_11 \n#    property = DD_ScrewPositive_11\n#   [../]\n#   [./DD_SP_12]\n#    type = MaterialRealAux\n#    variable = DD_SP_12\n#    property = DD_ScrewPositive_12\n#   [../]\n# []\n  \n\n# [AuxVariables]\n#   [./DD_SN_01]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_02]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_03]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_04]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_05]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_06]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_07]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_08]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_09]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_10]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_11]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_12]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n# []\n\n\n# [AuxKernels]\n#   [./DD_SN_01]\n#    type = MaterialRealAux\n#    variable = DD_SN_01\n#    property = DD_ScrewNegative_1\n#   [../]\n#   [./DD_SN_02]\n#    type = MaterialRealAux\n#    variable = DD_SN_02\n#    property = DD_ScrewNegative_2\n#   [../]\n#   [./DD_SN_03]\n#    type = MaterialRealAux\n#    variable = DD_SN_03\n#    property = DD_ScrewNegative_3\n#   [../]\n#   [./DD_SN_04]\n#    type = MaterialRealAux\n#    variable = DD_SN_04\n#    property = DD_ScrewNegative_4\n#   [../]\n#   [./DD_SN_05]\n#    type = MaterialRealAux\n#    variable = DD_SN_05\n#    property = DD_ScrewNegative_5\n#   [../]\n#   [./DD_SN_06]\n#    type = MaterialRealAux\n#    variable = DD_SN_06\n#    property = DD_ScrewNegative_6\n#   [../]\n#   [./DD_SN_07]\n#    type = MaterialRealAux\n#    variable = DD_SN_07\n#    property = DD_ScrewNegative_7\n#   [../]\n#   [./DD_SN_08]\n#    type = MaterialRealAux\n#    variable = DD_SN_08\n#    property = DD_ScrewNegative_8\n#   [../]\n#   [./DD_SN_09]\n#    type = MaterialRealAux\n#    variable = DD_SN_09\n#    property = DD_ScrewNegative_9\n#   [../]\n#   [./DD_SN_10]\n#    type = MaterialRealAux\n#    variable = DD_SN_10\n#    property = DD_ScrewNegative_10\n#   [../]\n#   [./DD_SN_11]\n#    type = MaterialRealAux\n#    variable = DD_SN_11\n#    property = DD_ScrewNegative_11\n#   [../]\n#   [./DD_SN_12]\n#    type = MaterialRealAux #ElementAverageValue\n#    variable = DD_SN_12\n#    property = DD_ScrewNegative_12\n#   [../]\n# []\n\n[AuxVariables]\n  [./shear_stress_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_01]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n\n[AuxKernels]\n  [./shear_stress_01]\n   type = MaterialStdVectorAux\n   variable = shear_stress_01\n   property = applied_shear_stress  \n   index = 0\n  [../]\n  [./back_stress_01]\n   type = MaterialStdVectorAux\n   variable = back_stress_01\n   property = back_stress\n   index = 0\n  [../]\n  [./shear_resistance_01]\n    type = MaterialStdVectorAux\n    variable = shear_resistance_01\n    property = slip_resistance  \n    index = 0\n  [../]\n  [./DD_mobile_01]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_01\n   property = dislocation_immobile\n   index = 0\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_02]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_02]\n   type = MaterialStdVectorAux\n   variable = shear_stress_02\n   property = applied_shear_stress  \n   index = 1\n  [../]\n[./back_stress_02]\n   type = MaterialStdVectorAux\n   variable = back_stress_02\n   property = back_stress\n   index = 1\n  [../]\n  [./shear_resistance_02]\n    type = MaterialStdVectorAux\n    variable = shear_resistance_02\n    property = slip_resistance  \n    index = 1\n  [../]\n[./DD_mobile_02]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_02\n   property = dislocation_immobile\n   index = 1\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_03]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_03]\n   type = MaterialStdVectorAux\n   variable = shear_stress_03\n   property = applied_shear_stress  \n   index = 2\n  [../]\n[./back_stress_03]\n   type = MaterialStdVectorAux\n   variable = back_stress_03\n   property = back_stress\n   index = 2\n  [../]\n  [./shear_resistance_03]\n    type = MaterialStdVectorAux\n    variable = shear_resistance_03\n    property = slip_resistance  \n    index = 2\n  [../]\n[./DD_mobile_03]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_03\n   property = dislocation_immobile\n   index = 2\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_04]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_04]\n   type = MaterialStdVectorAux\n   variable = shear_stress_04\n   property = applied_shear_stress  \n   index = 3\n  [../]\n[./back_stress_04]\n   type = MaterialStdVectorAux\n   variable = back_stress_04\n   property = back_stress\n   index = 3\n  [../]\n  [./shear_resistance_04]\n    type = MaterialStdVectorAux\n    variable = shear_resistance_04\n    property = slip_resistance  \n    index = 3\n  [../]\n[./DD_mobile_04]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_04\n   property = dislocation_immobile\n   index = 3\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_05]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_05]\n   type = MaterialStdVectorAux\n   variable = shear_stress_05\n   property = applied_shear_stress  \n   index = 4\n  [../]\n[./back_stress_05]\n   type = MaterialStdVectorAux\n   variable = back_stress_05\n   property = back_stress\n   index = 4\n  [../]\n  [./shear_resistance_05]\n    type = MaterialStdVectorAux\n    variable = shear_resistance_05\n    property = slip_resistance  \n    index = 4\n  [../]\n[./DD_mobile_05]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_05\n   property = dislocation_immobile\n   index = 4\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_06]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_06]\n   type = MaterialStdVectorAux\n   variable = shear_stress_06\n   property = applied_shear_stress  \n   index = 5\n  [../]\n[./back_stress_06]\n   type = MaterialStdVectorAux\n   variable = back_stress_06\n   property = back_stress\n   index = 5\n  [../]\n    [./shear_resistance_06]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_06\n      property = slip_resistance\n      index = 5\n    [../]\n[./DD_mobile_06]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_06\n   property = dislocation_immobile\n   index = 5\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_07]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_07]\n   type = MaterialStdVectorAux\n   variable = shear_stress_07\n   property = applied_shear_stress  \n   index = 6\n  [../]\n[./back_stress_07]\n   type = MaterialStdVectorAux\n   variable = back_stress_07\n   property = back_stress\n   index = 6\n  [../]\n    [./shear_resistance_07]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_07\n      property = slip_resistance\n      index = 6\n    [../]\n[./DD_mobile_07]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_07\n   property = dislocation_immobile\n   index = 6\n  [../]\n[]\n\n\n[AuxVariables]\n  [./shear_stress_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_08]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_08]\n   type = MaterialStdVectorAux\n   variable = shear_stress_08\n   property = applied_shear_stress  \n   index = 7\n  [../]\n[./back_stress_08]\n   type = MaterialStdVectorAux\n   variable = back_stress_08\n   property = back_stress\n   index = 7\n  [../]\n    [./shear_resistance_08]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_08\n      property = slip_resistance\n      index = 7\n    [../]\n[./DD_mobile_08]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_08\n   property = dislocation_immobile\n   index = 7\n  [../]\n[]\n\n\n\n[AuxVariables]\n  [./shear_stress_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_09]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_09]\n   type = MaterialStdVectorAux\n   variable = shear_stress_09\n   property = applied_shear_stress  \n   index = 8\n  [../]\n[./back_stress_09]\n   type = MaterialStdVectorAux\n   variable = back_stress_09\n   property = back_stress\n   index = 8\n  [../]\n    [./shear_resistance_09]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_09\n      property = slip_resistance\n      index = 8\n    [../]\n[./DD_mobile_09]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_09\n   property = dislocation_immobile\n   index = 8\n  [../]\n[]\n\n\n[AuxVariables]\n  [./shear_stress_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_10]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_10]\n   type = MaterialStdVectorAux\n   variable = shear_stress_10\n   property = applied_shear_stress  \n   index = 9\n  [../]\n[./back_stress_10]\n   type = MaterialStdVectorAux\n   variable = back_stress_10\n   property = back_stress\n   index = 9\n  [../]\n    [./shear_resistance_10]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_10\n      property = slip_resistance\n      index = 9\n    [../]\n[./DD_mobile_10]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_10\n   property = dislocation_immobile\n   index = 9\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_11]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_11]\n   type = MaterialStdVectorAux\n   variable = shear_stress_11\n   property = applied_shear_stress  \n   index = 10\n  [../]\n[./back_stress_11]\n   type = MaterialStdVectorAux\n   variable = back_stress_11\n   property = back_stress\n   index = 10\n  [../]\n    [./shear_resistance_11]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_11\n      property = slip_resistance\n      index = 10\n    [../]\n[./DD_mobile_11]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_11\n   property = dislocation_immobile\n   index = 10\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_12]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_12]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_12]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_12]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_12]\n   type = MaterialStdVectorAux\n   variable = shear_stress_12\n   property = applied_shear_stress  \n   index = 11\n  [../]\n[./back_stress_12]\n   type = MaterialStdVectorAux\n   variable = back_stress_12\n   property = back_stress\n   index = 11\n  [../]\n    [./shear_resistance_12]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_12\n      property = slip_resistance\n      index = 11\n    [../]\n[./DD_mobile_12]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_12\n   property = dislocation_immobile\n   index = 11\n  [../]\n[]\n\n[Materials]\n  [./compute_stress_wrapper]\n    type = ComputeLagrangianWrappedStress\n  [../]\n[]\n\n[AuxVariables]\n  [./GND_density_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_12]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./GND_density_01]\n    type = MaterialStdVectorAux\n    variable = GND_density_01\n    property = kappa  \n    index = 0\n  [../]\n[./GND_density_02]\n    type = MaterialStdVectorAux\n    variable = GND_density_02\n    property = kappa  \n    index = 1\n  [../]\n[./GND_density_03]\n    type = MaterialStdVectorAux\n    variable = GND_density_03\n    property = kappa  \n    index = 2\n  [../]\n[./GND_density_04]\n    type = MaterialStdVectorAux\n    variable = GND_density_04\n    property = kappa  \n    index = 3\n  [../]\n[./GND_density_05]\n    type = MaterialStdVectorAux\n    variable = GND_density_05\n    property = kappa  \n    index = 4\n  [../]\n[./GND_density_06]\n    type = MaterialStdVectorAux\n    variable = GND_density_06\n    property = kappa  \n    index = 5\n  [../]\n[./GND_density_07]\n    type = MaterialStdVectorAux\n    variable = GND_density_07\n    property = kappa  \n    index = 6\n  [../]\n[./GND_density_08]\n    type = MaterialStdVectorAux\n    variable = GND_density_08\n    property = kappa  \n    index = 7\n  [../]\n[./GND_density_09]\n    type = MaterialStdVectorAux\n    variable = GND_density_09\n    property = kappa  \n    index = 8\n  [../]\n[./GND_density_10]\n    type = MaterialStdVectorAux\n    variable = GND_density_10\n    property = kappa  \n    index = 9\n  [../]\n[./GND_density_11]\n    type = MaterialStdVectorAux\n    variable = GND_density_11\n    property = kappa  \n    index = 10\n  [../]\n[./GND_density_12]\n    type = MaterialStdVectorAux\n    variable = GND_density_12\n    property = kappa  \n    index = 11\n  [../]\n[]\n\n[AuxVariables]\n  [./slip_increment_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_12]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./slip_increment_01]\n    type = MaterialStdVectorAux\n    variable = slip_increment_01\n    property = slip_increment  \n    index = 0\n  [../]\n[./slip_increment_02]\n    type = MaterialStdVectorAux\n    variable = slip_increment_02\n    property = slip_increment  \n    index = 1\n  [../]\n[./slip_increment_03]\n    type = MaterialStdVectorAux\n    variable = slip_increment_03\n    property = slip_increment  \n    index = 2\n  [../]\n[./slip_increment_04]\n    type = MaterialStdVectorAux\n    variable = slip_increment_04\n    property = slip_increment  \n    index = 3\n  [../]\n[./slip_increment_05]\n    type = MaterialStdVectorAux\n    variable = slip_increment_05\n    property = slip_increment  \n    index = 4\n  [../]\n[./slip_increment_06]\n    type = MaterialStdVectorAux\n    variable = slip_increment_06\n    property = slip_increment  \n    index = 5\n  [../]\n[./slip_increment_07]\n    type = MaterialStdVectorAux\n    variable = slip_increment_07\n    property = slip_increment  \n    index = 6\n  [../]\n[./slip_increment_08]\n    type = MaterialStdVectorAux\n    variable = slip_increment_08\n    property = slip_increment  \n    index = 7\n  [../]\n[./slip_increment_09]\n    type = MaterialStdVectorAux\n    variable = slip_increment_09\n    property = slip_increment  \n    index = 8\n  [../]\n[./slip_increment_10]\n    type = MaterialStdVectorAux\n    variable = slip_increment_10\n    property = slip_increment  \n    index = 9\n  [../]\n[./slip_increment_11]\n    type = MaterialStdVectorAux\n    variable = slip_increment_11\n    property = slip_increment  \n    index = 10\n  [../]\n[./slip_increment_12]\n    type = MaterialStdVectorAux\n    variable = slip_increment_12\n    property = slip_increment  \n    index = 11\n  [../]\n[]\n\n[AuxVariables]\n  [./dde_vel_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_12]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./dde_vel_01]\n    type = MaterialStdVectorAux\n    variable = dde_vel_01\n    property = dislo_velocity_edge  \n    index = 0\n  [../]\n[./dde_vel_02]\n    type = MaterialStdVectorAux\n    variable = dde_vel_02\n    property = dislo_velocity_edge  \n    index = 1\n  [../]\n[./dde_vel_03]\n    type = MaterialStdVectorAux\n    variable = dde_vel_03\n    property = dislo_velocity_edge  \n    index = 2\n  [../]\n[./dde_vel_04]\n    type = MaterialStdVectorAux\n    variable = dde_vel_04\n    property = dislo_velocity_edge  \n    index = 3\n  [../]\n[./dde_vel_05]\n    type = MaterialStdVectorAux\n    variable = dde_vel_05\n    property = dislo_velocity_edge  \n    index = 4\n  [../]\n[./dde_vel_06]\n    type = MaterialStdVectorAux\n    variable = dde_vel_06\n    property = dislo_velocity_edge  \n    index = 5\n  [../]\n[./dde_vel_07]\n    type = MaterialStdVectorAux\n    variable = dde_vel_07\n    property = dislo_velocity_edge  \n    index = 6\n  [../]\n[./dde_vel_08]\n    type = MaterialStdVectorAux\n    variable = dde_vel_08\n    property = dislo_velocity_edge  \n    index = 7\n  [../]\n[./dde_vel_09]\n    type = MaterialStdVectorAux\n    variable = dde_vel_09\n    property = dislo_velocity_edge  \n    index = 8\n  [../]\n[./dde_vel_10]\n    type = MaterialStdVectorAux\n    variable = dde_vel_10\n    property = dislo_velocity_edge  \n    index = 9\n  [../]\n[./dde_vel_11]\n    type = MaterialStdVectorAux\n    variable = dde_vel_11\n    property = dislo_velocity_edge  \n    index = 10\n  [../]\n[./dde_vel_12]\n    type = MaterialStdVectorAux\n    variable = dde_vel_12\n    property = dislo_velocity_edge  \n    index = 11\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11031841",
                          "updatedAt": "2024-10-23T16:39:50Z",
                          "publishedAt": "2024-10-23T16:39:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "bmurgas-LANL"
                  },
                  "bodyText": "Hi @GiudGiud,\nI have been trying to find the problem with the Material Properties in the InterfaceDiffusion kernel.\nThe values were set to zero because I used the wrong values when initializing the variables in DiscoFluxCPStressUpdate::initQpStatefulProperties().\nI initialize the variables with the correct values and I can read them in the ConservativeAdvection and InterfaceDiffusion kernels. However, the Material Properties are evolving every time step in the crystal plasticity kernel, when reading the updated values I get the correct values in the ConservativeAdvection kernel but I keep getting the initial values in the InterfaceDiffusion.\nI suspect this error is coming from the fact that Moose creates three copies of the Material Properties (https://mooseframework.inl.gov/syntax/Materials/index.html). After reading this, I started to check the memory address of the same variable in the three kernels: DiscoFluxCPStressUpdate, ConservativeAdvection and InterfaceDiffusion.\nThis is the result from lldb:\nIn crystal plasticity\n(lldb) frame var -L _dislo_velocity_edge\n0x00007fd001ec6470: (MaterialProperty<std::vector<double> > &) _dislo_velocity_edge = 0x000060000123c090: {\n0x000060000123c090:   MaterialPropertyBase<std::__1::vector<double, std::__1::allocator<double> >, false> = {\n0x000060000123c090:     PropertyValue = {\n0x000060000123c098:       _id = 23\n    }\n0x000060000123c0a0:     _value = {\n0x000060000123c0a0:       _data_ptr = size=12 {\n0x000060000123c0a0:         pointer = 0x00006000027715f8 size=12\n      }\n0x000060000123c0a8:       _data = 0x00006000027715f8 size=12\n0x000060000123c0b0:       _size = 8\n0x000060000123c0b4:       _allocated_size = 8\n    }\n  }\n}\n\nIn interfacediffusiondislocation\n(lldb) frame var -L _dislo_velocity_CP_edge\n0x00007fd001f81ff0: (const MaterialProperty<std::vector<double> > &) _dislo_velocity_CP_edge = 0x000060000123e970: {\n0x000060000123e970:   MaterialPropertyBase<std::__1::vector<double, std::__1::allocator<double> >, false> = {\n0x000060000123e970:     PropertyValue = {\n0x000060000123e978:       _id = 23\n    }\n0x000060000123e980:     _value = {\n0x000060000123e980:       _data_ptr = size=12 {\n0x000060000123e980:         pointer = 0x0000600003765188 size=12\n      }\n0x000060000123e988:       _data = 0x0000600003765188 size=12\n0x000060000123e990:       _size = 4\n0x000060000123e994:       _allocated_size = 4\n    }\n  }\n}\n\nAnd in conservativeadvectiondislocation\n(lldb) frame var -L _dislo_velocity_CP_edge\n0x00007fd001f57e30: (const MaterialProperty<std::vector<double> > &) _dislo_velocity_CP_edge = 0x000060000123c090: {\n0x000060000123c090:   MaterialPropertyBase<std::__1::vector<double, std::__1::allocator<double> >, false> = {\n0x000060000123c090:     PropertyValue = {\n0x000060000123c098:       _id = 23\n    }\n0x000060000123c0a0:     _value = {\n0x000060000123c0a0:       _data_ptr = size=12 {\n0x000060000123c0a0:         pointer = 0x00006000027715f8 size=12\n      }\n0x000060000123c0a8:       _data = 0x00006000027715f8 size=12\n0x000060000123c0b0:       _size = 8\n0x000060000123c0b4:       _allocated_size = 8\n    }\n  }\n}\n\nAs you can see the memory address of the variable in the crystal plasticity (DiscoFluxCPStressUpdate) and the advection kernel (ConservativeAdvection) is the same. And the address of the interface diffusion kernel is different. Does it means that in the interface kernel system we are using the element face material properties?\nI wonder is there is an issue with Moose when the material properties are being updated in the crystal plasticity model and the elemental material variables don't update.\nI found this discussion #19062 and found it helpful. I'll try to create a Material Object to see if when calling the function copmputeQpProperties both the element and element face material properties are updated with the correct values.\nThank you for your help.\nBrayan",
                  "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11115620",
                  "updatedAt": "2024-10-31T19:35:13Z",
                  "publishedAt": "2024-10-31T19:35:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hi\nsorry for the delay. I ll get to this this weekend. I tried to find a resource to help earlier but failed.",
                          "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11121773",
                          "updatedAt": "2024-11-01T12:32:57Z",
                          "publishedAt": "2024-11-01T12:32:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I can't run the input file, I need the px3_bar_hex8_cl16e-3.e mesh and the px3-bar-sp10-sp01.inp data file.\nI ll make a MWE to see if I can reproduce this without those",
                          "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11131847",
                          "updatedAt": "2024-11-02T23:45:27Z",
                          "publishedAt": "2024-11-02T23:45:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok I made do with sxori-0-0-0.inp instead of px3-bar-sp10-sp01.inp.\nI am not getting uniformly 0 values on my case. So it could have something to do with your mesh. Is it possible for you to share that with me?\nAlternatively, maybe I am not checking the materials the same way as you. How did you determine slip_resistance /... were uniformly 0 in the interface kernels ?\n\nAnd the address of the interface diffusion kernel is different. Does it means that in the interface kernel system we are using the element face material properties?\n\nYes that is expected. The interface kernels request \"boundary material data\" from their inheritance on TwoMaterialPropertyInterface.\nInputParameters\nTwoMaterialPropertyInterface::validParams()\n{\n\n  // Objects inheriting from TwoMaterialPropertyInterface rely on Boundary MaterialData\n  InputParameters params = MaterialPropertyInterface::validParams();\n  params.set<Moose::MaterialDataType>(\"_material_data_type\") = Moose::BOUNDARY_MATERIAL_DATA;\n  return params;\n}\n\nWhich under the hood maps to boundary material data\nMaterialData &\nFEProblemBase::getMaterialData(Moose::MaterialDataType type, const THREAD_ID tid)\n{\n  switch (type)\n  {\n    case Moose::BLOCK_MATERIAL_DATA:\n      return _material_props.getMaterialData(tid);\n    case Moose::NEIGHBOR_MATERIAL_DATA:\n      return _neighbor_material_props.getMaterialData(tid);\n    case Moose::BOUNDARY_MATERIAL_DATA:\n    case Moose::FACE_MATERIAL_DATA:\n    case Moose::INTERFACE_MATERIAL_DATA:\n      return _bnd_material_props.getMaterialData(tid);\n  }\n\nSo it's a different address than the kernels which use block material data, which is from regular materials.",
                          "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11131965",
                          "updatedAt": "2024-11-03T00:45:27Z",
                          "publishedAt": "2024-11-03T00:44:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}