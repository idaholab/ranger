{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wOC0yN1QyMDoyNjo1OS0wNjowMM4AVOwy"
    },
    "edges": [
      {
        "node": {
          "title": "Implement a post processor that takes more than one variables",
          "author": {
            "login": "pengfejeac"
          },
          "bodyText": "Hi there,\nI've searched around but could't find anything related. I'm trying to do some post processing that involves more than one variables. So I start implementing my own post processor based on ElementIntegralArrayVariablePostprocessor and hope to add parameters so that I can input more variables. Some suggestions I found claims that \"_sys.getFieldVariable\" is a good idea, but I can't get it working in my own post processors, it works well in customized kernels.\nI'm still new to Moose, any help will be much appreciated!\nPeter",
          "url": "https://github.com/idaholab/moose/discussions/25347",
          "updatedAt": "2023-08-31T02:57:32Z",
          "publishedAt": "2023-08-30T07:38:12Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can add as many variable parameters as you need by adding them as coupled variables:\nIn validParams:\nparams.addCoupledVar(\"var_name1\", default_var1_name, \"first coupled variable (description)\");\nparams.addCoupledVar(\"var_name2\", default_var2_name, \"second coupled variable (description)\");\n\nin the constructor:\n_var1(coupledValue(\"var_name1\")),\n_var2(coupledValue(\"var_name2\")),\n\nin the header:\nconst VariableValue & _var1;\nconst VariableValue & _var2;\n\nthere's numerous examples if you search for any of these routines in the code base\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25347#discussioncomment-6863717",
                  "updatedAt": "2023-08-30T12:37:21Z",
                  "publishedAt": "2023-08-30T12:37:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to access a material property that is in main app from a sub app?",
          "author": {
            "login": "mahyarmalek"
          },
          "bodyText": "Hello MOOSE developers\nI wrote some fracture constitutive model and i wanted to solve the phasefield fracture alongside linear momentum balance with operator split. unfortunately, I get the error that material property \"hist\" cannot be accessed by the phasefield equation which is the sub app of my linear momentum equation. I guess since the mechanical constitutive model that has this material property \"hist\" exist in the main app, the phasefield eqaution (subapp) cannot access it. Is there anyway to bypass this error? here's theinput files for main and subapp (sub app's name is fracture.i )\nthe exact error i get : Material property 'hist', requested by 'PhasefieldFracture' is not defined on block 0\nNote : \"hist\" is the fracture resistance elastic energy and is defined in the material  \"ADFrozenCamClayFractureStress\"\nmain app:\n[Mesh]\n[./gen]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 20\n  ny = 40\n  ymin =  0.0\n  ymax = 0.2\n  xmin = 0.0\n  xmax = 0.1\n  []\n  [eng1]\n  type =ExtraNodesetGenerator\n  input = gen\n  new_boundary = 'corner'\n  coord = '0 0'\n  []\n  [eng2]\n  type =ExtraNodesetGenerator\n  input = eng1\n  new_boundary = 'cornerup'\n  coord = '0.1 0.195'\n  []\n  [eng3]\n  type =ExtraNodesetGenerator\n  input = eng2\n  new_boundary = 'cornerdown'\n  coord = '0.1 0.005'\n  []\n[]\n[GlobalParams]\n    gravity = '0 0 0'\n  biot_coefficient = 1.0\n  block = 0\n[]\n[Variables]\n  [disp_x]\n    family = Lagrange\n  []\n  [disp_y]\n    family = Lagrange\n  []\n   [p]\n    family = Lagrange\n  []\n   [T_f]\n  initial_condition = 272\n    family = Lagrange\n\n  []\n\n[]\n\n\n[Kernels]\n  [momentum_x]\n    type = momentumbishop\n    variable = disp_x\n    component = 0\n    porepressure = p\n    phasefield = phi_p\n    stress_expand = 0\n      block = 0\n  []\n  [momentum_y]\n    type = momentumbishop\n    variable = disp_y\n    component = 1\n    porepressure = p\n    phasefield = phi_p\n    stress_expand = 0\n      block = 0\n  []\n   [darcymass]\n    type = SaturatedIceWaterMassConservation \n    variable = p\n    shear = 1E9\n    K = 1e-12\n    alpha = 1e-7\n    porosity_zero = 0.4\n    phasefield = phi_p\n      block = 0\n  []\n   [heatconduction]\n  type = ADHeatConduction\n  variable = T_f\n  use_displaced_mesh = true\n  []\n  [heattimederivative]\n  type = ADHeatConductionTimeDerivative\n  variable = T_f\n  specific_heat = 2000\n  []\n[]\n  [Functions]\n    [./bc_func]\n    type = ParsedFunction\n    value = 'if( (t<=3000), -1e-5*t, -3e-2)' #'if( (t<=100), -100*t, -10000)' #'if( (t<=100), -1e-5*t, -1e-3)'\n    [../]\n        [./bc_func4]\n    type = ParsedFunction\n    value = 'if( (t>=5), 0, (-20+4*t) )'  #'if( (t<=100), -100*t, -10000)' #'if( (t<=100), -1e-5*t, -1e-3)'\n    [../]\n\n   [./bc_func2]\n    type = ParsedFunction\n    value = 'if( (t<=10), 272, 274 )' \n    [../]\n     [./bc_func3]\n    type = ParsedFunction\n    value = 'if( (t>=3), -200, 0 )'\n    [../]\n  [../]\n\n[BCs]\n     [./xdisp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = ' left bottom right'# top' # cornerup'\n    function = 0\n    []\n         [./xrightforce]\n    type = FunctionNeumannBC\n    variable = disp_x\n    boundary = 'right'\n    function = bc_func3\n    []\n  [./ydisp]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'top'\n    function = bc_func #'-1e-7*t'\t\n  [../]\n  [./yfix]\n    type = DirichletBC\n    variable = disp_y\n    #boundary = 'bottom'\n    boundary = 'bottom corner'\n    value = 0\n  [../]\n   [./toppressure]\n  type = ADFunctionDirichletBC\n  variable = p\n  boundary = 'top'\n  function = 0\n  [../]\n  [./toptemp]\n  type = ADFunctionDirichletBC\n  variable = T_f\n  boundary = 'top'\n  function = 272\n  [../]\n[]\n\n\n[Materials]\n  [heat]\n    type = ADHeatConductionMaterial\n    block = 0\n    thermal_conductivity = 6\n    specific_heat = 1000\n  []\n    [Cryo]\n    type = ADCryoSuction\n    PorePressure = p\n    Temperature = T_f\n    LatentHeat = 334\n    rho_l = 1 \n    rho_c = 0.9\n    m_value = 0.35\n    P_value = 280\n  []\n    [density_prop]\n    type = ADGenericConstantMaterial\n    prop_names =  density\n    prop_values = 2000\n      block = 0\n  []\n\n\n [stress]\n    type = ADFrozenCamClayFractureStress # ADComputeFrozenCamClayStress \n    ReferencePressure        = -20\n    ReferencePoisson         = 0.3\n    ShearModulusEvolution    = 0.0\t\n    PreconsolidationPressure = -100\n    VirginCompressionIndex   = 0.1\n    RecompressionIndex       = 0.01\n    phasefield_compressibility = 2\n    phasefield_damage        = d\n    CSLSlope                 = 1.05\n    Associativity            = 1.0\n    Verbose                  = false\n    tolerance                = 1e-8\n    initial_stress = '-20 0  0  0 -20 0 0 0 -20'\n    block = 0\n  []\n    [./strain]\n    type = ADComputeIncrementalSmallStrain\n    displacements = 'disp_x disp_y'\n      block = 0\n  [../]\n[]\n\n[AuxVariables]\n  [phi_p]\n    initial_condition = 0.0001\n    family = Lagrange\n   # order = SECOND\n  []\n  [d_pull]\n    initial_condition = 0.0001\n    family = Lagrange\n   # order = SECOND\n  []\n\n  [./Scryo]\n    family = MONOMIAL\n    order = SECOND\n  [../]\n    [./stressyy]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n      [./stress_xx]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n      [./stressxy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n      [./strain_yy]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n   [./strain_xx]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n   [./strain_xy]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n     [./eq_plastic_strain]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n       [./plastic_strain_xx]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n       [./plastic_strain_yy]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n       [./plastic_strainxy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n       [./pp]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n    [./qq]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n      [./Pc]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n  \n[]\n\n\n[AuxKernels]\n [Pc]\n    type = Ice_pressure\n    variable = Pc\n  []\n [Scryo]\n    type = CryoSuction\n    variable = Scryo\n  []\n [sigma_yy]\n    type = ADRankTwoAux\n    rank_two_tensor = stress\n    variable = stressyy\n    index_i = 1\n    index_j = 1\n  []\n   [sigma_xx]\n    type = ADRankTwoAux\n    rank_two_tensor = stress\n    variable = stress_xx\n    index_i = 0\n    index_j = 0\n  []\n   [sigma_xy]\n    type = ADRankTwoAux\n    rank_two_tensor = stress\n    variable = stressxy\n    index_i = 0\n    index_j = 1\n  []\n   [strain_xx]\n    type = ADRankTwoAux\n    rank_two_tensor = total_strain\n    variable = strain_xx\n    index_i = 0\n    index_j = 0\n  []\n   [strain_xy]\n    type = ADRankTwoAux\n    rank_two_tensor = total_strain\n    variable = strain_yy\n    index_i = 0\n    index_j = 1\n  []\n   [strain_yy]\n    type = ADRankTwoAux\n    rank_two_tensor = total_strain\n    variable = strain_yy\n    index_i = 1\n    index_j = 1\n  []\n  \n   [eq_plastic_strain]\n    type = effectiveplasticcamclay\n    variable = eq_plastic_strain\n  []\n   [plastic_strain_xx]\n    type = ADRankTwoAux\n    rank_two_tensor = plastic_straincam\n    variable = plastic_strain_xx\n    index_i = 0\n    index_j = 0\n  []\n     [plastic_strain_yy]\n    type = ADRankTwoAux\n    rank_two_tensor = plastic_straincam\n    variable = plastic_strain_yy\n    index_i = 1\n    index_j = 1\n  []\n     [plastic_strainxy]\n    type = ADRankTwoAux\n    rank_two_tensor = plastic_straincam\n    variable = plastic_strainxy\n    index_i = 1\n    index_j = 0\n  []\n       [p]\n    type = Camclaystress_p\n    variable = pp\n  []\n      [q]\n    type = Camclaystress_q\n    variable = qq\n  []\n\n[]\n\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  end_time = 10000\n  dtmax = 20\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1\n     cutback_factor = 0.5\n    growth_factor = 1.5\n   optimal_iterations = 10\n     []\n  l_max_its = 10000\n  nl_abs_tol = 3E-8\n  nl_rel_tol = 3E-6\n  automatic_scaling = true\n  nl_max_its = 10\n[]\n\n[Outputs]\n  perf_graph = false\n  csv = true\n  exodus = true\n[]\n\n[Preconditioning]\n  active = basic\n  [basic]\n    type = SMP\n    full = true\n    petsc_options = '-ksp_diagonal_scale -ksp_diagonal_scale_fix'\n    petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap'\n    petsc_options_value = ' asm      lu           NONZERO                   2'\n  []\n  [preferred_but_might_not_be_installed]\n    type = SMP\n    full = true\n    petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n    petsc_options_value = ' lu       mumps'\n  []\n[]\n\n[MultiApps]\n  [micro]\n   type = TransientMultiApp\n    positions = '0 0 0'\n    input_files = 'sub_phasefield.i'\n  []\n    [micro_d]\n   type = TransientMultiApp\n    positions = '0 0 0'\n    input_files = 'sub_fracture.i'\n  []\n[]\n\n[Transfers]\n  [push_T]\n type = MultiAppMeshFunctionTransfer\n    multi_app = micro\n    direction = to_multiapp\n    source_variable = T_f\n    variable = pushed_T\n  []\n\n  [push_pwater]\n type = MultiAppMeshFunctionTransfer\n    multi_app = micro\n    direction = to_multiapp\n    source_variable = p\n    variable = pushed_pwater\n  []\n  [pull_v]\n    #type = MultiAppPostprocessorInterpolationTransfer\n    type = MultiAppMeshFunctionTransfer\n    multi_app = micro\n    direction = from_multiapp\n    source_variable = phi\n    variable = phi_p\n   # postprocessor = average_phi\n  []\n    [pull_d]\n    #type = MultiAppPostprocessorInterpolationTransfer\n    type = MultiAppMeshFunctionTransfer\n    multi_app = micro_d\n    direction = from_multiapp\n    source_variable = d\n    variable = d_pull\n  []\n  \n  \n[]\n\nand subapp:\n\n[Mesh]\n[./gen]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 10\n  ny = 40\n  ymin =  0.0\n  ymax = 0.2\n  xmin = 0.0\n  xmax = 0.1\n  []\n  [eng1]\n  type =ExtraNodesetGenerator\n  input = gen\n  new_boundary = 'corner'\n  coord = '0 0'\n  []\n[]\n[GlobalParams]\n[]\n\n[Variables]\n\n  [d]\n    family = Lagrange\n#    order = SECOND\n#    scaling = 1E-7\n  initial_condition = 0.001\n  block = 0\n[]\n[]\n\n\n[Kernels]\n\n  [PhasefieldFracture]\n  type = PhasefieldFracture\n  variable = d\n  Gd    = 0.01\n  ld    = 0.001\n  block = 0\n  []\n \n[]\n  \n\n[Materials]\n []\n[BCs]\n[]\n[Materials]\n[]\n[AuxVariables]\n[]\n[AuxKernels]\n[]\n[Postprocessors]\n[]\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  end_time = 10000\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1\n     cutback_factor = 0.9\n    growth_factor = 1.1\n   optimal_iterations = 10\n     []\n  l_max_its = 10000\n  nl_abs_tol = 1E-4\n  nl_rel_tol = 1E-4\n  automatic_scaling = true\n  nl_max_its = 10\n[]\n\n[Outputs]\n  perf_graph = false\n  csv = true\n  exodus = true\n[]\n\n[Preconditioning]\n  active = basic\n  [basic]\n    type = SMP\n    full = true\n    petsc_options = '-ksp_diagonal_scale -ksp_diagonal_scale_fix'\n    petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap'\n    petsc_options_value = ' asm      lu           NONZERO                   2'\n  []\n  [preferred_but_might_not_be_installed]\n    type = SMP\n    full = true\n    petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n    petsc_options_value = ' lu       mumps'\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/25251",
          "updatedAt": "2023-08-30T03:44:31Z",
          "publishedAt": "2023-08-20T00:47:46Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "The canonical way to handle this is to convert your material property to an auxiliary variable and transfer that between apps",
                  "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6784927",
                  "updatedAt": "2023-08-21T20:10:07Z",
                  "publishedAt": "2023-08-21T20:10:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "Thank you for replying. I will implement this technique but since my models are all using AD material properties and Aux system ignores the derivatives and phase field is coupled to the elastic energy tightly, it might face convergence issues.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6785396",
                          "updatedAt": "2023-08-21T21:18:01Z",
                          "publishedAt": "2023-08-21T21:18:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If you are doing operator splitting, then you shouldn't need the derivatives right?",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6785595",
                          "updatedAt": "2023-08-21T21:50:48Z",
                          "publishedAt": "2023-08-21T21:50:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "Well, the \"hist\" value is dependent on displacement and phasefield. I don't need the derivative with respect to displacement if im splitting. But I need its derivative with respect to phasefield variable since im solving phasefield as single PDE now, I guess?\nI'm not really sure though about this one but since elastic energy rise significantly in strain localized quadrature points, 'hist\" variable may jump a lot in two consecutive time steps and if time steps are not small enough it again may cause convergence issues.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6786081",
                          "updatedAt": "2023-08-21T23:41:27Z",
                          "publishedAt": "2023-08-21T23:36:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "You are right that segregating solves may cause convergence issues if the physics are in reality tightly coupled. If you are worried about that, then you should not do the split and you should keep tightly coupled variables in a single input/app.\nIf you are doing the split, then there should be no derivative transfers between the two apps because you have the split the systems. You cannot supply derivatives for degrees of freedom that do not exist in a system.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6786415",
                          "updatedAt": "2023-08-22T00:38:57Z",
                          "publishedAt": "2023-08-22T00:38:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "With a conversion for material property to auxiliary variables, you will have some projection error. I would encourage you to try both approaches (coupled & segregated) and decide which one is best for you looking at mesh convergence error & computation speed.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6792137",
                          "updatedAt": "2023-08-22T13:46:35Z",
                          "publishedAt": "2023-08-22T13:46:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "I tried to decouple the problem with the instructions: I have few problems to begin with:\n\nMy mechanical constitutive model is a cam-clay plasticity model (for geomaterial) and I had so many problems to finish the run with a successful converge. The problem with this model is , it is very hard for the first step to converge and go to the next steps I used to get \"  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\" error and then nonlinear solves won't converge. I have read different threads and tried to use different preconditioning styles but the problem is still there. For example i tried the mumps or tried NONZERO option but no luck.\nThe only way that it converges is when I couple my stress divergence to pore pressure (from my mass balance equation). seems like the initial pore pressure makes it stable. Since I'm getting a lot of Oscillatory solutions from the pressure field it's also very hard to continue with the coupled pressure and it makes the solve slow when i want to add phase field on top of it.\nI tried to give a try to restart option. so basically I first coupled the mechanical and pressure and passed through the first step and put it into a checkpoint and then tried to continue and recover with  a decoupled multiapp. The problem s im getting the below error:\n\" Trying to load vector name  but that vector doesn't exist in the system.\"\n\nI'm trying to understand where this error comes from but so far no luck.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6827566",
                          "updatedAt": "2023-08-26T14:15:41Z",
                          "publishedAt": "2023-08-25T23:57:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nDid you try the troubleshooting instructions?\nIn particular let s check that the problem is not ill-posed\nhttps://mooseframework.inl.gov/moose/application_usage/failed_solves.html",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6830537",
                          "updatedAt": "2023-08-26T15:04:58Z",
                          "publishedAt": "2023-08-26T15:04:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "Hello, this is the output\nSVD: condition number            inf, 1029 of 1683 singular values are (nearly) zero\nSVD: smallest singular values: 0.000000000000e+00 -0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00\nSVD: largest singular values : 1.773493885709e+00 1.779826379564e+00 1.784597693878e+00 1.787789044278e+00 1.789387866683e+00\nwhat can I do fo this? why would adding pressure on top of the stress stabilize this system?",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6830833",
                          "updatedAt": "2023-08-26T16:22:04Z",
                          "publishedAt": "2023-08-26T16:22:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You're missing an equation for 1029 degrees of freedom basically.\nIs 1029 the numbers of dofs inside a block? That could point to the block with the issue\nSame for boundaries",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6831392",
                          "updatedAt": "2023-08-26T18:43:19Z",
                          "publishedAt": "2023-08-26T18:43:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "1683 DOFs are in the main app with (disp_x, disp_y, T_f) field variables and there is only one block no sub blocks so idk what 1029 comes from probably most of the displacement DOFs have this problem. I know the problem is definitely comes from the displacements but i have no idea how to address it.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6831459",
                          "updatedAt": "2023-08-26T19:05:29Z",
                          "publishedAt": "2023-08-26T19:05:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Try https://GitHub.com/hugary1995/raccoon.git :)",
                  "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6836590",
                  "updatedAt": "2023-08-27T21:24:58Z",
                  "publishedAt": "2023-08-27T21:24:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "Thank you for your suggestion. I want to couple my cam-clay plasticity model to linear momentum that has pressure and phase-transition (another phase-field) in it. So it is very different in context than classic fracture problems. It is very specialized for geomaterials and even crack propagation mechanisms are different.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6837355",
                          "updatedAt": "2023-08-28T01:32:20Z",
                          "publishedAt": "2023-08-28T01:32:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mahyarmalek"
                  },
                  "bodyText": "Not sure if anyone here wanna address this issue but I'm going to write it down here anyways:\nI have tried to split the the mechanical phase field equation and linear momentum equation. the phase field equation need a variable ( a material properties that is stateful called Hist and is the elastic energy stored in the Q-points) that is produced inside the linear momentum (the main app of the system). Therefore this material property needs to be pushed from main app to phase field app (sub-app). As far as I've been informed the only way is to make an auxkernel that computes this property and then push this value via an auxvariable to the sub app. I have done so but the problem is when i see the results in a particular time step, Hist values in ALL the quadrature points are equal and there is no variation. Seems like somewhere in the process there is some averaging going on. If anyone can take a look it will be appreciated bcz it makes it impossible to use operator split in these kind of cases.",
                  "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857271",
                  "updatedAt": "2023-08-29T20:20:58Z",
                  "publishedAt": "2023-08-29T20:19:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What type of auxiliary variable are you using?\nThere is going to be projections involved, either in filling the auxiliary variable or in the transfer process.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857290",
                          "updatedAt": "2023-08-29T20:23:06Z",
                          "publishedAt": "2023-08-29T20:23:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "I'm using this setting:\n   [./Hist]\n    family = LAGRANGE \n    []",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857352",
                          "updatedAt": "2023-08-29T20:34:34Z",
                          "publishedAt": "2023-08-29T20:34:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so it s first order lagrange. This means the values of the property are stored on nodes actually.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857408",
                          "updatedAt": "2023-08-29T20:42:42Z",
                          "publishedAt": "2023-08-29T20:42:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "Yes when i see them in paraview they are nodal values but all the same quantities.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857422",
                          "updatedAt": "2023-08-29T20:45:03Z",
                          "publishedAt": "2023-08-29T20:45:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Not sure you are supposed to use nodal variables here tbh\nCan you use a constant monomial?",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857459",
                          "updatedAt": "2023-08-29T20:50:26Z",
                          "publishedAt": "2023-08-29T20:50:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Hist values in ALL the quadrature points are equal and there is no variation\n\nThere is no variation across the whole mesh? Or there is no variation within single elements?",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857476",
                          "updatedAt": "2023-08-29T20:52:14Z",
                          "publishedAt": "2023-08-29T20:52:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "it worked with Constant MONOMIAL but since it only gives one element value the convergence is terrible.\nbut here is what I get for the hist:",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857603",
                          "updatedAt": "2023-08-29T21:11:14Z",
                          "publishedAt": "2023-08-29T21:10:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "May I ask why you are doing the operator splitting? You keep talking about terrible convergence; it's possible that the operator split is at the root of the problem. If the variables are strongly coupled, then convergence can be very slow if you split them.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857625",
                          "updatedAt": "2023-08-29T21:15:55Z",
                          "publishedAt": "2023-08-29T21:15:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "The reason is I'm currently have 3 coupled equations and another splitted phase-field (for phase transition) and hefty amounts of constitutive models that are computationally expensive when i add this fracture on top of them it becomes extremely slow and increasing the number of elements more than anything above a 20*10  becomes impossible with my current cpu config. Same thing happened when i coupled my first phase-field too but when i splitted, it worked fine. Fortunately, the first one did not have any associated coupled constitutive model that need any properties to be pushed but this one needs one.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857666",
                          "updatedAt": "2023-08-29T21:22:01Z",
                          "publishedAt": "2023-08-29T21:22:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mahyarmalek"
                          },
                          "bodyText": "Also, I need to add this: in order to get convergence with phase field when coupled to the main equation, i need lot of fine mesh which i cannot afford, but in splitting i can freely increase the number of meshes in the sub app without being worried about slowing down the whole system. currently i can go up to step 200 with split but when i couple all of them together with the same config the simulation only reach step 120 and no crack starts to form. So i guess splitting is computationally effective here.",
                          "url": "https://github.com/idaholab/moose/discussions/25251#discussioncomment-6857695",
                          "updatedAt": "2023-08-29T21:27:40Z",
                          "publishedAt": "2023-08-29T21:27:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Water97 fluid properties problem",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nI would like to use the partial derivative of sound to pressure in Water97FluidProperties, but I can not find the derivative function of sound. The only one that related to sound is Water97FluidProperties::c_from_p_T_template(const T & pressure, const T & temperature) const. The derivative terms are not included in this function.\nSo, how to calculate the partial derivative of sound to pressure? Can anyone kindly tell me?\nBest regards",
          "url": "https://github.com/idaholab/moose/discussions/25321",
          "updatedAt": "2023-08-29T17:40:08Z",
          "publishedAt": "2023-08-28T17:32:10Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou'll need to add that definition, we have not added it.\nAdd this signature:\nc_from_p_T(const Real pressure, const Real temperature, Real & c, Real & dc_dp, Real & dc_dT) const\n\nto WaterFP\nyou may have to template it later on\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25321#discussioncomment-6845159",
                  "updatedAt": "2023-08-28T17:37:14Z",
                  "publishedAt": "2023-08-28T17:37:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thank you! But it seems so complicated to calculate the dc_dp! And I do not know the partial derivative of these terms (just like d2gamma1_dpitau(pi, tau), d2gamma1_dtau2(pi, tau), d2gamma1_dpi2(pi, tau)) to pressure.",
                          "url": "https://github.com/idaholab/moose/discussions/25321#discussioncomment-6850057",
                          "updatedAt": "2023-08-29T07:45:18Z",
                          "publishedAt": "2023-08-29T07:45:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Yeah, they are super tedious! These were mostly coded before AD was available in MOOSE. You could see if you could 'cheat' and use AD to compute the derivatives - like\nhttps://github.com/idaholab/moose/blob/516ad1215a7f38384beab4549202215bd396ccf2/modules/fluid_properties/src/fluidproperties/Water97FluidProperties.C#L689C25-L689C35",
                          "url": "https://github.com/idaholab/moose/discussions/25321#discussioncomment-6851992",
                          "updatedAt": "2023-08-29T11:16:58Z",
                          "publishedAt": "2023-08-29T11:16:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "So, if I use this way, I need to update my moose version, is that right?",
                          "url": "https://github.com/idaholab/moose/discussions/25321#discussioncomment-6852311",
                          "updatedAt": "2023-08-29T11:50:52Z",
                          "publishedAt": "2023-08-29T11:50:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If it s really really old yes.\nIf not then AD has been around for years.",
                          "url": "https://github.com/idaholab/moose/discussions/25321#discussioncomment-6854321",
                          "updatedAt": "2023-08-29T15:03:16Z",
                          "publishedAt": "2023-08-29T15:03:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "OK, thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/25321#discussioncomment-6856013",
                          "updatedAt": "2023-08-29T17:40:08Z",
                          "publishedAt": "2023-08-29T17:40:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Plotting material properties",
          "author": {
            "login": "Khaksarkn"
          },
          "bodyText": "Hi,\nI was wondering if there is any way to plot material properties in the exodus output. Say I have defined a material property X which takes different values at _qp 's, and I want to see what the distribution of X is at each time step.\nis there a way to get the same plot we get for our main variables (on _qp 's), for a material property?\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/25334",
          "updatedAt": "2023-08-29T15:58:11Z",
          "publishedAt": "2023-08-29T15:21:02Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes it s very easy. You use the outputs parameter of the material block and say which\nNot on qps though. You ll get a cell-average\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25334#discussioncomment-6854726",
                  "updatedAt": "2023-08-29T15:36:40Z",
                  "publishedAt": "2023-08-29T15:36:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Orthotropic elasticity fill method showing error",
          "author": {
            "login": "chakra34"
          },
          "bodyText": "Hi,\nI am using the following elasticity tensor for orthotropic material:\n[elasticity_tensor]\ntype = ComputeElasticityTensor\nfill_method = orthotropic\nC_ijkl = '4.95e8 4.95e8 1.78e9 9.549e6 2.8568e8 2.8568e8 0.06925 0.249717818 0.249717818 0.06925 0.069444 0.069444'\nblock = 'block1'\n[]\nAnd upon executing I get the following error:\n*** ERROR ***\nOrthotropic elasticity tensor input is not consistent with symmetry requirements. Check input for accuracy\nWhen I look at the source of the error (https://mooseframework.inl.gov/docs/doxygen/moose/classRankFourTensorTempl.html#a0ffa73b46895112e75bc64265041569f) in the doxygen, I checked the conditions and it seems to me everything looks consistent between the Young's modulus and Poisson's ratio.\nIs the error because of precision or am I missing something completely ?\nThanks,\nAritra",
          "url": "https://github.com/idaholab/moose/discussions/25325",
          "updatedAt": "2023-08-30T17:43:28Z",
          "publishedAt": "2023-08-28T20:26:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Your input is failing this\n815   // Input must satisfy constraints.\n  816   bool preserve_symmetry = [MooseUtils::absoluteFuzzyEqual(nuab * Eb, nuba * Ea) &&\n  817                            [MooseUtils::absoluteFuzzyEqual(nuca * Ea, nuac * Ec) &&\n  818                            [MooseUtils::absoluteFuzzyEquall(nubc * Ec, nucb * Eb);\n  819 \n  820   if (!preserve_symmetry)\n  821     [mooseError](https://mooseframework.inl.gov/docs/doxygen/moose/MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad)(\"Orthotropic elasticity tensor input is not consistent with symmetry requirements. \"\n  822                \"Check input for accuracy\");",
                  "url": "https://github.com/idaholab/moose/discussions/25325#discussioncomment-6846709",
                  "updatedAt": "2023-08-28T21:14:35Z",
                  "publishedAt": "2023-08-28T21:13:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so yeah it could be that you are not inputting enough digits to satisfy these equalities",
                          "url": "https://github.com/idaholab/moose/discussions/25325#discussioncomment-6846720",
                          "updatedAt": "2023-08-28T21:14:58Z",
                          "publishedAt": "2023-08-28T21:14:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "I thought so.. I was actually inputting all the digits in a regular calculator, lol. But I will think of something",
                          "url": "https://github.com/idaholab/moose/discussions/25325#discussioncomment-6847292",
                          "updatedAt": "2023-08-28T23:11:31Z",
                          "publishedAt": "2023-08-28T23:11:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "@GiudGiud yeah it was the precision issue, and the following works:\n[elasticity_tensor]\ntype = ComputeElasticityTensor\nfill_method = orthotropic\nC_ijkl = '5.0e8  5.0e8  2.0e9  9.549e6 2.8568e8 2.8568e8    0.06925   0.277776   0.277776  0.06925   0.069444     0.069444'\nblock = 'skin_region core'\n[]\nAnother question, for Compute Thermal Expansion EigenStrain\n\nCan we use an alpha tensor ? so different alpha_xx, alpha_yy, and alpha_zz by entering the thermal expansion coefficient as a tensor ? or does it take only scalar values ?\nThanks,\nAritra",
                          "url": "https://github.com/idaholab/moose/discussions/25325#discussioncomment-6853882",
                          "updatedAt": "2023-08-29T14:23:23Z",
                          "publishedAt": "2023-08-29T14:23:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "only takes a scalar here\nfeel free to modify",
                          "url": "https://github.com/idaholab/moose/discussions/25325#discussioncomment-6854236",
                          "updatedAt": "2023-08-29T14:56:08Z",
                          "publishedAt": "2023-08-29T14:56:07Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using SodiumSaturationFluidProperties in THM",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "@GiudGiud @joshuahansel\nHello Giud and josh, I'm trying to calculate some sodium case in THM. But I find that SodiumSaturationFluidProperties is not like LeadBismuthFluidProperties which can be used in THM directly. Some state functions like h_from_v_e or p_from_v_e, are needed in SodiumSaturationFluidProperties. So I added them to SodiumSaturationFluidProperties. Now the SodiumSaturationFluidProperties can pass the unit test, but not converge in specific case. I guess there's something wrong with the latest code I added.\nI want to ask how should I find out the mistake? Or can you help me to check the code?\nHere is the code:\nhead:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#pragma once\n\n#include \"SinglePhaseFluidProperties.h\"\n\n/**\n * Fluid properties for liquid sodium at saturation conditions \\cite{sas} \\cite{fink}.\n */\nclass SodiumSaturationFluidProperties : public SinglePhaseFluidProperties\n{\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Woverloaded-virtual\"\npublic:\n  static InputParameters validParams();\n\n  SodiumSaturationFluidProperties(const InputParameters & parameters);\n\n  virtual std::string fluidName() const override;\n\n  virtual Real rho_from_p_T(Real p, Real T) const override;\n\n  virtual void\n  rho_from_p_T(Real p, Real T, Real & rho, Real & drho_dp, Real & drho_dT) const override;\n  virtual void rho_from_p_T(const DualReal & p,\n                            const DualReal & T,\n                            DualReal & rho,\n                            DualReal & drho_dp,\n                            DualReal & drho_dT) const override;\n\n  virtual Real v_from_p_T(Real p, Real T) const override;\n  virtual void v_from_p_T(Real p, Real T, Real & v, Real & dv_dp, Real & dv_dT) const override;\n\n  virtual Real p_from_v_e(Real v, Real e) const override;\n  virtual void p_from_v_e(Real v, Real e, Real & p, Real & dp_dv, Real & dp_de) const override;\n  virtual Real T_from_v_e(Real v, Real e) const override;\n  virtual void T_from_v_e(Real v, Real e, Real & T, Real & dT_dv, Real & dT_de) const override;\n\n  virtual Real h_from_p_T(Real p, Real T) const override;\n  virtual void h_from_p_T(Real p, Real T, Real & h, Real & dh_dp, Real & dh_dT) const override;\n  virtual Real h_from_v_e(Real v, Real e) const;\n  virtual void h_from_v_e(Real v, Real e, Real & h, Real & dh_dv, Real & dh_de) const;\n\n  virtual Real e_from_p_T(Real p, Real T) const override;\n  virtual void e_from_p_T(Real p, Real T, Real & e, Real & de_dp, Real & de_dT) const override;\n\n  virtual Real e_from_p_rho(Real p, Real rho) const override;\n  virtual void e_from_p_rho(Real p, Real rho, Real & e, Real & de_dp, Real & de_drho) const override;\n\n  virtual Real cp_from_p_T(Real p, Real T) const override;\n  virtual void cp_from_p_T(Real p, Real T, Real & cp, Real & dcp_dp, Real & dcp_dT) const override;\n\n  virtual Real c_from_v_e(Real v, Real e) const override;\n  virtual DualReal c_from_v_e(const DualReal & v, const DualReal & e) const override;\n\n  virtual Real cp_from_v_e(Real v, Real e) const override;\n  virtual void cp_from_v_e(Real v, Real e, Real & cp, Real & dcp_dv, Real & dcp_de) const override;\n\n  virtual Real cv_from_v_e(Real v, Real e) const override;\n  virtual void cv_from_v_e(Real v, Real e, Real & cv, Real & dcv_dv, Real & dcv_de) const override;\n\n  virtual Real mu_from_v_e(Real v, Real e) const override;\n  virtual void mu_from_v_e(Real v, Real e, Real & mu, Real & dmu_dv, Real & dmu_de) const override;\n\n  virtual Real k_from_v_e(Real v, Real e) const override;\n  virtual void k_from_v_e(Real v, Real e, Real & k, Real & dk_dv, Real & dk_de) const override;\n\n  using SinglePhaseFluidProperties::cv_from_p_T;\n\n  virtual Real cv_from_p_T(Real p, Real T) const override;\n  virtual void cv_from_p_T(Real p, Real T, Real & cv, Real & dcv_dp, Real & dcv_dT) const override;\n\n  virtual Real molarMass() const override;\n\n  virtual Real k_from_p_T(Real p, Real T) const override;\n  virtual void k_from_p_T(Real p, Real T, Real & k, Real & dk_dp, Real & dk_dT) const override;\n\n  virtual Real mu_from_p_T(Real p, Real T) const override;\n  virtual void\n  mu_from_p_T(Real p, Real T, Real & mu, Real & dmu_drho, Real & dmu_dT) const override;\n};\n#pragma GCC diagnostic pop\n\nsource:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"SodiumSaturationFluidProperties.h\"\n\nregisterMooseObject(\"FluidPropertiesApp\", SodiumSaturationFluidProperties);\n\nInputParameters\nSodiumSaturationFluidProperties::validParams()\n{\n  InputParameters params = SinglePhaseFluidProperties::validParams();\n  params.addClassDescription(\"Fluid properties for liquid sodium at saturation conditions\");\n  return params;\n}\n\nSodiumSaturationFluidProperties::SodiumSaturationFluidProperties(const InputParameters & parameters)\n  : SinglePhaseFluidProperties(parameters)\n{\n}\n\nstd::string\nSodiumSaturationFluidProperties::fluidName() const\n{\n  return \"sodium_sat\";\n}\n\nReal\nSodiumSaturationFluidProperties::molarMass() const\n{\n  return 22.989769E-3;\n}\n\nReal\nSodiumSaturationFluidProperties::rho_from_p_T(Real /* pressure */, Real temperature) const\n{\n  return 1.00423e3 - 0.21390 * temperature - 1.1046e-5 * temperature * temperature;\n}\n\nvoid\nSodiumSaturationFluidProperties::rho_from_p_T(\n    Real pressure, Real temperature, Real & rho, Real & drho_dp, Real & drho_dT) const\n{\n  rho = rho_from_p_T(pressure, temperature);\n  drho_dp = 0.0;\n  drho_dT = -0.21390 - 1.1046e-5 * 2 * temperature;\n}\n\nvoid\nSodiumSaturationFluidProperties::rho_from_p_T(const DualReal & pressure,\n                                              const DualReal & temperature,\n                                              DualReal & rho,\n                                              DualReal & drho_dp,\n                                              DualReal & drho_dT) const\n{\n  rho = SinglePhaseFluidProperties::rho_from_p_T(pressure, temperature);\n  drho_dp = 0.0;\n  drho_dT = -0.21390 - 1.1046e-5 * 2 * temperature;\n}\n\nReal\nSodiumSaturationFluidProperties::v_from_p_T(Real pressure, Real temperature) const\n{\n  return 1.0 / rho_from_p_T(pressure, temperature);\n}\n\nvoid\nSodiumSaturationFluidProperties::v_from_p_T(\n    Real pressure, Real temperature, Real & v, Real & dv_dp, Real & dv_dT) const\n{\n  v = v_from_p_T(pressure, temperature);\n  dv_dp = 0.0;\n\n  Real drho_dT = -0.21390 - 1.1046e-5 * 2 * temperature;\n  dv_dT = -v * v * drho_dT;\n}\n\nReal\nSodiumSaturationFluidProperties::p_from_v_e(Real v, Real e) const\n{\n  Real temperature = T_from_v_e(v, e);\n  // h does not depend on pressure\n  return (h_from_p_T(1e5, temperature) - e) / v;\n}\n\nvoid\nSodiumSaturationFluidProperties::p_from_v_e(Real v, Real e, Real & p, Real & dp_dv, Real & dp_de) const\n{\n  Real temperature, h, dT_dv, dh_dv, dT_de, dh_de;\n  temperature = T_from_v_e(v, e);\n  p = p_from_v_e(v, e);\n  h = h_from_p_T(1e5, temperature);\n  dT_dv = std::pow(0.2139*0.2139 + 4*1.1046e-5*(1.00423e3 - 1/v), -0.5)/v/v;\n  dT_de = 0.0;\n  dh_dv = cp_from_p_T(p, temperature)*dT_dv;\n  dh_de = cp_from_p_T(p, temperature)*dT_de;\n  dp_dv = (dh_dv*v - (h - e))/v/v;\n  dp_de = (dh_de - 1.0)/v;\n}\n\n\nReal\nSodiumSaturationFluidProperties::T_from_v_e(Real v, Real /* e */) const\n{\n  // From inversion of second order polynomial form of rho(T)\n  mooseAssert(0.2139 * 0.2139 + 4 * 1.1046e5 * (1.00423e3 - 1 / v) > 0,\n              \"Specific volume out of bounds\");\n  return (0.2139 - std::sqrt(0.2139 * 0.2139 + 4 * 1.1046e-5 * (1.00423e3 - 1 / v))) /\n         (2 * -1.1046e-5);\n}\n\nvoid\nSodiumSaturationFluidProperties::T_from_v_e(Real v, Real e, Real & T, Real & dT_dv, Real & dT_de) const\n{\n  T = T_from_v_e(v, e);\n  dT_de = 0;\n  dT_dv = std::pow(0.2139*0.2139 + 4*1.1046e-5*(1.00423e3 - 1.0/v), -0.5)/v/v;\n}\n\nReal\nSodiumSaturationFluidProperties::h_from_p_T(Real /*pressure*/, Real temperature) const\n{\n  Real t2 = temperature * temperature;\n  return 3.7782E-10 * t2 * t2 * temperature / 5 - 1.7191E-6 * t2 * t2 / 4.0 +\n         3.0921E-3 * t2 * temperature / 3.0 - 2.4560 * t2 / 2.0 + 1972.0 * temperature - 401088.7;\n}\n\nvoid\nSodiumSaturationFluidProperties::h_from_p_T(\n    Real pressure, Real temperature, Real & h, Real & dh_dp, Real & dh_dT) const\n{\n  h = h_from_p_T(pressure, temperature);\n  dh_dp = 0.0;\n  dh_dT = cp_from_p_T(pressure, temperature);\n}\n\nReal\nSodiumSaturationFluidProperties::h_from_v_e(Real v, Real e) const\n{\n  Real temperature = T_from_v_e(v, e);\n  Real t2 = temperature * temperature;\n  return 3.7782E-10 * t2 * t2 * temperature / 5 - 1.7191E-6 * t2 * t2 / 4.0 +\n         3.0921E-3 * t2 * temperature / 3.0 - 2.4560 * t2 / 2.0 + 1972.0 * temperature - 401088.7;\n}\n\nvoid\nSodiumSaturationFluidProperties::h_from_v_e(Real v, Real e, Real & h, Real & dh_dv, Real & dh_de) const\n{\n  Real T, dT_dv, dT_de;\n  T_from_v_e(v, e, T, dT_dv, dT_de);\n  h = h_from_v_e(v, e);\n  Real cp = cp_from_v_e(v, e);\n  dh_dv = cp * dT_dv;\n  dh_de = cp * dT_de;\n}\n\nReal\nSodiumSaturationFluidProperties::e_from_p_T(Real pressure, Real temperature) const\n{\n  // definition of h = e + p * v\n  Real v = v_from_p_T(pressure, temperature);\n  Real h = h_from_p_T(pressure, temperature);\n  return h - pressure * v;\n}\n\nvoid\nSodiumSaturationFluidProperties::e_from_p_T(\n    Real pressure, Real temperature, Real & e, Real & de_dp, Real & de_dT) const\n{\n  e = e_from_p_T(pressure, temperature);\n\n  Real v, dv_dp, dv_dT;\n  v_from_p_T(pressure, temperature, v, dv_dp, dv_dT);\n\n  // definition of e = h - p * v, with dh/dp = 0\n  de_dp = -pressure * dv_dp - v;\n\n  // definition of e = h - p * v\n  Real cp = cp_from_p_T(pressure, temperature);\n  de_dT = cp - pressure * dv_dT;\n}\n\nReal\nSodiumSaturationFluidProperties::e_from_p_rho(Real pressure, Real rho) const\n{\n  // definition of h = e + p * v\n  Real v = 1.0/rho;\n  Real temperature = (0.2139 - std::sqrt(0.2139 * 0.2139 + 4 * 1.1046e-5 * (1.00423e3 - 1 / v))) / (2 * -1.1046e-5);\n  Real h = h_from_p_T(pressure, temperature);\n  return h - pressure * v;\n}\n\nvoid\nSodiumSaturationFluidProperties::e_from_p_rho(\n    Real pressure, Real rho, Real & e, Real & de_dp, Real & de_drho) const\n{\n  e = e_from_p_rho(pressure, rho);\n\n  Real v, dv_dp, dv_dT;\n  Real temperature = (0.2139 - std::sqrt(0.2139 * 0.2139 + 4 * 1.1046e-5 * (1.00423e3 - 1 / v))) / (2 * -1.1046e-5);\n  v_from_p_T(pressure, temperature, v, dv_dp, dv_dT);\n\n  // definition of e = h - p * v, with dh/dp = 0\n  de_dp = -pressure * dv_dp - v;\n\n  // definition of e = h - p * v\n  Real cp = cp_from_p_T(pressure, temperature);\n  Real drho_dT = -0.21390 - 1.1046e-5 * 2 * temperature;\n  de_drho = cp/drho_dT + pressure/rho/rho;\n}\n\n\nReal\nSodiumSaturationFluidProperties::cp_from_p_T(Real /*pressure*/, Real temperature) const\n{\n  Real t2 = temperature * temperature;\n  return 3.7782E-10 * t2 * t2 - 1.7191E-6 * t2 * temperature + 3.0921E-3 * t2 -\n         2.4560 * temperature + 1972.0;\n}\n\nvoid\nSodiumSaturationFluidProperties::cp_from_p_T(\n    Real pressure, Real temperature, Real & cp, Real & dcp_dp, Real & dcp_dT) const\n{\n  cp = cp_from_p_T(pressure, temperature);\n  dcp_dp = 0.0;\n\n  Real t2 = temperature * temperature;\n  dcp_dT =\n      4 * 3.7782E-10 * t2 * temperature - 3 * 1.7191E-6 * t2 + 2 * 3.0921e-3 * temperature - 2.456;\n}\n\nReal\nSodiumSaturationFluidProperties::cp_from_v_e(Real v, Real e) const\n{\n  Real temperature = T_from_v_e(v, e);\n  Real t2 = temperature * temperature;\n  return 3.7782E-10 * t2 * t2 - 1.7191E-6 * t2 * temperature + 3.0921E-3 * t2 -\n         2.4560 * temperature + 1972.0;\n}\n\nvoid\nSodiumSaturationFluidProperties::cp_from_v_e(\n    Real v, Real e, Real & cp, Real & dcp_dv, Real & dcp_de) const\n{\n  Real T, dT_dv, dT_de;\n  Real t2 = T*T;\n  T_from_v_e(v, e, T, dT_dv, dT_de);\n  cp = cp_from_v_e(v, e);\n  dcp_dv = (4 * 3.7782E-10 * t2 * T - 3 * 1.7191E-6 * t2 + 2 * 3.0921e-3 * T - 2.456)*dT_dv;\n  dcp_de = (4 * 3.7782E-10 * t2 * T - 3 * 1.7191E-6 * t2 + 2 * 3.0921e-3 * T - 2.456)*dT_de;\n}\n\n\nReal\nSodiumSaturationFluidProperties::cv_from_p_T(Real /* pressure */, Real temperature) const\n{\n  Real t2 = temperature * temperature;\n  return 1.0369E-8 * temperature * t2 + 3.7164E-4 * t2 - 1.0494 * temperature + 1582.6;\n}\n\nvoid\nSodiumSaturationFluidProperties::cv_from_p_T(\n    Real pressure, Real temperature, Real & cv, Real & dcv_dp, Real & dcv_dT) const\n{\n  cv = cv_from_p_T(pressure, temperature);\n  dcv_dp = 0.0;\n  dcv_dT = 3 * 1.0369e-8 * temperature * temperature + 2 * 3.7164e-4 * temperature - 1.0494;\n}\n\nReal\nSodiumSaturationFluidProperties::cv_from_v_e(Real v, Real e) const\n{\n  Real p = p_from_v_e(v, e);\n  Real T = T_from_v_e(v, e);\n  return cv_from_p_T(p, T);\n}\n\nvoid\nSodiumSaturationFluidProperties::cv_from_v_e(Real v, Real e, Real & cv, Real & dcv_dv, Real & dcv_de) const\n{\n  Real p, dp_dv, dp_de;\n  p_from_v_e(v, e, p, dp_dv, dp_de);\n  Real T, dT_dv, dT_de;\n  T_from_v_e(v, e, T, dT_dv, dT_de);\n  Real dcv_dp, dcv_dT;\n  cv_from_p_T(p, T, cv, dcv_dp, dcv_dT);\n  dcv_dv = dcv_dp * dp_dv + dcv_dT * dT_dv;\n  dcv_de = dcv_dp * dp_de + dcv_dT * dT_de;\n}\n\nReal\nSodiumSaturationFluidProperties::mu_from_p_T(Real /*pressure*/, Real temperature) const\n{\n  return 3.6522E-5 + 0.16626 / temperature - 4.56877e1 / (temperature * temperature) +\n         2.8733E4 / (temperature * temperature * temperature);\n}\n\nvoid\nSodiumSaturationFluidProperties::mu_from_p_T(\n    Real pressure, Real temperature, Real & mu, Real & dmu_dp, Real & dmu_dT) const\n{\n  mu = this->mu_from_p_T(pressure, temperature);\n  dmu_dp = 0.0;\n\n  Real t2 = temperature * temperature;\n  dmu_dT = 0.16626 * -1 / t2 - 4.56877E1 * -2 / (temperature * t2) + 2.8733E4 * -3 / (t2 * t2);\n}\n\nReal\nSodiumSaturationFluidProperties::mu_from_v_e(Real v, Real e) const\n{\n  Real temperature = T_from_v_e(v, e);\n  return 3.6522E-5 + 0.16626 / temperature - 4.56877e1 / (temperature * temperature) +\n         2.8733E4 / (temperature * temperature * temperature);\n}\n\nvoid\nSodiumSaturationFluidProperties::mu_from_v_e(\n    Real v, Real e, Real & mu, Real & dmu_dv, Real & dmu_de) const\n{\n  Real T, dT_dv, dT_de;\n  Real t2 = T*T;\n  T_from_v_e(v, e, T, dT_dv, dT_de);\n  mu = mu_from_v_e(v, e);\n  dmu_dv = dT_dv*(0.16626 * -1 / t2 - 4.56877E1 * -2 / (T * t2) + 2.8733E4 * -3 / (t2 * t2));\n  dmu_de = dT_de*(0.16626 * -1 / t2 - 4.56877E1 * -2 / (T * t2) + 2.8733E4 * -3 / (t2 * t2));\n}\n\nReal\nSodiumSaturationFluidProperties::k_from_p_T(Real /*pressure*/, Real temperature) const\n{\n  return 1.1045e2 - 6.5112e-2 * temperature + 1.5430e-5 * temperature * temperature -\n         2.4617e-9 * temperature * temperature * temperature;\n}\n\nvoid\nSodiumSaturationFluidProperties::k_from_p_T(\n    Real pressure, Real temperature, Real & k, Real & dk_dp, Real & dk_dT) const\n{\n  k = this->k_from_p_T(pressure, temperature);\n  dk_dp = 0.0;\n  dk_dT = -6.5112e-2 + 2 * 1.5430e-5 * temperature - 3 * 2.4617e-9 * temperature * temperature;\n}\n\nReal\nSodiumSaturationFluidProperties::k_from_v_e(Real v, Real e) const\n{\n  Real temperature = T_from_v_e(v, e);\n  return 1.1045e2 - 6.5112e-2 * temperature + 1.5430e-5 * temperature * temperature -\n         2.4617e-9 * temperature * temperature * temperature;\n}\n\nvoid\nSodiumSaturationFluidProperties::k_from_v_e(Real v, Real e, Real & k, Real & dk_dv, Real & dk_de) const\n{\n  Real T, dT_dv, dT_de;\n  T_from_v_e(v, e, T, dT_dv, dT_de);\n  k = k_from_v_e(v, e);\n  dk_dv = dT_dv*(-6.5112e-2 + 2 * 1.5430e-5 * T - 3 * 2.4617e-9 * T * T);\n  dk_de = dT_de*(-6.5112e-2 + 2 * 1.5430e-5 * T - 3 * 2.4617e-9 * T * T);\n}\n\n\nReal\nSodiumSaturationFluidProperties::c_from_v_e(Real v, Real e) const\n{\n  Real T = T_from_v_e(v, e);\n  return 2660.7 - 0.37667*T - 9.0356e-5*T*T;\n}\n\nDualReal\nSodiumSaturationFluidProperties::c_from_v_e(const DualReal & v, const DualReal & e) const\n{\n  DualReal T = SinglePhaseFluidProperties::T_from_v_e(v, e);\n  return 2660.7 - 0.37667*T - 9.0356e-5*T*T;\n}",
          "url": "https://github.com/idaholab/moose/discussions/25303",
          "updatedAt": "2023-08-29T12:10:17Z",
          "publishedAt": "2023-08-25T09:21:09Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you check that your implementation is correct by looking at:\nh_from_v_e\nh_from_p_T(p_from_v_e, T_from_v_e)?\nsame question for p.\nThen did you add the derivatives tests?\nSodiumSaturation is a bit of a weird property btw. @aprilnovak added it in a very specific context I think\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6823496",
                  "updatedAt": "2023-08-25T13:55:05Z",
                  "publishedAt": "2023-08-25T13:55:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "I nearly add all the property_from_v_e by property_from_p_T(p_from_v_e, T_from_v_e).\nAnd how should I add the derivatives tests?",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6823560",
                          "updatedAt": "2023-08-25T14:01:38Z",
                          "publishedAt": "2023-08-25T14:01:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It s a special kind of unit tests, see the LeadBismuthFPTest for an example",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6823570",
                          "updatedAt": "2023-08-25T14:02:31Z",
                          "publishedAt": "2023-08-25T14:02:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "OK. So I should run the derivatives tests in the same way as I run the other unit tests? Enter the document and make in the terminal?",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6823656",
                          "updatedAt": "2023-08-25T14:11:06Z",
                          "publishedAt": "2023-08-25T14:11:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes it s very similar. You add to the file, creating batteries of new tests, then you make in the fluid_properties/unit folder, then you ./run_tests in that folder",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6823853",
                          "updatedAt": "2023-08-25T14:32:35Z",
                          "publishedAt": "2023-08-25T14:32:34Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Thank you Giud, I will do this later.\nEthan",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6823906",
                          "updatedAt": "2023-08-25T14:39:20Z",
                          "publishedAt": "2023-08-25T14:39:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Ethan-xj"
                  },
                  "bodyText": "@joshuahansel @GiudGiud Hi guys, I made some changes to the SodiumSaturationFluidProperties and now it can be used in THM. It also passed the new tests I created. I think I should share it here and maybe you can add it to MOOSE. Btw, I didn't write the code normatively, so maybe you should rectify the code which is nonstandard.\nHead:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#pragma once\n\n#include \"SinglePhaseFluidProperties.h\"\n\n/**\n * Fluid properties for liquid sodium at saturation conditions \\cite{sas} \\cite{fink}.\n */\nclass SodiumSaturationFluidProperties : public SinglePhaseFluidProperties\n{\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Woverloaded-virtual\"\npublic:\n  static InputParameters validParams();\n\n  SodiumSaturationFluidProperties(const InputParameters & parameters);\n\n  virtual std::string fluidName() const override;\n\n  virtual Real rho_from_p_T(Real p, Real T) const override;\n\n  virtual void\n  rho_from_p_T(Real p, Real T, Real & rho, Real & drho_dp, Real & drho_dT) const override;\n  virtual void rho_from_p_T(const DualReal & p,\n                            const DualReal & T,\n                            DualReal & rho,\n                            DualReal & drho_dp,\n                            DualReal & drho_dT) const override;\n\n  virtual Real v_from_p_T(Real p, Real T) const override;\n  virtual void v_from_p_T(Real p, Real T, Real & v, Real & dv_dp, Real & dv_dT) const override;\n\n  virtual Real p_from_v_e(Real v, Real e) const override;\n  virtual void p_from_v_e(Real v, Real e, Real & p, Real & dp_dv, Real & dp_de) const override;\n  virtual Real T_from_v_e(Real v, Real e) const override;\n  virtual void T_from_v_e(Real v, Real e, Real & T, Real & dT_dv, Real & dT_de) const override;\n\n  virtual Real h_from_p_T(Real p, Real T) const override;\n  virtual void h_from_p_T(Real p, Real T, Real & h, Real & dh_dp, Real & dh_dT) const override;\n  virtual Real h_from_v_e(Real v, Real e) const;\n  virtual void h_from_v_e(Real v, Real e, Real & h, Real & dh_dv, Real & dh_de) const;\n\n  virtual Real e_from_p_T(Real p, Real T) const override;\n  virtual void e_from_p_T(Real p, Real T, Real & e, Real & de_dp, Real & de_dT) const override;\n\n  virtual Real e_from_p_rho(Real p, Real rho) const override;\n  virtual void e_from_p_rho(Real p, Real rho, Real & e, Real & de_dp, Real & de_drho) const override;\n\n  virtual Real cp_from_p_T(Real p, Real T) const override;\n  virtual void cp_from_p_T(Real p, Real T, Real & cp, Real & dcp_dp, Real & dcp_dT) const override;\n\n  virtual Real c_from_v_e(Real v, Real e) const override;\n  virtual DualReal c_from_v_e(const DualReal & v, const DualReal & e) const override;\n\n  virtual Real cp_from_v_e(Real v, Real e) const override;\n  virtual void cp_from_v_e(Real v, Real e, Real & cp, Real & dcp_dv, Real & dcp_de) const override;\n\n  virtual Real cv_from_v_e(Real v, Real e) const override;\n  virtual void cv_from_v_e(Real v, Real e, Real & cv, Real & dcv_dv, Real & dcv_de) const override;\n\n  virtual Real mu_from_v_e(Real v, Real e) const override;\n  virtual void mu_from_v_e(Real v, Real e, Real & mu, Real & dmu_dv, Real & dmu_de) const override;\n\n  virtual Real k_from_v_e(Real v, Real e) const override;\n  virtual void k_from_v_e(Real v, Real e, Real & k, Real & dk_dv, Real & dk_de) const override;\n\n  using SinglePhaseFluidProperties::cv_from_p_T;\n\n  virtual Real cv_from_p_T(Real p, Real T) const override;\n  virtual void cv_from_p_T(Real p, Real T, Real & cv, Real & dcv_dp, Real & dcv_dT) const override;\n\n  virtual Real molarMass() const override;\n\n  virtual Real k_from_p_T(Real p, Real T) const override;\n  virtual void k_from_p_T(Real p, Real T, Real & k, Real & dk_dp, Real & dk_dT) const override;\n\n  virtual Real mu_from_p_T(Real p, Real T) const override;\n  virtual void\n  mu_from_p_T(Real p, Real T, Real & mu, Real & dmu_drho, Real & dmu_dT) const override;\n};\n#pragma GCC diagnostic pop\n\nSource:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"SodiumSaturationFluidProperties.h\"\n\nregisterMooseObject(\"FluidPropertiesApp\", SodiumSaturationFluidProperties);\n\nInputParameters\nSodiumSaturationFluidProperties::validParams()\n{\n  InputParameters params = SinglePhaseFluidProperties::validParams();\n  params.addClassDescription(\"Fluid properties for liquid sodium at saturation conditions\");\n  return params;\n}\n\nSodiumSaturationFluidProperties::SodiumSaturationFluidProperties(const InputParameters & parameters)\n  : SinglePhaseFluidProperties(parameters)\n{\n}\n\nstd::string\nSodiumSaturationFluidProperties::fluidName() const\n{\n  return \"sodium_sat\";\n}\n\nReal\nSodiumSaturationFluidProperties::molarMass() const\n{\n  return 22.989769E-3;\n}\n\nReal\nSodiumSaturationFluidProperties::rho_from_p_T(Real /* pressure */, Real temperature) const\n{\n  return 1.00423e3 - 0.21390 * temperature - 1.1046e-5 * temperature * temperature;\n}\n\nvoid\nSodiumSaturationFluidProperties::rho_from_p_T(\n    Real pressure, Real temperature, Real & rho, Real & drho_dp, Real & drho_dT) const\n{\n  rho = rho_from_p_T(pressure, temperature);\n  drho_dp = 0.0;\n  drho_dT = -0.21390 - 1.1046e-5 * 2 * temperature;\n}\n\nvoid\nSodiumSaturationFluidProperties::rho_from_p_T(const DualReal & pressure,\n                                              const DualReal & temperature,\n                                              DualReal & rho,\n                                              DualReal & drho_dp,\n                                              DualReal & drho_dT) const\n{\n  rho = SinglePhaseFluidProperties::rho_from_p_T(pressure, temperature);\n  drho_dp = 0.0;\n  drho_dT = -0.21390 - 1.1046e-5 * 2 * temperature;\n}\n\nReal\nSodiumSaturationFluidProperties::v_from_p_T(Real pressure, Real temperature) const\n{\n  return 1.0 / rho_from_p_T(pressure, temperature);\n}\n\nvoid\nSodiumSaturationFluidProperties::v_from_p_T(\n    Real pressure, Real temperature, Real & v, Real & dv_dp, Real & dv_dT) const\n{\n  v = v_from_p_T(pressure, temperature);\n  dv_dp = 0.0;\n\n  Real drho_dT = -0.21390 - 1.1046e-5 * 2 * temperature;\n  dv_dT = -v * v * drho_dT;\n}\n\nReal\nSodiumSaturationFluidProperties::p_from_v_e(Real v, Real e) const\n{\n  Real temperature = T_from_v_e(v, e);\n  // h does not depend on pressure\n  return (h_from_p_T(1e5, temperature) - e) / v;\n}\n\nvoid\nSodiumSaturationFluidProperties::p_from_v_e(Real v, Real e, Real & p, Real & dp_dv, Real & dp_de) const\n{\n  Real temperature, h, dT_dv, dh_dv, dT_de, dh_de;\n  temperature = T_from_v_e(v, e);\n  p = p_from_v_e(v, e);\n  h = h_from_p_T(1e5, temperature);\n  dT_dv = 1.0/std::sqrt(0.2139*0.2139 + 4*1.1046e-5*(1.00423e3 - 1/v))/v/v;\n  dT_de = 0.0;\n  dh_dv = cp_from_p_T(p, temperature)*dT_dv;\n  dh_de = cp_from_p_T(p, temperature)*dT_de;\n  dp_dv = (dh_dv*v - h + e)/v/v;\n  dp_de = (dh_de - 1.0)/v;\n}\n\n\nReal\nSodiumSaturationFluidProperties::T_from_v_e(Real v, Real /* e */) const\n{\n  // From inversion of second order polynomial form of rho(T)\n  mooseAssert(0.2139 * 0.2139 + 4 * 1.1046e5 * (1.00423e3 - 1 / v) > 0,\n              \"Specific volume out of bounds\");\n  return (0.2139 - std::sqrt(0.2139 * 0.2139 + 4 * 1.1046e-5 * (1.00423e3 - 1 / v))) /\n         (2 * -1.1046e-5);\n}\n\nvoid\nSodiumSaturationFluidProperties::T_from_v_e(Real v, Real e, Real & T, Real & dT_dv, Real & dT_de) const\n{\n  T = T_from_v_e(v, e);\n  dT_de = 0;\n  dT_dv = 1.0/std::sqrt(0.2139*0.2139 + 4*1.1046e-5*(1.00423e3 - 1/v))/v/v;\n}\n\nReal\nSodiumSaturationFluidProperties::h_from_p_T(Real /*pressure*/, Real temperature) const\n{\n  Real t2 = temperature * temperature;\n  return 3.7782E-10 * t2 * t2 * temperature / 5 - 1.7191E-6 * t2 * t2 / 4.0 +\n         3.0921E-3 * t2 * temperature / 3.0 - 2.4560 * t2 / 2.0 + 1972.0 * temperature - 401088.7;\n}\n\nvoid\nSodiumSaturationFluidProperties::h_from_p_T(\n    Real pressure, Real temperature, Real & h, Real & dh_dp, Real & dh_dT) const\n{\n  h = h_from_p_T(pressure, temperature);\n  dh_dp = 0.0;\n  dh_dT = cp_from_p_T(pressure, temperature);\n}\n\nReal\nSodiumSaturationFluidProperties::h_from_v_e(Real v, Real e) const\n{\n  Real temperature = T_from_v_e(v, e);\n  Real t2 = temperature * temperature;\n  return 3.7782E-10 * t2 * t2 * temperature / 5 - 1.7191E-6 * t2 * t2 / 4.0 +\n         3.0921E-3 * t2 * temperature / 3.0 - 2.4560 * t2 / 2.0 + 1972.0 * temperature - 401088.7;\n}\n\nvoid\nSodiumSaturationFluidProperties::h_from_v_e(Real v, Real e, Real & h, Real & dh_dv, Real & dh_de) const\n{\n  Real T, dT_dv, dT_de;\n  T_from_v_e(v, e, T, dT_dv, dT_de);\n  h = h_from_v_e(v, e);\n  Real cp = cp_from_v_e(v, e);\n  dh_dv = cp * dT_dv;\n  dh_de = cp * dT_de;\n}\n\nReal\nSodiumSaturationFluidProperties::e_from_p_T(Real pressure, Real temperature) const\n{\n  // definition of h = e + p * v\n  Real v = v_from_p_T(pressure, temperature);\n  Real h = h_from_p_T(pressure, temperature);\n  return h - pressure * v;\n}\n\nvoid\nSodiumSaturationFluidProperties::e_from_p_T(\n    Real pressure, Real temperature, Real & e, Real & de_dp, Real & de_dT) const\n{\n  e = e_from_p_T(pressure, temperature);\n\n  Real v, dv_dp, dv_dT;\n  v_from_p_T(pressure, temperature, v, dv_dp, dv_dT);\n\n  // definition of e = h - p * v, with dh/dp = 0\n  de_dp = -pressure * dv_dp - v;\n\n  // definition of e = h - p * v\n  Real cp = cp_from_p_T(pressure, temperature);\n  de_dT = cp - pressure * dv_dT;\n}\n\nReal\nSodiumSaturationFluidProperties::e_from_p_rho(Real pressure, Real rho) const\n{\n  // definition of h = e + p * v\n  Real v = 1.0/rho;\n  Real temperature = (0.2139 - std::sqrt(0.2139 * 0.2139 + 4 * 1.1046e-5 * (1.00423e3 - 1 / v))) / (2 * -1.1046e-5);\n  Real h = h_from_p_T(pressure, temperature);\n  return h - pressure * v;\n}\n\nvoid\nSodiumSaturationFluidProperties::e_from_p_rho(\n    Real pressure, Real rho, Real & e, Real & de_dp, Real & de_drho) const\n{\n  e = e_from_p_rho(pressure, rho);\n  Real T = T_from_v_e(1.0/rho, e);\n  Real de_dp_T, de_dT, dT_drho;\n  e_from_p_T(pressure, T, e, de_dp_T, de_dT);\n  de_dp = de_dp_T;\n  dT_drho = -1.0/std::sqrt(0.2139*0.2139 + 4*1.1046e-5*(1.00423e3 - rho));\n  de_drho = de_dT*dT_drho;\n}\n\n\nReal\nSodiumSaturationFluidProperties::cp_from_p_T(Real /*pressure*/, Real temperature) const\n{\n  Real t2 = temperature * temperature;\n  return 3.7782E-10 * t2 * t2 - 1.7191E-6 * t2 * temperature + 3.0921E-3 * t2 -\n         2.4560 * temperature + 1972.0;\n}\n\nvoid\nSodiumSaturationFluidProperties::cp_from_p_T(\n    Real pressure, Real temperature, Real & cp, Real & dcp_dp, Real & dcp_dT) const\n{\n  cp = cp_from_p_T(pressure, temperature);\n  dcp_dp = 0.0;\n\n  Real t2 = temperature * temperature;\n  dcp_dT =\n      4 * 3.7782E-10 * t2 * temperature - 3 * 1.7191E-6 * t2 + 2 * 3.0921e-3 * temperature - 2.456;\n}\n\nReal\nSodiumSaturationFluidProperties::cp_from_v_e(Real v, Real e) const\n{\n  Real temperature = T_from_v_e(v, e);\n  Real t2 = temperature * temperature;\n  return 3.7782E-10 * t2 * t2 - 1.7191E-6 * t2 * temperature + 3.0921E-3 * t2 -\n         2.4560 * temperature + 1972.0;\n}\n\nvoid\nSodiumSaturationFluidProperties::cp_from_v_e(\n    Real v, Real e, Real & cp, Real & dcp_dv, Real & dcp_de) const\n{\n  Real T, dT_dv, dT_de;\n  T_from_v_e(v, e, T, dT_dv, dT_de);\n  cp = cp_from_v_e(v, e);\n  dcp_dv = (4*3.7782E-10*T*T*T - 3*1.7191E-6*T*T + 2*3.0921e-3*T - 2.456)*dT_dv;\n  dcp_de = (4*3.7782E-10*T*T*T - 3*1.7191E-6*T*T + 2*3.0921e-3*T - 2.456)*dT_de;\n}\n\n\nReal\nSodiumSaturationFluidProperties::cv_from_p_T(Real /* pressure */, Real temperature) const\n{\n  Real t2 = temperature * temperature;\n  return 1.0369E-8 * temperature * t2 + 3.7164E-4 * t2 - 1.0494 * temperature + 1582.6;\n}\n\nvoid\nSodiumSaturationFluidProperties::cv_from_p_T(\n    Real pressure, Real temperature, Real & cv, Real & dcv_dp, Real & dcv_dT) const\n{\n  cv = cv_from_p_T(pressure, temperature);\n  dcv_dp = 0.0;\n  dcv_dT = 3 * 1.0369e-8 * temperature * temperature + 2 * 3.7164e-4 * temperature - 1.0494;\n}\n\nReal\nSodiumSaturationFluidProperties::cv_from_v_e(Real v, Real e) const\n{\n  Real p = p_from_v_e(v, e);\n  Real T = T_from_v_e(v, e);\n  return cv_from_p_T(p, T);\n}\n\nvoid\nSodiumSaturationFluidProperties::cv_from_v_e(Real v, Real e, Real & cv, Real & dcv_dv, Real & dcv_de) const\n{\n  Real p, dp_dv, dp_de;\n  p_from_v_e(v, e, p, dp_dv, dp_de);\n  Real T, dT_dv, dT_de;\n  T_from_v_e(v, e, T, dT_dv, dT_de);\n  Real dcv_dp, dcv_dT;\n  cv_from_p_T(p, T, cv, dcv_dp, dcv_dT);\n  dcv_dv = dcv_dp * dp_dv + dcv_dT * dT_dv;\n  dcv_de = dcv_dp * dp_de + dcv_dT * dT_de;\n}\n\nReal\nSodiumSaturationFluidProperties::mu_from_p_T(Real /*pressure*/, Real temperature) const\n{\n  return 3.6522E-5 + 0.16626 / temperature - 4.56877e1 / (temperature * temperature) +\n         2.8733E4 / (temperature * temperature * temperature);\n}\n\nvoid\nSodiumSaturationFluidProperties::mu_from_p_T(\n    Real pressure, Real temperature, Real & mu, Real & dmu_dp, Real & dmu_dT) const\n{\n  mu = this->mu_from_p_T(pressure, temperature);\n  dmu_dp = 0.0;\n\n  Real t2 = temperature * temperature;\n  dmu_dT = 0.16626 * -1 / t2 - 4.56877E1 * -2 / (temperature * t2) + 2.8733E4 * -3 / (t2 * t2);\n}\n\nReal\nSodiumSaturationFluidProperties::mu_from_v_e(Real v, Real e) const\n{\n  Real temperature = T_from_v_e(v, e);\n  return 3.6522E-5 + 0.16626 / temperature - 4.56877e1 / (temperature * temperature) +\n         2.8733E4 / (temperature * temperature * temperature);\n}\n\nvoid\nSodiumSaturationFluidProperties::mu_from_v_e(\n    Real v, Real e, Real & mu, Real & dmu_dv, Real & dmu_de) const\n{\n  Real T, dT_dv, dT_de;\n  T_from_v_e(v, e, T, dT_dv, dT_de);\n  mu = mu_from_v_e(v, e);\n  dmu_dv = dT_dv*(0.16626 * -1 /T/T - 4.56877E1 * -2 / (T*T*T) + 2.8733E4 * -3 / (T*T*T*T));\n  dmu_de = dT_de*(0.16626 * -1 /T/T - 4.56877E1 * -2 / (T*T*T) + 2.8733E4 * -3 / (T*T*T*T));\n}\n\nReal\nSodiumSaturationFluidProperties::k_from_p_T(Real /*pressure*/, Real temperature) const\n{\n  return 1.1045e2 - 6.5112e-2 * temperature + 1.5430e-5 * temperature * temperature -\n         2.4617e-9 * temperature * temperature * temperature;\n}\n\nvoid\nSodiumSaturationFluidProperties::k_from_p_T(\n    Real pressure, Real temperature, Real & k, Real & dk_dp, Real & dk_dT) const\n{\n  k = this->k_from_p_T(pressure, temperature);\n  dk_dp = 0.0;\n  dk_dT = -6.5112e-2 + 2 * 1.5430e-5 * temperature - 3 * 2.4617e-9 * temperature * temperature;\n}\n\nReal\nSodiumSaturationFluidProperties::k_from_v_e(Real v, Real e) const\n{\n  Real temperature = T_from_v_e(v, e);\n  return 1.1045e2 - 6.5112e-2 * temperature + 1.5430e-5 * temperature * temperature -\n         2.4617e-9 * temperature * temperature * temperature;\n}\n\nvoid\nSodiumSaturationFluidProperties::k_from_v_e(Real v, Real e, Real & k, Real & dk_dv, Real & dk_de) const\n{\n  Real T, dT_dv, dT_de;\n  T_from_v_e(v, e, T, dT_dv, dT_de);\n  k = k_from_v_e(v, e);\n  dk_dv = dT_dv*(-6.5112e-2 + 2 * 1.5430e-5 * T - 3 * 2.4617e-9 * T * T);\n  dk_de = dT_de*(-6.5112e-2 + 2 * 1.5430e-5 * T - 3 * 2.4617e-9 * T * T);\n}\n\n\nReal\nSodiumSaturationFluidProperties::c_from_v_e(Real v, Real e) const\n{\n  Real T = T_from_v_e(v, e);\n  return 2660.7 - 0.37667*T - 9.0356e-5*T*T;\n}\n\nDualReal\nSodiumSaturationFluidProperties::c_from_v_e(const DualReal & v, const DualReal & e) const\n{\n  DualReal T = SinglePhaseFluidProperties::T_from_v_e(v, e);\n  return 2660.7 - 0.37667*T - 9.0356e-5*T*T;\n}\n\nAnd the new SodiumSaturationFluidPropertiesTest:\nNo changes with head file, and the source file:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"SinglePhaseFluidPropertiesTestUtils.h\"\n#include \"SodiumSaturationFluidPropertiesTest.h\"\n\n/**\n * Test that the fluid name is correctly returned\n */\nTEST_F(SodiumSaturationFluidPropertiesTest, fluidName) { EXPECT_EQ(_fp->fluidName(), \"sodium_sat\"); }\n\n/**\n * Test that the molar mass is correctly returned\n */\nTEST_F(SodiumSaturationFluidPropertiesTest, molarMass)\n{\n  ABS_TEST(_fp->molarMass(), 22.989769E-3, REL_TOL_SAVED_VALUE);\n}\n\n/**\n * Test that the thermal conductivity and its derivatives are\n * correctly computed.\n */\nTEST_F(SodiumSaturationFluidPropertiesTest, thermalConductivity)\n{\n  const Real T = 800.0;\n  const Real p = 101325;\n  //Ethan-xj\n  const Real rho = _fp->rho_from_p_T(p, T);\n  const Real v = 1. / rho;\n  const Real e = _fp->e_from_p_T(p, T);\n\n  // Fink and Leibowitz (1979) list conductivity as 66.8 at 800 K, so the fit agrees well\n  REL_TEST(_fp->k_from_p_T(p, T), 66.9752096, REL_TOL_SAVED_VALUE);\n  //Ethan-xj\n  REL_TEST(_fp->k_from_v_e(v, e), 66.9752096, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->k_from_p_T, p, T, REL_TOL_DERIVATIVE);\n}\n\n/**\n * Test that the viscosity and its derivatives are correctly computed.\n */\nTEST_F(SodiumSaturationFluidPropertiesTest, viscosity)\n{\n  const Real T = 800.0;\n  const Real p = 101325;\n  //Ethan-xj\n  const Real rho = _fp->rho_from_p_T(p, T);\n  const Real v = 1. / rho;\n  const Real e = _fp->e_from_p_T(p, T);\n\n  // Fink and Leibowitz (1979) list viscosity as 0.000229 at 800 K, so the fit agrees well\n  REL_TEST(_fp->mu_from_p_T(p, T), 0.00022907910937500003, REL_TOL_SAVED_VALUE);\n  //Ethan-xj\n  REL_TEST(_fp->mu_from_v_e(v, e), 0.00022907910937500003, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->mu_from_p_T, p, T, REL_TOL_DERIVATIVE);\n}\n\n/**\n * Test that the isobaric specific heat and its derivatives are correctly computed.\n */\nTEST_F(SodiumSaturationFluidPropertiesTest, isobaricSpecificHeat)\n{\n  const Real T1 = 400.0;\n  const Real T2 = 800.0;\n  const Real p = 101325;\n  //Ethan-xj\n  const Real rho1 = _fp->rho_from_p_T(p, T1);\n  const Real v1 = 1. / rho1;\n  const Real e1 = _fp->e_from_p_T(p, T1);\n  const Real rho2 = _fp->rho_from_p_T(p, T2);\n  const Real v2 = 1. / rho2;\n  const Real e2 = _fp->e_from_p_T(p, T2);\n\n\n  // Fink and Leibowitz (1979) show Cp = 1373.6 at 400 K, so the fit agrees well\n  REL_TEST(_fp->cp_from_p_T(p, T1), 1383.985792, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->cp_from_p_T, p, T1, REL_TOL_DERIVATIVE);\n\n  // Fink and Leibowitz (1979) show Cp = 1263.6 at 800 K, so the fit agrees well\n  REL_TEST(_fp->cp_from_p_T(p, T2), 1260.719872, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->cp_from_p_T, p, T2, REL_TOL_DERIVATIVE);\n\n  //Ethan-xj\n  REL_TEST(_fp->cp_from_v_e(v1, e1), 1383.985792, REL_TOL_SAVED_VALUE);\n  REL_TEST(_fp->cp_from_v_e(v2, e2), 1260.719872, REL_TOL_SAVED_VALUE);\n}\n\n/**\n * Test that the isochoric specific heat and its derivatives are correctly computed.\n */\nTEST_F(SodiumSaturationFluidPropertiesTest, isochoricSpecificHeat)\n{\n  const Real T1 = 400.0;\n  const Real T2 = 800.0;\n  const Real p = 101325;\n  //Ethan-xj\n  const Real rho1 = _fp->rho_from_p_T(p, T1);\n  const Real v1 = 1. / rho1;\n  const Real e1 = _fp->e_from_p_T(p, T1);\n  const Real rho2 = _fp->rho_from_p_T(p, T2);\n  const Real v2 = 1. / rho2;\n  const Real e2 = _fp->e_from_p_T(p, T2);\n\n  // Fink and Leibowitz (1979) show Cv = 1230.1 at 400 K, so the fit agrees well\n  REL_TEST(_fp->cv_from_p_T(p, T1), 1222.9660159999999, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->cv_from_p_T, p, T1, REL_TOL_DERIVATIVE);\n\n  // Fink and Leibowitz (1979) show Cv = 982.611 at 800 K, so the fit agrees well\n  REL_TEST(_fp->cv_from_p_T(p, T2), 986.2385279999999, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->cv_from_p_T, p, T2, REL_TOL_DERIVATIVE);\n\n  //Ethan-xj\n  REL_TEST(_fp->cv_from_v_e(v1, e1), 1222.9660159999999, REL_TOL_SAVED_VALUE);\n  REL_TEST(_fp->cv_from_v_e(v2, e2), 986.2385279999999, REL_TOL_SAVED_VALUE);\n}\n\n/**\n * Test that the density and its derivatives are correctly computed.\n */\nTEST_F(SodiumSaturationFluidPropertiesTest, density)\n{\n  const Real Tm = 370.98;\n  const Real T = 800.0;\n  const Real Tb = 1156.5;\n  const Real p = 101325;\n\n  // Fink and Leibowitz (1979) list density at 370.98 K is 927.3, so the fit agrees well\n  ABS_TEST(_fp->rho_from_p_T(p, Tm), 923.3571594322216, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->rho_from_p_T, p, Tm, REL_TOL_DERIVATIVE);\n  ABS_TEST(_fp->v_from_p_T(p, Tm), 0.001083004544649772, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->v_from_p_T, p, Tm, REL_TOL_DERIVATIVE);\n\n  // Fink and Leibowitz (1979) list density at 800 K is 825.6, so the fit agrees well\n  ABS_TEST(_fp->rho_from_p_T(p, T), 826.04056, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->rho_from_p_T, p, T, REL_TOL_DERIVATIVE);\n  ABS_TEST(_fp->v_from_p_T(p, T), 0.0012105943078630425, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->v_from_p_T, p, T, REL_TOL_DERIVATIVE);\n\n  // Fink and Leibowitz (1979) list density at 1156.5 K is 739.4, so the fit agrees well\n  ABS_TEST(_fp->rho_from_p_T(p, Tb), 742.0807106065, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->rho_from_p_T, p, Tb, REL_TOL_DERIVATIVE);\n  ABS_TEST(_fp->v_from_p_T(p, Tb), 0.0013475623145933863, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->v_from_p_T, p, Tb, REL_TOL_DERIVATIVE);\n}\n\n/**\n * Test that the specific internal energy and its derivatives are correctly computed.\n */\nTEST_F(SodiumSaturationFluidPropertiesTest, specificInternalEnergy)\n{\n  const Real T = 800.0;\n  const Real p = 101325;\n  //Ethan-xj\n  const Real rho = _fp->rho_from_p_T(p, T);\n\n  ABS_TEST(_fp->e_from_p_T(p, T),\n           _fp->h_from_p_T(p, T) - p * _fp->v_from_p_T(p, T),\n           REL_TOL_SAVED_VALUE);\n  //Ethan-xj\n  REL_TEST(_fp->e_from_p_rho(p, rho),\n           _fp->h_from_p_T(p, T) - p * _fp->v_from_p_T(p, T),\n           REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->e_from_p_T, p, T, REL_TOL_DERIVATIVE);\n}\n\n/**\n * Test that the specific enthalpy and its derivatives are correctly computed.\n */\nTEST_F(SodiumSaturationFluidPropertiesTest, specificEnthalpy)\n{\n  const Real T = 800.0;\n  const Real p = 101325;\n  //Ethan-xj\n  const Real rho = _fp->rho_from_p_T(p, T);\n  const Real v = 1. / rho;\n  const Real e = _fp->e_from_p_T(p, T);\n\n  // Fink and Leibowitz (1979) compute enthalpy at 800 K as 768602, so the fit agrees well\n  ABS_TEST(_fp->h_from_p_T(p, T), 767034.6715200001, REL_TOL_SAVED_VALUE);\n  //Ethan-xj\n  REL_TEST(_fp->h_from_v_e(v, e), 767034.6715200001, REL_TOL_SAVED_VALUE);\n\n  DERIV_TEST(_fp->h_from_p_T, p, T, REL_TOL_DERIVATIVE);\n\n  // Fink and Leibowitz (1979) compute enthalpy at 1156.5 K as 1218803, so the fit agrees well\n  const Real T2 = 1156.5;\n  //Ethan-xj\n  const Real rho2 = _fp->rho_from_p_T(p, T2);\n  const Real v2 = 1. / rho2;\n  const Real e2 = _fp->e_from_p_T(p, T2);\n  ABS_TEST(_fp->h_from_p_T(p, T2), 1218897.6776327428, REL_TOL_SAVED_VALUE);\n  //Ethan-xj\n  REL_TEST(_fp->h_from_v_e(v2, e2), 1218897.6776327428, REL_TOL_SAVED_VALUE);\n  DERIV_TEST(_fp->h_from_p_T, p, T2, REL_TOL_DERIVATIVE);\n}\n\n/**\n * Test that the pressure can be computed from the specific volume & energy\n */\nTEST_F(SodiumSaturationFluidPropertiesTest, PTFromVE)\n{\n  // Starting pressure and temperature\n  const Real T = 800.0;\n  const Real p = 101325;\n\n  // Obtain specific volume and specific energy\n  const Real v = _fp->v_from_p_T(p, T);\n  const Real e = _fp->e_from_p_T(p, T);\n\n  // Verify that the conversion back succeeds\n  ABS_TEST(_fp->T_from_v_e(v, e), T, TOLERANCE);\n  ABS_TEST(_fp->p_from_v_e(v, e), p, 1e-6);\n}\n\nTEST_F(SodiumSaturationFluidPropertiesTest, derivatives)\n{\n  const Real tol = REL_TOL_DERIVATIVE;\n\n  const Real p = 101325;\n  const Real T = 800.0;\n  const Real rho = _fp->rho_from_p_T(p, T);\n  const Real v = 1. / rho;\n  const Real e = _fp->e_from_p_T(p, T);\n\n  DERIV_TEST(_fp->p_from_v_e, v, e, tol);\n  DERIV_TEST(_fp->mu_from_v_e, v, e, tol);\n  DERIV_TEST(_fp->k_from_v_e, v, e, tol);\n  DERIV_TEST(_fp->h_from_v_e, v, e, tol);\n  DERIV_TEST(_fp->T_from_v_e, v, e, tol);\n  DERIV_TEST(_fp->cp_from_v_e, v, e, tol);\n  DERIV_TEST(_fp->cv_from_v_e, v, e, tol);\n\n  DERIV_TEST(_fp->e_from_p_rho, p, rho, tol);\n}",
                  "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6842009",
                  "updatedAt": "2023-08-28T12:30:57Z",
                  "publishedAt": "2023-08-28T12:30:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Hi, to propose changes, please make a merge request: https://mooseframework.inl.gov/framework/contributing.html. Let us know if you need help with those instructions.",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6842292",
                          "updatedAt": "2023-08-28T13:00:20Z",
                          "publishedAt": "2023-08-28T13:00:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "In addition to contributing the code, this will also help us review what changes you've made and if they are correct.",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6842314",
                          "updatedAt": "2023-08-28T13:02:36Z",
                          "publishedAt": "2023-08-28T13:02:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@Ethan-xj are you doing 2 phase flow? SodiumSaturationFP is for the liquid part of a two phase sodium mixture\nWe need to rework SodiumFP to get the subcooled sodium fluid properties",
                  "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6843968",
                  "updatedAt": "2023-08-28T15:38:50Z",
                  "publishedAt": "2023-08-28T15:38:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Just single phase(subcooled). I think sodium can be seen as an incompressible fluid, so I use SodiumSaturationFluidPropertiesTest directly.",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6848068",
                          "updatedAt": "2023-08-29T02:04:02Z",
                          "publishedAt": "2023-08-29T01:59:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "If I recall correctly, SodiumSaturationFluidProperties provides sodium properties as a function of temperature, where the pressure at a particular temperature is equal to the saturation pressure. These correlations exist like this to match SAS4A/SASSYS, a commonly-used safety analysis code for SFRs.",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6848131",
                          "updatedAt": "2023-08-29T02:12:47Z",
                          "publishedAt": "2023-08-29T02:12:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so we're correct that it should not be used for subcooled sodium right?\nthere's definitely another set of properties for subcooled from the same reference",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6848158",
                          "updatedAt": "2023-08-29T02:17:45Z",
                          "publishedAt": "2023-08-29T02:17:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Yes, I think it's right. There should be another set of properties for subcooled sodium. And I've wrote the codes before. But at that time there was something wrong with the codes and I didn't know how to test it so I gave up. Maybe I can write it again.",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6848235",
                          "updatedAt": "2023-08-29T02:35:50Z",
                          "publishedAt": "2023-08-29T02:35:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "Yes, there are subcooled properties in the Fink reference as well: https://www.osti.gov/servlets/purl/5644097\nI'd try computing the saturated and subcooled properties at a few points in the range of interest to see if they are sizably different first. Some properties (I think density, for instance) are only very marginally different, and only when you get to fairly high pressures.",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6848261",
                          "updatedAt": "2023-08-29T02:43:09Z",
                          "publishedAt": "2023-08-29T02:43:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "I got it. Thank you for all your replies \ud83d\udc4d",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6848303",
                          "updatedAt": "2023-08-29T02:53:22Z",
                          "publishedAt": "2023-08-29T02:53:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Like April, I'm guessing the properties might be decent enough with the saturation approximation. The main question is how compatible they will be with whatever physics model you're using. I'm not sure how well this will do with THM's flow model, for instance, without any pressure dependence.",
                          "url": "https://github.com/idaholab/moose/discussions/25303#discussioncomment-6852502",
                          "updatedAt": "2023-08-29T12:10:18Z",
                          "publishedAt": "2023-08-29T12:10:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A question about generating mesh.",
          "author": {
            "login": "BrownieLL"
          },
          "bodyText": "Hello everyone,\nI'm relatively new to Moose, and I'm really interested in developing a model that involves an inclined model domain (see below, noted that the vertical direction corresponds to the z-axis). I would like to inquire whether Moose has the capability to generate a grid for the inclined model domain. Your assistance would be greatly appreciated. Thank you in advance!",
          "url": "https://github.com/idaholab/moose/discussions/25314",
          "updatedAt": "2023-08-29T05:50:23Z",
          "publishedAt": "2023-08-28T05:23:00Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe can do that.\nUse a GeneratedMeshGenerator or CartesianMeshGenerator (second one will let you do this grading)\nthen a ParsedNodeTransformGenerator to slant it\nhttps://mooseframework.inl.gov/docs/PRs/25087/site/source/meshgenerators/ParsedNodeTransformGenerator.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25314#discussioncomment-6842732",
                  "updatedAt": "2023-08-28T13:44:34Z",
                  "publishedAt": "2023-08-28T13:44:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "BrownieLL"
                          },
                          "bodyText": "Thank you very much, Guillaume. That really helps!",
                          "url": "https://github.com/idaholab/moose/discussions/25314#discussioncomment-6849232",
                          "updatedAt": "2023-08-29T05:50:24Z",
                          "publishedAt": "2023-08-29T05:50:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Applying stress boundary condition",
          "author": {
            "login": "zzzmx-josh"
          },
          "bodyText": "Hi there,\nI am working on a TensorMechanics problem using MOOSE and am trying to model the stress field from the AFM (Atom Force Microscopy) tip pressing using the Hertzian contact mechanics of a spherical indenters. The normal stress distribution on the model surface is written as\n\nwhere r, a, and F denote the distance to the contact center, the contact radius, and the magnitude of the loading force, respectively.  As the variables in TensorMechanics are displacements, how can the stress field above be applied in the surface?\nMore generally, I would like to work out how to accurately apply a stress boundary condition to solid elements in Moose. For example, the traction-free boundary condition is specified as \u03c3\u00b7n = 0.\nMany thanks in advance",
          "url": "https://github.com/idaholab/moose/discussions/25320",
          "updatedAt": "2023-08-29T02:34:33Z",
          "publishedAt": "2023-08-28T12:54:13Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "You can achieve the traction-free boundary condition by simply not specifying any boundary conditions. This yields the natural boundary condition. In finite elements when you integrate by parts, your surface term is <psi, sigma * n>. If you specify no boundary condition, this implicitly is setting sigma * n = 0. For your more specific boundary condition, you would likely need to write your own BC, unless such a BC already exists and I'm not aware of it. @recuero has done work with Hertzian contact",
                  "url": "https://github.com/idaholab/moose/discussions/25320#discussioncomment-6844413",
                  "updatedAt": "2023-08-28T16:16:52Z",
                  "publishedAt": "2023-08-28T16:16:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "A Hertzian assumption is small deformation. You can create a function that depends on the coordinate to apply the stress as a pressure boundary condition (which is automatically normal to the boundary). If that's not good enough for your problem, you can always fall back to @lindsayad's suggestion of writing your own BC.",
                          "url": "https://github.com/idaholab/moose/discussions/25320#discussioncomment-6844932",
                          "updatedAt": "2023-08-28T17:07:16Z",
                          "publishedAt": "2023-08-28T17:07:15Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zzzmx-josh"
                          },
                          "bodyText": "Thank you all for your guidance and suggestions. I will give it a try.",
                          "url": "https://github.com/idaholab/moose/discussions/25320#discussioncomment-6848229",
                          "updatedAt": "2023-08-29T02:34:28Z",
                          "publishedAt": "2023-08-29T02:34:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to let the sub-apps on other processors print log",
          "author": {
            "login": "xuxiaobei1995"
          },
          "bodyText": "Hi all,\nI found that when running the multi-app in parallel, only the sub-apps on the main processor will print log. However, I want to know what happen in the sub-apps on the other processors to debug so I need them also to print the log.  Does anyone know how to realize this? Thanks.\nXiaobei",
          "url": "https://github.com/idaholab/moose/discussions/25311",
          "updatedAt": "2023-08-29T01:12:45Z",
          "publishedAt": "2023-08-28T02:25:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou ll want to add \u2014keep-cout to the command line.\nsince this will overwhelm the terminal most likely you ll want to use the redirect-cout command line option as well to same that output to files\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25311#discussioncomment-6837945",
                  "updatedAt": "2023-08-28T02:28:46Z",
                  "publishedAt": "2023-08-28T02:28:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Thank you Giud! I will try this.\nXiaobei",
                          "url": "https://github.com/idaholab/moose/discussions/25311#discussioncomment-6838065",
                          "updatedAt": "2023-08-28T02:58:15Z",
                          "publishedAt": "2023-08-28T02:58:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Giud, I have another question. I tried --keep-cout and then all processors did print the log. But the file is too big to view conveniently. Do you know how to let each processor print the log to each single file? For example, 100 processors print their log to 100 different files? Thanks.\nXiaobei",
                          "url": "https://github.com/idaholab/moose/discussions/25311#discussioncomment-6839406",
                          "updatedAt": "2023-08-28T07:35:54Z",
                          "publishedAt": "2023-08-28T07:35:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "that s the redirect-cout command line argument\nuse --help to see those",
                          "url": "https://github.com/idaholab/moose/discussions/25311#discussioncomment-6842738",
                          "updatedAt": "2023-08-28T13:45:39Z",
                          "publishedAt": "2023-08-28T13:45:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Thanks, Giud! I will try it.\nXiaobei",
                          "url": "https://github.com/idaholab/moose/discussions/25311#discussioncomment-6847851",
                          "updatedAt": "2023-08-29T01:12:45Z",
                          "publishedAt": "2023-08-29T01:12:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to let the sub-apps on other processors print log",
          "author": {
            "login": "xuxiaobei1995"
          },
          "bodyText": "Hi all,\nI found that when running the multi-app in parallel, only the sub-apps on the main processor will print log. However, I want to know what happen in the sub-apps on the other processors to debug so I need them also to print the log.  Does anyone know how to realize this? Thanks.\nXiaobei",
          "url": "https://github.com/idaholab/moose/discussions/25312",
          "updatedAt": "2023-08-28T02:52:50Z",
          "publishedAt": "2023-08-28T02:26:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": []
          }
        }
      }
    ]
  }
}