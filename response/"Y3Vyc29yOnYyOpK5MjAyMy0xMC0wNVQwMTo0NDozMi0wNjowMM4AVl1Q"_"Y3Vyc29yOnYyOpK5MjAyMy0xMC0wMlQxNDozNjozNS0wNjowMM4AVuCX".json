{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMC0wMlQxNDozNjozNS0wNjowMM4AVuCX"
    },
    "edges": [
      {
        "node": {
          "title": "Contact with explicit time integrator",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "Can we use contact with explicit time integrator (e.g. CentralDifference)?\nI tried with the example in introduction of contact modules (https://mooseframework.inl.gov/modules/contact/tutorials/introduction/step01.html), with\n[Executioner]\n  type = Transient\n  end_time = 5\n  dt = 0.5\n  [TimeIntegrator]\n    type = CentralDifference\n  []\n[]\n\nbut only get\n*** ERROR ***\nNeed a system matrix",
          "url": "https://github.com/idaholab/moose/discussions/25401",
          "updatedAt": "2023-10-04T20:40:27Z",
          "publishedAt": "2023-09-05T14:49:02Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCentralDifference is implemented a little differently. Do you mind trying the other explicit time integrators?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-6916464",
                  "updatedAt": "2023-09-05T16:23:43Z",
                  "publishedAt": "2023-09-05T16:23:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "If you are interested in doing dynamics, I believe NewmarkBeta is often used. @recuero might want to comment more",
                  "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-6917470",
                  "updatedAt": "2023-09-05T18:26:55Z",
                  "publishedAt": "2023-09-05T18:26:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "Contact has not been implemented/tested for explicit dynamics (we will hopefully get to that). For implicit dynamics, use of contact objects is limited, but we do have examples or tests that use Newmark beta.",
                  "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-6917532",
                  "updatedAt": "2023-09-05T18:34:49Z",
                  "publishedAt": "2023-09-05T18:34:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lyyc199586"
                  },
                  "bodyText": "got it, thanks",
                  "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-6917569",
                  "updatedAt": "2023-09-05T18:39:28Z",
                  "publishedAt": "2023-09-05T18:39:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "FYI: We are going to be looking into explicit dynamics contact this year: #25666",
                          "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-7191102",
                          "updatedAt": "2023-10-04T20:12:40Z",
                          "publishedAt": "2023-10-04T20:12:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "great!",
                          "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-7191291",
                          "updatedAt": "2023-10-04T20:40:28Z",
                          "publishedAt": "2023-10-04T20:40:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "module command not found",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "I am trying to run my first job. Below is my sbatch file.\n#!/bin/bash                                                                     \n#SBATCH --job-name kks_multiphase_largescale_large                                                 \n#SBATCH --out  kks_multiphase_largescale_large.out        \n#SBATCH --nodes 1                                                               \n#SBATCH --ntasks 2\n#SBATCH --cpus-per-task 8\n#SBATCH --account amcorrosion                                                  \n##SBATCH --partition normal_q                                                   \n#SBATCH --time=100:00:00    \n##SBATCH --mem=gpu:pascal:4                                                     \n#SBATCH --export=NONE # this makes sure the compute environment is clean        \n#SBATCH --mail-user emmanuel324@vt.edu\n#SBATCH --mail-type=begin\n#SBATCH --mail-type=end\n\n\nsource /home/emmanuel324/.moose_profile\nmodule load apps site/tinkercliffs/easybuild/setup\nmodule load apps site/tinkercliffs-rome/easybuild/setup\nmodule load OpenMPI/4.1.1-GCC-10.3.0\nmodule load CMake/3.20.1-GCCcore-10.3.0\nmodule load Anaconda3/2020.11\n\n\ncd \"${submitdir}\"\n\n#rm kks_multiphase_largescale_large_csv*\n#rm kks_multiphase_largescale_large_out.e*\nmpirun --mca orte_base_help_aggregate 0 -np 2 /home/emmanuel324/projects/belson/belson-opt  -i  kks_multiphase_largescale_large.i\n\nAlso below is the .out file. A colleague used similar sbatch file with exception of job name and application and it works fine for them.\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 17: source: /home/emmanuel324/.moose_profile: is a directory\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 18: module: command not found\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 19: module: command not found\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 20: module: command not found\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 21: module: command not found\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 22: module: command not found\nrm: cannot remove 'kks_multiphase_largescale_large_out.e*': No such file or directory\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 29: mpirun: command not found\n\nHow do I resolve this?",
          "url": "https://github.com/idaholab/moose/discussions/25664",
          "updatedAt": "2023-10-04T16:06:37Z",
          "publishedAt": "2023-10-04T14:30:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis .moose_profile file, does it exist? Is it at this path?\nIt starts erroring there. Similarly it fails to run module on every command, so the conseuqnece is that there's no mpirun available?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25664#discussioncomment-7188218",
                  "updatedAt": "2023-10-04T14:58:22Z",
                  "publishedAt": "2023-10-04T14:58:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "I created the .moose_profile directory. How do i create or enable the mpirun",
                          "url": "https://github.com/idaholab/moose/discussions/25664#discussioncomment-7188547",
                          "updatedAt": "2023-10-04T15:28:08Z",
                          "publishedAt": "2023-10-04T15:28:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "You should really seek help from the administrators of the HPC cluster you are on. All HPC clusters are different. If this was Lemhi or Sawtooth (two clusters here at INL), I would say:\nIn order to obtain MPI, load up the following modules:\nmodule load use.moose moose-dev",
                          "url": "https://github.com/idaholab/moose/discussions/25664#discussioncomment-7188772",
                          "updatedAt": "2023-10-04T15:49:22Z",
                          "publishedAt": "2023-10-04T15:49:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I created the .moose_profile directory\n\nIt should be a file, and it should contain whatever is needed to run moose on your machine",
                          "url": "https://github.com/idaholab/moose/discussions/25664#discussioncomment-7188948",
                          "updatedAt": "2023-10-04T16:06:37Z",
                          "publishedAt": "2023-10-04T16:06:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "adCoupledScalarDot problem in ADScalarTimeKernel",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nI would like to develop a CoupledADScalarTimeDerivative which inherits ADScalarTimeKernel.\nBut ADScalarTimeKernel doesn't have the adCoupledScalarDot function. I can not define the variable like:\n_v_dot(adCoupledScalarDot(\"v\"))\nI also find CoupledODETimeDerivative defining _v_dot(coupledScalarDot(\"v\")), but it is not AD type. How to define an adCoupledScalarDot variable in ADScalarTimeKernel?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/25655",
          "updatedAt": "2023-10-04T12:11:25Z",
          "publishedAt": "2023-10-03T15:09:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@joshuahansel do you remember why we dont have that one",
                  "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7177477",
                  "updatedAt": "2023-10-03T15:56:36Z",
                  "publishedAt": "2023-10-03T15:56:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "I don't believe there is any reason - we just need to add adCoupledScalarDot to ScalarCoupleable.",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7178399",
                          "updatedAt": "2023-10-03T17:22:52Z",
                          "publishedAt": "2023-10-03T17:22:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "So, could you please tell me what should I do?",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7178911",
                          "updatedAt": "2023-10-03T18:24:52Z",
                          "publishedAt": "2023-10-03T18:24:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You ll need to edit the ScalarCoupleable.C/.h files in the src/include / interfaces folder(s) to add this new routine",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7179379",
                          "updatedAt": "2023-10-03T19:12:17Z",
                          "publishedAt": "2023-10-03T19:12:17Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Ok, I'll have a try. Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7183097",
                          "updatedAt": "2023-10-04T06:37:27Z",
                          "publishedAt": "2023-10-04T06:37:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Hi,\nI have added the function to ScalarCoupleable:\nScalarCoupleable.h:\nconst ADVariableValue & adCoupledScalarDot(const std::string & var_name, unsigned int comp = 0) const;\nScalarCoupleable.C:\nconst ADVariableValue &\nScalarCoupleable::adCoupledScalarDot(const std::string & var_name, unsigned int comp) const\n{\n  checkVar(var_name);\n  validateExecutionerType(var_name, \"adCoupledScalarDot\");\n  return getScalarVar(var_name, comp)->adUDot();\n}\n\nThe compilation is passed. But I'm not sure if it is OK. Is there anything I still need to add? or that is enough?",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7183864",
                          "updatedAt": "2023-10-04T08:04:50Z",
                          "publishedAt": "2023-10-04T08:04:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "looks good to me",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7186074",
                          "updatedAt": "2023-10-04T11:54:31Z",
                          "publishedAt": "2023-10-04T11:54:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7186242",
                          "updatedAt": "2023-10-04T12:11:17Z",
                          "publishedAt": "2023-10-04T12:11:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Water97FluidProperty problem",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nI would like to calculate pressure using enthalpy and entropy (p_from_h_s)[h and s are known variables].\nBut Water97FluidProperty does not contain this function. What should I do? Should I use an iteration (assume p and T)?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/25651",
          "updatedAt": "2023-10-04T06:40:39Z",
          "publishedAt": "2023-10-03T06:54:45Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes you should try to implement it.\nAn iterative method would work\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7174401",
                  "updatedAt": "2023-10-03T10:59:59Z",
                  "publishedAt": "2023-10-03T10:59:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Do you have any idea how to implement the iteration method?",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7174599",
                          "updatedAt": "2023-10-03T11:24:20Z",
                          "publishedAt": "2023-10-03T11:24:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Use the Newton1Dsolve method. See TabulatedFP for examples\nThe idea is that as long as you have s(p,h) or h(p,s) defined, or if you can compute it in several steps, you can use that to compute the other one from a Newton Raphson solve",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7174867",
                          "updatedAt": "2023-10-03T11:54:19Z",
                          "publishedAt": "2023-10-03T11:54:18Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thank you very much! I find a function in SinglePhaseFluidProperties:\nvoid\nSinglePhaseFluidProperties::p_T_from_h_s(const T & h,     // h value\n                                         const T & s,     // s value\n                                         const Real p0,   // initial guess\n                                         const Real T0,   // initial guess\n                                         T & pressure,    // returned pressure\n                                         T & temperature, // returned temperature\n                                         bool & conversion_succeeded) const\n\nI think I can use it directly to calculate pressure.",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7175037",
                          "updatedAt": "2023-10-03T13:03:00Z",
                          "publishedAt": "2023-10-03T12:12:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this should be all you need indeed. It s iterative iirc so it might be a bit slow\nThe other alternative is to math it out, solve analytically for the property you need in the different regions of IAPWS IF 97",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7175524",
                          "updatedAt": "2023-10-03T13:04:19Z",
                          "publishedAt": "2023-10-03T13:04:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "However, I think the analytical expressions (p_from_h_s) in the different regions of IAPWS-IF97 are difficult for me to construct. Do you have the exact expressions, or where can I find the exact expressions? If yes, I could have a try.",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7175588",
                          "updatedAt": "2023-10-03T13:11:11Z",
                          "publishedAt": "2023-10-03T13:11:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can check the papers listed in the documentation.\nhttps://mooseframework.inl.gov/source/fluidproperties/Water97FluidProperties.html\nI think it will be difficult unless it's already written there fand you just need to implement",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7175662",
                          "updatedAt": "2023-10-03T13:16:43Z",
                          "publishedAt": "2023-10-03T13:16:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Ok, thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7175685",
                          "updatedAt": "2023-10-03T13:18:42Z",
                          "publishedAt": "2023-10-03T13:18:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "There are backward equations for p(h,s) for some of the regions given by IAPWS - see http://www.iapws.org/release.html. These are much faster than iteration, but would require some hours of coding to add them. It isn't difficult, just time consuming, if you want to have a go at adding them.",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7181448",
                          "updatedAt": "2023-10-04T01:14:16Z",
                          "publishedAt": "2023-10-04T01:14:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7183124",
                          "updatedAt": "2023-10-04T06:40:40Z",
                          "publishedAt": "2023-10-04T06:40:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Postprocessor for arbitrary linear equation",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "I'd like to do something like a NodalSum Postprocessor, except I'd like the coefficients to be artibrary, ie. Ax + By + Cz +.... It would be boundary-restricted, so in theory the coefficients would correspond to the order of the nodes in my nodeset. I'm thinking of inhereting from the NodalSum PPS and overriding the execute method like so:\nvoid\nNodalSum::execute()\n{\n  _sum += _coef * _u[_qp];\n}\n\nI'm just not sure how to make sure I'm getting the right coeff for the particular node. Any ideas?",
          "url": "https://github.com/idaholab/moose/discussions/25616",
          "updatedAt": "2023-10-03T19:10:30Z",
          "publishedAt": "2023-09-28T13:57:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "If it s as simple as Ax + By + Cz you can use a function for the coefficient, and do this:\n_sum += _coef.value(_t, *_current_node);",
                  "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7134813",
                  "updatedAt": "2023-09-28T14:10:39Z",
                  "publishedAt": "2023-09-28T14:05:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Sorry, maybe I should be more specific. The x, y, and z are _u at different nodes. The equation reads more like:\n$A_0 u_0 + A_1 u_1 + A_2 u_2 + ...$\nWhere $A_i$'s are coefficients and $u_i$'s are my variables at nodes in my nodeset",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7134881",
                          "updatedAt": "2023-09-28T14:31:03Z",
                          "publishedAt": "2023-09-28T14:11:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah ok then what does A depend on?",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135171",
                          "updatedAt": "2023-09-28T14:34:24Z",
                          "publishedAt": "2023-09-28T14:34:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "It's a constant coefficient particular to the node.",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135209",
                          "updatedAt": "2023-09-28T14:36:57Z",
                          "publishedAt": "2023-09-28T14:36:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "So each node in the node set gets a different coefficient.",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135240",
                          "updatedAt": "2023-09-28T14:39:40Z",
                          "publishedAt": "2023-09-28T14:39:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "where do you know them?\nare they in a file?",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135316",
                          "updatedAt": "2023-09-28T14:46:26Z",
                          "publishedAt": "2023-09-28T14:46:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "For my case there will only be just a few, so I'm thinking about inputting them as parameters in the input file",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135347",
                          "updatedAt": "2023-09-28T14:47:48Z",
                          "publishedAt": "2023-09-28T14:47:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think a function makes sense here. And it has plenty of flexibility for the input.\nyou can bake in a space dependence fairly easily.\nwhat does that variation depend on? Are they different coefficients per subdomain?",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135656",
                          "updatedAt": "2023-09-28T15:16:06Z",
                          "publishedAt": "2023-09-28T15:16:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "I'm thinking if, since the pps will be boundary-restricted, getting the current node id (_current_node->id()), find its position in the nodeset, then apply the coefficient at the same position in the input vector of values. Does that make sense?",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135675",
                          "updatedAt": "2023-09-28T15:18:18Z",
                          "publishedAt": "2023-09-28T15:18:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "No variation in the coefficients, they would be constant in space and time.",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135690",
                          "updatedAt": "2023-09-28T15:19:22Z",
                          "publishedAt": "2023-09-28T15:19:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I don\u2019t think nodes are ordered within a node set. How are you ordering them?\nIf the coefficient depends on the node, it depends on space right?",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135783",
                          "updatedAt": "2023-09-28T15:30:07Z",
                          "publishedAt": "2023-09-28T15:30:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "HeatConduction",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "All,\nMy input includes;\n[./heat_conduction]\ntype = HeatConduction # The declaration of heat conduction model\nvariable = temperature\nblock = 1\n[../]\nThen, I got an error message;\nA 'HeatConduction' is not a registered object.\nIf you are trying to find this object in a dynamically loaded library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\nIn Makefile, I set as\nHEAT_CONDUCTION     := yes\nPlease help,\nS. Thomas",
          "url": "https://github.com/idaholab/moose/discussions/25649",
          "updatedAt": "2023-10-03T15:55:48Z",
          "publishedAt": "2023-10-03T01:21:55Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "did you recompile after enabling the heat_conduction module?\nyou may have to clean the repo before recompiling too (make clobberall)",
                  "url": "https://github.com/idaholab/moose/discussions/25649#discussioncomment-7171005",
                  "updatedAt": "2023-10-03T02:34:13Z",
                  "publishedAt": "2023-10-03T02:34:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you, Guillaume.\nI did \"clobberall\" and \"make -j 6.\" But it still does not work.\nI got a warning of\n*** Warning, This code is deprecated and will be removed in future versions:\n\"registerAll\" in Modules is deprecated. Please update your *App.C file(s) to call the new templated \"registerAllObjects\" method (e.g. ModulesApp::registerAllObjects<MyApp>(...))\n\nI am ignoring it now but does it matter?\nPlease help. S. Thomas",
                          "url": "https://github.com/idaholab/moose/discussions/25649#discussioncomment-7177458",
                          "updatedAt": "2023-10-03T15:54:58Z",
                          "publishedAt": "2023-10-03T15:54:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this warning can be ignored for now. But you'll have to fix it one day.\nThe message is fairly explicit, you need to change that registerAll call to a registerAllObject<.  your app name >",
                          "url": "https://github.com/idaholab/moose/discussions/25649#discussioncomment-7177468",
                          "updatedAt": "2023-10-03T15:55:49Z",
                          "publishedAt": "2023-10-03T15:55:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Implementing a set of equations",
          "author": {
            "login": "gj19866"
          },
          "bodyText": "Hi all,\nI would just like to check that my understanding of how MOOSE works is correct before I get really stuck into debugging my code.\nI am trying to solve a rather nasty set of equations, for variables $\\psi_R$, $\\psi_I$, $\\Phi$, and $\\underline{j}$:\n\n\n$$0=-u \\sqrt{1+\\gamma^2\\left(\\psi_R^2+\\psi_I^2\\right)}\\left(\\frac{\\partial}{\\partial t} \\psi_R-\\varphi \\psi_I\\right)+\\nabla^2 \\psi_R-\\gamma^2 \\psi_I \\nabla^2 \\varphi+\\left(1-\\psi_R^2-\\psi_I^2\\right) \\psi_R$$\n\n\n$$0=-u \\sqrt{1+\\gamma^2\\left(\\psi_R^2+\\psi_I^2\\right)}\\left(\\frac{\\partial}{\\partial t} \\psi_I+\\varphi \\psi_R\\right)+\\nabla^2 \\psi_I+\\gamma^2 \\psi_R \\nabla^2 \\varphi+\\left(1-\\psi_R^2-\\psi_I^2\\right) \\psi_I$$\n\n\n$$0=\\nabla^2 \\varphi-\\psi_R \\nabla^2 \\psi_I+\\psi_I \\nabla^2 \\psi_R$$\n\n\n$$0=\\underline{j}+\\nabla \\varphi-\\psi_R \\nabla \\psi_I+\\psi_I \\nabla \\psi_R$$\n\n\nTo do this I have written one kernel for each equation to solve them.\nAs I have 4 variables, I have to pick a variable for each equation to solve for, but it is arbitrary which I choose, as long as each variable has at least one active kernel. (is this correct?)\nThe other variables in the equation need to be coupled in as adCoupledValue etc. (is this correct?)\nFor example, the kernel for equation two is:\n#include \"eq66Im.h\"\n#include <cmath>\n\nregisterMooseObject(\"SCResApp\", eq66Im);\n\nInputParameters\neq66Im::validParams()\n{\n  InputParameters params = ADKernel::validParams();\n  params.addClassDescription(\n      \"Kernel representing Im component of eq66 of bible. Variable is Psi_Re.\");\n  params.addCoupledVar(\"Psi_Im\",\n                       \"Imaginary component of Psi\");\n  params.addCoupledVar(\"Phi\",\n                       \"Phi\");\n  params.addParam<MaterialPropertyName>(\n      \"ucon\", \"ucon\", \"u from eq66\");\n  params.addParam<MaterialPropertyName>(\n      \"gamma\", \"gamma\", \"gamma from eq66\");\n  return params;\n}\n\neq66Im::eq66Im(const InputParameters & parameters)\n  : ADKernel(parameters),\n    _Psi_Im(adCoupledValue(\"Psi_Im\")),\n    _grad_Psi_Im(adCoupledGradient(\"Psi_Im\")),\n    _Psi_Im_dot(adCoupledDot(\"Psi_Im\")),\n    _Phi(adCoupledValue(\"Phi\")),\n    _grad_Phi(adCoupledGradient(\"Phi\")),\n    _ucon(getADMaterialProperty<Real>(\"ucon\")),\n    _gamma(getADMaterialProperty<Real>(\"gamma\"))\n{\n}\n\nADReal\neq66Im::computeQpResidual()\n{\n\n//    part1 = (_test[_i][_qp] * (-_ucon[_qp] * sqrt(1+ _gamma[_qp] * _gamma[_qp] * (_u[_qp] * _u[_qp] + _Psi_Im[_qp] * _Psi_Im[_qp])) ) * (_Psi_Im_dot[_qp] + _Phi[_qp] * _u[_qp]));\n\n//    part2 = (_grad_test[_i][_qp] * (- _grad_Psi_Im[_qp]));\n\n//    part3 = (_grad_test[_i][_qp] * (- _gamma[_qp] * _gamma[_qp] *  _u[_qp] * _grad_Phi[_qp]));\n\n//    part4 = (_test[_i][_qp] * (1 - _u[_qp] * _u[_qp] - _Psi_Im[_qp] * _Psi_Im[_qp]) * _Psi_Im[_qp]);\n\n  return  (_test[_i][_qp] * (-_ucon[_qp] * sqrt(1+ _gamma[_qp] * _gamma[_qp] * (_u[_qp] * _u[_qp] + _Psi_Im[_qp] * _Psi_Im[_qp])) ) * (_Psi_Im_dot[_qp] + _Phi[_qp] * _u[_qp])) + (_grad_test[_i][_qp] * (- _grad_Psi_Im[_qp])) + (_grad_test[_i][_qp] * (- _gamma[_qp] * _gamma[_qp] *  _u[_qp] * _grad_Phi[_qp])) +  (_test[_i][_qp] * (1 - _u[_qp] * _u[_qp] - _Psi_Im[_qp] * _Psi_Im[_qp]) * _Psi_Im[_qp]);\n\n}\n\nDoes this look like I'm doing the right thing?\nIs this the correct way to approach the problem?\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/25639",
          "updatedAt": "2023-10-03T13:02:37Z",
          "publishedAt": "2023-10-02T12:49:59Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nAs I have 4 variables, I have to pick a variable for each equation to solve for, but it is arbitrary which I choose, as long as each variable has at least one active kernel. (is this correct?)\n\nYes, but this choice is consequential. This will determine what is on-diagonal and off-diagonal in the linearized system matrices that you solve during the linear steps of the nonlinear solve.\nA good idea is to make sure to have big diagonals for every variable.\n\nThe other variables in the equation need to be coupled in as adCoupledValue etc. (is this correct?)\n\ncorrect.\n\nDoes this look like I'm doing the right thing?\n\nI think the idea is right, though:\n\ni think the integration by parts for term 3 is not correct\nwe usually split each term on a per-kernel basis. It just improves the code re-use.\n\nTo verify your implementation, I would set 3 of the 4 variables to known functions, and solve for the 4th by hand. Then make sure the solver can solve each of these single equations.\nTo set a variable, use an auxiliary variable and a FunctionIC",
                  "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7165740",
                  "updatedAt": "2023-10-02T14:20:12Z",
                  "publishedAt": "2023-10-02T14:20:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "Amazing thank you GiudGiud! What is wrong with the 3rd term in the equation, please?\nThank you for all the help!",
                          "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7166935",
                          "updatedAt": "2023-10-02T16:01:02Z",
                          "publishedAt": "2023-10-02T16:01:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "integration by parts of\npsi_r div_grad_phi test\nleads to\ngrad_phi * (grad_psi_r test + grad_test * psi_r)\nand you only have\n_grad_test[_i][_qp] * _u[_qp] * _grad_Phi[_qp])\nso missing one term?",
                          "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7170041",
                          "updatedAt": "2023-10-02T23:23:35Z",
                          "publishedAt": "2023-10-02T23:23:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "Ah yes, I understand now.\nI had tried implementing the weak form as in https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/step04_weak_form.html#:~:text=Procedure%20for%20Generating%20Weak%20Forms&text=Write%20down%20the%20strong%20form,rule%20to%20separate%20the%20terms but I see that I was performing the product rule incorrectly!\nThank you very much GiudGiud, you have made a really big difference for me! I really appreciate all your help!",
                          "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7173416",
                          "updatedAt": "2023-10-03T09:00:31Z",
                          "publishedAt": "2023-10-03T09:00:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "I have now corrected and implemented all of these, but it's really struggling to converge.\nWhat is the best plan of attack to fix the convergence issues?",
                          "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7175324",
                          "updatedAt": "2023-10-03T12:47:48Z",
                          "publishedAt": "2023-10-03T12:47:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This plan\nhttps://mooseframework.inl.gov/moose/application_usage/failed_solves.html",
                          "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7175507",
                          "updatedAt": "2023-10-03T13:02:38Z",
                          "publishedAt": "2023-10-03T13:02:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Moving precipitates at grain boundaries",
          "author": {
            "login": "mdh23rct"
          },
          "bodyText": "Dear MOOSE experts,\nHope you are doing great! Currently, I am trying to simulate moving spherical precipitates in grain boundaries. For that I have to include:\n\nMultiple precipitates moving along the grain boundaries.\nprecipitate-precipitate interaction and precipitate-grain boundary interaction.\n\nI am planning to use the phase-field module for that. Would you be kind to advice me any particular tutorials I could follow.\nAlso do I need to combine any other module for that!\nI would appreciate your advice.\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/25563",
          "updatedAt": "2023-10-02T21:18:58Z",
          "publishedAt": "2023-09-23T17:22:14Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen",
                  "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7091534",
                  "updatedAt": "2023-09-24T01:45:29Z",
                  "publishedAt": "2023-09-24T01:45:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "Dear Dr. Guillaume,\nI am currently trying to simulate random formation of precipitates in a polycrystal using phase field. However, when I run the random formation code, I am seeing some boundary problems. The nucleation is happening at the outer boundaries (not the grain boundaries) of the computational domain, specially at the junction between grains. This seems to be some sort of computational error. For your convenience, I have attached the image of boundary problem and mesh in this mail.\n\n\nI am also attaching the random nucleation code I am using.\n[Modules]\n    [./PhaseField]\n      [./Conserved]\n        [./c]\n          free_energy = F\n          mobility = M\n          kappa = kappa_c\n          solve_type = REVERSE_SPLIT\n        [../]\n      [../]\n    [../]\n  []\n  \n  [ICs]\n    [./c_IC]\n      type = ConstantIC\n      variable = c\n      value = 0.2\n    [../]\n  []\n  \n  [Materials]\n    [./pfmobility]\n      type = GenericConstantMaterial\n      prop_names  = 'M kappa_c'\n      prop_values = '1 25'\n    [../]\n    [./chemical_free_energy]\n      # simple double well free energy\n      type = DerivativeParsedMaterial\n      property_name = Fc\n      coupled_variables = 'c'\n      constant_names       = 'barr_height  cv_eq'\n      constant_expressions = '0.1          0'\n      expression = 16*barr_height*c^2*(1-c)^2 #+0.01*(c*plog(c,0.005)+(1-c)*plog(1-c,0.005))\n      derivative_order = 2\n      outputs = exodus\n    [../]\n    [./probability]\n      # This is a made up toy nucleation rate it should be replaced by\n      # classical nucleation theory in a real simulation.\n      type = ParsedMaterial\n      property_name = P\n      coupled_variables = c\n      expression = 'if(c<0.21,c*1e-8,0)'\n      outputs = exodus\n    [../]\n    [./nucleation]\n      # The nucleation material is configured to insert nuclei into the free energy\n      # tht force the concentration to go to 0.95, and holds this enforcement for 500\n      # time units.\n      type = DiscreteNucleation\n      property_name = Fn\n      op_names  = c\n      op_values = 0.90\n      penalty = 5\n      penalty_mode = MIN\n      map = map\n      outputs = exodus\n    [../]\n    [./free_energy]\n      # add the chemical and nucleation free energy contributions together\n      type = DerivativeSumMaterial\n      derivative_order = 2\n      coupled_variables = c\n      sum_materials = 'Fc Fn'\n    [../]\n  []\n  \n  [UserObjects]\n    [./inserter]\n      # The inserter runs at the end of each time step to add nucleation events\n      # that happened during the timestep (if it converged) to the list of nuclei\n      type = DiscreteNucleationInserter\n      hold_time = 50\n      probability = P\n      radius = 1\n    [../]\n    [./map]\n      # The map UO runs at the beginning of a timestep and generates a per-element/qp\n      # map of nucleus locations. The map is only regenerated if the mesh changed or\n      # the list of nuclei was modified.\n      # The map converts the nucleation points into finite area objects with a given radius.\n      type = DiscreteNucleationMap\n      periodic = c\n      inserter = inserter\n    [../]\n  []\n  \n  [Preconditioning]\n    [./SMP]\n      type = SMP\n      full = true\n    [../]\n  []\n  \n  [BCs]\n    [./Periodic]\n      [./all]\n        auto_direction = 'x y'\n      [../]\n    [../]\n  []\n  \n  [Postprocessors]\n    [./dt]\n      type = TimestepSize\n    [../]\n    [./ndof]\n      type = NumDOFs\n    [../]\n    [./rate]\n      type = DiscreteNucleationData\n      value = RATE\n      inserter = inserter\n    [../]\n    [./dtnuc]\n      type = DiscreteNucleationTimeStep\n      inserter = inserter\n      p2nucleus = 0.0005\n      dt_max = 10\n    [../]\n    [./update]\n      type = DiscreteNucleationData\n      value = UPDATE\n      inserter = inserter\n    [../]\n    [./count]\n      type = DiscreteNucleationData\n      value = COUNT\n      inserter = inserter\n    [../]\n  []\n  \n  [Adaptivity]\n    [./Indicators]\n      [./jump]\n        type = GradientJumpIndicator\n        variable = c\n      [../]\n    [../]\n    [./Markers]\n      [./nuc]\n        type = DiscreteNucleationMarker\n        map = map\n      [../]\n      [./grad]\n        type = ValueThresholdMarker\n        variable = jump\n        coarsen = 0.1\n        refine = 0.2\n      [../]\n      [./combo]\n        type = ComboMarker\n        markers = 'nuc grad'\n      [../]\n    [../]\n    marker = combo\n    cycles_per_step = 3\n    recompute_markers_during_cycles = true\n    max_h_level = 3\n  []\n  \n  [Executioner]\n    type = Transient\n    scheme = bdf2\n    solve_type = 'PJFNK'\n    petsc_options_iname = '-pc_type -sub_pc_type'\n    petsc_options_value = 'asm      lu          '\n  \n    nl_max_its = 100\n    l_tol = 1.0e-4\n    nl_rel_tol = 1.0e-9\n    nl_abs_tol = 1.0e-9\n    start_time = 0.0\n    end_time = 4000\n  \n    [./TimeStepper]\n      type = IterationAdaptiveDT\n      dt = 10\n      growth_factor = 1.5\n      cutback_factor = 0.5\n      optimal_iterations = 8\n      iteration_window = 2\n      timestep_limiting_postprocessor = dtnuc\n    [../]\n  []\n  \n  [Outputs]\n    exodus = true\n    csv = true\n    print_linear_residuals = false\n  []\n\nWould you be kind to let me know if I am missing something in the code to remove this boundary issues? Or the definition of the BCs is wrong in these code? I would appreciate your advice.\nBest regards.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7147498",
                          "updatedAt": "2023-09-29T18:44:17Z",
                          "publishedAt": "2023-09-29T18:42:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This looks like a poor interaction between adaptivity and periodic boundary conditions.\nCan you try to run the code in debug module (recompile with METHOD=debug make -j4) to see if you get an error?\nElse would you consider turning off adaptivity near the borders? You d have to make a custom indicator probably",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7147522",
                          "updatedAt": "2023-09-29T18:46:10Z",
                          "publishedAt": "2023-09-29T18:46:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "Dear Dr. Guillaume,\nThank you for your reply. Since I am a newbie in MOOSE, please don't be annoyed by my questions:\n\nHow I can turn off adaptivity near the borders? As far as I guess, I have to generate a specific block (excluding the border regions), for which the adaptivity will be applied. Maybe you know better ways to do it? Please be aware that the mesh is irregular and not symmetric. Therefore, I exactly don't know how I can generate this mesh block!!\nHow to make a custom indicator for the border region? The same way as it is done for the whole domain??\n\nIf you have any tutorials regarding these, I would be happy if you can forward.\nI would appreciate your reply. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7147737",
                          "updatedAt": "2023-09-29T19:18:18Z",
                          "publishedAt": "2023-09-29T19:18:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the mesh is irregular and not symmetric\n\nit s periodic though right? If it s not periodic, the periodic BCs will fail",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7147762",
                          "updatedAt": "2023-09-29T19:21:52Z",
                          "publishedAt": "2023-09-29T19:21:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "Yes, the mesh is periodic. However, mesh adaptivity has some issue with the periodic boundary condition. If I turn off the periodic boundary condition, the border problem disappears.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7158708",
                          "updatedAt": "2023-10-01T17:21:03Z",
                          "publishedAt": "2023-10-01T17:21:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@roystgnr do we support adaptivity with a periodic mesh that becomes non-periodic with adaptivity?",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7158905",
                          "updatedAt": "2023-10-01T18:04:26Z",
                          "publishedAt": "2023-10-01T18:04:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "We definitely should support consistently combined constraints when using adaptivity with a periodic mesh.  git grep -l auto_direction | xargs grep -l Adaptivity shows a few dozen test files (mostly in the phase field module) using both.\nThe results here are obviously a non-physical bug, and almost certainly due to some adaptivity+periodicity interaction, but I don't understand what \"extra\" is going on that we're not covering in regression tests.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7165984",
                          "updatedAt": "2023-10-02T14:41:56Z",
                          "publishedAt": "2023-10-02T14:41:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Hi @mdh23rct , if you want to insert nuclei at grain boundaries, you are going to need to modify this example- right now you are setting c = 0.2 everywhere in the initial conditions, and then making the nucleation probability uniformly high everywhere c < 0.21. So, there is nothing that makes the nucleation localized to GBs as far as I can tell. I am not sure why it seems to be happening at the domain boundaries first, but the problem is not set up to capture the physics you want so I would start by trying to correct that. How are the grain boundaries represented in your simulation? It seems that you are running on a mesh that is refined near GBs, but that is not enough to represent the grain boundaries in the simulation. Normally we do this by adding some additional order parameters to represent the presence of the grains.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7166124",
                          "updatedAt": "2023-10-02T14:54:04Z",
                          "publishedAt": "2023-10-02T14:54:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "Dear Dr. Larry,\nI appreciate your reply.\n\nWe did SEM on the specimens. We are seeing carbide formation predominantly at the grain boundaries. That means carbon is diffusing to the grain boundaries.\nOk, I will modify the file as you adviced, and keep you updated.\n\nThanks for your time and support. I appreciate.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7169456",
                          "updatedAt": "2023-10-02T21:19:00Z",
                          "publishedAt": "2023-10-02T21:18:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ValidParams error",
          "author": {
            "login": "zahidhasan83"
          },
          "bodyText": "Dear MOOSE people,\nHope you are doing great! I am currently building a new app based on an old app coded by one of my colleagues three years back.\nWhile running the make file, it shows me the error:\nLinking Executable /home/user/projects/plasma/plasma-opt...\n/home/user/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/user/projects/plasma/lib/libplasma-opt.so: undefined reference to `InputParameters validParams<Material>()'\n/home/user/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/user/projects/plasma/lib/libplasma-opt.so: undefined reference to `InputParameters validParams<Kernel>()'\ncollect2: error: ld returned 1 exit status\nmake: *** [/home/user/projects/moose/framework/app.mk:445: /home/user/projects/plasma/plasma-opt] Error 1\n\n\nI believe, the code is using out-of-date style, or something is missing in the material and kernel of the source file. Do you have any suggestion, how I could solve this problem? For you convenience, I am adding part of the source file:\n#include \"PhaseFieldMaterial.h\"\n\nregisterMooseObject(\"plasmaApp\", PhaseFieldMaterial);\n\ntemplate <>\nInputParameters\nvalidParams<PhaseFieldMaterial>()\n{\n  InputParameters params = validParams<Kernel>();\n  params.addClassDescription(\n      \"Transforms a material property into a kernel value (including off-diagonal terms.\");\n  params.addRequiredParam<MaterialPropertyName>(\"mat_function\",\"The material property name\");\n  params.addCoupledVar(\"args\", \"Vector of arguments that the material property depends on.\");\n  return params;\n}\n\nPhaseFieldMaterial::PhaseFieldMaterial(const InputParameters & parameters)\n  : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n    _K(getMaterialProperty<Real>(\"mat_function\")),\n    _dKdu(getMaterialPropertyDerivative<Real>(\"mat_function\", _var.name())),\n    _nvar(_coupled_moose_vars.size()),\n    _dKdarg(_nvar)\n{\n  // Get rate derivatives wrt args\n  for (unsigned int i = 0; i < _nvar; ++i)\n    _dKdarg[i] = &getMaterialPropertyDerivative<Real>(\"mat_function\", _coupled_moose_vars[i]->name());\n}\n\nBest regards.",
          "url": "https://github.com/idaholab/moose/discussions/25645",
          "updatedAt": "2023-10-02T21:09:22Z",
          "publishedAt": "2023-10-02T20:57:11Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSee this annoucement for this hard deprecation we performed over a couple years\nhttps://mooseframework.inl.gov/newsletter/2021/2021_11.html#legacy-input-parameter-deprecation\nYou ll need to update all the objects that use the old declaration / definition for parameters\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25645#discussioncomment-7169362",
                  "updatedAt": "2023-10-02T21:02:26Z",
                  "publishedAt": "2023-10-02T21:02:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zahidhasan83"
                          },
                          "bodyText": "Dear Dr. Guillaume,\nThanks. I will update the objects as you advised. If still I find any issue, your advice will be appreciated.\nUntil then, all the very best.",
                          "url": "https://github.com/idaholab/moose/discussions/25645#discussioncomment-7169401",
                          "updatedAt": "2023-10-02T21:09:22Z",
                          "publishedAt": "2023-10-02T21:09:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Outputting the time derivative of non-linear variable",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Hi all,\nI need to output the time derivative of a non-linear variable into another non-linear variable. The type TimeDerivativeAux allows me to feed in a non-linear variable but will only output the time derivative to a linear variable. Is there another of computing the time derivative that will let me output to a non-linear variable?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/25640",
          "updatedAt": "2023-10-02T20:36:35Z",
          "publishedAt": "2023-10-02T13:35:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis doesnt seem like a good idea. If Y a non linear variable is simply X_dot, then you are adding a full variable of dofs to the nonlinear system to compute something that you can solve easily on the side. The nonlinear system is bigger and it will cost you\nEverywhere you have Y in your equations, just use X_dot instead, which you can compute using coupledDot(\"X\") or adCoupledDot(\"X\")\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7165520",
                  "updatedAt": "2023-10-02T14:03:06Z",
                  "publishedAt": "2023-10-02T13:59:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "That makes sense! Thank you\nHowever, I need to feed this derivative into a ParsedMaterial. coupledDot does not make a new coupled variable; it returns a pointer to a value, from my understanding. ParsedMaterial only looks for coupledVariables, which means that I would need to make a new coupled variable to store the time derivatives to feed the dot values in a parsedmaterial. Is this correct?",
                          "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7166023",
                          "updatedAt": "2023-10-02T14:45:48Z",
                          "publishedAt": "2023-10-02T14:45:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Two options:\n\nproceed anyway: make a kernel that is just computing test * (Y-X_dot) as the equation for Y. That will do what you want\nwrite a new material with the expression you need directly. This is likely the most efficient",
                          "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7166066",
                          "updatedAt": "2023-10-02T14:48:13Z",
                          "publishedAt": "2023-10-02T14:48:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Got it, thank you",
                          "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7166079",
                          "updatedAt": "2023-10-02T14:49:01Z",
                          "publishedAt": "2023-10-02T14:49:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "One more follow up:\n\n\nproceed anyway: make a kernel that is just computing test * (Y-X_dot) as the equation for Y. That will do what you want\n\n\nI am already using the ADTimeDerivative kernel. My original thought was to just output the _u_dot[_qp] variable created by this kernel, but I could not find a way to do so. I just want to double-check as to whether or not this is possible.",
                          "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7166368",
                          "updatedAt": "2023-10-02T15:11:30Z",
                          "publishedAt": "2023-10-02T15:11:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "sure you can use a Reaction kernel and an ADTimeDerivativeKernel to form that equation",
                          "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7166388",
                          "updatedAt": "2023-10-02T15:13:00Z",
                          "publishedAt": "2023-10-02T15:13:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If you don\u2019t have any spatial derivatives in your equation then it doesn\u2019t make sense to add projection error into the problem. I would suggest using the nodal kernel equivalent of time derivative and reaction kernels to avoid this",
                          "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7166589",
                          "updatedAt": "2023-10-02T15:31:53Z",
                          "publishedAt": "2023-10-02T15:31:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Got it, thank you both",
                          "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7167107",
                          "updatedAt": "2023-10-02T16:18:19Z",
                          "publishedAt": "2023-10-02T16:18:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "@GiudGiud\nUnfortunately, I am still having some trouble here. I wrote a new kernel but it led to a seg fault when the NL iteration began. I want to make sure I understand everything correctly. Here are the relevant portions of my input file. I have the kernels enacting the physics for d, while I have an extra kernel to output the derivative of d with respect to time, which is written to the variable ddot\n[Variables]\n  [d]\n  []\n  [ddot]\n  []\n[]\n\n[Kernels]\n  [Phys1]\n    type = CoefTimeDerivative\n    variable = d\n  [phy2]\n   type = ADDiffusion\n   variable = d\n  [phy3]\n    type = ADReaction\n    variable = d \n  []\n   [ddot]\n    type = ADTimeDerivativeCustom\n    variable = ddot\n    deriv_var = d\n  []\n[]\n\nHere is the relevant section of the kernel I wrote. I am replicating the _test(Y-X_dot) form you suggested.\nAre you able to find any issues with this implementation?\nADTimeDerivativeCustom::validParams()\n{\n  InputParameters params = ADKernelValue::validParams();\n  params.addClassDescription(\"outputting the time derivative\");\n  params.addRequiredCoupledVar(\"deriv_var\", \"variable to take time derivative of\");\n\n  return params;\n}\n\nADTimeDerivativeCustom::ADTimeDerivativeCustom(const InputParameters & parameters)\n  : ADKernelValue(parameters), _d_dot(adCoupledDot(\"deriv_var\"))\n{\n}\n\nADReal\nADTimeDerivativeCustom::precomputeQpResidual()\n{\n  return _test[_i][_qp] * (_u[_qp] - _d_dot[_qp]);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7167771",
                          "updatedAt": "2023-10-02T17:28:07Z",
                          "publishedAt": "2023-10-02T17:27:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Try compiling in dbg mode and run in a debugger. That will show you where the segmentation fault is coming from",
                          "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7167814",
                          "updatedAt": "2023-10-02T17:31:02Z",
                          "publishedAt": "2023-10-02T17:31:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Ah I was afraid you would say that. I need to figure out why I get compile errors when trying to make the dbg executable. But that's a whole other topic",
                          "url": "https://github.com/idaholab/moose/discussions/25640#discussioncomment-7167838",
                          "updatedAt": "2023-10-02T17:33:49Z",
                          "publishedAt": "2023-10-02T17:33:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}