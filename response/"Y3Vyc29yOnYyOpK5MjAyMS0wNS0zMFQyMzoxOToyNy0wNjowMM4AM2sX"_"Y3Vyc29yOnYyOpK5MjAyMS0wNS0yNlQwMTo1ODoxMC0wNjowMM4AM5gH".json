{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNS0yNlQwMTo1ODoxMC0wNjowMM4AM5gH"
    },
    "edges": [
      {
        "node": {
          "title": "Ansys mesh cannot be used in moose",
          "author": {
            "login": "liangyu-psi"
          },
          "bodyText": "Bug Description\nThe mesh generated by ICEM or Ansys Mesh cannot be recongized by MOOSE.\nSteps to Reproduce\nThe format of mesh is .msh. It's will cause a dimension error.\nBut when I use Gmsh. Although the format is still .msh, it will be recongized by MOOSE.\nImpact\nIt's not convenient to create a mesh by familiar software. I don't know if the mesh file of Ansys does not meet the MOOSE standard. Hope someone can answer. Many thanks.",
          "url": "https://github.com/idaholab/moose/discussions/17434",
          "updatedAt": "2022-06-28T14:49:13Z",
          "publishedAt": "2021-03-23T10:27:35Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "liangyu-psi"
                  },
                  "bodyText": "Is there anybody know the reason?",
                  "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-534718",
                  "updatedAt": "2022-06-28T14:49:13Z",
                  "publishedAt": "2021-03-26T13:31:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AnthonyB08"
                          },
                          "bodyText": "Is there any update on using Ansys Meshing file for MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-799493",
                          "updatedAt": "2022-06-28T14:49:14Z",
                          "publishedAt": "2021-05-28T19:48:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "You might be confusing a file extension with a mesh format. While both files end in .msh they might not be the same format at all. Is there a different format you could export your mesh to with Ansys?",
                  "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-534719",
                  "updatedAt": "2022-06-28T14:49:14Z",
                  "publishedAt": "2021-03-26T15:07:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "@dschwen This link suggests there are only a handful of export options for ANSYS (.mechdat, .msh, .poly, .cgns, .prj, and .tgf), so I think exporting to ANSYS .msh and converting using meshio (in my other answer) is probably the best bet if ANSYS must be used.",
                          "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-799698",
                          "updatedAt": "2022-06-28T14:49:28Z",
                          "publishedAt": "2021-05-28T20:58:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "There is a python tool, Meshio, that would allow a conversion from the .msh file created by ANSYS to an Exodus .e file which MOOSE can also import. Check out https://pypi.org/project/meshio/",
                  "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-799681",
                  "updatedAt": "2022-06-28T14:49:35Z",
                  "publishedAt": "2021-05-28T20:52:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AnthonyB08"
                          },
                          "bodyText": "I have tried this, but i keeps returning the same error of :\n\nSo then I resorted to importing my .msh into CUBIT and exporting it as a .e",
                          "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-799725",
                          "updatedAt": "2022-06-28T14:49:36Z",
                          "publishedAt": "2021-05-28T21:10:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "Oops - Not a very helpful error is it? Though it appears as though meshio could be treating it as a GMSH .msh file as well, judging from that output. I don't have ANSYS to troubleshoot with, but I'm glad you have a good workaround!",
                          "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-799739",
                          "updatedAt": "2022-06-28T14:49:41Z",
                          "publishedAt": "2021-05-28T21:15:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Access to nodal variable value][Postprocessor]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear users,\nI just found a way to access nodal variable values in postprocessors like the below (bold).\nBut this method only can access individual nodal id.\nIs there any way to call all nodal variable values in postprocessors?\nOr how can I load a number of nodes in mesh?\nThen, maybe I can use iterations to call all the variable values.\nI have looked through the whole postprocessors in moose but I could not find anything.\n\nReal\nNodalVariableValue::getValue()\n{\nReal value = 0;\nif (_node_ptr && _node_ptr->processor_id() == processor_id())\nvalue = _subproblem.getStandardVariable(_tid, var_name).getNodalValue(*_node_ptr);\ngatherSum(value);\nreturn _scale_factor * value;\n}",
          "url": "https://github.com/idaholab/moose/discussions/17952",
          "updatedAt": "2022-08-01T11:15:51Z",
          "publishedAt": "2021-05-27T16:08:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "Can you describe specifically what you are trying to accomplish? That is, what are you trying to output and when?",
                  "url": "https://github.com/idaholab/moose/discussions/17952#discussioncomment-793951",
                  "updatedAt": "2022-08-01T11:15:54Z",
                  "publishedAt": "2021-05-27T16:20:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Dear loganharbour,\nI am trying to make a precipitation of U(VI) in my transient model.\nSo, if U(VI) is reached certain threshold concentration, it will be precipitated via kinetic constant with U(VI) complex.\nTo make this, I need a postprocess every end of time step and this precipiated U(VI) complex should be an accumulated value.\nHence, I would like to access variable value end of each time step for whole nodal value to get concentration of U(VI) and judge whether it is saturated and start to precipitate.\nThen, I want to make the accumulation of U(VI) complex.",
                          "url": "https://github.com/idaholab/moose/discussions/17952#discussioncomment-795975",
                          "updatedAt": "2022-08-01T11:15:55Z",
                          "publishedAt": "2021-05-28T03:47:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "coskrrb2002"
                  },
                  "bodyText": "Oh, I found the way to do this and made it!\nI used the following postprocessors and auxkernel.\nCumulativeValuePostprocessor, PostprocessorAux, and I modified NodalExtremeValue to get nodal value.\nSo, Modified NodalExtremeValue load variable values in nodes, then the CumulativeValuePostprocessor calculated the accumulation of nodal variable values.\nAfter that PostrpocessorAux assigned accumulated values into auxvariables!\nThank you so much loganharbour!",
                  "url": "https://github.com/idaholab/moose/discussions/17952#discussioncomment-796385",
                  "updatedAt": "2022-08-01T11:15:56Z",
                  "publishedAt": "2021-05-28T06:14:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Material Properties as a function of temperature",
          "author": {
            "login": "alikhan-zada"
          },
          "bodyText": "Hello everyone,\nI'm new to MOOSE and I am currently trying to use the Heat Conduction Module. Please bear with my novice question even if they might be very obvious\n\nI want to be able to use the thermal conductivity and specific heat as a function of temperature, something of this sort:\n\nthermal conductivity = 11.82 + 0.0106 T\nspecific heat = 330.9 + 0.563 T - 0.0004015 T^2 + 0.00000009465 T^3\nI have tried doing this using thermal_conductivity_temperature_function in the materials block, but Functions can only take in only (x,y,z,t) as variables.\n[Functions]\n[./k_func]\ntype = ParsedFunction\nvars = temp\nvalue = '11.82 + 0.0106 * temp'\n[../]\n[./c_func]\ntype = ParsedFunction\nvars = temp\nvalue = '330.9 + 0.563 * temp - 0.0004015 * temp * temp + 0.00000009465 *temp * temp * temp'\n[../]\n[] # Functions\n[Materials]\n[./heat]\ntype = ADHeatConductionMaterial\nblock = 0\ntemp = temp\nthermal_conductivity_temperature_function = k_func\nspecific_heat_temperature_function = c_func\n[../]\n[]\nWhich is obviously wrong. Can someone point me in the right direction, please :)\n\n\nMy other question is, how can I link the FunctionPathEllipsoidHeatSource and grain_growth_2D_graintracker together?\nI know there's an implementation of the grain_growth_2D_graintracker where the mobility is a function of temperature. This can be done using multiapps, but which multiapp would be the most suitable for this application? A question similar to this (here) has already been asked in the discussions but the answers are not very helpful.\n\n\nLastly, what are the units of the different constants used in  FunctionPathEllipsoidHeatSource?\n\n\nKind regards,\nAli\nEdit: I was able to link up the two apps, so need to worry about question 2  \ud83d\ude05\ufe0f\nEdit 2: for question 3, units of material properties in the function_ellipsoid_heat_source are as follows:\nSpecific heat = J/(Kg . K)\nThermal Conductivity = W/(mm . K)\nDensity = Kg/mm^3\nPlease correct me if I am wrong. \ud83d\ude05",
          "url": "https://github.com/idaholab/moose/discussions/17820",
          "updatedAt": "2022-08-28T03:53:50Z",
          "publishedAt": "2021-05-13T10:45:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "I would create a new Material that defines the conductivity and specific heat with your desired function coded in the Material object.\nWe do this in Step 5 and 6 of the YouTube tutorial on the front page of mooseframework.org. Click the 'SHOW MORE\" and you will be able to go to the section.\nIn the tutorial we do a linear interpolation based on tabulated data to compute the temperature dependent properties: https://github.com/idaholab/moose/blob/next/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/src/materials/PackedColumn.C",
                  "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-734535",
                  "updatedAt": "2022-09-19T03:12:28Z",
                  "publishedAt": "2021-05-13T16:08:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alikhan-zada"
                          },
                          "bodyText": "Thank you Andrew,\nI'll take a look and let you know if I have any more questions.\nCheers,\nAli",
                          "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-736743",
                          "updatedAt": "2022-09-19T03:12:29Z",
                          "publishedAt": "2021-05-14T03:57:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alikhan-zada"
                          },
                          "bodyText": "Hey @aeslaughter, so what if I want to deposit a layer of material after each time the heat source passed from on top of the material?\nSomething like this https://ars.els-cdn.com/content/image/1-s2.0-S0924013618300980-mmc4.gif",
                          "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-769266",
                          "updatedAt": "2022-09-19T03:12:29Z",
                          "publishedAt": "2021-05-21T16:45:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "We do have some developments for this purpose. I would suggest you to look at: https://mooseframework.inl.gov/source/userobject/CoupledVarThresholdElementSubdomainModifier.html\nThe idea is to divide your physical domain into \"active\" and \"inactive\" subdomains, define your physical kernels in the \"active subdomain\" (with 'block = #'), and constantly moving elements from  \"inactive subdomain\" -> \"active subdomain\". (Set the kernel_coverage_check = false in the Problem block if no kernel is defined in the inactive subdomain)\nTo realize layer-by-layer material addition, I would try to set the coupled_var to be the z-position of the element. The threshold value to be the height of the heat source (I guess), below which the elements will be added. If you would like to apply BC at the top of the product as it is growing, then set the moving _boundary_name to be the sideset of the product top surface.\n@hugary1995 please feel free to add/correct me here since you made some great changes to this code :)",
                          "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-783493",
                          "updatedAt": "2022-09-19T03:12:29Z",
                          "publishedAt": "2021-05-25T21:56:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alikhan-zada"
                          },
                          "bodyText": "Thank you @dewenyushu for your answer.\nAs you can see in the gif, there is also a 2-D sectioned area, is it possible to deploy a MultiApp system just in that 2-D section and transfer the value of the heat source?\nWhat I am guessing is that both the Master and the sub app use the TransientMultiApp system and since the scales are not that different use the MultiAppCopyTransfer because I will probably use the same mesh distribution. But I might need to use a different transfer function if I decide to use adaptivity, what would be the best choice in that case?",
                          "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-790893",
                          "updatedAt": "2022-09-19T03:12:31Z",
                          "publishedAt": "2021-05-27T08:32:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Since I am not an expert on multiapp and transfers, @jiangwen84 would you mind answering this question?",
                          "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-794848",
                          "updatedAt": "2022-09-19T03:12:33Z",
                          "publishedAt": "2021-05-27T19:38:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Gradient of a tensor in Moose",
          "author": {
            "login": "ritamcj"
          },
          "bodyText": "Hi everyone,\nI am attempting to develop a dislocation density based crystal plasticity framework in the tensor mechanics module in Moose. To calculate the GND density (geometrically necessary dislocations) using Nye tensor (Nye (1953)), I need to compute the gradient of the plastic deformation gradient tensor (Fp) (Das et al. (2018)). Could anyone kindly guide me to the relevant resources in Moose? I have looked in the Phase field module in the solution of the Allen-Cahn equation (ACinterface.C), where the mobility gradient is calculated. But I am unable to figure out how the \"RealGradient\" method is being used to compute gradients. I am attempting to calculate the expressions (1)-(6) as attached.\nRitam Chatterjee",
          "url": "https://github.com/idaholab/moose/discussions/17741",
          "updatedAt": "2022-07-25T09:37:41Z",
          "publishedAt": "2021-05-03T18:17:51Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "This is a great question. Fp is directly calculated at quadrature points and it is not usually convenient to get its derivatives. One way you can do is to project Fp from quad points to nodes and then interpolate it using gradient of shape functions. In MOOSE, you can possibly perform global/local L2 project or Least Square fitting to get the nodal Fp values. For local LSF projection, you can take a look at an example at https://mooseframework.inl.gov/help/finite_element_concepts/nodal_patch_recovery.html",
                  "url": "https://github.com/idaholab/moose/discussions/17741#discussioncomment-690099",
                  "updatedAt": "2022-07-25T09:37:41Z",
                  "publishedAt": "2021-05-03T19:46:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Dear Wen,\nThank you so much for your prompt response. Are there any existing implementations of the nodal patch recovery technique in Moose? I was able to find some relevant literature (Pitts (2019)) and now have some idea of how to implement. If I understand correct, the gradient of the shape function is to be multiplied with Fp at the quadrature points and the nodal values will be calculated by taking a polynomial interpolation over all neighbouring quadrature points as shown in the thesis of Pitts (2019). I will attempt to implement and revert back to you in case there are more queries.\nWarm regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/17741#discussioncomment-695371",
                          "updatedAt": "2022-07-25T09:37:57Z",
                          "publishedAt": "2021-05-04T18:55:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Hi Ritam,\nWhen I calculated the gradient of the Fp tensor, I used the nodal patch recovery method that Wen linked to above to \"push\" the value of each Fp tensor component to the nodes, and then used the coupledGradient API to find the values of the gradient of each tensor component. More information on the coupledGradient API can be found here: https://mooseframework.inl.gov/docs/doxygen/moose/classCoupleable.html#a9c8ae645c4ed3f969de1345f2cc4fb27 and https://mooseframework.inl.gov/source/interfaces/Coupleable.html\nCertainly this approach wasn't computationally efficient, and hasn't been added to the official MOOSE repository. I believe that the MOOSE team is discussing different methods for these types of calculations. I'd recommend watching the Newsletter for updates, and perhaps Wen can provide additional details if he has more information, too.\nHope this helps some,\nStephanie",
                          "url": "https://github.com/idaholab/moose/discussions/17741#discussioncomment-695946",
                          "updatedAt": "2022-07-25T09:37:57Z",
                          "publishedAt": "2021-05-04T21:09:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Stephanie,\nThank you very much for your suggestions. I will work on this and keep an eye on the newsletter.\nWarm regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/17741#discussioncomment-696926",
                          "updatedAt": "2022-07-25T09:38:42Z",
                          "publishedAt": "2021-05-05T06:19:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Wen and Stephanie,\nI tried various approaches to use CoupledGradient to obtain grad(Fp), but unsuccessfully. I am pasting the original code here:\n                 const VariableGradient &\n                 Coupleable::coupledGradient(const std::string & var_name, unsigned int comp) const\n                 {\n                 const auto * const var = getVarHelper<MooseVariableField<Real>>(var_name, comp);\n                 if (!var)\n                 {\n                 _default_gradient.resize(_coupleable_max_qps);\n                 return _default_gradient;\n                 }\n                 checkFuncType(var_name, VarType::Gradient, FuncAge::Curr);\n\n                 if (!_coupleable_neighbor)\n                 return (_c_is_implicit) ? var->gradSln() : var->gradSlnOld();\n                 return (_c_is_implicit) ? var->gradSlnNeighbor() : var->gradSlnOldNeighbor();\n                 }\n\nNow, as my variable is Fp, which is a rank two tensor, can the argument \"var_name\" be defined as something other than a string? Fp is calculated in FiniteStrainUOBasedCP and I am reading it in my C file as \"_fp(getMaterialPropertyByName(\"fp\"))\". I tried storing the components of Fp in an array and defining var_name as \"DenseVector\" but this did not work.\nBasically, how can I define Fp as a string in my input file such that it can be passed as an argument to coupledGradient? Or else, is it possible to pass a vector or tensor to coupledGradient without having to define in the input file?\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/17741#discussioncomment-744270",
                          "updatedAt": "2022-09-22T04:45:32Z",
                          "publishedAt": "2021-05-16T12:26:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "You are mixing up variables and material properties. Those are not exchangable. You'll have to extract the tensor components into 9 variables (either use AuxVariables and nodal patch recovery - not fully implemented), or use regular variables (e.g. named Fp00 Fp01 Fp02 Fp10 ... Fp22) and use the MaterialPropertyValue kernel with a RankTwoCartesianComponent material (the kernel solves for a (nodal) variable field to match the property values at quadrature points). Then you can construct a RankThreeTensor from the gradients of your nine variables. We might want to consider making an action for this.",
                          "url": "https://github.com/idaholab/moose/discussions/17741#discussioncomment-744508",
                          "updatedAt": "2022-09-27T12:55:04Z",
                          "publishedAt": "2021-05-16T13:59:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Daniel,\nThank you for your valuable suggestions. I will attempt these two methods.\nWarm Regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/17741#discussioncomment-746353",
                          "updatedAt": "2022-09-27T12:55:04Z",
                          "publishedAt": "2021-05-17T05:12:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Daniel,\nI attempted the auxvariable method and created auxvariables to access the components of Fp. Here, I am pasting patches of my code for only one component of Fp. The auxvariables were defined as:\n[./gnd_evol_alpha]\n    type = CP_DD_GND_generation\n    variable_size = 28\n    Fp00 = fp_00\n  [../]\n\nThen I read the strings in my C file to apply to the CoupledGradient API as:\nfor (p = 0; p < 3; ++p)\n{\n   _grad_Fp00[p] = &coupledGradient(\"Fp00\", p);\n}\n\nwhere I have defined the strings as:\n  params.addRequiredCoupledVar(\"Fp00\", \"Fp(0,0)\");\n\nIn the class declaration, the gradient variable is defined as:\n    _grad_Fp00(3)\n\nwhich is defined in the header file as:\n std::vector<const VariableGradient *> _grad_Fp00;\n\nThrough this method, I am able to read the Fp components at only the first time step and not the evolved values afterwards. To verify this, we performed a bending test (attached) and checked the GND density evolution across a three-element structure but there was no change. Could you kindly point out an error in implementation if possible? In my humble opinion, it is not possible to read the updated Fp from FiniteStrainUObasedCP at each time step by reading the auxvariables from the input file. Thank you so much for your time.\nWarm regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/17741#discussioncomment-794411",
                          "updatedAt": "2022-09-27T12:55:04Z",
                          "publishedAt": "2021-05-27T17:42:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[About postprocessor][Accumulation values]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear users,\nI am trying to find a way to implement accumulation values after each time step in my transient model.\nThe accumulated values should be used in the next time step to calculate residuals.\nCan I use a postprocessor to do this?\nBecause I have tried to use auxkernels and material kernels before,\nbut I could not find a way to accumulate value in auxkernel.\nI could accumulate values by material kernels but, it repeated inside of the residual calculation and showed me wrong values. (via _old_Name[_qp]).",
          "url": "https://github.com/idaholab/moose/discussions/17945",
          "updatedAt": "2023-06-22T10:22:04Z",
          "publishedAt": "2021-05-27T09:08:31Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "Take a look at CumulativeValuePostprocessor.\nHere's an example input: https://github.com/idaholab/moose/blob/next/test/tests/postprocessors/cumulative_value_postprocessor/cumulative_value_postprocessor.i, which is accumulating the number of nonlinear iterations from another postprocessor over time.",
                  "url": "https://github.com/idaholab/moose/discussions/17945#discussioncomment-793274",
                  "updatedAt": "2023-06-22T10:24:43Z",
                  "publishedAt": "2021-05-27T14:18:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Dear loganharbour,\nThank you for your comment!",
                          "url": "https://github.com/idaholab/moose/discussions/17945#discussioncomment-793885",
                          "updatedAt": "2023-06-22T10:24:43Z",
                          "publishedAt": "2021-05-27T16:08:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Failing 'make -j 8' on MAC M1 machine",
          "author": null,
          "bodyText": "I'm trying to install MOOSE on my Macbook Air M1 machine, but am unable to pass the testing. I made sure my home directory was wiped of any hidden bash_session, git, conda, and related folders, and did a completely new installation of MOOSE. I made sure to perform the following:\n\nUpdating conda before installation of MOOSE\nUpdating MOOSE once MOOSE was cloned with git\nPerforming 'conda init bash' and successfully activating MOOSE\nInstalling moose-pyhit\nPeforming 'git clean -xfd'\nRestarting my shell\n\nNonetheless, both with the 'make -j 4' and 'make -j 8' commands, the system reports numerous errors, the majority coming from the file '~/miniconda3/envs/moose/bin/../include/c++/v1' with errors such as 'no member named 'strtod' in the global namespace', which included other members such as atol, size_t, div_t, and more. Later in the diagnostic message, this error appeared: 'clang frontend command failed due to signal (use -v to see invocation)'\nI hope I have illustrated the issue fully enough. If someone needs additional information, I will happily provide it. I've tried to install MOOSE the past two weeks with various methods, and these sorts of errors have shown up every time.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/17942",
          "updatedAt": "2021-05-27T15:07:10Z",
          "publishedAt": "2021-05-27T00:44:54Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "Unfortunately, we don't have any packages built for Apple Silicon as of yet.\nThe following... is a very early stage of building these packages. The current changes can be found on my m1-bigsur branch: milljm@150cd56\nYou will need to first build/install the moose-mpich package using conda build based on the changes in my branch. Then, install PETSc 3.15.0 manually using the same configure options you see in the m1-bigsur branch (I believe I am unable to build superlu, and strumpack).\nAs for libMesh, it is necessary to 'bootstrap' it and several contribs before running configure:\nexport PETSC_DIR=/where/ever/you/installed/it\n\ncd moose/scripts\n./update_and_rebuild_libmesh.sh     <----- this will fail. But it grabs the appropriate hash of libMesh\ncd ../libmesh\n./bootstrap\ncd contrib/metaphysicl\n./bootstrap\ncd ../timpi\n./bootstrap\ncd ../netcdf/netcdf-c-4.6.2/\nautoreconf\ncd ../../../build\n../configure --with-methods=\"opt\" \\\n                                   --prefix=/some/location \\\n                                   --enable-silent-rules \\\n                                   --enable-unique-id \\\n                                   --disable-warnings \\\n                                   --enable-glibcxx-debugging \\\n                                   --disable-maintainer-mode \\\n                                   --enable-petsc-hypre-required \\\n                                   --enable-metaphysicl-required\nmake\nmake install\nexport LIBMESH_DIR=/some/location\nAfter all of this, you'll be able to build MOOSE. But it still doesn't run... M1 is receiving more traction, so I suspect we will see some packages being made available sooner rather than later.",
                  "url": "https://github.com/idaholab/moose/discussions/17942#discussioncomment-793281",
                  "updatedAt": "2021-05-27T14:21:00Z",
                  "publishedAt": "2021-05-27T14:20:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "One possible edit to your code snippet. I would replace the lines after PETSc export with\ncd moose\ngit submodule update --init libmesh\ncd libmesh\n\nSince that's all the libmesh script is doing anyway, and it removes seeing scary failures from the equation.",
                          "url": "https://github.com/idaholab/moose/discussions/17942#discussioncomment-793295",
                          "updatedAt": "2021-05-27T14:27:50Z",
                          "publishedAt": "2021-05-27T14:25:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can MOOSE compute integrals over a plane?",
          "author": {
            "login": "alanchavez86"
          },
          "bodyText": "Hi all,\nI'm still new to MOOSE and was curious as to how integrals are computed in moose. I understand that Finite element methods are used to numerically computed the solution to PDEs, but I'm interested in how moose goes about numerically computing integrals.\nI've looked into the postprocessors section of the moose framework website for more information and found ElementAverageValue to be a possible solution to my question.\nInstead of using the Ferret approach, I'm instead seeing how I can simplify an integral for the demagnetizing field which influences decomposition behavior.\n\nA simplified version for the integral part is given as an equation of phi:\n\nIf rho, the magnetic charge density, is assumed to be 1, the integral be simplified in terms of x' and y' as:\n\nWould this be an appropriate approach to apply in MOOSE or would it be better off finding how to solve over a volume?\nThanks\nHere's an additional document for further information (pg 2)\nFeng_2017_Peritectic PF Mag.pdf",
          "url": "https://github.com/idaholab/moose/discussions/17565",
          "updatedAt": "2022-08-12T05:56:38Z",
          "publishedAt": "2021-04-09T21:42:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nmoose will use the FE quadrature rules to compute the integral.\nrho would be a variable right? And you want phi defined over the whole domain (so a variable) or just for a single position (more like a postprocessor) ?\nFor the latter, I would recommend looking at ElementIntegralVariablePostprocessor to do that.\nEDIT: Actually over a plane, maybe InterfaceIntegralVariablePostprocessor might be more appropriate. How is this plane defined in your mesh?\nFor the former, there may be a kernel already for this? @cticenhour will know more.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17565#discussioncomment-592071",
                  "updatedAt": "2022-08-12T05:56:51Z",
                  "publishedAt": "2021-04-09T23:13:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "@alanchavez86 I don't work on simulating ferromagnetic alloys, but I do recognize another form of these equations. They appear to be integral forms of a Poisson equation for the magnetic potential (also called the magnetostatic potential):\n\nand\n\nwhere M is the magnetization vector. I suppose you could solve for the magnetostatic potential as a variable using the Diffusion Kernel in the volume. But, that still requires knowledge of the right-hand-side magnetic charge density source term, as well as applicable boundary conditions on that potential. They solve for M in the paper using phase field, so I think you should look at the phase field module in conjunction with Eqn 3 in the paper to help get M. From there, you'll need M in an auxvariable in order to couple it into the poisson equation to calculate the gradient source term.\nSo that you don't go down too much of a rabbit hole with this, I'm also tagging @mangerij (as the lead of Ferret) who will have some specific knowledge in this area and may give you tips on alternative ways of solving this problem if you're wanting to forge your own path outside of the Ferret approach. I'll also tag @laagesen for general phase field.",
                          "url": "https://github.com/idaholab/moose/discussions/17565#discussioncomment-600654",
                          "updatedAt": "2022-08-12T05:56:56Z",
                          "publishedAt": "2021-04-12T15:40:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "@GiudGiud Thanks for the reply and the insight, the plane is defined in my mesh as a 2D mesh:\n[Mesh]\ntype = GeneratedMesh\ndim = 2\nelem_type = QUAD4\nnx = 100\nny = 100\nxmax = 200\nymax = 200\n[]\nThinking about this, I was confused whether or not solving the integral through x and y would be the correct approach and if it would be better solving it some other way.\nI'm looking more into John and Casey's approach to implement the demagnetizing field into my input file.",
                          "url": "https://github.com/idaholab/moose/discussions/17565#discussioncomment-606281",
                          "updatedAt": "2022-08-12T05:56:56Z",
                          "publishedAt": "2021-04-13T18:42:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mangerij"
                  },
                  "bodyText": "Yeah, I think they need M = M(c) where c is their concentration variable of the phase field problem. What confuses me is the paper I have been sent only gives an expression for M = M(c) as a magnitude of the magnetization which makes it tricky to use in the Poisson equation since the righthand side is the divergence of the vector. At these temperatures, I highly doubt the vector direction matters...\nBut in principle if you calculate M correctly, Casey's suggestion is exactly what you need. Just add \u2207\u22c5M as a Kernel. Here is what the residual entry would look like after integrating by parts\nReal\nPoissonRHS::computeQpResidual()\n{\n  RealVectorValue m(_mag_x[_qp], _mag_y[_qp], _mag_z[_qp]);\n  return - m*_grad_test[_i][_qp];\n}",
                  "url": "https://github.com/idaholab/moose/discussions/17565#discussioncomment-603606",
                  "updatedAt": "2022-08-12T05:56:56Z",
                  "publishedAt": "2021-04-13T08:08:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "this approach works with reasonable accuracy",
                          "url": "https://github.com/idaholab/moose/discussions/17565#discussioncomment-603953",
                          "updatedAt": "2022-08-12T05:56:56Z",
                          "publishedAt": "2021-04-13T09:53:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "@mangerij Thank you for the response John. I was looking into creating a new kernel for \u2207\u22c5M but had a quick question on how to add a C++ file to a MOOSE application. MOOSE mentions creating a C++ object, but I wasn't sure if I create that separately from moose or if you can create the C++ object from the moose application.",
                          "url": "https://github.com/idaholab/moose/discussions/17565#discussioncomment-606479",
                          "updatedAt": "2022-08-12T05:57:02Z",
                          "publishedAt": "2021-04-13T19:40:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "You should add a .C file into src/kernels and an .h file into include/kernels. Both files should have the same name. Take a look how its done in any of the MOOSE examples. This is basically how you would set up an app.",
                          "url": "https://github.com/idaholab/moose/discussions/17565#discussioncomment-608488",
                          "updatedAt": "2022-08-12T05:57:04Z",
                          "publishedAt": "2021-04-14T08:24:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "@mangerij Thank you for all the help! Sorry to bother you again, I was hoping you can take a look at a recent question I posted. I was hoping to get your thoughts on it. #17899 Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/17565#discussioncomment-789200",
                          "updatedAt": "2022-09-17T17:41:34Z",
                          "publishedAt": "2021-05-26T22:00:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unable to solve environment when installing moose",
          "author": {
            "login": "sSajjad90"
          },
          "bodyText": "Dear all,\nI already had MOOSE on my system, and when I tried to update it, I got a chain of errors. So I decided to uninstall and re-install again. But I got stuck in the below trouble. It was in this state for more than 2 hours without a change. I interrupted it and try again, and the same problem.\nDoes anyone know what the problem is?\nPS: My system memory is 32 Gb\n(base) sajjad@sajjad-PC:~$ conda create --name moose moose-libmesh moose-tools\nCollecting package metadata (current_repodata.json): done\nSolving environment: failed with repodata from current_repodata.json, will retry with next repodata source.\nCollecting package metadata (repodata.json): done\nSolving environment:\\",
          "url": "https://github.com/idaholab/moose/discussions/17094",
          "updatedAt": "2022-08-23T09:36:13Z",
          "publishedAt": "2021-02-22T20:29:05Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "I've seen lengthy solves among our continuous integration environment, but not on personal workstations. Can you try the following, and then attempt the install:\nconda clean --all --yes\nIf the above fails, perhaps one module at a time:\nconda create -n moose moose-libmesh\nconda activate moose\nconda install moose-tools\nIt is moose-tools which contains the most 'dependencies' Conda must solve for. And sometimes I see handing it one-package-at-a-time speeds things up. Let us know if none of these options work! I have more 'ideas'. Conda clean doesn't get everything.",
                  "url": "https://github.com/idaholab/moose/discussions/17094#discussioncomment-395256",
                  "updatedAt": "2022-08-23T09:36:14Z",
                  "publishedAt": "2021-02-22T21:50:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "purepuremilk-zz"
                          },
                          "bodyText": "I am having this similar issue, and I am installing moose on my personal laptop: solving the environment takes forever with \"conda create --name moose moose-libmesh moose-tools\". I tried to use the suggested approach by creating an empty environment first, activate it, and install moose-libmesh and moose-tools separately. I found the order of installing packages matters. Here are my commands:\nconda create -n moose\nconda install -c idaholab moose-tools\nconda install -c idaholab moose-libmesh\nHere were what I found: If we installed moose-libmesh first and then moose-tool, solving enviroment for moose-tool would take a very long time since it was a large package.\nHowever, if we installed moose-tools first, which basically took no time, and then went to moose-libmesh, it still took a while to solve moose-libmesh, but in a much shorter time.",
                          "url": "https://github.com/idaholab/moose/discussions/17094#discussioncomment-778854",
                          "updatedAt": "2022-08-23T09:36:25Z",
                          "publishedAt": "2021-05-25T00:27:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Conda solves can be a pain. moose-tools adds a lot of variety to the equation that Conda needs to solve for.\nIn the world of Conda, I try to be as non-explicit as possible to avoid potential shortcomings of our packages in the event another developer decides to pull a specific version from the Anaconda cloud. A version we might explicitly state as a requirement. Thus, things work... most of the time. But that does come at a cost of solve time.\nI am being very explicit with moose-libmesh. Because that package requires that we use the same compiler stack to build MOOSE (and allows you to build your Application). Hence, installing moose-libmesh is quick. Or rather, quicker than moose-tools.",
                          "url": "https://github.com/idaholab/moose/discussions/17094#discussioncomment-781663",
                          "updatedAt": "2022-10-03T13:32:50Z",
                          "publishedAt": "2021-05-25T15:07:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "@purepuremilk-zz thank you for this advice!\nI have (will be) implementing this change into our Continuous Integration recipes on https://civet.inl.gov. To facilitate installing Conda packages separately. Specifically moose-tools first. As I too see a substantial speed increase doing so.\nI will also modify our instructions to reflect this optimization: #17934",
                          "url": "https://github.com/idaholab/moose/discussions/17094#discussioncomment-787284",
                          "updatedAt": "2022-10-03T13:32:57Z",
                          "publishedAt": "2021-05-26T16:17:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "@purepuremilk-zz\nThere also exists an interesting downgrading routine (explicit dependency somewhere?) for the following packages when installing moose-tools first, and then moose-libmesh (this being the only two packages requesting to be installed in a fresh environment on a Darwin machine):\nThe following packages will be REMOVED:\n\n  glib-tools-2.68.2-he49afe7_0\n  libgfortran5-9.3.0-h6c81a4c_22\n  libglib-2.68.2-hd556434_0\n  libnghttp2-1.43.0-h07e645a_0\n\nThe following packages will be SUPERSEDED by a higher-priority channel:\n\n  glib                  conda-forge::glib-2.68.2-he49afe7_0 --> pkgs/main::glib-2.68.0-hdf23fa2_0\n\nThe following packages will be DOWNGRADED:\n\n  curl                                    7.76.1-hb861fe1_2 --> 7.71.1-hbdca1c0_1\n  dbus                                    1.13.6-ha13b53f_2 --> 1.13.6-h2f22bb5_0\n  expat                                    2.4.1-he49afe7_0 --> 2.2.9-hb1e8313_2\n  hdf4                                    4.2.15-hefd3b78_3 --> 4.2.13-h71d84a9_1004\n  hdf5                           1.10.6-nompi_hc5d9132_1114 --> 1.10.6-nompi_h34ad4e8_1111\n  krb5                                    1.19.1-hcfbf3a7_0 --> 1.17.2-h60d9502_0\n  libblas                                  3.9.0-9_openblas --> 3.8.0-15_openblas\n  libcblas                                 3.9.0-9_openblas --> 3.8.0-15_openblas\n  libcurl                                 7.76.1-hf45b732_2 --> 7.71.1-he6690cf_1\n  libcxx                                  11.1.0-habf9029_0 --> 11.0.0-h4c3b8ed_1\n  libgfortran                       5.0.0-9_3_0_h6c81a4c_22 --> 4.0.0-7_5_0_h1a10cd1_22\n  liblapack                                3.9.0-9_openblas --> 3.8.0-15_openblas\n  libopenblas                      0.3.15-openmp_h5e1b9a4_1 --> 0.3.8-h3d69b6c_0\n  libpng                                  1.6.37-h7cec526_2 --> 1.6.37-h2573ce8_0\n  llvm-openmp                             11.1.0-hda6cdc1_1 --> 11.0.0-h73239a0_1\n  matplotlib                           3.4.2-py37hf985489_0 --> 3.3.3-py37hf985489_0\n  matplotlib-base                      3.4.2-py37hb018525_0 --> 3.3.3-py37hef07623_0\n  openjpeg                                 2.4.0-h6e7aa92_1 --> 2.4.0-h6cbf5cd_0\n  pandas                               1.2.4-py37hb23ed4d_0 --> 1.2.1-py37h010c265_0\n  python                        3.7.10-h7728216_100_cpython --> 3.7.9-h6c3b2c9_0_cpython\n  scipy                                1.6.3-py37h866764c_0 --> 1.5.3-py37h04d6967_0\n  tbb                                     2020.2-h940c156_4 --> 2020.2-h926bf3e_3\nSo it stands to reason that perhaps moose-tools and moose-libmesh are at odds with one another. I'll continue investigating. But again, thank you for bringing this to my attention.",
                          "url": "https://github.com/idaholab/moose/discussions/17094#discussioncomment-787369",
                          "updatedAt": "2022-10-03T13:32:58Z",
                          "publishedAt": "2021-05-26T16:37:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "For reference. On Linux, the following seems to be inconsistent following a moose-tools installation:\nThe following packages will be SUPERSEDED by a higher-priority channel:\n\n  libtiff               pkgs/main::libtiff-4.2.0-h85742a9_0 --> conda-forge::libtiff-4.1.0-hc3755c2_3\n  zstd                     pkgs/main::zstd-1.4.5-h9ceee32_0 --> conda-forge::zstd-1.4.4-h3b9ef0a_2\n\nThe following packages will be DOWNGRADED:\n\n  hdf5                           1.10.6-nompi_h6a2412b_1114 --> 1.10.5-nompi_h5b725eb_1114\n  lcms2                                     2.12-hddcbb42_0 --> 2.11-hcbb858e_1\n  libnetcdf                        4.7.4-nompi_h56d31a8_107 --> 4.6.2-h303dfb8_1003\n  libpng                                  1.6.37-h21135ba_2 --> 1.6.37-hed695b0_0\n  lz4-c                                    1.9.2-he1b5a44_3 --> 1.8.3-he1b5a44_1001\n  openjpeg                                 2.4.0-hb52868f_1 --> 2.4.0-hf7af979_0\n  pillow                               8.2.0-py37h4600e1f_1 --> 8.1.0-py37he6b4880_1\n  vtk                                8.2.0-py37h2bd422c_218 --> 8.2.0-py37hfdee58b_203",
                          "url": "https://github.com/idaholab/moose/discussions/17094#discussioncomment-787498",
                          "updatedAt": "2022-10-03T13:33:03Z",
                          "publishedAt": "2021-05-26T17:12:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sSajjad90"
                  },
                  "bodyText": "Many thanks for your response.  it works, but I got another problem. when I make the application (make -j4) There is the below error:\nIn file included from /home/sajjad/projects/moose/framework/build/unity_src/meshgenerators_Unity.C:25:0:\n/home/sajjad/projects/moose/framework/src/meshgenerators/MeshGenerator.C: In member function 'std::unique_ptrlibMesh::MeshBase MeshGenerator::generateInternal()':\n/home/sajjad/projects/moose/framework/src/meshgenerators/MeshGenerator.C:92:62: error: no matching function for call to 'libMesh::MeshBase::get_info(int)'\nconst auto mesh_info = mesh->get_info(/* verbosity = */ 2);\n^\nIn file included from /home/sajjad/projects/moose/framework/build/header_symlinks/MooseApp.h:26:0,\nfrom /home/sajjad/projects/moose/framework/build/header_symlinks/MeshGenerator.h:14,\nfrom /home/sajjad/projects/moose/framework/build/header_symlinks/SideSetsGeneratorBase.h:12,\nfrom /home/sajjad/projects/moose/framework/build/header_symlinks/AllSideSetsByNormalsGenerator.h:12,\nfrom /home/sajjad/projects/moose/framework/src/meshgenerators/AllSideSetsByNormalsGenerator.C:10,\nfrom /home/sajjad/projects/moose/framework/build/unity_src/meshgenerators_Unity.C:2:\n/home/sajjad/miniconda3/envs/moose/libmesh/include/libmesh/mesh_base.h:1194:15: note: candidate: std::__cxx11::string libMesh::MeshBase::get_info() const\nstd::string get_info () const;\n^~~~~~~~\n/home/sajjad/miniconda3/envs/moose/libmesh/include/libmesh/mesh_base.h:1194:15: note:   candidate expects 0 arguments, 1 provided\nCompiling C++ (in opt mode) /home/sajjad/projects/moose/framework/build/unity_src/executioners_Unity.C...\n/home/sajjad/projects/moose/framework/build.mk:118: recipe for target '/home/sajjad/projects/moose/framework/build/unity_src/meshgenerators_Unity.x86_64-pc-linux-gnu.opt.lo' failed\nmake: *** [/home/sajjad/projects/moose/framework/build/unity_src/meshgenerators_Unity.x86_64-pc-linux-gnu.opt.lo] Error 1\nmake: *** Waiting for unfinished jobs....\nI should mention that I updated conda and moose but I receive this error. would you please let me know how could I fix it?",
                  "url": "https://github.com/idaholab/moose/discussions/17094#discussioncomment-396373",
                  "updatedAt": "2022-10-03T13:33:05Z",
                  "publishedAt": "2021-02-23T06:32:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Performing conda update, or conda install commands should be followed by rebuilding your application after a cleaning. This is due to the library stack possibly getting updated (moose-libmesh was updated, as well as the compiler versions). There a few ways to 'clean' your application:\n\nperform a make clobber all while in your application. Make sure to save (git commit) any changes you may have before doing so. Or:\nperform a git clean -xfd while in the root of your application, and then again while inside the root of the moose directory. Again, making sure to save any changes you may have before doing so.\n\nOnce the above is complete, proceed to building your application.",
                          "url": "https://github.com/idaholab/moose/discussions/17094#discussioncomment-397590",
                          "updatedAt": "2022-10-03T13:33:16Z",
                          "publishedAt": "2021-02-23T14:12:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Testing of external MooseMesh?",
          "author": {
            "login": "aprilnovak"
          },
          "bodyText": "Hi all,\nI'm wondering if there are any built-in classes for testing meshes? I'm wrapping a CFD code through MOOSE's ExternalProblem interface, and I want to write some unit tests to confirm that our NekMesh class works properly.\nThe doc for MooseObjectUnitTest seems to suggest that mesh-based objects like kernels can't be tested this way - does that also apply to the mesh objects themselves? I'm also considering the regression test route, by perhaps creating a new test/src/postprocessor/nElems.C, etc. for all the mesh data I want to check, but I thought the unit test approach could be easier.\nThanks,\n-April",
          "url": "https://github.com/idaholab/moose/discussions/16181",
          "updatedAt": "2022-08-01T21:56:25Z",
          "publishedAt": "2020-11-13T19:47:31Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "Making the unit test work for this will be difficult. What I have done is just create a test UserObject. Register it to your test application. Then you can do whatever crazy checks you want. I often make a MooseEnum that lists out the possible tests and then in constructor or initialSetup have a massive if statement that will check each item. Finally, create an input file and then add a bunch of blocks in your Tests file that hits everything you need.",
                  "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-131147",
                  "updatedAt": "2022-08-01T21:56:26Z",
                  "publishedAt": "2020-11-16T22:46:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "Thanks, that's a good idea - hadn't thought of that! This should be perfect for my needs.",
                          "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-131238",
                          "updatedAt": "2022-08-01T21:56:28Z",
                          "publishedAt": "2020-11-17T01:41:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bielsnohr"
                          },
                          "bodyText": "Apologies for opening an old resolved discussion, but this sounds ideal for facilitating something closer to TDD in my app. Could either of you @aprilnovak @aeslaughter  point to an example of this testing strategy in practice?",
                          "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-776325",
                          "updatedAt": "2022-08-01T21:56:29Z",
                          "publishedAt": "2021-05-24T11:17:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "Hi @bielsnohr, we currently use this UserObject approach in Cardinal, a wrapping of nekRS as a MOOSE application. The repository is private, so I can't point you to a complete example at the moment. But I can try to describe the general approach.\nWe made a NekMeshInfoPostprocessor that inherits from GeneralPostprocessor that we have a MooseEnum to toggle between various things we want to test:\nMooseEnum test_type(\"num_elems num_nodes node_x node_y node_z\");  \nparams.addRequiredParam<MooseEnum>(\"test_type\", test_type, \"The type of evaluation\");\n\nAnd then in getValue(), we just have a large if statement that returns the value we're interested in depending on the enumeration. By downcasting the mesh to our external mesh class we're testing (NekRSMesh), then we can call any of the methods on that external mesh for testing that it's set up correctly.\n_nek_mesh = dynamic_cast<const NekRSMesh *>(&_mesh);\n\nif (_test_type == \"num_elems\")\n  return _nek_mesh->nElem();\nelse if (_test_type == \"num_nodes\")\n  return _nek_mesh->nNodes();\n// ...\n\nThen, in a test, simply add the postprocessors you want to test - save the output file as a gold file, and then those postprocessors will be tested.\n[Postprocessors]\n  [./num_elems]\n    type = NekMeshInfoPostprocessor\n    test_type = num_elems\n  [../]\n  [./num_nodes]\n    type = NekMeshInfoPostprocessor\n    test_type = num_nodes\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-777055",
                          "updatedAt": "2022-08-01T21:56:30Z",
                          "publishedAt": "2021-05-24T14:30:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bielsnohr"
                          },
                          "bodyText": "Brilliant, thank you @aprilnovak for the detailed information. Quick question on implementation: is NekMeshInfoPostprocessor source implemented in the test/ directory, or in the usual location with the rest of the MooseApp?",
                          "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-780285",
                          "updatedAt": "2023-11-06T14:53:00Z",
                          "publishedAt": "2021-05-25T09:46:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "If you will only use your postprocessor for testing, it makes sense to put it in the test/src/postprocessors directory to help differentiate its purpose from other postprocessors in your application. But the choice is up to you, you can also place the postprocessor in src/postprocessors with the other source files of your app",
                          "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-781587",
                          "updatedAt": "2023-11-06T14:53:00Z",
                          "publishedAt": "2021-05-25T14:56:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "I'd also like to note that if you're looking at information like April posted up above, it's worth looking at a test Receiver as well. This'll let you output a ton of mixed type data/maps/etc and run simple diffs on it. We do this in MeshInfo.",
                          "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-781601",
                          "updatedAt": "2022-09-16T18:23:53Z",
                          "publishedAt": "2021-05-25T14:59:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bielsnohr"
                          },
                          "bodyText": "@loganharbour looking at the MOOSE Doxygen, the only stated purpose of the Receiver is to modify the value coming from at PostProcessor. I don't really have a use case for why that is useful. Do you have an example for MeshInfo? A quick search of GitHub suggests this project might be closed source.",
                          "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-782532",
                          "updatedAt": "2022-09-16T18:23:55Z",
                          "publishedAt": "2021-05-25T18:03:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "Gah... I was working on a Receiver object at the time and I typed that poorly. Bad multi tasking! What I should have typed instead is:\n\nI'd also like to note that if you're looking at information like April posted up above, it's worth looking at a test Reporter as well. This'll let you output a ton of mixed type data/maps/etc and run simple diffs on it. We do this in MeshInfo.\n\nMeshInfo is here: https://github.com/idaholab/moose/blob/next/framework/src/reporters/MeshInfo.C\nReporters are a little more complex as they can support arbitrary output in JSON format (which is the primary purpose). Example output is here: https://github.com/idaholab/moose/blob/next/test/tests/reporters/mesh_info/gold/mesh_info_out.json\nThe Reporter is quite a bit more complex because it doesn't just involve scalar values, but it is much more versatile as a result of this. As a whole, we would like to transition more complex output to the Reporter system as a result of this versatility. If you give us an idea of what type of data you would like to output for test purposes, we should be able to pretty quickly tell you how easy of an implementation it would be.",
                          "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-782564",
                          "updatedAt": "2022-09-16T18:23:55Z",
                          "publishedAt": "2021-05-25T18:08:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bielsnohr"
                          },
                          "bodyText": "@loganharbour  not to worry, I'm all to familiar with humans being deficient at concurrency, myself included \ud83d\ude09\nThanks for the offer of advice on my particular use case. Brief summary is that I will be reading scalar values on the elements of a trig mesh from an HDF5 file. The scalar values are held in a 1D array. I want to proceed in a stepwise fashion somewhat like TDD:\n\nwrite test to check array has been read correctly from HDF5, then implement read of array\nwrite test to check array has been mapped correctly into the AuxVariable of the AuxiliarySystem, then implement copy from array to AuxVariable\nwrite test to check integrated value of the AuxVariable\n\nAll of this will be happening within the syncSolutions() method of an ExternalProblem subclass. Hope that is clear.",
                          "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-785902",
                          "updatedAt": "2022-09-16T18:24:15Z",
                          "publishedAt": "2021-05-26T11:57:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "I also think that is appropriate to make a test object that just hard codes the \"gold\" information in the C++. If the data doesn't match throw an error. I even add sucess error messages like \"read of HDF5 passes\" that get thrown if it all worked as expected and setup the test specification to expect that \"error\"",
                          "url": "https://github.com/idaholab/moose/discussions/16181#discussioncomment-786510",
                          "updatedAt": "2022-09-16T18:24:24Z",
                          "publishedAt": "2021-05-26T14:16:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A problem of custom creating an action",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nI customized an action on my APP kunpeng, based on PolycrystalElasticDrivingForceAction, I just changed the file name and the PolycrystalElasticDrivingForceAction in the document to PolycrystalElasticEnergyAction, and there was no problem compiling the app.\nBut when running bicrystal.i where PolycrystalElasticDrivingForce kernel is written as PolycrystalElasticEnergy, the following error occurred,\n*** ERROR ***\n/home/xia/projects/kunpeng/grain_growth/ph_lin/bicrystal.i:79: missing required parameter 'Kernels/PolycrystalElasticEnergy/type'\n\tDoc String: \"A string representing the Moose Object that will be built by this Action\"\n\nI don't know what stupid operations I made to make such a mistake.\nAny suggestions or recommendations to fix these problems would be greatly appreciated.\nThank you\nWei",
          "url": "https://github.com/idaholab/moose/discussions/17921",
          "updatedAt": "2022-06-28T05:24:04Z",
          "publishedAt": "2021-05-25T14:39:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "PengWei97"
                  },
                  "bodyText": "I think I solved this problem by myself.\nThe main problem arises that I need to add a line of code to kunpengAPP.C. The purpose is to customize the grammar in an input file. The details are as follows,\nregisterSyntax(\"PolycrystalElasticEnergyAction\", \"Kernels/PolycrystalElasticEnergy\");\nThanks \ud83d\ude04\nwei",
                  "url": "https://github.com/idaholab/moose/discussions/17921#discussioncomment-784919",
                  "updatedAt": "2022-06-28T05:24:04Z",
                  "publishedAt": "2021-05-26T07:58:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}