{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wMi0xNVQxNTo1NzowOC0wNzowMM4AOzEc"
    },
    "edges": [
      {
        "node": {
          "title": "Possible to build pointy grid surrounded by a pointy hexagon via `Reactor` meshing?",
          "author": {
            "login": "veeshy"
          },
          "bodyText": "I want the outer hexagon to have sides parallel to the inner hexagons, is that possible now or should I open a feature request?\n\n[Mesh]\n  [foo]\n    type = HexagonConcentricCircleAdaptiveBoundaryMeshGenerator\n    num_sectors_per_side = '4 4 4 4 4 4'\n    background_intervals = 2\n    hexagon_size = 2\n    is_control_drum = false\n    ring_radii = '1'\n    ring_intervals = '3'\n  []\n\n  [layout]\n    type = PatternedHexMeshGenerator\n    inputs = 'foo'\n    pattern = '   0 0;\n                 0 0 0;\n                  0 0'\n    hexagon_size = 8\n  []\n[]\n\n[Problem]\n  solve = false\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/20338",
          "updatedAt": "2022-07-12T18:28:46Z",
          "publishedAt": "2022-02-18T00:07:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you please try the pattern_boundary=hexagon option?\nIt s documented here:\nhttps://mooseframework.inl.gov/source/meshgenerators/PatternedHexMeshGenerator.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20338#discussioncomment-2201535",
                  "updatedAt": "2022-07-12T18:29:01Z",
                  "publishedAt": "2022-02-18T02:57:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "veeshy"
                          },
                          "bodyText": "That\u2019s the default so that\u2019s what\u2019s shown already. I also tried the rotate input which rotates the whole mesh and not just the background hex (granted the doc does say it\u2019s for the whole mesh)",
                          "url": "https://github.com/idaholab/moose/discussions/20338#discussioncomment-2201876",
                          "updatedAt": "2022-07-12T18:29:01Z",
                          "publishedAt": "2022-02-18T04:36:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok i understand better what you want now.\nYou could try rotating foo, but doubt that s supported.",
                          "url": "https://github.com/idaholab/moose/discussions/20338#discussioncomment-2202055",
                          "updatedAt": "2022-07-12T18:29:00Z",
                          "publishedAt": "2022-02-18T05:34:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I remember the code to build the outer boundary to be fairly flexible, so if it lets you build the pattern with a rotated unit cell you should be ok for building the boundary",
                          "url": "https://github.com/idaholab/moose/discussions/20338#discussioncomment-2202060",
                          "updatedAt": "2022-07-12T18:29:01Z",
                          "publishedAt": "2022-02-18T05:35:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "veeshy"
                  },
                  "bodyText": "Skimming https://www.osti.gov/biblio/1821454 I don\u2019t think I see any flat hex grid surrounded by a flat hex either",
                  "url": "https://github.com/idaholab/moose/discussions/20338#discussioncomment-2201878",
                  "updatedAt": "2022-07-12T18:29:04Z",
                  "publishedAt": "2022-02-18T04:36:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Contact Question",
          "author": {
            "login": "ats5662"
          },
          "bodyText": "Is there an option in moose to define general contact or self contact? I am looking to run a simulation similar to the picture below. Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/20340",
          "updatedAt": "2022-10-13T18:12:23Z",
          "publishedAt": "2022-02-18T03:25:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Unfortunately, MOOSE does not support self contact at this moment.",
                  "url": "https://github.com/idaholab/moose/discussions/20340#discussioncomment-2201675",
                  "updatedAt": "2022-10-13T18:12:23Z",
                  "publishedAt": "2022-02-18T03:34:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about returnMapping functionality",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "I have a question about the returnMappingSolve class.\nI have a set of residual calculations that will return undefined values when a negative value is introduced by the return mapping solve. Obviously, this breaks the solver and leads to the simulation failing.\nIs there any way to prevent the return mapping from suggesting negative values while not harming the convergence of the return mapping?",
          "url": "https://github.com/idaholab/moose/discussions/20297",
          "updatedAt": "2023-07-10T17:36:53Z",
          "publishedAt": "2022-02-14T20:57:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@jiangwen84 @hugary1995 any of you know about this particular system? Or knows who knows?",
                  "url": "https://github.com/idaholab/moose/discussions/20297#discussioncomment-2183584",
                  "updatedAt": "2023-07-10T17:36:53Z",
                  "publishedAt": "2022-02-15T19:47:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I discussed with @TheGreatCid offline about this. I'm posting here what we discovered in case this is helpful for anyone in the future:\nIn his case, the yield surface is undefined with negative plastic strain rates. The best way to handle this is to let the return mapping algorithm respect the lower bound of zero. There are several ways to achieve this, e.g. line search, trust region, bisection methods, etc. The SingleVariableReturnMappingSolution class in moose offers an interface to provide lower and upper bounds. He simply needs to set _check_range = true; in the constructor and override the method minimumPermissibleValue:\nvirtual Real minimumPermissibleValue(const Real &) const override { return 0; }\nThen the return mapping will make sure values passed into the computeResidual and computeDerivative methods always respect the lower bound.",
                          "url": "https://github.com/idaholab/moose/discussions/20297#discussioncomment-2198909",
                          "updatedAt": "2023-07-10T17:36:53Z",
                          "publishedAt": "2022-02-17T17:45:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@dschwen is working on adding line search to the return mapping. I believe he also mentioned about setting bounds.",
                          "url": "https://github.com/idaholab/moose/discussions/20297#discussioncomment-2199423",
                          "updatedAt": "2023-07-10T17:36:53Z",
                          "publishedAt": "2022-02-17T19:00:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "More accurate stresses and strain are needed for the calculation not just for visualization",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nI have an optimization problem where the gradient is computed as the integral (adjoint_strains x stresses). The stresses and adjoint_strains   are computed through two separate input files. the actual integration required for the gradient computation is carried out in a 3rd separate input file (it is just for post-processing, no need for any solves/factorization). The problem involves point forces (which causes some high stresses concentrations), and since the optimization requires accurate gradient computation, I needed to compute the stresses and strain more accurately (something other than CONSTANT , MONOMIAL). I have tried FIRST MONOMIAL, and I could get better stresses and strains visuals. However, when I upload these stresses and strain into the 3rd input file designated for post-processing, I am getting a segmentation fault (core dumped) message. That 3rd input file (responsible for post-processing) is posted below:\nAny thoughts on how best to compute the gradient of that form? and since this input is only for post-processing, Do I have other computationally cheaper ways to write this input?\n[Mesh]\n        type = GeneratedMesh\n        dim = 2\n        xmin=0\n        xmax=1\n        ymin=0\n        ymax=1\n        nx =100\n        ny=100\n        # displacements = 'uxr uyr uxi uyi'\n[]\n[Variables]\n    [dummy2] #dummy variable, we will not do any solve here, just multiplication, integration, and subtraction.\n    []\n    [dummy3] #dummy variable, we will not do any solve here, just multiplication, integration, and subtraction.\n    []\n[]\n\n[AuxVariables]\n\n    [dummy] #the variable that needed for ComputeVariableIsotropicElasticityTensor \n    []\n    #adjoint solution auxvariables\n    #real stress aux variables\n    [stress_real_xx]\n        order = FIRST\n        family = MONOMIAL\n    []\n    [stress_real_yy]\n        order = FIRST\n        family = MONOMIAL\n    []\n[]\n\n[Kernels]\n    [urealx]\n        type = StressDivergenceTensors\n        variable = dummy2\n        displacements='dummy2 dummy3'\n        component = 0\n        base_name = real\n        #volumetric_locking_correction=True\n    []\n    [urealy]\n        type = StressDivergenceTensors\n        variable = dummy3\n        displacements='dummy2 dummy3'\n        component = 1\n        base_name = real\n        #volumetric_locking_correction=True\n    []\n[]\n\n[AuxKernels]\n    [load_strain_real_xx]#used to reload the adjoint solution from old exudos file resulted from the adjoint solves\n        type = SolutionAux\n        solution = sln_strain_real_xx\n        variable = strain_real_xx\n        direct = true\n    []\n    [load_strain_real_yy]#used to reload the adjoint solution from old exudos file resulted from the adjoint solves\n        type = SolutionAux\n        solution = sln_strain_real_yy\n        variable = strain_real_yy\n        direct = true\n    []\n[]\n\n[UserObjects]\n\n    #load stresses from the forward solve\n    [sln_stress_real_xx]\n      type = SolutionUserObject\n      mesh = '_forward_elastic_waves/forwardsolve.e'\n      system_variables = stress_real_xx\n    []\n    [sln_stress_real_yy]\n      type = SolutionUserObject\n      mesh = '_forward_elastic_waves/forwardsolve.e'\n      system_variables = stress_real_yy\n    []                               \n[]\n\n[Outputs]\n    [exodus]\n        file_base = 'grad_computation_elastic_waves/grad_'\n        type = Exodus\n        execute_on = final\n    []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/19656",
          "updatedAt": "2022-08-18T12:43:57Z",
          "publishedAt": "2021-12-16T22:01:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere's a lot going on here. Could you please remove what's not needed and update the post? You can just set solve=false in the [Problem] to not do a solve, no need for dummy variables.\nWhere is the seg fault happening exactly? Could you please wrap this in a debugger and get us a back trace?\nIf there is a problem with a high variable order that is not supported by some auxkernel or transfer, then recompiling in devel mode (METHOD=devel make) is very likely to catch this.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19656#discussioncomment-2084096",
                  "updatedAt": "2022-08-18T12:44:07Z",
                  "publishedAt": "2022-01-31T19:22:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "@aaelmeli  did you find the problem?  Where did it segfault, is it when it tries to read the data in with the userObject or when you compute one of the auxkernels?  Is the data being read in first monomial data?",
                          "url": "https://github.com/idaholab/moose/discussions/19656#discussioncomment-2184865",
                          "updatedAt": "2022-08-18T12:44:07Z",
                          "publishedAt": "2022-02-16T00:17:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Hi @lynnmunday\nObviously, I missed @GiudGiud reply, really sorry for that.\nSo the following is the output when running on the devel mode.\nAssertion `sys_elem.n_dofs(sys_num, var_num) > 0' failed\nVariable strain_real_xx has no DoFs on element 0\nat /home/aaelmeli/projects/moose/framework/src/userobject/SolutionUserObject.C, line 404\nStack frames: 30\n0: libMesh::print_trace(std::ostream&)\n1: SolutionUserObject::directValue(libMesh::Elem const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const\n2: SolutionAux::computeValue()\n3: AuxKernelTempl<double>::compute()\n4: ComputeElemAuxVarsThread<AuxKernelTempl<double> >::onElement(libMesh::Elem const*)\n5: ThreadedElementLoopBase<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> >::operator()(libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> const&, bool)\n6: void AuxiliarySystem::computeElementalVarsHelper<AuxKernelTempl<double> >(MooseObjectWarehouse<AuxKernelTempl<double> > const&, std::vector<std::vector<MooseVariableFieldBase*, std::allocator<MooseVariableFieldBase*> >, std::allocator<std::vector<MooseVariableFieldBase*, std::allocator<MooseVariableFieldBase*> > > > const&)\n7: AuxiliarySystem::computeElementalVars(MooseEnumItem)\n8: AuxiliarySystem::compute(MooseEnumItem)\n9: FEProblemBase::computeResidualTags(std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n10: FEProblemBase::computeResidualInternal(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n11: FEProblemBase::computeResidualSys(libMesh::NonlinearImplicitSystem&, libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&)\n12: ComputeResidualFunctor::residual(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, libMesh::NonlinearImplicitSystem&)\n13: libmesh_petsc_snes_residual\n14: SNESComputeFunction\n15: /home/aaelmeli/miniconda3/envs/moose/lib/libpetsc.so.3.15(+0xd22bdb) [0x7f0650782bdb]\n16: SNESSolve\n17: libMesh::PetscNonlinearSolver<double>::solve(libMesh::SparseMatrix<double>&, libMesh::NumericVector<double>&, libMesh::NumericVector<double>&, double, unsigned int)\n18: libMesh::NonlinearImplicitSystem::solve()\n19: NonlinearSystem::solve()\n20: FEProblemBase::solve()\n21: FEProblemSolve::solve()\n22: FixedPointSolve::solveStep(double&, double&, std::set<unsigned long, std::less<unsigned long>, std::allocator<unsigned long> > const&)\n23: FixedPointSolve::solve()\n24: Steady::execute()\n25: MooseApp::executeExecutioner()\n26: MooseApp::run()\n27: ./first_test-devel(+0x3153) [0x7f065760b153]\n28: __libc_start_main\n29: ./first_test-devel(+0x33dd) [0x7f065760b3dd]\n[0] /home/aaelmeli/projects/moose/framework/src/userobject/SolutionUserObject.C, line 404, compiled Feb 15 2022 at 21:17:02\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure: Bad file descriptor\n\nSo, I think the error happened when loading the data from the exodus file through the solutionuserobject. In fact, when playing around this, I found this link, where in notes, it is written that exodus does not support higher-order elemental variables \"more than CONSTANT MONOMIAL\".",
                          "url": "https://github.com/idaholab/moose/discussions/19656#discussioncomment-2185504",
                          "updatedAt": "2022-08-18T12:44:07Z",
                          "publishedAt": "2022-02-16T03:08:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "I don't know if this would work but maybe you can oversample your output mesh (test/tests/outputs/oversample/over_sampling_test_gen.i) and then read it in on a finer mesh with constant monomial onto a finer mesh.  Maybe the solutionFunction can be used to interpolate the oversampled output mesh onto higher order element variable. I don't see any tests for this.\nAnother option would be to output your element variables as nodal variables using the nodalPatchRecovery and then do you calculations on nodal variables in the above file.",
                          "url": "https://github.com/idaholab/moose/discussions/19656#discussioncomment-2198804",
                          "updatedAt": "2022-08-18T12:45:40Z",
                          "publishedAt": "2022-02-17T17:31:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Spatially-dependent timestep size",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "I'm currently in a meeting where someone mentioned their software could use spatially-dependent timestep size.  Eg, if nothing-much is happening in a certain domain, then why not take large timesteps there?  Has anyone thought about doing this with MOOSE?\nandy",
          "url": "https://github.com/idaholab/moose/discussions/20320",
          "updatedAt": "2022-09-13T19:00:25Z",
          "publishedAt": "2022-02-16T20:37:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFor a per-domain granularity:\nSeems like something we ll be able to do when we support multi-system. First we are reworking the Executioner system to allow arbitrary chaining (see the Executor system), then we will look at multi-system.\nFor a per-element granularity of the time & timestep,\nI dont think that s planned. Could be interesting but seems like a headache to keep track of time everywhere and always be interpolating.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20320#discussioncomment-2191591",
                  "updatedAt": "2022-09-13T19:00:25Z",
                  "publishedAt": "2022-02-16T20:42:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Saturation Issue with NeumannBC in Cahn-Hilliard",
          "author": {
            "login": "ashwinshekhar21"
          },
          "bodyText": "Hello,\nWe are attempting to modify the tutorial code for the spinodal decomposition of the Cr-Fe alloy provided with MOOSE. We start with a somewhat homogeneous initial concentration of a value less than that required for spinodal decomposition.\nOur objective is to induce the spinodal decomposition locally, by imposing a flux on the left boundary, such that the concentration gradually shifts towards the right in the double-well delG vs concentration curve, inducing the decomposition into an advancing front of c=0.8 Cr followed by the rest being ~0.2 Cr.\n\nOver time, we expected one of the decomposition product phases (orange in our output, Cr mol = ~0.8), to grow and progressively occupy a larger fraction. However, it saturates after a certain number of timesteps and it is not clear why this happens. For instance, here, this configuration is attained relatively early in the simulation, and nothing happens until the simulation ends:\n\n  \n    \n    \n\n    op035.mp4\n    \n  \n\n  \n\n  \n\n\nThis does not appear to depend on the length of the simulation either (same result even if we run for t=280 weeks etc.). We are implementing periodic boundary conditions in the y-direction, and imposing NeumannBC value = 1e-5 on the left and = 0 on the right. Our initial concentration is approximately 0.35 mol Cr (RandomIC, variation from 0.34-0.36).\nHere is our code:\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  elem_type = QUAD4\n  nx = 25\n  ny = 25\n  nz = 0\n  xmin = 0\n  xmax = 25\n  ymin = 0\n  ymax = 25\n  zmin = 0\n  zmax = 0\n  uniform_refine = 2\n[]\n\n[Variables]\n  [./c]   # Mole fraction of Cr (unitless)\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./w]   # Chemical potential (eV/mol)\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n[ICs]\n  [./concentrationIC]   # 35 wt% Cr with variations\n    type = RandomIC\n    min = 0.34\n    max = 0.36\n    seed = 210\n    variable = c\n  [../]\n[]\n\n[BCs]\n  [./Periodic]\n    [./c_bcs]\n      auto_direction = 'y'\n    [../]\n  [../]\n  [./left]\n    type = NeumannBC\n    variable = c\n    boundary = left\n    value = 1e-5\n  [../]\n  [./left]\n    type = NeumannBC\n    variable = c\n    boundary = right\n    value = 0\n  [../]\n[]\n\n[Kernels]\n  [./w_dot]\n    variable = w\n    v = c\n    type = CoupledTimeDerivative\n  [../]\n  [./coupled_res]\n    variable = w\n    type = SplitCHWRes\n    mob_name = M\n  [../]\n  [./coupled_parsed]\n    variable = c\n    type = SplitCHParsed\n    f_name = f_loc\n    kappa_name = kappa_c\n    w = w\n  [../]\n[]\n\n[Materials]\n  [./constants]\n    type = GenericFunctionMaterial\n    prop_names = 'kappa_c M'\n    prop_values = '8.125e-16*6.24150934e+18*1e+09^2*1e-27\n                   2.2841e-26*1e+09^2/6.24150934e+18/1e-27'\n                   # kappa_c*eV_J*nm_m^2*d\n                   # M*nm_m^2/eV_J/d\n  [../]\n  [./local_energy]\n    type = DerivativeParsedMaterial\n    f_name = f_loc\n    args = c\n    constant_names = 'A   B   C   D   E   F   G  eV_J  d'\n    constant_expressions = '-2.446831e+04 -2.827533e+04 4.167994e+03 7.052907e+03\n                            1.208993e+04 2.568625e+03 -2.354293e+03\n                            6.24150934e+18 1e-27'\n    function = 'eV_J*d*(A*c+B*(1-c)+C*c*log(c)+D*(1-c)*log(1-c)+\n                E*c*(1-c)+F*c*(1-c)*(2*c-1)+G*c*(1-c)*(2*c-1)^2)'\n    derivative_order = 2\n  [../]\n[]\n\n[Postprocessors]\n  [./step_size]          \n    type = TimestepSize\n  [../]\n  [./iterations]          \n    type = NumNonlinearIterations\n  [../]\n  [./nodes]                \n    type = NumNodes\n  [../]\n  [./evaluations]           \n    type = NumResidualEvaluations\n  [../]\n  [./active_time]          \n    type = PerfGraphData\n    section_name = \"Root\"\n    data_type = total\n  [../]\n[]\n\n[Preconditioning]\n  [./coupled]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  l_max_its = 30\n  l_tol = 1e-6\n  nl_max_its = 50\n  nl_abs_tol = 1e-9\n  end_time = 16934400   # 7*28 days\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_ksp_type\n                         -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'asm      31                  preonly\n                         ilu          1'\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 10\n    cutback_factor = 0.8\n    growth_factor = 1.5\n    optimal_iterations = 7\n  [../]\n  [./Adaptivity]\n    coarsen_fraction = 0.1\n    refine_fraction = 0.7\n    max_h_level = 2\n  [../]\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\n[Outputs]\n  exodus = true\n  console = true\n  [./console]\n    type = Console\n    max_rows = 10\n  [../]\n[]\n\nIs there any reason for this apparent \"saturation\", and is there any way to rectify it such that the transition continues to grow? Such that the orange portion in our simulation box eventually occupies the entire area?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/20308",
          "updatedAt": "2022-06-22T07:33:07Z",
          "publishedAt": "2022-02-15T18:51:07Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ykvishal"
                  },
                  "bodyText": "Interesting issue.\nIf you replace your initial condition by following then what will happen?\n[ICs]\n  [./concentrationIC] \n     type = BoundingBoxIC\n     x1 = 0\n     y1 = 0\n     x2 = 20\n     y2 = 25\n     inside = 0.823659\n     outside = 0.236248\n    variable = c\n  [../]\n[]\n\nyou can vary x2 from 5 to 20 and comment out  end_time = 16934400",
                  "url": "https://github.com/idaholab/moose/discussions/20308#discussioncomment-2186690",
                  "updatedAt": "2022-06-22T07:33:10Z",
                  "publishedAt": "2022-02-16T08:04:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashwinshekhar21"
                          },
                          "bodyText": "Thank you for your response.\nSo we tried out the above modifications, as suggested. The resulting output is as follows (showing here for x2 = 15, although this is emblematic, as all the x2 values result in similar behaviour):\n\n  \n    \n    \n\n    x2_15.mp4\n    \n  \n\n  \n\n  \n\n\nThe relative fraction of the two phases remains unchanged. The only observable change is the establishment of a diffuse interface, but that's to be expected.",
                          "url": "https://github.com/idaholab/moose/discussions/20308#discussioncomment-2187471",
                          "updatedAt": "2022-06-22T07:33:10Z",
                          "publishedAt": "2022-02-16T10:20:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ykvishal"
                          },
                          "bodyText": "This suggests that interface won't move after reaching to equilibrium concertation from common tangent construction. It seems that MOOSE is doing fine. I may be wrong, but the issue is related to your problem definition. If you change value = 1e-5 to value = 1e-3 or value = 1e-1 then it may not converge after reaching equilibrium concentration.",
                          "url": "https://github.com/idaholab/moose/discussions/20308#discussioncomment-2190892",
                          "updatedAt": "2022-06-22T07:33:10Z",
                          "publishedAt": "2022-02-16T18:37:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the coordinates of mesh nodes after deformation",
          "author": {
            "login": "BihengX"
          },
          "bodyText": "Hello, MOOSE\nI am using MOOSE to do the calculation of thermal expansion of reactor fuel.  However, I need to extract the node coordinates at certain boundaries and specific sidesets for the fuel geometry after thermal mechanical coupling calculation, which can be used as a basis for other calculations. For example, I need the average height of the fuel rod top surface after deformation from the node coordinates.\nI would like to know how to export this coordinate information in post-processing. Thank you very much!",
          "url": "https://github.com/idaholab/moose/discussions/20293",
          "updatedAt": "2022-12-11T16:25:19Z",
          "publishedAt": "2022-02-12T01:35:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "BihengX"
                  },
                  "bodyText": "I just found NodalValueSampler that can output boundary node coordinates, which seems to solve my problem. It is right that I use this coordinates information?   Thank you so much!",
                  "url": "https://github.com/idaholab/moose/discussions/20293#discussioncomment-2161708",
                  "updatedAt": "2022-12-11T16:25:19Z",
                  "publishedAt": "2022-02-12T03:01:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nNodalValueSampler will output information at nodes, and will indeed preface the information with the x,y,z coordinates.\nSo this should work for you.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/20293#discussioncomment-2169640",
                          "updatedAt": "2022-12-11T16:25:19Z",
                          "publishedAt": "2022-02-13T23:44:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BihengX"
                          },
                          "bodyText": "Thank you very much! This is very helpful.",
                          "url": "https://github.com/idaholab/moose/discussions/20293#discussioncomment-2186741",
                          "updatedAt": "2023-01-12T22:19:25Z",
                          "publishedAt": "2022-02-16T08:13:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Oh I just saw you wanted after deformation.\nCould you please execute the VPP on initial and during the problem to check that it s returning the deformed coordinates?\nadd this parameter:\nExecute_on = \u201cinitial timestep_end\u201d",
                          "url": "https://github.com/idaholab/moose/discussions/20293#discussioncomment-2189295",
                          "updatedAt": "2023-01-12T22:19:25Z",
                          "publishedAt": "2022-02-16T15:03:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Computing Current Density Over an Interface",
          "author": {
            "login": "jsevic"
          },
          "bodyText": "I have a 2-D model of a thin-film dielectric stack with top and bottom ohmic contacts and I wish to compute the total current over either contact. Do I need to define an auxiliary variable, say J(x,y,t), from E(x,y,t) * sigma_electrical(x,y,t) and then perform an integration over either one of the contacts, say over x for fixed y? Is the integration something I can do in a post-processing step or would it too be an auxiliary variable?\nThank you!\nJohn Sevic",
          "url": "https://github.com/idaholab/moose/discussions/20280",
          "updatedAt": "2023-05-19T04:02:34Z",
          "publishedAt": "2022-02-11T01:43:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nA total current seems like the job for a postprocessor.\nWhether you start from J = E * sigma or whether you provide E and sigma for the integration depends on your preferences. I suspect if you use J you ll be able to use an existing SideIntegration postprocessor\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20280#discussioncomment-2169669",
                  "updatedAt": "2023-11-11T16:30:22Z",
                  "publishedAt": "2022-02-13T23:55:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jsevic"
                  },
                  "bodyText": "Ok cool let me try thx!\n\nJohn Sevic\n\u2026\nSent from my iPhone\n On Feb 13, 2022, at 4:56 PM, Guillaume Giudicelli ***@***.***> wrote:\n\n \ufeff\n Hello\n\n A total current seems like the job for a postprocessor.\n Whether you start from J = E * sigma or whether you provide E and sigma for the integration depends on your preferences. I suspect if you use J you ll be able to use an existing SideIntegration postprocessor\n\n Guillaume\n\n \u2014\n Reply to this email directly, view it on GitHub, or unsubscribe.\n Triage notifications on the go with GitHub Mobile for iOS or Android.\n You are receiving this because you authored the thread.",
                  "url": "https://github.com/idaholab/moose/discussions/20280#discussioncomment-2170001",
                  "updatedAt": "2023-11-11T16:30:24Z",
                  "publishedAt": "2022-02-14T01:45:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jsevic"
                  },
                  "bodyText": "Another question related to this.\n\nI recall on an earlier simulation I did, I used an auxiliary kernel to compute electrical conductivity based on the product mobility and charge density and electron charge.\n\nIf I define electrical conductivity presently using a ParsedMaterial, and call this sigma_e, is there a way to pass this sigma_e to the Exodus output so I can plot it? I used AuxKernal for this before.\n\nThx!\n\u2026\n On Feb 13, 2022, at 4:56 PM, Guillaume Giudicelli ***@***.***> wrote:\n\n\n Hello\n\n A total current seems like the job for a postprocessor.\n Whether you start from J = E * sigma or whether you provide E and sigma for the integration depends on your preferences. I suspect if you use J you ll be able to use an existing SideIntegration postprocessor\n\n Guillaume\n\n \u2014\n Reply to this email directly, view it on GitHub <#20280 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ABD6MBQW6GSWM64ZBAY6EGTU3BAJHANCNFSM5OCWS5UA>.\n Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n You are receiving this because you authored the thread.",
                  "url": "https://github.com/idaholab/moose/discussions/20280#discussioncomment-2185078",
                  "updatedAt": "2023-11-11T16:30:30Z",
                  "publishedAt": "2022-02-16T01:11:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "From a ParsedMaterial you can output to exodus with this\nhttps://mooseframework.inl.gov/source/auxkernels/MaterialRealAux.html",
                          "url": "https://github.com/idaholab/moose/discussions/20280#discussioncomment-2185762",
                          "updatedAt": "2023-11-11T16:30:31Z",
                          "publishedAt": "2022-02-16T03:47:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "or you can specify the output parameter of the parsedmaterial to the exodus output",
                          "url": "https://github.com/idaholab/moose/discussions/20280#discussioncomment-2185763",
                          "updatedAt": "2023-11-11T16:30:33Z",
                          "publishedAt": "2022-02-16T03:48:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jsevic"
                  },
                  "bodyText": "Ok I will try I also tried AuxVariable and AuxKernel and this seemed to work too.\n\u2026\nSent from my iPhone\n On Feb 15, 2022, at 8:48 PM, Guillaume Giudicelli ***@***.***> wrote:\n\n \ufeff\n From a ParsedMaterial you can output to exodus with this\n https://mooseframework.inl.gov/source/auxkernels/MaterialRealAux.html\n\n \u2014\n Reply to this email directly, view it on GitHub, or unsubscribe.\n Triage notifications on the go with GitHub Mobile for iOS or Android.\n You are receiving this because you authored the thread.",
                  "url": "https://github.com/idaholab/moose/discussions/20280#discussioncomment-2188109",
                  "updatedAt": "2023-11-11T16:30:33Z",
                  "publishedAt": "2022-02-16T12:10:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "structure mechanic analysis using moose",
          "author": {
            "login": "tjumsl"
          },
          "bodyText": "I try to find an alternative structure analysis application to the commercial software NASTRAN. Moose seems to be very promising.\nMy main analysis area is using plate/shell/beam elements for airframe structures, including linear / non-linear / buckling / modal anlaysis / frequency response etc. I asssume Moose should be able to do this, is that correct?",
          "url": "https://github.com/idaholab/moose/discussions/20285",
          "updatedAt": "2022-07-23T05:52:27Z",
          "publishedAt": "2022-02-11T06:21:57Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe dont have modal analysis\nWe have some capabilities for frequency response though they may be in MASTODON, @cbolisetti will know the most about this.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2169658",
                  "updatedAt": "2022-07-23T05:52:54Z",
                  "publishedAt": "2022-02-13T23:51:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ats5662"
                  },
                  "bodyText": "If MOOSE doesn't have what you're looking for try openCFS",
                  "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2184334",
                  "updatedAt": "2022-07-23T05:52:54Z",
                  "publishedAt": "2022-02-15T22:17:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tjumsl"
                          },
                          "bodyText": "If MOOSE doesn't have what you're looking for try openCFS\n\nThanks for the kind suggestion. For OpenCFS, do you know whehter it can conver the structure areas I mentioned above?\nI quickly checked the website, it seems the tutorial examples are mainly on acoustic aspects.",
                          "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2185694",
                          "updatedAt": "2022-07-23T05:52:54Z",
                          "publishedAt": "2022-02-16T03:30:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ats5662"
                          },
                          "bodyText": "Yeah, I use openCFS for acoustic simulations, so I am not very familiar with its structural dynamics capabilities. I know they exist though - check out these resources\nopenCFS YouTube tutorials\nCantilever beam eigenfrequency example\nSinglefield mechanics testsuit",
                          "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2185756",
                          "updatedAt": "2022-07-23T05:52:54Z",
                          "publishedAt": "2022-02-16T03:46:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tjumsl"
                          },
                          "bodyText": "Yeah, I use openCFS for acoustic simulations, so I am not very familiar with its structural dynamics capabilities. I know they exist though - check out these resources\nopenCFS YouTube tutorials Cantilever beam eigenfrequency example Singlefield mechanics testsuit\n\nThanks, I will check the materials and reach the openCFS team for further confirmation.",
                          "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2185792",
                          "updatedAt": "2022-07-23T05:52:54Z",
                          "publishedAt": "2022-02-16T03:56:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "oldninja"
                          },
                          "bodyText": "Another one is CalculiX . The only issue is that plate/shell/beam elements are expanded internally into brick elements. But it can do linear, non-linear (material and contact), buckling, modal, and freq. response.",
                          "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2185962",
                          "updatedAt": "2022-09-28T08:31:26Z",
                          "publishedAt": "2022-02-16T04:47:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cbolisetti"
                  },
                  "bodyText": "@tjumsl, you can use MOOSE for several mechanics applications but it's still not at the extent of traditional structural engineering software. We have plate/beam/shell elements, but we cannot model nonlinearities yet. Also, we don't have Eigen value analysis merged into MOOSE. If you are looking to use solid elements or stay in the linear range, MOOSE is great for large problems and multiphysics applications.",
                  "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2184400",
                  "updatedAt": "2022-07-23T05:52:54Z",
                  "publishedAt": "2022-02-15T22:28:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tjumsl"
                          },
                          "bodyText": "@tjumsl, you can use MOOSE for several mechanics applications but it's still not at the extent of traditional structural engineering software. We have plate/beam/shell elements, but we cannot model nonlinearities yet. Also, we don't have Eigen value analysis merged into MOOSE. If you are looking to use solid elements or stay in the linear range, MOOSE is great for large problems and multiphysics applications.\n\nOK, i see. Many thanks for the kind response. How about XFEM crack propergation? Is it possible for MOOSE to carry out complicate crack propergation analysises? Solid elements will be used in most cases.",
                          "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2185727",
                          "updatedAt": "2022-07-23T05:52:54Z",
                          "publishedAt": "2022-02-16T03:38:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "What do you mean by complicated crack propagation?  MOOSE XFEM can do certain 2D and 3D crack propagation modeling. Branching or merging is not well supported.",
                          "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2185759",
                          "updatedAt": "2022-07-23T05:52:54Z",
                          "publishedAt": "2022-02-16T03:47:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tjumsl"
                          },
                          "bodyText": "What do you mean by complicated crack propagation? MOOSE XFEM can do certain 2D and 3D crack propagation modeling. Branching or merging is not well supported.\n\nI am trying to use XFEM as an alternative tools to the commercial software Franc3D, do you think this would be possible?",
                          "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2185788",
                          "updatedAt": "2022-07-23T05:52:54Z",
                          "publishedAt": "2022-02-16T03:55:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Does Franc3D support XFEM? If you are comfortable with writing some codes, MOOSE will provide you much more flexibility. If you are a primary commercial code user, I guess Franc3D would be a better choice.",
                          "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2185873",
                          "updatedAt": "2022-07-23T05:53:16Z",
                          "publishedAt": "2022-02-16T04:18:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tjumsl"
                          },
                          "bodyText": "Does Franc3D support XFEM? If you are comfortable with writing some codes, MOOSE will provide you much more flexibility. If you are a primary commercial code user, I guess Franc3D would be a better choice.\n\nFranc3D ultilized traditional FEM methods which needs a lot of meshing work. I am willing to write some codes and will dig into more details of MOOSE XFEM.",
                          "url": "https://github.com/idaholab/moose/discussions/20285#discussioncomment-2185968",
                          "updatedAt": "2022-07-23T05:53:17Z",
                          "publishedAt": "2022-02-16T04:50:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Generate sideset and nodeset for the intersection of the subdomains",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE Experts\nI am importing the Abaqus mesh file in the MOOSE. There is a number of subdomains in it.\nIs it possible to generate the NODESETS for the nodes that are at the intersection between subdomains? Also, I want to generate the SIDESET of the outer boundary of the entire domain.\nPlease guide me through it. I shall be very thankful.\nBest\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/20310",
          "updatedAt": "2022-08-26T07:16:22Z",
          "publishedAt": "2022-02-15T20:07:56Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSee the mesh generators for generating sidesets, notably these two:\nhttps://mooseframework.inl.gov/source/meshgenerators/SideSetsBetweenSubdomainsGenerator.html\nhttps://mooseframework.inl.gov/source/meshgenerators/SideSetsAroundSubdomainGenerator.html\nAnd see the options in this page to generate nodesets from sidesets:\nhttps://mooseframework.inl.gov/source/mesh/MooseMesh.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20310#discussioncomment-2183709",
                  "updatedAt": "2022-08-26T07:16:22Z",
                  "publishedAt": "2022-02-15T20:11:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What is the domain outer boundary? If continuous, might be easier to just use that one for the outer boundary\nhttps://mooseframework.inl.gov/source/meshgenerators/SideSetsFromNormalsGenerator.html",
                          "url": "https://github.com/idaholab/moose/discussions/20310#discussioncomment-2183724",
                          "updatedAt": "2022-08-26T07:16:22Z",
                          "publishedAt": "2022-02-15T20:14:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Hello @GiudGiud\nIt is multiple 3d grains intersecting each other.",
                          "url": "https://github.com/idaholab/moose/discussions/20310#discussioncomment-2183938",
                          "updatedAt": "2022-08-26T07:16:46Z",
                          "publishedAt": "2022-02-15T20:58:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Hello @GiudGiud\nI am trying the following\nhttps://mooseframework.inl.gov/source/meshgenerators/SideSetsBetweenSubdomainsGenerator.html\nBut I do not have the information that the given subdomain is surrounded by how many and which subdomains.\nI think in this way, I cannot able to find all the intersection Nodesets once. For this, I need to apply it for individual subdomains. Correct me if I am wrong.\nBest\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/20310#discussioncomment-2183987",
                          "updatedAt": "2022-08-26T07:16:46Z",
                          "publishedAt": "2022-02-15T21:09:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can list one primary and all the other blocks in paired_block to be sure (you ll have to list them), even if they dont touch\nOr you can use https://mooseframework.inl.gov/source/meshgenerators/SideSetsAroundSubdomainGenerator.html\nif you just want to have what s around one grain.",
                          "url": "https://github.com/idaholab/moose/discussions/20310#discussioncomment-2184535",
                          "updatedAt": "2022-12-12T17:01:30Z",
                          "publishedAt": "2022-02-15T22:57:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}