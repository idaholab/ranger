{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wOS0yOVQwNjozNTozOS0wNjowMM4AATVs"
    },
    "edges": [
      {
        "node": {
          "title": "MOOSE on Xsede",
          "author": {
            "login": "mamivand"
          },
          "bodyText": "Hello MOOSE users,\nJust wondering if anyone has experience in running MOOSE on Xsede machines? Any recommendation for machine selection?\nThanks,\nMahmood Mamivand",
          "url": "https://github.com/idaholab/moose/discussions/18997",
          "updatedAt": "2022-08-18T13:09:46Z",
          "publishedAt": "2021-10-04T18:37:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI have not. Let s see if someone pitches in.\n@friedmud have you heard of anyone?\nWith regards to machine selection, pick something that has:\n\nCPUs with lots of cores\nenough memory for your application\nan infiniband network or similar if you are going to use more than one node. You want small latencies between your compute nodes, as there can be quite a bit of data transfers between processes, depending on your application\nsupport modern gcc/mpi etc so you dont have to deal with older versions\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18997#discussioncomment-1427433",
                  "updatedAt": "2022-08-18T13:09:46Z",
                  "publishedAt": "2021-10-05T00:15:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "I mean - XSEDE is a program, not a machine.  I've used XSEDE a couple of times in the past for running on the Blue Gene machines at ANL.\n@GiudGiud is right... you want something with lots of CPU cores.  GPU won't do anything for you with MOOSE at this point.\nIs there a particular machine you're interested in?",
                          "url": "https://github.com/idaholab/moose/discussions/18997#discussioncomment-1430880",
                          "updatedAt": "2022-08-18T13:09:46Z",
                          "publishedAt": "2021-10-05T15:25:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mamivand"
                          },
                          "bodyText": "Derek and Guillaume,\nThanks for your response.\nThrough XSEDE I can request access to machines that are under XSEDE. I wanted to check if anyone has experience in running MOOSE on any of them. Since MOOSE uses Conda, I think my concern regarding MOOSE compatibility with different clusters is not relevant. I am aiming for Jetstream2 Indiana University .\nMahmood",
                          "url": "https://github.com/idaholab/moose/discussions/18997#discussioncomment-1432410",
                          "updatedAt": "2022-08-18T13:09:51Z",
                          "publishedAt": "2021-10-05T21:18:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "@mamivand : you won't want to use Conda on the clusters though.  You will need to compile a custom version of MOOSE using the cluster's compilers and MPI stack.\nMOOSE from Conda is just for workstations.\nYou will want to follow our HPC setup instructions here: https://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html",
                          "url": "https://github.com/idaholab/moose/discussions/18997#discussioncomment-1433004",
                          "updatedAt": "2022-08-18T13:09:57Z",
                          "publishedAt": "2021-10-06T01:26:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Nested Mesh Interaction",
          "author": {
            "login": "klaw13"
          },
          "bodyText": "Hi there,\nI'm trying to simulate the flow of water inside a cavity flowing inside the red volume. As the water flows throughout the cavity, the pressure from the flow should be able to push on the mesh boundary to move it. If the force is large\nenough, both the outer and inner volumes should become cylinders.\n\ninput file: input.i.txt )\nI initially tried to just simulate the flow of the water inside the cavity without considering any deformations to the mesh. When I run the simulation, I can get the water to flow about half way through, but then the simulation fails to converge.\nI thought it might be because I need to take into consideration the effects on the mesh, so I  tried to base my approach on the 3D_struc_acoustic.i example, and added in kernels to handle the convected mesh.\nHowever, I have not been able to converge at any timestep. Currently, I'm getting the following error:\n*** ERROR *** MooseVariableFE: Old time derivative of solution (u_dot_old) is not stored. Please set uDotOldRequested() to true in FEProblemBase before requesting u_dot_old.",
          "url": "https://github.com/idaholab/moose/discussions/18267",
          "updatedAt": "2022-07-08T00:11:49Z",
          "publishedAt": "2021-07-06T13:49:44Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe effect on the mesh should be a sufficiently different issue that you should try to get a resolved solution without modeling this effect first.\nOnce you get a good solution without the fluid structure interaction, @somu15 should be able to help with that error message, which I assume is related to a FSI kernel\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-971357",
                  "updatedAt": "2022-07-08T00:11:49Z",
                  "publishedAt": "2021-07-06T17:55:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "somu15"
                          },
                          "bodyText": "Hi @klaw13. As @GiudGiud suggested, try and resolve the problem without FSI. With the FSI, it is important how you define the element and neighbor boundaries when setting the sidesets. I will provide more information once you let me know you have resolved your issue without FSI. Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-971378",
                          "updatedAt": "2022-07-08T00:11:49Z",
                          "publishedAt": "2021-07-06T18:01:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Thanks @GiudGiud.\nHi @somu15\nSo my convergence issue seems to be due to the values I have set in the parameters of my executioner block  - so establishing the flow of water was not my issue. However, I'm still running into the same error when I try to incorporate FSI with the mesh:\n*** ERROR *** MooseVariableFE: Old time derivative of solution (u_dot_old) is not stored. Please set uDotOldRequested() to true in FEProblemBase before requesting u_dot_old.\nTaking a look at a simpler problem, I tried to modify the fsi_flat_channel.i example within the MOOSE repo: simplified.i.txt\nI added the following to the kernels\n\n[./diffusion]\ntype = Diffusion\nvariable = 'p'\nblock = 0\n[../]\n[./inertia]\ntype = AcousticInertia\nvariable = p\nblock = 0\n[../]\n[./DynamicTensorMechanics]\ndisplacements = 'disp_x disp_y'\nblock = 1\n[../]\n\nand then changed the InterfaceKernels block from using CoupledPenaltyInterfaceDiffusion to instead use the StructureAcousticInterface module. This input file setup also results in the same error regardless of the interface kernel I choose.",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1001457",
                          "updatedAt": "2022-07-08T00:11:51Z",
                          "publishedAt": "2021-07-14T00:11:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Do you have a working fluid-flow only simulation now?\n@somu15 for the variable error",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1048161",
                          "updatedAt": "2022-07-08T00:11:56Z",
                          "publishedAt": "2021-07-25T20:50:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Yes, I have a working fluid-flow only simulation now.",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1058609",
                          "updatedAt": "2022-08-22T04:14:05Z",
                          "publishedAt": "2021-07-26T22:13:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "somu15"
                          },
                          "bodyText": "Hi @klaw13 . Could you try turning off the INS kernels and commenting out the velocity variables for the fluid domain and run FSI?",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1058629",
                          "updatedAt": "2022-08-22T04:14:05Z",
                          "publishedAt": "2021-07-26T22:22:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Hi @somu15, it runs successfully when INS kernels are turned off and velocity variables are removed.",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1075026",
                          "updatedAt": "2022-08-22T04:14:05Z",
                          "publishedAt": "2021-07-27T21:43:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "somu15"
                          },
                          "bodyText": "@klaw13 That is what I had expected. The FSI you are using is an acoustic FSI where pressure is the only primary variable in the fluid domain. See the physics here: https://mooseframework.inl.gov/modules/fsi/fsi_acoustics.html I believe @fdkong has an interface kernel that can work with INS kernels. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1075212",
                          "updatedAt": "2022-08-22T04:14:05Z",
                          "publishedAt": "2021-07-27T21:46:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Thanks @somu15.\nAlso, are there any specific requirements of how the mesh should be defined (more specifically at the interface) for FSI to work correctly?",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1079246",
                          "updatedAt": "2022-08-22T04:14:05Z",
                          "publishedAt": "2021-07-28T00:00:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "somu15"
                          },
                          "bodyText": "@klaw13  Yes, when defining the interface either in Cubit or MOOSE ('SideSetsBetweenSubdomainsGenerator'), the primary side should be the fluid and secondary side should be the structure. This way, the normal vector would point from the fluid to the structure. Correspondingly, in the 'StructureAcousticInterface', the primary variable should be 'p' and neighbor variable should be 'disp'.",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1083148",
                          "updatedAt": "2022-08-22T04:14:05Z",
                          "publishedAt": "2021-07-28T15:50:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Hi @somu15 I tried using  'StructureAcousticInterface' for this geometry without any INS kernels. I adjusted the 3D_struc_acoustic.i example for my problem, but still receive the error as before:\n*** ERROR ***\nMooseVariableFE: Old time derivative of solution (u_dot_old) is not stored. Please set uDotOldRequested() to true in FEProblemBase before requesting u_dot_old.\nI've also verified with the geometry that the blocks of the solid and liquid regions are merged together and display in the mesh output, and that the primary variable is 'p' and neighbor variables are 'disp' as you stated.",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1421515",
                          "updatedAt": "2022-08-22T04:14:09Z",
                          "publishedAt": "2021-10-03T16:58:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "It is a fascinating application. We currently do not have a 3D example in FSI module, but we have a 2D model, \"fsi/test/tests/fsi_2d\", with which you could start.\nThe example is simple, but it is pretty general. Most of the components, internals, and kernels, should be ready to use for your applications.\n\nAlso, are there any specific requirements of how the mesh should be defined (more specifically at the interface) for FSI to work correctly?\n\nWe require solid and fluid meshes to match each other on the interface, even though that can be lifted in the future.",
                  "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1084451",
                  "updatedAt": "2022-07-08T00:11:54Z",
                  "publishedAt": "2021-07-28T21:27:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Thanks @fdkong and @somu15!\nMore on the mesh specifications, are Cubit and the MOOSE mesh generators the only softwares currently compatible with the FSI module? I am using gmsh which doesn't seem to have an option to specify the primary and secondary sides of an interface.\nI was able to extend the fsi_2d example into 3d with the MOOSE mesh, but when I recreate it with gmsh while ensuring that the meshes match on each side of the interface, the simulation fails to implement the FSI module correctly.",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1084505",
                          "updatedAt": "2022-07-11T07:13:40Z",
                          "publishedAt": "2021-07-28T21:48:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "More on the mesh specifications, are Cubit and the MOOSE mesh generators the only softwares currently compatible with the FSI module? I am using gmsh which doesn't seem to have an option to specify the primary and secondary sides of an interface.\n\nHmm, no, we do not put any restriction on FSI module. I have minimal experience with gmsh, but we have a lot of users who use gmsh.\nYou do not necessarily need to generate or mark primary and secondary sides interface using gmsh.  You only need to create fluid and solid meshes using gmsh. Of course, you need to mark each of the domains as a block. And then, you could use SideSetsBetweenSubdomainsGenerator (as @somu15  suggested earlier) to generate interface side sets.\n\nbut when I recreate it with gmsh while ensuring that the meshes match on each side of the interface, the simulation fails to implement the FSI module correctly.\n\nWhat were error messages?",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1084645",
                          "updatedAt": "2022-07-11T07:13:41Z",
                          "publishedAt": "2021-07-28T22:47:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "I wasn't getting an explicit error message, but the fluid would go through the fluid block and nothing would happen to the solid block which is not what we would expect.\nI made two rectangular blocks and specified them accordingly in gmsh, but when I use the SideSetsBetweenSubdomainsGenerator and run the simulation, I get the error that the side set id does not exist...\nMy mesh definition syntax was\n[Mesh]\n[main]\ntype = FileMeshGenerator\nfile = '1side_v0.msh'\n[]\n[interface]\ntype = SideSetsBetweeSubdomainsGenerator\ninput = main\nprimary_block = 'fluid'\npaired_block = 'solid'\nnew_boundary = 'in_between'\n[]\n[]\nAnd in my InterfaceKernels block, I reference the boundary 'in_between' Which based on the examples should be correct.",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1084810",
                          "updatedAt": "2022-07-11T07:13:45Z",
                          "publishedAt": "2021-07-29T00:16:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Run your code with \"--mesh-only\", and then use paraview to check if blocks \"fluid\" and \"solid\", and interface set  \"in_between\" do exist",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1122428",
                          "updatedAt": "2022-07-11T07:13:49Z",
                          "publishedAt": "2021-08-02T22:05:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "When running \"--mesh-only\", the solid and fluid blocks exist. However, the \"in_between\" interface set does not exist.",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1122506",
                          "updatedAt": "2022-07-11T07:13:49Z",
                          "publishedAt": "2021-08-02T22:46:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Do you mind sharing the mesh with us?",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1122529",
                          "updatedAt": "2022-07-11T07:13:49Z",
                          "publishedAt": "2021-08-02T22:59:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "Sure! 1side_v0.zip",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1122552",
                          "updatedAt": "2022-07-11T07:13:49Z",
                          "publishedAt": "2021-08-02T23:12:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "I meant the exodus file that was  generated by using \"--mesh-only\"",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1122603",
                          "updatedAt": "2022-07-11T07:13:50Z",
                          "publishedAt": "2021-08-02T23:38:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "klaw13"
                          },
                          "bodyText": "mesh_exodus.zip",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1122633",
                          "updatedAt": "2022-07-11T07:13:50Z",
                          "publishedAt": "2021-08-02T23:55:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Does gmsh has an equivalent command-line of \"merge volume solid fluid\" of cubit?\nThe interface is not merged between fluid and solid. That can be done via \"merge volume solid fluid\" in cubit. Could you do the same thing in gmsh?",
                          "url": "https://github.com/idaholab/moose/discussions/18267#discussioncomment-1125488",
                          "updatedAt": "2022-07-11T07:13:50Z",
                          "publishedAt": "2021-08-03T14:41:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Line Search Options",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "I apologize if I missed it somewhere.  I am trying to figure out the different line search options. The most information I could find was this \"Options: basic, bt, contact, cp, default, l2, none, project, shell\". The problem I am having is that I am not sure which line search option is which. I can assume bt is backtracking, but I don't know what the others are. Is there a resource I missed when looking at the different line search options?",
          "url": "https://github.com/idaholab/moose/discussions/18993",
          "updatedAt": "2022-10-13T18:22:00Z",
          "publishedAt": "2021-10-04T17:21:16Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere's a documentation page but it's super short and I m not sure where it is online so no need to look for it.\nThe line searches are mostly inherited from Petsc. You should look at petsc documentation for more explanation on bt etc\nIf they dont work well, try line_search = 'none'\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18993#discussioncomment-1427326",
                  "updatedAt": "2022-10-13T18:22:00Z",
                  "publishedAt": "2021-10-04T23:51:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you post a link once you've found the petsc documentation? I'll upgrade our line search docs in moose\nI created an issue #19006",
                          "url": "https://github.com/idaholab/moose/discussions/18993#discussioncomment-1427427",
                          "updatedAt": "2022-10-13T18:22:00Z",
                          "publishedAt": "2021-10-05T00:10:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "This is good to know. Thank you for the information. https://petsc.org/release/docs/manualpages/SNES/SNESLineSearchSetType.html\nI am sure this is the petsc documentation you are asking for; it includes references to different line searches with many of the same names in Moose.",
                          "url": "https://github.com/idaholab/moose/discussions/18993#discussioncomment-1427472",
                          "updatedAt": "2022-10-13T18:22:00Z",
                          "publishedAt": "2021-10-05T00:33:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18993#discussioncomment-1427490",
                          "updatedAt": "2022-10-13T18:22:00Z",
                          "publishedAt": "2021-10-05T00:44:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@GiudGiud while you are at it, maybe it's helpful to also link to the documentation for the contact line search.",
                          "url": "https://github.com/idaholab/moose/discussions/18993#discussioncomment-1427576",
                          "updatedAt": "2022-10-13T18:22:01Z",
                          "publishedAt": "2021-10-05T01:14:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "p-refinement",
          "author": {
            "login": "whiffee"
          },
          "bodyText": "Hi All,\nI see in Moose example ex05 mesh adaptivity is demonstrated, but I can't tell whether it is h- or p-refinement.\nI notice that in the examples in the libMesh repository the distinction is clearly stated. Does/can Moose take\nadvantage of this choice? How would that change the input file?",
          "url": "https://github.com/idaholab/moose/discussions/18984",
          "updatedAt": "2022-06-06T14:18:04Z",
          "publishedAt": "2021-10-02T21:48:53Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nMoose does h-refinement with the unifom_refine options (or with adaptivity). Uniform refinement can be used by specifying -r xx on the command line or by adding uniform_refine = xx to the [Mesh] block.\nAdaptivity and mesh generators allow you to tune the mesh refinement more than just a uniform refinement.\nYou can do p-refinement manually by changing the FE family order in the [Variables] block.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1419851",
                  "updatedAt": "2022-06-06T14:18:09Z",
                  "publishedAt": "2021-10-03T02:27:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "whiffee"
                  },
                  "bodyText": "I'm sort of stuck with the mesh I have, a hex mesh. I've tried .inp import and it seems to work.\nI realize I probably wasn't ready to ask a question about this. However, since I already have,\nI'm supposing a variables block like\n[Variables]\n  order = FOURTH\n  family = LAGRANGE\n\n[]\nwould turn on p-refinement, with a maximum basis order of 4. But how would the decision be made\nas to which element quality would be assigned which order?\nthanks for your patience\nGary",
                  "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1421335",
                  "updatedAt": "2022-06-06T14:18:11Z",
                  "publishedAt": "2021-10-03T15:43:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "moose can refine that mesh (h-refinement) for you, with the options I listed. It doesnt matter that it's imported from a .inp file for refinement.\nThis p-refinement would only work if the mesh can accomodate such a high order variable, eg if it has all the extra points in each element.\n@roystgnr will know more than me here",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1421499",
                          "updatedAt": "2022-06-06T14:18:13Z",
                          "publishedAt": "2021-10-03T16:51:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "whiffee"
                          },
                          "bodyText": "Please don't think I'm knocking h-refinement. It's great if the local mesh quality can support it. I'm just fishing for information on p-refinement because Wikipedia said Moose could do it.",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1424897",
                          "updatedAt": "2022-06-06T14:18:13Z",
                          "publishedAt": "2021-10-04T14:01:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "I know about the libMesh side of things, so we can start off there, at least:\nTo do adaptive p-refinement, you want your \"base\" variable type to be the lowest order you ever want to see.  If you ask for FOURTH order, that means that p=4 will be the minimum in your subsequent simulation, not the maximum.\nWe don't currently support p>2 with LAGRANGE (or L2_LAGRANGE, or RATIONAL_BERNSTEIN) elements, simply because we don't have any geometric Elem types with enough nodes to get cubics with an FE type that sort of inherently associates each Degree of Freedom with a specific node.  Adding higher order geometric elements (at least for the edge/quad/hex Elem types) is on my to-do list now but I'm not sure if I'll get to it by the end of the calendar year.\nTo get adaptive p refinement (not just uniform), you also currently need an FE type that's \"hierarchic\" in the way it assigns degrees of freedom.  Right now that limits you to HERMITE, HIERARCHIC, L2_HIERARCHIC, MONOMIAL, MONOMIAL_VEC, SIDE_HIERARCHIC, SZABAB, and/or XYZ elements.  Some of those elements have other quirks or limitations too - L2_HIERARCHIC, MONOMIALs and XYZ are discontinuous, SIDE_HIERARCHIC is just defined on inter-element boundaries, etc.\nSo the variables block you'd want to start with would be something like\norder = FIRST\nfamily = HIERARCHIC\n\nAnd then you'd do p adaptivity from there ... and I'm not actually sure how to do that in Moose.  In libMesh, after you've run an error estimator and used it to flag elements (for h refinement by default), you just run MeshRefinement::switch_h_to_p_refinement() to switch those \"h refine me\" flags to be \"p refine me\" flags before calling refine_and_coarsen_elements.  A git grep isn't showing me any calls to that switch from within Moose, though.  I'm not seeing anything obvious in Adaptivity.C either.  Do we not have any way to do this from a Moose input file, without making users write custom C++ modules?  If not then that ought to go on my to-do list ASAP; it'd be pretty easy to add a new Adaptivity option that would at least cover most use cases (probably anything without mesh displacement).",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1425007",
                          "updatedAt": "2022-06-06T14:18:33Z",
                          "publishedAt": "2021-10-04T14:21:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Unrelated, about L2_LAGRANGE, was that improved to support p>2 without the geometric constraint?",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1425738",
                          "updatedAt": "2022-06-21T21:35:59Z",
                          "publishedAt": "2021-10-04T16:29:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "No; I'm going to wait until I've got higher-order LAGRANGE.  I assume everyone is going to expect/insist on local DoF ordering matching between the two, and I'd hate to run into some catch with LAGRANGE and the higher-order node ordering and discover that I had to make a backwards-incompatible change to L2_LAGRANGE to match.\nAlso ... until we have higher-order geometric elements (at which point I'll be adding the higher-order LAGRANGE immediately; we need that for just default master->physical mappings), It's hard to see the point of higher-order L2_LAGRANGE.  I guess we'd effectively have \"virtual nodes\" that don't exist, to e.g. define 16-\"node\" L2_LAGRANGE shapes on a Quad9?  That's doable, but what would the benefit even be, over L2_HIERARCHIC?  Lagrange shape functions don't work great in the mixed-order setting - you can put a first-order FE on a second-order Elem easily enough since the nodes are subsets, but you can't do that in general, only in the p1 == 2^n p2 case.  We may never support LAGRANGE on log2(elem_p/p) \\notin W cases, because there's no Lagrange node on which to \"put\" some of the DoFs there.  Supporting L2_LAGRANGE for those cases would be easier, but it'd be hard to convince me it was worth the trouble.",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1426022",
                          "updatedAt": "2022-06-21T21:35:59Z",
                          "publishedAt": "2021-10-04T17:28:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "I think I used high order L2_LAGRANGE without changing the mesh (first order) with DFEM. Now I am not sure if things were working ok.",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1426441",
                          "updatedAt": "2022-06-21T21:36:14Z",
                          "publishedAt": "2021-10-04T19:05:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "If you didn't use the Lagrange property in your code (i.e. if you could have just run with L2_HIERARCHIC instead), then that actually should have worked okay!  The trouble with high order L2_LAGRANGE is that one tends to naturally assume that L2_LAGRANGE elements are Lagrange elements, i.e. that phi_i(node_j) is 1 if i==j and 0 if i!=j.  With second-order L2_LAGRANGE on a first-order Elem, node_j doesn't even exist for high j.  But where it starts getting even worse is for third-order L2_LAGRANGE on a second-order Elem: there the first several non-vertex nodes do exist, but they're not at the 1/3 and 2/3 intervals where you'd expect them for a cubic, they're at the mid points suitable for a quadratic, and trying to evaluate phi_i(node_j) can actually give you wrong results for a cubic phi_i on a quadratic node_j, not just undefined-behavior-but-probably-a-nice-clean-segfault.\nAnyway, if you want to chat more about this, let's open a new discussion entry, not clutter up comments on the p-refinement question.",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1426737",
                          "updatedAt": "2022-06-21T21:36:14Z",
                          "publishedAt": "2021-10-04T20:17:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Benchmarking: Overestimated surface displacement?",
          "author": {
            "login": "tshreve"
          },
          "bodyText": "I am attempting to benchmark Moose's Tensor Mechanics module for a spheroidal pressurized cavity against an analytical solution developed for volcanic source modelling (https://pubs.usgs.gov/tm/13/b1/pdf/tm13-b1.pdf). Assuming linear elasticity, I would expect surface displacements to scale linearly with pressure change, however I found the surface displacements are overestimated when imposing a high pressure change (~1 GPa) on the cavity boundary. Figure 1 shows surface displacements when the boundary pressure change is ~1 GPa, and Figure 2 shows surface displacements when it is ~10 MPa (surface displacements are then scaled by 100). I was wondering if you have any insights as to where this discrepancy comes from.\nThanks in advance for your help!\nFigure 1:\n\nFigure 2:",
          "url": "https://github.com/idaholab/moose/discussions/18898",
          "updatedAt": "2022-06-30T13:39:53Z",
          "publishedAt": "2021-09-22T18:18:16Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nJust a small question and I ll tag the experts after, how refined is your mesh? Did you try using the uniform_refine parameter in [Mesh]?",
                  "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371107",
                  "updatedAt": "2022-06-30T13:39:59Z",
                  "publishedAt": "2021-09-22T18:25:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tshreve"
                          },
                          "bodyText": "The mesh is refined to ~80 m at the surface in a 2 km radius around the cavity, then gradually reduces to ~6 km at a distance of 30 km away from the source. The same mesh is used for both calculations and was created using gmsh. I have not tried using uniform_refine since I am already reaching a high number of DOFs (Num DOFs:                274857, Num Local DOFs: 37722 if running on 8 cores).",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371186",
                          "updatedAt": "2022-06-30T13:40:01Z",
                          "publishedAt": "2021-09-22T18:38:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it would be great to check that a single level of refinement does not change the answer much",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371212",
                          "updatedAt": "2022-06-30T13:40:02Z",
                          "publishedAt": "2021-09-22T18:41:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc @dschwen @jiangwen84",
                  "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371208",
                  "updatedAt": "2022-06-30T13:40:02Z",
                  "publishedAt": "2021-09-22T18:40:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Couple of things:\n\nplease share your input file.\nis the analytical solution derived based on small strain or finite strain assumption? I expect the the deformation will be larger for higher pressure and it might change the assumption.  Could you provide the analytical solution here?\nIs the domain large enough to eliminate the BC effect? I guess the analytical solution assumes infinite domain.",
                  "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371233",
                  "updatedAt": "2022-06-30T13:40:02Z",
                  "publishedAt": "2021-09-22T18:47:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tshreve"
                          },
                          "bodyText": "Input file for high pressure example is attached.\nIt is based on small strain assumption and is described on page 20 (Prolate Spheroid Source) of this document (https://pubs.usgs.gov/tm/13/b1/pdf/tm13-b1.pdf). Let me know if you need more info.\nThe domain is 100 km while the wavelength of the signal is <15 km, so we expect the BC effect to be mitigated.\n\nYang_ElastA3d_nograv_a1000_b500_t90_p0_vertical_highP.txt",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371281",
                          "updatedAt": "2022-06-30T13:40:02Z",
                          "publishedAt": "2021-09-22T19:01:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @tshreve\nAs others say, try a bigger domain, especially in depth along z,\nfor bigger pressures the effect of your \"signal wavelength\" may be larger and you may need a larger domain.\nAlso, try hexahedral elements, tetrahedra elements are usually not very accurate for problems involving bending.\nAlso, check the boundary conditions assumption in the analytical model,\nI think the pressure BC in MOOSE takes into account of the deformed surface,\nmeaning the total force on the surface of one boundary element is pressure * deformed area\nwhile in the analytical model the boundary condition may not consider the deformation,\nit may be applied on the undeformed domain,\notherwise, I am not sure if an analytical solution would be possible.\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371901",
                          "updatedAt": "2022-06-30T13:40:02Z",
                          "publishedAt": "2021-09-22T21:30:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I agree with @ngrilli .\n\nAdd use_displaced_mesh = false in the Pressure block.\ndo you have other 2D example? Maybe you can use them to see the boundary effect. Currently you use symmetric BC, maybe try use a minimum BC that just restricts the rigid body motion.\nWhat did you plot in those figures? displacement along the center line? I suggest you use LineValueSampler to get them directly from MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371944",
                          "updatedAt": "2022-06-30T13:40:14Z",
                          "publishedAt": "2021-09-22T21:42:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tshreve"
                          },
                          "bodyText": "Thanks for your quick responses!\n\nAfter running with use_displaced_mesh = false in the Pressure block, I obtain the following: Warning: unused parameter 'BCs/Pressure/use_displaced_mesh'. Do you know why this parameter is not be taken into consideration? We also noticed that in the Pressure BC documentation the pressure is always applied to the displaced mesh, which we suspect would explain the discrepancy in the displacements.\n\nTo answer your other questions:\n\nI tried with a 2D example and with a large enough domain (100 km) did not see any BC effects.\nI plot the surface displacements with python after testing various interpolation schemes. I will try LineValueSampler for comparison.",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1404355",
                          "updatedAt": "2022-06-30T13:40:27Z",
                          "publishedAt": "2021-09-29T17:34:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@tshreve The use_displaced_mesh option is not implemented in Pressure Action. You can use\n  [pressure_x]\n    type = Pressure\n    boundary = chamber\n    variable = disp_x\n    component = 0\n    factor = 0.96e9\n    use_displaced_mesh = false\n  []\n\n  [pressure_y]\n    type = Pressure\n    boundary = chamber\n    variable = disp_y\n    component = 1\n    factor = 0.96e9\n    use_displaced_mesh = false\n  []\n\n  [pressure_z]\n    type = Pressure\n    boundary = chamber\n    variable = disp_z\n    component = 2\n    factor = 0.96e9\n    use_displaced_mesh = false\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1405052",
                          "updatedAt": "2022-06-30T13:40:32Z",
                          "publishedAt": "2021-09-29T19:11:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tshreve"
                          },
                          "bodyText": "Thanks, I'll give that a try!",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1405431",
                          "updatedAt": "2022-06-30T13:40:43Z",
                          "publishedAt": "2021-09-29T20:43:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tshreve"
                          },
                          "bodyText": "use_displaced_mesh = false resolved the discrepancy. Thanks, we appreciate your help!",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1410645",
                          "updatedAt": "2022-06-30T13:40:43Z",
                          "publishedAt": "2021-09-30T18:31:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "use_displaced_mesh probably shouldn't be suppressed in the Pressure action.",
                  "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1414173",
                  "updatedAt": "2022-06-30T13:40:23Z",
                  "publishedAt": "2021-10-01T12:11:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "It is not suppressed, just not implemented as an option in Pressure action. I agree we should add it, see #18979",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1414807",
                          "updatedAt": "2022-06-30T13:40:50Z",
                          "publishedAt": "2021-10-01T14:20:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Exposing it would just be another chance for users to shoot themselves in the foot, wouldn't it? Physically it makes no sense IMO to apply the forces computed on the undisplaced mesh to the displaced mesh for a pressure BC.",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1414842",
                          "updatedAt": "2022-06-30T13:40:50Z",
                          "publishedAt": "2021-10-01T14:26:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "If we set 'use_displaced_mesh = false`, we will calculate the forces on the undisplayed mesh and apply it on the undisplayed mesh too. Isn't it?\nI guess another way to resolve @tshreve 's issue is NOT to use displaced mesh by setting 'use_displaced_mesh = false` in the Mesh block.",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1414897",
                          "updatedAt": "2022-06-30T13:40:55Z",
                          "publishedAt": "2021-10-01T14:40:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Exposing it would just be another chance for users to shoot themselves in the foot, wouldn't it? Physically it makes no sense IMO to apply the forces computed on the undisplaced mesh to the displaced mesh for a pressure BC.\n\nI think that depends. The root cause of the issue that @tshreve 's seeing is that she is assuming small deformation, while although the deformation is in some sense small, it is large enough to make a non-negligible mismatch with the analytical solution. Ideally, if the deformation was small enough, use_displaced_mesh should make negligible difference.\nNow, there are several ways to solve this issue, as @jiangwen84 suggested:\n\nDo not use the Pressure action, but setup pressure BCs manually with use_displaced_mesh = false,\nLet the displaced mesh fall back to the undisplaced mesh, by setting use_displaced_mesh = false in the Mesh block,\nReduce the magnitude of the pressure until the mismatch between the numerical solution and the analytical solution is negligible.\n\nThen, as a physics module, we need to make a choice:\na. If we want to support methods 1 and 2, then we better allow actions to set those parameters;\nb. If we suggest method 3, we are basically saying this is user error -- the user is using linear elasticity but the problem is violating the small strain assumptions.\nI see arguments for both choices. I guess if we make choice b, it would be better to issue runtime warnings like \"You are using a small strain formulation,but the deformation in your problem is outside the small strain regime, be aware of numerical errors...\".",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1417149",
                          "updatedAt": "2022-06-30T13:41:08Z",
                          "publishedAt": "2021-10-02T01:59:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Ok, makes sense. Wen, I think you're right. The force should be applies to the undisplaced mesh. I guess that means the force is still applied normal to the surface, but the local magnitude of the force is not quite correct because the undeformed  element area rather than the deformed element are is used, right?",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1419008",
                          "updatedAt": "2022-06-30T13:41:22Z",
                          "publishedAt": "2021-10-02T17:12:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Transferring std::vector between apps",
          "author": {
            "login": "sblondel"
          },
          "bodyText": "Hi,\nI want to take advantage of the transfer system for an external app. I know how to transfer a scalar between apps but now I am interested in transferring a std::vector which size would be defined at run time. I looked into the MultiAppReporterTransfer but I am still not sure if it is the best approach. What would you recommend using?",
          "url": "https://github.com/idaholab/moose/discussions/18894",
          "updatedAt": "2022-06-20T14:26:03Z",
          "publishedAt": "2021-09-22T12:36:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs it sized based on the number of elements?\nIn what format do you want this to be available on the MOOSE side? Variable? Vectorpostprocessor?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1369847",
                  "updatedAt": "2022-06-20T14:26:03Z",
                  "publishedAt": "2021-09-22T14:48:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "@GiudGiud The size will be independent of the number of elements, but each mesh/grid point will be passing the same vector size. I think I would prefer to have it as a variable but as long as the externalApp can use it it doesn't matter to me.\nSophie",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1369880",
                          "updatedAt": "2022-06-20T14:26:04Z",
                          "publishedAt": "2021-09-22T14:53:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So it's a vector for every element in the mesh? Like an array variable?",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1369902",
                          "updatedAt": "2022-06-20T14:26:04Z",
                          "publishedAt": "2021-09-22T14:56:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "I believe so.",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1369943",
                          "updatedAt": "2022-06-20T14:26:07Z",
                          "publishedAt": "2021-09-22T15:06:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Great thanks! I dont think anyone has done that in particular. @aprilnovak has made regular variable transfers in Cardinal I believe. Could you please help out here? @sblondel you are at ORNL right? This will help with sharing that project.\n@fdkong @permcody  do you know of any other external apps who worked with transfers in that direction before?",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1369965",
                          "updatedAt": "2022-10-18T18:34:34Z",
                          "publishedAt": "2021-09-22T15:10:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "I am official at University of Tennessee but have an collaborator account at ORNL. For transfers I am familiar with @fdkong work in the external_petsc_solver module.",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370006",
                          "updatedAt": "2022-10-18T18:34:34Z",
                          "publishedAt": "2021-09-22T15:17:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "Hi @sblondel - we have a wrapping of the Nek CFD code in MOOSE that has transfer similar to this - but we don't use the Transfer system directly. Our general approach is to:\n\nCreate a mirror of the external App's mesh (on which the std::vector entries correspond to data on quadrature points, for instance) as a MooseMesh.\nWithin an ExternalProblem class, directly write from the std::vector into a MooseVariable on the mesh created in step (1).\nUse MOOSE's usual transfer system to then get that variable to another application.\n\nSo in essence, we don't write any custom Transfers - instead, we copy the external application's data onto a mesh that MOOSE understands, and then use any existing transfer to get data to another application. We chose not to go with the custom Transfer route because we would have had to implement all the logistics and parallelism of the transfers - like, finding the nearest node on a MooseMesh to a quadrature point in Nek, or doing a mesh interpolation/projection between a MOOSE mesh and a Nek mesh, etc. It was much simpler to just do a mesh + data copy and use MOOSE's transfers \"out-of-the-box.\"\nWhat does your application look like?",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370052",
                          "updatedAt": "2022-10-18T18:34:34Z",
                          "publishedAt": "2021-09-22T15:24:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "Hi @aprilnovak , your approach sounds good. To make sure I understand it: do you have multiple meshes for one app in this case (one for the physical domain and one for the std::vector entries)?\nI'm trying to extend this application: https://github.com/SciDAC-MOOSE-Xolotl-coupling-group/coupling_xolotl/blob/master/src/problem/XolotlProblem.C .",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370181",
                          "updatedAt": "2022-10-18T18:34:54Z",
                          "publishedAt": "2021-09-22T15:33:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "At all times, we have two meshes for Nek - one is the actual mesh that Nek uses for its CFD solve and on which the std::vector exists. The other is a \"mirror\" of that mesh in a MooseMesh format - no solves happen on this mesh - it only exists to receive the std::vector from Nek and put it into a MooseVariable.\nI'm not familiar with your application, but it looks like you have a mesh that replicates the Xolotl domain, in XolotlReflectedMesh? I think our analogue is a NekRSMesh: https://cardinal.cels.anl.gov/source/mesh/NekRSMesh.html\nTo get the std::vector onto the mesh mirror, we have a NekRSProblem where we do this in syncSolutions. In syncSolutions, we call a function like this - _nek_mesh is a pointer to the mesh mirror, and the value we pass in is essentially the std::vector we extracted from Nek.\nvoid\nNekRSProblemBase::fillAuxVariable(const unsigned int var_number, const double * value)\n{\n  auto & solution = _aux->solution();\n  auto sys_number = _aux->number();\n  auto pid = _communicator.rank();\n\n  for (unsigned int e = 0; e < _n_elems; e++)\n  {\n    auto elem_ptr = _nek_mesh->queryElemPtr(e);\n\n    for (unsigned int n = 0; n < _n_vertices_per_elem; n++)\n    {\n      auto node_ptr = elem_ptr->node_ptr(n);\n\n      // For each face vertex, we can only write into the MOOSE auxiliary fields if that\n      // vertex is \"owned\" by the present MOOSE process.\n      if (node_ptr->processor_id() == pid)\n      {\n        // Nek uses different node ordering than linMesh\n        int node_index = _nek_mesh->nodeIndex(n);\n        auto node_offset = e * _n_vertices_per_elem + node_index;\n\n        // get the DOF for the auxiliary variable, then use it to set the value in the auxiliary system\n        auto dof_idx = node_ptr->dof_number(sys_number, var_number, 0);\n        solution.set(dof_idx, value[node_offset]);\n      }\n    }\n  }\n\n  solution.close();\n}\n\nMost importantly, in the NekRSProblem::addExternalVariables function, we add MOOSE variables to represent Nek's internal solution. It looks like your XolotlProblem doesn't have any MOOSE variables added like this. If you wanted to use this approach, you'd add an external variable to represent whatever Xolotl solves for (say, flux?). Then in syncSolutions, write into that flux variable. Then you should be able to apply any MOOSE transfer to that MOOSE-variable-representation-of-flux to get it somewhere else.",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370377",
                          "updatedAt": "2022-10-18T18:34:59Z",
                          "publishedAt": "2021-09-22T15:46:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "Thank you so much for sharing this! Yes, XolotlReflectedMesh replicates the Xolotl domain. I'll try something similar to what you have and let you know how it went (it will probably take me a few days...).",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370469",
                          "updatedAt": "2022-10-18T18:36:01Z",
                          "publishedAt": "2021-09-22T16:03:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "Are you on the MOOSE slack? Feel free to reach out if you have any questions, there's not a ton of examples of the external problem approach in the framework itself",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370732",
                          "updatedAt": "2022-10-18T18:36:01Z",
                          "publishedAt": "2021-09-22T16:56:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "The Reporter system should be able to handle this, perhaps @zachmprince can provide some additional insight into this problem.",
                  "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370470",
                  "updatedAt": "2022-06-20T14:26:08Z",
                  "publishedAt": "2021-09-22T16:03:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "Hi @sblondel. Just give an overview of the reporter system. It has the same high-level functionality as Postprocessors and VectorPostprocessors, except the data can be of arbitrary type. The data created with reporters is available throughout the entire application and can be referenced by other objects. Or it can be transferred between sub-applications using MultiAppReporterTransfer, as long as the type is copy-assignable.\nSo from my possibly flawed understanding of what you need. You could maybe create a Reporter object that converts the data from the Xototl run into an std::vector. You can then create empty std::vector reporter values in the main and other sub-apps using ConstantReporter which MultiAppReporterTransfer can transfer the data into. The objects in the sub-app running the other Xototl instances can then reference this transferred data for their execution.\nI hope this makes sense \ud83d\ude2c",
                  "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1405769",
                  "updatedAt": "2022-06-20T14:26:09Z",
                  "publishedAt": "2021-09-29T22:24:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "Thank you very much for the overview. I'm still trying to decide what is the best approach for my case, I'll let you know if I run into issues with the Reporter and MultiAppReporterTransfer.",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1414214",
                          "updatedAt": "2022-06-20T14:26:13Z",
                          "publishedAt": "2021-10-01T12:21:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Compressible Finite Volume HLLC Boundary Conditions",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "Does the CNSFVHLLC class have a no-slip boundary condition? In the Incompressible finite volume, I see there is a no-slip wall BC, but I am not sure which of the CNSFVHLLC boundary conditions would mimic that.",
          "url": "https://github.com/idaholab/moose/discussions/18963",
          "updatedAt": "2022-09-01T14:07:46Z",
          "publishedAt": "2021-09-29T12:05:29Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont think so. @lindsayad\nNo slip boundary conditions are more of a viscous flow concept, and the HLLC solver is for Eulerian flows with 0 viscosity.\nIf you have a reference for their formulation for HLLC we could have a look\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18963#discussioncomment-1403512",
                  "updatedAt": "2022-09-01T14:07:51Z",
                  "publishedAt": "2021-09-29T15:08:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We have this example here of using our fully compressible Kurganov-Tadmor implementation in a cavity with viscous drag from the walls. Use of the FVOrthogonalBoundaryDiffusion objects ensures that the only momentum flux at the walls is due to viscous forces (no advective outflow of momentum).",
                          "url": "https://github.com/idaholab/moose/discussions/18963#discussioncomment-1404520",
                          "updatedAt": "2022-09-01T14:07:51Z",
                          "publishedAt": "2021-09-29T18:00:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Thank you. I will look at this right away.",
                          "url": "https://github.com/idaholab/moose/discussions/18963#discussioncomment-1408793",
                          "updatedAt": "2022-09-01T14:07:51Z",
                          "publishedAt": "2021-09-30T12:32:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Note that a KT boundary condition may not mix well with HLLC kernels. I'd recommend switching over completely from HLLC to KT for this application.",
                          "url": "https://github.com/idaholab/moose/discussions/18963#discussioncomment-1409536",
                          "updatedAt": "2022-09-01T14:07:52Z",
                          "publishedAt": "2021-09-30T14:50:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "That example does not use any boundary conditions unique to KT",
                          "url": "https://github.com/idaholab/moose/discussions/18963#discussioncomment-1410690",
                          "updatedAt": "2022-09-01T14:07:52Z",
                          "publishedAt": "2021-09-30T18:39:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to implement the term (stress multiply strain rate) in MOOSE?",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hi MOOSEer,\nI want to ask how to calculate the term below in MOOSE? Are there any similar examples on this? Thanks.\n\nwhere \\sigma is stress and \\epsilon is strain.",
          "url": "https://github.com/idaholab/moose/discussions/18822",
          "updatedAt": "2022-06-01T08:43:56Z",
          "publishedAt": "2021-09-14T15:22:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "They are both tensors right?\nThis documentation can help you here https://mooseframework.inl.gov/docs/doxygen/moose/classRankTwoTensorTempl.html",
                  "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1325027",
                  "updatedAt": "2022-06-01T08:43:57Z",
                  "publishedAt": "2021-09-14T15:31:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@GiudGiud Thanks! Yes, they are both ranktwo tensor, I'll have look into this page. Are there any examples of it?",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1329834",
                          "updatedAt": "2022-06-01T08:43:57Z",
                          "publishedAt": "2021-09-14T20:35:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For sure. Once you find the operation you should be using (outer_product I think?) then you can grep the repo for it. I dont think there are examples in the tutorials.",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1329841",
                          "updatedAt": "2022-06-01T08:43:59Z",
                          "publishedAt": "2021-09-14T20:37:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "OK, thank you:) I'll have a try and see what happens.",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1329866",
                          "updatedAt": "2022-06-01T08:43:57Z",
                          "publishedAt": "2021-09-14T20:42:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ajacquey"
                  },
                  "bodyText": "I think you are looking for the double_contraction() function.\nIt looks like you wants the Plastic Heat Energy kernel and associated ComputePlasticHeatEnergy material from the tensor mechanics module.\nIf you'd prefer to implement your own, have a look at lines 42-43 from ComputePlasticHeatEnergy.",
                  "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1332852",
                  "updatedAt": "2022-06-01T08:43:57Z",
                  "publishedAt": "2021-09-15T11:42:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@ajacquey That's very similar to what I want, I'll definitely learn the pages. Thank you !",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1332963",
                          "updatedAt": "2022-06-01T08:44:08Z",
                          "publishedAt": "2021-09-15T12:06:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@ajacquey Hi! When I try to modify the material module above (ComputePlasticHeatEnergy), a variable _d_stress_dT (the derivative of stress w.r.t temperature) was defined, and the rest is mostly the same. But it has the error message as:\n\nerror: 'const class MaterialProperty<RankTwoTensorTempl >' has no member named 'doubleContraction'\n57 |       _d_stress_dT[_qp].doubleContraction(_elastic_strain[_qp] - _elastic_strain_old[_qp]) / _dt;\n\nDo you have any idea of what's going on with the error? Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1397809",
                          "updatedAt": "2022-06-01T08:44:08Z",
                          "publishedAt": "2021-09-28T17:58:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ajacquey"
                          },
                          "bodyText": "Hi @rh201,\nNot sure what causes this error.\nCould you share your files?",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1402301",
                          "updatedAt": "2022-06-01T08:44:07Z",
                          "publishedAt": "2021-09-29T12:44:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "This is the .C file modified form ComputePlasticHeatEnergy, in which I want to consider _d_stress_dT and AD version.\nInputParameters\nComputeElasticHeatEnergy::validParams()\n{\n  InputParameters params = ADMaterial::validParams();\n  params.addParam<std::string>(\"base_name\",\n                               \"Optional parameter that allows the user to define \"\n                               \"multiple mechanics material systems on the same \"\n                               \"block, i.e. for multiple phases\");\n  params.addRequiredCoupledVar(\"temperature\",\"Coupled temperature variable\");\n  params.addClassDescription(\"elastic heat energy density = stress * elastic_strain_rate\");\n  return params;\n}\n\nComputeElasticHeatEnergy::ComputeElasticHeatEnergy(const InputParameters & parameters)\n  : DerivativeMaterialInterface<ADMaterial>(parameters),\n    // _base_name(isParamValid(\"base_name\") ? getParam<std::string>(\"base_name\") + \"_\" : \"\"),\n    // _plastic_strain(getMaterialProperty<RankTwoTensor>(\"plastic_strain\")),\n    // _plastic_strain_old(getMaterialPropertyOld<RankTwoTensor>(\"plastic_strain\")),\n    // _stress(getMaterialProperty<RankTwoTensor>(_base_name + \"stress\")),\n    // _Jacobian_mult(getMaterialProperty<RankFourTensor>(_base_name + \"Jacobian_mult\")),\n    // _elasticity_tensor(getMaterialProperty<RankFourTensor>(_base_name + \"elasticity_tensor\")),\n    // _plastic_heat(declareProperty<Real>(_base_name + \"plastic_heat\")),\n    // _dplastic_heat_dstrain(declareProperty<RankTwoTensor>(_base_name + \"dplastic_heat_dstrain\"))\n    _base_name(isParamValid(\"base_name\") ? getParam<std::string>(\"base_name\") + \"_\" : \"\"),\n    _elastic_strain(getADMaterialProperty<RankTwoTensor>(\"elastic_strain\")),\n    _elastic_strain_old(getMaterialPropertyOld<RankTwoTensor>(\"elastic_strain\")),\n    _stress(getADMaterialProperty<RankTwoTensor>(_base_name + \"stress\")),\n    _d_stress_dT(parameters.hasDefaultCoupledValue(\"temperature\")\n          ? nullptr\n          : &getADMaterialProperty<RankTwoTensor>(derivativePropertyNameFirst(_base_name + \"stress\",\n             getVar(\"temperature\", 0)->name()))),\n    _T_dot(adCoupledDot(\"temperature\")),\n    // _Jacobian_mult(getADMaterialProperty<RankFourTensor>(_base_name + \"Jacobian_mult\")),\n    // _elasticity_tensor(getADMaterialProperty<RankFourTensor>(_base_name + \"elasticity_tensor\")),\n    _elastic_heat(declareADProperty<Real>(_base_name + \"elastic_heat\"))\n    // _delastic_heat_dstrain(declareADProperty<RankTwoTensor>(_base_name + \"delastic_heat_dstrain\"))\n{\n}\n\nvoid\nComputeElasticHeatEnergy::computeQpProperties()\n{\n  _elastic_heat[_qp] =\n      _d_stress_dT[_qp].doubleContraction(_elastic_strain[_qp] - _elastic_strain_old[_qp]) / _dt;\n\n  // if (_fe_problem.currentlyComputingJacobian())\n  // {\n  //   if (_elastic_strain[_qp] == _elastic_strain_old[_qp])\n  //     // no plastic deformation, so _elasticity_tensor = _Jacobian_mult\n  //     _delastic_heat_dstrain[_qp] = RankTwoTensor();\n  //   else\n  //   {\n  //     _delastic_heat_dstrain[_qp] =\n  //         (_elastic_strain[_qp] - _elastic_strain_old[_qp]).initialContraction(_Jacobian_mult[_qp]);\n  //     _delastic_heat_dstrain[_qp] += _stress[_qp];\n  //     _delastic_heat_dstrain[_qp] -=\n  //         _stress[_qp].initialContraction(_elasticity_tensor[_qp].invSymm() * _Jacobian_mult[_qp]);\n  //     _delastic_heat_dstrain[_qp] /= _dt;\n  //   }\n  // }\n}\n\nThe error I mentioned above will show when compiling.\nAnd when I call elastic_strain_old with getADMaterialPropertyOld as below,\n    _elastic_strain_old(getADMaterialPropertyOld<RankTwoTensor>(\"elastic_strain\")),\nanother error will occur\n\nerror: 'getADMaterialPropertyOld' was not declared in this scope; did you mean 'getMaterialPropertyOld'?\n39 |     _elastic_strain_old(getADMaterialPropertyOld(\"elastic_strain\")),\n|                         ^~~~~~~~~~~~~~~~~~~~~~~~\n|                         getMaterialPropertyOld\n\nIt seems there are no getADMaterialPropertyOld function.\nHope it's clear :)",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1403647",
                          "updatedAt": "2022-07-09T21:43:09Z",
                          "publishedAt": "2021-09-29T15:25:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There is no getADMaterialPropertyOld, AD terms are not kept for the old time step. You need to retrieve this as a regular material property\nSee this #18482",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1403664",
                          "updatedAt": "2022-07-09T21:43:11Z",
                          "publishedAt": "2021-09-29T15:28:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@rh201 , what @GiudGiud said is correct.\nYour code doesn't compile because your _d_stress_dT is a pointer. You should instead use\n(*_d_stress_dT)[_qp].doubleContraction(_elastic_strain[_qp] - _elastic_strain_old[_qp]) / _dt;",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1404239",
                          "updatedAt": "2022-07-09T21:43:12Z",
                          "publishedAt": "2021-09-29T17:12:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@GiudGiud @hugary1995 Thank you for pointing this out. It helps.\nBTW, how should I define and calculate _d_stress_dT inside the .C file instead of in input file? since I think it's not convenient to directly retrieve stress when using DerivativeParsedMaterial in input file.",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1407577",
                          "updatedAt": "2022-07-09T21:43:12Z",
                          "publishedAt": "2021-09-30T08:36:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Suppose your stress is a MaterialProperty<RankTwoTensor>, and your temperature is a VariableValue, you can declare the derivative of stress w.r.t. temperature (in the initialization list) using\n_dstress_dT(declareProperty<RankTwoTensor>(derivativePropertyName(\"stress\", {getVar(\"temperature\", 0)->name()})))\nwhere the method derivativePropertyName is defined in DerivativeMaterialPropertyNameInterface.\nSimilarly, if you want to use AD, you can use\n_dstress_dT(declareADProperty<RankTwoTensor>(derivativePropertyName(\"stress\", {getVar(\"temperature\", 0)->name()})))",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1408488",
                          "updatedAt": "2022-07-09T21:43:12Z",
                          "publishedAt": "2021-09-30T11:45:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@hugary1995  Thanks for your help, it compiles successfully now :)",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1408774",
                          "updatedAt": "2022-08-11T14:45:16Z",
                          "publishedAt": "2021-09-30T12:31:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem building libmesh",
          "author": {
            "login": "hsheldon"
          },
          "bodyText": "I'm having trouble building libmesh. Here's what I'm getting:\nlibtool: warning: '/apps/gcc/9.2.0/lib/gcc/x86_64-pc-linux-gnu/9.2.0/../../../../lib64/libstdc++.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libgfortran.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libgfortran.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libgfortran.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nCXXLD    fparser_parse-opt\n./.libs/libmesh_opt.so: error: undefined reference to 'GOMP_loop_nonmonotonic_dynamic_start'\n./.libs/libmesh_opt.so: error: undefined reference to 'GOMP_loop_nonmonotonic_dynamic_next'\ncollect2: error: ld returned 1 exit status\nMakefile:13596: recipe for target 'fparser_parse-opt' failed\nmake[1]: *** [fparser_parse-opt] Error 1\nmake[1]: Leaving directory '/scratch1/projects/moose/moose/libmesh/build'\nMakefile:32290: recipe for target 'all-recursive' failed\nmake: *** [all-recursive] Error 1\nIn those warnings it seems to be looking for gcc/4.9.3 but I have gcc/9.2.0 loaded. Does that have something to do with it? Or is the error completely unrelated to the warnings?\nCheers,\nHeather",
          "url": "https://github.com/idaholab/moose/discussions/18929",
          "updatedAt": "2022-06-14T22:19:54Z",
          "publishedAt": "2021-09-27T01:38:50Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSeems like remnants of a previous compilation are being used. Could you please clean the repo (save your work then git clean -xfd) then try again.\nHow are you building libmesh? With scripts/update_and_rebuild_libmesh?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1393327",
                  "updatedAt": "2022-06-14T22:19:55Z",
                  "publishedAt": "2021-09-28T00:51:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "I've started over with a completely clean installation - just using plain vanilla MOOSE, not my own MOOSE app - still the same problem. I'm using scripts/update_and_rebuild_libmesh. Presumably I need to figure out why it's looking for gcc/4.9.3?\nThanks,\nHeather",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1393744",
                          "updatedAt": "2022-06-14T22:20:01Z",
                          "publishedAt": "2021-09-28T03:37:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "Heather - I suspect gcc/4.9.3 is not an issue here. Compilers are needed to compile... compilers. In this case, I suspect your server admins use gcc 4.9.3 to compile gcc 9.2.0.",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1393781",
                          "updatedAt": "2022-06-14T22:20:01Z",
                          "publishedAt": "2021-09-28T03:48:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "Ok, I'll stop going down the 4.9.3 rabbit hole! Any other suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1393791",
                          "updatedAt": "2022-06-14T22:20:01Z",
                          "publishedAt": "2021-09-28T03:51:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does which mpicxx return though?",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1394079",
                          "updatedAt": "2022-06-14T22:20:20Z",
                          "publishedAt": "2021-09-28T05:58:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "/apps/openmpi/3.1.4-ofed45-gcc/bin/mpicxx",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1394543",
                          "updatedAt": "2022-06-14T22:20:21Z",
                          "publishedAt": "2021-09-28T07:55:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Can you list all your loaded modules? And a printout of an env would also be helpful:\nmodule purge\nmodule load <the modules you are attempting to use>\nmodule list\nenv\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1396191",
                          "updatedAt": "2022-06-14T22:20:24Z",
                          "publishedAt": "2021-09-28T13:31:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "I seem to have fixed the problem by switching from gcc/9.2.0 to gcc/6.1.0. I have the following modules loaded:\nCurrently Loaded Modulefiles:\n\nSC                              4) openmpi/3.1.4-ofed45-gcc        7) netcdf/4.3.3.1                 10) hdf5/1.8.16-gcc                13) git/2.30.0                     16) paraview/5.5.0\nslurm/current                   5) petsc/3.10.5-gcc-mpi314-moose   8) glpk/4.60                      11) eigen/3.3.7                    14) python/2.7.13\nhpc-x/2.4.0                     6) intel-mkl/11.3.2                9) gcc/6.1.0                      12) moose/master                   15) mesa/17.2.4_gallium\n\nMaybe there's something in there that explains why gcc/6.1.0 works?",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1405873",
                          "updatedAt": "2022-06-14T22:20:21Z",
                          "publishedAt": "2021-09-29T23:09:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "As long as all of these were compiled with gcc 6.1.0 (or 9.2 previously)\nWhy are you loading moose/master though? You are compiling your own libmesh, you should compile your own moose too",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1405882",
                          "updatedAt": "2022-06-14T22:20:22Z",
                          "publishedAt": "2021-09-29T23:15:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "I am compiling moose as well - which works now that I've managed to build libmesh. I have module load moose in my .profile.\nThanks for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1405897",
                          "updatedAt": "2022-06-14T22:20:22Z",
                          "publishedAt": "2021-09-29T23:23:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "getting stress_old in ComputeLinearElasticPFFractureStress",
          "author": {
            "login": "selarem"
          },
          "bodyText": "Hi all,\nI am trying to get _stress_old in ComputeLinearElasticPFFractureStress by writting at the constructor:\n_stress_old(getMaterialPropertyOld(_base_name + \"stress\"))\nbut when compiling I obtain:\nprojects/moose/modules/tensor_mechanics/src/materials/ComputeLinearElasticPFFractureStress.C:34:5: error: class 'ComputeLinearElasticPFFractureStress' does not have any field named '_stress_old'\n_stress_old(getMaterialPropertyOld(_base_name + \"stress\"))\nThanks for any suggestion.\nRegards",
          "url": "https://github.com/idaholab/moose/discussions/16552",
          "updatedAt": "2022-06-09T08:18:55Z",
          "publishedAt": "2020-12-21T10:43:12Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "_stress_old needs to be defined in the header file with the correct type. The call to getMaterialPropertyOld should also contain a template argument: getMaterialPropertyStressOld<TheTypeHere>(...).\nFinally, are you modifying this class and plan to push the changes to MOOSE? Otherwise, you should create your own Material object that inherits from this within you application or a separate Material object that uses the properties from this Material.",
                  "url": "https://github.com/idaholab/moose/discussions/16552#discussioncomment-230134",
                  "updatedAt": "2022-06-09T08:19:20Z",
                  "publishedAt": "2020-12-21T16:16:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@aeslaughter Hi! What's the correct type do you refer to? I searched getMaterialPropertyStressOld  but found no results. Are there any examples of that?\nAlso, when I modify getMaterialPropertyOld to getADMaterialPropertyOld, it seems not work, so does AD contain the function of getADMaterialPropertyOld ? Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/16552#discussioncomment-1400790",
                          "updatedAt": "2022-06-09T08:19:20Z",
                          "publishedAt": "2021-09-29T07:45:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Can you tell us why you want to get stress_old? This seems to be an unusual request, But if you describe what you want to achieve here, we might be able to suggest you the right thing to do here.",
                          "url": "https://github.com/idaholab/moose/discussions/16552#discussioncomment-1402073",
                          "updatedAt": "2022-09-09T13:19:02Z",
                          "publishedAt": "2021-09-29T11:59:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Hi Gary, what I want is strain_old to calculate the strain rate. Maybe the question #18822 is much clear.",
                          "url": "https://github.com/idaholab/moose/discussions/16552#discussioncomment-1402250",
                          "updatedAt": "2022-09-09T13:19:02Z",
                          "publishedAt": "2021-09-29T12:35:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}