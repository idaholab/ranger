{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNi0yNlQwMTo1ODoxNS0wNjowMM4ATX3J"
    },
    "edges": [
      {
        "node": {
          "title": "Nucleation of a single seed (benchmark problem)_ Unable to get seed to grow",
          "author": {
            "login": "StephanieSharay22"
          },
          "bodyText": "Hello all!\nI have been working on some of the phase field benchmark problems for Moose. For nucleation of a single seed, I have been unsuccessful in getting my single seed nucleation to grow in size at and above the critical radius value. A link of the problem statement (part a) is listed below. In addition, a zip of my input on csv files are attached.\nThank you in advance for any help!\nhttps://pages.nist.gov/pfhub/benchmarks/benchmark8.ipynb/\nFiles : https://github.com/StephanieSharay22/Nucleation_SingleSeed\nnucleation_single2.zip",
          "url": "https://github.com/idaholab/moose/discussions/24711",
          "updatedAt": "2023-06-27T19:09:45Z",
          "publishedAt": "2023-06-15T21:06:26Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI wont be able to help here, but others may. @recuero @amjokisaari\nI would advise you create a github repository with your inputs rather than share a zip file. Most people will not download zip files from the internet.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6192566",
                  "updatedAt": "2023-06-16T04:05:47Z",
                  "publishedAt": "2023-06-16T04:05:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "StephanieSharay22"
                          },
                          "bodyText": "Hi there! I went ahead and created a repository for the files. Thanks for the advice!",
                          "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6196981",
                          "updatedAt": "2023-06-16T12:56:46Z",
                          "publishedAt": "2023-06-16T12:56:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "liang-tech"
                  },
                  "bodyText": "hello, from your input file, I don not find the DiscreteNucleationInserter and DiscreteNucleationMap in the [UserObjects]. How do you insert a nuclei?",
                  "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6193889",
                  "updatedAt": "2023-06-16T07:34:56Z",
                  "publishedAt": "2023-06-16T07:34:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "StephanieSharay22"
                          },
                          "bodyText": "Hello! It is inserted with the smoothcircleIC. The equation built in to it corresponds to the critical radius. The exact equation is equation 16 in the description link. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6197023",
                          "updatedAt": "2023-06-16T13:02:11Z",
                          "publishedAt": "2023-06-16T13:02:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Any update here?\n@laagesen have we had someone work on these benchmarks?",
                  "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6271038",
                  "updatedAt": "2023-06-24T22:15:57Z",
                  "publishedAt": "2023-06-24T22:15:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "StephanieSharay22"
                          },
                          "bodyText": "Not quite! Closer though, I believe. Will be sure to update the input when we do!",
                          "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6294115",
                          "updatedAt": "2023-06-27T13:44:00Z",
                          "publishedAt": "2023-06-27T13:44:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hello! These have been solved with MOOSE, although the person who did this originally was a postdoc at Argonne and I don't believe he is there anymore. However someone else from our team may have looked at a similar problem, I will check on this.",
                  "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6284316",
                  "updatedAt": "2023-06-26T16:40:48Z",
                  "publishedAt": "2023-06-26T16:40:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "@sourabhkadambi has worked on this in the past and should be able to help. He also generated the nucleation section of this best practices page using MOOSE, which may be useful: https://github.com/usnistgov/pfhub/wiki/Problem-Setup",
                  "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6284405",
                  "updatedAt": "2023-06-26T16:49:48Z",
                  "publishedAt": "2023-06-26T16:49:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "StephanieSharay22"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6293787",
                          "updatedAt": "2023-06-27T13:16:15Z",
                          "publishedAt": "2023-06-27T13:16:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sourabhkadambi"
                  },
                  "bodyText": "Hello! The problem is sensitive to the diffuse interface width, so it's important to set the required profile type and width with  SmoothCircleIC (see documentation at https://mooseframework.inl.gov/source/ics/SmoothCircleIC.html). The interface width is defined as the spatial distance between some choice of order parameter limits, e.g. 0.1 and 0.9. Eq. 4 in https://pages.nist.gov/pfhub/benchmarks/benchmark8.ipynb/ is specific to the tanh profile, but I'm not sure what limits they used to derive the expression. The definition 2.2 \\sqrt(2) *\\sqrt(kappa/W) seems to work better. You can try setting int_width = 3.1113 and profile = TANH in your SmoothCircleIC block.",
                  "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6285668",
                  "updatedAt": "2023-06-26T19:20:13Z",
                  "publishedAt": "2023-06-26T19:20:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "StephanieSharay22"
                          },
                          "bodyText": "Hi there! Thank you so much for your answer! I tried setting my int_width = 3.1113 and profile = TANH, but unfortunately, the seed still will not grow and my total free energy continues to increase. I'll continue working through the problem. Thanks for all the help!!",
                          "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6293782",
                          "updatedAt": "2023-06-27T13:16:00Z",
                          "publishedAt": "2023-06-27T13:16:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sourabhkadambi"
                          },
                          "bodyText": "Please define the material property names in your DerivativeParsedMaterial blocks following https://mooseframework.inl.gov/source/materials/DerivativeParsedMaterial.html, i.e. material_property_names = 'g(eta) p(eta)'. If you don't declare the variable dependence for the materials, the derivates needed for the driving force for evolution may not be available. Someone else can confirm if the situation is the same with ADDerivativeParsedMaterial. Also, set a smaller time step; dt = 0.5 worked for me. Let us know if this worked.",
                          "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6296648",
                          "updatedAt": "2023-06-27T17:52:00Z",
                          "publishedAt": "2023-06-27T17:52:00Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "StephanieSharay22"
                          },
                          "bodyText": "It worked! Thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/24711#discussioncomment-6297274",
                          "updatedAt": "2023-06-27T19:09:46Z",
                          "publishedAt": "2023-06-27T19:09:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question on StitchedMeshGenerator",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Hi all,\nWhen using StitchedMeshGenerator, it works great when I only have one boundary that needs to be combined between two meshes. However, in the problem I have, the two meshes have two boundaries that need to be stitched with each other. Is there a functionality for this?",
          "url": "https://github.com/idaholab/moose/discussions/24832",
          "updatedAt": "2023-06-27T15:46:20Z",
          "publishedAt": "2023-06-27T15:06:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo you ll need to rename the two boundaries to one before stitiching, on both meshes, using a RenameBoundaryGenerator\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24832#discussioncomment-6295145",
                  "updatedAt": "2023-06-27T15:08:58Z",
                  "publishedAt": "2023-06-27T15:08:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "To make sure I understand:\nI have 4 total boundaries to consider on mesh A and mesh B. I want to stitch boundary ID's A1->B1 and A2->B2. Are you saying to rename the A2->B2 boundaries to be A1->B1?\nedit: My wording was unclear in my original question. So I am considering four total boundaries. Two on each mesh",
                          "url": "https://github.com/idaholab/moose/discussions/24832#discussioncomment-6295214",
                          "updatedAt": "2023-06-27T15:19:47Z",
                          "publishedAt": "2023-06-27T15:16:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes. Make sure the boundaries on mesh 1 have the same name, and on mesh 2 as well",
                          "url": "https://github.com/idaholab/moose/discussions/24832#discussioncomment-6295286",
                          "updatedAt": "2023-06-27T15:24:22Z",
                          "publishedAt": "2023-06-27T15:24:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "That worked, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/24832#discussioncomment-6295518",
                          "updatedAt": "2023-06-27T15:46:18Z",
                          "publishedAt": "2023-06-27T15:46:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "phase field model simulation problems",
          "author": {
            "login": "Wolke926"
          },
          "bodyText": "Hello,\nThe following errors occur when I run a two-phase (Liquid and Solid) phase field simulation.\n\n\nThe last term (surface tension) in equation 4 hasn't been coupled. Some mobilities still need to be calculated but I set them as constants for convenience.\nBesides, I'd like to know if my approach (see material module below) is correct when miu or rho is not a constant.\nI've been struggling with this issue in recent days, any help would be greatly appreciated.\nThe input file:\n[Mesh]`\n\n type = GeneratedMesh\n dim = 2\n nx = 80\n ny = 40\n nz = 0\n xmin = 0\n xmax = 40\n ymin = 0\n ymax = 20\n zmax = 0\n elem_type = QUAD4\n uniform_refine = 1\n[]\n`\n\nmu_S = 0.1  # viscousity\nmu_L = 1e-3\nrho_S = 1500  \nrho_L = 1000\nM_AA = 0.5   # mobility\nM_AB = 0.8\nM_BA = 0.8\nM_BB = 1\nL = 1.0 \n\n[Mesh]\n type = GeneratedMesh\n dim = 2\n nx = 80\n ny = 40\n nz = 0\n xmin = 0\n xmax = 40\n ymin = 0\n ymax = 20\n zmax = 0\n elem_type = QUAD4\n uniform_refine = 1\n[]\n\n[Variables]\n [./p]\n [../]\n\n [./c_A]                \n [../]\n\n [./c_B]\n [../]\n\n [./w_A]\n [../]\n [./w_B]\n [../]\n\n [./eta_S] \n  [../]\n [./eta_L] \n  [../]\n\n [./velocity]  \n family = LAGRANGE_VEC\n[../]\n\n[]\n\n\n[Kernels]\n # N-S equation ->\n   [./mass]                           \n    type = INSADMass\n    variable = p\n  [../]\n\n [./mass_pspg]\n    type = INSADMassPSPG\n    variable = p\n [../]\n \n  [./momentum_advection]\n  type = INSADMomentumAdvection          #rho is not a const\n  variable = velocity\n  [../]\n\n  [./viscous]\n  type = INSADMomentumViscous\n  variable = velocity\n  [../]\n\n  [./momentum_time]\n    type = INSADMomentumTimeDerivative\n    variable = velocity\n  [../]\n\n [momentum_pressure]\n    type = INSADMomentumPressure\n    variable = velocity\n    pressure = p\n  []\n\n  [./momentum_supg]\n    type = INSADMomentumSUPG\n    variable = velocity\n    velocity = velocity\n  [../] \n  \n #  CH equation component A & B ->\n\n   [./c_A_residual]\n    type = SplitCHParsed\n    variable = c_A\n    f_name = F\n    kappa_name = kappa_c\n    w = w_A                \n  [../]\n\n   [./w_AA_residual]       \n    type = SplitCHWRes\n    variable = w_A      \n    mob_name = M_AA             \n  [../]\n\n   [./w_AB_residual]\n    type = SplitCHWRes\n    variable = w_A  \n    w = w_B                      \n    mob_name = M_AB\n  [../]\n\n   [./c_B_residual]\n    type = SplitCHParsed\n    variable = c_B\n    f_name = F\n    kappa_name = kappa_c\n    w = w_B                \n  [../]\n\n   [./w_BB_residual]\n    type = SplitCHWRes\n    variable = w_B\n    mob_name = M_BB\n  [../]\n\n   [./w_BA_residual]  \n    type = SplitCHWRes\n    variable = w_B\n    w = w_A\n    mob_name = M_BA\n  [../]\n\n [./timeA]\n    type = CoupledTimeDerivative                 \n    variable = w_A                               \n    v = 'c_A'                         \n  [../]\n\n  [./timeB]\n    type = CoupledTimeDerivative                 \n    variable = w_B\n    v = 'c_B'                          \n  [../]\n\n  [./c_B_convect]\n    type = ConservativeAdvection              \n    variable = c_B\n    velocity = velocity                               \n  [../]\n\n  [./c_A_convect]\n    type = ConservativeAdvection              \n    variable = c_A\n    velocity = velocity                          \n  [../]\n\n# -> AC equation eta_S  (coupling adv)        assuming L s/l and L s/s are same\n \n [./adv_eta_S]                       \n type = ConservativeAdvection\n variable = eta_S\n velocity = velocity\n  [../]\n\n [./eta_dot_S]\n    type = TimeDerivative\n    variable = 'eta_S'\n  [../]\n\n [./AC_int_S]\n   type = ACInterface\n   variable = 'eta_S'\n   kappa_name = kappa_eta\n   mob_name = L\n [../]\n\n  [./AC_bulk_S]\n   type = AllenCahn\n   variable = 'eta_S'\n   f_name = F\n   mob_name = L\n   args = 'eta_L c_A c_B'\n [../]\n \n# -> ac equation eta_L   \n\n [./adv_eta_L]                               \n type = ConservativeAdvection\n variable = eta_L\n velocity = velocity\n  [../]\n\n[./eta_dot_L]\n    type = TimeDerivative\n    variable = 'eta_L'\n  [../]\n\n [./AC_int_L]\n   type = ACInterface\n   variable = 'eta_L'\n   kappa_name = kappa_eta\n   mob_name = L          \n [../]\n\n [./AC_bulk_L]\n   type = AllenCahn\n   variable = 'eta_L'\n   f_name = F                            \n [../]\n\n[]\n\n[Materials]\n\n  [./rho]\n   type = ADDerivativeParsedMaterial\n    f_name = rho\n    args = 'eta_S eta_L'\n    derivative_order = 2\n   function = ' ${rho_S} * eta_S + ${rho_L} * eta_L '\n  [../]\n\n   [./mu]\n   type = ADDerivativeParsedMaterial\n    f_name = mu\n    args = 'eta_S eta_L'\n    derivative_order = 2\n   function = '${mu_S} * eta_S + ${mu_L} * eta_L '                                   # ??\n  [../]\n\n [./constants] # default names of Allen-Cahn gradient coefficient and mobility\n    type = GenericConstantMaterial\n    prop_names = 'kappa_c   kappa_eta     L    M_AA    M_AB  M_BA  M_BB'   \n    \n    prop_values = '1.0       0.5     ${L}  ${M_AA} ${M_AB} ${M_BA}  ${M_BB} '\n  [../]\n\n  [./total_free_energy]                                        \n    type = DerivativeParsedMaterial \n    constant_names = 'A B'\n    constant_expressions = '16.0 1.0 '\n    coupled_variables = 'c_A c_B eta_L eta_S'                        \n    expression ='A * (c_A * c_B)+ B * ( eta_L^2 + eta_S^2 ) '             # please omit this function, it need to be defined                 \n    property_name = F   \n    derivative_order = 2                 \n  [../]\n[]\n\n\n[BCs]\n  [./Periodic]\n    [./All]\n      auto_direction = 'x y'\n    [../]\n  [../]\n[]\n\n[AuxVariables]   \n  [vel_x]\n  []\n  [vel_y]\n  []     \n\n [./total_free_energy]\n    order = CONSTANT\n    family = MONOMIAL\n [../]\n\n [./bnds]                \n [../]\n\n [./dwdx]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./dwdy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n[]\n\n[AuxKernels]\n  [vel_x]\n    type = VectorVariableComponentAux\n    variable = vel_x\n    vector_variable = velocity\n    component = 'x'\n  []\n  [vel_y]\n    type = VectorVariableComponentAux\n    variable = vel_y\n    vector_variable = velocity\n    component = 'y'\n  []\n\n  [./total_free_energy]        \n    type = TotalFreeEnergy\n    variable = total_free_energy\n    f_name = F\n    kappa_names = 'kappa_c kappa_eta'\n    interfacial_vars = 'c_A c_B   eta_S   eta_L'\n  [../]\n  [./bnds]\n    type = BndsCalcAux\n    variable = bnds\n    execute_on = timestep_end\n  [../]\n[]\n\n\n[ICs]                           \n  [./eta_S]                       # Solid = pure component A\n    type = SmoothCircleIC\n    variable = eta_S\n    x1 = '13.5'\n    y1 = '10'\n    radius = '5.5'\n    invalue = 1.0\n    outvalue = 0.0\n    int_width =2.0\n  [../]\n   [./eta_L]                     # liquid = pure component B\n    type = SmoothCircleIC\n    variable = eta_L\n    x1 = '27.5'\n    y1 = '10'\n    radius = '5.5'\n    invalue = 1.0\n    outvalue = 0.0\n    int_width =2.0\n  [../]\n\n   [./c_A]                         \n    type = SpecifiedSmoothCircleIC           \n    x_positions = '13.5'\n    y_positions = '10.0 '\n    z_positions = '0.0  '\n    radii       = '5.5 '\n    invalue = 1.0\n    outvalue = 0.0\n    int_width = 2.0\n    variable = c_A\n    [../]\n   [./c_B]                       \n    type = SpecifiedSmoothCircleIC           \n    x_positions = '27.5 '\n    y_positions = ' 10.0  '\n    z_positions = ' 0.0  '\n    radii       = ' 5.5'\n    invalue = 1.0\n    outvalue = 0.0\n    int_width = 2.0\n    variable = c_B\n    [../]\n[]\n\n[Preconditioning]\n  [./coupled]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Postprocessors]\n  [./area]\n    type = ElementIntegralVariablePostprocessor     \n    variable = 'eta_L'\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n  [./total_free_energy]\n    type = ElementIntegralVariablePostprocessor\n    variable = total_free_energy\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = NEWTON\n  automatic_scaling = true\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_ksp_type\n                         -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'asm      31                  preonly\n                         lu          1'\n  l_tol = 1e-05\n  nl_max_its = 30\n  l_max_its = 30\n  nl_rel_tol = 1e-07\n  nl_abs_tol = 1e-09\n  start_time = 0.0\n  end_time = 500\n  #dt = 0.05\n  \n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    cutback_factor = 0.5\n    dt = 0.01\n    growth_factor = 2\n    optimal_iterations = 8\n  [../]\n  [./Adaptivity]\n    initial_adaptivity = 1\n    refine_fraction = 0.6\n    coarsen_fraction = 0.01\n    max_h_level = 2\n    print_changed_info = true\n  [../]\n[]\n\n[Outputs]\n  file_base = liquid_sintering\n  exodus = true\n  csv = true\n  [./debug]\n    type = VariableResidualNormsDebugOutput\n  [../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24570",
          "updatedAt": "2023-07-05T20:04:10Z",
          "publishedAt": "2023-06-01T21:01:13Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI recommend you build a fluid only simulation and a phase field only simulation first, then try to combine them.\nA first try to combining them should use the multiapps system, it's easier to build coupled simulations that way.\nhttps://mooseframework.inl.gov/syntax/MultiApps/index.html\nThis error is an issue with how the INSAD model is set up in your simulation. You do not have an INSADMaterial defined to hold the quantities needed for that solve\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24570#discussioncomment-6065603",
                  "updatedAt": "2023-06-01T21:34:39Z",
                  "publishedAt": "2023-06-01T21:34:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "Thanks for your suggestions. I add this part to my code in the material block, but some other errors occur. What does the \"size \" mean?\n[./ins_mat]\ntype = INSADMaterial\nvelocity = velocity\npressure = p\n[../]\n\nAnother question, should I define a sub-domain to set the BC or IC for the Navier-Stokes equation to distinguish which part in the system is a liquid? Since the BCs I am using now are just considering the pure phase field equation.",
                          "url": "https://github.com/idaholab/moose/discussions/24570#discussioncomment-6153852",
                          "updatedAt": "2023-06-12T15:28:49Z",
                          "publishedAt": "2023-06-12T15:28:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This comes from a different block, from the total_free_energy object.\nYou need to look at the parameters and make them the same size (like parameter = 'a b c' is of size 3)",
                          "url": "https://github.com/idaholab/moose/discussions/24570#discussioncomment-6154261",
                          "updatedAt": "2023-06-12T16:04:14Z",
                          "publishedAt": "2023-06-12T16:04:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "I fixed this problem but I still have another 2 questions:\n1. what kind of kernel should be used in the high-lightened surface tension term?\n\n2.the problem can not converge",
                          "url": "https://github.com/idaholab/moose/discussions/24570#discussioncomment-6222850",
                          "updatedAt": "2023-06-19T19:13:38Z",
                          "publishedAt": "2023-06-19T19:13:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The preconditioning failed.\nCan you try LU with a nonzero pc_factor_shift ?",
                          "url": "https://github.com/idaholab/moose/discussions/24570#discussioncomment-6222909",
                          "updatedAt": "2023-06-19T19:22:44Z",
                          "publishedAt": "2023-06-19T19:22:43Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "any luck here?",
                          "url": "https://github.com/idaholab/moose/discussions/24570#discussioncomment-6271053",
                          "updatedAt": "2023-06-24T22:18:41Z",
                          "publishedAt": "2023-06-24T22:18:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "Yes! When I try nonzero pc_factor_shift, the solution converges! Thanks for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/24570#discussioncomment-6294936",
                          "updatedAt": "2023-06-27T14:51:32Z",
                          "publishedAt": "2023-06-27T14:51:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issues with EqualValueConstraint",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Hi all,\nI am attempting to use an EqualValueConstraint to impose continuity across a disjointed mesh. Below is the domain I am using.\nHere the refined region is disjointed from the rest of the mesh. I am trying to impose continuity by matching displacements on the boundaries between f the two meshes. The mesh is fully HEX8\n\nHere is the constraint block for the x displacement on one of the boundaries\n[mortar_x1]\n    type = EqualValueConstraint\n    primary_boundary = 'b1_r'\n    primary_subdomain = ref_domain\n    primary_variable = disp_x\n    secondary_boundary = 'b1_c'\n    secondary_subdomain = coarse_domain\n    variable = lambda\n    quadrature = SECOND\n  []\n\nHere 'ref_domain' is the refined domain and 'coarse_domain' is, well, the coarse domain. \"b1_r\" and \"b1_c\" are overlapping boundaries between the domains. I define lamba as a nonlinear variable for the lagrange multiplier. I have this block repeated for all displacements and both boundaries.\nWhen I go to run this simulation, it seg faults. Running MOOSE in debug model reveals the following error in MortarData.C\nAssertion `ip' failed\nLower dimensional elements should always have an interior parent set when using mortar\n\nI believe the implication of this is that I don't have IDs for all of the volumes on my mesh, but I do. I also have labels for all the surfaces. I am assuming I am misinterpreting this.\nAny clarification would be greatly appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/24768",
          "updatedAt": "2023-06-27T12:32:13Z",
          "publishedAt": "2023-06-21T19:50:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you draw the interface on which you are trying to impose the constraint?\nIs it between the coarse and fine elements?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6247575",
                  "updatedAt": "2023-06-22T02:49:24Z",
                  "publishedAt": "2023-06-22T02:49:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Yes, the interfaces are the surfaces between the coarse and fine elements, as shown here.",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6252085",
                          "updatedAt": "2023-06-22T13:16:29Z",
                          "publishedAt": "2023-06-22T13:15:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok it seems MOOSE is expecting these to be born out of local refinement.\nI would try again with a unfirom mesh, set a different subdomain in the \"fine\" area, then refine using the RefineBlockGeneration",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6252571",
                          "updatedAt": "2023-06-22T14:01:09Z",
                          "publishedAt": "2023-06-22T14:01:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Ah but the issue is then the boundaries are handled using whatever interpolation method MOOSE uses for hanging nodes, and I will start to see stress oscillations since I am simulating a plastic material. I am using this way of doing things to try and avoid that.\nCan the hanging nodes born out of local refinement be handled using Lagrange multipliers instead of mesh interpolation?",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6252597",
                          "updatedAt": "2023-06-22T14:04:25Z",
                          "publishedAt": "2023-06-22T14:04:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m not sure. Would a penalty method work for you?\nIf the mesh are still separated, even though uniform refinement was used. to get the fine one, you should get the same treatment as you were expecting in your current attempt",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6253832",
                          "updatedAt": "2023-06-22T15:59:11Z",
                          "publishedAt": "2023-06-22T15:59:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "A penalty method could work, but I may be misinterpreting the syntax on the constraint conditions. I am taking the primary_boundary to be the interface surfaces between the two domains. Then the primary_subdomain and secondary_domain are the lower dimensional blocks generated from the interface surface side sets. So I am using the LowerDBlockFromSidesetGenerator on the interfaces and using the block it outputs as the respective subdomains.  Do you know if that is correct?",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6253912",
                          "updatedAt": "2023-06-22T16:08:21Z",
                          "publishedAt": "2023-06-22T16:06:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "going to defer to @recuero @dschwen",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6254043",
                          "updatedAt": "2023-06-22T16:21:58Z",
                          "publishedAt": "2023-06-22T16:21:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Another question to tack on when they see this\n\nIs there some sort of estimation I could use to figure out what  is? It is unclear from this",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6254173",
                          "updatedAt": "2023-06-22T16:37:00Z",
                          "publishedAt": "2023-06-22T16:36:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "sadly no just trial and error unless you are deep deep into the code. If it gives you the derivatives error, increase it (reconfigure then recompile)",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6254181",
                          "updatedAt": "2023-06-22T18:15:03Z",
                          "publishedAt": "2023-06-22T16:38:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Is there some sort of estimation I could use to figure out what is?\n\nIf you want to fine tune, think of the nodal variables from the primary surface that will affect the residual computation on an element on the secondary surface and take its maximum estimate. This number will be bigger with a bigger dimension (e.g. 3 vs 2), with a higher order (second Lagrange vs first Lagrange), and with more physics (e.g. thermal and mechanical primal and dual interface variables).",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6255233",
                          "updatedAt": "2023-06-22T18:54:31Z",
                          "publishedAt": "2023-06-22T18:54:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I am taking the primary_boundary to be the interface surfaces between the two domains.\n\nThere should be a primary boundary and a secondary boundary. You seem to have that defined correctly in your input. Also, the way you are defining lower-dimensional domains seems correct to me. You could try reducing the number of EqualValueConstraint constraints in your input until you don't get that particular error anymore and take it from there.",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6255250",
                          "updatedAt": "2023-06-22T18:58:00Z",
                          "publishedAt": "2023-06-22T18:57:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "TheGreatCid"
                  },
                  "bodyText": "Is there some sort of estimation I could use to figure out what is?\n\nIf you want to fine tune, think of the nodal variables from the primary surface that will affect the residual computation on an element on the secondary surface and take its maximum estimate. This number will be bigger with a bigger dimension (e.g. 3 vs 2), with a higher order (second Lagrange vs first Lagrange), and with more physics (e.g. thermal and mechanical primal and dual interface variables).\n\nThis makes sense, thank you!",
                  "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6255436",
                  "updatedAt": "2023-06-22T19:20:52Z",
                  "publishedAt": "2023-06-22T19:20:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jbadger95"
                  },
                  "bodyText": "Sorry, it's been a while since I looked at mortar methods so my explanation above was a bit off (it's coming back to me now). Edge dropping happens when only part of the primary surface has a corresponding secondary element. In the incorrect treatment the LM is integrated over the entire secondary surface and only part of the primary surface; the part of the secondary surface without a primary counterpart is thus effectively constrained to be 0 (the LM constraint term looks something like <lambda, u_1 - u_2> = 0, so on the portion where u_1 isn't defined it becomes <lamda, -u_2> = 0 which effectively constrains u_2 to be 0 on that portion of the element). I do remember this causing oscillations in solutions (you're trying to enforce discontinuous data so it's somewhat expected); I think I have some examples of that kicking around somewhere.",
                  "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6286985",
                  "updatedAt": "2023-06-26T22:15:13Z",
                  "publishedAt": "2023-06-26T22:15:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "The way it is implemented in MOOSE, edge dropping takes place if part of the secondary side (element) does not project, akin to it sliding past the primary surface (this is just a matter of criterion and may be confusing when compared with the literature); if this doesn't happen, there is no need to modify the LM shape functions and the constraint integrations and using or not using the correct_edge_dropping option should render the same results for . This is only considered for mechanical contact on post(), so it shouldn't affect the results for the case presented in this discussion.",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6288030",
                          "updatedAt": "2023-06-27T01:40:22Z",
                          "publishedAt": "2023-06-27T01:40:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "I misunderstood the definition of edge-dropping previously. I agree; here it should not make a difference as the surfaces are not sliding past each other",
                          "url": "https://github.com/idaholab/moose/discussions/24768#discussioncomment-6293309",
                          "updatedAt": "2023-06-27T12:27:30Z",
                          "publishedAt": "2023-06-27T12:27:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow: convergence problem.",
          "author": {
            "login": "sinaomrani96"
          },
          "bodyText": "Hi,\nHope you are doing well.\nI am working with a 2-phase 3-component system. The input file works fine, but when I change it to compositional using PorousFlowFluidState (calculating dissolution and mass fraction in each phase) I face convergence error. I checked the Jacobian and this is the results:\nNo errors detected. :-)\nKernel for variable 'zi':\n(1,1) On-diagonal Jacobian is wrong (off by 62.6 %)\nKernel for variable 'tracer':\n(2,1) Off-diagonal Jacobian for variable 'zi' is slightly off (by 0.045432 %)\nI was wondering if there is a problem in my input file or anything else. Thanks.\nBest regards,\nSina",
          "url": "https://github.com/idaholab/moose/discussions/24717",
          "updatedAt": "2023-06-26T23:25:49Z",
          "publishedAt": "2023-06-16T09:11:03Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sinaomrani96"
                  },
                  "bodyText": "Also, I am getting 0 residual on one of the variables event though it has initial condition defined. I do not understand why this 0 residual happens.\npwater: 0\nzi:     0.000545419\ntracer: 3.84182e-06",
                  "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6195474",
                  "updatedAt": "2023-06-16T10:00:28Z",
                  "publishedAt": "2023-06-16T10:00:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Hi everyone,\nSorry to ask again, but I was not able to solve it by my own. I would appreciate if you could help me. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6228760",
                          "updatedAt": "2023-06-20T10:06:48Z",
                          "publishedAt": "2023-06-20T10:06:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@cpgr @RLiu2020 any hint on this?",
                          "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6232825",
                          "updatedAt": "2023-06-20T16:28:55Z",
                          "publishedAt": "2023-06-20T16:28:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Sorry - I didn't see this one when I last checked.\nAt a guess it is a BC causing this, or might even be this #23197 (reply in thread)\nI'd be happy to take a look at your example if you can share a simple version?",
                          "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6235317",
                          "updatedAt": "2023-06-20T21:17:25Z",
                          "publishedAt": "2023-06-20T21:17:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Hi Chris,\nHope you are doing well.\nI checked the solution you mentioned but it did not work. About BCs, I did not change them compare to the example I had with 2-phase 3-components but without dissolution. Below is the input file link. I would appreciate it if you could look at it. Thanks.\nhttps://github.com/sinaomrani96/PorousFlow-test/tree/main",
                          "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6235606",
                          "updatedAt": "2023-06-20T22:03:13Z",
                          "publishedAt": "2023-06-20T22:03:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Hi Chris,\nI was working on the input file and now I do not get 0 residual for pressure and the jacobian analyser gives no error. However, I still cannot run it and get the following error:\nTime Step 1, time = 1, dt = 1\n0 Nonlinear |R| = 5.470420e-07\n|residual|_2 of individual variables:\npwater: 5.47042e-07\nzi:     0\ntracer: 3.84182e-10\n0 Linear |R| = 5.470420e-07\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nI outlined the conditioning number and here is the result:\nSVD: condition number            inf, 443 of 1323 singular values are (nearly) zero\nSVD: smallest singular values: 0.000000000000e+00 6.976952038536e-109 3.109126926142e-93 6.704283696648e-92 2.280963623827e-85\nSVD: largest singular values : 1.000000000000e+00 1.000000000000e+00 1.000000000000e+00 1.000000000000e+00 1.000000000000e+00\nI suspect the issue is with PorousFlowBrineCO2. I specified the liquid component but I guess because I have one more component in liquid phase it faces an issue in calculating mass fractions. I would appreciate it if you could give me your insight. Thanks.\nAlso, below is the input file link:\nhttps://github.com/sinaomrani96/PorousFlow-test/blob/main/test",
                          "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6275294",
                          "updatedAt": "2023-06-25T18:09:47Z",
                          "publishedAt": "2023-06-25T18:09:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "I have been testing this and I'm pretty certain that you are correct. At least, I'm sure that it isn't a bug in the code, rather a lack of functionality for this problem. If you remove the tracer the problem runs.\nAt the moment, there is no way to add a tracer when using one of the classes where solubility is included. Like you suggest, the main problem is that there isn't a way to add extra mass fractions. In your example, PorousFlowBrineCO2 computes the mass fraction for NaCl in water as component 2, so you can't use that for the tracer, and there isn't a way to add a fourth component (the tracer) to the mass fraction array. I don't think it would be hard, it's just that I have never needed it so didn't add it.\nI think that the way to do it would be to add an extra parameter to the PorousFlowFluidState material that then appends extra mass fractions to the array of mass fractions, but this would require some coding.",
                          "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6276469",
                          "updatedAt": "2023-06-25T23:40:51Z",
                          "publishedAt": "2023-06-25T23:40:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Actually, now I'm not sure that is the best idea....",
                          "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6276605",
                          "updatedAt": "2023-06-26T00:31:55Z",
                          "publishedAt": "2023-06-26T00:31:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Dear Chris,\nThank you for your time and consideration. I will work on it and see how it can be handled. Also, I had a question regarding gas viscosity when I am using PorousFlowBrineCO2 and PorousFlowFluidState. When I look at it in Paraview, it shows the value of 1 in regions that there is no gas. I checked it in the code and it is commented that it is to prevent dividing by zero. So, I was wondering that if affects the gas movement, which probably won't, and how I can remove it for visualization. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6283761",
                          "updatedAt": "2023-06-26T15:49:34Z",
                          "publishedAt": "2023-06-26T15:49:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "SVD: condition number inf, 443 of 1323 singular values are (nearly) zero\n\nthis is a big deal. The problem is severely ill-posed, the equations are not enough to determine the degree of freedoms of all the variables.\nOnce you figure out the other aspects of this, you will want to check that there is no more singular values",
                          "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6287318",
                          "updatedAt": "2023-06-26T23:18:07Z",
                          "publishedAt": "2023-06-26T23:18:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "It was a while ago, but I think that there was a floating point exception when running in dbg due to the (rho * k * kr / mu) term in the advection kernel. It doesn't have any affect on the physics, because rho = 0 in this region so this term is zero.\nIt does affect the visualisation though as you have observed! One option is you can use Paraview to clip the data to gas_saturation > 0 and overlay it on the full mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/24717#discussioncomment-6287334",
                          "updatedAt": "2023-06-26T23:24:03Z",
                          "publishedAt": "2023-06-26T23:24:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to generate composite beam?",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE experts,\nI am trying to solve beam equation\nhttps://mooseframework.inl.gov/source/kernels/StressDivergenceBeam.html\nI can able to solve it as single layer/material. Is it possible to add second layer of some other material for this module?\nFor example,\nI want to simulate something like bimetallic thermal strip with eigen strain given to the upper layer.\nAny suggestions?\nBest,\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/23501",
          "updatedAt": "2023-06-26T23:01:42Z",
          "publishedAt": "2023-02-21T17:18:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you get a working solution here?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23501#discussioncomment-6270687",
                  "updatedAt": "2023-06-24T20:03:42Z",
                  "publishedAt": "2023-06-24T20:03:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "@GiudGiud I did solve it but analytically with lots of assumptions. Still looking if I can do it using MOOSE.\nThanks,\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/23501#discussioncomment-6282933",
                          "updatedAt": "2023-06-26T14:29:18Z",
                          "publishedAt": "2023-06-26T14:29:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "More than likely so.\nDoes it work with the same assumptions as analytically?",
                          "url": "https://github.com/idaholab/moose/discussions/23501#discussioncomment-6287257",
                          "updatedAt": "2023-06-26T23:01:42Z",
                          "publishedAt": "2023-06-26T23:01:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to retrieve 'LayeredExtremum' of material properties?",
          "author": {
            "login": "slee-USNC"
          },
          "bodyText": "Can we retrieve layer-wise extremum of material properties? I am trying to extract maximum temperature of specific material within different intervals on the z-axis.\ne.g.) Given a mesh like below:\n[Mesh]\n  [hexagon]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '4 4 4 4 4 4'\n    ring_intervals = '1 1 1 1'\n    ring_radii = '1 1 1 1'\n    ring_block_ids = '1 2 3 4'\n    polygon_size = 6\n    background_block_ids = 5\n    quad_center_elements = True\n  []\n  [extrusion]\n    type = AdvancedExtruderGenerator\n    input = hexagon\n    direction = '0 0 1'\n    heights = '1 1 1 1 1'\n    num_layers = '1 1 1 1 1'\n  []\n[]\n\nI'd like to get the max temperature for every 1 m axial layer of block 3.\nI know LayeredAverage does something similar, but I want to retrieve maximum and minimum instead of the average.",
          "url": "https://github.com/idaholab/moose/discussions/24672",
          "updatedAt": "2023-06-26T22:56:14Z",
          "publishedAt": "2023-06-13T17:19:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe need to create a LayeredExtrema class to do this. It will be able to do min/max and will look much like the LayeredAverage code\nDo you feel comfortable creating it?\nThis is something that could be contributed to the framework.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6166395",
                  "updatedAt": "2023-06-13T17:49:25Z",
                  "publishedAt": "2023-06-13T17:49:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "slee-USNC"
                          },
                          "bodyText": "Do you feel comfortable creating it?\n\nI have to say no unfortunately. I don't have any experience in MOOSE development yet.",
                          "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6166940",
                          "updatedAt": "2023-06-13T19:03:32Z",
                          "publishedAt": "2023-06-13T19:03:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What kind of timeline do you have on this?\nAre you working in collaboration with a program at INL or ANL on this?\nFeel free to email me at guillaume.giudicelli@inl.gov if this is confidential",
                          "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6167292",
                          "updatedAt": "2023-06-13T19:56:40Z",
                          "publishedAt": "2023-06-13T19:56:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "slee-USNC"
                          },
                          "bodyText": "What kind of timeline do you have on this?\n\nWe don't need this in urgent. Definitely something to explore in the future though.\n\nAre you working in collaboration with a program at INL or ANL on this?\n\nNo",
                          "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6168213",
                          "updatedAt": "2023-06-13T22:38:20Z",
                          "publishedAt": "2023-06-13T22:38:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I've created this issue to keep track of this feature request\n#24682\nI also made this branch:\nhttps://github.com/GiudGiud/moose/tree/PR_extrema\nwhich has a LayeredExtremumMaterialProperty user object\nI did not test it, and I have to move on to something else rn, please let me know if it works as expected.\nI ll try to test it this week",
                          "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6169333",
                          "updatedAt": "2023-06-14T01:59:11Z",
                          "publishedAt": "2023-06-14T01:59:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "slee-USNC"
                          },
                          "bodyText": "@GiudGiud\nThank you! We will try the new branch out on our end as well",
                          "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6179787",
                          "updatedAt": "2023-06-14T22:34:36Z",
                          "publishedAt": "2023-06-14T22:34:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Trying it right now too. looks like I duplicated a parameter, I ll do some clean up",
                          "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6179815",
                          "updatedAt": "2023-06-14T22:40:25Z",
                          "publishedAt": "2023-06-14T22:40:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yeah it does not work yet. I ll see if I get it working soon.\nSorry for the false hope",
                          "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6179927",
                          "updatedAt": "2023-06-14T23:05:57Z",
                          "publishedAt": "2023-06-14T23:05:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Should work now. I got a reasonable result for my test input.\nPlease let me know what you see on your end\nI pushed a new version to the branch with my test too",
                          "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6180032",
                          "updatedAt": "2023-06-14T23:24:56Z",
                          "publishedAt": "2023-06-14T23:24:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "slee-USNC"
                          },
                          "bodyText": "It seems working well and as expected on our end too. Thanks @GiudGiud !",
                          "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6235897",
                          "updatedAt": "2023-06-20T23:12:17Z",
                          "publishedAt": "2023-06-20T23:12:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Good to hear.\nI just improved my test a little and saw an issue with every other value when outputting through a SpatialUOVPP. Just letting you know",
                          "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6258219",
                          "updatedAt": "2023-06-23T04:22:32Z",
                          "publishedAt": "2023-06-23T04:22:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "LayeredExtremumMaterialProperty is merged into MOOSE, in the next/ branch. It will propagate in devel / master then in the applications over the next few days",
                  "url": "https://github.com/idaholab/moose/discussions/24672#discussioncomment-6287216",
                  "updatedAt": "2023-06-26T22:56:15Z",
                  "publishedAt": "2023-06-26T22:56:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using JFNK and PBP to solve an 3D CFD problem",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, experts.\nI have seen many examples of applying JFNK method to CFD, so I want to use MOOSE to do some 3D CFD calculations. But when I use JFNK algorithm and PBP in MOOSE to calculate a 3D-CFD case, the result cannot converge. When I use NEWTON method with FSP or SMP, it can converge well. Here are my Preconditioning and Executioner settings:\n[Preconditioning]\n  active = 'PBP'\n  [PBP]\n    type = PBP\n    solve_order =    'p   velocity Tf       Ts'\n    preconditioner = 'LU  LU       LU       LU'\n    full = true\n    petsc_options_iname = '-ksp_type'\n    petsc_options_value = 'gmres'\n  []\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = 'JFNK'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  line_search = 'none'\n\n  nl_abs_tol = 1e-8\n  nl_rel_tol = 1e-8\n  nl_max_its = 50\n  l_max_its = 100\n[]\n\nDo you have any suggestions or similar experiences?",
          "url": "https://github.com/idaholab/moose/discussions/23496",
          "updatedAt": "2023-06-26T16:11:21Z",
          "publishedAt": "2023-02-21T14:58:26Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Use PJFNK, JFNK is meant to avoid preconditioning",
                  "url": "https://github.com/idaholab/moose/discussions/23496#discussioncomment-6270683",
                  "updatedAt": "2023-06-24T20:02:55Z",
                  "publishedAt": "2023-06-24T20:02:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "PBP was meant to be used with JFNK, not PJFNK. But I would say that you should use FSP instead of PBP",
                          "url": "https://github.com/idaholab/moose/discussions/23496#discussioncomment-6284008",
                          "updatedAt": "2023-06-26T16:11:21Z",
                          "publishedAt": "2023-06-26T16:11:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "FSI at high Reynolds number: Vector or scalar field velocity variable?",
          "author": {
            "login": "Eilloo"
          },
          "bodyText": "Hi all,\nI am working towards running FSI simulations at high Reynolds numbers:\nI have had some success using the fsi module at low Reynolds numbers, where the velocity is a scalar field variable (ie: one variable per component), and also running CFD only simulations in FE at high Reynolds numbers. In the latter case, SUPG stabilisation is required, and the velocity is a vector variable.\nTo combine the two approaches, I believe I need to either:\n\nAllow the interface kernels to accept a vector velocity variable, without changing the structural variables to be vectors too. This idea is described near the end of this thread.\nAdd a kernel to implement SUPG stabilisation, which accepts the velocity as three separate components. and applies a stabilisation term to each appropriately.\n\nI have done some digging, and anticipate the following obstacles with each approach:\nIn the first case, the main problem is that the class template for the interface kernel expects only one variable type.\nThe more I look into the code, the more I think it is not straightforward to add a second type, and change everything this feeds as well. Indeed, I'm encountering situations where the type of one object would be dependent on the type of another, which so far is troublesome in C++.\nThe bottom line here is the implications of messing with the class template seem complex and relatively far-reaching in terms of other changes I would need to make.\nIn the second case, the current implementation of SUPG stabilisation in the INS module is tied to material classes, which expect a vector velocity variable. My initial thinking was to extract all of the equations which go into calculating this term and collect them in a new, ordinary kernel which does the calculations according to a scalar field velocity. This way I would avoid redefining large chunks of these built-in material classes.\nHowever, I noticed that the current SUPG kernel is not an ordinary kernel, but an 'ADStabilizedKernel'. I've not found much documentation for this, but in the header file there is a comment noting: 'Called before forming the residual for an element'.\nI would like to know whether stabilisation terms such as this can be included is ordinary kernels with a residual contribution as proposed above, or whether some special treatment is required?\nPhew! Apologies for the information dump - I wanted to be as clear as possible about the current state of affairs. Presently, I am thinking that option 2 is likely easier to achieve.\nIn addition to the specific question about stabilisation kernels, I am hoping to get some thoughts thoughts from anyone who's more involved/familiar with these modules.\nI would welcome any insight regarding which is more feasible to achieve, or even suggestions of some altogether simpler solution.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/23567",
          "updatedAt": "2023-06-26T15:46:52Z",
          "publishedAt": "2023-03-01T08:48:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSorry the delay.\nScalar field velocity variables will be easier to deal with. There are simply many more objects you can use with scalar fields over vector fields.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23567#discussioncomment-6271068",
                  "updatedAt": "2023-06-24T22:23:24Z",
                  "publishedAt": "2023-06-24T22:23:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Eilloo"
                  },
                  "bodyText": "No problem, thanks for the advice!",
                  "url": "https://github.com/idaholab/moose/discussions/23567#discussioncomment-6279144",
                  "updatedAt": "2023-06-26T07:58:54Z",
                  "publishedAt": "2023-06-26T07:58:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "In #24204 I am introducing an interface kernel that interfaces the component treatment of displacements in the tensor mechanics module with the vector velocity treatment of INSAD",
                  "url": "https://github.com/idaholab/moose/discussions/23567#discussioncomment-6283732",
                  "updatedAt": "2023-06-26T15:46:53Z",
                  "publishedAt": "2023-06-26T15:46:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How is 'use displaced mesh' implemented?",
          "author": {
            "login": "Eilloo"
          },
          "bodyText": "Hello all,\nWhilst experimenting with FSI in the FE Navier-Stokes module, I have encountered a situation where setting use_displaced_mesh = true for the Navier-Stokes kernels gives me different solutions when using the vector family of kernels, compared to the field variable family.\nAs in my other recent posts, the testing ground has been the flat channel example discussed here.\nRunning the original, and vector variable versions of this file with use_displaced_mesh = false everywhere produces identical results in both the solid and fluid domains. This is great news, and I believe indicates that the custom interface kernels (thanks again for the input here!) are doing exactly the same thing as the original versions.\nHowever, when I turn on use_displaced_mesh, the solutions become different.\nI am therefore wondering if the displaced mesh system should behave any differently with either vector variables, or for some reason specifically in the vector family of Navier-Stokes kernels? So far, I haven't found anything in the code that would suggest this...\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/24042",
          "updatedAt": "2023-06-26T07:58:25Z",
          "publishedAt": "2023-04-12T16:20:30Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Conceptually they should not behave differently; in practice ... well it seems like they do \ud83d\ude26",
                  "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-5596573",
                  "updatedAt": "2023-04-12T19:26:11Z",
                  "publishedAt": "2023-04-12T19:26:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "One thing I will say is that the vector kernels have built-in addition of derivatives with respect to the mesh displacements to the jacobian, whereas the scalar field kernels do not. However, that should only impact the convergence efficiency, and if both solves converge then the solutions should compare equal within a tolerance.",
                          "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-5596592",
                          "updatedAt": "2023-04-12T19:28:02Z",
                          "publishedAt": "2023-04-12T19:28:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "Interesting... Yes, I've seen some cases where the convergence is different depending on which kernels I turn on displaced mesh for. In fact, the interface diffusion kernels seem to have the biggest effect here, with the non-vector version failing to converge at all when displaced mesh is on (by default and in the example file though, it's off). Nice to know where that might be coming from.\nIf I uncover anything explaining the differences in the actual solutions, I'll keep you updated.\nFor these simple test cases with very few elements, the differences are noticeable, but pretty small. Going up to more complex cases though, these differences seem to compound resulting in wildly different behaviour between vector and non-vector stuff. (Of course, that's assuming this discrepancy is the cause, and not some other mistake \ud83d\ude06)",
                          "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-5604159",
                          "updatedAt": "2023-04-13T12:56:53Z",
                          "publishedAt": "2023-04-13T12:56:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "Following up on this, does anyone know where I can look for the code implementation of use_displaced_mesh = true compared to false?\nI can see that displaced_problem seems to be a whole system of its own, but I can't find anything vector or non-vector specific so far.\nIn the kernel base class, I can see the declaration of use_displaced_mesh, but not the code where things are calculated differently based on whether this is true or false.\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-5733077",
                          "updatedAt": "2023-04-26T15:18:25Z",
                          "publishedAt": "2023-04-26T15:18:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThis will very much depend on the object type.\nFor example for ADKernels:\nADKernelTempl<T>::computeResidual()\n{\n  precalculateResidual();\n\n  std::vector<Real> residuals(_test.size(), 0);\n\n  if (_use_displaced_mesh)\n    for (_qp = 0; _qp < _qrule->n_points(); _qp++)\n      for (_i = 0; _i < _test.size(); _i++)\n        residuals[_i] += raw_value(_ad_JxW[_qp] * _ad_coord[_qp] * computeQpResidual());\n\nthe difference here is the use of the local element jacobian/weights with AD derivatives with regards to the displacements of the mesh\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-5733367",
                          "updatedAt": "2023-04-26T15:40:48Z",
                          "publishedAt": "2023-04-26T15:40:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "Thanks Guillaume,\nThis does make me think, if the Jacobian is used in the computeResidual() method, does this mean that the addition of derivatives mentioned by Alex above could in fact impact the solution, rather than just the convergence? Or have I misunderstood this...",
                          "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-5740372",
                          "updatedAt": "2023-04-27T08:56:17Z",
                          "publishedAt": "2023-04-27T08:56:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The solution doesnt change, as the residual is the same.\nThis of an AD number for the contribution to the residual as :  (residual, d_residual_variable_1_local_cell, d_residual_variable_2_local_cell ...)\nonly the first component gets used to compute the residual, then the derivatives are used to build the Jacobian",
                          "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-5742102",
                          "updatedAt": "2023-04-27T11:49:48Z",
                          "publishedAt": "2023-04-27T11:49:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@Eilloo are you setting use_displaced_mesh on the INSAD material? This is essential to get the same results as when using the INS objects since the INSAD material computes the strong residuals that are used by most of the INSAD kernels, e.g. the INSAD objects rarely do computations themselves. I made this mistake myself yesterday",
                          "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-5745446",
                          "updatedAt": "2023-04-27T17:00:25Z",
                          "publishedAt": "2023-04-27T17:00:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "This is a very good point and no, I haven't been - I'll test that as soon as I can and confirm any improvement.\nThanks also for highlighting 24024 - I'll add a link here too in case anyone finds this thread in future",
                          "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-5753144",
                          "updatedAt": "2023-04-28T10:47:47Z",
                          "publishedAt": "2023-04-28T10:47:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@Eilloo is this resolved?",
                          "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-6271091",
                          "updatedAt": "2023-06-24T22:31:52Z",
                          "publishedAt": "2023-06-24T22:31:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "Hi yes, sorry - forgot to mark as answer",
                          "url": "https://github.com/idaholab/moose/discussions/24042#discussioncomment-6279136",
                          "updatedAt": "2023-06-26T07:58:16Z",
                          "publishedAt": "2023-06-26T07:58:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}