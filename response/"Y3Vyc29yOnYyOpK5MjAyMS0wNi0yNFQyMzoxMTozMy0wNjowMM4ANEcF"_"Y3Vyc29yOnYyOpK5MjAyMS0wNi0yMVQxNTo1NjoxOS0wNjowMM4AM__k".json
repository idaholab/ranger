{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNi0yMVQxNTo1NjoxOS0wNjowMM4AM__k"
    },
    "edges": [
      {
        "node": {
          "title": "Wrong value when time=0 in output file",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Above pictures are parts of my code.\nWhat I expected was \"phi_Ni = -1.03665 in output file\" when time = 0.\nBut when time=0, phi_Ni = 0 was shown.\n\nWhat do I miss at here?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/18165",
          "updatedAt": "2021-06-24T21:18:41Z",
          "publishedAt": "2021-06-24T20:54:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthe postprocessor is not being executed at the 0th timestep.\nYou need to add execute_on = 'INITIAL timestep_end' to your input file for this postprocessor\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18165#discussioncomment-917595",
                  "updatedAt": "2021-06-24T20:58:36Z",
                  "publishedAt": "2021-06-24T20:58:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Thanks, it works!",
                          "url": "https://github.com/idaholab/moose/discussions/18165#discussioncomment-917670",
                          "updatedAt": "2021-06-24T21:18:31Z",
                          "publishedAt": "2021-06-24T21:18:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Two mesh domain NS Solution",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I have created a NS model that is composed of two separate mesh domains. The flow for one domain (domain-1) is pressure driven between the inlet and the outlet, walls are treated as no-slip boundary conditions. The second mesh domain is contained in the interior of the first and has different material properties. The problem is transient. I would like to implicitly define within the domain-1  the a no-slip boundary condition based on the outer boundary shape on domain-2. The expectation is that I will be able to observe flow around domain-2 in domain-1. I would then like to translate the viscous stress in domain-1 at the implicit boundary of domain-2 as a boundary force condition in domain-2. This is all done within a single application. Can this be accomplished as described and if so how?\nFallingBall.e.txt\nFallingBall.i.txt",
          "url": "https://github.com/idaholab/moose/discussions/17925",
          "updatedAt": "2022-07-27T20:57:13Z",
          "publishedAt": "2021-05-25T19:01:29Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDo you want to be tracking the interface explicitly or use some sort of volume averaging?\nWe laid out an approach in this discussion\n@fdkong this is another fsi-like problem where the solid block is moving around in the fluid. We should make an example of this.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-805241",
                  "updatedAt": "2022-07-27T20:57:11Z",
                  "publishedAt": "2021-05-31T05:00:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "I would like to track the effects explicitly in each time step iteration. Ball position establishes moving no-slip boundary for the larger fluid domain. The fluid stress at the ball establishes changing ball position.\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-807285",
                          "updatedAt": "2022-07-27T20:57:11Z",
                          "publishedAt": "2021-05-31T14:34:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok this is very similar to the thread I linked to.\nSo same advice, do you have a satisfactory solution without the ball moving?\nAnd you'll need to set up elastic mesh deformation, to adapt the mesh at every time step",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-808514",
                          "updatedAt": "2022-07-27T20:57:11Z",
                          "publishedAt": "2021-05-31T20:21:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Ok this is very similar to the thread I linked to.\nSo same advice, do you have a satisfactory solution without the ball moving?\nAnd you'll need to set up elastic mesh deformation, to adapt the mesh at every time step\n\nYes, I get very good convergence of the flow solution in the channel. The solution is just absent the blockage and no slip velocity condition that I want to provide by the sphere.\nThank you again for your advise and help.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-808578",
                          "updatedAt": "2022-07-27T20:57:11Z",
                          "publishedAt": "2021-05-31T20:48:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "@TLWise Is domain 2 moving? Does domain 2 deform?\nIf so, it seems like an actual FSI example.",
                  "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-811528",
                  "updatedAt": "2022-07-27T20:57:11Z",
                  "publishedAt": "2021-06-01T15:10:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for your interest. Domain 2 is not intended to deform, but is expected to move due to forces from domain 1 and vise versa domain 1 to respond to position of domain 2. Almost fsi but without ALE (mesh movement).",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-811550",
                          "updatedAt": "2022-12-13T17:36:52Z",
                          "publishedAt": "2021-06-01T15:15:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "How far domain 2 needs to move? The movement is relatively small or large? It will determine what method we could use.\nALE is referred to as how do we define the fluid domain. Even the domain 2 is rigid, ALE still can be used in domain 1 because domain 2 is moving. One issue with the ALE is that we need to remesh domains  if domain 2 is moving too much (i.e., from the inlet to the outlet). Remeshing is not easy in general, especially in parallel.\nAn alternative way might be immersed boundary method where we do not need to remesh and a fixed mesh is used. But we might lose the interpolation accuracy between domain 1 and domain 2.\nWhat equations are you using to define the movement of domain 2 because of the stress from domain 1?  Is it a simple relation?",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-811665",
                          "updatedAt": "2022-12-13T17:36:52Z",
                          "publishedAt": "2021-06-01T15:38:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "The immersed boundary method appears to be the solution that I am looking to implement. Domain 2 is allowed to move to any extent within the boundaries of domain 1, but is to be constrained to not cross out of the boundaries of domain 1.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-811706",
                          "updatedAt": "2022-12-13T17:36:52Z",
                          "publishedAt": "2021-06-01T15:44:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "The only other influence on domain 2 outside fluid stress is gravity force.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-811715",
                          "updatedAt": "2022-12-13T17:36:53Z",
                          "publishedAt": "2021-06-01T15:46:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@fdkong Immersed boundary method is like a VOF method right?\nOk for domain 2 staying in domain 1, but do you want the domain 2 mesh to move, or do you want to just be tracking relative fractions of 2 and 1 in a fixed mesh?",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-818959",
                          "updatedAt": "2022-12-13T17:36:59Z",
                          "publishedAt": "2021-06-03T05:20:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for your continued advice and support with this. I would like to observe the motion of domain 2 within domain one. I have been able to run the model, but I have not observed the effects of each domain on the flow and position solutions.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-823016",
                          "updatedAt": "2022-09-12T09:58:23Z",
                          "publishedAt": "2021-06-03T19:14:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "In the model that I have made. The particle mesh already exist as a subdomain as well as the fluid subdomain. The fsi formulation that I am basing my model on uses the SubdomainBoundingBoxGenerator which appears to constrain me to portions of a square or rectangular subdomain vise the circle that I am trying to track. Also is it required that I specify a bounding box coordinate in SubdomainBoundingBoxGenerator since the subdomains are already defined?",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-837360",
                          "updatedAt": "2022-09-12T09:58:24Z",
                          "publishedAt": "2021-06-07T23:39:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any progress on this?\nSubdomainBoundingBoxGen might not be the one you need here. You should have the two blocks defined in the mesh before loading it in MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-899275",
                          "updatedAt": "2022-09-12T09:58:25Z",
                          "publishedAt": "2021-06-21T17:42:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for remaining engaged in assist with the issue. I had some success using the bounding box approach. What I found in using it, is that the effects of the motion of the bounded region on the mesh deforms the mesh similar to two separate mesh domains with one having motion internal to the other. I need to determine how to do at least two things:\n\nDefine a bounding shape (circle, oval, octagon, etc.) other than a rectangle.\nRedefine the bounding shape in the next time step based on the new translation coordinates of the previous time step.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-899409",
                          "updatedAt": "2022-09-12T09:58:25Z",
                          "publishedAt": "2021-06-21T18:17:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you will have to add a new mesh generator to do 1. If you could make a parsed expression one I think that would be more valuable than just adding circle. Let us know if you need help with that.\n\nmight be tricky. @fdkong do you know how to have the mesh be reset at every time step and mesh generators be ran again?",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-917105",
                          "updatedAt": "2022-12-13T17:37:50Z",
                          "publishedAt": "2021-06-24T18:42:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Demagnetizing Field and Custom Kernel",
          "author": {
            "login": "alanchavez86"
          },
          "bodyText": "Hi all!\nI've asked a similar question before and received a great discussion! I wanted to run by some thoughts I had for solving for the demagnetizing field of FeCrCo.\nIn the last discussion, I was given a couple equations to work with that resembled ones that I've been working with that make the problem easier to work with:\n\nand\n\nI wanted to make sense of this and computed the weak form of the first equation:\n\nSince I'm trying to calculate for psi, how would I go about creating a custom kernel for that? If I have a custom kernel for \u2207\u22c5M, would I combine that with a kernel for \u2207^2 \u03a8? Also, \u2207^2 \u03a8 is very similar to the diffusion kernel in moose, so would it be alright to use that?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/17899",
          "updatedAt": "2022-06-17T09:16:54Z",
          "publishedAt": "2021-05-20T18:13:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "alanchavez86"
                  },
                  "bodyText": "In this case, M should be the saturation magnetization (M = M(c)). The first source I'm attaching is from Koyama 2004. I'm assuming I can implement a material property that defines M as Ms*m(r).\nKoyama_2004.pdf\nA custom kernel was created for del M and I was wondering how that would be put together with psi in this equation:\n\nHere is the .C file that I created for del M:\n#include \"MagnetizationVector.h\"\n/**\n\nAll MOOSE based object classes you create must be registered using this macro.  The first\nargument is the name of the App you entered in when running the stork.sh script with an \"App\"\nsuffix. If you ran \"stork.sh Example\", then the argument here becomes \"ExampleApp\". The second\nargument is the name of the C++ class you created.\n*/\nregisterMooseObject(\"fecrcoApp\", MagnetizationVector);\n\n/**\n\nThis function defines the valid parameters for\nthis Kernel and their default values\n*/\ntemplate <>\nInputParameters\nvalidParams()\n{\nInputParameters params = validParams();\nparams.addRequiredParam(\"mag x\", \"X direction Vector\");\nreturn params;\n}\n\nMagnetizationVector::MagnetizationVector(const InputParameters & parameters)\n: // You must call the constructor of the base class first\nKernel(parameters),\nm(getParam(\"mag x\"))\n{\n}\nReal\nMagnetizationVector::computeQpResidual()\n{\n//  RealVectorValue m(_mag_x[_qp]);\nreturn - m*_grad_test[_i][_qp];\n}\nI removed _mag_x[_qp], _mag_y[_qp], and _mag_z[_qp] because I was assuming the vector direction wouldn't matter at higher temperatures. Here is the last part of my .h file that I modified for the custom kernel to compile correctly:\nprivate:\n/**\n\nA vector object for storing the velocity.  Convenient for\ncomputing dot products.\n*/\nRealVectorValue m;\n\nIf my del M custom kernel is correct, could I combine that with the Diffusion kernel to satisfy the Poisson Equation I have and how would that be done? Here is another file that I'm referencing for the demagnetizing energy:\nFeng_2017_Peritectic PF Mag.pdf",
                  "url": "https://github.com/idaholab/moose/discussions/17899#discussioncomment-789262",
                  "updatedAt": "2022-06-17T09:17:26Z",
                  "publishedAt": "2021-05-26T22:13:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@mangerij @cticenhour",
                          "url": "https://github.com/idaholab/moose/discussions/17899#discussioncomment-898911",
                          "updatedAt": "2022-06-17T09:18:02Z",
                          "publishedAt": "2021-06-21T16:24:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "Sorry, I didn't see the first post. I was on a bit of a vacation so sorry for the delay here.\nYeah, this should work. You can have two separate Kernels for the two terms in the Poisson equation (just make sure the signs are right!). The surface terms in the equation either drop out or are handled naturally within MOOSE. As for your pseudo code here:\nNote that m*_grad_test[_i][_qp] should be a dot product because _grad_test[_i][_qp] is a vector (gradient of a scalar function). This is where Koyama2004 confuses me because he seems to be concerned with the vector value of the magnetization.\nAlso, the magnetization should depend explicitly on the concentration. What you could do is write an AuxKernel to calculate the magnetization m = m(c(r)) and then call this AuxVariable in your Kernel for grad*m. I am not sure if you need to calculate the off-diagonal terms for dm/dc in the Kernel for grad\"m -  you might :)",
                          "url": "https://github.com/idaholab/moose/discussions/17899#discussioncomment-903137",
                          "updatedAt": "2022-06-17T09:18:02Z",
                          "publishedAt": "2021-06-22T07:58:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "Thanks for the advice John! I just posted a different discussion that me and my colleague are looking into to solve for the magnetic potential! We modified the CoefDiffusion Kernel to take a function and solve for phi with good results. Now the question is how can we can add a material property that can act as the function and solve for phi.",
                          "url": "https://github.com/idaholab/moose/discussions/17899#discussioncomment-912429",
                          "updatedAt": "2022-06-17T09:18:16Z",
                          "publishedAt": "2021-06-23T22:28:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "_grad_test variable type using ADKernel? I'm getting an error saying multiplication is an invalid operation.",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "Hi, I'm completely new to Moose. I was following the tutorial posted to YouTube and modifying things here and there, but I'm having trouble computing the residual for a simple diffusion equation. What I have is very similar to the DarcyPressure.C tutorial, but the error message I get says the multiplication \"*\" operand is invalid. Below is the very simple kernel I'm trying to implement:\n`\n#include \"FlowNet.h\"\n#include \"DerivativeMaterialInterface.h\"\nregisterMooseObject(\"farmApp\", FlowNet);\nInputParameters\nFlowNet::validParams()\n{\nInputParameters params = ADKernel::validParams();\nparams.addClassDescription(\"Calculate flow potential under flownet\");\nreturn params;\n}\nFlowNet::FlowNet(const InputParameters & parameters)\n: DerivativeMaterialInterface(parameters),\n_permeability(getMaterialPropertyByName<Real>(\"permeability\"))\n\n{\n}\nADReal\nFlowNet::computeQpResidual()\n{\n/// isotropic permeability\nconst auto & k = _permeability;\nreturn k * _grad_test[_i][_qp] * _grad_u[_qp];\n\n}\n`\nwith the error message:\nerror: no match for 'operator*' (operand types are 'const MaterialProperty' and 'const value_type' {aka 'const libMesh::VectorValue<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true> >'})\nI am also aware that if I use the \"ADKernelGrad\" then I won't need to explicitly add \"_grad_test\" myself, but I wanted to do it with ADKernel.",
          "url": "https://github.com/idaholab/moose/discussions/18146",
          "updatedAt": "2022-11-10T21:02:26Z",
          "publishedAt": "2021-06-23T05:31:55Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "k is a material property right?\nSo it'd be k[_qp] not k to get the value at the quadrature point",
                  "url": "https://github.com/idaholab/moose/discussions/18146#discussioncomment-908248",
                  "updatedAt": "2022-11-10T21:02:31Z",
                  "publishedAt": "2021-06-23T06:06:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Yes, its a scalar value for the permeability. Would it still be k[_qp] in that case? I don't see how, since it is a single value. I tried it though, and it worked! But I'm not sure why.\nThe example on the tutorial also left it as is (didn't index the quadrature point). (https://youtu.be/2tJwBsYaLaI @3:49:19) mark.",
                          "url": "https://github.com/idaholab/moose/discussions/18146#discussioncomment-908303",
                          "updatedAt": "2022-11-10T21:02:40Z",
                          "publishedAt": "2021-06-23T06:30:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Well in the header for that source file, you can see if it s a scalar (Real or ADReal) or a MaterialProperty\nYou may set it as a scalar in the input file, but MOOSE can convert scalars to material properties when needed",
                          "url": "https://github.com/idaholab/moose/discussions/18146#discussioncomment-908310",
                          "updatedAt": "2022-11-10T21:02:43Z",
                          "publishedAt": "2021-06-23T06:32:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "I see. That makes sense. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18146#discussioncomment-908316",
                          "updatedAt": "2022-11-10T21:02:45Z",
                          "publishedAt": "2021-06-23T06:33:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "stochastictool - transient_outputs",
          "author": {
            "login": "purepuremilk-zz"
          },
          "bodyText": "Hello, I am running a transient problem with stochastictool. In my transient input file, I have a vectorprocessor that dumps vectors at every time step, which gives me 100 CSVs if I am having 100 steps and output as CSVs. My postprocessor looks like:\n[VectorPostprocessors] [T_sample] type = LineValueSampler num_points = 100 start_point = '0 0.5 -2.5' end_point =   '0 0.5 2.5' variable = T sort_by = z [] []\nNow I am using stochastictool to sample the boundary conditions and would like to gather outputs all transient data from each sample. I am currently using 'Reporter' and 'Transfers'. Meanwhile, I used JSON output as instructed in issue #17895. However, I am having only one vector for each sample instead of all 100 steps in the JSON file. What should I do to output all 100 steps for each sample? Follows are my code for 'Reporter', 'Transfers', and 'Outputs'\n[Transfers] [data] type = SamplerReporterTransfer multi_app = runner execute_on = 'timestep_end' sampler = hypercube stochastic_reporter = storage from_reporter = 'T_sample/z T_sample/T' [] [] [Reporters] [storage] type = StochasticReporter execute_on = 'timestep_end' [] [] [Outputs] [out] type = JSON execute_system_information_on = none [] []",
          "url": "https://github.com/idaholab/moose/discussions/18139",
          "updatedAt": "2022-06-14T20:22:32Z",
          "publishedAt": "2021-06-22T18:32:54Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "If you are using SamplerFullSolveMultiApp, this capability is not available, although we are actively working on it. Another option is to use SamplerTransientMultiApp, but you will need to have a constant time step defined in the main input. This will perform the transfer and output at each time step.",
                  "url": "https://github.com/idaholab/moose/discussions/18139#discussioncomment-907269",
                  "updatedAt": "2023-09-14T14:19:45Z",
                  "publishedAt": "2021-06-22T21:56:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "This will also cause a significant slow down because the simulations need to stop at every time step. I think we will be doing some work in this area soon(ish).",
                          "url": "https://github.com/idaholab/moose/discussions/18139#discussioncomment-907521",
                          "updatedAt": "2023-09-14T14:19:49Z",
                          "publishedAt": "2021-06-22T23:44:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Variable for use Only in Boundary Condition",
          "author": {
            "login": "AngeloCass"
          },
          "bodyText": "Hello,\nI am wondering if there is a way to have a variable that exists only in a boundary condition and does not require use in a kernel. This variable only exists at the surface or 'top' of the domain or 'mesh'. The variable is coupled with two others in the governing equation. Optimally, I would like to solve for this value only on the surface and neglect it elsewhere. I have not found an effective way to do this. If anyone could provide information on how I may accomplish this, it would be much appreciated.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/18141",
          "updatedAt": "2023-02-16T22:48:39Z",
          "publishedAt": "2021-06-22T19:53:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can define a block for your sideset/nodeset of interest, then claim the variable to be block-restricted, i.e.\n[Variables]\n  [u]\n    block = top\n  []\n[]\n\nYou may or may not need to turn off the kernel coverage check depending on your setup.",
                  "url": "https://github.com/idaholab/moose/discussions/18141#discussioncomment-907394",
                  "updatedAt": "2023-02-16T22:48:47Z",
                  "publishedAt": "2021-06-22T22:48:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Perhaps LowerDBlockFromSidesetGenerator or ParsedSubdomainMeshGenerator will be of use.  @hugary1995 is suggesting you'll have to include the following in your input file\n[Problem]\n  kernel_coverage_check = false\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18141#discussioncomment-907419",
                          "updatedAt": "2023-02-16T22:48:41Z",
                          "publishedAt": "2021-06-22T22:57:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Symmetry Condition for Plane not Aligned with Cartesian Planes",
          "author": {
            "login": "elementx54"
          },
          "bodyText": "I've got a cylindrical mesh that has a symmetry wedge from 0 to 72 degrees. I'd like to use symmetric boundary conditions to avoid having to simulate the entire cylinder. I understand how to set displacements to zero for symmetric conditions when a symmetry plane is orthogonal to the displacement axis in Cartesian coordinates\nSo my question, is there a boundary condition for tensor mechanics that will allow me to set symmetry displacement conditions on my 72 degree surface whose symmetry plane is not orthogonal to any Cartesian displacement?\nMy geometry is 3D with features that do not allow it to be 2D, 1D, 2D RZ, or 1D RZ.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/18135",
          "updatedAt": "2022-08-21T11:30:14Z",
          "publishedAt": "2021-06-22T10:57:57Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Take a look at inclined no disp BCs https://mooseframework.inl.gov/syntax/BCs/InclinedNoDisplacementBC/index.html",
                  "url": "https://github.com/idaholab/moose/discussions/18135#discussioncomment-906166",
                  "updatedAt": "2022-08-21T11:30:14Z",
                  "publishedAt": "2021-06-22T16:45:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "elementx54"
                          },
                          "bodyText": "I tried that with a penalty of 1e9 and my surface did not stay in the plane. Do I just need a higher penalty? Can you put in too high of a penalty?",
                          "url": "https://github.com/idaholab/moose/discussions/18135#discussioncomment-906833",
                          "updatedAt": "2022-08-21T11:30:14Z",
                          "publishedAt": "2021-06-22T19:40:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Most likely yes. But this could also happen if your penalty is too high. I would start with a penalty that is 1x~100x the young's modulus. Automatic scaling also helps to some extent.\nWell, this is the common problem with penalty methods. I remember someone was developing a Nitsche's version, but I don't know the current status of that.",
                          "url": "https://github.com/idaholab/moose/discussions/18135#discussioncomment-907402",
                          "updatedAt": "2022-08-21T11:30:14Z",
                          "publishedAt": "2021-06-22T22:52:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MultiApps - multi core questions",
          "author": {
            "login": "MatiasAllay"
          },
          "bodyText": "Hi MOOSE,\nI'm currently running a simulation using Multiapps. The mode is batch-reset and as a sampler I'm using a CSVSampler that has only two columns but many rows. I'm also using MultiAppCommandLineControl to change materials parameters as it was suggested here #18046. My problem now is that even though I'm using multiple cores when I call the simulation, for each simulation MOOSE is only using one core for each \"multiapp\" (and running one \"multiapp\" at time). Any advice in how can I force MOOSE to use all the available cores?\nCheers,\nMatias",
          "url": "https://github.com/idaholab/moose/discussions/18098",
          "updatedAt": "2022-05-31T08:24:16Z",
          "publishedAt": "2021-06-16T13:59:41Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "By default, each multiapp  uses 1 processor. You can set min_procs_per_app in your MultiApp block  to use multiple processors for each multiapp.",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-878538",
                  "updatedAt": "2022-06-05T05:32:44Z",
                  "publishedAt": "2021-06-16T14:30:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHave you tried using the min_procs_per_app and min_procs_per_row parameters?\nSee documentation there https://mooseframework.inl.gov/source/multiapps/SamplerFullSolveMultiApp.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-878539",
                  "updatedAt": "2022-06-05T05:32:44Z",
                  "publishedAt": "2021-06-16T14:30:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MatiasAllay"
                  },
                  "bodyText": "Hi MOOSE,\nThanks for your help! I added  min_procs_per_app in my MultiApps block and also min_procs_per_row in my Samplers block as is suggested in the documentation (https://mooseframework.inl.gov/source/multiapps/SamplerFullSolveMultiApp.html) and I set it with the number of processors I want to use, but nothing happens (simulation still runs with one processor although MOOSE \"blocks\" all the available processors).\nAny idea of what else could I try?\nThanks!!\nMatias",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-881763",
                  "updatedAt": "2022-06-05T05:32:45Z",
                  "publishedAt": "2021-06-17T07:19:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "@zachmprince Might have some insight into what is happening, if I recall he implemented this capability.",
                          "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-883574",
                          "updatedAt": "2022-06-11T18:57:54Z",
                          "publishedAt": "2021-06-17T14:18:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MatiasAllay"
                          },
                          "bodyText": "Hi @aeslaughter how could we proceed? Shall we move this issue somewhere else? Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-897406",
                          "updatedAt": "2022-06-11T18:57:54Z",
                          "publishedAt": "2021-06-21T11:58:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "Thanks for your help! I added min_procs_per_app in my MultiApps block and also min_procs_per_row in my Samplers block as is suggested in the documentation (https://mooseframework.inl.gov/source/multiapps/SamplerFullSolveMultiApp.html) and I set it with the number of processors I want to use, but nothing happens (simulation still runs with one processor although MOOSE \"blocks\" all the available processors).\n\nCould you post the multiapp block of your input file?  I went through SamplerFullSolveMultiApp, but  I did not see anything special.",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-898329",
                  "updatedAt": "2022-06-11T18:57:54Z",
                  "publishedAt": "2021-06-21T14:56:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "Apologies, I just noticed this discussion. I created an input using a SamplerCSV. You can find the main and sub inputs here. It seemed to work fine with min_procs_per_app and using mpiexec -n 4. It would be helpful to see your input though.",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-898668",
                  "updatedAt": "2022-06-11T18:58:34Z",
                  "publishedAt": "2021-06-21T16:02:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MatiasAllay"
                  },
                  "bodyText": "Hi all,\nThanks for your kind reply. Thanks @zachmprince for the example. I missed the StochasticTools block in my subApp:\n[StochasticTools]\n[]\nNow my simulation seems to run fine!\nThanks\nMatias",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-899344",
                  "updatedAt": "2022-06-11T18:58:38Z",
                  "publishedAt": "2021-06-21T18:01:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "Be careful with that syntax. If you use that, the problem won't actually solve. I put that in my sub app input because I'm just testing the partitioning and not solving a problem.",
                          "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-900265",
                          "updatedAt": "2022-06-11T18:58:40Z",
                          "publishedAt": "2021-06-21T23:46:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MatiasAllay"
                          },
                          "bodyText": "You are right... I got excited that my simulation was running fast with  [StochasticTools] in the subApp that I didn't noticed that nothing was happening :(. But today I tried running your example and I got an updated warning, so I updated and now seems to work fine!\nThanks again!\nMatias",
                          "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-905386",
                          "updatedAt": "2022-06-11T18:58:39Z",
                          "publishedAt": "2021-06-22T14:27:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Surplus E files after executing s3_decomp.i",
          "author": {
            "login": "rl3fz"
          },
          "bodyText": "Hello, I've executed the 's3_decomp.i' file for spinodal decomposition (Step 3 of the phase field tutorial), but in addition to the corresponding file (of type E), 82 other files (of type E-S002, E-S003, E-S004, etc.) were created.\n\nThis didn't happen in previous steps, and by process of elimination the added files seem to be a result of the changes to the mesh and executioner blocks for adaptive meshing.\nIs this supposed to happen? I don't see any difference in mesh quality between the E-S002 file and the E-S083 files, so I'm not sure why they would be necessary in the first place. If this shouldn't happen, advice on preventing it would be greatly appreciated.\n\nI'm also not sure whether I should be using the [./elapsed] or [./active_time] postprocessor to determine the time spent on the simulation. They both seem to work fine, but if one is outdated or has another use, I would appreciate any info here too (I couldn't find documentation for either).",
          "url": "https://github.com/idaholab/moose/discussions/18076",
          "updatedAt": "2023-03-28T15:47:47Z",
          "publishedAt": "2021-06-11T21:14:35Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GregVernon"
                  },
                  "bodyText": "Exodus doesn't (yet) support dynamic mesh topology within a single Exodus file, instead they create a new \"state\" Exodus file (the e-sXXX files) if the mesh connectivity (topology) changes.  Dynamic mesh topology is often caused by using mesh-adaptivity.  ParaView is able to recognize these \"extra\" Exodus files as being sequential so this shouldn't affect visualization in ParaView, if that's a concern.\nYou can find out more about the dynamic topology and Exodus from the SEACAS project page here.",
                  "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-860369",
                  "updatedAt": "2023-03-28T15:47:47Z",
                  "publishedAt": "2021-06-11T22:41:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-905197",
                          "updatedAt": "2023-03-28T15:47:47Z",
                          "publishedAt": "2021-06-22T13:58:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @rl3fz\nYes, it's normal.\nThat happens also if you use element elimination methods that modify the mesh,\nfor instance the one described here:\nhttps://arxiv.org/abs/2105.13257\nand the test cases here:\nhttps://github.com/idaholab/moose/tree/next/test/tests/userobjects/element_subdomain_modifier\nIf you open the main .e file in paraview, the one without -s*,\nall the time steps will be automatically accessible in paraview.\nJust don't delete the -s* files .\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-865273",
                  "updatedAt": "2023-03-28T15:47:51Z",
                  "publishedAt": "2021-06-13T15:43:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-905196",
                          "updatedAt": "2023-03-28T15:47:51Z",
                          "publishedAt": "2021-06-22T13:57:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Wrt to the postprocessors you should use, the PerfGraphData should have all you need for timing your application.\nNote that [./elapsed] or [./active_time] are just the name of the objects, they can be set to anything. What matters for you is the type of the object",
                  "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-900082",
                  "updatedAt": "2023-03-28T15:47:51Z",
                  "publishedAt": "2021-06-21T22:01:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-905200",
                          "updatedAt": "2023-03-28T15:47:51Z",
                          "publishedAt": "2021-06-22T13:58:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Use of CoupledPenaltyInterfaceDiffusion with vectors",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I am using the CoupledPenaltyInterfaceDiffusion interface kernel with velocity which is defined as a LAGRANGE_VEC, I have defined the velocity components  (vel_x, vel_y) as AuxKernels. During execution of the code an error is displayed for the variables (velocity, vel_x, vel_y) that I am attempting to use within CoupledPenaltyInterfaceDiffusion. The error indicates that neither of these variables is of the nonlinear type expected by the Kernel. Is there a way to transform these values for use in the CoupledPenaltyInterfaceDiffusion interface kernel?",
          "url": "https://github.com/idaholab/moose/discussions/18068",
          "updatedAt": "2021-07-08T00:48:53Z",
          "publishedAt": "2021-06-11T12:21:24Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi\nThe CoupledPenaltyInterfaceDiffusion expects a non vector variable. You will have to either recode this interface kernel to use a vector variable or use 3 non linear variables for each component of velocity.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18068#discussioncomment-900075",
                  "updatedAt": "2021-06-21T21:56:33Z",
                  "publishedAt": "2021-06-21T21:56:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}