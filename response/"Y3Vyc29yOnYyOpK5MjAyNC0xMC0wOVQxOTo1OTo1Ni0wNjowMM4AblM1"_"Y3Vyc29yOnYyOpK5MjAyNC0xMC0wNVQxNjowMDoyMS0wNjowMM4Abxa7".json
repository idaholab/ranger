{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMC0wNVQxNjowMDoyMS0wNjowMM4Abxa7"
    },
    "edges": [
      {
        "node": {
          "title": "Array nodal bcs for eigenproblem",
          "author": {
            "login": "xieeeect"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI'm working on a array nodal boundary condition for eigenvalue problems, it describes like: M * U = 0 , M is an n*n matrix, and U is an array variable. However, I didn't find any BCS about it, and when developing a new bcs with 'ArrayNodalBC', I got an error:\n\"Invalid NodalBC for eigenvalue problems, please use homogeneous (array) Dirichlet.\"\nThanks for your time,\nxieeeect",
          "url": "https://github.com/idaholab/moose/discussions/28455",
          "updatedAt": "2024-10-10T01:52:55Z",
          "publishedAt": "2024-08-22T09:32:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@YaqiWang I think we have had this conversation before.\nDo you recall the conclusions? What kind of BCs can be used for eigenvalue problems?",
                  "url": "https://github.com/idaholab/moose/discussions/28455#discussioncomment-10419142",
                  "updatedAt": "2024-08-22T12:58:05Z",
                  "publishedAt": "2024-08-22T12:58:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "or @lindsayad I think you know exactly what's up  here considering your latest work",
                          "url": "https://github.com/idaholab/moose/discussions/28455#discussioncomment-10420753",
                          "updatedAt": "2024-08-22T15:15:28Z",
                          "publishedAt": "2024-08-22T15:15:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The short answer is that I do not know the theory well enough to say what BCs can theoretically be used for eigenvalue problems. I can only speak to the implementation which is that we only allow homogeneous BCs in MOOSE.\nFrom the libMesh side we now allow solving eigenproblems with arbitrary constraints in which we condense out the constrained degrees of freedom when performing the eigensolve. We then enforce the constraints post-eigensolve on the requested eigenvector",
                          "url": "https://github.com/idaholab/moose/discussions/28455#discussioncomment-10896790",
                          "updatedAt": "2024-10-09T20:13:58Z",
                          "publishedAt": "2024-10-09T20:13:44Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xieeeect"
                          },
                          "bodyText": "Thanks for the answer, I have a general understanding of the rules for handling BCs for eigenvalue problems, and next I will study the idea you said.  : )",
                          "url": "https://github.com/idaholab/moose/discussions/28455#discussioncomment-10898572",
                          "updatedAt": "2024-10-10T01:52:55Z",
                          "publishedAt": "2024-10-10T01:52:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Accessing global stiffness and mass matrix for debugging",
          "author": {
            "login": "adhithya96"
          },
          "bodyText": "Is there a way to access the global jacobian or stiffness matrix and mass matrix in MOOSE ? I am trying to solve eigenvalue problem and I am not getting the results as expected.",
          "url": "https://github.com/idaholab/moose/discussions/27407",
          "updatedAt": "2024-10-09T20:02:01Z",
          "publishedAt": "2024-04-18T11:54:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nyou can print it with -ksp_view_pmat in the petsc options or on the command line\nyou can also output to a matlab readable format iirc\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27407#discussioncomment-9154275",
                  "updatedAt": "2024-04-18T12:07:03Z",
                  "publishedAt": "2024-04-18T12:06:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "adhithya96"
                          },
                          "bodyText": "Thanks for the input. I checked petsc manual and found the solution. Adding  -mat_view ::ascii_matlab. in command line while running the executable works. -mat_view :filename.m:ascii_matlab. prints the data into a matlab file.\nI was going through the source files of MOOSE to see where I can use std::cout for a few hours",
                          "url": "https://github.com/idaholab/moose/discussions/27407#discussioncomment-9154768",
                          "updatedAt": "2024-04-18T12:52:53Z",
                          "publishedAt": "2024-04-18T12:52:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adhithya96"
                          },
                          "bodyText": "Is there anyway I can see how the global stiffness matrix  is solved  from the source code file ? Or  are the calls being made to slepc and slepc solves the problem ?",
                          "url": "https://github.com/idaholab/moose/discussions/27407#discussioncomment-9154883",
                          "updatedAt": "2024-04-18T13:04:39Z",
                          "publishedAt": "2024-04-18T13:04:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Back to your first question, I should know about how to print mass matrix but I dont\n@lindsayad if you have time to teach us\nYou can use the Debug/show_execution_order flag to see a little bit of how the Jacobian is assembled.\nOtherwise you need to dig into the code\nSLEPc definitely solves eigenvalue problems, with callbacks to moose to compute various quantities like the residual and the Jacobian\nAre eigenvalue problems what you are doing?",
                          "url": "https://github.com/idaholab/moose/discussions/27407#discussioncomment-9156502",
                          "updatedAt": "2024-04-18T15:26:15Z",
                          "publishedAt": "2024-04-18T15:23:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "In almost all MOOSE simulations only a single matrix is formed for solving the linear problem at each Newton iteration: $J \\delta u = -R$ where $J$ is the Jacobian, $\\delta u$ is the (candidate) solution update, and $R$ is the residual. We do not separate a mass matrix or stiffness matrix. There are ways you can create those matrices, but before we talk about how to do that, it's probably worthwhile to learn more about what your problem is.\nMost people doing eigenvalue calculations in MOOSE do some free power iterations to generate a good initial guess and then do a Newton solve to get the fundamental mode. Is this what you're doing? In such a case, when solving the generalized eigenvalue problem $(Ax) = \\lambda (Bx)$, MOOSE provides function evaluations for $Ax$ and $Bx$ and then preconditioning is usually done only with some approximation of $A$ so again only a single matrix data structure is formed",
                          "url": "https://github.com/idaholab/moose/discussions/27407#discussioncomment-9157476",
                          "updatedAt": "2024-04-18T16:48:37Z",
                          "publishedAt": "2024-04-18T16:48:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adhithya96"
                          },
                          "bodyText": "@lindsayad\nYes. I am solving eigenvalue problem. I am evaluating the stiffness matrix using MatDiffusion and  mass matrix using CoefReaction. I have been trying to implement the bloch type periodic boundary condition. Trying to print matrices  to see if I can figure out where I am going wrong.",
                          "url": "https://github.com/idaholab/moose/discussions/27407#discussioncomment-9162150",
                          "updatedAt": "2024-04-19T05:07:10Z",
                          "publishedAt": "2024-04-19T05:07:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "periodic boundary conditions introduce constraints that the current eigen classes in MOOSE have problems solving. In order to correctly solve problems with constraints, we have libMesh/libmesh#3821 and #27276 in progress",
                          "url": "https://github.com/idaholab/moose/discussions/27407#discussioncomment-9169053",
                          "updatedAt": "2024-04-19T17:04:03Z",
                          "publishedAt": "2024-04-19T17:04:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "In almost all MOOSE simulations only a single matrix is formed for solving the linear problem at each Newton iteration: J \u03b4 u = \u2212 R where J is the Jacobian, \u03b4 u is the (candidate) solution update, and R is the residual. We do not separate a mass matrix or stiffness matrix. There are ways you can create those matrices, but before we talk about how to do that, it's probably worthwhile to learn more about what your problem is.\nMost people doing eigenvalue calculations in MOOSE do some free power iterations to generate a good initial guess and then do a Newton solve to get the fundamental mode. Is this what you're doing? In such a case, when solving the generalized eigenvalue problem ( A x ) = \u03bb ( B x ) , MOOSE provides function evaluations for A x and B x and then preconditioning is usually done only with some approximation of A so again only a single matrix data structure is formed\n\nDoes -mat_view return the sum of the mass and stiffness matrices? What would be the way to obtain them separately?",
                          "url": "https://github.com/idaholab/moose/discussions/27407#discussioncomment-10698558",
                          "updatedAt": "2024-09-19T23:09:27Z",
                          "publishedAt": "2024-09-19T23:09:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "It will return the sum. You could explore the tagging system if you want to separate out contributions to the system matrix",
                          "url": "https://github.com/idaholab/moose/discussions/27407#discussioncomment-10896692",
                          "updatedAt": "2024-10-09T20:02:02Z",
                          "publishedAt": "2024-10-09T20:02:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to Solve a 4th-Order Partial Differential Equation in MOOSE",
          "author": {
            "login": "zzzmx-josh"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi MOOSE team and community,\nI am trying to solve a 4th-order partial differential equation of the form:\n\nwith periodic boundary conditions for \ud835\udc62. I would like to ask if there is a straightforward way to solve such an equation in MOOSE? I understand that typically, this kind of high-order equation might be challenging to solve directly. Is the only viable approach to introduce intermediate variables and reduce the system into lower-order equations (for example, by introducing new variables for the second derivatives)?\nAny guidance or suggestions on how to implement this in MOOSE would be greatly appreciated!\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/28788",
          "updatedAt": "2024-10-09T01:15:10Z",
          "publishedAt": "2024-10-06T16:54:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI can't think of a direct way here\n\nIs the only viable approach to introduce intermediate variables and reduce the system into lower-order equations (for example, by introducing new variables for the second derivatives)?\n\nthis should work. We have coupledSecond in the coupleable API to let you represent these terms.\nstart with a second order mesh (Mesh/second_order = true) and have at least 2nd order variables for the intermediate variable(s)",
                  "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10859901",
                  "updatedAt": "2024-10-06T17:34:10Z",
                  "publishedAt": "2024-10-06T17:34:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zzzmx-josh"
                          },
                          "bodyText": "Thank you for the guidance! But I\u2019m still not sure how coupledSecond works. Do I need to write a new Kernel to introduce intermediate variables? Or could you please provide a simple example of setting up the intermediate variables and Kernels in MOOSE?\nThanks for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10862226",
                          "updatedAt": "2024-10-07T02:28:16Z",
                          "publishedAt": "2024-10-07T02:28:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You ll want to solve a system with additional variables for the second order derivatives\n[Variables]\n  [u]\n    order = SECOND\n  []\n  [d2udx2]\n    order = SECOND\n  []\n  [d2udy2]\n    order = SECOND\n  []\n  [d2udz2]\n    order = SECOND\n  []\n[]\n\nthen make new kernels for using coupledSecond (I didnt find any that fits)\nYou ll need kernels for four equations.\nd2udx2 = u_xx (if you know what I mean, one is the variable, the other is from coupledSecond)\nd2udy2 = u_yy\nd2udz2 = u_zz\nd2udx2_xx + d2udy2_yy + d2udz2_zz = f\n\nso 10 kernels, with at least one new one to make for the double derivative operation (add a component parameter to avoid having to make 3)",
                          "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10862305",
                          "updatedAt": "2024-10-07T02:50:19Z",
                          "publishedAt": "2024-10-07T02:50:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zzzmx-josh"
                          },
                          "bodyText": "I have two follow-up questions regarding the previous response:\n\n\nWhen solving the first three equations (e.g., d2udx2=u_xx), should I use coupledGradient(\"u\") * grad_test to represent u_xx, or can I directly use coupledSecond(\"u\")  in computeQpResidual?\n\n\nFor the equation  d2udx2_xx + d2udy2_yy + d2udz2_zz = f, how do I solve for the three variables? Since each Kernel in MOOSE can only act on one variable, do I need to solve this equation three separate times for d2udx2, d2udy2, and d2udz2?\nIn that case, why are 10 Kernels needed as mentioned earlier?\n\n\nThank you for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10862459",
                          "updatedAt": "2024-10-07T03:29:16Z",
                          "publishedAt": "2024-10-07T03:29:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you should use \"coupledSecond(\"u\")\" in the constructor's initializer's list to initialize a reference to this value, rather than use it in computeQpResidual\nplease see how coupledValue is used in the coupledForce kernel for example\nyou do not need grad_test\n\nhow do I solve for the three variables\n\nthe \"variable\" parameter of the kernel is first and foremost the equation number. You can have variables in that equation that are coupled in. I would expect this syntax for this last equation\n[Kernels]\n  [d4udx4]\n    type = SecondDerivative\n    variable = u\n    variable_to_take_the_derivative_of = d2udx2\n    component = 'x'\n   []\n  [d4udy4]\n    type = SecondDerivative\n    variable = u\n    variable_to_take_the_derivative_of = d2udy2\n    component = 'y'\n   []\n  [d4udz4]\n    type = SecondDerivative\n    variable = u\n    variable_to_take_the_derivative_of = d2udz2\n    component = 'z'\n   []\n   [f]\n    type = BodyForce\n    variable = u \n    function = f\n  []\n[]\n\nI m picking 'u' as the variable for that equation but that might not be the better choice, since u does not appear in it so there will be 0 on the diagonal of the Jacobian and it will struggle for the inversion",
                          "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10862615",
                          "updatedAt": "2024-10-07T04:19:24Z",
                          "publishedAt": "2024-10-07T04:06:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zzzmx-josh"
                          },
                          "bodyText": "it's a little weird for me to understand that in the equation d2udx2_xx + d2udy2_yy + d2udz2_zz = f, there is no variable u, but can this equation still be used to solve for u?\nI would like to know if my implementation of SecondDerivative is correct according to my understanding:\nReal SecondDerivative::SecondDerivative(const InputParameters &parameters)\n    : Kernel(parameters),\n      _v(coupledValue(\"variable_to_take_the_derivative_of\")),\n      _grad_v(coupledGradient(\"variable_to_take_the_derivative_of\")),\n      _component(getParam<unsigned int>(\"component\")),\n      _ii(_component)\n{\n}\n\nReal SecondDerivative::computeQpResidual()\n{\n  return -_grad_v[_qp](_ii) * _grad_test[_i][_qp](_ii);\n}\n\nReal SecondDerivative::computeQpJacobian()\n{\n}",
                          "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10863243",
                          "updatedAt": "2024-10-07T05:53:48Z",
                          "publishedAt": "2024-10-07T05:53:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it's a little weird for me to understand that in the equation d2udx2_xx + d2udy2_yy + d2udz2_zz = f, there is no variable u, but can this equation still be used to solve for u?\n\nIt still works because all the equations are solved together. If you dont like that choice, you can use d2udx2 as the variable for that equation\n\nI would like to know if my implementation of SecondDerivative is correct according to my understanding:\n\nIt's not, it does not compile.\nTry starting from this, which uses automatic differentiation for simplicity\nSecondDerivative::SecondDerivative(const InputParameters &parameters)\n    : ADKernel(parameters),\n      _grad_v(adCoupledGradient(\"variable_to_take_the_derivative_of\")),\n      _component(getParam<unsigned int>(\"component\"))\n{\n}\n\nADReal SecondDerivative::computeQpResidual()\n{\n  return -_grad_v[_qp](_ii) * _grad_test[_i][_qp](_ii);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10866939",
                          "updatedAt": "2024-10-07T12:20:28Z",
                          "publishedAt": "2024-10-07T12:20:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zzzmx-josh"
                          },
                          "bodyText": "Thank you for your previous response.\nBased on the previous replies, I wrote two kernels, which are as follows:\nD2udi2Uii.h\n#ifndef D2udi2Uii_H\n#define D2udi2Uii_H\n\n#include \"Kernel.h\"\n\nclass D2udi2Uii : public Kernel\n{\npublic:\n  D2udi2Uii(const InputParameters & parameters);\n  static InputParameters validParams();\n\nprotected:\n\n  virtual Real computeQpResidual() override;\n  virtual Real computeQpJacobian() override;\n\nprivate:\n  // The component (0: x, 1: y, 2: z) to apply this kernel to\n  const unsigned int _ii;\n\n  // Reference to the second derivative (or gradient coupling) of variable 'w'\n  const VariableSecond & _second_grad_couple_w;\n};\n\n#endif\n\nD2udi2Uii.C\n#include \"D2udi2Uii.h\"\n\n// Register the kernel with the application\nregisterMooseObject(\"babblerApp\", D2udi2Uii);\n\n// Method to define valid input parameters for this kernel\nInputParameters\nD2udi2Uii::validParams()\n{\n  InputParameters params = Kernel::validParams();\n  \n  // Add a description for this kernel\n  params.addClassDescription(\"Split formulation D2udi2Uii for polar component Kernel\");\n\n  // Add required parameter to specify which component (x, y, z) this kernel applies to\n  params.addRequiredParam<unsigned int>(\"component\", \"The component (0: x, 1: y, 2: z) to apply this kernel to.\");\n  params.addRequiredCoupledVar(\"w\", \"e.g., vx\");\n\n  return params;\n}\n\n// Constructor for D2udi2Uii\nD2udi2Uii::D2udi2Uii(const InputParameters & parameters)\n  : Kernel(parameters),\n    _ii(getParam<unsigned int>(\"component\")),  // Get the component (x, y, z)\n    _second_grad_couple_w(coupledSecond(\"w\"))  // Get second derivative of coupled variable 'w'\n{\n}\n\nReal\nD2udi2Uii::computeQpResidual()\n{\n  Real residual = (_u[_qp] - _second_grad_couple_w[_qp](_ii, _ii)) * _test[_i][_qp];\n  return residual;\n}\n\n// Method to compute the Jacobian at a quadrature point\nReal\nD2udi2Uii::computeQpJacobian()\n{\n  Real jacobian = _phi[_j][_qp] * _test[_i][_qp];\n  \n  return jacobian;\n}\n\n\nSecondDerivative.h\n#pragma once\n\n#include \"ADKernel.h\"\n\n/// Class for computing the second derivative kernel\nclass SecondDerivative : public ADKernel\n{\npublic:\n  // Method to define valid input parameters for this kernel\n  static InputParameters validParams();\n\n  SecondDerivative(const InputParameters & parameters);\n\nprotected:\n\n  virtual ADReal computeQpResidual() override;\n  virtual Real computeQpJacobian() override;\n\nprivate:\n  // Index for variable component (e.g., 0: x, 1: y, etc.)\n  const unsigned int _ii;\n\n  // Gradient of the coupled variable 'v'\n  const VariableGradient & _grad_v;\n};\n\nSecondDerivative.C\n#include \"SecondDerivative.h\"\n\n// Register the SecondDerivative kernel with the application\nregisterMooseObject(\"babblerApp\", SecondDerivative);\n\n// Method to define valid input parameters for this ADKernel\nInputParameters SecondDerivative::validParams()\n{\n  // Initialize parameters from the base ADKernel\n  InputParameters params = ADKernel::validParams();\n\n  // Add a required parameter to specify which component (x, y, z) this kernel applies to\n  params.addRequiredParam<unsigned int>(\"component\", \"The component (0: x, 1: y, 2: z) to apply this ADKernel to.\");\n\n  params.addRequiredCoupledVar(\"variable_to_take_the_derivative_of\", \"The coupled velocity variable v.\");\n\n  return params;\n}\n\n// Constructor for SecondDerivative\nSecondDerivative::SecondDerivative(const InputParameters &parameters)\n    : ADKernel(parameters),\n      _ii(getParam<unsigned int>(\"component\")),   // Get the specified component (x, y, or z)\n      _grad_v(coupledGradient(\"variable_to_take_the_derivative_of\")) // Get the gradient of the coupled velocity variable\n{\n}\n\n// Method to compute the residual at a quadrature point\nADReal SecondDerivative::computeQpResidual()\n{\n  return -_grad_v[_qp](_ii) * _grad_test[_i][_qp](_ii);\n}\n\nReal SecondDerivative::computeQpJacobian()\n{\n  return 0;\n}\n\nAnd the corresponding input file:\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 20\n  ny = 20\n  nz = 2\n  xmin = -20\n  xmax = 20\n  ymin = -20\n  ymax = 20\n  zmin = -1\n  zmax = 1\n  second_order = true\n  # elem_type = HEX8\n[]\n[Variables]\n  [u]\n    order = SECOND\n  []\n  [d2udx2]\n    order = SECOND\n  []\n  [d2udy2]\n    order = SECOND\n  []\n  [d2udz2]\n    order = SECOND\n  []\n[]\n[Kernels]\n  [u_xx]\n    type = D2udi2Uii\n    variable = d2udx2\n    w = u\n    component = 0\n  []\n  [u_yy]\n    type = D2udi2Uii\n    variable = d2udy2\n    w = u\n    component = 1\n  []\n  [u_zz]\n    type = D2udi2Uii\n    variable = d2udz2\n    w = u\n    component = 2\n  []\n  [d4udx4]\n    type = SecondDerivative\n    variable = u\n    variable_to_take_the_derivative_of = d2udx2\n    component = 0\n   []\n  [d4udy4]\n    type = SecondDerivative\n    variable = u\n    variable_to_take_the_derivative_of = d2udy2\n    component = 1\n   []\n  [d4udz4]\n    type = SecondDerivative\n    variable = u\n    variable_to_take_the_derivative_of = d2udz2\n    component = 2\n   []\n   [f]\n    type = BodyForce\n    variable = u \n    function = f\n  []\n[]\n\nIt looks like there might still be some issues in the code. Could you please help me identify and resolve them?\nYour expertise would be greatly appreciated!",
                          "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10880137",
                          "updatedAt": "2024-10-08T13:18:11Z",
                          "publishedAt": "2024-10-08T13:18:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For ADkernels you do not need to add the computeQpJacobian routine",
                          "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10880953",
                          "updatedAt": "2024-10-08T14:18:13Z",
                          "publishedAt": "2024-10-08T14:18:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zzzmx-josh"
                          },
                          "bodyText": "Thanks!  I will remove the computeQpJacobian function from the ADKernel.\nAside from that, is everything else okay?",
                          "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10881158",
                          "updatedAt": "2024-10-08T14:34:37Z",
                          "publishedAt": "2024-10-08T14:34:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are you sure about taking the component in second derivative?\nNow that you use these intermediate variable then do an integration by parts, you should see something like:\n  return _grad_d2udx2[_qp] * _grad_test[_i][_qp];",
                          "url": "https://github.com/idaholab/moose/discussions/28788#discussioncomment-10881433",
                          "updatedAt": "2024-10-08T14:56:54Z",
                          "publishedAt": "2024-10-08T14:56:54Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Thermal expansion to a plastic material",
          "author": {
            "login": "haqfariha"
          },
          "bodyText": "I am using two blocks of material and applying crystal plasticity to both. I have applied a thermal expansion rate of 15% to the IMC block. The code is running however, IMC is not expanding, so any stresses or strains are not developing. Everything is 0.\n[Mesh]\n    type = FileMesh\n    file = 2phase_2D.msh\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n[]\n\n[AuxVariables] \n  [temp]\n    family = LAGRANGE\n    order = FIRST\n  []\n[]\n\n[Functions]\n  [./temperature_load]\n    type = ParsedFunction\n    value = 0.1*t  \n  [../]\n[]\n\n[AuxKernels]  \n  [./temp_aux]\n    type = FunctionAux\n    variable = temp\n    function = temperature_load \n    block = 'IMC'  \n  [../]\n[]\n\n[BCs]\n  [./x_disp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = 'Left Right'\n    function = 0.0\n  [../]\n\n  [./y_anchor]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'Bottom Top'\n    value = 0.0\n  [../]\n[]\n\n[Materials]\n  [./elastic_tensor1]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '72300 59400 35800 72300 35800 88400 22000 22000 24000'\n    fill_method = symmetric9\n    block = 'Sn'\n  [../]\n\n  [./stress1]\n    type = ComputeMultipleCrystalPlasticityRotation\n    crystal_plasticity_models = 'trial_xtalpl'\n    tan_mod_type = exact\n    block = 'Sn'\n  [../]\n\n  [./trial_xtalpl]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 32\n    slip_sys_file_name = slip_sys_tin.txt\n    ao = 2.5e-4\n    gss_a = 2\n    r = 1.4\n    h = 80\n    gss_initial = 23\n    t_sat = 30\n    crystal_lattice_type = BCC\n    unit_cell_dimension = '0.583 0.583 0.318'\n    xm = 0.4\n    block = 'Sn'\n  [../]\n\n  [./elastic_tensor2]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '97300 59400 55800 97300 55800 118400 35000 35000 38000'\n    fill_method = symmetric9\n    block = 'IMC'\n  [../]\n\n  [./stress2]\n    type = ComputeMultipleCrystalPlasticityRotation\n    crystal_plasticity_models = 'trial_xtalpl1'\n    tan_mod_type = exact\n    block = 'IMC'\n  [../]\n\n    [./trial_xtalpl1]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 32\n    slip_sys_file_name = slip_sys_tin.txt\n    ao = 0  \n    gss_a = 2 \n    r = 1.4\n    h = 120  \n    gss_initial = 28  \n    t_sat = 30\n    xm = 0.4\n    block = 'IMC'\n  [../]\n\n  [./volumExp_strainIMC]\n    type = ComputeThermalExpansionEigenstrain\n    temperature = temp\n    thermal_expansion_coeff = 0.15\n    stress_free_temperature = 0.0\n    eigenstrain_name = eigenstrain1\n    block = 'IMC'\n  [../]\n[]\n\n[Modules/TensorMechanics/Master]\n    strain = Finite\n    displacements = 'disp_x disp_y'\n    add_variables = true\n    planar_formulation = PLANE_STRAIN\n    generate_output = 'stress_xx stress_xy stress_yy strain_xx strain_xy strain_yy vonmises_stress hydrostatic_stress'\n    [./block1]\n      block = 'IMC'\n      eigenstrain_names = 'eigenstrain1'\n      temperature = temp \n    [../]\n    [./block2]\n      block = 'Sn'\n    [../]  \n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold'\n  petsc_options_value = 'hypre boomeramg 3100 0.7'\n  nl_rel_tol = 1e-6\n  start_time = 0.0\n  num_steps = 10000\n  dt = 0.1\n[]\n\n[Outputs]\n  exodus = true\n  checkpoint = true\n  interval = 50\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\n\nHowever, when I applied the elasticity model to the IMC, I got proper stress-strain values.\n[./elastic_tensor2]\n    type = ComputeIsotropicElasticityTensor\n    poissons_ratio = 0.31\n    youngs_modulus = 97000\n    block = 'IMC'\n  [../]\n [./stress2]\n    type = ComputeFiniteStrainElasticStress\n    block = 'IMC'\n  [../]\n  [./volumExp_strainIMC]\n    type = ComputeThermalExpansionEigenstrain\n    temperature = temp\n    thermal_expansion_coeff = 0.15\n    stress_free_temperature = 0.0\n    eigenstrain_name = eigenstrain1\n    block = 'IMC'\n  [../]\n\nBut I need to update the model to plasticity. I have also tried \"ComputeCrystalPlasticityThermalEigenstrain\", the same thing! Am I missing something when I am trying to incorporate expansion with plasticity? Nothing happens.\n[thermal_eigenstrain_1]\n    type = ComputeCrystalPlasticityThermalEigenstrain\n    eigenstrain_name = thermal_eigenstrain_1\n    deformation_gradient_name = thermal_deformation_gradient_1\n    temperature = temp  \n    thermal_expansion_coefficients = '0.15 0.15 0.15'  \n    block = 'IMC'\n  [../]\n[]\n\n[Modules/TensorMechanics/Master]\n    strain = Finite\n    displacements = 'disp_x disp_y'\n    add_variables = true\n    planar_formulation = PLANE_STRAIN\n    generate_output = 'stress_xx stress_xy stress_yy strain_xx strain_xy strain_yy vonmises_stress hydrostatic_stress'\n    [./block1]\n      block = 'IMC'\n      eigenstrain_names = 'thermal_eigenstrain_1'\n      temperature = temp \n    [../]\n    [./block2]\n      block = 'Sn'\n    [../]  \n[]",
          "url": "https://github.com/idaholab/moose/discussions/28776",
          "updatedAt": "2024-10-08T22:03:02Z",
          "publishedAt": "2024-10-04T18:19:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "Hi @haqfariha,\nIn general, use the ComputeCrystalPlasticityThermalEigenstrain class, and \"tell\" the ComputeMultipleCrystalPlasticityStress class about the eigenstrain with the parameter eigenstrain_names; see the example at the bottom of the documentation page here: https://mooseframework.inl.gov/source/materials/crystal_plasticity/ComputeCrystalPlasticityThermalEigenstrain.html\nNote that your input file is missing the ComputeMultipleCrystalPlasticityStress crystal plasticity specific stress calculator class. If the class ComputeMultipleCrystalPlasticityStressRotation is your own constitutive class that you wrote based on ComputeMultipleCrystalPlasticityStress, you will need to make sure that it can accommodate the eigenstrain.\nFinally, I am not aware of testing with the crystal plasticity models using the plane strain assumption. I would urge caution when using this option and would recommend using the 3D strain formulation",
                  "url": "https://github.com/idaholab/moose/discussions/28776#discussioncomment-10885645",
                  "updatedAt": "2024-10-08T22:03:03Z",
                  "publishedAt": "2024-10-08T22:03:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error : \"The variable must be elemental\" for ForcingFunctionAux AuxKernel - With a digression into Functors",
          "author": {
            "login": "EdSheltonUKAEA"
          },
          "bodyText": "I've been running into some errors trying to use a combination of Variables, AuxVariables and Materials.  I know not all these things can talk to each other, or use each other as inputs.\nI thought I had found a work around, but my current stumbling block is in an AuxKernel with type ForcingFunctionAux. The error message is \"The variable must be elemental\".\nI assume this means the AuxVariable I'm using is nodal, but there doesn't seem to be any mention of the elemental variable requirement in the page for the AuxKernel:\nhttps://mooseframework.inl.gov/source/auxkernels/ForcingFunctionAux.html\nIs there a way to define whether an AuxVariable is nodal or elemental?  I can't see anything obvious here:\n\u2060https://mooseframework.inl.gov/source/variables/AuxVariable.html\nI have created the AuxVariable with default settings.  If it defaults to nodal, is it odd that an AuxKernel wants an elemental variable?\nIs there a way to make sure my AuxVariable is elemental for the ForcingFunctionAux, but can still work as a nodal variable where this is needed in for other functions or calculations?",
          "url": "https://github.com/idaholab/moose/discussions/28627",
          "updatedAt": "2024-10-08T15:21:31Z",
          "publishedAt": "2024-09-16T09:02:12Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "EdSheltonUKAEA"
                  },
                  "bodyText": "I've  got an initial answer to this from a colleague.  By setting the AuxVariable to have parameters:\norder = CONSTANT\nfamily = MONOMIAL\nI have made it elemental.  And by changing a few other things I now have a model which is running, but not converging.  This is likely to be because of some other problem.",
                  "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10659042",
                  "updatedAt": "2024-09-16T12:19:22Z",
                  "publishedAt": "2024-09-16T12:19:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "A nodal variable is defined with the dofs at the nodals, for example a lagrange family variable.\nAn elemental variable would tentatively be a variable where all the dofs are inside the element.\nThe pickle is that there are many variable types which have nodal dofs, side dofs and elemental dofs, so the nodal/elemental distinction is not quite enough.\nI m not sure why ForcingFunctionAux is elemental-only. I ll take a look",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10659437",
                          "updatedAt": "2024-09-16T12:59:18Z",
                          "publishedAt": "2024-09-16T12:59:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so there is nothing \"elemental\"-only about it, if only that it's been implemented for working on qps\n  return _u_old[_qp] + _dt * _func.value(_t, _q_point[_qp]);\n\nfor nodals we would want something like below for the function\n_func.value(_t, *_current_node);",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10659502",
                          "updatedAt": "2024-09-16T13:03:44Z",
                          "publishedAt": "2024-09-16T13:03:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Thanks for the comments on this.  I'm not sure if the second one means that ForcingFunctionAux should work with Lagrangian AuxVariables.  But even if it \"should\", for whatever reason in my model if I allow the AuxVariable family to default to LAGRANGE I get the \"must be elemental\" error when I try to run it.\nIf I'm stuck with using a MONOMIAL AuxVariable, is there a way of converting this into another AuxVariable which is LAGRANGE and so outputs nodal values?\nOr perhaps I can achieve what I want another way.  I'm using ForcingFunctionAux to obtain the value of the AuxVariable at the end of the previous timestep (i.e. start of the current time step) by setting the function, f, to zero, i.e.  V(t+\u0394t)=V(t)+f\u0394t = V(t) .\nI expect there is a simpler or more elegant way of getting the value at the start of the current timestep of an AuxVariable (or a MaterialProperty might work) at every node.  But looking through the Source Documentation page I haven't found one yet.  I don't think I can use a Postprocessor for this, as I need this value at every node to be available for calculations within the solve.  Postprocessors giving average, integral or extreme values over a domain won't give me what I want.\nIs there a way of calling the value at the start of the current time step of an AuxVariable of any type?",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10690614",
                          "updatedAt": "2024-09-19T08:31:02Z",
                          "publishedAt": "2024-09-19T08:31:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "But even if it \"should\", for whatever reason in my model if I allow the AuxVariable family to default to LAGRANGE I get the \"must be elemental\" error when I try to run it.\n\nError is good, it is not currently implemented for nodal variables. I can take a look at making it work for nodal variables if you want.\n\nIf I'm stuck with using a MONOMIAL AuxVariable, is there a way of converting this into another AuxVariable which is LAGRANGE and so outputs nodal values?\n\nThere is the ProjectionAux to go from elemental to nodal variables. This will incur some projection error of course.\n\nIs there a way of calling the value at the start of the current time step of an AuxVariable of any type?\n\nIf you execute (execute_on parameter) the auxkernel that sets that variable on timestep_begin only, it will retrain the value at the start of the time step",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10692318",
                          "updatedAt": "2024-09-19T11:17:18Z",
                          "publishedAt": "2024-09-19T11:17:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Thank you.  This is really helpful and gives me some other options to try.  So I probably don't need the ForcingFunctionAux in a nodal version right now.",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10692697",
                          "updatedAt": "2024-09-19T11:53:47Z",
                          "publishedAt": "2024-09-19T11:53:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Using execute_on = timestep_begin looks like it should let me do what I want much more elegantly that using ForcingFunctionAux.  But there doesn't seem to be an execute_on parameter for Material properties.  So ideally I need to convert a material property into a nodal AuxVariable.  However, it looks like this isn't currently possible where is says here: https://mooseframework.inl.gov/source/auxkernels/ParsedAux.html\n\"Material properties are currently not supported, but it would be really easy to add it so feel free to contact us.\"\nThis could be really helpful!  How easy and quick could it be to implement this?  Days? Hours?\nAltenatively, I'm looking at the newer(?) concept of Functors, where it looks like Material Properties, AuxVariables and Functions all become more interchangeable as nodal parameters.  What is the first step to either defining a Material property as a Functor or making a copy of a conventional Material property as a Functor?  As I read it, a FunctorMaterial can use as inputs existing FunctorMaterials, but not non-Functors, so I always seem to be one step away from converting my conventional Materials into a Functor then to use with AuxVariables.",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10702194",
                          "updatedAt": "2024-09-20T08:53:51Z",
                          "publishedAt": "2024-09-20T08:30:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "I've just found this: https://mooseframework.inl.gov/source/materials/MaterialFunctorConverter.html\n\"This Material handles the conversion from functor material properties to regular material properties. Unfortunately, the conversion in the other direction, from regular material properties to functors, is not implemented and would be quite challenging notably because of the need to handle complex material property dependency resolution.\"  [My bold.]\nThis seems to answer my second question.  So it looks like being able to include MatProps in a ParsedAux is my best option.",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10702432",
                          "updatedAt": "2024-09-20T08:54:37Z",
                          "publishedAt": "2024-09-20T08:54:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "As I read more about Functors and FunctorMaterials, I'm wondering if for the calculations I want to do, using FunctorMaterials might in fact be a better option.  Many of the \"Materials properties\" I'm using during each time step solve are just temporary parameters used in calculation, not something that needs to be output or plotted, or even saved into the next time step.  As it describes FunctorMaterials as being calculated \"on the fly\", does this mean using them in calculations like this should be less demanding on memory and make a solve faster?",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10704203",
                          "updatedAt": "2024-09-20T11:31:41Z",
                          "publishedAt": "2024-09-20T11:31:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So ideally I need to convert a material property into a nodal AuxVariable\n\nKeep in mind there are no nodal material properties. You can convert to an elemental variable using a MaterialRealAux\n\n\"Material properties are currently not supported, but it would be really easy to add it so feel free to contact us.\"\nThis could be really helpful! How easy and quick could it be to implement this? Days? Hours?\n\nProbably less than a day thing. Seems like the ideal way for me to procrastinate making slides. I'll let you know how it goes.\nI m not sure you really need it though? It wont offer that much more than a MaterialRealAux, then chained with a ParsedAux\n\nAltenatively, I'm looking at the newer(?) concept of Functors\n\nDefinitely newer. We have been using them for ~2 years now.\n\n. What is the first step to either defining a Material property as a Functor or making a copy of a conventional Material property as a Functor?\n\nRegular material properties cannot be defined as functors unfortunately.\n\nAs I read more about Functors and FunctorMaterials, I'm wondering if for the calculations I want to do, using FunctorMaterials might in fact be a better option.\n\nTransitioning from Materials to FunctorMaterials is an option. You just have to take a look at your Materials in the Materials block to see how big of a task it will be to change that code.\n\ndoes this mean using them in calculations like this should be less demanding on memory and make a solve faster?\n\nPre-computing properties can be an optimization for some problems with expensive constitutive models. So functor materials are not always faster. However, functor materials only compute the 1 property you need, while materials always computed every single properties no matter what.  That can be an improvement",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10707216",
                          "updatedAt": "2024-09-20T17:16:11Z",
                          "publishedAt": "2024-09-20T16:23:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "#28673\nplease let me know if it does not work. It will error if you try to set a nodal variable, because material properties are not defined at nodes. If you need that, then set an elemental variable first, then use a ProjectionAux to get to a nodal variable",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10707687",
                          "updatedAt": "2024-09-20T17:15:59Z",
                          "publishedAt": "2024-09-20T17:15:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I saw the message in my email. Please keep in mind execute_on for FunctorMaterial relates to refreshing the caching of element and face values.\nIt's generally easier to leave that setting to the default, in which case the FunctorMaterial does not use any caching",
                  "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10821626",
                  "updatedAt": "2024-10-02T14:33:34Z",
                  "publishedAt": "2024-10-02T14:33:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Thanks.  I found a fix which by calling the corresponding elemental AuxVariable as the functor to give the value at timestep_begin.\nNow I get non-zero values for the rate of change over the timestep, but back to the usual problem of the solve not converging.\nThe error message is:\n\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nSolve Did NOT Converge!\nAborting as solve did not converge",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10821686",
                          "updatedAt": "2024-10-02T14:37:55Z",
                          "publishedAt": "2024-10-02T14:37:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Should I use the AuxVariable which duplicates the FunctorMaterial also to give the timestep_end \"now\" value?",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10821696",
                          "updatedAt": "2024-10-02T14:39:33Z",
                          "publishedAt": "2024-10-02T14:39:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is the value of the auxvariable dependent on the nonlinear variables? Because if so, no derivative information is propagated and the Jacobian would be missing terms.\nWhere are you in the process of troubleshooting the nonconvergence?\nwrt this page\nhttps://mooseframework.inl.gov/moose/application_usage/failed_solves.html",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10821713",
                          "updatedAt": "2024-10-02T14:40:56Z",
                          "publishedAt": "2024-10-02T14:40:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Is the value of the auxvariable dependent on the nonlinear variables? Because if so, no derivative information is propagated and the Jacobian would be missing terms.\n\nIndirectly, yes.  In my simplified example, x is the non-linear variable being solved.  So the FunctorMaterial is calculated as a function of this.  Then the AuxVariable takes the value of FunctorMaterials using FunctorMaterialRealAux.\n\nWhere are you in the process of troubleshooting the nonconvergence?\nwrt this page\nhttps://mooseframework.inl.gov/moose/application_usage/failed_solves.html\n\nI'll have to work through that and get back to you!",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10821777",
                          "updatedAt": "2024-10-02T14:46:54Z",
                          "publishedAt": "2024-10-02T14:46:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Instead of using an auxiliary variable, could you please use a functor material for this value?\nThe ADParsedFunctorMaterial is likely flexible enough to replace the auxkernel?\nAnd it will conserve derivatives",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10821824",
                          "updatedAt": "2024-10-02T14:51:50Z",
                          "publishedAt": "2024-10-02T14:51:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Instead of using an auxiliary variable, could you please use a functor material for this value?\n\nFor which value?  If you mean the value at the start of the timestep, that's what I tried first, but always got zeros for the change over the timestep.  If I understood your previous message correctly, FunctorMaterials \"execute_on\" don't remember values from the end of the previous timestep, they calculated new each time.\nShould I call back a new FunctorMaterial for the start of the timestep using the AuxVariable at timestep_begian, and then use that is the rate of change calculation?",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10821894",
                          "updatedAt": "2024-10-02T14:56:41Z",
                          "publishedAt": "2024-10-02T14:56:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For every value that is using an auxiliary variable right now.\nSince functor materials are evaluated on-the-fly (unless you specified an execute_on, in which case there was caching), the zeros must come from whatever is being input in the functor material.\nIf you call a functor material from an auxkernel, you will lose derivative information.\nIn the troubleshooting instructions, you can look at the Jacobian analyser section, to see if that is the current problem you are facing",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10821954",
                          "updatedAt": "2024-10-02T15:01:25Z",
                          "publishedAt": "2024-10-02T15:01:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Ultimately, as I need the rate value as a conventional material property to use in ADMatHeatSource kernel, could I call both \"then\" and \"now\" values as other conventional materials properties from the AuxKernel and FunctorMaterial respectively, and calculate the difference and rate in the [Materials] block rather than [FunctorMaterials] block?  Would doing it this way provide what's needed for the solve to work?",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10821968",
                          "updatedAt": "2024-10-02T15:02:08Z",
                          "publishedAt": "2024-10-02T15:02:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh you are computing the rate manually?\nIn a functor material, you can do functor.dot(arg, state) to get the time derivative.\nComputing the rates manually could be done in Materials as well.\nI suspect you would not be able to get second order time integration if you compute rates manually instead of using the dot() / coupledDot routines",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10822228",
                          "updatedAt": "2024-10-02T15:17:50Z",
                          "publishedAt": "2024-10-02T15:17:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "OK.  Thanks.  I'll take a look at these tomorrow as about to head home.\nCan you show the \"functor.dot(arg, state)\" in an example input file?\nBut it looks like that might be something in a C++ file, and I don't work with that.  I can only use \"off the shelf\" MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/28627#discussioncomment-10822267",
                          "updatedAt": "2024-10-02T15:21:23Z",
                          "publishedAt": "2024-10-02T15:21:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to run axisymmetric heat conduction simulation",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "Hi, I am trying to run a simple heat conduction problem where I reduce the full 3D model to an axisymmetric 2D one. I am sure I'm missing something but I'm not sure what. I thought I'd ask here first before I get into the weeds of radial coordinates/working it out manually.\nThe problem setup is simple: a semi-infinite box with homogeneous material properties (thermal conductivity) has a gaussian heat flux applied at the top surface. It is steady state too, so no worry about the time terms for now.\n\nBelow is the temperature profile from the top of the box to the bottom at r = 0 (i.e x=0, y=0).\n\nI implemented the exact same simulation in 2D with a mesh that should be a slice of the 3D version. But my result differs. Not just in magnitude but the temperature profile itself is different. edit, it's based on the way derivatives are calculated in the rz coordinate system.\n\n\nIs there an existing model/kernel that can help solve a problem like this/is there something simple I'm missing?",
          "url": "https://github.com/idaholab/moose/discussions/28803",
          "updatedAt": "2024-10-08T03:01:09Z",
          "publishedAt": "2024-10-07T23:14:28Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "richmondodufisan"
                  },
                  "bodyText": "Solved, MOOSE has built in functionality, no need to reinvent the wheel\n[Problem]\ncoord_type = RZ\n[]\nAlthough I got a warning that this is deprecated and should be under the mesh block, but I got an error when I did that",
                  "url": "https://github.com/idaholab/moose/discussions/28803#discussioncomment-10874776",
                  "updatedAt": "2024-10-08T02:42:03Z",
                  "publishedAt": "2024-10-08T02:42:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this should work\n[Mesh]\n  coord_type = RZ\n  [other_mg]\n      ...\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28803#discussioncomment-10874884",
                          "updatedAt": "2024-10-08T02:58:18Z",
                          "publishedAt": "2024-10-08T02:58:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "That worked thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/28803#discussioncomment-10874900",
                          "updatedAt": "2024-10-08T03:01:10Z",
                          "publishedAt": "2024-10-08T03:01:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about output analysis of PF simulations",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nDo you know if MOOSE has any tools for analyzing the outputs of PF simulations? In particular, does it have a way of determining the characteristic dimensions of phase domains, e.g., using spectral analysis?\nThank you very much.\nBest,",
          "url": "https://github.com/idaholab/moose/discussions/24720",
          "updatedAt": "2024-10-08T02:23:53Z",
          "publishedAt": "2023-06-16T15:49:46Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen @amjokisaari",
                  "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6207420",
                  "updatedAt": "2023-06-18T04:44:29Z",
                  "publishedAt": "2023-06-18T04:44:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "For example, I want to measure the characteristic length of these microstructures.",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6209978",
                          "updatedAt": "2023-06-18T14:12:22Z",
                          "publishedAt": "2023-06-18T14:12:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "Is there any software can measure the characteristic length of the figure of two phase system?",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6221186",
                          "updatedAt": "2023-06-19T15:57:31Z",
                          "publishedAt": "2023-06-19T15:57:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@dschwen",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6221193",
                          "updatedAt": "2023-06-19T15:58:31Z",
                          "publishedAt": "2023-06-19T15:58:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "I think you can get it from an analysis of the 2-point correlation function. I talked about using 2-point correlation function for image analysis in this paper and gave a citation for the software we used. I'm not sure off hand exactly how to go from the correlation function to a characteristic length but it might just be the peak of the distribution function (we related it to bubble spacing in our paper and I'm guessing it is the same idea but you will probably need to do a little further reading on this).\nhttps://www.sciencedirect.com/science/article/pii/S0927025622004839?via%3Dihub",
                  "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6255232",
                  "updatedAt": "2023-06-22T18:54:29Z",
                  "publishedAt": "2023-06-22T18:54:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "Thank you for your reply. I read that paper and found that 2 point correlation matlab code. Is this code only suitable for calculating the distance of two circles?",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6263671",
                          "updatedAt": "2023-06-23T15:45:11Z",
                          "publishedAt": "2023-06-23T15:45:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "The code calculates the two-point correlation function. To go from the correlation function to characteristic length, you will need to research on your own, I don't know off hand exactly how to do that. However the surface area per unit length I mentioned below is probably easier.",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6264486",
                          "updatedAt": "2023-06-23T17:15:31Z",
                          "publishedAt": "2023-06-23T17:15:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "You could also use the inverse of the surface area per unit volume as a length scale. We did this and gave references to where this idea came from in this paper:\nhttps://materialstheory.springeropen.com/articles/10.1186/s41313-021-00041-5\nFor a 2D simulation, you would use the GB length per unit area. You could get GB length with the GrainBoundaryArea postprocessor (set grains_per_side = 1) or with Paraview - in fact I would try both and compare them to make sure you are getting the right answer.",
                  "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6255363",
                  "updatedAt": "2023-06-22T19:12:56Z",
                  "publishedAt": "2023-06-22T19:12:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "Thank you for your suggestions. In our work, we did not investigate GB. We only have one order parameter, which is concentration, so this may be not suitable..",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6263685",
                          "updatedAt": "2023-06-23T15:46:28Z",
                          "publishedAt": "2023-06-23T15:46:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "The GrainBoundaryArea postprocessor should still work for a single order parameter as long as you set grains_per_side = 1. Sorry the name is a bit confusing but it should do what you want. You can also use Paraview as I mentioned.",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6264494",
                          "updatedAt": "2023-06-23T17:16:27Z",
                          "publishedAt": "2023-06-23T17:16:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "I am using paraview to output the video of evolution. Could you please tell me how to do this using paraview? Since I don't have grain boundary, which length should I measure?",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6266141",
                          "updatedAt": "2023-06-23T21:15:45Z",
                          "publishedAt": "2023-06-23T21:15:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The GrainBoundaryArea is a postprocessor in MOOSE, not in paraview.\nIt wil be a number output to CSV which you can plot in paraview",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6266165",
                          "updatedAt": "2023-06-23T21:19:55Z",
                          "publishedAt": "2023-06-23T21:19:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "I added this in postprocessor block, however, I got error message...\n\nWhy is this? Is there other command I need to add?",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6266477",
                          "updatedAt": "2023-06-23T22:22:58Z",
                          "publishedAt": "2023-06-23T22:22:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "need to add the pf variables",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6266486",
                          "updatedAt": "2023-06-23T22:24:11Z",
                          "publishedAt": "2023-06-23T22:24:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TJT-post95"
                          },
                          "bodyText": "According to the source code of GrainBoundaryArea, I find that it's the integration of the amplitude about gradient of order parameter within element. Why it's sum could be applied to calculate the length (2D) and area (3D) of grain boundary? Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6315453",
                          "updatedAt": "2023-06-29T13:27:42Z",
                          "publishedAt": "2023-06-29T13:27:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ChaunceyDevonport"
                          },
                          "bodyText": "I am new to MOOSE and am not well versed enough to look into the source code. I am using two post-processors; the AverageGrainVolume and GrainBoundaryArea post-processors. There are syntax pages in the documentation for the post-processors, but these syntax pages don't explain the calculation that is made for these two post-processors?",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-10855636",
                          "updatedAt": "2024-10-06T00:48:58Z",
                          "publishedAt": "2024-10-06T00:48:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "AverageGrainVolume uses the FeatureFloodCount (FFC) postprocessor\nhttps://mooseframework.inl.gov/moose/source/postprocessors/FeatureFloodCount.html\nFFC identifies the number of individual features and the volume associated with each. Then AverageGrainVolume totals up those volumes and divides by number of features. (it does not simply divide the total domain volume by number of features to allow it to handle the case where there is a second phase present and you don't want the volume associated with the second phase included in the AverageGrainVolume",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-10872237",
                          "updatedAt": "2024-10-07T19:16:50Z",
                          "publishedAt": "2024-10-07T19:16:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "GrainBoundaryArea calculates the gradient of each order parameter, then integrates the magnitude of each gradient. You can show analytically that integrating the gradient in 1D will give you the difference between the value of the order parameter on either side of the interface. If you do that over a unit volume and divide by the difference between OPs, you will get the area of the grain boundary (and usually need to divide by a factor of 2 for models where there are 2 order parameters varying through the interface, as is the case the with standard MOOSE grain growth model for polycrystals)",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-10872299",
                          "updatedAt": "2024-10-07T19:22:46Z",
                          "publishedAt": "2024-10-07T19:22:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abc-hy"
                  },
                  "bodyText": "What is pf variables?\n\u2026\nOn Fri, Jun 23, 2023 at 5:24 PM Guillaume Giudicelli < ***@***.***> wrote:\n need to add the pf variables\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24720 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/APF2ZCSDWMIZSLPDTEWWKYLXMYJRNANCNFSM6AAAAAAZJN3N7A>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6266627",
                  "updatedAt": "2023-06-23T23:04:21Z",
                  "publishedAt": "2023-06-23T23:04:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "you need to tell it what phase-field variable you want to use. So if your phase-field order parameter is c you need to add v = c. I think this should work, I have not actually tried it with the single variable before....if it doesn't work you can also use Paraview.",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6266663",
                          "updatedAt": "2023-06-23T23:13:38Z",
                          "publishedAt": "2023-06-23T23:13:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "Do you mean that I can directly use Paraview to calculate the length? Could you please show me how to realize that?",
                          "url": "https://github.com/idaholab/moose/discussions/24720#discussioncomment-6266992",
                          "updatedAt": "2023-06-24T00:54:31Z",
                          "publishedAt": "2023-06-24T00:54:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Choice of Framework for Precipitate Growth",
          "author": {
            "login": "nwinner"
          },
          "bodyText": "Hello all, I am new to the MOOSE community, having found it as a platform for solving phase field problems. I have some known multicomponent, multiphase alloys with CALPHAD database files. When the alloy is cast, there is a distribution of intermetallic precipitates that are of interest to me. I want to study the impact of processing temperature on the growth/coallescence of these phases. Ideally, starting with annealing, and then including different temperature profiles as well as gradients in the alloy from a cold/hot side. The precipitates are highly anisotropic, so treating the interfaces properly is important to me.\nI'd like to know which phase field formalism is the best starting point for this. From the website, it seems like there are a couple of different frameworks that could potentially solve this. The sublattice KKS model, the multiphase model, and the grand potential model.\nThe paper on SLKKS specifically discusses importing calphad models, so this seems most ideal, but I cannot see much discussion on it. There is a single example on CrFe, which currently has CrFe_sigma_out_var_0001.csv file missing, so the file cannot be tested. The grand potential formalism is described as offering some improved computational performance as compared to the SL-KKS model. Since I'm working with .tdb files, SL-KKS would be more straightforward it seems, but perhaps approximating the phases with a series parabolic free energies could be worth improved performance.\nGiven my description above, which would be the best framework to start with in terms of performance and ease-of-use. I will stork my own MOOSE app once I get a feel for things, but obviously I'd like a gentle introduction if possible.\nIn either case, are their examples out there which seem analogous to this problem?",
          "url": "https://github.com/idaholab/moose/discussions/28792",
          "updatedAt": "2024-10-07T23:40:33Z",
          "publishedAt": "2024-10-06T20:50:07Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen\n@dschwen for this missing file :S (see previous post)",
                  "url": "https://github.com/idaholab/moose/discussions/28792#discussioncomment-10861239",
                  "updatedAt": "2024-10-06T21:48:43Z",
                  "publishedAt": "2024-10-06T21:48:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "I would start with Sublattice KKS and use that if you can get the performance you need. But I would use the simplest chemistry you can to start out with, try starting with a binary alloy Calphad description to work out as many kinks as possible before moving to ternary+ alloys.",
                          "url": "https://github.com/idaholab/moose/discussions/28792#discussioncomment-10872326",
                          "updatedAt": "2024-10-07T19:26:17Z",
                          "publishedAt": "2024-10-07T19:26:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nwinner"
                          },
                          "bodyText": "Got it. I'll plan to start with SLKKS and Ni-Cu or something. Are there other working examples for SLKKS while we wait for this missing file?",
                          "url": "https://github.com/idaholab/moose/discussions/28792#discussioncomment-10873164",
                          "updatedAt": "2024-10-07T21:10:54Z",
                          "publishedAt": "2024-10-07T21:10:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nwinner"
                          },
                          "bodyText": "@GiudGiud and @dschwen it actually looks like the missing file is provided by first running CrFe_sigma.i, which produces the csv files as output. See this short PR.",
                          "url": "https://github.com/idaholab/moose/discussions/28792#discussioncomment-10873719",
                          "updatedAt": "2024-10-07T23:13:32Z",
                          "publishedAt": "2024-10-07T23:13:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "awesome I ll take a look at the end of the week",
                          "url": "https://github.com/idaholab/moose/discussions/28792#discussioncomment-10873802",
                          "updatedAt": "2024-10-07T23:40:34Z",
                          "publishedAt": "2024-10-07T23:40:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Extending kks_mechanics example to 2D",
          "author": {
            "login": "ppandit95"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nHi Developers\nI am tryig to extend the kks_mechanics_KHS.i input file to simulate on a 2D grid (infile attached) but even though the solution is converging it only runs for single time step(outfile attached) although vtk output is generated for all time steps in vtk but when vizualized the mesh keeps on moving every time step.\nAny help in this regard would be appreciated.\nMany Thanks\nPushkar\noutput.txt\n(Optional) code in question / simulation log / errors\nInFile>>>>\n\n# KKS phase-field model coupled with elasticity using Khachaturyan's scheme as\n# described in L.K. Aagesen et al., Computational Materials Science, 140, 10-21 (2017)\n# Original run #170403a\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 640\n  ny = 640\n  nz = 1\n  xmin = -10\n  xmax = 10\n  ymin = -10\n  ymax = 10\n  zmin = 0\n  zmax = 0.03125\n  elem_type = HEX8\n[]\n\n\n[Variables]\n  # order parameter\n  [./eta]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  # solute concentration\n  [./c]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  # chemical potential\n  [./w]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  # solute phase concentration (matrix)\n  [./cm]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  # solute phase concentration (precipitate)\n  [./cp]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_z]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n[ICs]\n  [./eta_ic]\n    variable = eta\n    type = FunctionIC\n    function = ic_func_eta\n    block = 0\n  [../]\n  [./c_ic]\n    variable = c\n    type = FunctionIC\n    function = ic_func_c\n    block = 0\n  [../]\n  [./w_ic]\n    variable = w\n    type = ConstantIC\n    value = 0.00991\n    block = 0\n  [../]\n  [./cm_ic]\n    variable = cm\n    type = ConstantIC\n    value = 0.131\n    block = 0\n  [../]\n  [./cp_ic]\n    variable = cp\n    type = ConstantIC\n    value = 0.236\n    block = 0\n  [../]\n[]\n\n[Functions]\n  [./ic_func_eta]\n    type = ParsedFunction\n    expression = '0.5*(1.0+tanh((sqrt(x*x+y*y))/delta_eta/sqrt(2.0)))'\n    symbol_names = 'delta_eta'\n    symbol_values = '0.5'\n  [../]\n  [./ic_func_c]\n    type = ParsedFunction\n    expression = '0.2389*(0.5*(1.0+tanh(sqrt(x*x+y*y)/delta/sqrt(2.0))))^3*(6*(0.5*(1.0+tanh(sqrt(x*x+y*y)/delta/sqrt(2.0))))^2-15*(0.5*(1.0+tanh(sqrt(x*x+y*y)/delta/sqrt(2.0))))+10)+0.1339*(1-(0.5*(1.0+tanh(sqrt(x*x+y*y)/delta/sqrt(2.0))))^3*(6*(0.5*(1.0+tanh(sqrt(x*x+y*y)/delta/sqrt(2.0))))^2-15*(0.5*(1.0+tanh(sqrt(x*x+y*y)/delta/sqrt(2.0))))+10))'\n    symbol_names = 'delta'\n    symbol_values = '0.8034'\n  [../]\n  [./psi_eq_int]\n    type = ParsedFunction\n    expression = 'volume*psi_alpha'\n    symbol_names = 'volume psi_alpha'\n    symbol_values = 'volume psi_alpha'\n  [../]\n  [./gamma]\n    type = ParsedFunction\n    expression = '(psi_int - psi_eq_int) / dy / dz'\n    symbol_names = 'psi_int psi_eq_int dy       dz'\n    symbol_values = 'psi_int psi_eq_int 0.03125  0.03125'\n  [../]\n[]\n\n[AuxVariables]\n  [./sigma11]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./sigma22]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./sigma33]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e11]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e12]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e22]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e33]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e_el11]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e_el12]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e_el22]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./f_el]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./eigen_strain00]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./Fglobal]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./psi]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./matl_sigma11]\n    type = RankTwoAux\n    rank_two_tensor = stress\n    index_i = 0\n    index_j = 0\n    variable = sigma11\n  [../]\n  [./matl_sigma22]\n    type = RankTwoAux\n    rank_two_tensor = stress\n    index_i = 1\n    index_j = 1\n    variable = sigma22\n  [../]\n  [./matl_sigma33]\n    type = RankTwoAux\n    rank_two_tensor = stress\n    index_i = 2\n    index_j = 2\n    variable = sigma33\n  [../]\n  [./matl_e11]\n    type = RankTwoAux\n    rank_two_tensor = total_strain\n    index_i = 0\n    index_j = 0\n    variable = e11\n  [../]\n  [./f_el]\n    type = MaterialRealAux\n    variable = f_el\n    property = f_el_mat\n    execute_on = timestep_end\n  [../]\n  [./GlobalFreeEnergy]\n    variable = Fglobal\n    type = KKSGlobalFreeEnergy\n    fa_name = fm\n    fb_name = fp\n    w = 0.0264\n    kappa_names = kappa\n    interfacial_vars = eta\n  [../]\n  [./psi_potential]\n    variable = psi\n    type = ParsedAux\n    coupled_variables = 'Fglobal w c f_el sigma11 e11'\n    expression = 'Fglobal - w*c + f_el - sigma11*e11'\n  [../]\n[]\n\n\n[BCs]\n  [./left_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = left\n    value = 0\n  [../]\n  [./right_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = right\n    value = 0\n  [../]\n  [./front_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = front\n    value = 0\n  [../]\n  [./back_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = back\n    value = 0\n  [../]\n  [./top_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = top\n    value = 0\n  [../]\n  [./bottom_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = bottom\n    value = 0\n  [../]\n[]\n\n[Materials]\n  # Chemical free energy of the matrix\n  [./fm]\n    type = DerivativeParsedMaterial\n    property_name = fm\n    coupled_variables = 'cm'\n    expression = '6.55*(cm-0.13)^2'\n  [../]\n\n  # Chemical Free energy of the precipitate phase\n  [./fp]\n    type = DerivativeParsedMaterial\n    property_name = fp\n    coupled_variables = 'cp'\n    expression = '6.55*(cp-0.235)^2'\n  [../]\n\n# Elastic energy of the precipitate\n  [./elastic_free_energy_p]\n    type = ElasticEnergyMaterial\n    f_name = f_el_mat\n    args = 'eta'\n    outputs = vtk\n  [../]\n\n\n  # h(eta)\n  [./h_eta]\n    type = SwitchingFunctionMaterial\n    h_order = HIGH\n    eta = eta\n  [../]\n\n  # 1- h(eta), putting in function explicitly\n  [./one_minus_h_eta_explicit]\n    type = DerivativeParsedMaterial\n    property_name = one_minus_h_explicit\n    coupled_variables = eta\n    expression = 1-eta^3*(6*eta^2-15*eta+10)\n    outputs = vtk\n  [../]\n\n  # g(eta)\n  [./g_eta]\n    type = BarrierFunctionMaterial\n    g_order = SIMPLE\n    eta = eta\n  [../]\n\n  # constant properties\n  [./constants]\n    type = GenericConstantMaterial\n    prop_names  = 'M   L   kappa      misfit'\n    prop_values = '0.7 0.7 0.01704    0.00377'\n  [../]\n\n  #Mechanical properties\n  [./Stiffness_matrix]\n    type = ComputeElasticityTensor\n    base_name = C_matrix\n    C_ijkl = '103.3 74.25 74.25 103.3 74.25 103.3 46.75 46.75 46.75'\n    fill_method = symmetric9\n  [../]\n  [./Stiffness_ppt]\n    type = ComputeElasticityTensor\n    C_ijkl = '100.7 71.45 71.45 100.7 71.45 100.7 50.10 50.10 50.10'\n    base_name = C_ppt\n    fill_method = symmetric9\n  [../]\n  [./C]\n    type = CompositeElasticityTensor\n    args = eta\n    tensors = 'C_matrix               C_ppt'\n    weights = 'one_minus_h_explicit   h'\n  [../]\n  [./stress]\n    type = ComputeLinearElasticStress\n  [../]\n  [./strain]\n    type = ComputeSmallStrain\n    displacements = 'disp_x disp_y disp_z'\n    eigenstrain_names = 'eigenstrain_ppt'\n  [../]\n  [./eigen_strain]\n    type = ComputeVariableEigenstrain\n    eigen_base = '0.00377 0.00377 0.00377 0 0 0'\n    prefactor = h\n    args = eta\n    eigenstrain_name = 'eigenstrain_ppt'\n  [../]\n[]\n\n[Kernels]\n  [./TensorMechanics]\n    displacements = 'disp_x disp_y disp_z'\n  [../]\n\n  # enforce c = (1-h(eta))*cm + h(eta)*cp\n  [./PhaseConc]\n    type = KKSPhaseConcentration\n    ca       = cm\n    variable = cp\n    c        = c\n    eta      = eta\n  [../]\n\n  # enforce pointwise equality of chemical potentials\n  [./ChemPotVacancies]\n    type = KKSPhaseChemicalPotential\n    variable = cm\n    cb       = cp\n    fa_name  = fm\n    fb_name  = fp\n  [../]\n\n  #\n  # Cahn-Hilliard Equation\n  #\n  [./CHBulk]\n    type = KKSSplitCHCRes\n    variable = c\n    ca       = cm\n    fa_name  = fm\n    w        = w\n  [../]\n\n  [./dcdt]\n    type = CoupledTimeDerivative\n    variable = w\n    v = c\n  [../]\n  [./ckernel]\n    type = SplitCHWRes\n    mob_name = M\n    variable = w\n  [../]\n\n  #\n  # Allen-Cahn Equation\n  #\n  [./ACBulkF]\n    type = KKSACBulkF\n    variable = eta\n    fa_name  = fm\n    fb_name  = fp\n    w        = 0.0264\n    args = 'cp cm'\n  [../]\n  [./ACBulkC]\n    type = KKSACBulkC\n    variable = eta\n    ca       = cm\n    cb       = cp\n    fa_name  = fm\n  [../]\n  [./ACBulk_el] #This adds df_el/deta for strain interpolation\n    type = AllenCahn\n    variable = eta\n    f_name = f_el_mat\n  [../]\n  [./ACInterface]\n    type = ACInterface\n    variable = eta\n    kappa_name = kappa\n  [../]\n  [./detadt]\n    type = TimeDerivative\n    variable = eta\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -sub_pc_type   -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm       ilu            nonzero'\n\n  l_max_its = 30\n  nl_max_its = 30\n  l_tol = 1.0e-4\n  nl_rel_tol = 1.0e-6\n  nl_abs_tol = 1.0e-8\n  num_steps = 200\n\n  [./TimeStepper]\n    type = SolutionTimeAdaptiveDT\n    dt = 0.01\n  [../]\n[]\n\n[Postprocessors]\n  [./f_el_int]\n    type = ElementIntegralMaterialProperty\n    mat_prop = f_el_mat\n  [../]\n  [./c_alpha]\n    type =  SideAverageValue\n    boundary = left\n    variable = c\n  [../]\n  [./c_beta]\n    type =  SideAverageValue\n    boundary = right\n    variable = c\n  [../]\n  [./e11_alpha]\n    type =  SideAverageValue\n    boundary = left\n    variable = e11\n  [../]\n  [./e11_beta]\n    type =  SideAverageValue\n    boundary = right\n    variable = e11\n  [../]\n  [./s11_alpha]\n    type =  SideAverageValue\n    boundary = left\n    variable = sigma11\n  [../]\n  [./s22_alpha]\n    type =  SideAverageValue\n    boundary = left\n    variable = sigma22\n  [../]\n  [./s33_alpha]\n    type =  SideAverageValue\n    boundary = left\n    variable = sigma33\n  [../]\n  [./s11_beta]\n    type =  SideAverageValue\n    boundary = right\n    variable = sigma11\n  [../]\n  [./s22_beta]\n    type =  SideAverageValue\n    boundary = right\n    variable = sigma22\n  [../]\n  [./s33_beta]\n    type =  SideAverageValue\n    boundary = right\n    variable = sigma33\n  [../]\n  [./f_el_alpha]\n    type =  SideAverageValue\n    boundary = left\n    variable = f_el\n  [../]\n  [./f_el_beta]\n    type =  SideAverageValue\n    boundary = right\n    variable = f_el\n  [../]\n  [./f_c_alpha]\n    type =  SideAverageValue\n    boundary = left\n    variable = Fglobal\n  [../]\n  [./f_c_beta]\n    type =  SideAverageValue\n    boundary = right\n    variable = Fglobal\n  [../]\n  [./chem_pot_alpha]\n    type =  SideAverageValue\n    boundary = left\n    variable = w\n  [../]\n  [./chem_pot_beta]\n    type =  SideAverageValue\n    boundary = right\n    variable = w\n  [../]\n  [./psi_alpha]\n    type =  SideAverageValue\n    boundary = left\n    variable = psi\n  [../]\n  [./psi_beta]\n    type =  SideAverageValue\n    boundary = right\n    variable = psi\n  [../]\n  [./total_energy]\n    type = ElementIntegralVariablePostprocessor\n    variable = Fglobal\n  [../]\n  # Get simulation cell size from postprocessor\n  [./volume]\n    type = ElementIntegralMaterialProperty\n    mat_prop = 1\n  [../]\n  [./psi_eq_int]\n    type = FunctionValuePostprocessor\n    function = psi_eq_int\n  [../]\n  [./psi_int]\n    type = ElementIntegralVariablePostprocessor\n    variable = psi\n  [../]\n  [./gamma]\n    type = FunctionValuePostprocessor\n    function = gamma\n  [../]\n  [./int_position]\n    type = FindValueOnLine\n    start_point = '-10 -10 0'\n    end_point = '10 10 0'\n    v = eta\n    target = 0.5\n  [../]\n[]\n\n#\n# Precondition using handcoded off-diagonal terms\n#\n[Preconditioning]\n  [./full]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Outputs]\n  [./vtk]\n    type = VTK\n    time_step_interval = 20\n  [../]\n  checkpoint = true\n  [./csv]\n    type = CSV\n    execute_on = 'final'\n  [../]\n[]\nEncountering Errors? Please include diagnostic output\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/28796",
          "updatedAt": "2024-10-07T02:31:13Z",
          "publishedAt": "2024-10-07T02:31:12Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "2020 darcy_thermo_mech example: Windows line endings issue",
          "author": {
            "login": "ColinMG2"
          },
          "bodyText": "Hello. I am trying to create a mesh for the darcy_thermo_mech example in the moose repository and when I run  ../darcy_therm\no_mech-opt -i step1_colin.i --mesh-only after defining my parameters in VSCode, I get this error: *** ERROR ***\n/home/colinmoose/projects/moose/tutorials/darcy_thermo_mech/step01_diffusion/problems/step1_colin.i contains Windows(DOS) line endings which are not supported.\nStack frames: 10\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits, std::allocator > >(std::__cxx11::basic_string<char, std::char_traits, std::allocator >&&)\n3: MooseUtils::checkFileReadable(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, bool, bool, bool)\n4: Parser::parse()\n5: Moose::createMooseApp(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, int, char**)\n6: ../darcy_thermo_mech-opt(+0x30cf) [0x562f0b1c00cf]\n7: /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7f24dfd75d90]\n8: __libc_start_main\n9: ../darcy_thermo_mech-opt(+0x337a) [0x562f0b1c037a]\nAbort(1) on node 0 (rank 0 in comm 0): application called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\nHow can I fix this issue?",
          "url": "https://github.com/idaholab/moose/discussions/28783",
          "updatedAt": "2024-10-05T22:00:21Z",
          "publishedAt": "2024-10-05T18:38:38Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "if you are using VSCode you can press control shift P and select \"change end of line sequence\"\nIf you are on linux you can use dos2unix in the command line to clear the file of DOS line endings",
                  "url": "https://github.com/idaholab/moose/discussions/28783#discussioncomment-10854426",
                  "updatedAt": "2024-10-05T19:17:19Z",
                  "publishedAt": "2024-10-05T19:17:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ColinMG2"
                          },
                          "bodyText": "Okay. I tried changing the line endings from CRLF to LF and it still failed to work. It could be because the MOOSE Language server is failing to connect to the server. Here is the error message I received in VSCode: [Error - 4:28:32 PM] MOOSE Language Server client: couldn't create connection to server.\nLaunching server using command \\wsl.localhost\\Ubuntu\\home\\colinmoose\\projects\\moose\\tutorials\\darcy_thermo_mech\\step01_diffusion\\darcy_thermo_mech-opt failed. Error: spawn \\wsl.localhost\\Ubuntu\\home\\colinmoose\\projects\\moose\\tutorials\\darcy_thermo_mech\\step01_diffusion\\darcy_thermo_mech-opt ENOENT",
                          "url": "https://github.com/idaholab/moose/discussions/28783#discussioncomment-10854712",
                          "updatedAt": "2024-10-05T20:31:21Z",
                          "publishedAt": "2024-10-05T20:31:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the languge server failures are not related I think\ndid the error change after the fix?\nare you using WSL? if so, is your text editor installed on the windows side?",
                          "url": "https://github.com/idaholab/moose/discussions/28783#discussioncomment-10854770",
                          "updatedAt": "2024-10-05T20:47:25Z",
                          "publishedAt": "2024-10-05T20:47:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ColinMG2"
                          },
                          "bodyText": "I am using wsl in the command terminal on a Windows 11 OS. The error did not change even after changing the line endings in VSCode. I could try doing it in the ubuntu terminal using dos2unix but I would have to do sudo apt install dos2unix",
                          "url": "https://github.com/idaholab/moose/discussions/28783#discussioncomment-10854800",
                          "updatedAt": "2024-10-05T20:55:03Z",
                          "publishedAt": "2024-10-05T20:55:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ColinMG2"
                          },
                          "bodyText": "My text editor is for the Windows version of VSCode.",
                          "url": "https://github.com/idaholab/moose/discussions/28783#discussioncomment-10854802",
                          "updatedAt": "2024-10-05T20:55:46Z",
                          "publishedAt": "2024-10-05T20:55:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "My text editor is for the Windows version of VSCode.\n\nIt probably saved again using CRLF right after you switched it. You ll have to change the settings to change the default line endings\n\nI could try doing it in the ubuntu terminal using dos2unix but I would have to do sudo apt install dos2unix\n\nthis would work. installing dos2unix is safe",
                          "url": "https://github.com/idaholab/moose/discussions/28783#discussioncomment-10854815",
                          "updatedAt": "2024-10-05T20:59:21Z",
                          "publishedAt": "2024-10-05T20:59:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ColinMG2"
                          },
                          "bodyText": "Okay I did dos2unix and that worked perfectly. This is my output now:  Mesh Information:\n  elem_dimensions()={2}\n  spatial_dimension()=2\n  n_nodes()=1111\n    n_local_nodes()=1111\n  n_elem()=1000\n    n_local_elem()=1000\n    n_active_elem()=1000\n  n_subdomains()=1\n  n_elemsets()=0\n  n_partitions()=1\n  n_processors()=1\n  n_threads()=1\n  processor_id()=0\n  is_prepared()=true\n  is_replicated()=true\n\n Mesh Bounding Box:\n  Minimum: (x,y,z)=(       0,        0,        0)\n  Maximum: (x,y,z)=(      10,       20,        0)\n  Delta:   (x,y,z)=(      10,       20,        0)\n\n Mesh Element Type(s):\n  QUAD4\n\n Mesh Nodesets:\n  Nodeset 0 (bottom), 101 nodes\n   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n   Bounding box maximum: (x,y,z)=(      10,        0,        0)\n   Bounding box delta: (x,y,z)=(      10,        0,        0)\n  Nodeset 1 (right), 11 nodes\n   Bounding box minimum: (x,y,z)=(      10,        0,        0)\n   Bounding box maximum: (x,y,z)=(      10,       20,        0)\n   Bounding box delta: (x,y,z)=(       0,       20,        0)\n  Nodeset 2 (top), 101 nodes\n   Bounding box minimum: (x,y,z)=(       0,       20,        0)\n   Bounding box maximum: (x,y,z)=(      10,       20,        0)\n   Bounding box delta: (x,y,z)=(      10,        0,        0)\n  Nodeset 3 (left), 11 nodes\n   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n   Bounding box maximum: (x,y,z)=(       0,       20,        0)\n   Bounding box delta: (x,y,z)=(       0,       20,        0)\n\n Mesh Sidesets:\n  Sideset 0 (bottom), 100 sides (EDGE2), 100 elems (QUAD4), 101 nodes\n   Side volume: 10\n   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n   Bounding box maximum: (x,y,z)=(      10,        0,        0)\n   Bounding box delta: (x,y,z)=(      10,        0,        0)\n  Sideset 1 (right), 10 sides (EDGE2), 10 elems (QUAD4), 11 nodes\n   Side volume: 20\n   Bounding box minimum: (x,y,z)=(      10,        0,        0)\n   Bounding box maximum: (x,y,z)=(      10,       20,        0)\n   Bounding box delta: (x,y,z)=(       0,       20,        0)\n  Sideset 2 (top), 100 sides (EDGE2), 100 elems (QUAD4), 101 nodes\n   Side volume: 10\n   Bounding box minimum: (x,y,z)=(       0,       20,        0)\n   Bounding box maximum: (x,y,z)=(      10,       20,        0)\n   Bounding box delta: (x,y,z)=(      10,        0,        0)\n  Sideset 3 (left), 10 sides (EDGE2), 10 elems (QUAD4), 11 nodes\n   Side volume: 20\n   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n   Bounding box maximum: (x,y,z)=(       0,       20,        0)\n   Bounding box delta: (x,y,z)=(       0,       20,        0)\n\n Mesh Edgesets:\n  None\n\n Mesh Subdomains:\n  Subdomain 0: 1000 elems (QUAD4, 1000 active), 1111 active nodes\n   Volume: 200\n   Bounding box minimum: (x,y,z)=(       0,        0,        0)\n   Bounding box maximum: (x,y,z)=(      10,       20,        0)\n   Bounding box delta: (x,y,z)=(      10,       20,        0)\n  Global mesh volume = 200\n\nHow can I fix the language server issues so I can have autofill in VSCode?",
                          "url": "https://github.com/idaholab/moose/discussions/28783#discussioncomment-10854826",
                          "updatedAt": "2024-10-05T21:23:03Z",
                          "publishedAt": "2024-10-05T21:04:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you cannot fix it easily from Windows I suspect.\nThe easiest would be to install VSCode on the linux side, then once it finds a working executable for your application, it can generate the acceptable syntax list.\nIf you want to try to fix the windows VSCode plugin, then you need to generate the syntax dump in linux using <your executable> --json, then make VSCode on windows find that file. I m not sure how to do that last part",
                          "url": "https://github.com/idaholab/moose/discussions/28783#discussioncomment-10854921",
                          "updatedAt": "2024-10-05T21:24:51Z",
                          "publishedAt": "2024-10-05T21:24:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ColinMG2"
                          },
                          "bodyText": "I was able to fix the windows VSCode plugin by properly running in WSL: Ubuntu on VSCode. I now have the autofill capabilities from the MOOSE Language extension.",
                          "url": "https://github.com/idaholab/moose/discussions/28783#discussioncomment-10855064",
                          "updatedAt": "2024-10-05T22:00:22Z",
                          "publishedAt": "2024-10-05T22:00:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}