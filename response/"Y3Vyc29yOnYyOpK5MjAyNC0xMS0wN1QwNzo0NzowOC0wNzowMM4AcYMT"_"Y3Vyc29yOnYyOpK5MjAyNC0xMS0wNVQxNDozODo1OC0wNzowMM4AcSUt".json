{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMS0wNVQxNDozODo1OC0wNzowMM4AcSUt"
    },
    "edges": [
      {
        "node": {
          "title": "Reference",
          "author": {
            "login": "Rahim-Habibi"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\n Hi all,\nI would like to know more details about the theory you described here (link). Can you please refer me to paper or book you used for?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/28940",
          "updatedAt": "2024-11-07T12:43:41Z",
          "publishedAt": "2024-10-27T11:52:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "@sapitts looks like you were the one that wrote this; can you comment?",
                  "url": "https://github.com/idaholab/moose/discussions/28940#discussioncomment-11069514",
                  "updatedAt": "2024-10-28T00:55:56Z",
                  "publishedAt": "2024-10-28T00:55:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Unfortunately all I did was to transfer this documentation over to MooseDocs from the old system. @WilkAndy is the one who wrote the original text. If he's not monitoring GitHub notifications, maybe @bwspenc can comment?",
                          "url": "https://github.com/idaholab/moose/discussions/28940#discussioncomment-11075887",
                          "updatedAt": "2024-10-28T14:59:55Z",
                          "publishedAt": "2024-10-28T14:59:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Rahim-Habibi"
                          },
                          "bodyText": "Hi @sapitts\nThanks for your reply.\n@bwspenc any comment?\nRahim",
                          "url": "https://github.com/idaholab/moose/discussions/28940#discussioncomment-11177538",
                          "updatedAt": "2024-11-07T12:43:41Z",
                          "publishedAt": "2024-11-07T12:43:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "HPC issue on running MOOSE: obtain different results when using multiple nodes compared with single node",
          "author": {
            "login": "chunhuizhao478"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi all,\nI encounter a serious issue that obtain different results when running on Expanse cluster. The first case I use single node, 40 cores per node, the second case I use 2 nodes, 40 cores per node (80 cores in total), it appears the results for single node works fine (produce zero velocity field), but for the 2 nodes case, there are weird velocity field observed in the domain, I have a custom stress material object, and I suspect it is due to mesh partition and node communications, and I wonder what I should do to debug such issue, thanks!",
          "url": "https://github.com/idaholab/moose/discussions/28999",
          "updatedAt": "2024-11-07T07:29:49Z",
          "publishedAt": "2024-11-04T22:04:03Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\ncan you please attach the convergence logs for both solves, as well as the Executioner block in use\nthx\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28999#discussioncomment-11148032",
                  "updatedAt": "2024-11-04T22:36:33Z",
                  "publishedAt": "2024-11-04T22:36:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks @GiudGiud I will update it later and let you know!",
                          "url": "https://github.com/idaholab/moose/discussions/28999#discussioncomment-11148514",
                          "updatedAt": "2024-11-05T00:08:07Z",
                          "publishedAt": "2024-11-05T00:08:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "multi_nodes.txt\nsingle_node.txt\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    # solve_type = 'PJFNK'\n    start_time = -1e-12\n    end_time = 1e100\n    num_steps = 200\n    l_max_its = 200\n    l_tol = 1e-7\n    nl_rel_tol = 1e-6\n    nl_max_its = 10\n    nl_abs_tol = 1e-8\n    petsc_options_iname = '-ksp_type -pc_type -ksp_initial_guess_nonzero'\n    petsc_options_value = 'gmres     hypre True'\n    # petsc_options_iname = '-pc_type -pc_factor_shift_type'\n    # petsc_options_value = 'lu       NONZERO'\n    # petsc_options_iname = '-ksp_type -pc_type -pc_hypre_type  -ksp_initial_guess_nonzero -ksp_pc_side -ksp_max_it -ksp_rtol -ksp_atol'\n    # petsc_options_value = 'gmres        hypre      boomeramg                   True        right       1500        1e-7      1e-9    '\n    # petsc_options_iname = '-ksp_type -pc_type'\n    # petsc_options_value = 'gmres ilu' \n    # petsc_options_iname = '-ksp_type -pc_type'\n    # petsc_options_value = 'preonly lu'    \n    automatic_scaling = true\n    # nl_forced_its = 3\n    # line_search = 'bt'\n    # dt = 1e-2\n    [TimeStepper]\n        type = FarmsIterationAdaptiveDT\n        dt = 0.01\n        cutback_factor_at_failure = 0.5\n        optimal_iterations = 5\n        growth_factor = 1.5\n        max_time_step_bound = 1e10\n    []\n    [./TimeIntegrator]\n        type = NewmarkBeta\n        beta = 0.25\n        gamma = 0.5\n        inactive_tsteps = 1\n    [../]\n[]\n\nHi @GiudGiud, I have attached Muti-cores (2:40) and single-core (1:40) logs, and the execution block. Let me know if you have any suggestions, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/28999#discussioncomment-11148675",
                          "updatedAt": "2024-11-05T00:40:37Z",
                          "publishedAt": "2024-11-05T00:40:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "do you really need to be running to these insane times? 10^11s is 3000 years\nwhat are you simulating?\nThis is somewhat loose.\nI dont think that's what's biting you on the final time steps but it could be if the results in the first few time steps are wrong.\nAre the results different for the first few time steps?\n    nl_rel_tol = 1e-6",
                          "url": "https://github.com/idaholab/moose/discussions/28999#discussioncomment-11160359",
                          "updatedAt": "2024-11-05T23:20:05Z",
                          "publishedAt": "2024-11-05T23:20:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi @GiudGiud, I think I figure it out, I have a damage region defined in the central domain, if I refine the damage region and adopt a more smooth transition from maximum damage to zero damage, the imbalance of strain can be reduced and eventually gone.",
                          "url": "https://github.com/idaholab/moose/discussions/28999#discussioncomment-11174388",
                          "updatedAt": "2024-11-07T07:29:48Z",
                          "publishedAt": "2024-11-07T07:29:47Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Libmesh error when developing a custom auxkernel to solve for the flux of atoms & defects in a binary alloy",
          "author": {
            "login": "swonner"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI am trying to develop an auxkernel to solve for the following equation & others similarly like it to get JA, JB, JI, and JV:\n\ud835\udc3d\ud835\udc34 = 1/(\ud835\udc58\ud835\udc35 * \ud835\udc47)[\ud835\udc3f\ud835\udc34\ud835\udc34V(\u2207\ud835\udf07\ud835\udc34\u2212\u2207\ud835\udf07\ud835\udc49) + \ud835\udc3f\ud835\udc34\ud835\udc35\ud835\udc49*(\u2207\ud835\udf07\ud835\udc35\u2212\u2207\ud835\udf07\ud835\udc49) + \ud835\udc3f\ud835\udc34\ud835\udc34\ud835\udc3c*(\u2207\ud835\udf07\ud835\udc34+\u2207\ud835\udf07\ud835\udc3c) + \ud835\udc3f\ud835\udc34\ud835\udc35\ud835\udc3c*(\u2207\ud835\udf07\ud835\udc35+ \u2207\ud835\udf07\ud835\udc3c)]\nAll onsager coefficients (L) will be materials properties, and chemical potentials (\ud835\udf07) I plan to solve for with another auxkernel. Fluxes (J) will be input into the kernels block to ultimately solve (\ud835\udf15\ud835\udc4b\ud835\udc34)/\ud835\udf15\ud835\udc61 + \u2207\u2219\ud835\udc3dA = 0, etc.\nI am having issue compiling the custom auxkernel I have developed for J, seemingly based on libMesh issue. Please see below for more details on the custom kernel and error.\nI am quite new to MOOSE and am having trouble finding the solution to this issue. May I please receive some guidance on the origin of this error and how to possibly remedy this issue?\nHeader File\n#pragma once\n#include \"AuxKernel.h\"\n\nclass ADAuxFluxA : public AuxKernel\n{\npublic: \n   static InputParameters validParams();\n\n   ADAuxFluxA(const InputParameters & parameters);\n\nprotected:\n   virtual Real computeValue();\n\n   // Boltzmann Constant\n   const ADMaterialProperty<Real> & _k;\n\n   // Temperature\n   const ADMaterialProperty<Real> & _T;\n\n   // LAAV\n   const ADMaterialProperty<Real> & _LAAV;\n\n   // LABV\n   const ADMaterialProperty<Real> & _LABV;\n\n   // LAAI\n   const ADMaterialProperty<Real> & _LAAI;\n\n   // LABI\n   const ADMaterialProperty<Real> & _LABI;\n\n   //muA\n   const ADVariableGradient & _grad_muA;\n\n   //muB\n   const ADVariableGradient & _grad_muB;\n\n   //muV\n   const ADVariableGradient & _grad_muV;\n\n   //muI\n   const ADVariableGradient & _grad_muI;\n\n}; \n\nSource Code\n\n/**\n* Solving for the flux of A atoms\n* when using the assumption that intersitials are not exchanging with B atoms == (LABI = 0)\n* \ud835\udc3d\ud835\udc34\ud835\udc65 = 1/(\ud835\udc58\ud835\udc35*\ud835\udc47)*[\ud835\udc3f\ud835\udc34\ud835\udc34V*(\u2207\ud835\udf07\ud835\udc34\u2212\u2207\ud835\udf07\ud835\udc49) + \ud835\udc3f\ud835\udc34\ud835\udc35\ud835\udc49*(\u2207\ud835\udf07\ud835\udc35\u2212\u2207\ud835\udf07\ud835\udc49) + \ud835\udc3f\ud835\udc34\ud835\udc34\ud835\udc3c*(\u2207\ud835\udf07\ud835\udc34+\u2207\ud835\udf07\ud835\udc3c) + \ud835\udc3f\ud835\udc34\ud835\udc35\ud835\udc3c*(\u2207\ud835\udf07\ud835\udc35+ \u2207\ud835\udf07\ud835\udc3c)] \n*/\n//\n\n\n#include \"ADAuxFluxA.h\"\n\nregisterMooseObject(\"RadiationInducedSegregation\", ADAuxFluxA);\n\nInputParameters\nADAuxFluxA::validParams()\n{\n   InputParameters params = AuxKernel::validParams();\n   params.addClassDescription(\"Calculates the flux of A atoms\");\n   params.addRequiredParam<MaterialPropertyName>(\"k\", \"boltzmann constant\");\n   params.addRequiredParam<MaterialPropertyName>(\"Temp\", \"Temperature\");\n   params.addParam<MaterialPropertyName>(\"LAAV\", 0.0, \"Onsager Coe for LAA^v\");\n   params.addParam<MaterialPropertyName>(\"LABV\", 0.0, \"Onsager Coe for LAB^v\");\n   params.addParam<MaterialPropertyName>(\"LAAI\", 0.0, \"Onsager Coe for LAA^i\"); \n   params.addParam<MaterialPropertyName>(\"LABI\", 0.0, \"Onsager Coe for LAA^i\"); \n\n   params.addRequiredCoupledVar(\"muA\", \"Chemical Potential for A. The gradient of this variable will be used.\");\n   params.addRequiredCoupledVar(\"muB\", \"Chemical Potential for B. The gradient of this variable will be used.\");\n   params.addRequiredCoupledVar(\"muV\", \"Chemical Potential for V. The gradient of this variable will be used.\");    \n   params.addRequiredCoupledVar(\"muI\", \"Chemical Potential for I. The gradient of this variable will be used.\");\n   return params;\n}\n\nADAuxFluxA::ADAuxFluxA(const InputParameters & parameters)\n : AuxKernel(parameters),\n   _k(getADMaterialProperty<Real>(\"k\")), \n   _T(getADMaterialProperty<Real>(\"Temp\")),\n   _LAAV(getADMaterialProperty<Real>(\"LAAV\")),\n   _LABV(getADMaterialProperty<Real>(\"LABV\")),\n   _LAAI(getADMaterialProperty<Real>(\"LAAI\")),\n   _LABI(getADMaterialProperty<Real>(\"LABI\")),    \n   _grad_muA(adCoupledGradient(\"muA\")),\n   _grad_muB(adCoupledGradient(\"muB\")),\n   _grad_muV(adCoupledGradient(\"muV\")),\n   _grad_muI(adCoupledGradient(\"muI\"))\n{\n   \n}\n\nReal\nADAuxFluxA::computeValue()\n{\n return (1/_k[_qp]*_T[_qp]) * ( _LAAV[_qp]*(_grad_muA[_qp] - _grad_muV[_qp])\n                              + _LABV[_qp]*(_grad_muB[_qp] - _grad_muV[_qp]) \n                              + _LAAI[_qp]*(_grad_muA[_qp] + _grad_muI[_qp])   \n                              + _LABI[_qp]*(_grad_muB[_qp] + _grad_muI[_qp]));\n} \n   \n\nERROR\nADAuxFluxA.C: In member function 'virtual libMesh::Real ADAuxFluxA::computeValue()':\nADAuxFluxA.C:55:30: error: cannot convert 'libMesh::boostcopy::enable_if_c<true, libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true> > >::type' {aka 'libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true> >'} to 'libMesh::Real' {aka 'double'} in return\n  55 |   return (1/_k[_qp]*_T[_qp]) * ( _LAAV[_qp]*(_grad_muA[_qp] - _grad_muV[_qp])\n     |          ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n     |                              |\n     |                              libMesh::boostcopy::enable_if_c<true, libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true> > >::type {aka libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true> >}\n  56 |                                + _LABV[_qp]*(_grad_muB[_qp] - _grad_muV[_qp])\n     |                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  57 |                                + _LAAI[_qp]*(_grad_muA[_qp] + _grad_muI[_qp])\n     |                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  58 |                                + _LABI[_qp]*(_grad_muB[_qp] + _grad_muI[_qp]));\n     |                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
          "url": "https://github.com/idaholab/moose/discussions/29003",
          "updatedAt": "2024-11-06T21:57:40Z",
          "publishedAt": "2024-11-05T06:37:07Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo this expression as a whole seems to evaluate to an ADVector.\nThis makes sense because k, T are ADReal, then the Ls are Real and finially the gradients are vectors.\nSo this makes for an ADVector.\nBut the return type is a Real, so it is both:\n\nnot AD\na scalar not a vector.\n\nTo turn an AD number into a regular number you can use: Real a = MetaPhysicL::raw_value(b);\nto turn a vector into a number, you need to either:\n\ntake a dot product\nchoose a component\nWhich one fits here?",
                  "url": "https://github.com/idaholab/moose/discussions/29003#discussioncomment-11160328",
                  "updatedAt": "2024-11-05T23:12:35Z",
                  "publishedAt": "2024-11-05T23:12:35Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "swonner"
                          },
                          "bodyText": "Hello!  Thank you so much for your for your response!\nYou are correct that the expression is evaluating a vector, $\\vec{J}_A$. I now understand based on your answer that I have incorrectly written the auxkernel to calculate a number and that the variable types are currently incompatible as written.\nBased on your response and since what I want to calculate is a vector, I believe I should edit the auxkernel to correctly calculate a RealVectorValue.\nI attempted my revision by changing instances of AuxKernel to VectorAuxKernel and instances Real to RealVectorValue as seen below. I also attempted to utilize MetaPhysicL::raw_value(). However, I am still having trouble with the incompatible variables types. May I please receive some additional guidance on how I might approach this revision?\nHeader File\n\n\n#pragma once\n#include \"AuxKernel.h\"\n\nclass ADAuxFluxA : public VectorAuxKernel // changed AuxKernel to VectorAuxKernel\n{\npublic: \n    static InputParameters validParams();\n\n    ADAuxFluxA(const InputParameters & parameters);\n\nprotected:\n    virtual RealVectorValue computeValue(); // changed Real to RealVectorValue\n\n    // Boltzmann Constant\n    const ADMaterialProperty<Real> & _k;\n\n    // Temperature\n    const ADMaterialProperty<Real> & _T;\n\n    // LAAV\n    const ADMaterialProperty<Real> & _LAAV;\n\n    // LABV\n    const ADMaterialProperty<Real> & _LABV;\n\n    // LAAI\n    const ADMaterialProperty<Real> & _LAAI;\n\n    // LABI\n    const ADMaterialProperty<Real> & _LABI;\n\n    //muA\n    const ADVariableGradient & _grad_muA;\n\n    //muB\n    const ADVariableGradient & _grad_muB;\n\n    //muV\n    const ADVariableGradient & _grad_muV;\n\n    //muI\n    const ADVariableGradient & _grad_muI;\n\n};\n\nSource File\n\n\n#include \"ADAuxFluxA.h\"\n\nregisterMooseObject(\"RadiationInducedSegregation\", ADAuxFluxA);\n\nInputParameters\nADAuxFluxA::validParams()\n{\n    InputParameters params = VectorAuxKernel::validParams(); // changed AuxKernel to VectorAuxKernel\n    params.addClassDescription(\"Calculates the flux of A atoms\");\n    params.addRequiredParam<MaterialPropertyName>(\"k\", \"boltzmann constant\");\n    params.addRequiredParam<MaterialPropertyName>(\"Temp\", \"Temperature\");\n    params.addParam<MaterialPropertyName>(\"LAAV\", 0.0, \"Onsager Coe for LAA^v\");\n    params.addParam<MaterialPropertyName>(\"LABV\", 0.0, \"Onsager Coe for LAB^v\");\n    params.addParam<MaterialPropertyName>(\"LAAI\", 0.0, \"Onsager Coe for LAA^i\"); \n    params.addParam<MaterialPropertyName>(\"LABI\", 0.0, \"Onsager Coe for LAA^i\"); \n\n    params.addRequiredCoupledVar(\"muA\", \"Chemical Potential for A. The gradient of this variable will be used.\");\n    params.addRequiredCoupledVar(\"muB\", \"Chemical Potential for B. The gradient of this variable will be used.\");\n    params.addRequiredCoupledVar(\"muV\", \"Chemical Potential for V. The gradient of this variable will be used.\");    \n    params.addRequiredCoupledVar(\"muI\", \"Chemical Potential for I. The gradient of this variable will be used.\");\n    return params;\n}\n\nADAuxFluxA::ADAuxFluxA(const InputParameters & parameters)\n  : VectorAuxKernel(parameters), // changed AuxKernel to VectorAuxKernel\n    _k(getADMaterialProperty<Real>(\"k\")), \n    _T(getADMaterialProperty<Real>(\"Temp\")),\n    _LAAV(getADMaterialProperty<Real>(\"LAAV\")),\n    _LABV(getADMaterialProperty<Real>(\"LABV\")),\n    _LAAI(getADMaterialProperty<Real>(\"LAAI\")),\n    _LABI(getADMaterialProperty<Real>(\"LABI\")),    \n    _grad_muA(adCoupledGradient(\"muA\")),\n    _grad_muB(adCoupledGradient(\"muB\")),\n    _grad_muV(adCoupledGradient(\"muV\")),\n    _grad_muI(adCoupledGradient(\"muI\"))\n{\n    \n}\n\nRealVectorValue // changed Real to RealVectorValue\nADAuxFluxA::computeValue()\n{\n  return MetaPhysicL::raw_value(1/_k[_qp]*_T[_qp]) * ( MetaPhysicL::raw_value(_LAAV[_qp]) * (_grad_muA[_qp] - _grad_muV[_qp])\n                                                     + MetaPhysicL::raw_value(_LABV[_qp]) * (_grad_muB[_qp] - _grad_muV[_qp]) \n                                                     + MetaPhysicL::raw_value(_LAAI[_qp]) * (_grad_muA[_qp] + _grad_muI[_qp])   \n                                                     + MetaPhysicL::raw_value(_LABI[_qp]) * (_grad_muB[_qp] + _grad_muI[_qp]));\n} \n    \n\nError\nIn file included from /libmesh/point.h:24,\n                 from bounding_box.h:25,\n                 from MooseUtils.h:22,\n                 fromInputParameters.h:13,\n                 from MooseObject.h:13,\n                 fromAuxKernel.h:12,\n                 from ADAuxFluxA.h:7,\n                 from/src/ADAuxFluxA.C:13:\n\\libmesh/type_vector.h: In instantiation of 'libMesh::TypeVector<T>::TypeVector(const libMesh::TypeVector<T2>&) [with T2 = MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>; T = double]':\nvector_value.h:208:19:   required from 'libMesh::VectorValue<T>::VectorValue(const libMesh::TypeVector<T2>&) [with T2 = MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>; T = double]'\nADAuxFluxA.C:58:126:   required from here\nibmesh/type_vector.h:555:27: error: cannot convert 'const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>' to 'double' in assignment\n  555 |     _coords[i] = p._coords[i];\n      |                  ~~~~~~~~~^\n      |                           |\n      |                           const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true>",
                          "url": "https://github.com/idaholab/moose/discussions/29003#discussioncomment-11170440",
                          "updatedAt": "2024-11-06T19:55:07Z",
                          "publishedAt": "2024-11-06T19:55:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you need to remote AD form the entire thing\n  return MetaPhysicL::raw_value(1/_k[_qp]*_T[_qp] * ( MetaPhysicL::raw_value(_LAAV[_qp]) * (_grad_muA[_qp] - _grad_muV[_qp])\n                                                     + MetaPhysicL::raw_value(_LABV[_qp]) * (_grad_muB[_qp] - _grad_muV[_qp]) \n                                                     + MetaPhysicL::raw_value(_LAAI[_qp]) * (_grad_muA[_qp] + _grad_muI[_qp])   \n                                                     + MetaPhysicL::raw_value(_LABI[_qp]) * (_grad_muB[_qp] + _grad_muI[_qp])));\n} \n\nif that does not compile, remove AD from the gradients as well",
                          "url": "https://github.com/idaholab/moose/discussions/29003#discussioncomment-11170473",
                          "updatedAt": "2024-11-06T20:00:30Z",
                          "publishedAt": "2024-11-06T20:00:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "swonner"
                          },
                          "bodyText": "I see, thank you so much!! This was very helpful.\nConverting the _grad_mu variables in that way did not work, but I was able to make it compile after changing ADVariableGradient to VariableGradient, and adCoupledGradient to coupledGradient - effectively removing the AD from the gradient terms.",
                          "url": "https://github.com/idaholab/moose/discussions/29003#discussioncomment-11171282",
                          "updatedAt": "2024-11-06T21:55:46Z",
                          "publishedAt": "2024-11-06T21:55:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question on Phase Field Fracture simulation results of the first time step",
          "author": {
            "login": "Lingfu-Liu"
          },
          "bodyText": "I created a model coupled solid mechanics and phase field method to study 1D bar elongation with damage by gradually adding loads (specify strain). I notice a very strange phenomenon that the first time step can not creat any damage no matter how huge strain I specify.\nMy script is attached as below.\n\n[Mesh]\ntype = GeneratedMesh\ndim = 1\nnx = 50\nxmin = 0.0\nxmax = 1.0\n[]\n[GlobalParams]\ndisplacements = 'disp'\n[]\n[Variables]\n[./disp]  # displacement\norder = FIRST\nfamily = LAGRANGE\n[../]\n[./d] # Phase field\norder = FIRST\nfamily = LAGRANGE\n[../]\n[]\n[Physics/SolidMechanics/QuasiStatic]\n[./mech]\nstrain = SMALL\nadd_variables = true\ngenerate_output = stress_xx\nmaterial_output_family = LAGRANGE\nmaterial_output_order = FIRST\n[../]\n[]\n[Modules/PhaseField/Nonconserved]\n[./d]\nfree_energy = F\nkappa = kappa_op\nmobility = L\n[../]\n[]\n[Kernels]\n[./couple]\ntype = PhaseFieldFractureMechanicsOffDiag\nvariable = disp\ncomponent = 0\nc = d\n[../]\n[]\n[BCs]\n[./left_fixed]\ntype = DirichletBC\nboundary = left\nvariable = disp\nvalue = 0.0\n[../]\n[./xdisp]\ntype = FunctionDirichletBC\nvariable = disp\nboundary = right\nfunction = 't'\n[../]\n[]\n[Materials]\n[./elasticity_tensor]\ntype = ComputeIsotropicElasticityTensor\nyoungs_modulus = 100e9  # Pa\npoissons_ratio = 0\n[../]\n[./pfbulkmat]\ntype = GenericConstantMaterial\n# gc_prop: Critical energy release rate (Energy required to create fractures per unit area)\n# l: internal length scale (diffusion leng;pth paramter)\n# visco: damping coefficient of phase field\n# c0: paramter in crack geometrical function (a(d)=d^2 ==> c0 =2)\nprop_names = 'gc_prop l visco c0'\nprop_values = '1 0.1 1e-4 2'\n[../]\n[./define_mobility]\ntype = ParsedMaterial\nproperty_name = L\nmaterial_property_names = 'visco'\nexpression = '1.0/visco'\n[../]\n[./define_kappa]\ntype = ParsedMaterial\nproperty_name = kappa_op\nmaterial_property_names = 'gc_prop l c0'\nexpression = '2 * gc_prop * l / c0'\n[../]\n[./elastic]\ntype = ComputeLinearElasticPFFractureStress\nc = d\nE_name = 'elastic_energy'\nD_name = 'degradation'\nF_name = 'local_fracture_energy'\ndecomposition_type = strain_spectral\n[../]\n[./degradation]\ntype = DerivativeParsedMaterial\nproperty_name = degradation\ncoupled_variables = 'd'\nexpression = (1-d)^p*(1-delta)+delta\nconstant_names       = 'p delta'\nconstant_expressions = '2 1e-6'\nderivative_order = 2\n[../]\n[./local_fracture_energy]\ntype = DerivativeParsedMaterial\nproperty_name = local_fracture_energy\ncoupled_variables = d\nmaterial_property_names = 'gc_prop c0 l'\nexpression = 'gc_prop * d^2 / c0 / l'\nderivative_order = 2\n[../]\n[./fracture_driving_energy]\ntype = DerivativeSumMaterial\nproperty_name = F\ncoupled_variables = d\nsum_materials = 'elastic_energy local_fracture_energy'\nderivative_order = 2\n[../]\n[]\n[Executioner]\ntype = Transient\ndt = 1e-6\nsolve_type = PJFNK\nend_time = 1e-5\n[]\n[Outputs]\nexodus = true\n[./csv]\ntype = CSV\n[../]\n[]\n[Postprocessors]\n[u(end)]\ntype = PointValue\npoint = '1 0 0'\nvariable = disp\nexecute_on = TIMESTEP_END\n[]\n[d_ave]\ntype = ElementAverageValue\nvariable = 'd'\nexecute_on = TIMESTEP_END\n[]\n[sigma_xx_ave]\ntype = ElementAverageValue\nvariable = 'stress_xx'\nexecute_on = TIMESTEP_END\n[]\n[]\n\nPostprocessor Values:\n(Table 1)\n+----------------+----------------+----------------+----------------+\n| time                     | d_ave                  | sigma_xx_ave   | u(end)                |\n+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-06 |   0.000000e+00 |   1.000000e+05 |   1.000000e-06 |\n|   2.000000e-06 |   9.082643e-04 |   1.996369e+05 |   2.000000e-06 |\n|   3.000000e-06 |   4.445888e-03 |   2.973384e+05 |   3.000000e-06 |\n|   4.000000e-06 |   1.212433e-02 |   3.903593e+05 |   4.000000e-06 |\n|   5.000000e-06 |   2.520100e-02 |   4.751166e+05 |   5.000000e-06 |\n|   6.000000e-06 |   4.462309e-02 |   5.476471e+05 |   6.000000e-06 |\n|   7.000000e-06 |   7.097100e-02 |   6.041665e+05 |   7.000000e-06 |\n|   8.000000e-06 |   1.044134e-01 |   6.416605e+05 |   8.000000e-06 |\n|   9.000000e-06 |   1.446850e-01 |   6.584077e+05 |   9.000000e-06 |\n|   1.000000e-05 |   1.910964e-01 |   6.543253e+05 |   1.000000e-05 |\n+----------------+----------------+----------------+----------------+\nIn above table, \"time\" is equavalent to \"strain\" specified to the system. I manually calculate the analitical solution of \"strain\" versus \"d\"(phase filed of damage) with the belowing implicite process.\n\n\nI have the following results.\n(Table 2)\nstrain       | d_analitical\n0.00E+00 | 0\n1.00E-06 | 0.000908265\n2.00E-06 | 0.004445892\n3.00E-06 | 0.012124339\n4.00E-06 | 0.025201021\n5.00E-06 | 0.04462313\n6.00E-06 | 0.070971065\n7.00E-06 | 0.104413459\n8.00E-06 | 0.144685103\n9.00E-06 | 0.191096615\n1.00E-05 | 0.242580513\nBy comparing results in Tables 1 and 2, you may find that if I delete the data of \"d\" at the second row and second column in Table 1, the rest data of \"time\" vs \"d_ave\" in Table 1 matches well with \"strain\" vs \"d_analitical\" in Table 2.\nIn summary, my question is why there is a zero damage (d=0) results at first time step. Even I specify a very huge strain (e.g., 1), \"d\" is always equal to 0 at first time step.",
          "url": "https://github.com/idaholab/moose/discussions/28858",
          "updatedAt": "2024-11-06T17:36:19Z",
          "publishedAt": "2024-10-16T01:30:48Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe first result in the table (if the table comes from MOOSE console output) in not from the first time step, but rather the INITIAL step.\nAnd by default, no object is computed on INITIAL.\nTo get computations on initial, you need to run the postprocessors / auxkernels / etc (anything involved in computing this value) on INITIAL.\nthis can be done by setting execute_on = 'INITIAL TIMESTEP_END' for example\nNote that at t=0 (=strain = 0 here?), you expect to only see any damage?\nEDIT: my bad. I misread the last table as the output from MOOSE",
                  "url": "https://github.com/idaholab/moose/discussions/28858#discussioncomment-10962025",
                  "updatedAt": "2024-10-17T15:24:43Z",
                  "publishedAt": "2024-10-16T16:17:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Lingfu-Liu"
                          },
                          "bodyText": "Thank you for your response.\nI included execute_on = TIMESTEP_END in all postprocessors - referring to my scripts.\nI need to clarify that the first time step means t=dt=1e-6=strain. I see the stress becomes none zero at end of the first time step, but the damage (d) keeps zero. Even I set the strain=dt=1, the value of d always keeps zero at the end of first time step. I don't know how it works.\nI am thinking if the problem is about the solving processes. Does MOOSE apply a fully coupled solver, i.e. solve two variables (disp and d in my case) simultaneously with one Jacobin matrix? Or does MOOSE solve \"disp\" first while keeping \"d\" as constant in the [QuasiStatic] Block, then update \"d\" with the new \"disp\" in the [Nonconserved] Block, while keeping the \"disp\" as constant (input) and only solving \"d\"?",
                          "url": "https://github.com/idaholab/moose/discussions/28858#discussioncomment-10962414",
                          "updatedAt": "2024-10-16T18:56:26Z",
                          "publishedAt": "2024-10-16T16:56:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nI dont see anything in the input file that deviates from the fully coupled apprach. So it should solve all variables together",
                          "url": "https://github.com/idaholab/moose/discussions/28858#discussioncomment-10963493",
                          "updatedAt": "2024-10-16T19:05:32Z",
                          "publishedAt": "2024-10-16T19:05:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Lingfu-Liu"
                          },
                          "bodyText": "Hi,\nThank you for your answering.\nI created a new test simulation by specifying initial displacement (u_i=1e-6*x) while keeping d_i=0. Then I add loads by specifing u_end = dt+1e-6. I found out the value of \"d\" also keeps at 0 at end of the first time step (as shown in the second row and second column of the following Postprocessor results), which means MOOSE doesn't run with my assumed non-fully coupled method.\nDo you have any idea why phase field variable \"d\" is not updated in the first time step?\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+\n| time           | d_ave          | sigma_xx_ave   | u(end)         |\n+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   1.000000e-06 |\n|   1.000000e-06 |   0.000000e+00 |   2.000000e+05 |   2.000000e-06 |\n|   2.000000e-06 |   3.623185e-03 |   2.978300e+05 |   3.000000e-06 |\n|   3.000000e-06 |   1.138249e-02 |   3.909458e+05 |   4.000000e-06 |\n|   4.000000e-06 |   2.453626e-02 |   4.757648e+05 |   5.000000e-06 |\n|   5.000000e-06 |   4.403221e-02 |   5.483247e+05 |   6.000000e-06 |\n|   6.000000e-06 |   7.045086e-02 |   6.048432e+05 |   7.000000e-06 |\n|   7.000000e-06 |   1.039607e-01 |   6.423093e+05 |   8.000000e-06 |\n|   8.000000e-06 |   1.442961e-01 |   6.590065e+05 |   9.000000e-06 |\n|   9.000000e-06 |   1.907671e-01 |   6.548582e+05 |   1.000000e-05 |\n|   1.000000e-05 |   2.423059e-01 |   6.315109e+05 |   1.100000e-05 |\n+----------------+----------------+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/28858#discussioncomment-10964023",
                          "updatedAt": "2024-10-16T20:18:32Z",
                          "publishedAt": "2024-10-16T20:07:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm afraid not. @laagesen would you know why?",
                          "url": "https://github.com/idaholab/moose/discussions/28858#discussioncomment-10973225",
                          "updatedAt": "2024-10-17T15:24:25Z",
                          "publishedAt": "2024-10-17T15:24:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "sorry I'm afraid not, maybe @SudiptaBiswas or @jiangwen84 ?",
                          "url": "https://github.com/idaholab/moose/discussions/28858#discussioncomment-10974439",
                          "updatedAt": "2024-10-17T17:16:46Z",
                          "publishedAt": "2024-10-17T17:16:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Lingfu-Liu"
                          },
                          "bodyText": "I recently discovered that I resolved this issue by adding a history variable to prevent crack rehealing.\nThe updated scripts are provided below, with changes highlighted in bold font.\n\n[Mesh]\ntype = GeneratedMesh\ndim = 1\nnx = 50\nxmin = 0.0\nxmax = 1.0\n[]\n[GlobalParams]\ndisplacements = 'disp'\n[]\n[Variables]\n[./disp]\norder = FIRST\nfamily = LAGRANGE\n[../]\n[./d]\norder = FIRST\nfamily = LAGRANGE\n[../]\n[]\n\n[AuxVariables]\n[./bounds_dummy]\norder = FIRST\nfamily = LAGRANGE\n[../]\n[]\n\n[Physics/SolidMechanics/QuasiStatic]\n[./mech]\nstrain = SMALL\nadd_variables = true\ngenerate_output = stress_xx\nmaterial_output_family = LAGRANGE\nmaterial_output_order = FIRST\n[../]\n[]\n[Modules/PhaseField/Nonconserved]\n[./d]\nfree_energy = F\nkappa = kappa_op\nmobility = L\n[../]\n[]\n[Kernels]\n[./couple]\ntype = PhaseFieldFractureMechanicsOffDiag\nvariable = disp\ncomponent = 0\nc = d\n[../]\n[]\n[BCs]\n[./left_fixed]\ntype = DirichletBC\nboundary = left\nvariable = disp\nvalue = 0.0\n[../]\n[./xdisp]\ntype = FunctionDirichletBC\nvariable = disp\nboundary = right\nfunction = 't'\n[../]\n[]\n[Materials]\n[./elasticity_tensor]\ntype = ComputeIsotropicElasticityTensor\nyoungs_modulus = 100e9  # Pa\npoissons_ratio = 0\n[../]\n[./pfbulkmat]\ntype = GenericConstantMaterial\n# gc_prop: Critical energy release rate (Energy required to create fractures per unit area)\n# l: internal length scale (diffusion leng;pth paramter)\n# visco: damping coefficient of phase field\n# c0: paramter in crack geometrical function (a(d)=d^2 ==> c0 =2)\nprop_names = 'gc_prop l visco c0'\nprop_values = '1 0.1 1e-4 2'\n[../]\n[./define_mobility]\ntype = ParsedMaterial\nproperty_name = L\nmaterial_property_names = 'visco'\nexpression = '1.0/visco'\n[../]\n[./define_kappa]\ntype = ParsedMaterial\nproperty_name = kappa_op\nmaterial_property_names = 'gc_prop l c0'\nexpression = '2 * gc_prop * l / c0'\n[../]\n[./elastic]\ntype = ComputeLinearElasticPFFractureStress\nc = d\nE_name = 'elastic_energy'\nD_name = 'degradation'\nF_name = 'local_fracture_energy'\ndecomposition_type = strain_spectral\n\nuse_current_history_variable = true\n\n[../]\n[./degradation]\ntype = DerivativeParsedMaterial\nproperty_name = degradation\ncoupled_variables = 'd'\nexpression = (1-d)^p*(1-delta)+delta\nconstant_names       = 'p delta'\nconstant_expressions = '2 1e-6'\nderivative_order = 2\n[../]\n[./local_fracture_energy]\ntype = DerivativeParsedMaterial\nproperty_name = local_fracture_energy\ncoupled_variables = d\nmaterial_property_names = 'gc_prop c0 l'\nexpression = 'gc_prop * d^2 / c0 / l'\nderivative_order = 2\n[../]\n[./fracture_driving_energy]\ntype = DerivativeSumMaterial\nproperty_name = F\ncoupled_variables = d\nsum_materials = 'elastic_energy local_fracture_energy'\nderivative_order = 2\n[../]\n[]\n[Executioner]\ntype = Transient\ndt = 1e-6\n\npetsc_options_iname = '-pc_type  -snes_type'\npetsc_options_value = 'lu vinewtonrsls'\n\nsolve_type = NEWTON\nnum_steps = 10\n#end_time = 5e-5\n[]\n[Outputs]\nexodus = true\n[./csv]\ntype = CSV\n[../]\n[]\n[Postprocessors]\n[u(end)]\ntype = PointValue\npoint = '1 0 0'\nvariable = disp\n[]\n[d_ave]\ntype = ElementAverageValue\nvariable = 'd'\n[]\n[sigma_xx_ave]\ntype = ElementAverageValue\nvariable = 'stress_xx'\n[]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28858#discussioncomment-11156930",
                          "updatedAt": "2024-11-05T16:19:33Z",
                          "publishedAt": "2024-11-05T16:13:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Thanks for letting us know!",
                          "url": "https://github.com/idaholab/moose/discussions/28858#discussioncomment-11169331",
                          "updatedAt": "2024-11-06T17:36:19Z",
                          "publishedAt": "2024-11-06T17:36:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to speed up polycrystal crystal plasticity simualtion in 3D",
          "author": {
            "login": "RWTHLHK"
          },
          "bodyText": "Hello experts. I'd like to perform crystal plasticity simulation in 3D, but I find the polycrystal simulation is quite slow. Is there any suggestion to speed up the process.",
          "url": "https://github.com/idaholab/moose/discussions/29014",
          "updatedAt": "2024-11-06T15:08:57Z",
          "publishedAt": "2024-11-05T23:09:36Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDo you have an example simulation? You could profile it and see where the slow path is\nhttps://mooseframework.inl.gov/moose/application_development/profiling.html\n@dewenyushu  @jiangwen84 do you have advice on this? Were there any future works performance-wise that could be addressed?",
                  "url": "https://github.com/idaholab/moose/discussions/29014#discussioncomment-11160340",
                  "updatedAt": "2024-11-05T23:15:24Z",
                  "publishedAt": "2024-11-05T23:15:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "Thanks! I just find the reason is maybe my RVE is kind of too big and contains too many grains.  And I can simply reduce the size of my RVE to a smaller size. My final goal is cross-scale simulation of fracture mechanics, MOOSE is really a convenient tool to achieve this.",
                          "url": "https://github.com/idaholab/moose/discussions/29014#discussioncomment-11167314",
                          "updatedAt": "2024-11-06T14:18:00Z",
                          "publishedAt": "2024-11-06T14:17:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "I just found it is also possible to wrap external non-MOOSE codes; this can significantly accelerate my progress. But the relevant tutorial is still not in detail, are there any further instructions?",
                          "url": "https://github.com/idaholab/moose/discussions/29014#discussioncomment-11167343",
                          "updatedAt": "2024-11-06T14:20:38Z",
                          "publishedAt": "2024-11-06T14:20:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "there are examples. Cardinal is the biggest one\nhttps://github.com/neams-th-coe/cardinal",
                          "url": "https://github.com/idaholab/moose/discussions/29014#discussioncomment-11167449",
                          "updatedAt": "2024-11-06T14:29:58Z",
                          "publishedAt": "2024-11-06T14:29:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "OK, thanks. I will learn how Cardinal works.  I want to implement my phase field model coupled with crystal plasticity.  I have used MATLAB's symbolic operations to derive the weak form and Jacobian matrix.  However, the interfacial term of my phase field model is too complex,  it is quite challenging and timeconsuming to code weak form and Jacobian in MOOSE by hand.  Can I externally compute the residual and Jacobian and then pass values to MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/29014#discussioncomment-11167686",
                          "updatedAt": "2024-11-06T14:53:44Z",
                          "publishedAt": "2024-11-06T14:53:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No that's likely going to be too inefficient.\nI would recommend using AD if you think the Jacobian takes too long to implement",
                          "url": "https://github.com/idaholab/moose/discussions/29014#discussioncomment-11167845",
                          "updatedAt": "2024-11-06T15:08:57Z",
                          "publishedAt": "2024-11-06T15:08:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to store the historical maximum principal stress?",
          "author": {
            "login": "PEI0214"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello\uff0c\nI want to create a material model. The elastic tensor of the model is related to the historical maximum compressive stress of the large principal stress. I write a header file and a source file. Is that appropriate? Can the maximum compressive stress be stored?\nComputeElasticityTensor.h.pdf\nComputeElasticityTensor.C.pdf",
          "url": "https://github.com/idaholab/moose/discussions/29018",
          "updatedAt": "2024-11-06T14:37:23Z",
          "publishedAt": "2024-11-06T13:20:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis will keep the local maximum. Do you need this or the global maximum?\nMy only concern here is that Cijkl is set with the old property so it's effectively lagged by a time step. Did you intend to do that?",
                  "url": "https://github.com/idaholab/moose/discussions/29018#discussioncomment-11166746",
                  "updatedAt": "2024-11-06T13:24:34Z",
                  "publishedAt": "2024-11-06T13:24:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "This will keep the local maximum. Do you need this or the global maximum?\n\nWhat I need is the maximum value that occurred before the current calculation step. Can the above be done?\n\nMy only concern here is that Cijkl is set with the old property so it's effectively lagged by a time step.  Did you intend to do that?\n\nIt needs to lag by one time step. The stress is calculated based on strain and Cijkl. When calculating Cijkl, the stress of this time step is not yet obtained, is it not?",
                          "url": "https://github.com/idaholab/moose/discussions/29018#discussioncomment-11167132",
                          "updatedAt": "2024-11-06T14:01:56Z",
                          "publishedAt": "2024-11-06T14:01:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What I need is the maximum value that occurred before the current calculation step. Can the above be done?\n\nso the global spatial maximum? Or the local timestep maximum?",
                          "url": "https://github.com/idaholab/moose/discussions/29018#discussioncomment-11167189",
                          "updatedAt": "2024-11-06T14:08:20Z",
                          "publishedAt": "2024-11-06T14:08:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "The maximum value of a local time step. Just before the current time step.",
                          "url": "https://github.com/idaholab/moose/discussions/29018#discussioncomment-11167264",
                          "updatedAt": "2024-11-06T14:14:04Z",
                          "publishedAt": "2024-11-06T14:14:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "local is spatial.\nis this the maximum over the entire (spatial) domain, or the local maximum at the quadrature point over the history of the system",
                          "url": "https://github.com/idaholab/moose/discussions/29018#discussioncomment-11167328",
                          "updatedAt": "2024-11-06T14:19:22Z",
                          "publishedAt": "2024-11-06T14:19:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "The maximum value at each quadrature point.",
                          "url": "https://github.com/idaholab/moose/discussions/29018#discussioncomment-11167446",
                          "updatedAt": "2024-11-06T14:29:38Z",
                          "publishedAt": "2024-11-06T14:29:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok then what you have seems good to me",
                          "url": "https://github.com/idaholab/moose/discussions/29018#discussioncomment-11167451",
                          "updatedAt": "2024-11-06T14:30:13Z",
                          "publishedAt": "2024-11-06T14:30:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "Well, thank you for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/29018#discussioncomment-11167522",
                          "updatedAt": "2024-11-06T14:37:23Z",
                          "publishedAt": "2024-11-06T14:37:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "CoupledVarThresholdElementSubdomainModifier - moving boundary error",
          "author": {
            "login": "czadeh"
          },
          "bodyText": "Hi,\nI made sure MOOSE and conda were fully updated before testing and posting this and I could not find this issue posted elsewhere.\nI am using CoupledVarThresholdElementSubdomainModifier in my input file to modify my active domain. I start with a thin layer and add more layers in the Z direction. The function used to modify the boundary is called 'layerZ' and its value is displayed in exodus.\nInput file is here:\n[Problem]\n  solve = false\n  kernel_coverage_check = false\n[]\n[Mesh]\n    construct_side_list_from_node_list = true\n    [gen]\n      type = GeneratedMeshGenerator\n      dim = 3\n      nx = 20\n      ny = 20\n      nz = 20\n      xmax = 2\n      ymax = 1\n      zmax = 1\n    []\n    [powder_domain] #the initial domain, the first layer\n      type = SubdomainBoundingBoxGenerator\n      input = 'gen'\n      block_id = 1\n      bottom_left = '0 0 0'\n      top_right = '2 1 0.1'\n    []\n    [gas_domain] #the initially inactive domain\n      type = SubdomainBoundingBoxGenerator\n      input = 'powder_domain'\n      block_id = 2\n      bottom_left = '0 0 0.1'\n      top_right = '2 1 1'\n    []\n[]\n[Variables]\n  [u]\n    initial_condition = 1\n    family = LAGRANGE\n    block = '1 2'\n  []\n[]\n[Kernels]\n  [dummy]\n    type = NullKernel\n    variable = u\n  []\n[]\n[UserObjects]\n  [addLayer] #subdomain modifier\n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = 'layerZ' #the z height of the active layers\n    criterion_type = BELOW\n    threshold = 0\n    subdomain_id = 1\n    # complement_subdomain_id = 2\n    moving_boundary_name = topLayer #the top boundary of the top layer\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n[]\n[Functions]\n  [LayerZFunc] #function to define layerZ\n    type = ParsedFunction\n    value = 'z-0.1*floor(t)-0.1'\n    # value = 'int(10*(z-0.1*floor(t)-0.1))/10'\n  []\n[]\n[AuxVariables]\n  [layerZ]\n    [InitialCondition]\n      type = ConstantIC\n      value = 0.1\n      variable = layerZ\n    []\n  []\n[]\n[AuxKernels]\n  [layerZ]\n    type = FunctionAux\n    variable = layerZ\n    function = LayerZFunc\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n[]\n[Executioner]\n  type = Transient\n  solve_type = JFNK\n  num_steps = 5\n  dt = 1\n[]\n[Outputs]\n  exodus = true\n[]\n\nThe bulk of the domain seems to behave correctly, but some unusual behavior appears on the boundary.\ntime = 2\n\nAccording to the legend it seems like a rounding error. Not a big deal, but the moving boundary labeled 'topLayer' shows some inconsistent behavior.\ntime = 2\n\nAt first it matches block 1 almost exactly.\nBut at some point it diverges from block 1 and somehow the moving boundary is comprised of separate z-planes.\ntime = 4\n\ntime = 4\n\nI need to use the moving boundary as part of my problem but I do not think it will work like this. I am struggling to figure out why this error occurs.\nI appreciate your help in figuring this out.\nThanks,\nCameron",
          "url": "https://github.com/idaholab/moose/discussions/19047",
          "updatedAt": "2024-11-06T14:31:21Z",
          "publishedAt": "2021-10-08T19:53:34Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSince you have already identified the issue as being a rounding error, just change the value field in LayerZfunc to be offset by some small epsilon like 1e-8 and it will resolve this.\nRounding errors can be inconsistent between different computations at different timesteps, there s very little that can done apart from using small offsets\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1456827",
                  "updatedAt": "2022-07-04T08:32:43Z",
                  "publishedAt": "2021-10-11T03:39:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "czadeh"
                  },
                  "bodyText": "Hi Guillaume,\nI tried adding an epsilon starting with e-8 up to e-2. I tried it both within the argument of the floor function and outside of it, but the error persists the same way.\nWould changing the value of\nexecute_on\nin UserObjects or AuxKernels affect this?",
                  "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1460172",
                  "updatedAt": "2022-07-04T08:32:43Z",
                  "publishedAt": "2021-10-11T16:45:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It can affect this if there is an issue with dependency resolution. There should not be.\nyou can try to shift the order of execution of the User object if you want using:\nforce_preaux = true\nor\nforce_postaux = true\nin the user object parameter\nBy default, user objects are executed after aux kernels, so what you did should work since the layer criterion is being computed by an aux kernel.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1461345",
                          "updatedAt": "2022-07-04T08:33:01Z",
                          "publishedAt": "2021-10-11T21:40:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I can test to see if I can reproduce this. I've already recorded several bugs, if this is also a bug in element subdomain modifier, I'll also add this to my to-do list. But right now I don't have a clear idea of when I can get to them.",
                  "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1461627",
                  "updatedAt": "2022-07-04T08:33:07Z",
                  "publishedAt": "2021-10-11T23:53:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Pinging @dewenyushu here because she might have some resources to work on this. I'm not sure.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1461633",
                          "updatedAt": "2022-07-04T08:33:07Z",
                          "publishedAt": "2021-10-11T23:55:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Yes, we can potentially use part of a ldrd project to fix the issues associated with the subdomain modifier, if you may have the availability.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1465346",
                          "updatedAt": "2022-07-04T08:33:03Z",
                          "publishedAt": "2021-10-12T14:47:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "czadeh"
                  },
                  "bodyText": "I tried to circumvent this issue by using SideSetsAroundSubdomainGenerator when defining my mesh and blocks initially. I used it to define the boundaries around block 1. But now the problem is that\n\n\nThe top boundary between blocks 1 and 2 works correctly until the subdomain is modified by CoupledVarThresholdElementSubdomainModifier. At that point, the boundary between the subdomains disappears.\n\n\nThe sides of block 1 (everything except z = 0 and the boundary between blocks 1 and 2) stay at their initially defined geometry and do not update with increasing z.\n\n\nIs there a way to make the mesh generator update the sidesets when CoupledVarThresholdElementSubdomainModifier makes a change?\nThanks,\nCameron",
                  "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1523682",
                  "updatedAt": "2022-07-04T08:33:03Z",
                  "publishedAt": "2021-10-22T22:37:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nNo we currently cant run mesh generators inside a simulation. We ll be able to do that soon, when we can compose the order of execution of executioners. We ll add a MeshGenerator executioner that will be allowed to run then.\nAnother solution is to leverage the adaptivity system to rename sidesets. This is the current cannon way to do this, but no one has implemented it afaik.\nEither that or you can add a user object to run those mesh generators on any execute_on.\nBut for 1.) the CoupledVarThresholdElementSubdomainModifier should be handling the moving interface and updating it as it progresses.\nFor 2. can you share the sideset between block 1 and 2? Then they should still be valid & have the same name as the domains move. Is this for a boundary condition? Are the variables the same in both domains? The latter could be an issue.\nYou could pause the simulation every step and recover, and run the generators then. It s not very efficient though\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1534974",
                          "updatedAt": "2022-07-04T08:33:05Z",
                          "publishedAt": "2021-10-25T21:10:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "also for 2. could you specify those boundaries as moving boundaries of the  CoupledVarThresholdElementSubdomainModifier  ? Hopefully that does the trick",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1534977",
                          "updatedAt": "2022-07-04T08:33:07Z",
                          "publishedAt": "2021-10-25T21:11:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "Hi Guillaume, sorry for the delay in responding.\nI am glad to hear that this feature will be added soon. Are you all working on a set of tools for additive manufacturing modeling?\n\nAnother solution is to leverage the adaptivity system to rename sidesets.\n\nI do not understand how you could use adaptivity, doesn't it just refine or coarsen the mesh? How can you use it rename sidesets?\n\nEither that or you can add a user object to run those mesh generators on any execute_on.\n\nDo you mean something like ActivateElementsByPath or ActivateElementsCoupled?\n\nBut for 1.) the CoupledVarThresholdElementSubdomainModifier should be handling the moving interface and updating it as it progresses.\n\nMy top sideset (shown below) stopped working once CoupledVarThresholdElementSubdomainModifier took effect. So I need to use  moving_boundary_name after the change to the boundary.\n  [sideset_top]\n    input = gas_domain\n    type = SideSetsAroundSubdomainGenerator\n    normal = '0 0 1'\n    block = 1\n    new_boundary = 'active_layer_top'\n  []\n\n\nFor 2. can you share the sideset between block 1 and 2? Then they should still be valid & have the same name as the domains move. Is this for a boundary condition? Are the variables the same in both domains? The latter could be an issue.\n\nI defined it for block 1. I have been trying to only define nonlinear variables in the powder/liquid/solid region, not gas. Yes, I am using this to set the upper boundary condition of the active domain.\n\nYou could pause the simulation every step and recover, and run the generators then\n\nThanks, I will try that.\n\nalso for 2. could you specify those boundaries as moving boundaries of the CoupledVarThresholdElementSubdomainModifier ?\n\nI thought I could only specify a single moving boundary in CoupledVarThresholdElementSubdomainModifier. When I specified it, it only did the top region.\nCameron",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1573232",
                          "updatedAt": "2022-07-04T08:33:07Z",
                          "publishedAt": "2021-11-02T00:04:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nWe pretty much always have people working on that yes, very promising research / engineering field. @friedmud anyone I can tag on additive manufacturing?\n\n\nYou're right that adaptivity currently only does refinement and coarsening. However, \"adapting\" the mesh by changing the sidesets feels like it belongs in adaptivity. Any kind of mesh operation that reacts to simulation variables is \"adaptivity\" to me, but maybe I am abusing the term.\n\n\nI don't think ActivateElementXXX does quite what you want. I think a new UO would need to be created to do what you want. Ideally we can figure out a way to make it run a mesh generator. If not, then you would just have to paste the code in a mesh generator in the UO. It will work there too.\n\n\nFor recovering and running mesh generators, please note that this is disabled by default. You ll have to go in the code and remove the disabling.\n\n\nOk for having a single moving boundary. It was just an idea. Can you use more than one CoupledVarThresholdElementSubdomainModifier with different moving boundaries though??\n\n\nI'm afraid most solutions I am proposing involve coding a new object (1 & 2) or modifying some MOOSE internal code (3, which is kind of hacky, probably gonna get a dislike for this). I can't see how to leverage an existing system to move the multiple sidesets, unless 4 works out of the box.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1574096",
                          "updatedAt": "2022-07-04T08:33:15Z",
                          "publishedAt": "2021-11-02T06:30:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "There are many who are more plugged into what's going on in advanced manufacturing than me... @laagesen @sapitts may have some thoughts.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1577012",
                          "updatedAt": "2022-07-04T08:33:20Z",
                          "publishedAt": "2021-11-02T15:41:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@czadeh  I can partially answer your question on the additive manufacturing development. Currently we can do thermal-mechanical modeling at component level using element activation algorithm and meso-scale melt pool dynamics modeling with level set and ALE methods. The component modeling is available in the MOOSE and melt-pool dynamics is inside our new MOOSE-based application called MALAMUTE.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1577193",
                          "updatedAt": "2022-07-04T08:33:20Z",
                          "publishedAt": "2021-11-02T16:10:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@czadeh  I just ran your input file. It seems that the top layer boundary is shown correctly at every step. Did I miss any thing?\nBTW, I visualized them in Paraview BTW. Maybe there were some issues with the reading the boundary as mesh changes in Peacock.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1577250",
                          "updatedAt": "2022-07-04T08:33:17Z",
                          "publishedAt": "2021-11-02T16:22:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "We're also working to add some advanced manufacturing modeling capabilities to the MALAMUTE app, in addition to the additive manufacturing capabilities @jiangwen84 described. @cticenhour and @lindsayad  are leading that effort, along with the other folks participating in this discussion. We are pretty excited to have one MOOSE app for these types of multiphysics problems!",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1577258",
                          "updatedAt": "2022-07-04T08:33:21Z",
                          "publishedAt": "2021-11-02T16:23:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "That's exciting, will MALAMUTE be released to the public? Is there a place where I can learn more about it?",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1578182",
                          "updatedAt": "2022-07-04T08:33:20Z",
                          "publishedAt": "2021-11-02T18:58:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "@jiangwen84 interesting, was that with block 1 visible? My image with the error was with only the moving boundary visible, no other domains.\nIf it is just an error in Peacock that's good to know.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1578212",
                          "updatedAt": "2022-07-04T08:33:22Z",
                          "publishedAt": "2021-11-02T19:03:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "get drho_dT from Water97FluidProperties",
          "author": {
            "login": "SunJianhang678"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear MOOSE experts,\nI'm using the Water97FluidProperties and trying to get drho_dT as a property of my material so that it could be consumed by other kernels. But I don't know how to achieve it. I want to get drho_dT in a way like how i get rho, by declaring _rho in .h file and getting it in .C file, but it seems that Water97Fluidproperties does not have a member named 'drho_dT_from_p_T' corresponding to 'rho_from_p_T'. Part of my current code is as below.\nCould you please offer some guidance? It will be great help if there are some examples using drho_dT this way. Thank you so much!\n.h file\nprivate:\nMaterialProperty & _rho;\nMaterialProperty & _drho_dT;\nMaterialProperty & _drho_dp;\nconst Water97FluidProperties & _fluid;\n.C file\nWater97::Water97(const InputParameters & parameters)\n: Material(parameters),\n_rho(declareProperty(\"rho\")),\n_drho_dT(declareProperty(\"drho_dT\")),\n_drho_dp(declareProperty(\"drho_dp\")),\n_fluid(getUserObject(\"fp\"))\n{\n}\nvoid\nWater97::computeQpProperties()\n{\n_rho[_qp] = _fluid.rho_from_p_T(_p[_qp], _T[_qp]);\n_drho_dT[_qp] = _fluid.drho_dT_from_p_T(_p[_qp], _T[_qp]);\n_drho_dp[_qp] = _fluid.drho_dp_from_p_T(_p[_qp], _T[_qp]);\n}",
          "url": "https://github.com/idaholab/moose/discussions/29016",
          "updatedAt": "2024-11-06T14:18:17Z",
          "publishedAt": "2024-11-06T09:53:56Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SunJianhang678"
                  },
                  "bodyText": "I solved this problem by replacing the last two lines showed above with the following codes:\ndouble delta = 1e-1;\ndouble rho_dT = _fluid.rho_from_p_T(_p[_qp], _T[_qp] + delta);\ndouble rho_dp = _fluid.rho_from_p_T(_p[_qp] + delta, _T[_qp]);\n_drho_dT[_qp] = (rho_dT - _rho[_qp]) / delta;\n_drho_dp[_qp] = (rho_dp - _rho[_qp]) / delta;\nbut I'm wondering if there were more convenient ways provided by moose, instead of calculating the values by myself?",
                  "url": "https://github.com/idaholab/moose/discussions/29016#discussioncomment-11165152",
                  "updatedAt": "2024-11-06T10:35:18Z",
                  "publishedAt": "2024-11-06T10:35:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is fine but the convenient way is to do this:\nFinite differencing will be a slightly more imprecise than using the routines that compute those derivatives\nReal rho, drho_dT, drho_dp;\n_fluid.rho_from_p_T(_p[_qp], _T[_qp], rho, drho_dT, drho_dp);",
                          "url": "https://github.com/idaholab/moose/discussions/29016#discussioncomment-11166705",
                          "updatedAt": "2024-11-06T13:21:32Z",
                          "publishedAt": "2024-11-06T13:19:30Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SunJianhang678"
                          },
                          "bodyText": "Got it! When I read the source code of Water97FP, I didn't know why more params than needed appear in this function and what they are for, now I understand. Thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/29016#discussioncomment-11167230",
                          "updatedAt": "2024-11-06T14:11:59Z",
                          "publishedAt": "2024-11-06T14:11:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "p, T are inputs\nrho, drho_dT, drho_dp are references to a number. So while they are passed as arguments, they are actually outputs of this routine\nso this routine officially returns \"void\" but in practice it computes rho, drho_dT, drho_dp in the (reference to) numbers you pass as parameters",
                          "url": "https://github.com/idaholab/moose/discussions/29016#discussioncomment-11167315",
                          "updatedAt": "2024-11-06T14:18:18Z",
                          "publishedAt": "2024-11-06T14:18:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "SegFault using LinearNodalConstraint with Distributed Mesh",
          "author": {
            "login": "TheBEllis"
          },
          "bodyText": "Hi MOOSE team,\nI've been trying to use LinearNodalConstraint to replicate an RBE3-esque constraint on a problem that will need a distributed mesh, and I am running into a SegFault. I have put together a small reproducible example. I have uploaded the mesh here https://drive.google.com/file/d/1ZlKYpy96iZ3vGojwCULTtBbGSVbFBUxG/view?usp=sharing.\n\nThe independent (primary) nodes in this situation are all the nodes on the cylindrical extrude face, and the dependent (secondary) node is located at 0,0,0 at the centre of the mesh. All the weightings are equal. I have pre-split the mesh into 2 parts. Using a debug executable I immediately get this error, which points to libmesh_assert_valid_neighbors.\n\nUsing an opt executable and running a debugger for each MPI process, the backtrace looks like this,\n\nAlso I am running b9eefd8, so aaedfb9 is included.\nAny help is much appreciated:) The problem converges fine without --use-split, but as soon as the distributed mesh is used the segfault appears.\nEdit: After a bit of digging it seems the problem is the elemPtr() call at line 459 of SystemBase.C, in augmentSendList(). Should this be a queryElemPtr()?\npenalty = 1e13\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh]\n  type = FileMesh\n  file = '../mesh/rbetest_no_elems.e'\n[] \n  \n[Variables]\n  [temperature]\n    initial_condition = 0 # Start at room temperature\n  []\n[]\n  \n[Kernels]\n  # Heat conduction kernels\n  [heat_conduction]\n    type = ADHeatConduction\n    variable = temperature\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    use_automatic_differentiation = true\n    volumetric_locking_correction = true\n    strain = SMALL\n    add_variables = true\n    incremental = false\n    generate_output = 'strain_xx strain_yy strain_zz vonmises_stress'\n    eigenstrain_names = eigenstrain\n  []\n[]\n  \n[Materials]\n  [CCZ_elasticity]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 100000\n    poissons_ratio = 0.33\n  []\n  [CCZ_heat]\n    type = ADHeatConductionMaterial\n    temp = temperature\n    thermal_conductivity = 400.0\n    specific_heat = 330.0\n  []\n\n  [CCZ_thermal_expansion]\n    type = ADComputeThermalExpansionEigenstrain\n    stress_free_temperature = 10\n    thermal_expansion_coeff = 5e-04\n    temperature = temperature\n    eigenstrain_name = eigenstrain\n    block = 1\n  []\n\n  [rbe_thermal_expansion]\n    type = ADComputeThermalExpansionEigenstrain\n    stress_free_temperature = 0\n    thermal_expansion_coeff = 0\n    temperature = temperature\n    eigenstrain_name = eigenstrain\n    block = 2\n  []\n\n  [stress]\n    type = ADComputeLinearElasticStress\n  []\n[]\n\n[Constraints]\n    [rbe3_x]\n        type = LinearNodalConstraint\n        primary = '7 1 149 8 190 191 192 193 13 194 195 196 197 198 199 200 14 15 16 17 18 19 20 21 22 23 2 64 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922'\n        secondary_node_set = 'secondary'\n        variable = disp_x\n        penalty = ${penalty}\n        weights = '0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005'\n    []\n\n    [rbe3_y]\n        type = LinearNodalConstraint\n        primary = '7 1 149 8 190 191 192 193 13 194 195 196 197 198 199 200 14 15 16 17 18 19 20 21 22 23 2 64 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922'\n        secondary_node_set = 'secondary'\n        variable = disp_y\n        penalty = ${penalty}\n        weights = '0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005'\n    []\n\n    [rbe3_z]\n        type = LinearNodalConstraint\n        primary = '7 1 149 8 190 191 192 193 13 194 195 196 197 198 199 200 14 15 16 17 18 19 20 21 22 23 2 64 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922'\n        secondary_node_set = 'secondary'\n        variable = disp_z\n        penalty = ${penalty}\n        weights = '0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005'\n    []\n[]\n\n[BCs]\n  [temp_high]\n    type = ADDirichletBC\n    variable = temperature\n    boundary = 'hot'\n    value = 100\n  []\n  [temp_low]\n    type = ADDirichletBC\n    variable = temperature\n    boundary = 'cold'\n    value = 0\n  []\n[]\n\n[Postprocessors]\n  [average_x]\n    type = AverageNodalVariableValue\n    variable = disp_x\n    boundary = 'primary'\n  []\n  [average_y]\n    type = AverageNodalVariableValue\n    variable = disp_y\n    boundary = 'primary'\n  []\n  [average_z]\n    type = AverageNodalVariableValue\n    variable = disp_z\n    boundary = 'primary'\n  []\n[]\n  \n#[Preconditioning]\n#  [./SMP]\n#    #Creates the entire Jacobian, for the Newton solve\n#    type = SMP\n#    full = true\n#  [../]\n#[]\n  \n[Executioner]\n  type = Steady\n  automatic_scaling = true\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre    boomeramg'\n  nl_rel_tol = 1e-20\n  nl_abs_tol = 1e-5\n  l_tol = 1e-8\n  l_abs_tol = 1e-10\n  line_search = none\n[]\n\n[Outputs]\n  exodus = true\n  perf_graph = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/29005",
          "updatedAt": "2024-11-06T09:48:10Z",
          "publishedAt": "2024-11-05T11:52:22Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nCan you try this instead:\n\ngenerate the split with --split-mesh as usual\nload the split mesh using a FileMeshGenerator (FileMesh -- like you have now -- can work too probably)\ndo not use --use-split\n\nuse-split follows a different code path that does not do a good job at keeping track of neighbors iirc\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/29005#discussioncomment-11160246",
                  "updatedAt": "2024-11-06T13:24:58Z",
                  "publishedAt": "2024-11-05T22:56:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheBEllis"
                          },
                          "bodyText": "Hi Guillaume,\nThis worked, thank you lots! I should have paid more attention to this.\n\nNote for anyone else who is trying to do this, the only other thing I needed to get it working was to set skip_partitioning to true in FileMeshGenerator, as my mesh was pre-split and it is set to False by default (and use the --distributed-mesh command line argument when running).\nAgain, many thanks,\nBill",
                          "url": "https://github.com/idaholab/moose/discussions/29005#discussioncomment-11164702",
                          "updatedAt": "2024-11-06T09:51:50Z",
                          "publishedAt": "2024-11-06T09:48:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Principal stress is used in a material model",
          "author": {
            "login": "PEI0214"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello\uff0c\nI want to add a material model. The elastic modulus of this model is related to the principal stress. When I use meshmodifiers to simulate construction, the process is shown below.\n\nWhen the type of principal stress is nodal variable, the inactive part also has principal stress. When the principal stress type is elemental variable, the principal stress value of the inactive part is 0, as shown in the figure below.\n\nHowever, the solving type of the principal stress in moose is node type, which will affect my solving of the elastic modulus value. Is there a way to use element type principal stress in a material model?\nminPrincipal in MOOSE:\ntemplate <typename T>\nT\nminPrincipal(const RankTwoTensorTempl<T> & r2tensor, Point & direction)\n{\n  return calcEigenValuesEigenVectors(r2tensor, 0, direction);\n}",
          "url": "https://github.com/idaholab/moose/discussions/28994",
          "updatedAt": "2024-11-05T21:38:58Z",
          "publishedAt": "2024-11-03T15:46:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe have not implemented any default behavior for material properties on newly activated subdomains.\nAll the work has focused on variables so far. If you want a particular behavior you will need to implement it\nFor the figure you show, that's a visualization artefact. That's just how paraview plot nodal variables, as continuous variables by default\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28994#discussioncomment-11135171",
                  "updatedAt": "2024-11-03T16:03:56Z",
                  "publishedAt": "2024-11-03T16:03:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "I don't understand what you are wanting to implement but stress is a material property defined at the gauss points, not the nodes.\nYou can compute a \"nodal stress\" as a post processing step from the stress material property but that \"nodal stress\" isn't the stress used in a constitutive model.  ComputeSmearedCrackingStress is a material that uses principal strains to modify material properties.  Maybe you can do something similar.",
                          "url": "https://github.com/idaholab/moose/discussions/28994#discussioncomment-11159768",
                          "updatedAt": "2024-11-05T21:38:59Z",
                          "publishedAt": "2024-11-05T21:38:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}