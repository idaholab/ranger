{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wNi0xMFQwMDoxODo1MC0wNjowMM4AZ51V"
    },
    "edges": [
      {
        "node": {
          "title": "Missing registered objects",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "I just reinstalled my MOOSE it passed the test just as my application.\nI went to the KKS modules to try out some of the input scripts but I got these errors in the respective input scripts:\nkks_example.i:\nA 'SmoothCircleIC' is not a registered object.check_inp(moose_srv)\nIf you are trying to find this object in a dynamically loaded library, make sure thatcheck_inp(moose_srv)\nthe library can be found either in your \"Problem/library_path\" parameter or in thecheck_inp(moose_srv)\nMOOSE_LIBRARY_PATH environment variable.\n\nnonlinear.i:\nA 'SwitchingFunctionMaterial' is not a registered object.check_inp(moose_srv)\nIf you are trying to find this object in a dynamically loaded library, make sure thatcheck_inp(moose_srv)\nthe library can be found either in your \"Problem/library_path\" parameter or in thecheck_inp(moose_srv)\nMOOSE_LIBRARY_PATH environment variable.",
          "url": "https://github.com/idaholab/moose/discussions/27876",
          "updatedAt": "2024-06-13T04:48:35Z",
          "publishedAt": "2024-06-12T00:40:03Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Emmanuel-324"
                  },
                  "bodyText": "I have fixed it. Thanks",
                  "url": "https://github.com/idaholab/moose/discussions/27876#discussioncomment-9744965",
                  "updatedAt": "2024-06-12T00:54:48Z",
                  "publishedAt": "2024-06-12T00:54:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "I thought recompiling my application after setting all the modules to yes would work, but it did not.",
                          "url": "https://github.com/idaholab/moose/discussions/27876#discussioncomment-9745067",
                          "updatedAt": "2024-06-12T01:14:32Z",
                          "publishedAt": "2024-06-12T01:14:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no you definitely have to \"git clean\" before recompiling. Sorry for the trouble",
                          "url": "https://github.com/idaholab/moose/discussions/27876#discussioncomment-9751270",
                          "updatedAt": "2024-06-12T12:38:06Z",
                          "publishedAt": "2024-06-12T12:38:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "git clean -Xfd",
                          "url": "https://github.com/idaholab/moose/discussions/27876#discussioncomment-9755743",
                          "updatedAt": "2024-06-12T19:24:16Z",
                          "publishedAt": "2024-06-12T19:24:15Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "Yeah thanks I figured it.",
                          "url": "https://github.com/idaholab/moose/discussions/27876#discussioncomment-9755753",
                          "updatedAt": "2024-06-12T19:25:36Z",
                          "publishedAt": "2024-06-12T19:25:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Rotating objects with adhesive or lubricating contact in between",
          "author": {
            "login": "malih1186"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI have a fluid mechanics background and I am new to MOOSE, I have seen the tutorials and searched the application website but I am still unsure if the problem I have can be simulated with MOOSE.\nI have a stationary and a rotating object (rotating at high RPM) with a very small gap in between. I have searched for FE analysis in Moose but I am unsure about the contact and how to set it up when one object is rotating (to prevent clash) and the mesh is deforming.\nI appreciate if you can let me know in case this type of simulation is possible in MOOSE and give me some directions.\n/Mali",
          "url": "https://github.com/idaholab/moose/discussions/27717",
          "updatedAt": "2024-06-12T16:54:49Z",
          "publishedAt": "2024-05-28T09:19:21Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I am not aware of any work in this area. @bwspenc @dschwen @jiangwen84 @recuero are you guys?",
                  "url": "https://github.com/idaholab/moose/discussions/27717#discussioncomment-9754463",
                  "updatedAt": "2024-06-12T16:54:49Z",
                  "publishedAt": "2024-06-12T16:54:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "FEM analysis of rotating objects in MOOSE",
          "author": {
            "login": "malih1186"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI have a fluid mechanics background and I am new to MOOSE, I have seen the tutorials and searched the application website but I am still unsure if the problem I have can be simulated with MOOSE.\nI have a stationary and a rotating object (rotating at high RPM) with a very small gap in between. I have searched for FE analysis in Moose but I am unsure about the contact and how to set it up when one object is rotating (to prevent clash) and the mesh is deforming.\nI appreciate if you can let me know in case this type of simulation is possible in MOOSE and give me some directions.\n/Mali\nOriginally posted by @malih1186 in #27717",
          "url": "https://github.com/idaholab/moose/discussions/27881",
          "updatedAt": "2024-06-12T16:51:55Z",
          "publishedAt": "2024-06-12T09:21:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Hmm, I transferred this over from issue, but I see there is already #27717 which appears to be identical",
                  "url": "https://github.com/idaholab/moose/discussions/27881#discussioncomment-9754430",
                  "updatedAt": "2024-06-12T16:51:46Z",
                  "publishedAt": "2024-06-12T16:51:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to draw a spiral block/boundary?",
          "author": {
            "login": "Yasunaoka"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi guys, I recently wanted to draw a spiral p=e^\u03b8\uff08(as shown by the green line on the diagram) or a series of points on that spiral over a 2D circular mesh so that I can specify the initial condition variable c=1 in the region. i have tried a few objects but didn't succeed. Does anyone know how to implement this elegantly please? Any help is much appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/27860",
          "updatedAt": "2024-06-12T07:41:31Z",
          "publishedAt": "2024-06-11T12:51:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDo you want the mesh to have a spirally shape? Or simply cover part of the domain with a spiral?\nYou are looking for 2D surface right? Or a 1D spiral curve?\nUse this generator\nhttps://mooseframework.inl.gov/source/meshgenerators/ConcentricCircleMeshGenerator.html\nThen this one to transform the circles into spirals\nhttps://mooseframework.inl.gov/source/meshgenerators/ParsedNodeTransformGenerator.html\nYou'll have to figure out the transformation in cartesian coordinates\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27860#discussioncomment-9739575",
                  "updatedAt": "2024-06-11T13:45:44Z",
                  "publishedAt": "2024-06-11T13:45:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Yasunaoka"
                          },
                          "bodyText": "Sorry, I may have missed the point, I currently do have a circular mesh AnnularMeshGenerator already:\n\nSo far, I have gotten the following linear initial condition via BoundingBoxIC\n\nBut now I'm trying to get the spiral pattern shown in the green line below, and I'm not finding the right way to do it.",
                          "url": "https://github.com/idaholab/moose/discussions/27860#discussioncomment-9740445",
                          "updatedAt": "2024-06-11T15:00:39Z",
                          "publishedAt": "2024-06-11T15:00:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you want the mesh to rigorously align with the spiral, you could rotate the mesh (not evenly, with the parsedTransform) first.\nthen use a ParsedGenerateSideset to select the spiral sideset\nIf you are OK with a jagged edge, then you could simply use the ParsedGenerateSideset to approximately draw the spiral bit within the mesh",
                          "url": "https://github.com/idaholab/moose/discussions/27860#discussioncomment-9740506",
                          "updatedAt": "2024-06-11T15:05:58Z",
                          "publishedAt": "2024-06-11T15:05:57Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Yasunaoka"
                          },
                          "bodyText": "That's exactly what I want! That's great! Thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/27860#discussioncomment-9748143",
                          "updatedAt": "2024-06-12T07:41:31Z",
                          "publishedAt": "2024-06-12T07:41:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Seeking clarification on the distinction between Points, Nodes, Vertices, and Quadrature Points in libmesh",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "I am working on calculating the center point of an element's side by averaging the coordinates of each vertex. I have been exploring the information available regarding libmesh::Elem for this purpose. However, I am currently confused about the differences among Point, Node, Vertex, and Quadrature Point.\nMy current understanding is as follows:\nA Point solely contains coordinate information.\nA Node builds upon a Point and is associated with degrees of freedom; every Node contains a Point.\nIn MOOSE, each Quadrature Point corresponds to unknown variables (i.e. degrees of freedom), suggesting it should be linked to a Node.\nThe number of Vertices is determined by the type of the element, representing physically existing points.\nThe confusion arises from the fact that both Nodes and Vertices seem to use the same indexing scheme when accessing their positions via the elem->point(n) function.\n Point Elem::vertex_average() const\n {\n   Point cp;\n \n   const auto n_vertices = this->n_vertices();\n \n   for (unsigned int n=0; n<n_vertices; n++)\n     cp.add (this->point(n));\n \n   return (cp /= static_cast<Real>(n_vertices));\n }\nstd::unique_ptr<MeshBase>\nCoarseMeshMappingForCMFD::generate()\n{\n    ......\n\n    // Check if the fine elem is nested in the coarse element\n    for (unsigned int n = 0; n < elem->n_nodes(); n++)\n    {\n      // Get the node: we need to manually move it towards the centroid to\n      // ensure that nothing weird happes due to round-off\n      Point current_node = elem->point(n);\n\n      ......\n}\n\nThis gives me the impression that Vertices and Nodes share the same index set, which seems contradictory given that their counts are different.\nFurthermore, my understanding suggests that each element has its unique set of Quadrature Points while Nodes can be shared across elements. This seemingly contradicts my earlier notion that each Quadrature Point corresponds to a single Node.\nI would greatly appreciate your help in clarifying these concepts and how they relate to finding the center point of an element's side. Thank you in advance for your attention and assistance.",
          "url": "https://github.com/idaholab/moose/discussions/26837",
          "updatedAt": "2024-06-12T01:58:51Z",
          "publishedAt": "2024-02-19T15:37:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "rnpratoori"
                  },
                  "bodyText": "You are wrong to conclude that each Quadrature point corresponds to a node. Quadrature point is usually something that is located within the element, not on the boundary/vertices of the element like nodes. Quadrature points differ based on the shape of elements and more predominantly the shape functions used. Both of these will determine how many Quadrature points are there for a particular element and also their respective locations.",
                  "url": "https://github.com/idaholab/moose/discussions/26837#discussioncomment-9741774",
                  "updatedAt": "2024-06-11T17:03:08Z",
                  "publishedAt": "2024-06-11T17:03:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you very much for your reminder.",
                          "url": "https://github.com/idaholab/moose/discussions/26837#discussioncomment-9745278",
                          "updatedAt": "2024-06-12T01:58:42Z",
                          "publishedAt": "2024-06-12T01:58:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Why a postprocessed variable displays zero?",
          "author": {
            "login": "amerallaf"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI am trying to postprocess the heat_source variable (source_integral), but it keeps showing me the value as zero. The heat_source has a greater value than zero, because whenever I change it, the maximum temperature value also changes, but I still get the source_integral as zero.\nI would appreciate your help in solving this issue.\nHere is my input:\nL = 300.0\nT_fluid = ${fparse 280.0 + 273.15}\n\n[Mesh]\n  [file]\n    type = FileMeshGenerator\n    file = mesh_in.e\n  []\n[]\n\n[Variables]\n  [temp]\n    initial_condition = ${T_fluid}\n  []\n[]\n\n[AuxVariables]\n  [./heat_source]\n\n  [../]\n[]\n\n[Kernels]\n  [hc]\n    type = HeatConduction\n    variable = temp\n  []\n  [heat_source]\n    type = HeatSource\n    value = 250 \n    variable = temp\n    block = '2 3'\n  []\n[]\n\n[Functions]\n  [T_fluid]\n    type = ParsedFunction\n    expression = '573.0 + 50.0 * (z / 300.0)'\n  []\n[]\n\n[BCs]\n  [surface]\n    type = ConvectiveFluxFunction\n    T_infinity = T_fluid\n\n    # convert from W/m2/K to W/cm2/K\n    coefficient = ${fparse 1000.0/100.0/100.0}\n    variable = temp\n    boundary = 'rmax_c'\n  []\n[]\n\n[ThermalContact]\n  # This adds boundary conditions bewteen the fuel and the cladding, which represents\n  # the heat flux in both directions as\n  # q''= h * (T_1 - T_2)\n  # where h is a conductance that accounts for conduction through a material and\n  # radiation between two infinite parallel plate gray bodies.\n  [one_to_two]\n    type = GapHeatTransfer\n    variable = temp\n    primary = 'rmax'\n    secondary = 'rmin_c'\n\n    # we will use a quadrature-based approach to find the gap width and cross-side temperature\n    quadrature = true\n\n    # emissivity of the fuel\n    emissivity_primary = 0.8\n\n    # emissivity of the clad\n    emissivity_secondary = 0.8\n\n    # thermal conductivity of the gap material\n    gap_conductivity = 1.0\n\n    # geometric terms related to the gap\n    gap_geometry_type = CYLINDER\n    cylinder_axis_point_1 = '0 0 0'\n    cylinder_axis_point_2 = '0 0 ${L}'\n  []\n[]\n\n[Materials]\n  [k_clad]\n    type = GenericConstantMaterial\n    prop_values = '0.5'\n    prop_names = 'thermal_conductivity'\n    block = '1'\n  []\n  [k_fuel]\n    type = GenericConstantMaterial\n    prop_values = '0.05'\n    prop_names = 'thermal_conductivity'\n    block = '2 3'\n  []\n[]\n\n[Executioner]\n  type = Transient\n  nl_abs_tol = 1e-8\n  num_steps = 5\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\n[Postprocessors]\n  [source_integral]\n    type = ElementIntegralVariablePostprocessor\n    variable = heat_source\n  []\n  [max_T]\n    type = NodalExtremeValue\n    variable = temp\n  []\n[]\nand this is the mesh input\nr_pin = 0.39218\nclad_ir = 0.40005\nclad_or = 0.45720\nL = 300.0\n\n[Mesh]\n  [clad] # This makes a circular annulus that will represent the clad\n    type = AnnularMeshGenerator\n    nr = 3\n    nt = 20\n    rmin = ${clad_ir}\n    rmax = ${clad_or}\n    quad_subdomain_id = 1\n    tri_subdomain_id = 0\n  []\n  [extrude_clad] # this extrudes the circular annulus in the axial direction\n    type = AdvancedExtruderGenerator\n    input = clad\n    heights = '${L}'\n    num_layers = '40'\n    direction = '0 0 1'\n  []\n\n  # A sideset in MOOSE is both an ID and a name.\n  # This renames the sideset numbers on the clad inner surface (0) and outer surface (1)\n  # to (5) and (4), respectively. This is done to avoid name collisions with another\n  # AnnularMeshGenerator we use for the fuel pellet. After we rename the sideset IDs, we\n  # need another RenameBoundaryGenerator to rename the sideset names.\n  [rename_clad]\n    type = RenameBoundaryGenerator\n    input = extrude_clad\n    old_boundary = '1 0' # outer surface, inner surface\n    new_boundary = '5 4'\n  []\n  [rename_clad_names]\n    type = RenameBoundaryGenerator\n    input = rename_clad\n    old_boundary = 'rmax rmin' # outer surface, inner surface\n    new_boundary = 'rmax_c rmin_c'\n  []\n\n  [fuel] # this makes a circle that will represent the fuel\n    type = AnnularMeshGenerator\n    nr = 10\n    nt = 20\n    rmin = 0\n    rmax = ${r_pin}\n    quad_subdomain_id = 2\n    tri_subdomain_id = 3\n    growth_r = -1.2\n  []\n  [extrude] # this extrudes the circle in the axial direction\n    type = AdvancedExtruderGenerator\n    input = fuel\n    heights = '${L}'\n    num_layers = '40'\n    direction = '0 0 1'\n  []\n  [combine]\n    type = CombinerGenerator\n    inputs = 'rename_clad_names extrude'\n  []\n\n  # one of the mesh generators does not work with distributed mesh\n  parallel_type = replicated\n[]",
          "url": "https://github.com/idaholab/moose/discussions/27786",
          "updatedAt": "2024-06-11T17:39:34Z",
          "publishedAt": "2024-06-04T17:34:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIn paraview are you visualizing the last time step?\nThe default is to show you the initial condition",
                  "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9670806",
                  "updatedAt": "2024-06-04T23:51:20Z",
                  "publishedAt": "2024-06-04T23:51:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "amerallaf"
                          },
                          "bodyText": "Hello @GiudGiud,\nI am checking all time steps and it is zero always.\nSee the figure below:\n\nBut the interesting thing is if I change the power the temperature changes accordingly:\nFor heat_source=250\n\nFor heat_source=350",
                          "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9680060",
                          "updatedAt": "2024-06-05T16:05:27Z",
                          "publishedAt": "2024-06-05T16:05:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you look at the field instead?\nThis graph is likely showing a value at the wrong location",
                          "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9683558",
                          "updatedAt": "2024-06-06T00:23:33Z",
                          "publishedAt": "2024-06-06T00:23:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Maybe not\nHow did you compute heat_source in the simulation ?",
                          "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9683567",
                          "updatedAt": "2024-06-06T00:25:12Z",
                          "publishedAt": "2024-06-06T00:25:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "In your input the postprocessor is called source_integral not heat_source. So what are you plotting in that graph?",
                          "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9683757",
                          "updatedAt": "2024-06-06T00:59:26Z",
                          "publishedAt": "2024-06-06T00:59:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amerallaf"
                          },
                          "bodyText": "Sorry for the confusion, it is the same variable, I just ran a different version of the script\n  [heat_source]\n    type = ElementIntegralVariablePostprocessor\n    variable = heat_source\n  []\nI also tried the field and still shows zero (for any time step).",
                          "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9690866",
                          "updatedAt": "2024-06-06T14:47:58Z",
                          "publishedAt": "2024-06-06T14:46:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think there is some confusion here\nyou are creating a heat source in the equation with this kernel\n  [heat_source]\n    type = HeatSource\n    value = 250 \n    variable = temp\n    block = '2 3'\n  []\n\nwhich does NOT use a heat_source auxiliary variable. That auxiliary variable is currently doing nothing, sitting at a 0 value.\nIf you want to use this variable:\n\nuse an auxiliary kernel or a transfer to set the heat source aux variable\nuse a CoupledForce kernel to make use of the heat_source variable in the equations",
                          "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9696925",
                          "updatedAt": "2024-06-07T04:46:53Z",
                          "publishedAt": "2024-06-07T04:46:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amerallaf"
                          },
                          "bodyText": "Thanks a lot @GiudGiud , now it is working well.\nI did the following in the end:\n[AuxVariables]\n  [power]\n    block = '2 3'\n    initial_condition = 300\n  []\n[]\n\n[Kernels]\n  [hc]\n    type = HeatConduction\n    variable = temp\n  []\n  [source]\n    type = CoupledForce\n    variable = temp\n    v = power\n    block = '2 3'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9706669",
                          "updatedAt": "2024-06-07T19:35:58Z",
                          "publishedAt": "2024-06-07T19:35:57Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amerallaf"
                          },
                          "bodyText": "Currently I am trying to turn this variable into a function of time by doing the following:\n[AuxVariables]\n  [power]\n    block = '2 3'\n    initial_condition = 300\n  []\n[]\n\n[AuxKernels]\n  [./reconstruct_power]\n    type = FunctionAux\n    variable = power\n    function = Fiss_Function\n  [../]\n[]\n\n[Kernels]\n  [source]\n    type = CoupledForce\n    variable = temp\n    v = power\n    block = '2 3'\n  [../]\n[]\n\n[Functions]\n  [Fiss_Function]\n    type = ParsedFunction\n    expression = 't* ${power}'\n  []\n[]\nBut I am getting the following error:\n*** ERROR ***\nno variable 'power' found for substitution expression\nI would really appreciate your advice on this.",
                          "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9706717",
                          "updatedAt": "2024-06-07T19:44:12Z",
                          "publishedAt": "2024-06-07T19:41:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Nothing in the snippet you pasted asks for a source auxiliary variable?",
                          "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9709664",
                          "updatedAt": "2024-06-08T03:24:01Z",
                          "publishedAt": "2024-06-08T03:24:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amerallaf"
                          },
                          "bodyText": "No this is the whole thing:\n*** ERROR ***\n..../solid_CoupledForce_time_1.i:54.5: no variable 'power' found for substitution expression\nStack frames: 11\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits, std::allocator >&>(std::__cxx11::basic_string<char, std::char_traits, std::allocator >&)\n3: Moose::Builder::build()\n4: MooseApp::setupOptions()\n5: MooseApp::run()\n6: ./cardinal-opt(+0x3264) [0x7f5694ed0264]\n7: main\n8: /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7f5685af9d90]\n9: __libc_start_main\n10: ./cardinal-opt(+0x34dd) [0x7f5694ed04dd]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor",
                          "url": "https://github.com/idaholab/moose/discussions/27786#discussioncomment-9731481",
                          "updatedAt": "2024-06-10T20:28:19Z",
                          "publishedAt": "2024-06-10T20:28:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Pull request steps",
          "author": {
            "login": "Leni-Yeo"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nGood morning.\nI have a general question about \"Pull requests\".\nI submitted one (#27816) for the first time recently.\nI saw that there are checks that have failed (46 errored and 1 failing checks), so I tried to see the details next to them, but the results screen doesn't load/show anything even after a day. I don't know if I have something to do/fix anything on my end or if I just have to wait till the developers complete a process first.",
          "url": "https://github.com/idaholab/moose/discussions/27863",
          "updatedAt": "2024-06-11T18:02:14Z",
          "publishedAt": "2024-06-11T16:37:23Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThanks for reaching out. I replied there with more information.\nThe output of the testing is already in the PR, but maybe you could not see it\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27863#discussioncomment-9741756",
                  "updatedAt": "2024-06-11T17:01:41Z",
                  "publishedAt": "2024-06-11T17:01:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "how to compute a strain wich is about hydrostaic stress",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Hello, I want to compute a strain wich is about hydrostaic stress.\nso I write this class\n  _stress(this->template getMaterialPropertyByName<RankTwoTensor>(\"stress\")),\n\n    // theoretical density fraction perecent\n    if (_geom_type == OxidalDensificationTempl<is_ad>::PLATE)\n      _hydro_stress = _stress[_qp].trace() / 3.0;\n    else if (_geom_type == OxidalDensificationTempl<is_ad>::CYLINDER)\n      _hydro_stress = (_stress[_qp](0, 0) + _stress[_qp](1, 1)) / 2.0;\nand when i test this, there is somthing wrong\ndensification <- all_strain <- stress <- densification\nMy input .i is like this\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 2e11\n    poissons_ratio = 0.3\n  []\n  [density]\n    type = Density\n    density = 10e3\n  []\n  [densification]\n    type = OxidalDensification\n    burnup = burnup\n    temperature = temp\n    densification_model = MATPRO\n    plutonium_concentration = plutonium_concentration\n    grain_size = grain_size\n    OM_ratio = OM_ratio\n    density = density\n    eigenstrain_name = 'denficaton_eigenstrain'\n  [] \n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []\n[]\nand I find some useful code in there ADViscoplasticityStressUpdate\nso I need to pubic parent class like ADViscoplasticityStressUpdateBase?\nI also find the hydrostatic stress is been defined in RankTwoScalarAux, so I also write the other code\n_hydro_stress(this->template coupledValue(\"hydro_stress\"))\nMy question is What is the difference between the latter and the former\uff1f\nSecond question is about creep in #27783\nwhy MOOSE PowerLawCreepUpdateStress use the\n\nCan I think of the formula in the box as von Mises? if not, what are the advantages of doing this?\nThanks for your reply",
          "url": "https://github.com/idaholab/moose/discussions/27834",
          "updatedAt": "2024-06-11T16:11:16Z",
          "publishedAt": "2024-06-08T14:08:16Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFor the first question, do you mean that the code complains about a circular dependency?\ndensification <- all_strain <- stress <- densification\n\nif so then one option would be to move your code into the strain material.\nFor the second question,\n@tophmatthews @jasondhales",
                  "url": "https://github.com/idaholab/moose/discussions/27834#discussioncomment-9717261",
                  "updatedAt": "2024-06-09T03:32:37Z",
                  "publishedAt": "2024-06-09T03:32:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "if so then one option would be to move your code into the strain material.\n\nthanks. yes there has a circular wrong.\nI don't sure how to do move code into strain material. Is there has similar code?\nI use a auxvariable to get hydrosticity stress with ranktwoscalaraux. later i post my code.",
                          "url": "https://github.com/idaholab/moose/discussions/27834#discussioncomment-9718886",
                          "updatedAt": "2024-06-09T12:18:49Z",
                          "publishedAt": "2024-06-09T12:18:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "In both code i public ComputeEigenstrainBaseTempl\nfirst code has the circular dependency\n  _stress(this->template getMaterialPropertyByName<RankTwoTensor>(\"stress\")),\n\ntemplate <bool is_ad>\nvoid\nOxidalDensificationTempl<is_ad>::computeProperties()\n{\n    if (_geom_type == OxidalDensificationTempl<is_ad>::PLATE)\n      _hydro_stress = _stress[_qp].trace() / 3.0;\n    else if (_geom_type == OxidalDensificationTempl<is_ad>::CYLINDER)\n      _hydro_stress = (_stress[_qp](0, 0) + _stress[_qp](1, 1)) / 2.0;\n}\nwhith test.i\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 2e11\n    poissons_ratio = 0.3\n  []\n  [density]\n    type = Density\n    density = 10e3\n  []\n  [densification]\n    type = OxidalDensification\n    burnup = burnup\n    temperature = temp\n    densification_model = MATPRO\n    plutonium_concentration = plutonium_concentration\n    grain_size = grain_size\n    OM_ratio = OM_ratio\n    density = density\n    eigenstrain_name = 'denficaton_eigenstrain'\n  [] \n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []\n[]\nsecond way code is\n   _hydro_stress(this->template coupledValue(\"hydro_stress\")),\nwith test.i is\n  [hydro_stress]\n    type = RankTwoScalarAux\n    variable = hydro_stress\n    rank_two_tensor = stress\n    scalar_type = hydrostatic\n  []\n  [densification]\n    type = OxidalDensification\n    burnup = burnup\n    temperature = temp\n    densification_model = MATPRO\n    plutonium_concentration = plutonium_concentration\n    grain_size = grain_size\n    OM_ratio = OM_ratio\n    density = density\n    eigenstrain_name = 'denficaton_eigenstrain'\n    hydro_stress = hydro_stress\n  [] \n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/27834#discussioncomment-9719782",
                          "updatedAt": "2024-06-09T15:43:48Z",
                          "publishedAt": "2024-06-09T15:43:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "by move code I mean move the definition and computation of the material property.\nThinking about it, it might not help. The properties should not define on each other like this. And if they do, you have to find a way to break the dependency.\nMaybe consider lagging one term? Using the value from the previous time step",
                          "url": "https://github.com/idaholab/moose/discussions/27834#discussioncomment-9721879",
                          "updatedAt": "2024-06-10T00:50:10Z",
                          "publishedAt": "2024-06-10T00:50:10Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Hello, I do as you advice\nin the code\n_stress_old(this->template getMaterialPropertyOldByName<RankTwoTensor>(\"stress\"))\nthe result show is same with second way above.",
                          "url": "https://github.com/idaholab/moose/discussions/27834#discussioncomment-9722284",
                          "updatedAt": "2024-06-10T02:19:57Z",
                          "publishedAt": "2024-06-10T02:19:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the result show is same with second way above.\n\nSo if the problem is transient then using an old material property just turned whichever time integration scheme into a explicit-implicit scheme. It likely is now 1st order in time (if it was not already)\nIt is not necessarily an issue.",
                          "url": "https://github.com/idaholab/moose/discussions/27834#discussioncomment-9741246",
                          "updatedAt": "2024-06-11T16:11:16Z",
                          "publishedAt": "2024-06-11T16:11:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to Access Variable Values at Specific Points in a Kernel",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI want to compute a 2D equation that includes a term representing the difference in a variable's values at two positions, such as u(x,1)\u2212u(x,\u22121). How can I access the variable solution at arbitrary points in a Kernel?\nThank you all for your attention. I would be especially grateful if someone could provide a solution to this issue.",
          "url": "https://github.com/idaholab/moose/discussions/27861",
          "updatedAt": "2024-06-11T14:33:20Z",
          "publishedAt": "2024-06-11T13:49:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe easiest way to do this will be to use the Functor arguments of variables.\nYou use a ElemPointArg as an argument to the evaluation of the variable, with something similar to this pseudo code (use the doxygen to find the actual routines):\n// First, get a point locator from the mesh\n_pl = _mesh.getPointLocator();\nconst auto other_elem = _pl.locate_elem(point + (0,1,0));\nconst ElemPointArg elem_point(other_elem, point + (0,1,0));\nconst auto value_other_elem = _var(elem_point, determineState());\n\nthen this gets you the location at the a point + 1 on the second axis\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27861#discussioncomment-9740123",
                  "updatedAt": "2024-06-11T14:33:20Z",
                  "publishedAt": "2024-06-11T14:33:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Who generates my stress_xy, ...xz, ...?",
          "author": {
            "login": "jmeier"
          },
          "bodyText": "Dear Community,\nIn my Moose input file I use the \"Physics/SolidMechanics/QuasiStatic\" block. The model itself works fine.\nI only request stress_xx, _yy, and _zz to be present as AuxVariable but Moose is generating all the others too. Moose writes:\nAuxiliary System:\n  Num DOFs:                270028\n  Num Local DOFs:          17325\n  Variables:               { \"stress_xx\" \"stress_yy\" \"stress_zz\" \"stress_xy\" \"stress_xz\" ... \"stress_yz\" \n                             \"stress_zx\" \"stress_zy\" \"p\" \"q\" } \n  Finite Element Types:    \"MONOMIAL\" \n  Approximation Orders:    \"CONSTANT\" \n\nI'd like to restrict Moose to have only Variables: { \"stress_xx\" \"stress_yy\" \"stress_zz\" \"p\" \"q\" } \nMy questions are: Why Moose does this and how can I restrict the AuxVariables generated?\nMy \"Physics/SolidMechanics/QuasiStatic\" block looks like (this is my only block of this type, no includes in my file...):\n[Physics]\n  [SolidMechanics]\n    [QuasiStatic]\n      [.all]\n        strain = SMALL\n        incremental = true\n        add_variables = true\n        eigenstrain_names = ini_stress\n        generate_output = 'stress_xx stress_yy stress_zz'\n      []\n    []\n  []\n[]\n\nThere are some additional AuxVariables and AuxKernels:\n[AuxVariables]\n  [p]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [q]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[AuxKernels]\n  [p]\n    type = RankTwoScalarAux\n    rank_two_tensor = stress\n    variable = p\n    scalar_type = hydrostatic\n  []\n  [q]\n    type = RankTwoScalarAux\n    rank_two_tensor = stress\n    variable = q\n    scalar_type = vonmisesStress\n  []\n[]\n\nOutput-block looks like:\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/27819",
          "updatedAt": "2024-06-10T06:18:56Z",
          "publishedAt": "2024-06-07T13:12:12Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis could be modified in the QuasiStaticSolidMechanics. We simply havent worked on limiting the output.\nFeel free to make a pull request if you really need this\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27819#discussioncomment-9711275",
                  "updatedAt": "2024-06-08T07:15:31Z",
                  "publishedAt": "2024-06-08T07:15:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Guillaume,\nThank you for the clarification! I checked the code of QuasiStaticSolidMechanicsPhysics, but realized that the restriction of the output must be done by someone more experienced.\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/27819#discussioncomment-9723490",
                          "updatedAt": "2024-06-10T06:35:10Z",
                          "publishedAt": "2024-06-10T06:18:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}