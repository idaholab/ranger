{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNi0xN1QwODoxNjo0My0wNjowMM4ANBq2"
    },
    "edges": [
      {
        "node": {
          "title": "Get some statistic date from moose in phaseFiled/grain growth model",
          "author": {
            "login": "zengfy-hust"
          },
          "bodyText": "Hello Moose experts:\nI recently get the data i want from moose .however ,except for the visulize file (.e)file .I can also get avg_grain_volume  etc,however ,Can I get the data of each grain's diameter  evlove with time  \uff1f Thank you .",
          "url": "https://github.com/idaholab/moose/discussions/18066",
          "updatedAt": "2021-06-23T09:27:36Z",
          "publishedAt": "2021-06-11T03:14:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat kind of object is this avg_grain_volume? If it s a post processor, then it s stored as a global variable in the exodus file and you can view it in paraview\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18066#discussioncomment-900058",
                  "updatedAt": "2021-06-21T21:51:35Z",
                  "publishedAt": "2021-06-21T21:51:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Continuity in secondary domain from mesh file input",
          "author": {
            "login": "AnthonyB08"
          },
          "bodyText": "Hi all,\nI am trying to import a mesh file of a pipe with some thickness. This then becomes a two-domain problem. Block id, 3, is the inner volume of the pipe, while block Id 4 is the thickness of the pipe. The interface between the two domains is side set 13 and   12. I would like to impose continuity between the domains, which will require merging these side sets to form an interface or implement a continuity boundary condition at these side sets.\nSide set :13 Block Id =3\n\nSide set :12 Block Id =4",
          "url": "https://github.com/idaholab/moose/discussions/17991",
          "updatedAt": "2023-02-02T17:42:38Z",
          "publishedAt": "2021-06-02T23:24:41Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "AnthonyB08"
                  },
                  "bodyText": "P.S The inner domain was hidden for best illustration. See the mesh of the Side Set depicted as orange.",
                  "url": "https://github.com/idaholab/moose/discussions/17991#discussioncomment-818345",
                  "updatedAt": "2023-02-02T17:42:17Z",
                  "publishedAt": "2021-06-03T00:32:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Potentially, you can use glued contact to enforce the continuity of two blocks. However, it would be much easier to create conforming mesh for two blocks, any reason that you can not do it using your meshing tools?",
                          "url": "https://github.com/idaholab/moose/discussions/17991#discussioncomment-821598",
                          "updatedAt": "2023-02-02T17:42:17Z",
                          "publishedAt": "2021-06-03T15:55:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AnthonyB08"
                          },
                          "bodyText": "It is quite a lengthy progress until I can get meshio , from python, to work. I design and mesh my domains in Ansys Fluent. Then import it into Coreform to export as a .e (exodus file). I have glued the two interfaces together but it is then only reading a single block (domain).\n\nI will have to read around.",
                          "url": "https://github.com/idaholab/moose/discussions/17991#discussioncomment-821966",
                          "updatedAt": "2023-02-02T17:42:17Z",
                          "publishedAt": "2021-06-03T17:23:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Anthony\nYou could use a Parsed meshgenerator to separate the two blocks in moose\nhttps://mooseframework.inl.gov/source/meshgenerators/ParsedSubdomainMeshGenerator.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17991#discussioncomment-900042",
                  "updatedAt": "2023-02-02T17:42:19Z",
                  "publishedAt": "2021-06-21T21:46:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Transfer material parameters to a Sub-App (MultiApps)",
          "author": {
            "login": "LabrosV"
          },
          "bodyText": "Hi all,\nIn my main app, I declare a Material Property, which is different at each quadrature point (and can be considered as a history variable).\nWhen I needed to use a staggered scheme between 2 coupled fields, I used the MultiApp system to do so. The aforementioned history variable is requested in the sub app but it cannot be transferred based on other posts I read here. I managed to convert this Material Property into AuxVariable (that can be transferred) using MaterialRealAux but this approach makes this history variable constant throughout the element in the sub-app.\nQuestions:\n\n\nHow can I convert this material property into AuxVariable with higher order (not constant)? Please consider that I want to be able to run my code in a cluster (so higher order approximations at element level (i.e. the MONOMIAL option with high order) cannot be used because they cannot run in parallel).\n\n\nI created an AuxKernel which returns an AuxVariable based on the values of the Material Property. However, I think this solution is wrong because this kernel must run on a nodal variable and not material property. Can I use an AuxKernel to convert the data? Any suggestion for a Postprocessor method that I have overlooked?\n\n\nShould I change my implementation in the main app and declare an AuxVariable instead of a Material Property? Then, it will be easier to transfer it.\n\n\nAny alternative ways to implement a staggered scheme without using the MultiApps system? Maybe a field-split solver in the executioner?\n\n\nAnswers to any of these questions are much appreciated.\nThanks,\nLabros",
          "url": "https://github.com/idaholab/moose/discussions/18104",
          "updatedAt": "2022-07-08T08:04:20Z",
          "publishedAt": "2021-06-17T02:03:56Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nTransferring to AuxVariables is the right thing to do here. However, using a higher order AuxVariable and essentially projecting the material property may not have been implemented. @fdkong worked on projections for transfers, which is a similar issue, he should be able to tell us more.\nAuxKernels are the right way to copy MaterialProperties onto an AuxKernel. Postprocessors will only process like one value for the whole domain.\nIf that is an option, I think it would work. Then you will avoid the projection issue.\nField split executioner is an option but it s not really staggered. Please let us know how that goes if you try it. Multiapp is the easier option for staggering.\nbest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18104#discussioncomment-898633",
                  "updatedAt": "2022-07-08T08:04:19Z",
                  "publishedAt": "2021-06-21T15:53:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "How can I convert this material property into AuxVariable with higher order (not constant)? Please consider that I want to be able to run my code in a cluster (so higher order approximations at element level (i.e. the MONOMIAL option with high order) cannot be used because they cannot run in parallel).\n\nWhat error messages you saw when using higher order variables?  MaterialRealAux should work with  higher order variables and it will do projections.\n\nI created an AuxKernel which returns an AuxVariable based on the values of the Material Property. However, I think this solution is wrong because this kernel must run on a nodal variable and not material property. Can I use an AuxKernel to convert the data? Any suggestion for a Postprocessor method that I have overlooked?\n\nYes, but  MaterialRealAux should do right things for you. AuxKernels can run on either nodal variables or elemental variables.\n\nShould I change my implementation in the main app and declare an AuxVariable instead of a Material Property? Then, it will be easier to transfer it.\n\nThis option will work, but it is not necessary if your code already with materials.\n\nAny alternative ways to implement a staggered scheme without using the MultiApps system? Maybe a field-split solver in the executioner?\n\nA field-split solver  is a preconditioner, and it does not fit well for your purpose here.\nHowever, even you have a high order variable using, and the current implementation of transfers does not work well with high order variables yet. We have a PR here #17417 for enabling high-order variable transfers",
                  "url": "https://github.com/idaholab/moose/discussions/18104#discussioncomment-899497",
                  "updatedAt": "2022-07-08T08:04:19Z",
                  "publishedAt": "2021-06-21T18:41:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Anisotropy] GBAnisotropy Question when there are many grains",
          "author": {
            "login": "syeonk"
          },
          "bodyText": "Hello!\nI'm interested in grain growth mechanism, so I have referred your simulation nowadays.\nI'm really happy to use phase field simulation easily :)\nBut I have a problem on the anisotropy grain growth.\nWhen I run it through below conditions, it did not converge at the time step although I apply large number of iterations in executioner. Moreover, it did not look like general grain growth case. (boundary goes to bend)\n(Conditions: in 'combined' module, set initial points of 22 grains using txt file.\n100X100 meshes on 2D surface (10nmX10nm).\ntime step 0.25 ns.\nmaking matrices of GB properties (GB energy, mobility prefactor) through a paper, 'Eisuke Miyoshi, et al. Large-scale phase-field study of anisotropic grain growth: Effects of misorientation-dependent grain boundary energy and mobility, Comp. Mater. Sci. 186 (2021) 109992')\nI also tested using 'combined' module in moose program for 6 grains on same conditions (just reduce the number of grains), however, it works.\nIs there a problem when I increase the number of grains?\nI would appreciate your reply :)\nThanks,",
          "url": "https://github.com/idaholab/moose/discussions/18091",
          "updatedAt": "2022-06-29T07:32:01Z",
          "publishedAt": "2021-06-16T03:25:27Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "simopier"
                  },
                  "bodyText": "Hi @syeonk,\nCould you provide the input files and other txt files of the two simulations (the one that works and the one that does not), and the associated output files? That would help identify where the issue is coming from.\nThank you!",
                  "url": "https://github.com/idaholab/moose/discussions/18091#discussioncomment-899376",
                  "updatedAt": "2022-06-29T07:32:01Z",
                  "publishedAt": "2021-06-21T18:08:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Calculations of total concentration generated and at the boundaries",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "Dear MOOSE Group,\nI have a concentration diffusion model with a source term (please see the attached figure).\nIn the model, the concentration is generated in Block 1 and diffused to the boundaries.\nI would like to calculate the total concentration [moles] generated in Block 1 and the concentration [moles] on the top, right, bottom, and left boundaries to confirm the conservation.\nI am looking for examples for these calculations.\nPlease help me.\nThomas\nDiffusion_Model_with_Source.pdf",
          "url": "https://github.com/idaholab/moose/discussions/18040",
          "updatedAt": "2023-08-29T18:36:47Z",
          "publishedAt": "2021-06-09T17:49:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere are plenty of diffusion-source examples on the website. Let me know If you need me to find one for you\nYou should be able to use postprocessors to calculate the concentration:\n\nSideAverageValue for the boundaries\nElementAverageValue for block 1 https://mooseframework.inl.gov/source/postprocessors/ElementExtremeValue.html\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18040#discussioncomment-899267",
                  "updatedAt": "2023-08-29T18:36:47Z",
                  "publishedAt": "2021-06-21T17:39:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Implementing a custom factor in steady-state calculation",
          "author": {
            "login": "mistloin"
          },
          "bodyText": "Hi. I studied about \"time-stepping\" framework in moose like the below equation; (increase or cutoff timestep along with residual value).\ndt_new = dt_old * \"Factor\"      --> \"Factor\" adjusted along with residual value\nI currently use the moose library to solve a steady-state equation, and I want to implement a similar concept as;\nX_new = X_old - \"Factor\" * Inv(J) * F     --> \"Factor\" adjusted along with residual vlaue;\nwhere X is solution vector, J is a jacobian matrix, F is residual\nI have searched the moose framework which supports this kind of concept, but I have found nothing yet.\nShould I develop a custom user object or other functional files for my question?\nOr is there any framework that supports the above concept?\nAlso, is there any way to get residual value (printed on-screen after each iteration) in my kernel?\n(I tried to approach the printed value, the value may be printed through \"PetscOutput.C\", but I failed to access them)\nThanks for reading my question. Have a good day.",
          "url": "https://github.com/idaholab/moose/discussions/17999",
          "updatedAt": "2023-02-23T17:20:57Z",
          "publishedAt": "2021-06-03T12:38:09Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere is a timestepper that can grow the time step by a constant factor. See https://mooseframework.inl.gov/source/timesteppers/IterationAdaptiveDT.html\nFor the update, I m not sure why you would want to add a factor there. Could you please give a reference for this method?\nIn the kernel? The kernel is executed at every quadrature point, so you want the residual at every quadrature point (which the kernel is contributing to)? Or do you want the residual for the whole domain?\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17999#discussioncomment-836909",
                  "updatedAt": "2023-02-23T17:20:58Z",
                  "publishedAt": "2021-06-07T20:52:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mistloin"
                          },
                          "bodyText": "Thanks for your response.\nThe reason why I want to use the factor in a steady-state is that the factor may improve convergence of my problem.\nWhen I solve Newton method using MATLAB, I found that the problem (which was not converged) was converged by using the factor. (Initially the factor is very small value such as 1e-10, and along with residual, the factor increases up to 1)\nI want to access the residual value for whole domain, because I should decides the factor value along with whole domain residual.",
                          "url": "https://github.com/idaholab/moose/discussions/17999#discussioncomment-837809",
                          "updatedAt": "2023-02-23T17:20:58Z",
                          "publishedAt": "2021-06-08T02:53:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok that makes sense. Somehow I thought the factor would be bigger than 1.\nYou can use relaxed Picard iterations to achieve the same effect. In those you will have:\nX_new_picard = a * X_new + (1-a) * X_old = (a + 1 -a) * X_old  - a * invJ F\nWe currently do not support varying relaxation factors, though that feature would not be very hard all to add in executioners/PicardSolve.C. I would make the relaxation factor a function then. This function could be the same as the one used by the timestepper to control the timestep.\nFor getting the residual in a kernel, you can use a Residual postprocessor, then create a new kernel that can take it as an input, then use getPostprocessorValueByName to get the value.\nOr you can look at postprocessors/Residual.C and import some of that code into your kernel\nBest,\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/17999#discussioncomment-837855",
                          "updatedAt": "2023-02-23T17:20:58Z",
                          "publishedAt": "2021-06-08T03:14:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mistloin"
                          },
                          "bodyText": "Thanks for your advice! I will study about the Picard iteration and the residual post-proccessor just right now.",
                          "url": "https://github.com/idaholab/moose/discussions/17999#discussioncomment-897562",
                          "updatedAt": "2023-02-23T18:00:04Z",
                          "publishedAt": "2021-06-21T12:36:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Material property assign on boundary]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear moose users,\nI am trying to find a way to implement material properties only on boundaries (Surfaces or points).\nIs there any way to do this?\nI found the Interfacematerials.C, but it's for interfaces of two different domains.",
          "url": "https://github.com/idaholab/moose/discussions/18124",
          "updatedAt": "2025-03-11T20:26:26Z",
          "publishedAt": "2021-06-21T04:53:41Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can specify the 'boundary' parameter in the same way that you define 'block' for a material defined inside the domain.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18124#discussioncomment-895978",
                  "updatedAt": "2022-06-14T14:32:21Z",
                  "publishedAt": "2021-06-21T06:02:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Thank you for your comment @GiudGiud .\nIt works!\nCheers,\nNakkyu",
                          "url": "https://github.com/idaholab/moose/discussions/18124#discussioncomment-896296",
                          "updatedAt": "2022-06-14T14:32:21Z",
                          "publishedAt": "2021-06-21T07:44:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can not build a navier stokes app",
          "author": {
            "login": "majumdararn"
          },
          "bodyText": "I want to build an app with the Navier_Stokes module on. When I make this app, it shows following error.\n/home/amajumda/anaconda3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/9.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/amajumda/moose/modules/module_loader/lib/libmodule_loader_with_fp_ray_hc_rdg_ns-opt.so: undefined reference to NavierStokesApp::registerExecFlags(Factory&)' /home/amajumda/anaconda3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/9.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/amajumda/moose/modules/module_loader/lib/libmodule_loader_with_fp_ray_hc_rdg_ns-opt.so: undefined reference to NavierStokesApp::registerObjects(Factory&)'\n/home/amajumda/anaconda3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/9.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/amajumda/moose/modules/module_loader/lib/libmodule_loader_with_fp_ray_hc_rdg_ns-opt.so: undefined reference to `NavierStokesApp::associateSyntax(Syntax&, ActionFactory&)'\ncollect2: error: ld returned 1 exit status\nmake: *** [/home/amajumda/moose/framework/app.mk:407: /home/amajumda/navier_stokes/navier_stokes-opt] Error 1\nCould anyone help?",
          "url": "https://github.com/idaholab/moose/discussions/18108",
          "updatedAt": "2022-08-23T22:40:51Z",
          "publishedAt": "2021-06-17T09:58:39Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nLet\u2019s first try to update moose and libmesh.\nfor moose pull from the repository, for lib mesh run conda update \u2014all\nthen make clobberall to clean up and make -j<the number of cores> again\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18108#discussioncomment-883637",
                  "updatedAt": "2022-08-23T22:40:52Z",
                  "publishedAt": "2021-06-17T14:25:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "majumdararn"
                          },
                          "bodyText": "@GiudGiud Thank you very much for your suggestion\nIt worked.\nI ran git pull inside moose directory and then did conda update --all\nfinally did make clobberall and then make -j",
                          "url": "https://github.com/idaholab/moose/discussions/18108#discussioncomment-885681",
                          "updatedAt": "2022-08-23T22:40:52Z",
                          "publishedAt": "2021-06-17T23:55:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Boundary condition in annular geometry",
          "author": {
            "login": "FloPasselaigue"
          },
          "bodyText": "Hello,\nI would like to apply a constant, non-uniform, Dirichlet boundary condition on an annular geometry. I tried using FunctionDirichletBC with a PiecewiseLinear function but it doesn't work.\nI assume it's because I can't indicate the coordinate to use is theta in PiecewiseLinear, since it can only take x, y, or z. Is there another class to use?\nBelow is my attempted input file, thanks for the help!\n[Mesh]\n  [./amg]\n    type = AnnularMeshGenerator\n    nr = 10\n    nt = 12\n    rmin = 8.93e-3\n    rmax = 9.5e-3\n    dmin = 0\n    dmax = 180\n  []\n[]\n\n[Variables]\n  [temperature]\n  []\n[]\n\n[Functions]\n # These functions give the temperature as a function of theta (given in degrees) \n # at the inner and outer boundaries\n  [temperature_in]\n    type = PiecewiseLinear\n    x = '0\t5\t10\t15\t20\t25\t30\t35\t40\t45\t50\t55\t60\t65\t70\t75\t80\t85\t90\t95\t100\t105\t110\t115\t120\t125\t130\t135\t140\t145\t150\t155\t160\t165\t170\t175\t180'\n    y = '313\t312\t312\t312\t312\t311\t311\t310\t310\t309\t309\t308\t307\t307\t305\t304\t302\t298\t260\t298\t302\t304\t305\t307\t307\t308\t309\t309\t310\t310\t311\t311\t312\t312\t312\t312\t313'\n  []\n  [temperature_out]\n    type = PiecewiseLinear\n    x = '0\t5\t10\t15\t20\t25\t30\t35\t40\t45\t50\t55\t60\t65\t70\t75\t80\t85\t90\t95\t100\t105\t110\t115\t120\t125\t130\t135\t140\t145\t150\t155\t160\t165\t170\t175\t180'\n    y = '312\t312\t312\t312\t311\t311\t311\t310\t310\t309\t309\t308\t307\t306\t305\t304\t302\t299\t296\t299\t302\t304\t305\t306\t307\t308\t309\t309\t310\t310\t311\t311\t311\t312\t312\t312\t312'\n  []\n[]\n\n[BCs]\n  [Tin]\n    type = FunctionDirichletBC\n    variable = temperature\n    boundary = 0\n    function = temperature_in\n  []\n  [Tout]\n    type = FunctionDirichletBC\n    variable = temperature\n    boundary = 1\n    function = temperature_out\n  []\n[]\n\n[Kernels]\n  [heatflow]\n    type = CoefDiffusion\n    variable = temperature\n    coef = 1e-4\n  []\n[]\n\n[Executioner]\n  type = Steady\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/18112",
          "updatedAt": "2022-06-06T14:39:14Z",
          "publishedAt": "2021-06-17T14:04:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI d try to make it work with a FunctionSeries in the functional expansion module (you might need to add this dependency in your makefile)\nhttps://mooseframework.inl.gov/moose/source/functions/FunctionSeries.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18112#discussioncomment-884048",
                  "updatedAt": "2023-08-17T00:07:04Z",
                  "publishedAt": "2021-06-17T15:41:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "External Libraries in MOOSE",
          "author": {
            "login": "AmerMalik9"
          },
          "bodyText": "Hi,\nWe are planning to use MOOSE for our commercial software and for that we need to make sure that we don't violate any of the license rules both for MOOSE and for all the external libraries within MOOSE. Could anyone provide us with the complete list of external libraries that are being used within MOOSE. I found this list: https://mooseframework.inl.gov/sqa/library_requirements.html but I am not sure if it's complete or updated?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/18096",
          "updatedAt": "2022-08-02T16:22:08Z",
          "publishedAt": "2021-06-16T13:51:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "The items on the provided list look up to date and accurate to my eyes.",
                  "url": "https://github.com/idaholab/moose/discussions/18096#discussioncomment-878151",
                  "updatedAt": "2022-08-02T16:22:08Z",
                  "publishedAt": "2021-06-16T13:54:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "doquang"
                          },
                          "bodyText": "@AmerMalik9 - MOOSE uses PETSc, and the default configuration of PETSc on MOOSE requires:\n\nHyper\nfblaslapack\nmetis\nptscotch\nparmetis\nsuperlu\nmumps\nstrumpack\nscalapack\nslepc\n(See moose/scripts/update_and_rebuild_petsc.sh)",
                          "url": "https://github.com/idaholab/moose/discussions/18096#discussioncomment-878376",
                          "updatedAt": "2022-08-02T16:22:58Z",
                          "publishedAt": "2021-06-16T14:22:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AmerMalik9"
                          },
                          "bodyText": "@doquang Thanks Minh! Will get back to you for more questions.\n@milljm Thanks for the confirmation.",
                          "url": "https://github.com/idaholab/moose/discussions/18096#discussioncomment-881900",
                          "updatedAt": "2022-08-02T16:23:03Z",
                          "publishedAt": "2021-06-17T07:47:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "You can also take a look at our manual install instructions to control/follow everything you need: https://mooseframework.inl.gov/getting_started/installation/manual_installation_gcc.html\nOur default builds for libMesh and PETSc can be found in our scripts directory, these scripts should be relying on anything compatible. However, it is possible to configure them with things that are not.\nhttps://github.com/idaholab/moose/blob/next/scripts/update_and_rebuild_libmesh.sh\nhttps://github.com/idaholab/moose/blob/next/scripts/update_and_rebuild_petsc.sh\nFinally, framework/contrib contains some software packages that we rely on as well. To the best of our knowledge everything is compatible with LGPL 2.1.",
                          "url": "https://github.com/idaholab/moose/discussions/18096#discussioncomment-883557",
                          "updatedAt": "2022-08-02T16:23:04Z",
                          "publishedAt": "2021-06-17T14:16:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}