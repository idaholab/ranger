{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMC0wNlQxNDoxNToxNS0wNjowMM4AVxll"
    },
    "edges": [
      {
        "node": {
          "title": "Looking for MeshGenerator that combines nodesets but leaves old nodesets intact",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "I have some nodesets/boundaries that I'd like to combine in multiple ways. Say I have 3 nodesets A, B, and C. I want:\n\nA + B = D\nA + C = E\nB + C = F\n\nSeems like RenameBoundaryGenerator is close, but it destroys the old boundaries. I'm using it like:\nold_boundary = 'A B'\nnew_boundary  = 'D D'\n\netc...",
          "url": "https://github.com/idaholab/moose/discussions/25707",
          "updatedAt": "2023-10-10T20:45:28Z",
          "publishedAt": "2023-10-10T20:11:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Use ParsedGenerateSideset with the included_boundaries parameter to create new ones.\nthe combinatorial geometry can be x > -1000000 to not matter",
                  "url": "https://github.com/idaholab/moose/discussions/25707#discussioncomment-7245724",
                  "updatedAt": "2023-10-10T20:22:10Z",
                  "publishedAt": "2023-10-10T20:22:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Hmm, that creates sidesets, but what about nodesets? Also, the nodesets may not be located together - could be 4 corners of the mesh for example, or centers of mesh edges, so I can't think of a expression that works for the combinatorial geometry.",
                          "url": "https://github.com/idaholab/moose/discussions/25707#discussioncomment-7245775",
                          "updatedAt": "2023-10-10T20:29:27Z",
                          "publishedAt": "2023-10-10T20:29:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "kk seems like you ll need to make ParsedGenerateNodeset. It will be a massive copy paste with very few line changes",
                          "url": "https://github.com/idaholab/moose/discussions/25707#discussioncomment-7245882",
                          "updatedAt": "2023-10-10T20:45:39Z",
                          "publishedAt": "2023-10-10T20:45:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "mamba init",
          "author": {
            "login": "gsoim"
          },
          "bodyText": "Hi everyone,\nI am trying install MOOSE on a Mac (with Intel processor) but I got this message when I am initializing mamba:\nmemoryview: a bytes-like object is required, not 'str'\n\n# >>>>>>>>>>>>>>>>>>>>>> ERROR REPORT <<<<<<<<<<<<<<<<<<<<<<\n\n    Traceback (most recent call last):\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/site-packages/conda/exceptions.py\", line 1129, in __call__\n        return func(*args, **kwargs)\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/site-packages/mamba/mamba.py\", line 935, in exception_converter\n        raise e\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/site-packages/mamba/mamba.py\", line 928, in exception_converter\n        exit_code = _wrapped_main(*args, **kwargs)\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/site-packages/mamba/mamba.py\", line 886, in _wrapped_main\n        result = do_call(parsed_args, p)\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/site-packages/mamba/mamba.py\", line 758, in do_call\n        exit_code = shell_init(args)\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/site-packages/mamba/mamba_shell_init.py\", line 79, in shell_init\n        exit_code = initialize(\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/site-packages/conda/core/initialize.py\", line 119, in initialize\n        run_plan_elevated(plan2)\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/site-packages/conda/core/initialize.py\", line 688, in run_plan_elevated\n        result = subprocess_call(\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/site-packages/conda/gateways/subprocess.py\", line 100, in subprocess_call\n        stdout, stderr = process.communicate(input=stdin)\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/subprocess.py\", line 1152, in communicate\n        stdout, stderr = self._communicate(input, endtime, timeout)\n      File \"/Users/georgiossoimoiris/mambaforge3/lib/python3.10/subprocess.py\", line 1983, in _communicate\n        input_view = memoryview(self._input)\n    TypeError: memoryview: a bytes-like object is required, not 'str'\n\n`$ /Users/georgiossoimoiris/mambaforge3/bin/mamba init`\n\n  environment variables:\n                 CIO_TEST=<not set>\n        CONDA_DEFAULT_ENV=base\n                CONDA_EXE=/opt/anaconda3/bin/conda\n             CONDA_PREFIX=/opt/anaconda3\n    CONDA_PROMPT_MODIFIER=(base)\n         CONDA_PYTHON_EXE=/opt/anaconda3/bin/python\n               CONDA_ROOT=/Users/georgiossoimoiris/mambaforge3\n              CONDA_SHLVL=1\n           CURL_CA_BUNDLE=<not set>\n                     PATH=/Users/georgiossoimoiris/mambaforge3/bin:/opt/anaconda3/bin:/opt/anaco\n                          nda3/condabin:/Library/Frameworks/Python.framework/Versions/3.10/bin:/\n                          usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/s\n                          bin:/usr/local/share/dotnet:~/.dotnet/tools:/Library/Apple/usr/bin:/Li\n                          brary/Frameworks/Mono.framework/Versions/Current/Commands\n       REQUESTS_CA_BUNDLE=<not set>\n            SSL_CERT_FILE=<not set>\n\n     active environment : /opt/anaconda3\n    active env location : /opt/anaconda3\n            shell level : 1\n       user config file : /Users/georgiossoimoiris/.condarc\n populated config files : /Users/georgiossoimoiris/mambaforge3/.condarc\n                          /Users/georgiossoimoiris/.condarc\n          conda version : 22.9.0\n    conda-build version : not installed\n         python version : 3.10.6.final.0\n       virtual packages : __osx=13.0.1=0\n                          __unix=0=0\n                          __archspec=1=x86_64\n       base environment : /Users/georgiossoimoiris/mambaforge3  (writable)\n      conda av data dir : /Users/georgiossoimoiris/mambaforge3/etc/conda\n  conda av metadata url : None\n           channel URLs : https://conda.software.inl.gov/public/osx-64\n                          https://conda.software.inl.gov/public/noarch\n                          https://conda.anaconda.org/conda-forge/osx-64\n                          https://conda.anaconda.org/conda-forge/noarch\n                          https://repo.anaconda.com/pkgs/main/osx-64\n                          https://repo.anaconda.com/pkgs/main/noarch\n                          https://repo.anaconda.com/pkgs/r/osx-64\n                          https://repo.anaconda.com/pkgs/r/noarch\n          package cache : /Users/georgiossoimoiris/mambaforge3/pkgs\n                          /Users/georgiossoimoiris/.conda/pkgs\n       envs directories : /Users/georgiossoimoiris/mambaforge3/envs\n                          /Users/georgiossoimoiris/.conda/envs\n               platform : osx-64\n             user-agent : conda/22.9.0 requests/2.28.1 CPython/3.10.6 Darwin/22.1.0 OSX/13.0.1\n                UID:GID : 501:20\n             netrc file : None\n           offline mode : False\n\n\nAn unexpected error has occurred. Conda has prepared the above report.",
          "url": "https://github.com/idaholab/moose/discussions/22807",
          "updatedAt": "2023-10-10T14:48:49Z",
          "publishedAt": "2022-11-28T20:24:11Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis looks like a borked mamba. I would reinstall mamba and try again. If still not working I d try download a different version\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22807#discussioncomment-4257117",
                  "updatedAt": "2022-11-28T20:36:09Z",
                  "publishedAt": "2022-11-28T20:36:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "gsoim"
                          },
                          "bodyText": "Yes, it works! Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/22807#discussioncomment-4261036",
                          "updatedAt": "2022-11-29T07:39:01Z",
                          "publishedAt": "2022-11-29T07:39:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jensoulou"
                          },
                          "bodyText": "Hey,\nI have the same problem. I tried to reinstall mamba and even older versions. Sadly, none of them are working: I always have the exact same error as shown above. What can you suggest to me to do to fix this?\nThank you so much,\nJens",
                          "url": "https://github.com/idaholab/moose/discussions/22807#discussioncomment-7240156",
                          "updatedAt": "2023-10-10T11:40:07Z",
                          "publishedAt": "2023-10-10T11:40:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Let s open a new post if the solutions on this thread don't work.\nCan you run the diagnostics script in moose/script when you create the new post? Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/22807#discussioncomment-7240750",
                          "updatedAt": "2023-10-10T12:48:02Z",
                          "publishedAt": "2023-10-10T12:48:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jensoulou"
                          },
                          "bodyText": "I opened a new one: #25703 (comment)\n:-)",
                          "url": "https://github.com/idaholab/moose/discussions/22807#discussioncomment-7241961",
                          "updatedAt": "2023-10-10T14:33:17Z",
                          "publishedAt": "2023-10-10T14:33:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Boundaries in CohesiveZoneAction",
          "author": null,
          "bodyText": "Hello,\nIs there a way to set all of the interfacial boundary IDs (block0_block1 block1_block2 etc) as boundary parameter in the CohesiveZoneAction or do we have to name them all one by one ?",
          "url": "https://github.com/idaholab/moose/discussions/25690",
          "updatedAt": "2023-10-10T14:28:39Z",
          "publishedAt": "2023-10-09T14:03:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@jiangwen84 @arovinelli",
                  "url": "https://github.com/idaholab/moose/discussions/25690#discussioncomment-7233072",
                  "updatedAt": "2023-10-09T17:51:20Z",
                  "publishedAt": "2023-10-09T17:51:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "arovinelli"
                  },
                  "bodyText": "@nshabib if you use the split_interface=true option (see BreakMeshByBlockGenerator ) yes, you have to list them all.",
                  "url": "https://github.com/idaholab/moose/discussions/25690#discussioncomment-7233905",
                  "updatedAt": "2023-10-09T19:47:17Z",
                  "publishedAt": "2023-10-09T19:47:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Oh ok, thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/25690#discussioncomment-7237971",
                          "updatedAt": "2023-10-10T07:48:58Z",
                          "publishedAt": "2023-10-10T07:48:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@nshabib Just a clarification.\nYou need to use split_interface=true only if the cohesive responses is different for different interfaces.\nIf this is not the case, i.e. you use the same cohesive law with the same parameter for all interfaces, you can use split_interface=false. This will generate one single cohesive interface called interface",
                          "url": "https://github.com/idaholab/moose/discussions/25690#discussioncomment-7241849",
                          "updatedAt": "2023-10-10T14:24:33Z",
                          "publishedAt": "2023-10-10T14:24:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Yes I got that, thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/25690#discussioncomment-7241901",
                          "updatedAt": "2023-10-10T14:28:40Z",
                          "publishedAt": "2023-10-10T14:28:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A postprocessor that can simultaneously handle integration using 2 variables",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello everyone,\nI want to integrate the following volume integral on the computational domain.\nu_r and u_z are both my main variables. If I only had one variable, ElementIntegralVariablePostprocessor would had been a great option. Now that the integral consists of two main variables, how can I calculate the volume integral?\n\n\nThanks,\nAli",
          "url": "https://github.com/idaholab/moose/discussions/25695",
          "updatedAt": "2023-10-10T13:21:04Z",
          "publishedAt": "2023-10-09T23:33:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you have a variable for each derivative you could use a ParsedAux to form the whole term in a new auxvariable then use the classic PP to integrate it\nIf not then you ll need to make a new PP. It should be fine there s plenty of examples\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25695#discussioncomment-7235068",
                  "updatedAt": "2023-10-09T23:37:38Z",
                  "publishedAt": "2023-10-09T23:37:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Thanks. Do you think this is a correct way to calculate it? I mean I can integrate by getting r and z velocities separately and then call a variable that does not exist in the integral Here are .h, .C and input files.\n    [./VD]\n    type = ViscousDissipation\n    variable = w\n    vel_r = vel_x\n    vel_z = vel_y\n    c = c\n    mu = ${mu_water}\n[../]\n\n#pragma once\n\n#include \"ElementIntegralPostprocessor.h\"\n#include \"MooseVariableInterface.h\"\n\n\nclass ViscousDissipation : public ElementIntegralPostprocessor,\n                                             public MooseVariableInterface<Real>\n{\npublic:\n  static InputParameters validParams();\n\n  ViscousDissipation(const InputParameters & parameters);\n\nprotected:\n  virtual Real computeQpIntegral() override;\n\n  /// Holds the solution at current quadrature points\n  const VariableValue & _u;\n  const VariableValue & _vel_r;\n  const VariableValue & _vel_z;\n  /// Holds the solution gradient at the current quadrature points\n  const VariableGradient & _grad_vel_r;\n  const VariableGradient & _grad_vel_z;\n\n  const VariableValue & _c;\n  const Real & _mu;\n};\n\n#include \"ViscousDissipation.h\"\n\nregisterMooseObject(\"MooseApp\", ViscousDissipation);\n\nInputParameters\nViscousDissipation::validParams()\n{\n  InputParameters params = ElementIntegralPostprocessor::validParams();\n  params.addRequiredCoupledVar(\"variable\", \"The name of the variable that this object operates on\");\n  params.addRequiredCoupledVar(\"vel_r\", \"vel_r\");\n  params.addRequiredCoupledVar(\"vel_z\", \"vel_z\");\n  params.addRequiredCoupledVar(\"c\", \"c\");\n  params.addClassDescription(\"Computes a volume integral of the specified variable\");\n  params.addParam<Real>(\"mu\", 1.0, \"mu\");\n  return params;\n}\n\nViscousDissipation::ViscousDissipation(\n    const InputParameters & parameters)\n  : ElementIntegralPostprocessor(parameters),\n    MooseVariableInterface<Real>(this,\n                                 false,\n                                 \"variable\",\n                                 Moose::VarKindType::VAR_ANY,\n                                 Moose::VarFieldType::VAR_FIELD_STANDARD),\n    _u(coupledValue(\"variable\")),\n    _vel_r(coupledValue(\"vel_r\")),\n    _vel_z(coupledValue(\"vel_z\")),\n\n    _grad_vel_r(coupledGradient(\"vel_r\")),\n    _grad_vel_z(coupledGradient(\"vel_z\")),\n\n    _c(coupledValue(\"c\")),\n\n    _mu(getParam<Real>(\"mu\"))\n\n\n{\n  addMooseVariableDependency(&mooseVariableField());\n}\n\nReal\nViscousDissipation::computeQpIntegral()\n{\n  if (_c[_qp] < -0.0)\n  return 0;\n  const Real & r = _q_point[_qp](0);\n\n  return _mu *(2.0 * (_grad_vel_r[_qp](0)*_grad_vel_r[_qp](0) + _vel_r[_qp]*_vel_r[_qp] / (r * r) + _grad_vel_z[_qp](1)*_grad_vel_z[_qp](1)) +\n        _grad_vel_r[_qp](1)*_grad_vel_r[_qp](1) + _grad_vel_z[_qp](0)*_grad_vel_z[_qp](0) + 2.0 * _grad_vel_r[_qp](1)*_grad_vel_z[_qp](0));       \n}",
                          "url": "https://github.com/idaholab/moose/discussions/25695#discussioncomment-7235398",
                          "updatedAt": "2023-10-10T00:47:00Z",
                          "publishedAt": "2023-10-10T00:47:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Looks like you are on the right track\nThe best way to check this is to use it on a case where you know the solution.",
                          "url": "https://github.com/idaholab/moose/discussions/25695#discussioncomment-7241130",
                          "updatedAt": "2023-10-10T13:21:05Z",
                          "publishedAt": "2023-10-10T13:21:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "1D Curve boundary conditions for Flow in Fractured Media",
          "author": {
            "login": "SirGardener"
          },
          "bodyText": "Dear Moose community and developers,\nI hope you can help me out with this. What I am trying to accomplish is to reproduce the flow in fractured media example from the porous flow module (https://github.com/idaholab/moose/blob/next/modules/porous_flow/examples/flow_through_fractured_media/coarse_3D.i). However, I want to use an externally generated .msh File created in GMSH with the OCC Geometry Kernel. In the example, two intersecting fractures embedded within a cubic matrix are considered. These fractures, each box side and the total volume are assigned as physical groups in GMSH. Moreover, the intersection lines (1D) with the box sides are assigned as physical groups. By searching through the forum, I came across the hint that adding lower_dimensional_block in the .msh file in the respective lines under $PhysicalGroups fixed a first issue. This issue was that the fractures were not recognized in spite of having the correct ids. Afterward, the simulation successfully converged. However, inspection of the exported exodus II file revealed that lf1 and rf2 (the fracture intersections with the box side) were the entire left and right side of the cube instead of only the intersection lines. I am not sure whether this is a problem related to Moose or to GMSH. It might also be relevant to mention that while these lines were visible after creating the file in gmsh there are only points (no curves) visible for them when reopening the written .msh file with GMSHs fltk GUI. Does anybody have recommendations for me on what the best way would be to use mesh files generated in gmsh, e. g. in terms of file format? Is is perhaps necessary to combine the mesh with internal meshing capabilities?\nBest Regards\nChris",
          "url": "https://github.com/idaholab/moose/discussions/25699",
          "updatedAt": "2023-10-10T12:48:02Z",
          "publishedAt": "2023-10-10T10:18:37Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SirGardener"
                  },
                  "bodyText": "I found out that is was just turner in the input file and now it works. Closed",
                  "url": "https://github.com/idaholab/moose/discussions/25699#discussioncomment-7240749",
                  "updatedAt": "2023-10-10T12:48:17Z",
                  "publishedAt": "2023-10-10T12:47:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "What do negative values for reaction rates imply in PorousFlow?",
          "author": null,
          "bodyText": "Hello,\nI recently simulated a simple dissolution problem using the PorousFlowAqueousPreDis Kernel. However, I was surprised to see that my dissolution rates were negative. According to the PorousFlow documentation, I expected positive values for dissolution and negative values for precipitation. Is this some type of error in my simulation? I tried convincing myself by running the PorousFlow dissolution_limited.i test file, and again, I observed negative values for that problem. Does it mean negative values correspond to dissolution? Could someone please clarify this? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/25697",
          "updatedAt": "2023-10-10T04:14:54Z",
          "publishedAt": "2023-10-10T02:03:42Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "So, is the mineral actually dissolving when the reaction rate is negative? And how are you checking the reaction rate?",
                  "url": "https://github.com/idaholab/moose/discussions/25697#discussioncomment-7236352",
                  "updatedAt": "2023-10-10T03:41:34Z",
                  "publishedAt": "2023-10-10T03:41:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Hi @cpgr, Yes. The mineral is dissolving while the reaction rate is negative.I\u2019m getting the reaction rate from PorousFlowPropertyAux Kernel as follows:\n[AuxVariables]\n[diss_rate_per_sec]\n  family = MONOMIAL\n  order = CONSTANT\n[]\n[]\n\n[AuxKernels]\n[diss_rate_per_sec]\n  type = PorousFlowPropertyAux\n  property = mineral_reaction_rate\n  mineral_species = 0\n  variable = diss_rate_per_sec\n[]\n[]  \n\n\nHere is a graph of my reaction rate with the dissolving mineral:",
                          "url": "https://github.com/idaholab/moose/discussions/25697#discussioncomment-7236509",
                          "updatedAt": "2023-10-10T04:15:37Z",
                          "publishedAt": "2023-10-10T04:14:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Calling derivative of the basis functions and assembling in the a postprocessor",
          "author": {
            "login": "xiekai-mc"
          },
          "bodyText": "Hello,\nI want to calculate the macroscopic overall moduli $\\bar{\\mathbb{C}}$ as described in  https://doi.org/10.1016/S0927-0256(99)00080-4, with the formula being\n\n\nI believe I should use a postprocessor to compute the components of $\\bar{\\mathbb{C}}$, but I'm unsure about how to call the derivative of the basis functions $B$ within the postprocessor and assemble it across all elements.",
          "url": "https://github.com/idaholab/moose/discussions/25665",
          "updatedAt": "2023-10-12T14:29:01Z",
          "publishedAt": "2023-10-04T18:00:08Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "What is C?",
                  "url": "https://github.com/idaholab/moose/discussions/25665#discussioncomment-7191002",
                  "updatedAt": "2023-10-04T19:57:33Z",
                  "publishedAt": "2023-10-04T19:57:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "$\\mathbb{C}$ is  a rank four tensor.",
                          "url": "https://github.com/idaholab/moose/discussions/25665#discussioncomment-7193036",
                          "updatedAt": "2023-10-05T02:12:02Z",
                          "publishedAt": "2023-10-05T02:09:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grmnptr"
                          },
                          "bodyText": "The spatial derivatives of the basis functions should be accessible using the gradPhi function of your variable if I remember correctly. Or through the assembly object if you have access to it.",
                          "url": "https://github.com/idaholab/moose/discussions/25665#discussioncomment-7203803",
                          "updatedAt": "2023-10-05T23:00:03Z",
                          "publishedAt": "2023-10-05T22:59:26Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "What goes into C?",
                          "url": "https://github.com/idaholab/moose/discussions/25665#discussioncomment-7213266",
                          "updatedAt": "2023-10-06T20:17:51Z",
                          "publishedAt": "2023-10-06T20:17:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "$\\mathbb{C} = \\frac{\\partial \\boldsymbol{P}}{\\partial \\boldsymbol{F}} $, $\\boldsymbol{P}$ is the pk1 stress,  $\\boldsymbol{F}$ is the deformation gradient.",
                          "url": "https://github.com/idaholab/moose/discussions/25665#discussioncomment-7223723",
                          "updatedAt": "2023-10-08T16:25:57Z",
                          "publishedAt": "2023-10-08T16:25:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I would follow @grmnptr's suggestion",
                          "url": "https://github.com/idaholab/moose/discussions/25665#discussioncomment-7233032",
                          "updatedAt": "2023-10-09T17:47:05Z",
                          "publishedAt": "2023-10-09T17:47:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Orthotropic temperature dependent material",
          "author": {
            "login": "chakra34"
          },
          "bodyText": "Hi,\nI saw that currently MOOSE has temperature dependent isotropic elasticity, however it does not have that for orthotropic materials. I was hoping to implement such in MOOSE, and was wondering if I could get some help/documentation for the way the ComputeVariableIsotropicElasticity is coded, so that I can use that as a basis for orthotropic materials.\nAny suggestion/literature in this direction will be extremely helpful.\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/25194",
          "updatedAt": "2023-10-09T19:46:50Z",
          "publishedAt": "2023-08-13T20:51:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFor elasticity, there's a section on orthotropic models here:\nhttps://mooseframework.inl.gov/source/materials/ComputeElasticityTensor.html\nit s a matter of selecting the fill method\nSo you could adapt the code in ComputeVariableIsotropicElasticity the same way\n@jiangwen84 for comment\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-6722056",
                  "updatedAt": "2023-08-14T15:19:50Z",
                  "publishedAt": "2023-08-14T15:18:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Yeah in the code ComputeVariableIsotropicElasticity there is dE, d2E, dlambda, d2lambda,... etc. I was wondering where I can get some reading material on these derivatives, and how they would look for orthotropic material.\nThere is a fill method, but for Orthotropic it needs 9 input, each of which would be temperature dependent, and would be provided in a tabular format in the input file.\nThanks again,\nAritra",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-6751934",
                          "updatedAt": "2023-08-17T14:24:56Z",
                          "publishedAt": "2023-08-17T14:24:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you would need to convert the tabular form to a \"Function\" form using PiecewiseLinear function for example to capture the temperature dependence.\nThen for the coeffiicent entry, you enable Functions instead of numbers\nYou can look at ComputeVariableIsotropicElasticity for examples on receiving functions\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-6752436",
                          "updatedAt": "2023-08-17T15:08:48Z",
                          "publishedAt": "2023-08-17T15:08:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "okay, I can do that, as in input the parameters as Function. But still for the orthotropic I also need to provide the derivatives right ? Like there is dE and d2E, ... there would be similar for orthotropic where it would be dE11 dE22 dE33, dG12,....(9 terms) for each derivative ?",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-6753511",
                          "updatedAt": "2023-08-17T16:54:14Z",
                          "publishedAt": "2023-08-17T16:54:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For the derivatives you should be able to use the time derivative method of functions\nbecause the functions you are inputting are functions of temperature used as the time  variable",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-6753560",
                          "updatedAt": "2023-08-17T16:59:43Z",
                          "publishedAt": "2023-08-17T16:59:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "okay, so I don't have to write the expression for dE, d2E, but directly use the derivative method functions? In that case I will start writing a skeleton, and ask for help as I proceed through it!\nAlso, (forgive me for the stupid question), is there any code that already uses the time derivative method functions which I can look into ?\nThanks a lot!\nAritra",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-6761043",
                          "updatedAt": "2023-08-18T12:20:05Z",
                          "publishedAt": "2023-08-18T12:20:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can see in the function source files the definitions of each timeDerivative routine.\nYou can see here a use case for this routine:\nvoid\nThermalFunctionSolidProperties::rho_from_T(const Real & T, Real & rho, Real & drho_dT) const\n{\n  rho = rho_from_T(T);\n  drho_dT = _rho_function.timeDerivative(T);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-6769366",
                          "updatedAt": "2023-08-19T16:27:24Z",
                          "publishedAt": "2023-08-19T16:27:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Thanks a lot! :)",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-6780105",
                          "updatedAt": "2023-08-21T11:57:40Z",
                          "publishedAt": "2023-08-21T11:57:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "chakra34"
                  },
                  "bodyText": "Hi @GiudGiud , I finally started to code a orthotropic temperature dependent elasticity material, but am facing the following questions:\nSo I wrote the following code  ComputeVariableOrthotropicElasticityTensor.h which inherits from ComputeElasticityTensorTempl with the following header file:\n#pragma once\n\n#include \"ComputeElasticityTensor.h\"\n\n/**\n * ComputeVariableIsotropicElasticityTensor defines an elasticity tensor material for\n * isotropic materials in which the elastic constants (Young's modulus and Poisson's ratio)\n * vary as defined by material properties.\n */\ntemplate <bool is_ad>\nclass ComputeVariableOrthotropicElasticityTensorTempl : public ComputeElasticityTensorTempl<is_ad>\n{\npublic:\n  static InputParameters validParams();\n\n  ComputeVariableOrthotropicElasticityTensorTempl(const InputParameters & parameters);\n\nprotected:\n  virtual void computeQpElasticityTensor() override;\n\n  /// Value of temperature at each quadrature point\n  const VariableValue & _temperature;\n\n  /// Function input for 9 elasticity parameters required for orthotropic values\n  const Function & _E11;\n  const Function & _E22;\n  const Function & _E33;\n  \n  const Function & _G12;\n  const Function & _G23;\n  const Function & _G31;\n\n  const Function & _nu12;\n  const Function & _nu23;\n  const Function & _nu31;\n\n  /// vector to store the stiffness values\n  std::vector<Real> _ortho_stiffness_components ; \n  ///\n  RankFourTensor _ortho_Cijkl ;\n\n  using ComputeElasticityTensorTempl<is_ad>::_elasticity_tensor;\n  using ComputeElasticityTensorTempl<is_ad>::_qp;\n\n};\n\n\ntypedef ComputeVariableOrthotropicElasticityTensorTempl<false> ComputeVariableOrthotropicElasticityTensor;\ntypedef ComputeVariableOrthotropicElasticityTensorTempl<true> ADComputeVariableOrthotropicElasticityTensor;\n\n\nand the following is the source file:\n#include \"ComputeVariableOrthotropicElasticityTensor.h\"\n#include \"RotationTensor.h\"\n\nregisterMooseObject(\"TensorMechanicsApp\", ComputeVariableOrthotropicElasticityTensor);\nregisterMooseObject(\"TensorMechanicsApp\", ADComputeVariableOrthotropicElasticityTensor);\n\ntemplate <bool is_ad>\nInputParameters\nComputeVariableOrthotropicElasticityTensorTempl<is_ad>::validParams()\n{\n  InputParameters params = ComputeElasticityTensorTempl<is_ad>::validParams();\n  params.addClassDescription(\"Compute an orthotropic elasticity tensor for elastic constants that \"\n                             \"change as a function of temperature\");\n\n  params.addRequiredCoupledVar(\"temperature\", \"Coupled temperature\");\n\n  params.addRequiredParam<FunctionName>(\n      \"E11\",\n      \"Function describing the Young's modulus E11\");\n  params.addRequiredParam<FunctionName>(\n      \"E22\",\n      \"Function describing the Young's modulus E11\");\n  params.addRequiredParam<FunctionName>(\n      \"E33\",\n      \"Function describing the Young's modulus E11\");\n\n  params.addRequiredParam<FunctionName>(\n      \"G12\",\n      \"Function describing the shear modulus G12\");\n  params.addRequiredParam<FunctionName>(\n      \"G23\",\n      \"Function describing the shear modulus G23\");\n  params.addRequiredParam<FunctionName>(\n      \"G31\",\n      \"Function describing the shear modulus G31\");\n\n  params.addRequiredParam<FunctionName>(\n      \"nu12\",\n      \"Function describing the Poisson's ratio nu12\");\n  params.addRequiredParam<FunctionName>(\n      \"nu23\",\n      \"Function describing the Poisson's ratio nu23\");\n  params.addRequiredParam<FunctionName>(\n      \"nu31\",\n      \"Function describing the Poisson's ratio nu31\");\n\n  return params;\n}\n\n\ntemplate <bool is_ad>\nComputeVariableOrthotropicElasticityTensorTempl<is_ad>::ComputeVariableOrthotropicElasticityTensorTempl(\n    const InputParameters & parameters)\n  : ComputeElasticityTensorTempl<is_ad>(parameters),\n  _temperature(coupledValue(\"temperature\")),\n  _E11(this->getFunction(\"E11\")),\n  _E22(this->getFunction(\"E22\")),\n  _E33(this->getFunction(\"E33\")),\n  _G12(this->getFunction(\"G12\")),\n  _G23(this->getFunction(\"G23\")),\n  _G31(this->getFunction(\"G31\")),\n  _nu12(this->getFunction(\"nu12\")),\n  _nu23(this->getFunction(\"nu23\")),\n  _nu31(this->getFunction(\"nu31\"))\n{ \n}\n\ntemplate <bool is_ad>\nvoid\nComputeVariableOrthotropicElasticityTensorTempl<is_ad>::computeQpElasticityTensor()\n{\n  // Get the stiffness values for the current temperature\n  const auto current_qp_temperature = 100.0;  //_temperature[_qp].value();\n  _ortho_stiffness_components[0] = _E11.value(current_qp_temperature);\n  _ortho_stiffness_components[1] = _E22.value(current_qp_temperature);\n  _ortho_stiffness_components[2] = _E33.value(current_qp_temperature);\n\n  _ortho_stiffness_components[3] = _G12.value(current_qp_temperature);\n  _ortho_stiffness_components[4] = _G23.value(current_qp_temperature);\n  _ortho_stiffness_components[5] = _G31.value(current_qp_temperature);\n\n  _ortho_stiffness_components[6] = _nu12.value(current_qp_temperature);\n  _ortho_stiffness_components[7] = _nu23.value(current_qp_temperature);\n  _ortho_stiffness_components[8] = _nu31.value(current_qp_temperature);\n\n  // _nu21 = _nu12 * (_E22/_E11) ; \n  // _nu32 = _nu23 * (_E33/_E22) ; \n  // _nu13 = _nu31 * (_E11/_E33) ; \n\n  _ortho_stiffness_components[9]  = _nu12.value(current_qp_temperature) * \n                                    (_E22.value(current_qp_temperature)/ _E11.value(current_qp_temperature));\n  _ortho_stiffness_components[10] = _nu23.value(current_qp_temperature) * \n                                    (_E33.value(current_qp_temperature)/ _E22.value(current_qp_temperature));\n  _ortho_stiffness_components[11] = _nu31.value(current_qp_temperature) * \n                                    (_E11.value(current_qp_temperature)/ _E33.value(current_qp_temperature));\n\n\n  _ortho_Cijkl.fillGeneralOrthotropicFromInputVector(_ortho_stiffness_components);\n\n  // Assign elasticity tensor at a given quad point\n  _elasticity_tensor[_qp] = _ortho_Cijkl;\n\n}\n\n\nFor the above code I get compiler errors:\n--  with regards to adding the coupled variable _temperature\nerror: there are no arguments to \\u2018coupledValue\\u2019 that depend on a template parameter, so a declaration of \\u2018coupledValue\\u2019 must be available [-fpermissive]\n   64 |  _temperature(coupledValue(\"temperature\"))\n\n\nwhich probably indicates that I don't have a material property, in that case how do I access the local temperature at each _qp\n--- with regard to  void fillGeneralOrthotropicFromInputVector(const std::vector<T> & input); it gives the following error:\nerror: \\u2018void RankFourTensorTempl< <template-parameter-1-1> >::fillGeneralOrthotropicFromInputVector(const std::vector<T>&) [with T = double]\\u2019 is protected within this context\n  107 |   _ortho_Cijkl.fillGeneralOrthotropicFromInputVector(_ortho_stiffness_components);\n\n\nbut my definition of _ortho_stiffness_components is a  std::vector<Real>, and it is in protected, so I don't understand the error :(\n--- A basic question, if I have to declare a general vector with a certain size how do I do that in Moose header file ? Right now as you can see the _ortho_stiffness_components vector is not defined with a certain size, I tried  std::vector<double> _ortho_stiffness_components(12); and it gave an error :(\n--- Lastly, I haven't put the derivatives here, but I guess I would need to have _dstiffness which would be the _E11.timeDerivative(), _E22.timeDerivative(), ...\nApologies for such long comment, but I have been trying to figure out the issue for some time, and am currently unable to do it.\nThanks again,\nAritra",
                  "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-7213277",
                  "updatedAt": "2023-10-06T20:18:40Z",
                  "publishedAt": "2023-10-06T20:18:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The first one is because your class is a template\ninstead of\n_temperature(coupledValue(\"temperature\"))\n\nit should be\n_temperature(this->coupledValue(\"temperature\"))\n\nit s a C++ thing, the templating is pretty unintuitive\nFor the 3rd thing, the vector is already declared in your header, so it s a member of the class. You dont need to re-declare it.\nJust resize it:\n_ortho_stiffness_components.resize(12);\n\nthen fill it\n_E11 is a function so you can indeed call .timeDerivative() and it will give you the derivative with regards to whatever you are using in lieu of time when calling the function",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-7213381",
                          "updatedAt": "2023-10-06T20:32:04Z",
                          "publishedAt": "2023-10-06T20:32:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Thanks a lot @GiudGiud ! definitely resolved the compilation issues. The following code compiles (Please have a look if you get a chance):\n#include \"ComputeVariableOrthotropicElasticityTensor.h\"\n#include \"RotationTensor.h\"\n\nregisterMooseObject(\"TensorMechanicsApp\", ComputeVariableOrthotropicElasticityTensor);\nregisterMooseObject(\"TensorMechanicsApp\", ADComputeVariableOrthotropicElasticityTensor);\n\ntemplate <bool is_ad>\nInputParameters\nComputeVariableOrthotropicElasticityTensorTempl<is_ad>::validParams()\n{\n  InputParameters params = ComputeElasticityTensorTempl<is_ad>::validParams();\n  params.addClassDescription(\"Compute an orthotropic elasticity tensor for elastic constants that \"\n                             \"change as a function of temperature\");\n\n  params.addRequiredCoupledVar(\"temperature\", \"Coupled temperature\");\n\n  params.addRequiredParam<FunctionName>(\n      \"E11\",\n      \"Function describing the Young's modulus E11\");\n  params.addRequiredParam<FunctionName>(\n      \"E22\",\n      \"Function describing the Young's modulus E11\");\n  params.addRequiredParam<FunctionName>(\n      \"E33\",\n      \"Function describing the Young's modulus E11\");\n\n  params.addRequiredParam<FunctionName>(\n      \"G12\",\n      \"Function describing the shear modulus G12\");\n  params.addRequiredParam<FunctionName>(\n      \"G23\",\n      \"Function describing the shear modulus G23\");\n  params.addRequiredParam<FunctionName>(\n      \"G31\",\n      \"Function describing the shear modulus G31\");\n\n  params.addRequiredParam<FunctionName>(\n      \"nu12\",\n      \"Function describing the Poisson's ratio nu12\");\n  params.addRequiredParam<FunctionName>(\n      \"nu23\",\n      \"Function describing the Poisson's ratio nu23\");\n  params.addRequiredParam<FunctionName>(\n      \"nu31\",\n      \"Function describing the Poisson's ratio nu31\");\n\n  return params;\n}\n\n\ntemplate <bool is_ad>\nComputeVariableOrthotropicElasticityTensorTempl<is_ad>::ComputeVariableOrthotropicElasticityTensorTempl(\n    const InputParameters & parameters)\n  : ComputeElasticityTensorTempl<is_ad>(parameters),\n _temperature(this->coupledValue(\"temperature\")),\n  _E11(this->getFunction(\"E11\")),\n  _E22(this->getFunction(\"E22\")),\n  _E33(this->getFunction(\"E33\")),\n  _G12(this->getFunction(\"G12\")),\n  _G23(this->getFunction(\"G23\")),\n  _G31(this->getFunction(\"G31\")),\n  _nu12(this->getFunction(\"nu12\")),\n  _nu23(this->getFunction(\"nu23\")),\n  _nu31(this->getFunction(\"nu31\"))\n{ \n}\n\ntemplate <bool is_ad>\nvoid\nComputeVariableOrthotropicElasticityTensorTempl<is_ad>::computeQpElasticityTensor()\n{\n  // Get the stiffness values for the current temperature\n  const auto current_qp_temperature = _temperature[_qp];\n  _ortho_stiffness_components.resize(12);\n  _ortho_stiffness_components = {0.0} ;\n\n  _ortho_stiffness_components[0] = _E11.value(current_qp_temperature);\n  _ortho_stiffness_components[1] = _E22.value(current_qp_temperature);\n  _ortho_stiffness_components[2] = _E33.value(current_qp_temperature);\n\n  _ortho_stiffness_components[3] = _G12.value(current_qp_temperature);\n  _ortho_stiffness_components[4] = _G23.value(current_qp_temperature);\n  _ortho_stiffness_components[5] = _G31.value(current_qp_temperature);\n\n  _ortho_stiffness_components[6] = _nu12.value(current_qp_temperature);\n  _ortho_stiffness_components[7] = _nu23.value(current_qp_temperature);\n  _ortho_stiffness_components[8] = _nu31.value(current_qp_temperature);\n\n  // _nu21 = _nu12 * (_E22/_E11) ; \n  // _nu32 = _nu23 * (_E33/_E22) ; \n  // _nu13 = _nu31 * (_E11/_E33) ; \n\n  _ortho_stiffness_components[9]  = _nu12.value(current_qp_temperature) * \n                                    (_E22.value(current_qp_temperature)/ _E11.value(current_qp_temperature));\n  _ortho_stiffness_components[10] = _nu23.value(current_qp_temperature) * \n                                    (_E33.value(current_qp_temperature)/ _E22.value(current_qp_temperature));\n  _ortho_stiffness_components[11] = _nu31.value(current_qp_temperature) * \n                                    (_E11.value(current_qp_temperature)/ _E33.value(current_qp_temperature));\n\n\n _ortho_Cijkl.zero();\n _ortho_Cijkl.fillFromInputVector(_ortho_stiffness_components, RankFourTensor:: orthotropic);\n\n  // Assign elasticity tensor at a given quad point\n  _elasticity_tensor[_qp] = _ortho_Cijkl;\n\n}\n\ntemplate class ComputeVariableOrthotropicElasticityTensorTempl<false>;\ntemplate class ComputeVariableOrthotropicElasticityTensorTempl<true>;\n\nAlso, a final question regarding the derivative, so if I have only temperature dependence, then I populate the std::vector<MaterialProperty<RankFourTensor> *> _delasticity_tensor , but where is it being used ? Do I have to modify some other code/source file, or just populating the _delasticity_tensor in the current file should be enough ?\nAgain, thank you so much for the huge help!\n-Aritra",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-7225021",
                          "updatedAt": "2023-10-09T12:46:52Z",
                          "publishedAt": "2023-10-08T21:17:16Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Also what is _effective_stiffness[_qp] do I need to populate that as well ?",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-7230643",
                          "updatedAt": "2023-10-09T13:43:06Z",
                          "publishedAt": "2023-10-09T13:43:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm not that familiar with that part of the code.\nI would expect you dont need to fill _delasticity_tensor  if you use automatic differentiation but you ll have to check",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-7230961",
                          "updatedAt": "2023-10-09T14:11:42Z",
                          "publishedAt": "2023-10-09T14:11:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Thank you so much @GiudGiud , I have added the derivatives following similar to \"ComputeConcentrationDependentElasticity\". It compiles and now I am going to test it out.\nThanks again, so much for all the help!!\n-Aritra",
                          "url": "https://github.com/idaholab/moose/discussions/25194#discussioncomment-7231669",
                          "updatedAt": "2023-10-09T15:14:44Z",
                          "publishedAt": "2023-10-09T15:14:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "cannot open source file \"MooseApp.h\"",
          "author": {
            "login": "nan-f"
          },
          "bodyText": "Hi all,\nI already had MOOSE on my system,and I try to write code on vscode. but I can\u2019t find source file \"MooseApp.h\".\nThis is my setting.json:\n{\n    \"[cpp]\": {\n        \"editor.defaultFormatter\": \"ms-vscode.cpptools\"\n    },\n    \"telemetry.telemetryLevel\": \"off\",\n    \"C_Cpp.default.cppStandard\": \"c++17\",\n    \"C_Cpp.default.includePath\": [\n        \"${workspaceFolder}/**\",\n        \"/home/fangn/mambaforge3/envs/moose/**\",\n        \"/usr/include/**\"\n    ],\n    \"files.associations\": {\n        \"*.C\": \"cpp\",\n        \"*.h\": \"cpp\"\n    },\n    \"files.trimTrailingWhitespace\": true,\n    \"editor.tabSize\": 2,\n    \"editor.formatOnSave\": true,\n    \"files.insertFinalNewline\": true\n}",
          "url": "https://github.com/idaholab/moose/discussions/25684",
          "updatedAt": "2023-10-09T03:11:29Z",
          "publishedAt": "2023-10-08T07:48:24Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI just tried with your settings and it works fine. Ctrl + P will still find MooseApp.h\nAre you getting a compiling error? This would not be related to your vscode settings\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25684#discussioncomment-7224129",
                  "updatedAt": "2023-10-08T17:44:09Z",
                  "publishedAt": "2023-10-08T17:44:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "nan-f"
                          },
                          "bodyText": "I try to change my  .vscode/c_cpp_properties.json as  #18307 say, and then I can find MooseApp.h. \ud83d\ude04",
                          "url": "https://github.com/idaholab/moose/discussions/25684#discussioncomment-7226279",
                          "updatedAt": "2023-10-09T03:11:30Z",
                          "publishedAt": "2023-10-09T03:11:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Electrostatic Shielding Model",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "Hi\nI am trying to model electric field shielding for a 2d domain as follow:\nInitially the electric field E along x axis is a continuous variable and identical along y-axis (due to symmetry).\nHowever, a material property c(x,y,t) is used for executing shielding condition.\nSo whenever c(x0,y0,t0) > c_cutoff for x incrementing from x=0 to x = L (right boundary)\nI want to execute E_new = E for x<=x0;\nand,                      E_new = func(c(x0,y0,t0) ) for x>x0; irrespective of any other value of c along x.\nFurther I will be adding some smooth transitions for E.\nHere E is a moose variable.\nIn simple words for moving from x= 0 to x = xmax if we encounter c(x=x0)>c_cuttoff I want to define a unit function U(x-x0) irrespective of any other value of c(x>x0).\nI am unable to find a way to execute this in moose.\nPlease help.\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/25677",
          "updatedAt": "2023-10-06T20:15:15Z",
          "publishedAt": "2023-10-06T13:40:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo E is the variable that you are solving the equations for right?\nWe call this the 'nonlinear' variable.\nThere is no way to set a nonlinear variable, you can only solve equations to compute them.\nSo instead I suggest you make the terms of your equations dependent on c.\nfor example:\nsomekernel::computeQpResidual()\n{\n  if (c[_qp] < c_cutoff)\n    normal term for the equation\n  else\n    different term that gets the value you want for E\n}\n\nalternatively, you can use the Control system to change between sets of kernels based on a criterion.\nhttps://mooseframework.inl.gov/syntax/Controls/index.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25677#discussioncomment-7210346",
                  "updatedAt": "2023-10-06T14:29:46Z",
                  "publishedAt": "2023-10-06T14:29:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Yes, but its not just c[_qp] >= c_cutoff for the else case, rather its like a trigger. So as soon as c[qp]> c_cutoff, the else condition should always be true along the x axis for particular y. Will this code work in that case.\nThanks",
                          "url": "https://github.com/idaholab/moose/discussions/25677#discussioncomment-7210567",
                          "updatedAt": "2023-10-06T14:53:25Z",
                          "publishedAt": "2023-10-06T14:53:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "then you can keep a boolean called trigger in the kernel attributed\nIf the trigger happens, then set that boolean\nand decide the term based on that boolean\nThe Controls system also handles triggers / persistent and non-persistent conditions",
                          "url": "https://github.com/idaholab/moose/discussions/25677#discussioncomment-7210746",
                          "updatedAt": "2023-10-06T15:09:40Z",
                          "publishedAt": "2023-10-06T15:09:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Couple of more thing\n\nhow to reset the boolean once x=xmax for qp?\nWhat is the order if loop will begin qp with? I mean is it like first for y0 it will go for all x0 to x1 and so on upto xn. Then shift to y1 and so on to yn for a 2 D system.",
                          "url": "https://github.com/idaholab/moose/discussions/25677#discussioncomment-7211062",
                          "updatedAt": "2023-10-06T16:06:53Z",
                          "publishedAt": "2023-10-06T15:42:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is this a different condition for every qp?\nif so a boolean on a per-kernel basis wont work btw. You ll need to create a field of booleans, either with an auxvariable and an auxkernel, or with material properties\nyou can have another if condition:\nif (boolean and x > xmax)\n  boolean = false",
                          "url": "https://github.com/idaholab/moose/discussions/25677#discussioncomment-7211220",
                          "updatedAt": "2023-10-06T15:57:31Z",
                          "publishedAt": "2023-10-06T15:57:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "is this a different condition for every qp?\n\nThe condition is same but once it is executed for all {x0,x1,x2.....xn} at y0. It needs to be reset and check again for the same condition to be true for y1 and .... .\nMy query is as every element has two qp. So will it begin with element 1 of y and look for the condition for x elements (starting from x1 to xn) to be true. Then reset the boolean at x=xmax. And then move to element 2 of y and repeat for all x elements.",
                          "url": "https://github.com/idaholab/moose/discussions/25677#discussioncomment-7211692",
                          "updatedAt": "2023-10-06T16:49:19Z",
                          "publishedAt": "2023-10-06T16:48:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So there's a grid of elements? in X and Y?\nWe have layered user objects that can examine groups of elements in layers with an origin and an axis for layering",
                          "url": "https://github.com/idaholab/moose/discussions/25677#discussioncomment-7212328",
                          "updatedAt": "2023-10-06T18:04:50Z",
                          "publishedAt": "2023-10-06T18:04:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Yes I am using GeneratedMesh with nx and ny equal to 100.\nCan't I just define a generic functor material that gives me a unit signal U(x-x0) if c(x0)>0. And then simply multiply it on my kernel.\nElse, I will have to do it your way.\nThanks",
                          "url": "https://github.com/idaholab/moose/discussions/25677#discussioncomment-7213204",
                          "updatedAt": "2023-10-06T20:10:23Z",
                          "publishedAt": "2023-10-06T20:10:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you want to examine more than 1 element to make a decision on the value, you need something that works with layers\nIf you can decide based on the local value of c on one element, then yes, please go ahead and write an auxkernel or material property for the cirterion",
                          "url": "https://github.com/idaholab/moose/discussions/25677#discussioncomment-7213246",
                          "updatedAt": "2023-10-06T20:15:16Z",
                          "publishedAt": "2023-10-06T20:15:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}