{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMi0xNlQxNTo1Nzo0My0wNzowMM4AWwdU"
    },
    "edges": [
      {
        "node": {
          "title": "Importing a constant number (maybe via ConstantFunction) to damage dependent perm (K) calculation",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nso here is my current version of PorousFlowPermeabilityConstCSV is a bit messy and have constant numbers (1e-13 1e-15 etc) which I have to update every time when I work on different projects.\nis there a way that I can define those number in the input file and call those numbers in my PorousFlowPermeabilityConstCSV?\nI see that ConstantFunction allows me to define a constant number, but how to I take the value from there to my perm calculation?\nPlease help if you have any idea\nThank you!\nTraiwit\n@GiudGiud @cpgr tagging you guys, coz you guys are very good at this.\nPorousFlowPermeabilityConstCSV::PorousFlowPermeabilityConstCSV(const InputParameters & parameters)\n  : PorousFlowPermeabilityBase(parameters), _damage(getMaterialProperty<Real>(\"damage\")),\n  _read_prop_user_object(isParamValid(\"read_prop_user_object\")\n                             ? &getUserObject<ElementPropertyReadFile>(\"read_prop_user_object\")\n                             : nullptr),\n  _mat_prop(declareProperty<RealVectorValue>(\"perm\")),\n  _RMD(declareProperty<RealVectorValue>(\"RMD\")),\n  _kmax(declareProperty<RealVectorValue>(\"kmax\")),\n  _perm(declareProperty<RealVectorValue>(\"perm_tensor\")),\n  _flag(getMaterialProperty<Real>(\"flag\"))\n{\n\n\nPorousFlowPermeabilityConstCSV::computeQpProperties()\n{\n\n \n  //  read values from .CSV file\n    _mat_prop[_qp](0) = _read_prop_user_object->getData(_current_elem, 0);\n    _mat_prop[_qp](1) = _read_prop_user_object->getData(_current_elem, 1);\n    _mat_prop[_qp](2) = _read_prop_user_object->getData(_current_elem, 2);\n    _RMD[_qp](0) = _read_prop_user_object->getData(_current_elem, 6);\n    _kmax[_qp](0)    = _read_prop_user_object->getData(_current_elem, 7);\n    // // calculate perm tensor\n\n        if (_damage[_qp] >= 3 ) { // backfill  \n        _perm[_qp](0) =  1e-15; \n        _perm[_qp](1) =  1e-15; \n        _perm[_qp](2) =  1e-15; \n\n       }\n\n        else if (_damage[_qp] >= 2 && _damage[_qp] < 3 ) {  // CAVE \n\n        _perm[_qp](0) =  1e-13; \n        _perm[_qp](1) =  1e-13; \n        _perm[_qp](2) =  1e-13; \n\n       }\n\n    else {\n\n    _perm[_qp](0) = std::min(exp(_damage[_qp]*(1/(_RMD[_qp](0))*log(_kmax[_qp](0)/_mat_prop[_qp](0))))*_mat_prop[_qp](0)*1e-7, _kmax[_qp](0)*1e-7); \n    _perm[_qp](1) = std::min(exp(_damage[_qp]*(1/(_RMD[_qp](0))*log(_kmax[_qp](0)/_mat_prop[_qp](1))))*_mat_prop[_qp](1)*1e-7, _kmax[_qp](0)*1e-7); \n    _perm[_qp](2) = std::min(exp(_damage[_qp]*(1/(_RMD[_qp](0))*log(_kmax[_qp](0)/_mat_prop[_qp](2))))*_mat_prop[_qp](2)*1e-7, _kmax[_qp](0)*1e-7); \n\n       }",
          "url": "https://github.com/idaholab/moose/discussions/26366",
          "updatedAt": "2023-12-19T02:04:57Z",
          "publishedAt": "2023-12-19T00:30:59Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "Have you tried adding these as parameters? Something like (I'm just guessing names for these, you probably have better ones you could use)\nparams.addParam<Real>(\"perm_backfill\", 1e-15, \"Permeability for backfill (default 1e-15)\");\nparams.addParam<Real>(\"perm_cave\", 1e-13, \"Permeability for cave (default 1e-13)\");\n\nin validParams(), then\n_perm_backfill(getParam<Real>(\"perm_backfill\")\n\netc in the constructor, then\nif (_damage[_qp] >= 3 ) { // backfill  \n        _perm[_qp](0) =  _perm_backfill; \n        _perm[_qp](1) =   _perm_backfill; \n        _perm[_qp](2) =   _perm_backfill; \n\n       }\n\netc",
                  "url": "https://github.com/idaholab/moose/discussions/26366#discussioncomment-7892322",
                  "updatedAt": "2023-12-19T01:42:46Z",
                  "publishedAt": "2023-12-19T01:42:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "omg I feel so stupid after reading your comment\nThank you very much @cpgr",
                          "url": "https://github.com/idaholab/moose/discussions/26366#discussioncomment-7892408",
                          "updatedAt": "2023-12-19T02:04:54Z",
                          "publishedAt": "2023-12-19T02:04:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow residual format",
          "author": {
            "login": "Bearunner"
          },
          "bodyText": "1",
          "url": "https://github.com/idaholab/moose/discussions/26334",
          "updatedAt": "2024-01-30T23:47:16Z",
          "publishedAt": "2023-12-14T11:11:03Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "The multiphase Darcy kernel (and all kernels derived from that) implement node-based upwinding, see https://mooseframework.inl.gov/modules/porous_flow/stabilization.html for lots of information. So there is lots of nodenum or _i instead of _qp in these kernels.",
                  "url": "https://github.com/idaholab/moose/discussions/26334#discussioncomment-7857728",
                  "updatedAt": "2023-12-14T20:53:07Z",
                  "publishedAt": "2023-12-14T20:53:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "So there are two ways to write residuals: one is based on  [_qp] (e.g., [PorousFlowHeatConduction.C]), and another one is node number upwinding (e.g.,  PorousFlowHeatAdvection.C ) without using [_qp]?\nWhat I know is that the integration of the quadrant points is very important in the finite element method.\nWhat you mean here is that the [_qp] in the residual can be replaced by the node number based on upwinding, right?",
                          "url": "https://github.com/idaholab/moose/discussions/26334#discussioncomment-7857859",
                          "updatedAt": "2023-12-14T21:08:26Z",
                          "publishedAt": "2023-12-14T21:08:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "If you look through that documentation, you see we lump mass to the nodes in the time derivative kernels, and therefore use the nodal fluxes in the advection kernels. There are benefits and also drawbacks as discussed - the important point is that we are consistent in how we do this.\nDiffusion kernels and the like don't need this, so they are just formulated like normal using the quadrature points.",
                          "url": "https://github.com/idaholab/moose/discussions/26334#discussioncomment-7858006",
                          "updatedAt": "2023-12-14T21:28:46Z",
                          "publishedAt": "2023-12-14T21:28:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "Thanks for your explanation.\n\n\nAccording to what you said, my understanding is that one variable or property can have two formats in kernels depending on how we want to use them: one is node value and another is qp value\uff0c am I right?\n\n\nOn line 94 in PorousFlowDarcyBase.C\nReal\nPorousFlowDarcyBase::darcyQp(unsigned int ph) const\n{\nreturn _grad_test[_i][_qp] *\n(_permeability[_qp] * (_grad_p[_qp][ph] - _fluid_density_qp[_qp][ph] * _gravity));\n}\n\n\nWhy do we use qp value to calculate darcyQp, not node value as the mobility in this kernel? Can I also just\nuse node value for Darcy velocity calculation?\nReal\nPorousFlowDarcyBase::mobility(unsigned nodenum, unsigned phase) const\n{\nreturn _fluid_density_node[nodenum][phase] / _fluid_viscosity[nodenum][phase];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/26334#discussioncomment-7858272",
                          "updatedAt": "2023-12-14T22:06:15Z",
                          "publishedAt": "2023-12-14T22:05:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "If I remember correctly, it is because the gradient of a variable (pressure) only exists at the qps, not the nodes",
                          "url": "https://github.com/idaholab/moose/discussions/26334#discussioncomment-7890850",
                          "updatedAt": "2023-12-18T21:04:42Z",
                          "publishedAt": "2023-12-18T21:04:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "INS AD/nonAD version",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nI'm trying to \"upgrade\" a NS INS example to its AD version (see whether this could speed up the solver). I (think I) put almost all things together, though I am stuck with a BC. The problem is that I need to impose a MatchValueBC along a specific boundary (whose values I take from an auxVariable - lagrange), and I'm not sure how to make it working while having the velocity as a lagrange vector variable. I tried to have a lagrange auxvariable (with 3 components) and make use of the BuildArrayVariable, but it is not compatible with lagrange_vec type. This said, before looking at a solution on my own, I though it wise to ask the forum...\nI am attaching my two input files (sorry if this violates the posting rules), for anyone who could help.\nThanks a lot\nfracture_flow.zip",
          "url": "https://github.com/idaholab/moose/discussions/26316",
          "updatedAt": "2023-12-18T19:50:01Z",
          "publishedAt": "2023-12-13T08:10:52Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you need a VectorMatchedValueBC?\nOr do you need a way to create a vector variable, to then use it in a VectorMatchedValueBC?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26316#discussioncomment-7845135",
                  "updatedAt": "2023-12-13T17:11:23Z",
                  "publishedAt": "2023-12-13T17:11:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "In principle a way to create a VectorVariable (same as per the velocity - Lagrange_vec) to use in a VectorMatchedValueBC",
                  "url": "https://github.com/idaholab/moose/discussions/26316#discussioncomment-7845656",
                  "updatedAt": "2023-12-13T18:04:28Z",
                  "publishedAt": "2023-12-13T18:04:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Does the ParsedVectorAux let you do that ?\nOr is it restricted to non nodal variables as well",
                          "url": "https://github.com/idaholab/moose/discussions/26316#discussioncomment-7845691",
                          "updatedAt": "2023-12-13T18:08:31Z",
                          "publishedAt": "2023-12-13T18:08:31Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "I can give it a try (guess I can move the auxvariables to nodes). Will report back tomorrow once in the office.\nThanks again",
                          "url": "https://github.com/idaholab/moose/discussions/26316#discussioncomment-7845729",
                          "updatedAt": "2023-12-13T18:12:18Z",
                          "publishedAt": "2023-12-13T18:12:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "sounds good. Thanks for engaging on this\nBuildArrayVariable is for array variables but maybe we need to add a BuildVectorVariable to make it clear what we're doing with vector variables",
                          "url": "https://github.com/idaholab/moose/discussions/26316#discussioncomment-7845816",
                          "updatedAt": "2023-12-13T18:21:04Z",
                          "publishedAt": "2023-12-13T18:21:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@GiudGiud your hints did work indeed! Thanks a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/26316#discussioncomment-7850695",
                          "updatedAt": "2023-12-14T07:58:50Z",
                          "publishedAt": "2023-12-14T07:58:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "Of course, the vector variable should be populated from existing lagrangian variables.\nThanks",
                  "url": "https://github.com/idaholab/moose/discussions/26316#discussioncomment-7845667",
                  "updatedAt": "2023-12-13T18:05:35Z",
                  "publishedAt": "2023-12-13T18:05:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I'm trying to \"upgrade\" a NS INS example to its AD version (see whether this could speed up the solver)\n\nIf you're referring to the INS vs INSAD prefixed objects in the navier_stokes module you're unlikely to see better solver performance with INSAD unless you're running on displacing meshes. We worked pretty hard to get the Jacobians correct for the INS objects",
                  "url": "https://github.com/idaholab/moose/discussions/26316#discussioncomment-7858839",
                  "updatedAt": "2023-12-14T23:49:57Z",
                  "publishedAt": "2023-12-14T23:49:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "I see, indeed we are running on a displaced mesh. And, just tested it, did not provide any speed up wrt the INS formulation, so in the end I will stay with the non AD version. Thanks anyway for the support.",
                          "url": "https://github.com/idaholab/moose/discussions/26316#discussioncomment-7862863",
                          "updatedAt": "2023-12-15T11:11:25Z",
                          "publishedAt": "2023-12-15T11:11:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Are you using PJFNK or NEWTON?",
                          "url": "https://github.com/idaholab/moose/discussions/26316#discussioncomment-7890341",
                          "updatedAt": "2023-12-18T19:50:02Z",
                          "publishedAt": "2023-12-18T19:50:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Contact modulue changes",
          "author": {
            "login": "srinath-chakravarthy"
          },
          "bodyText": "Hello all,\nIts been several months since i updated moose and my current input file for using contact is\n[./normal_lm]\ntype = NormalNodalLMMechanicalContact\nslave = 15\nmaster = 16\nvariable = normal_lm\nmaster_variable = ux\nnormal_smoothing_distance = 0.2\ndisp_y = uy\nncp_function_type = min\ntangential_tolerance = 0.2\nc = 1e-3\n# c = 1e-3\n# extra_vector_tags = 'ref'\n# c = 1e3\n# ncp_function_type = min\n# order = FIRST\n# tangential_tolerance = 0.1\n[../]\n[./normal_x]\ntype = NormalMortarMechanicalContact\nmaster_boundary = 16\nslave_boundary = 15\nmaster_subdomain = 4\nslave_subdomain = 3\nvariable = normal_lm\nslave_variable = ux\ncomponent = x\nuse_displaced_mesh = true\ncompute_lm_residuals = false\n# extra_vector_tags = 'ref'\n[../]\n[./normal_y]\ntype = NormalMortarMechanicalContact\nmaster_boundary = 16\nslave_boundary = 15\nmaster_subdomain = 4\nslave_subdomain = 3\nvariable = normal_lm\nslave_variable = uy\ncomponent = y\nuse_displaced_mesh = true\ncompute_lm_residuals = false\n# extra_vector_tags = 'ref'\n[../]\nCan anyone comment on how this has changed...\nCheers\nSrinath",
          "url": "https://github.com/idaholab/moose/discussions/26360",
          "updatedAt": "2023-12-18T19:49:46Z",
          "publishedAt": "2023-12-18T15:44:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you hitting an error? Are the results different now?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26360#discussioncomment-7888181",
                  "updatedAt": "2023-12-18T16:03:41Z",
                  "publishedAt": "2023-12-18T16:03:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "i am getting an error\n*** ERROR ***\nA 'NormalNodalLMMechanicalContact' is not a registered object.\nIf you are trying to find this object in a dynamically loaded library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.",
                  "url": "https://github.com/idaholab/moose/discussions/26360#discussioncomment-7888236",
                  "updatedAt": "2023-12-18T16:09:46Z",
                  "publishedAt": "2023-12-18T16:09:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "PS i updated moose recently and have adapted all custom kernels, materials etc so my code compiles and passes all local tests, but this was an object that used to be present in framework/contact module... looks like its been renamed",
                  "url": "https://github.com/idaholab/moose/discussions/26360#discussioncomment-7888251",
                  "updatedAt": "2023-12-18T16:11:03Z",
                  "publishedAt": "2023-12-18T16:11:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you look at the index in the contact module page on the framework website can you find the new name?\n@recuero otherwise will know",
                          "url": "https://github.com/idaholab/moose/discussions/26360#discussioncomment-7889375",
                          "updatedAt": "2023-12-18T18:06:52Z",
                          "publishedAt": "2023-12-18T18:06:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "That object was removed a while ago (maybe a year ago?) because we replaced the existing mortar constraints with a new formulation. If you look at the constraint folder of the contact module, you'll see similar object names without the \"Nodal\" string that can be used to apply surface traction on the boundaries.\nDo you need to use a traction-applying  object like that or the contact action would be sufficient for your application?",
                          "url": "https://github.com/idaholab/moose/discussions/26360#discussioncomment-7890008",
                          "updatedAt": "2023-12-18T19:13:27Z",
                          "publishedAt": "2023-12-18T19:13:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "Thanks for the response. I have several other constraint objects for custom mortar constraints i have written, for which the contact action is not exactly convenient. This type of explicit enumeration of objects is a little easier for initial proof-of-concept phase. I plan to eventually add to contact action later on.\nSo the new structure will involve some kind of user object and one of the ComputeWeightedGap constraints right ?",
                  "url": "https://github.com/idaholab/moose/discussions/26360#discussioncomment-7890124",
                  "updatedAt": "2023-12-18T19:23:42Z",
                  "publishedAt": "2023-12-18T19:23:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Yes, you can use the user object design to develop your own mortar constraints. Then separate constraint objects are used to 1) Enforce the constraints and 2) Apply the surface tractions.\nIf you already have mortar constraint objects with weighted quantities, you might only need to apply the resulting traction.",
                          "url": "https://github.com/idaholab/moose/discussions/26360#discussioncomment-7890320",
                          "updatedAt": "2023-12-18T19:47:23Z",
                          "publishedAt": "2023-12-18T19:47:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "The idea is that the user object computes quantities over the mortar segment mesh that are then used to impose the constraints, either as penalty or with Lagrange multipliers.",
                          "url": "https://github.com/idaholab/moose/discussions/26360#discussioncomment-7890339",
                          "updatedAt": "2023-12-18T19:49:46Z",
                          "publishedAt": "2023-12-18T19:49:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "libmesh installation error for BISON",
          "author": {
            "login": "aahalimi"
          },
          "bodyText": "Hello,\nI have been having problems with BISON installation on my HPC session. In particular, compiling libmesh generates the following error:\n\u2026.\n../../include/enums/enum_eigen_solver_type.h ../../include/enums/enum_elem_quality.h ../../include/enums/enum_elem_type.h ../../include/enums/enum_error_estimator_type.h ../../include/enums/enum_fe_family.h ../../include/enums/enum_inf_map_type.h ../../include/enums/enum_io_package.h ../../include/enums/enum_matrix_build_type.h ../../include/enums/enum_norm_type.h ../../include/enums/enum_order.h ../../include/enums/enum_parallel_type.h '/apps/herd/bison/bison-2023-11-30/libmesh/include/libmesh'\ncp: cannot create regular file '/apps/herd/bison/bison-2023-11-30/libmesh/include/libmesh/inst.75162': Permission denied\nmake[3]: *** [Makefile:1161: install-includeHEADERS] Error 1\nmake[3]: Leaving directory '/home/haliassi/workspace/bison/moose/libmesh/build/include'\nmake[2]: *** [Makefile:1354: install-am] Error 2\nmake[2]: Leaving directory '/home/haliassi/workspace/bison/moose/libmesh/build/include'\nmake[1]: *** [Makefile:1188: install-recursive] Error 1\nmake[1]: Leaving directory '/home/haliassi/workspace/bison/moose/libmesh/build/include'\nmake: *** [Makefile:33431: install-recursive] Error 1\nCan you help me figure out what is the root of such error?\nThanks,\nAssil",
          "url": "https://github.com/idaholab/moose/discussions/26361",
          "updatedAt": "2023-12-18T16:55:06Z",
          "publishedAt": "2023-12-16T13:32:02Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "Converting this to a discussion, as it is not an issue that can be fixed within the MOOSE repository.\nThe following path:\n/apps/herd/bison/bison-2023-11-30\nIndicates you are attempting to use the pre-compiled version of Bison. That said, there is no reason for you to try and build libMesh.\nIf you are indeed trying to use your own version of Bison, you must refrain from loading the bison module. And instead load the modules that were used to create Bison instead:\nmodule purge\nmodule load use.moose moose-dev\nAfter doing the above, it will be necessary to clean out your previous build, as some pieces of it, will not doubt still be linked to the pre-compiled version. Take care with the following commands. They will delete and non-tracked files you may be working on:\ncd workspace/bison\ngit clean -xfd\ngit submodule foreach --recursive git clean -xfd\nNext, it will be necessary to build PETSc and libMesh, and then Bison:\ncd moose\nexport MOOSE_JOBS=6 METHODS=opt METHOD=opt\nscripts/update_and_rebuild_petsc.sh\nscripts/update_and_rebuild_libmesh.sh\nscripts/update_and_rebuild_wasp.sh\ncd ../\nmake -j $MOOSE_JOBS",
                  "url": "https://github.com/idaholab/moose/discussions/26361#discussioncomment-7888706",
                  "updatedAt": "2023-12-18T16:55:08Z",
                  "publishedAt": "2023-12-18T16:55:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Transfer] How to correspondingly tranfer variables between apps?",
          "author": {
            "login": "Bearunner"
          },
          "bodyText": "1",
          "url": "https://github.com/idaholab/moose/discussions/26211",
          "updatedAt": "2023-12-18T14:15:57Z",
          "publishedAt": "2023-11-30T17:44:34Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDepends on the algorithm you want to use to select a value\nI would recommend this one:\nhttps://mooseframework.inl.gov/source/transfers/MultiAppGeneralFieldShapeEvaluationTransfer.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7720859",
                  "updatedAt": "2023-11-30T17:53:53Z",
                  "publishedAt": "2023-11-30T17:53:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "which direction is the transfer? from pipe to volume?",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7721647",
                          "updatedAt": "2023-11-30T19:33:48Z",
                          "publishedAt": "2023-11-30T19:33:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "The transfer happens both from pipe to volume and from volume to pipe.",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7721844",
                          "updatedAt": "2023-11-30T19:58:44Z",
                          "publishedAt": "2023-11-30T19:58:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "volume to pipe, shape evaluation will do well\npipe to volume, I would use NearestLocation OR user object with a layered average user object",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7721886",
                          "updatedAt": "2023-11-30T20:02:53Z",
                          "publishedAt": "2023-11-30T20:02:52Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "thanks a lot. I will try them and let you know the results.",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7722520",
                          "updatedAt": "2023-11-30T21:15:52Z",
                          "publishedAt": "2023-11-30T21:15:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "Hi Guillaume.\nI get the aux variable T_well (in pipe app) from the source variable T_res by using [MultiAppShapeEvaluationTransfer].\nHow can I use the aux variable T in the function /postprocessor in the sub app?\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7730059",
                          "updatedAt": "2023-12-01T14:24:22Z",
                          "publishedAt": "2023-12-01T14:24:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you want to use a PP in the subapp, either:\n\nperform some averaging using a user object then use the MultiAppGeneralFieldUserObjectTransfer\ntransfer the local value of the variable to the postprocessor with\nhttps://mooseframework.inl.gov/source/transfers/MultiAppVariableValueSamplePostprocessorTransfer.html",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7730125",
                          "updatedAt": "2023-12-01T14:30:09Z",
                          "publishedAt": "2023-12-01T14:30:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Bearunner"
                  },
                  "bodyText": "",
                  "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7730977",
                  "updatedAt": "2023-12-18T14:16:34Z",
                  "publishedAt": "2023-12-01T15:49:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Functions cannot use variables btw. Not even ParsedFunctions. Do you mean a material property?\nThe first step with making a multiapp simulation is getting both inputs to work separately.\nMaybe list exactly for both transfers what you plan to transfer, and what form it is in MOOSE (auxvariable? PPs?)",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7731144",
                          "updatedAt": "2023-12-01T16:05:30Z",
                          "publishedAt": "2023-12-01T16:05:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Bearunner"
                  },
                  "bodyText": "",
                  "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7731397",
                  "updatedAt": "2023-12-18T14:16:15Z",
                  "publishedAt": "2023-12-01T16:32:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nNo problem with 1.\n\n\n\nof every volume element\nThese Tem_res will be stored in the postprocessor or function and finally used in the heat kernels of the sub-app.\n\nThis does not seem consistent. In the first you say of every volume element, so you likely want to project the 3D field onto the 1D pipe. But then you mention using a postprocessor, which does not let you capture multiple values. Only 1 value in a postprocessor.\nDo you mean a vector postprocessor that is indexed by 1D elements? Have you tried a 1D variable instead?\nFunctions are also not the right medium to hold a temperature field. Functions are meant to be dependent only on X Y Z and time.\n\n\n\nSame problem\nI would consider transferring to variables instead of postpcessors.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7741608",
                          "updatedAt": "2023-12-03T02:44:08Z",
                          "publishedAt": "2023-12-03T02:44:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "thanks for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7751277",
                          "updatedAt": "2023-12-04T10:00:20Z",
                          "publishedAt": "2023-12-04T10:00:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Bearunner"
                  },
                  "bodyText": "",
                  "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7832172",
                  "updatedAt": "2023-12-18T14:15:49Z",
                  "publishedAt": "2023-12-12T15:25:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nI'm actually in charge of developing these transfers so if you can make a MWE that shows that you are not getting the expected value I can look at this.\nIf the 1D domain overlaps on the 3D domain, I dont see why it does not work to evaluarte the shape function.\nDo you have a hole in the 3D domain where the 1D domain is?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7832225",
                          "updatedAt": "2023-12-12T15:30:52Z",
                          "publishedAt": "2023-12-12T15:30:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "In reality, we have a hole in the 3D domain. But the radius of our 1D pipe model is rather smaller than the block size in 3D model.\nSo we simply ignore the hole in 3D.",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7832316",
                          "updatedAt": "2023-12-12T15:39:05Z",
                          "publishedAt": "2023-12-12T15:39:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok so in 3D you should be able to evaluate the variables at the location of the 1D pipe right? because it does overlap.\nso why does it not work for you?",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7832326",
                          "updatedAt": "2023-12-12T15:40:09Z",
                          "publishedAt": "2023-12-12T15:40:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you try:\n\ngreedy search for the transfer\nmaking sure the 1D domain fits entirely within the region (reduce its length by 0.1 for example) that provides the values (block 1?)",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7833161",
                          "updatedAt": "2023-12-12T16:59:01Z",
                          "publishedAt": "2023-12-12T16:59:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "Yes. The 'greedy_search = true' is set as above the [./to_pro_sub_P] in [Transfers].\nAnd The 1D pipe has a length of 90m fitting entirely within the region.\nBut I still get a similar error.\n(1) 1D pipe\n[Mesh]\n[./file]\ntype = GeneratedMeshGenerator\ndim = 1\nxmin = -2995\nxmax = 0\nnx = 600\n[../]\n[./sink_area]\ntype = SubdomainBoundingBoxGenerator\ninput = file\nblock_id = '1'\nbottom_left = '-2905 -0.1 -0.1'\ntop_right = '-2995 0.1 0.1'\n[../]\n[]\n_*** ERROR ***\nThe following error occurred in the object \"to_pro_sub_rho\", of type \"MultiAppGeneralFieldShapeEvaluationTransfer\".\nElement 17 for app 0 could not be located_",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7833317",
                          "updatedAt": "2023-12-12T17:15:38Z",
                          "publishedAt": "2023-12-12T17:14:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m not sure I understand.\n3D extends in [-3000, -2900] x [95, 100] x [-2.5, 2.5]\n1D extends in [-2995, -2905] x [195.1,194.9] x [-0.1,0.1] (from positions = '0 195 0' and the 1D generator)\nIt seems to me like they dont overlap at all in Y?",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7833422",
                          "updatedAt": "2023-12-12T17:26:56Z",
                          "publishedAt": "2023-12-12T17:26:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "Thanks for your tips. Now I can use MultiAppGeneralFieldShapeEvaluationTransfer for tranfering 3D models' data to pipe.\nUnfortunally, I still get the following wrong temperature results around the production well.",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7834754",
                          "updatedAt": "2023-12-14T22:21:28Z",
                          "publishedAt": "2023-12-12T19:44:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so this is the 3D model results right? So the problem is coming from the 1D to 3D transfer maybe?\nWhat does the output of this transfer look like?",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7834777",
                          "updatedAt": "2023-12-12T19:46:53Z",
                          "publishedAt": "2023-12-12T19:46:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so that output looks fine then?\nLooks good to me.\nWhat could be affecting the temperature like this?\nCan you simplify the problem?\nAlso is your mesh well-made? That s always my concern. You can use a MeshDiagnosticsGenerator to check it",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7836121",
                          "updatedAt": "2023-12-12T22:45:52Z",
                          "publishedAt": "2023-12-12T22:45:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Interesting.\n@cpgr might have a solution for this.\nI dont know how we can create sidedness in either the 1D object or the 3D mesh. Maybe in the 3D mesh there could be a slit / cut, and boundary conditions on both sides",
                          "url": "https://github.com/idaholab/moose/discussions/26211#discussioncomment-7843922",
                          "updatedAt": "2023-12-13T15:33:33Z",
                          "publishedAt": "2023-12-13T15:33:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ComputeIsotropicElasticityTensor from element-based imported youngs_modulus and poissons_ratio",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nI'd like to ComputeIsotropicElasticityTensor from element-based imported youngs_modulus and poissons_ratio\nI can import heterogenous youngs_modulus and poissons_ratio using ElementPropertyReadFile (to read .csv file) and GenericConstantArray (this is successfully done without a problem).\nbut in ComputeIsotropicElasticityTensor  it only takes a single value of  youngs_modulus and poissons_ratio such that\n  params.addParam<Real>(\"poissons_ratio\", -1, \"Poisson's ratio for the material.\");\n  params.addParam<Real>(\"youngs_modulus\", -1, \"Young's modulus of the material.\");\n.....\n  if (_youngs_modulus_set && _poissons_ratio_set)\n  {\n    _Cijkl.fillSymmetricIsotropicEandNu(_youngs_modulus, _poissons_ratio);\n    _effective_stiffness_local =\n        std::max(std::sqrt((_youngs_modulus * (1 - _poissons_ratio)) /\n                           ((1 + _poissons_ratio) * (1 - 2 * _poissons_ratio))),\n                 std::sqrt(_youngs_modulus / (2 * (1 + _poissons_ratio))));\n    return;\n  }\n.....\n  // Assign elasticity tensor at a given quad point\n  _elasticity_tensor[_qp] = _Cijkl;\n\n  // Assign effective stiffness at a given quad point\n  _effective_stiffness[_qp] = _effective_stiffness_local;\n\nis there a way to work around this? my imported youngs_modulus and poissons_ratio would be in this format:\n_youngs_modulus2(getMaterialProperty<Real>(\"_youngs_modulus2\")  and _poissons_ratio2(getMaterialProperty<Real>(\"_poissons_ratio2\") >>> _youngs_modulus2[_qp] and _poissons_ratio2[_qp] which I cannot simply just replace to the above\nto summarise, the question would be, how do I compute  _elasticity_tensor[_qp] and _effective_stiffness[_qp] based on element-based imported youngs_modulus and poissons_ratio.\n..................................................................................\nyou might say why don't I just use a block-restricted approach to do this, it won't work if I want to control mining activities such as excavation and backfill on a highly heterogeneous model, modifying the mesh is also not ideal in our workflow.\n\nSince MOOSE doesn't allow overlapping blocks, I plan to use a block-restricted approach to control mining activities (white blocks) instead by multiplying the imported properties by some 'prefactor'.\nThank you very much\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/20188",
          "updatedAt": "2023-12-18T02:45:38Z",
          "publishedAt": "2022-02-01T02:55:55Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUnless you can find a pre-exisiting one,\nYou'll probably have to make your own class which allows a material property for these coefficients, instead of the constant values which this one allows.\nIt should be fairly easy though\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-2093514",
                  "updatedAt": "2022-05-31T08:58:34Z",
                  "publishedAt": "2022-02-02T05:19:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud,\nso the original way of assigning the constant value is this\n  _Cijkl.fillSymmetricIsotropicEandNu(_youngs_modulus, _poissons_ratio);\n    _effective_stiffness_local =\n        std::max(std::sqrt((_youngs_modulus * (1 - _poissons_ratio)) /\n                           ((1 + _poissons_ratio) * (1 - 2 * _poissons_ratio))),\n                 std::sqrt(_youngs_modulus / (2 * (1 + _poissons_ratio))));\n    return;\n\n\nnot sure what does fillSymmetricIsotropicEandNu do, but when I modified it to:\n    _Cijkl.fillSymmetricIsotropicEandNu(_youngs_modulus_csv[_qp], _poissons_ratio_csv[_qp]);\n    _effective_stiffness_local =\n        std::max(std::sqrt((_youngs_modulus_csv[_qp] * (1 - _poissons_ratio_csv[_qp])) /\n                           ((1 + _poissons_ratio_csv[_qp]) * (1 - 2 * _poissons_ratio_csv[_qp]))),\n                 std::sqrt(_youngs_modulus_csv[_qp] / (2 * (1 + _poissons_ratio_csv[_qp]))));\n    return;\n\ni got this error:\n> moosebe-opt: malloc.c:4036: _int_malloc: Assertion `(unsigned long) (size) >= (unsigned long) (nb)' failed.\n> corrupted size vs. prev_size\n> \n> ===================================================================================\n> =   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n> =   PID 799677 RUNNING AT moose-System-Product-Name\n> =   EXIT CODE: 134\n> =   CLEANING UP REMAINING PROCESSES\n> =   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\n> ===================================================================================\n> YOUR APPLICATION TERMINATED WITH THE EXIT STRING: Aborted (signal 6)\n> This typically refers to a problem with your application.\n> Please see the FAQ page for debugging suggestions",
                          "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-2101461",
                          "updatedAt": "2022-05-31T08:58:37Z",
                          "publishedAt": "2022-02-03T05:51:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hi\nThe location where you modified this is a setup function. It s not being ran on every quadrature point, and the reason why is that this class defines constant isotropic material properties, so you only need to compute them once. _qp is not defined at this point, and the material properties have not been initialized.\nIf you want to be recomputing things on every quadrature point, with a _qp index into a material property, then you need to be recomputing things in computeQpElasticityTensor() in that material.\nBut it seems @josebastiase has already worked on this, so please have a look at his material.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-2106162",
                          "updatedAt": "2022-06-03T12:51:42Z",
                          "publishedAt": "2022-02-03T19:15:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "that might not be a problem at all, the problem could come from the way I define those array of Material properties:\nin .h\nconst MaterialProperty<Real> & _poissons_ratio_csv;\nconst MaterialProperty<Real> & _youngs_modulus_csv;\n\nin .C\n_poissons_ratio_csv(this->template getMaterialProperty<Real>(\"poissons_ratio_csv\")),\n_youngs_modulus_csv(this->template getMaterialProperty<Real>(\"youngs_modulus_csv\")),\n\nI've never modified any file with AD option, i think i probs stuff it up at the initial step",
                  "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-2101467",
                  "updatedAt": "2022-06-03T12:51:42Z",
                  "publishedAt": "2022-02-03T05:53:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this looks fine, for non AD work",
                          "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-2106165",
                          "updatedAt": "2022-05-31T08:58:41Z",
                          "publishedAt": "2022-02-03T19:15:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "josebastiase"
                  },
                  "bodyText": "This may be useful (https://github.com/josebastiase/RHEA) just copy and paste IsotropicElasticModulusFromVar.C and IsotropicElasticModulusFromVar.h in your tensor mechanics materials. Depending on what type of physics are you using in PorousFlow, you may also want the Biot modulus.",
                  "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-2104524",
                  "updatedAt": "2022-05-31T08:58:41Z",
                  "publishedAt": "2022-02-03T15:14:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @josebastiase,\nthank you, i think i almost get it, here is my modified version:\n#include \"ComputeIsotropicElasticityTensorBE.h\"\n\nregisterMooseObject(\"moosebeApp\", ComputeIsotropicElasticityTensorBE);\n\ntemplate <>\nInputParameters\nvalidParams<ComputeIsotropicElasticityTensorBE>()\n{\n  InputParameters params = validParams<ComputeElasticityTensorBase>();\n  params.addClassDescription(\"Compute a isotropic, heterogeneous elasticity tensor using the \"\n\t\t\t     \"spatially-varying bulk_modulus and shear_modulus values.\");\nparams.addParam<MaterialPropertyName>(\"youngs_modulus_csv\",-1,\"The coupled variable which provides the force\");\nparams.addParam<MaterialPropertyName>(\"poissons_ratio_csv\",-1,\"The coupled variable which provides the force\");\n  return params;\n}\n\nComputeIsotropicElasticityTensorBE::ComputeIsotropicElasticityTensorBE(const InputParameters & parameters)\n  : ComputeElasticityTensorBase(parameters),\n  _poissons_ratio_csv(getMaterialProperty<Real>(\"poissons_ratio_csv\")),\n  _youngs_modulus_csv(getMaterialProperty<Real>(\"youngs_modulus_csv\"))\n{\n   issueGuarantee(_elasticity_tensor_name, Guarantee::ISOTROPIC);\n}\n\nvoid\nComputeIsotropicElasticityTensorBE::computeQpElasticityTensor()\n{\n // Fill elasticity tensor\n\n  _Cijkl.fillSymmetricIsotropicEandNu(_poissons_ratio_csv[_qp], _youngs_modulus_csv[_qp]);\n  _elasticity_tensor[_qp] = _Cijkl;\n}\n\nand this is the error I got after 1 iteration of nl\n>  58 Linear |R| = 9.723134e-07\n>      59 Linear |R| = 9.491814e-07\n>      60 Linear |R| = 9.263357e-07\n>      61 Linear |R| = 9.153495e-07\n>      62 Linear |R| = 9.046562e-07\n>      63 Linear |R| = 8.917094e-07\n>      64 Linear |R| = 8.703339e-07\n> Cannot take square root of a number less than or equal to zero in the calculation of C3_test for the Rashid approximation for the rotation tensor. This zero or negative number may occur when elements become heavily distorted.\n> \n> A MooseException was raised during Auxiliary variable computation.\n> The next solve will fail, the timestep will be reduced, and we will try again.\n> \n> Cannot take square root of a number less than or equal to zero in the calculation of C1 for the Rashid approximation for the rotation tensor. This zero or negative number may occur when elements become heavily distorted.\n> \n> A MooseException was raised during Auxiliary variable computation.\n> The next solve will fail, the timestep will be reduced, and we will try again.\n> \n> Cannot take square root of a number less than or equal to zero in the calculation of C1 for the Rashid approximation for the rotation tensor. This zero or negative number may occur when elements become heavily distorted.\n> \n> A MooseException was raised during Auxiliary variable computation.\n> The next solve will fail, the timestep will be reduced, and we will try again.\n\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nSolve Did NOT Converge!\n\nI'm not super certain how fillSymmetricIsotropicEandNu works, but it does seem like it doesn't like the way I input _poissons_ratio_csv[_qp], _youngs_modulus_csv[_qp]\nThanks!\nTraiwit\n@GiudGiud  @WilkAndy I tag you two as well, just in case you are familiar with this issue",
                          "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-2108235",
                          "updatedAt": "2022-06-03T12:51:42Z",
                          "publishedAt": "2022-02-04T02:56:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "all good now, so I just change the last bit to this:\nvoid\nComputeIsotropicElasticityTensorBE::computeQpElasticityTensor()\n{\n // Fill elasticity tensor\n\n const Real E = _youngs_modulus_csv[_qp];\n const Real nu = _poissons_ratio_csv[_qp];\n\n\n\n  _Cijkl.fillSymmetricIsotropicEandNu(E, nu);\n  _elasticity_tensor[_qp] = _Cijkl;\n}\n\nThank you everyone!",
                          "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-2108503",
                          "updatedAt": "2022-06-03T12:52:13Z",
                          "publishedAt": "2022-02-04T04:51:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "manikumd22"
                          },
                          "bodyText": "Hi @josebastiase/ @Traiwit\nI need little help from your side, anyone please have a look at it.\nI have gone through whole discussion and make some progress for reading csv file for material property. However, I'm facing some issues while defining it in input file, this is the way I am reading the value of lambda constant from csv file, but I am getting an error\n*** ERROR ***\nThe following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\nMaterial property 'lambda1', requested by 'compute_stress' is not defined on block surface\nMaterial property 'lambda1', requested by 'compute_stress_face' is not defined on block surface\nMaterial property 'lambda1', requested by 'compute_stress_neighbor' is not defined on block surface\nE_values.csv:\n5, 10000.0\n[Functions]\n[./lambda1]\ntype = PiecewiseConstantFromCSV\nread_prop_user_object = 'reader_block'\nread_type = 'block'\ncolumn_number = '2'\n[../]\n[]\n[UserObjects]\n[reader_block]\ntype = PropertyReadFile\nprop_file_name = 'E_values.csv'\nread_type = 'block'\nnprop = 1\nnblock = 5\n[]\n[]\n[Materials]\n[compute_stress]\ntype = ComputeNeoHookeanStress\nlambda = lambda1\nmu = 8300.33333888888926\n[]\n[compute_strain]\ntype = ComputeLagrangianStrain\n[]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-7880453",
                          "updatedAt": "2023-12-18T00:57:07Z",
                          "publishedAt": "2023-12-18T00:57:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "answer is on the other thread.\nPlease dont double post.",
                          "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-7880889",
                          "updatedAt": "2023-12-18T02:23:38Z",
                          "publishedAt": "2023-12-18T02:23:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "manikumd22"
                          },
                          "bodyText": "Hi @GiudGiud\nI am sorry, I didn't realize that",
                          "url": "https://github.com/idaholab/moose/discussions/20188#discussioncomment-7881012",
                          "updatedAt": "2023-12-18T02:45:39Z",
                          "publishedAt": "2023-12-18T02:45:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Different elastic modulus for each element",
          "author": {
            "login": "drebbel1z"
          },
          "bodyText": "assuming I have a 10 by 10 mesh, with different elastic modulus for each element, is there a way to set this up in moose without assigning a different element id to each element? The time spent setting up is manageable for a 10 by 10 mesh, but setting up becomes very slow when the size of the mesh increases.",
          "url": "https://github.com/idaholab/moose/discussions/26351",
          "updatedAt": "2023-12-17T15:45:15Z",
          "publishedAt": "2023-12-15T21:05:32Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou mean a different blockID on each element?\nIf you can use a function for the elastic modulus, then you can specify this per-element dependency as a spatial dependency in x,y,z using a CSV file to hold the XYZ data. See piecewiseConstrantFromCSV for that function\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26351#discussioncomment-7868623",
                  "updatedAt": "2023-12-15T23:30:41Z",
                  "publishedAt": "2023-12-15T23:30:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "drebbel1z"
                          },
                          "bodyText": "Yes. I meant blockID for each element. For context, I have a stochastic field for my elastic moduli. So ideally I would want a different element modulus for each quadrature point. Since I didn't know how to do that in moose, I have decided to do a different elastic modulus per element.\nFrom the source code, ComputeIsotropicElasticityTensor material does not take youngs_modulus as a function but as a Real, so this will mean that I will still have to specify a material for every element. The problem is that when I do this, it takes a long time to set up for large meshes. Please let me know if I am missing something.\nLooking at the ComputeIsotropicElasticityTensor code, I was thinking maybe the youngs_modulus argument can be changed to a function instead of Real. This way when computeQpElasticityTensor() is called, I can get the coordinates of the _qp and use a PiecewiseBilinear function to compute the young's modulus based on the coordinates of the _qp. After that the computed young's modulus can be used to calculate _Cijkl.\nI am hoping there is already a way to do this.",
                          "url": "https://github.com/idaholab/moose/discussions/26351#discussioncomment-7872426",
                          "updatedAt": "2023-12-16T18:36:48Z",
                          "publishedAt": "2023-12-16T18:36:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Different block ID is one solution but it s not the only one.\nIf you make the elastic moduli a function of space, you can re-create this \"one value per element\" through the spatial dependence.\nIs ComputeIsotropyElasticityTensor the only material that works here? I know there are quite a few materials with slight variations\nI see this one that uses a material property?\nhttps://mooseframework.inl.gov/source/materials/ADComputeVariableIsotropicElasticityTensor.html\nA material property can be set with a Function (GenericFunctionMaterial for example) so that can be the solution?\nOtherwise modifying a Real to be a Function reasonably difficult.\nYou could also just make a custom material much like ComputeIsotropyElasticityTensor that reads in  data tabulated by element.",
                          "url": "https://github.com/idaholab/moose/discussions/26351#discussioncomment-7873740",
                          "updatedAt": "2023-12-16T22:59:01Z",
                          "publishedAt": "2023-12-16T22:50:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "drebbel1z"
                          },
                          "bodyText": "I wrote a material that takes a pieceiwisebilinear function and interpolates the elastic modulus at the qp. so all good now. Thanks for the pointers to the piecewise functions. They were helpful.",
                          "url": "https://github.com/idaholab/moose/discussions/26351#discussioncomment-7877633",
                          "updatedAt": "2023-12-17T15:45:15Z",
                          "publishedAt": "2023-12-17T15:45:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "New Material",
          "author": {
            "login": "manikumd22"
          },
          "bodyText": "I am trying to define a new material for the specific problem and this material is related to NeoHooken Behvaior but with some modifications.\nI have take out the files ComputeNeoHookeanStress.h and .C files from the MOOSE Folder and trying to modify it. But I'm getting error \"____ is not a registered object\".\nIs it correct way to do it?\nIf no, please let me know the correct way to do it",
          "url": "https://github.com/idaholab/moose/discussions/26356",
          "updatedAt": "2023-12-17T01:19:31Z",
          "publishedAt": "2023-12-16T07:59:58Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe key to fixing these errors is making sure these objects are registered to your application.\nIn the register call at the top of the source file, make sure the app name is exactly the same as your app name in the base/your app.C file\nAlternatively you can register the object to MooseApp that s always an option\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7870000",
                  "updatedAt": "2023-12-16T09:05:37Z",
                  "publishedAt": "2023-12-16T09:05:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "manikumd22"
                  },
                  "bodyText": "Hi @GiudGiud\nFor example, I am registering it to mooseApp (this is what created), will it be ok to do so?\n#include \"ComputeMultiscaleStress.h\"\n\nregisterMooseObject(\"mooseApp\", ComputeMultiscaleStress);\n\nInputParameters\nComputeMultiscaleStress::validParams()\n{\n  InputParameters params = ComputeLagrangianStressPK2::validParams();\n\n  params.addParam<MaterialPropertyName>(\"lambda\",\n                                        \"lambda\",\n                                        \"Parameter conjugate to Lame parameter\"\n                                        \" for small deformations\");\n  params.addParam<MaterialPropertyName>(\"mu\",\n                                        \"mu\",\n                                        \"Parameter conjugate to Lame parameter\"\n                                        \" for small deformations\");\n\n  return params;\n}\n\nComputeMultiscaleStress::ComputeMultiscaleStress(const InputParameters & parameters)\n  : ComputeLagrangianStressPK2(parameters),\n    _lambda(getMaterialProperty<Real>(getParam<MaterialPropertyName>(\"lambda\"))),\n    _mu(getMaterialProperty<Real>(getParam<MaterialPropertyName>(\"mu\")))\n\n{\n}\n\nvoid\nComputeMultiscaleStress::computeQpPK2Stress()\n{\n  // Hyperelasticity is weird, we need to branch on the type of update if we\n  // want a truly linear model\n  //\n  // This is because we need to drop quadratic terms for the linear update\n  usingTensorIndices(i_, j_, k_, l_);\n\n  // Large deformation = nonlinear strain\n  if (_large_kinematics)\n  {\n    RankTwoTensor Cinv = (2 * _E[_qp] + RankTwoTensor::Identity()).inverse();\n    _S[_qp] = (_lambda[_qp] * log(_F[_qp].det()) - _mu[_qp]) * Cinv +\n              _mu[_qp] * RankTwoTensor::Identity();\n    _C[_qp] =\n        -2 * (_lambda[_qp] * log(_F[_qp].det()) - _mu[_qp]) * Cinv.times<i_, k_, l_, j_>(Cinv) +\n        _lambda[_qp] * Cinv.times<i_, j_, k_, l_>(Cinv);\n  }\n  // Small deformations = linear strain\n  else\n  {\n    const auto I = RankTwoTensor::Identity();\n    RankTwoTensor strain = 0.5 * (_F[_qp] + _F[_qp].transpose()) - I;\n    _C[_qp] = _lambda[_qp] * I.times<i_, j_, k_, l_>(I) +\n              2.0 * _mu[_qp] * RankFourTensor(RankFourTensor::initIdentitySymmetricFour);\n    _S[_qp] = _C[_qp] * strain;\n  }\n}",
                  "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7872564",
                  "updatedAt": "2023-12-16T22:40:57Z",
                  "publishedAt": "2023-12-16T19:01:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If it doesn't work try MooseApp",
                          "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7872874",
                          "updatedAt": "2023-12-16T19:54:03Z",
                          "publishedAt": "2023-12-16T19:54:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "manikumd22"
                          },
                          "bodyText": "Hi @GiudGiud\nLet me tell you in detail,\nI modified the above code and put the .C and .h file in the mooseApp, and after that, I executed the make file, it is the procedure I followed, right?\nmyApp.h file:\n#pragma once\n\n#include \"MooseApp.h\"\n\nclass myApp : public MooseApp\n{\npublic:\n  static InputParameters validParams();\n\n  myApp(InputParameters parameters);\n  virtual ~myApp();\n\n  static void registerApps();\n  static void registerAll(Factory & f, ActionFactory & af, Syntax & s);\n};\n\nERROR:\nA 'ComputeMultiscaleStress' is not a registered object.\n\nIf you are trying to find this object in a dynamically loaded library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.'",
                          "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7872993",
                          "updatedAt": "2023-12-16T22:40:42Z",
                          "publishedAt": "2023-12-16T20:10:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes that s fine as long as the executable compiled properly (no error message)\nBut in this register(...) like in the .C file you need to put in the right app name. Otherwise you will get the error you are getting",
                          "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7873118",
                          "updatedAt": "2023-12-16T20:29:45Z",
                          "publishedAt": "2023-12-16T20:29:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "manikumd22"
                          },
                          "bodyText": "Hi @GiudGiud\nAs I mentioned I am using MooseApp in registerMooseObject(\"MooseApp\", ComputeMultiscaleStress), this is what is mentioned in the myApp.h file",
                          "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7873167",
                          "updatedAt": "2023-12-16T20:36:44Z",
                          "publishedAt": "2023-12-16T20:36:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This should have worked. However in the code you pasted you have\nregisterMooseObject(\"mooseApp\", ComputeMultiscaleStress);\n\nnot\nregisterMooseObject(\"MooseApp\", ComputeMultiscaleStress);",
                          "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7873717",
                          "updatedAt": "2023-12-16T22:41:25Z",
                          "publishedAt": "2023-12-16T22:41:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "manikumd22"
                          },
                          "bodyText": "Hi @GiudGiud\nIs it possible to modify the original defined material like ComputeNeohookean.C file and then execute make command to update the library\nModifications:\n\nImport CSV file and other modifications\n\nIf it works, then I will modify the original code.",
                          "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7873811",
                          "updatedAt": "2023-12-16T23:18:49Z",
                          "publishedAt": "2023-12-16T23:18:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "manikumd22"
                          },
                          "bodyText": "registerMooseObject(\"MooseApp\", ComputeMultiscaleStress);\n\nI have tried this also, but getting same error\nI have a question, do I need to change  .h file  and make file also?\nI have added all the necessary file such as .h, .C, myApp.h, and MakeFile\nComputeMultiscaleStress.C file:\n\n#include \"ComputeMultiscaleStress.h\"\n\nregisterMooseObject(\"MooseApp\", ComputeMultiscaleStress);\n\nInputParameters\nComputeMultiscaleStress::validParams()\n{\n  InputParameters params = ComputeLagrangianStressPK2::validParams();\n\n  params.addParam<MaterialPropertyName>(\"lambda\",\n                                        \"lambda\",\n                                        \"Parameter conjugate to Lame parameter\"\n                                        \" for small deformations\");\n  params.addParam<MaterialPropertyName>(\"mu\",\n                                        \"mu\",\n                                        \"Parameter conjugate to Lame parameter\"\n                                        \" for small deformations\");\n\n  return params;\n}\n\nComputeMultiscaleStress::ComputeMultiscaleStress(const InputParameters & parameters)\n  : ComputeLagrangianStressPK2(parameters),\n    _lambda(getMaterialProperty<Real>(getParam<MaterialPropertyName>(\"lambda\"))),\n    _mu(getMaterialProperty<Real>(getParam<MaterialPropertyName>(\"mu\")))\n\n{\n}\n\nvoid\nComputeMultiscaleStress::computeQpPK2Stress()\n{\n  // Hyperelasticity is weird, we need to branch on the type of update if we\n  // want a truly linear model\n  //\n  // This is because we need to drop quadratic terms for the linear update\n  usingTensorIndices(i_, j_, k_, l_);\n\n  // Large deformation = nonlinear strain\n  if (_large_kinematics)\n  {\n    RankTwoTensor Cinv = (2 * _E[_qp] + RankTwoTensor::Identity()).inverse();\n    _S[_qp] = (_lambda[_qp] * log(_F[_qp].det()) - _mu[_qp]) * Cinv +\n              _mu[_qp] * RankTwoTensor::Identity();\n    _C[_qp] =\n        -2 * (_lambda[_qp] * log(_F[_qp].det()) - _mu[_qp]) * Cinv.times<i_, k_, l_, j_>(Cinv) +\n        _lambda[_qp] * Cinv.times<i_, j_, k_, l_>(Cinv);\n  }\n  // Small deformations = linear strain\n  else\n  {\n    const auto I = RankTwoTensor::Identity();\n    RankTwoTensor strain = 0.5 * (_F[_qp] + _F[_qp].transpose()) - I;\n    _C[_qp] = _lambda[_qp] * I.times<i_, j_, k_, l_>(I) +\n              2.0 * _mu[_qp] * RankFourTensor(RankFourTensor::initIdentitySymmetricFour);\n    _S[_qp] = _C[_qp] * strain;\n  }\n}\n\nComputeMultiscaleStress.h file\n#pragma once\n\n#include \"ComputeLagrangianStressPK2.h\"\n\n/// Compressible Neo-Hookean hyperelasticity\n///\n///  Model follows from W = lambda / 2 * (ln J)^2 - mu * ln J + 1/2 * mu *\n///  (tr(C)- I)\n///\n///  with C = 1/2*(F.T*F-I) and J = det(F)\n///\nclass ComputeMultiscaleStress : public ComputeLagrangianStressPK2\n{\npublic:\n  static InputParameters validParams();\n  ComputeMultiscaleStress(const InputParameters & parameters);\n\nprotected:\n  /// Actual stress/Jacobian update\n  virtual void computeQpPK2Stress();\n\nprotected:\n  const MaterialProperty<Real> & _lambda;\n  const MaterialProperty<Real> & _mu;\n};\n\nregisterMooseObject(\"ComputeLagrangianStressPK2Object\", ComputeLagrangianStressPK2);\n\nmyApp.h\n#pragma once\n\n#include \"MooseApp.h\"\n\nclass myApp : public MooseApp\n{\npublic:\n  static InputParameters validParams();\n\n  myApp(InputParameters parameters);\n  virtual ~myApp();\n\n  static void registerApps();\n  static void registerAll(Factory & f, ActionFactory & af, Syntax & s);\n};\n\nMakeFile:\n###############################################################################\n################### MOOSE Application Standard Makefile #######################\n###############################################################################\n#\n# Optional Environment variables\n# MOOSE_DIR        - Root directory of the MOOSE project\n#\n###############################################################################\n# Use the MOOSE submodule if it exists and MOOSE_DIR is not set\nMOOSE_SUBMODULE    := $(CURDIR)/moose\nifneq ($(wildcard $(MOOSE_SUBMODULE)/framework/Makefile),)\n  MOOSE_DIR        ?= $(MOOSE_SUBMODULE)\nelse\n  MOOSE_DIR        ?= $(shell dirname `pwd`)/moose\nendif\n\n# framework\nFRAMEWORK_DIR      := $(MOOSE_DIR)/framework\ninclude $(FRAMEWORK_DIR)/build.mk\ninclude $(FRAMEWORK_DIR)/moose.mk\n\n################################## MODULES ####################################\n# To use certain physics included with MOOSE, set variables below to\n# yes as needed.  Or set ALL_MODULES to yes to turn on everything (overrides\n# other set variables).\n\nALL_MODULES                 := yes\n\nCHEMICAL_REACTIONS          := yes\nCONTACT                     := yes\nEXTERNAL_PETSC_SOLVER       := yes\nFLUID_PROPERTIES            := yes\nFUNCTIONAL_EXPANSION_TOOLS  := yes\nHEAT_TRANSFER               := yes\nLEVEL_SET                   := yes\nMISC                        := yes\nNAVIER_STOKES               := yes\nPHASE_FIELD                 := yes\nPOROUS_FLOW                 := yes\nRDG                         := yes\nRICHARDS                    := yes\nSOLID_MECHANICS             := yes\nSTOCHASTIC_TOOLS            := yes\nTENSOR_MECHANICS            := yes\nXFEM                        := yes\n\ninclude $(MOOSE_DIR)/modules/modules.mk\n###############################################################################\n\n# dep apps\nAPPLICATION_DIR    := $(CURDIR)\nAPPLICATION_NAME   := myApp\nBUILD_EXEC         := yes\nGEN_REVISION       := no\ninclude            $(FRAMEWORK_DIR)/app.mk\n\n###############################################################################\n# Additional special case targets should be added here\n``",
                          "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7873863",
                          "updatedAt": "2023-12-17T00:03:45Z",
                          "publishedAt": "2023-12-16T23:33:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "which executable are you using?\nin which folder is the new source file?\nno you should not need to modify the makefile",
                          "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7873957",
                          "updatedAt": "2023-12-17T00:04:04Z",
                          "publishedAt": "2023-12-17T00:02:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "manikumd22"
                          },
                          "bodyText": "Hi @GiudGiud\nAre you talking about this executable?\n[Executioner]\ntype = Steady\nsolve_type = 'newton'\n\nline_search = 'none'\n\npetsc_options_iname = -pc_type\npetsc_options_value = lu\n\nnl_abs_tol = 1e-10\nnl_rel_tol = 1e-6\nl_tol = 1e-10\n\n[]\nSource File Location:\n/storage/home/mvk6158/work/moose_directories/mooseApp\nIn this folder,\nI kept my .C, .h  and MAKEFILE file\nand executing make command for this folder\nWhen I tried to put the .C file in the folder\n/storage/home/mvk6158/work/moose_directories/moose/modules/tensor_mechanics/src/materials/lagrangian/ComputeMultiscaleStress.C\nI am getting error\nstorage/home/mvk6158/work/moose_directories/moose//modules/tensor_mechanics/build/header_symlinks/ComputeLagrangianStressPK2.h:34:16: note:   'virtual void ComputeLagrangianStressPK2::computeQpPK2Stress()'\nvirtual void computeQpPK2Stress() = 0;",
                          "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7873972",
                          "updatedAt": "2023-12-17T00:22:38Z",
                          "publishedAt": "2023-12-17T00:10:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "that s the executioner not the executable. The executable is the .exe file on windows.\nOk so your code was not compiling so you moved it to the wrong folder and now it s not erroring  at compile time because the compiler isnt compiling it. However, you cannot use it in a simulation.\nYou need to put your code in src/materials either in moose or in your app (the latter is the correct way)\nthen you need to compile it, and fix all the compile errors. Then you can move on to using it.\nthis error you got means you need to implement computeQpPK2Stress(). It cannot be left unimplemented in the class.",
                          "url": "https://github.com/idaholab/moose/discussions/26356#discussioncomment-7874018",
                          "updatedAt": "2023-12-17T00:30:38Z",
                          "publishedAt": "2023-12-17T00:30:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Accessing a non-linear variable from a contour to compute the residual term for integrated boundary condition",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello everyone,\nIn order to be able to impose a dynamic wetting boundary condition, first I need to define the c=0 contour (c is the order parameter). After that, I need to access the velocity on the closest point to the c=0 contour to the wall! Because at wall, the no-slip velocity boundary condition is used. So I need the velocity on the second closet point on the wall. Is this possible in MOOSE kernel system?\nIf this is not possible, is it possible to for example define a some y-intercept of the c=0 contour and find the velocity there?\nThanks,\nAli",
          "url": "https://github.com/idaholab/moose/discussions/26352",
          "updatedAt": "2023-12-16T22:57:43Z",
          "publishedAt": "2023-12-16T01:01:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you need this to work efficiently in parallel (MPI), it s going to be quite a bit of work. You ll need to create a new relationship manager than introduces ghosting of variable values from a contour to the wall / this point near the wall.\nIf not (threading is fine, or inefficient global comm of the contour), I would make a user object that:\n\ndetects which elements are on the c=0 contour\nfills a KDTree with those elements\nThen the BC can query the user object to:\nget the KDTRee from the UO\nquery the KDTree for the closest distance from the wall to the contour\n\nTo work on the 1st and 2nd nodes near the wall, I would make a nodeset, with something close to a boundary layer generator. We dont have that one in MOOSE yet either, but we could use one.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26352#discussioncomment-7873758",
                  "updatedAt": "2023-12-16T22:57:44Z",
                  "publishedAt": "2023-12-16T22:57:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}