{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wMS0xOFQyMTowMjowOC0wNzowMM4AOfdx"
    },
    "edges": [
      {
        "node": {
          "title": "convergence issue with AbauqsUMATstress",
          "author": {
            "login": "edwardXZ06"
          },
          "bodyText": "Hi, everyone:\nI met a question when running the AbaqusUMATstress feature in the MOOSE.\nFirst the umat file works well with Abaqus regardless of element number. Second, there is no issue when running in the MOOSE on a single element test. However, when I just increase the element number, it becomes more and more difficult to converge. I have manipulated the executioner module a little bit but it doesn't work.\nHas anyone met similar issues or any advice on this problem? I have attached the input file in txt format.\nMany thanks!\nXiang\nelastic_test.txt",
          "url": "https://github.com/idaholab/moose/discussions/19574",
          "updatedAt": "2023-06-05T12:35:58Z",
          "publishedAt": "2021-12-07T20:11:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @edwardXZ06\nTry using the adaptive time stepper, as explained here:\nhttps://mooseframework.inl.gov/source/materials/abaqus/AbaqusUMATStress.html\nIt is because your UMAT may be asking a time step cut using PNEWDT,\nbut if you don't add the adaptive time stepper, the time step cut is not handled properly in moose.\nDepending on your specific UMAT, that may cause problems.\nYou need to add the user objects, postprocessor and adaptive time stepper as explained here:\nmodules/tensor_mechanics/test/tests/umat/time_step/elastic_timestep.i\nMay not be the solution to your problem, but try anyway.\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19574#discussioncomment-1784710",
                  "updatedAt": "2023-06-05T12:36:04Z",
                  "publishedAt": "2021-12-10T10:14:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@edwardXZ06\nPlease check this other discussion, I think I ultimately found the origin of the convergence problem\nwhen running the umat with more elements:\n#20109\nHope this helps\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19574#discussioncomment-2027365",
                  "updatedAt": "2023-06-05T12:36:11Z",
                  "publishedAt": "2022-01-23T13:23:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "'ElementIntegralVariablePostprocessor'",
          "author": {
            "login": "Leni-Yeo"
          },
          "bodyText": "Good afternoon, I hope you are all doing well.\nI am trying to do a bi-crystal simulation with an assigned energy and compare the value to that of the 'ElementIntegralVariablePostprocessor' output; using the 'AuxKernels' setup generally used in moose. I am using the 'PolycrystalKernel'  action for kernels setup. I am trying to have 'mu' as a constant input with a calculated grain boundary width. However, no matter the variation of 'mu', I am unable to have a match with both energies. I have tried using  'ElementIntegralVariablePostprocessor' for a number of setups where the grain boundary width is constant and 'mu' is calculated;  however, it always fails to yield the right value regardless of the inputs I have.\nI may have a wrong setup or missing a point. I was wondering if anyone has ever been able to have a match between output from 'ElementIntegralVariablePostprocessor' and the actual energy that is assigned in the input file ?. Please let me know if there is maybe a verified version/file in MOOSE that I may have missed too.\nIt would greatly help if you could also take a look at the files I have attached. I have an input file and its output file as well as the material class I quickly made to verify 'ElementIntegralVariablePostprocessor'.\nThank you in advance for your help.\nFiles.zip",
          "url": "https://github.com/idaholab/moose/discussions/19977",
          "updatedAt": "2022-06-14T11:30:33Z",
          "publishedAt": "2022-01-07T19:44:19Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "I'm not sure exactly what you mean by \"assigning\" an energy to the system. I see that you added a DerivativeParsedMaterial for the local free energy density that look likes it matches the Moelans model, and that you are adding it to the gradient term using the TotalFreeEnergy AuxKernel, passing it to an AuxVariable. Then you are integrating the AuxVariable using the ElementIntegralVariablePostprocessor. This all seems fine and should give you the correct integrated free energy for the entire system. However, I'm not sure what you are comparing that number to when you say you are \"assigning\" an energy, can you please elaborate? Are you trying to calculate the energy for this configuration analytically or something?",
                  "url": "https://github.com/idaholab/moose/discussions/19977#discussioncomment-1993950",
                  "updatedAt": "2022-06-14T11:31:07Z",
                  "publishedAt": "2022-01-18T23:06:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Leni-Yeo"
                          },
                          "bodyText": "Thank you for answering.\nSorry for the misunderstanding.\nI am trying to compare the integrated free energy for the entire system using the ElementIntegralVariablePostprocessor to the sigma value that is inputted in the material block -- 0.708 J/m2.  It is my understanding that by multiplying the grain boundary area to the sigma value, we should be able to get the same total energy as what we get with the ElementIntegralVariablePostprocessor. However, both values are different for some reason. So, I was wandering if I may have a mistake in the setup or if it is an understanding issue. The main question is whether anyone was able to equate both results under any specific setup.",
                          "url": "https://github.com/idaholab/moose/discussions/19977#discussioncomment-1994158",
                          "updatedAt": "2022-06-14T11:31:07Z",
                          "publishedAt": "2022-01-19T00:13:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "The grain boundary energy value you gave is the energy per unit area of interface, so you are correct that you need to multiply by the area of the interface. It looks like you're using your own custom material property to calculate kappa. Can you do the same calculation using the GBEvolution material that comes with the framework instead to see if the results are consistent? The next thing to be aware of is that there is a length scale parameter in GBEvolution that sets the units for the problem. By default it is in nm, so if your simulation domain is set to be 300 by 300 in your input file, that means 300 nm by 300 nm. So I'm not sure if you did the same thing in your custom material property but that is another thing to check - you must use this length scale when you're determining the GB area for your analytical calculation of GB energy * GB area, which you are trying to match to the postprocessor calculation.",
                          "url": "https://github.com/idaholab/moose/discussions/19977#discussioncomment-1994206",
                          "updatedAt": "2022-06-14T11:33:11Z",
                          "publishedAt": "2022-01-19T00:31:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Leni-Yeo"
                          },
                          "bodyText": "Thank you.\nI will try that and get back to you.",
                          "url": "https://github.com/idaholab/moose/discussions/19977#discussioncomment-1994279",
                          "updatedAt": "2022-06-14T11:33:08Z",
                          "publishedAt": "2022-01-19T00:58:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Leni-Yeo"
                          },
                          "bodyText": "Good afternoon,\nSorry for the delay.\nI ran a bi-crystal by modifying the built-in file \"grain_growth_2D_voronoi.i\". I attached the input / output files and a snip of the total energy from integrating the free energy for the entire system using the ElementIntegralVariablePostprocessor.\n\n\nThe total energy is at around \"1337 eV\". The mu value \"1.89385\" is the one calculated by \"GBEvolution\". I ran the simulation once at first and copied the value to the \"DerivativeParsedMaterial\" of the \"free_energy\" material.\n\n\nThe total energy when using sigma = 0.708 J/m^2 = 4.4 eV/nm^2 ; wGB = 14 nm; the height of the block  = 300 nm is: 4.4 * 14 * 300 =  18,480 eV. It is ~13.8 times greater.\n\n\nI may have a mistake so I am not really 100% sure, but no matter the changes I tried both values are different somewhat.\ngrain_growth_2D_voronoi_BICRYSTAL.zip",
                          "url": "https://github.com/idaholab/moose/discussions/19977#discussioncomment-2009001",
                          "updatedAt": "2022-06-14T11:36:09Z",
                          "publishedAt": "2022-01-20T18:47:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "It looks like you are getting the correct result from the postprocessor but there is an error in your hand calculation. I think you may be getting confused by the fact that this is a 2D simulation, which is a \"slice\" of the real system in 3D. In the real 3D system, if the GB runs along the y-direction, then it sits in the yz plane and the x-direction is normal to the GB. So to calculate the energy of the GB, you would multiply sigma times the size in the y-direction times the size in the z-direction. You don't multiply by wGB, as this width (in the x-direction) is associated with the diffuse interface representation of the grain boundary.\nSo assume the domain is 1 nm in the z-direction (the actual number doesn't matter). Your total energy for the analytical calculation is 4.4 eV/nm^2 * 300 nm * 1 nm = 1320 eV. To compare to the postprocessor, you need to recognize that the integrated value is also for a 2D domain which also has an arbitrary length in the z-direction; since we set it to 1 nm the total energy is 1337 eV/nm * 1 nm = 1337 eV. So you see the two vales are very close. You can repeat the exercise with any value you want for the length of the domain in the z-direction and you'll find the same thing. The factor of ~13.8 difference that you were getting is because you were multiplying the hand calculation by 14, which is incorrect.\nYou can probably make the postprocessor calculation match the hand calculation even more closely by increasing the resolution of the mesh in the interfacial region.",
                          "url": "https://github.com/idaholab/moose/discussions/19977#discussioncomment-2010042",
                          "updatedAt": "2022-06-14T11:36:12Z",
                          "publishedAt": "2022-01-20T21:24:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Leni-Yeo"
                          },
                          "bodyText": "Oh I see. It makes sense now.\nI just did a trial run with my own material and the values are much closer.\nThank you so much. You were of great help.",
                          "url": "https://github.com/idaholab/moose/discussions/19977#discussioncomment-2010253",
                          "updatedAt": "2022-06-14T11:36:14Z",
                          "publishedAt": "2022-01-20T21:55:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Installation on ALCF Theta",
          "author": {
            "login": "smpark7"
          },
          "bodyText": "I'm currently trying to install a MOOSE App on Theta. I don't have any specific requirements concerning PETSc and libMesh versions. Can anyone provide me with the appropriate environment for installing MOOSE on Theta?\nI tried the following:\nmodule load cray-hdf5-parallel\nmodule load cray-fftw\nmodule load cray-petsc\nmodule load cray-tpsl\nmodule load cray-python\nexport CC=cc\nexport CXX=CC\nexport FC=ftn\nexport EPYTHON=python3.8\nexport PETSCDIR=$PETSC_DIR\nexport CRAYPE_LINK_TYPE=dynamic\nexport CRAY_ADD_RPATH=yes\n\nwhich I (blindly) adapted from my experience with another supercomputer. This resulted in a seemingly successful installation, but when I run an input file (that works on other machines), the simulation run gets killed by the OOM killer despite using only ~32GB of the available 192GB memory per node.",
          "url": "https://github.com/idaholab/moose/discussions/20082",
          "updatedAt": "2022-06-17T21:51:37Z",
          "publishedAt": "2022-01-19T17:21:42Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDoes the test suite pass?\nHow did you measure the 32 GB ?\nHow did you request the 192 GB ?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-1999817",
                  "updatedAt": "2022-06-17T21:51:41Z",
                  "publishedAt": "2022-01-19T17:51:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "Hello,\nThanks for the quick reply. I have trouble running run_tests despite providing export MOOSE_MPI_COMMAND=aprun and alias mpiexec=aprun. I get the following error message for all tests:\nnts.nts: Running command: aprun -n 1 /gpfs/mira-home/smpark3/projects/moltres/moltres-opt -i nts.i --no-gdb-backtrace\nnts.nts: apsched: request exceeds max nodes, alloc\nnts.nts: apsched: request exceeds max nodes, alloc\nnts.nts: \nnts.nts: \nnts.nts: Exit Code: 1\nnts.nts: ################################################################################\nnts.nts: Tester failed, reason: CRASH\nnts.nts: \nnts.nts ....................................................................................... FAILED (CRASH)\n\nThe test input files seem to run successfully when I manually run aprun -n 64 ... individually, but this approach obviously does not compare the output against the gold copy. I measured 32 GB using MemoryUsage postprocessor with the default settings which report total memory usage across all ranks. I assumed 192 GB of memory is provided based on Theta's machine info.\nSun Myung",
                          "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-2000120",
                          "updatedAt": "2022-06-17T21:52:03Z",
                          "publishedAt": "2022-01-19T18:48:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Well it depends on the cluster. I think if you requested a full node, you should get the whole memory for it. Is that what you are doing with -n 1 ?\n\"apsched: request exceeds max nodes, alloc\" is this the oom output?\naprun -n 1 on the inputs individually works too?\nDoesnt theta have some minimum ressource request? Like at least 4 nodes?",
                          "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-2000312",
                          "updatedAt": "2022-06-17T21:52:11Z",
                          "publishedAt": "2022-01-19T19:22:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "No, the OOM killer error occurred when I ran a non-test input file with aprun -n 64 on 1 compute node, whereas the apsched: request exceeds max nodes, alloc error occurred when I tried to run run_tests.\nYes aprun -n 1 works when individually running tests. I ran it on the debug queue which allows me to request 1 to 8 compute nodes.",
                          "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-2000397",
                          "updatedAt": "2022-06-17T21:52:15Z",
                          "publishedAt": "2022-01-19T19:36:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are you using run_tests on the debug queue as well?\nThis troubleshooting page: http://www.archer.ac.uk/documentation/troubleshooting.php (for another cluster, is there a theta one?)\nis saying that aprun is being run on the head node instead of within a job script.\nI m not familiar with aprun. Is this more of an mpirun command or more of an interactive qsub command",
                          "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-2000440",
                          "updatedAt": "2022-06-17T21:52:32Z",
                          "publishedAt": "2022-01-19T19:47:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "Yes I ran run_tests on the debug queue as well. Unfortunately, Theta's user guide doesn't seem to have troubleshooting information relevant to my issues.\naprun seems to function similarly to mpirun; I just replace mpirun with aprun in my commands. aprun is responsible for starting jobs on the compute nodes from the service nodes from which we send commands. Theta provides this illustration as an overview of what qsub and aprun do:",
                          "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-2000557",
                          "updatedAt": "2022-06-17T21:52:32Z",
                          "publishedAt": "2022-01-19T20:09:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah ok so you're running all this from a qsub interactive session?\nwhy would you get this apsched: request exceeds max nodes, alloc then though...\nSeems like 1 should be ok.",
                          "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-2000741",
                          "updatedAt": "2022-06-17T21:52:35Z",
                          "publishedAt": "2022-01-19T20:38:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "Yes it's very perplexing to get this error even though I'm in the interactive session and run_tests ran aprun -n 1.\nRegarding the OOM issue, I tried running the same input file with fewer MPI ranks per node (32 vs 64 previously). I still got the same OOM killer triggered at the same point during the simulation (right after 5 time steps). This seems to imply that the OOM issue is not hardware-related.\nI found an old thread from 2018 in the moose-users group about installing MOOSE on Theta. Could the comment from Fande about static vs dynamic libs be relevant to my OOM killer issue?",
                          "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-2000790",
                          "updatedAt": "2022-06-17T21:52:36Z",
                          "publishedAt": "2022-01-19T20:47:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Oh great let's tag @fdkong since he was running stuff on theta.\nI dont think it's related though. I'd double check that your interactive session has requested enough memory. There should be a way to get that from qstat",
                          "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-2000990",
                          "updatedAt": "2022-06-17T21:52:35Z",
                          "publishedAt": "2022-01-19T21:26:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Does \"aprun -n 1 /gpfs/mira-home/smpark3/projects/moltres/moltres-opt -i nts.i\" run if you type it manually?\nI did not see any indication that this is related to how did you build moose. I ran MOOSE a couple of years ago but I did not do \"run_tests\".   I tried to use a job script to launch the simulation I want.",
                          "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-2001351",
                          "updatedAt": "2022-06-17T21:52:39Z",
                          "publishedAt": "2022-01-19T22:34:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "Yes, all test input files run if I run them individually like that. From manually scanning through some of the postprocessor values, the values seem to indicate that the results match the gold copies. So I'm not too concerned about run_tests not running correctly.\nDo you have any advice/ideas about the OOM killer issue? I tried asking the ALCF support desk, but they recommended directing my question to the MOOSE developers.",
                          "url": "https://github.com/idaholab/moose/discussions/20082#discussioncomment-2001414",
                          "updatedAt": "2022-06-17T21:52:43Z",
                          "publishedAt": "2022-01-19T22:50:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "SegFault at mpirun for DynamicStressDivergenceTensors",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "Hi,\nI was running a multiapp (tensor_mechanics and phase-field) and with multiple cpus on ubuntu. It worked fine until I changed the kernel from ADStressDivergenceTensors to ADDynamicStressDivergenceTensors. After that, I encountered Segmentation fault (signal 11) only at running it with multiple cpus.\nI have updated moose and its dependencies. I looked at the moose debugging document but the parallel method does not seem to apply to ubuntu(https://mooseframework.inl.gov/application_development/debugging.html). For backtrace information, I need help on how to get that with mpirun on ubuntu for moose.\nBo",
          "url": "https://github.com/idaholab/moose/discussions/20073",
          "updatedAt": "2022-06-16T18:29:33Z",
          "publishedAt": "2022-01-18T22:42:32Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nTo run gdb in parallel you can do it like this:\nmpirun -n 2 gdb --ex run --ex bt --args app-dbg -i input_file.i\nIf you need more than this, the instructions listed in the link you pasted can be translated directly from lldb to gdb, no tricks\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20073#discussioncomment-1994123",
                  "updatedAt": "2022-06-16T18:29:48Z",
                  "publishedAt": "2022-01-19T00:00:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "BoZeng1997"
                  },
                  "bodyText": "Hi,\nHere is the backtrace from gdb for the SIGSEGV signal\nThread 1 \"raccoon-opt\" received signal SIGSEGV, Segmentation fault.\n0x00007ffff5ecf35a in libMesh::PetscVector<double>::operator()(unsigned long) const () from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#0  0x00007ffff5ecf35a in libMesh::PetscVector<double>::operator()(unsigned long) const () from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#1  0x00007ffff5a4e8cb in MultiAppFieldTransfer::transferDofObject(libMesh::DofObject*, libMesh::DofObject*, MooseVariableFieldBase&, MooseVariableFieldBase&, libMesh::NumericVector<double>&, libMesh::NumericVector<double>&) ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#2  0x00007ffff5a82de1 in MultiAppFieldTransfer::transfer(FEProblemBase&, FEProblemBase&) ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#3  0x00007ffff5a8319b in MultiAppCopyTransfer::execute() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#4  0x00007ffff5472130 in FEProblemBase::execMultiAppTransfers(MooseEnumItem, Transfer::DIRECTION) ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#5  0x00007ffff547291f in FEProblemBase::execMultiApps(MooseEnumItem, bool) ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#6  0x00007ffff50842c1 in FixedPointSolve::solveStep(double&, double&, std::set<unsigned long, std::less<unsigned long>, std::allocator<unsigned long> > const&) () from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#7  0x00007ffff509f31a in FixedPointSolve::solve() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#8  0x00007ffff5b4d0ce in TimeStepper::step() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#9  0x00007ffff508246e in Transient::takeStep(double) ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#10 0x00007ffff507ec8f in Transient::execute() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#11 0x00007ffff60a76e3 in MooseApp::executeExecutioner() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#12 0x00007ffff60ad483 in MooseApp::run() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#13 0x0000555555557153 in main ()\n(gdb) \nProgram received signal SIGSEGV, Segmentation fault.\n0x00007ffff5ecf35a in libMesh::PetscVector<double>::operator()(unsigned long) const () from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#0  0x00007ffff5ecf35a in libMesh::PetscVector<double>::operator()(unsigned long) const () from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#1  0x00007ffff5a4e8cb in MultiAppFieldTransfer::transferDofObject(libMesh::DofObject*, libMesh::DofObject*, MooseVariableFieldBase&, MooseVariableFieldBase&, libMesh::NumericVector<double>&, libMesh::NumericVector<double>&) ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#2  0x00007ffff5a82de1 in MultiAppFieldTransfer::transfer(FEProblemBase&, FEProblemBase&) ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#3  0x00007ffff5a8319b in MultiAppCopyTransfer::execute() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#4  0x00007ffff5472130 in FEProblemBase::execMultiAppTransfers(MooseEnumItem, Transfer::DIRECTION) ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#5  0x00007ffff547291f in FEProblemBase::execMultiApps(MooseEnumItem, bool) ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#6  0x00007ffff50842c1 in FixedPointSolve::solveStep(double&, double&, std::set<unsigned long, std::less<unsigned long>, std::allocator<unsigned long> > const&) () from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#7  0x00007ffff509f31a in FixedPointSolve::solve() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#8  0x00007ffff5b4d0ce in TimeStepper::step() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#9  0x00007ffff508246e in Transient::takeStep(double) ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#10 0x00007ffff507ec8f in Transient::execute() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#11 0x00007ffff60a76e3 in MooseApp::executeExecutioner() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#12 0x00007ffff60ad483 in MooseApp::run() ()\n   from /home/bozeng/projects/raccoon/moose/framework/libmoose-opt.so.0\n#13 0x0000555555557153 in main ()\n\nPlease tell me what should I do next to solve this.",
                  "url": "https://github.com/idaholab/moose/discussions/20073#discussioncomment-2008344",
                  "updatedAt": "2022-06-16T18:29:47Z",
                  "publishedAt": "2022-01-20T17:05:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "Here is the input file for main app elasticity\nE = 9.8e3 #9.8Gpa\nnu = 0.13\nK = '${fparse E/3/(1-2*nu)}'\nG = '${fparse E/2/(1+nu)}'\nLambda = '${fparse E*nu/(1+nu)/(1-2*nu)}'\n\nGc = 9.1e-2 # 91N/m\nl = 0.12 #0.35\nsigma_ts = 27\nsigma_cs = 77\ndelta = 9.66 #1.16\nc1 = '${fparse (1+nu)*sqrt(Gc)/sqrt(2*pi*E)}'\nc2 = '${fparse (3-nu)/(1+nu)}'\nahead = -1\nV = 20\nnx = 25 #100 #90 #300 #90\nny = 20 #50 #30 #100 #30\nlength = 5\nheight = 4\nrefine = 5 #3\n\n\n[Functions]\n  [bc_func]\n    type = ParsedFunction\n    value = c1*((x-V*t-ahead)^2+y^2)^(0.25)*(c2-cos(atan2(y,(x-V*t-ahead))))*sin(0.5*atan2(y,(x-V*t-ahead)))\n    vars = 'c1 c2 V ahead'\n    vals = '${c1} ${c2} ${V} ${ahead}'\n  []\n[]\n\n[MultiApps]\n  [fracture]\n    type = TransientMultiApp\n    input_files = fracture.i\n    cli_args = 'E=${E};K=${K};G=${G};Lambda=${Lambda};Gc=${Gc};l=${l};nx=${nx};ny=${ny};refine=${refine};length=${length};height=${height}'\n    execute_on = 'TIMESTEP_END'\n  []\n[]\n\n[Transfers]\n  [from_d]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = from_multiapp\n    variable = 'd'\n    source_variable = 'd'\n  []\n  [to_psie_active]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = to_multiapp\n    variable = 'psie_active ce'\n    source_variable = 'psie_active ce'\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Mesh]\n  [top_half]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = ${nx}\n    ny = '${fparse ny/2}'\n    xmin = 0\n    xmax = ${length}\n    ymin = 0 #-25 #-50\n    ymax = '${fparse height/2}'\n    boundary_id_offset = 0\n    boundary_name_prefix = top_half\n  []\n  [top_stitch]\n    type = BoundingBoxNodeSetGenerator\n    input = top_half\n    new_boundary = top_stitch\n    bottom_left = '1 0 0'\n    top_right = '5 0 0'\n  []\n  [top_crack]\n    type = BoundingBoxNodeSetGenerator\n    input = top_stitch\n    new_boundary = top_crack\n    bottom_left = '0 0 0'\n    top_right = '1 0 0'\n  []\n  [bottom_half]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = ${nx}\n    ny = '${fparse ny/2}'\n    xmin = 0\n    xmax = ${length}\n    ymin = '${fparse -height/2}'\n    ymax = 0 # 25 # 50\n    boundary_id_offset = 7\n    boundary_name_prefix = bottom_half\n  []\n  [bottom_stitch]\n    type = BoundingBoxNodeSetGenerator\n    input = bottom_half\n    new_boundary = bottom_stitch\n    bottom_left = '1 0 0'\n    top_right = '5 0 0'\n  []\n  [bottom_crack]\n    type = BoundingBoxNodeSetGenerator\n    input = bottom_stitch\n    new_boundary = bottom_crack\n    bottom_left = '0 0 0'\n    top_right = '1 0 0'\n  []\n  [stitch]\n    type = StitchedMeshGenerator\n    inputs = 'top_crack bottom_crack'\n    stitch_boundaries_pairs = 'top_stitch bottom_stitch'\n  []\n  construct_side_list_from_node_list = true\n  [fix_point]\n    type = ExtraNodesetGenerator\n    input = stitch\n    new_boundary = fix_point\n    coord = '0 -2'\n  []\n  [crack_tip]\n    type = ExtraNodesetGenerator\n    input = fix_point\n    new_boundary = crack_tip\n    coord = '0 0 0'\n  []\n[]\n\n[Adaptivity]\n  marker = marker\n  initial_marker = marker\n  initial_steps = ${refine}\n  stop_time = 0\n  max_h_level = ${refine}\n  [Markers]\n    [marker]\n      type = BoxMarker\n      bottom_left = '0 -0.2 0' # 0.7\n      top_right = '5 0.2 0'\n      outside = DO_NOTHING\n      inside = REFINE\n    []\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [strain_zz]\n  []\n[]\n\n[AuxVariables]\n  [d]\n    [InitialCondition]\n      type = FunctionIC\n      function = 'if(y=0&x<=1,1,0)'\n    []\n  []\n[]\n\n[Kernels]\n  [solid_x]\n    type = ADDynamicStressDivergenceTensors\n    # displacements = disp_x\n    variable = disp_x\n    component = 0\n    out_of_plane_strain = strain_zz\n    zeta = 1e-6\n  []\n  [solid_y]\n    type = ADDynamicStressDivergenceTensors\n    # displacements = disp_y\n    variable = disp_y\n    component = 1\n    out_of_plane_strain = strain_zz\n    zeta = 1e-6\n  []\n  [plane_stress]\n    type = ADWeakPlaneStress\n    variable = 'strain_zz'\n    displacements = 'disp_x disp_y'\n  []\n[]\n\n[BCs]\n  [fix_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = fix_point\n    value = 0\n  []\n  [bottom_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = bottom_half_bottom\n    function = bc_func\n  []\n  [top_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = top_half_top\n    function = bc_func\n  []\n[]\n\n[Materials]\n  [bulk]\n    type = ADGenericConstantMaterial\n    prop_names = 'E K G lambda Gc l'\n    prop_values = '${E} ${K} ${G} ${Lambda} ${Gc} ${l}'\n  []\n  [degradation]\n    type = PowerDegradationFunction\n    f_name = g\n    function = (1-d)^p*(1-eta)+eta\n    phase_field = d\n    parameter_names = 'p eta '\n    parameter_values = '2 0'\n  []\n  [strain]\n    type = ADComputePlaneSmallStrain\n    out_of_plane_strain = 'strain_zz'\n    displacements = 'disp_x disp_y'\n  []\n  [elasticity]\n    type = SmallDeformationIsotropicElasticity\n    bulk_modulus = K\n    shear_modulus = G\n    phase_field = d\n    degradation_function = g\n    decomposition = NONE\n    output_properties = 'psie_active psie'\n    outputs = exodus\n  []\n  [stress]\n    type = ComputeSmallDeformationStress\n    elasticity_model = elasticity\n    output_properties = 'stress'\n  []\n  [crack_geometric]\n    type = CrackGeometricFunction\n    f_name = alpha\n    function = 'd'\n    phase_field = d\n  []\n  [kumar_material]\n    type = NucleationMicroForce\n    normalization_constant = c0\n    tensile_strength = '${sigma_ts}'\n    compressive_strength = '${sigma_cs}'\n    delta = '${delta}'\n    external_driving_force_name = ce\n    output_properties = 'ce'\n    outputs = exodus\n  []\n[]\n\n[Postprocessors]\n  [Jint]\n    type = PhaseFieldJIntegral\n    J_direction = '1 0 0'\n    strain_energy_density = psie\n    displacements = 'disp_x disp_y'\n    boundary = 'top_half_left top_half_top top_half_right bottom_half_right bottom_half_bottom bottom_half_left'\n  []\n  [Jint_over_Gc]\n    type = ScalePostprocessor\n    value = 'Jint'\n    scaling_factor = '${fparse 1.0/Gc}'\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu       superlu_dist                 '\n  automatic_scaling = true\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-10\n\n  dt = 1e-2\n  end_time = 1e-1\n\n  fixed_point_max_its = 500\n  accept_on_max_fixed_point_iteration = false\n  fixed_point_rel_tol = 1e-3\n  fixed_point_abs_tol = 1e-5\n[]\n\n[Outputs]\n  exodus = true\n  file_base = L0.12_ahead-1meshd_ftol35eta0itr500zeta6\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/20073#discussioncomment-2008441",
                          "updatedAt": "2022-06-16T18:29:49Z",
                          "publishedAt": "2022-01-20T17:21:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "Here is the input file for subapp fracture\n[Mesh]\n  [top_half]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = ${nx}\n    ny = '${fparse ny/2}'\n    xmin = 0\n    xmax = ${length}\n    ymin = 0 #-25 #-50\n    ymax = '${fparse height/2}'\n    boundary_id_offset = 0\n    boundary_name_prefix = top_half\n  []\n  [top_stitch]\n    type = BoundingBoxNodeSetGenerator\n    input = top_half\n    new_boundary = top_stitch\n    bottom_left = '1 0 0'\n    top_right = '5 0 0'\n  []\n  [top_crack]\n    type = BoundingBoxNodeSetGenerator\n    input = top_stitch\n    new_boundary = top_crack\n    bottom_left = '0 0 0'\n    top_right = '1 0 0'\n  []\n  [bottom_half]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = ${nx}\n    ny = '${fparse ny/2}'\n    xmin = 0\n    xmax = ${length}\n    ymin = '${fparse -height/2}'\n    ymax = 0 # 25 # 50\n    boundary_id_offset = 7\n    boundary_name_prefix = bottom_half\n  []\n  [bottom_stitch]\n    type = BoundingBoxNodeSetGenerator\n    input = bottom_half\n    new_boundary = bottom_stitch\n    bottom_left = '1 0 0'\n    top_right = '5 0 0'\n  []\n  [bottom_crack]\n    type = BoundingBoxNodeSetGenerator\n    input = bottom_stitch\n    new_boundary = bottom_crack\n    bottom_left = '0 0 0'\n    top_right = '1 0 0'\n  []\n  [stitch]\n    type = StitchedMeshGenerator\n    inputs = 'top_crack bottom_crack'\n    stitch_boundaries_pairs = 'top_stitch bottom_stitch'\n  []\n  construct_side_list_from_node_list = true\n  [fix_point]\n    type = ExtraNodesetGenerator\n    input = stitch\n    new_boundary = fix_point\n    coord = '0 -2'\n  []\n  [crack_tip]\n    type = ExtraNodesetGenerator\n    input = fix_point\n    new_boundary = crack_tip\n    coord = '0 0 0'\n  []\n[]\n\n[Adaptivity]\n  marker = marker\n  initial_marker = marker\n  initial_steps = ${refine}\n  stop_time = 0\n  max_h_level = ${refine}\n  [Markers]\n    [marker]\n      type = BoxMarker\n      bottom_left = '0 -0.2 0' # 0.7\n      top_right = '5 0.2 0'\n      outside = DO_NOTHING\n      inside = REFINE\n    []\n  []\n[]\n\n[Variables]\n  [d]\n    [InitialCondition]\n      type = FunctionIC\n      function = 'if(y=0&x<=1,1,0)'\n    []\n  []\n[]\n\n[AuxVariables]\n  [bounds_dummy]\n  []\n  [psie_active]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [ce]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[Bounds]\n  [conditional]\n    type = ConditionalBoundsAux\n    variable = bounds_dummy\n    bounded_variable = d\n    fixed_bound_value = 0\n    threshold_value = 0.95\n  []\n  [upper]\n    type = ConstantBoundsAux\n    variable = bounds_dummy\n    bounded_variable = d\n    bound_type = upper\n    bound_value = 1\n  []\n[]\n\n[Kernels]\n  [diff]\n    type = ADPFFDiffusion\n    variable = d\n    fracture_toughness = Gc\n    regularization_length = l\n    normalization_constant = c0\n  []\n  [source]\n    type = ADPFFSource\n    variable = d\n    free_energy = psi\n  []\n[]\n\n[Materials]\n  [fracture_properties]\n    type = ADGenericConstantMaterial\n    prop_names = 'E K G lambda Gc l'\n    prop_values = '${E} ${K} ${G} ${Lambda} ${Gc} ${l}'\n  []\n  [degradation]\n    type = PowerDegradationFunction\n    f_name = g\n    function = (1-d)^p*(1-eta)+eta\n    phase_field = d\n    parameter_names = 'p eta '\n    parameter_values = '2 0'\n  []\n  [crack_geometric]\n    type = CrackGeometricFunction\n    f_name = alpha\n    function = 'd'\n    phase_field = d\n  []\n  [psi]\n    type = ADDerivativeParsedMaterial\n    f_name = psi\n    function = 'g*psie_active+(ce+Gc/c0/l)*alpha'\n    args = 'd psie_active ce'\n    material_property_names = 'alpha(d) g(d) Gc c0 l'\n    derivative_order = 1\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  automatic_scaling = true\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-10\n[]\n\n[Outputs]\n  print_linear_residuals = false\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/20073#discussioncomment-2008448",
                          "updatedAt": "2022-06-16T18:29:52Z",
                          "publishedAt": "2022-01-20T17:22:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so the meshes start the same right, but then the displacements modify them.\nDo they modify them the same way?\nCan you please try using a Projection transfer instead of a copy transfer?\nhttps://mooseframework.inl.gov/source/transfers/MultiAppProjectionTransfer.html",
                          "url": "https://github.com/idaholab/moose/discussions/20073#discussioncomment-2008898",
                          "updatedAt": "2022-06-16T18:29:52Z",
                          "publishedAt": "2022-01-20T18:29:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "Projection transfer does not have this error.\nWhat I do not understand is why ADStressDivergenceTensors with Copy transfer does not produce this error. The displacement also modifies the mesh there.",
                          "url": "https://github.com/idaholab/moose/discussions/20073#discussioncomment-2009783",
                          "updatedAt": "2022-07-26T05:58:04Z",
                          "publishedAt": "2022-01-20T20:40:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are the displacement exactly the same? Or is there more with one than the other?",
                          "url": "https://github.com/idaholab/moose/discussions/20073#discussioncomment-2009822",
                          "updatedAt": "2022-07-26T05:58:04Z",
                          "publishedAt": "2022-01-20T20:45:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "If ADDynamicStressDivergenceTensors with zeta=0 is equivalent to ADStressDivergenceTensors so that they produced the same displacement under the same prescribed boundary condition, then yes. ADDynamicStressDivergenceTensors with zeta=0 also produce this error when parallel computed",
                          "url": "https://github.com/idaholab/moose/discussions/20073#discussioncomment-2009897",
                          "updatedAt": "2022-07-26T05:58:04Z",
                          "publishedAt": "2022-01-20T20:58:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I suspect copy trasnfers dont like displaced meshes. I ll run some tests",
                          "url": "https://github.com/idaholab/moose/discussions/20073#discussioncomment-2009931",
                          "updatedAt": "2022-07-26T05:58:04Z",
                          "publishedAt": "2022-01-20T21:06:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "CriticalStrech Damage with NOSPD model",
          "author": {
            "login": "ppandit95"
          },
          "bodyText": "Dear MOOSE Community\nI wish to replicate a simulation done in Bond Based formulation using a NOSPD formulation that involves damage so I was wondering if it is possible to use critical stretch damage criteria with the NOSPD model although I understand that generally energy or stress-based criteria is used but since I am carrying out brittle fracture I just wanted to know if it is possible or I should go with the development of energy-based damage rule.\nMany Thanks\nPushkar",
          "url": "https://github.com/idaholab/moose/discussions/19991",
          "updatedAt": "2023-04-26T14:46:26Z",
          "publishedAt": "2022-01-10T05:33:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen @jiangwen84 any ideas",
                  "url": "https://github.com/idaholab/moose/discussions/19991#discussioncomment-1987203",
                  "updatedAt": "2023-04-26T14:46:26Z",
                  "publishedAt": "2022-01-18T01:36:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Afraid I can't help here, sorry...",
                          "url": "https://github.com/idaholab/moose/discussions/19991#discussioncomment-1993887",
                          "updatedAt": "2023-04-26T14:46:26Z",
                          "publishedAt": "2022-01-18T22:44:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@hchen139",
                          "url": "https://github.com/idaholab/moose/discussions/19991#discussioncomment-1993903",
                          "updatedAt": "2023-04-26T14:46:25Z",
                          "publishedAt": "2022-01-18T22:49:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hchen139"
                  },
                  "bodyText": "It is not a good option to use bond breakage criterion in NOSPD models. A damage model will work better.",
                  "url": "https://github.com/idaholab/moose/discussions/19991#discussioncomment-1999788",
                  "updatedAt": "2023-04-26T14:46:24Z",
                  "publishedAt": "2022-01-19T17:46:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ppandit95"
                          },
                          "bodyText": "Thanks @hchen139 for elaborating on that as in one of your published paper on BA NOSPD , a critical stretch damage model was used but it seems to give inaccurate results with NOSPD model as you suggested.",
                          "url": "https://github.com/idaholab/moose/discussions/19991#discussioncomment-2002755",
                          "updatedAt": "2023-04-26T14:46:24Z",
                          "publishedAt": "2022-01-20T04:16:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "how to change the dimension of sidesets\uff1f",
          "author": {
            "login": "amosaha"
          },
          "bodyText": "hello\uff0c\nBy the way I tried to get sidesets, I got a 3D network of sidesets index. I noticed that it is possible to use lowerLowerDBlockFromSidesetGenerator to convert 3D sidesets to 2D blocks, but can I turn this 2D block into 2D sidesets?Because I need to calculate the surface heat flux density, I need a 2D boundary. Looking forward to your answer.",
          "url": "https://github.com/idaholab/moose/discussions/20080",
          "updatedAt": "2022-07-05T17:56:45Z",
          "publishedAt": "2022-01-19T12:40:44Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI have not done or tested this before, but you should be able to create a 2D sideset from 2D block, at least for the sideset generators where this makes sense. If not, then it's a feature we should make sure to support.\nJust use whichever sideset generator you are wanting to use with the 2D block as the argument.\nPlease let us know how this goes,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-1998181",
                  "updatedAt": "2022-07-05T17:56:49Z",
                  "publishedAt": "2022-01-19T14:20:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "amosaha"
                          },
                          "bodyText": "Yes, only 2D blocks can be used to create 2D sidesets. At present, I have obtained such a 2D block through LowerDBlockFromSidesetGenerator. I would like to know if I can use this 2D plane block to turn it into a sideset. Searched almost all meshgenerator resources, I didn't find a suitable way.",
                          "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-1998419",
                          "updatedAt": "2022-07-05T17:57:05Z",
                          "publishedAt": "2022-01-19T14:49:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok just to be absolutely sure, it is '2D sideset' as in a 'sideset of a 2D block', so really a sideset made of 1D elements.\nCan you use this one for example?\nhttps://mooseframework.inl.gov/source/meshgenerators/SideSetsAroundSubdomainGenerator.html\nWith the block argument set to the 2D block you extracted ?",
                          "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-1998517",
                          "updatedAt": "2022-07-05T17:57:05Z",
                          "publishedAt": "2022-01-19T15:03:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "amosaha"
                  },
                  "bodyText": "I have tried using this type on my 2D block, and it resulted in the bounding of the 2d face. So if you use a rectangle block, the resulting sidesets are the four sides of the rectangle.\n\n\n\n\n\n\n\n\n\n\u53d1\u81ea\u6211\u7684iPhone\n\u2026\n------------------ Original ------------------\nFrom: Guillaume Giudicelli ***@***.***&gt;\nDate: Wed,Jan 19,2022 11:03 PM\nTo: idaholab/moose ***@***.***&gt;\nCc: amosaha ***@***.***&gt;, Author ***@***.***&gt;\nSubject: Re: [idaholab/moose] how to change the dimension of sidesets\uff1f (Discussion #20080)\n\n\n\n\n\n\nOk just to be absolutely sure, it is '2D sideset' as in a 'sideset of a 2D block', so really a sideset made of 1D elements.\n\nCan you use this one for example?\n https://mooseframework.inl.gov/source/meshgenerators/SideSetsAroundSubdomainGenerator.html\n With the block argument set to the 2D block you extracted ?\n\n\u2014\nReply to this email directly, view it on GitHub, or unsubscribe.\nTriage notifications on the go with GitHub Mobile for iOS or Android.\nYou are receiving this because you authored the thread.Message ID: ***@***.***&gt;",
                  "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-1998659",
                  "updatedAt": "2022-07-05T17:57:22Z",
                  "publishedAt": "2022-01-19T15:18:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Isnt that what you want?",
                          "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-1998817",
                          "updatedAt": "2022-07-05T17:57:28Z",
                          "publishedAt": "2022-01-19T15:36:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "amosaha"
                  },
                  "bodyText": "No, I want the sidesets of the whole plane.\n\n\n\n\n\u53d1\u81ea\u6211\u7684iPhone\n\u2026\n------------------ Original ------------------\nFrom: Guillaume Giudicelli ***@***.***&gt;\nDate: Wed,Jan 19,2022 11:36 PM\nTo: idaholab/moose ***@***.***&gt;\nCc: amosaha ***@***.***&gt;, Author ***@***.***&gt;\nSubject: Re: [idaholab/moose] how to change the dimension of sidesets\uff1f (Discussion #20080)\n\n\n\n\n\n\nIsnt that what you want?\n\n\u2014\nReply to this email directly, view it on GitHub, or unsubscribe.\nTriage notifications on the go with GitHub Mobile for iOS or Android.\nYou are receiving this because you authored the thread.Message ID: ***@***.***&gt;",
                  "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-2001893",
                  "updatedAt": "2022-07-05T17:57:29Z",
                  "publishedAt": "2022-01-20T00:23:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so you want a 2D surface?\nOr you want all the 1D elements in the 2D block?",
                          "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-2001920",
                          "updatedAt": "2022-07-05T17:57:32Z",
                          "publishedAt": "2022-01-20T00:34:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "amosaha"
                  },
                  "bodyText": "I want a 2d surface as the sidesets.\n\n\n\n\u53d1\u81ea\u6211\u7684iPhone\n\u2026\n------------------ Original ------------------\nFrom: Guillaume Giudicelli ***@***.***&gt;\nDate: Thu,Jan 20,2022 8:34 AM\nTo: idaholab/moose ***@***.***&gt;\nCc: amosaha ***@***.***&gt;, Author ***@***.***&gt;\nSubject: Re: [idaholab/moose] how to change the dimension of sidesets\uff1f (Discussion #20080)\n\n\n\n\n\n\nso you want a 2D surface?\n Or you want all the 1D elements in the 2D block?\n\n\u2014\nReply to this email directly, view it on GitHub, or unsubscribe.\nTriage notifications on the go with GitHub Mobile for iOS or Android.\nYou are receiving this because you authored the thread.Message ID: ***@***.***&gt;",
                  "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-2001922",
                  "updatedAt": "2022-07-05T17:57:33Z",
                  "publishedAt": "2022-01-20T00:36:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the use the sideset generators on the 3D mesh directly, not the lowerDblock...generator",
                          "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-2001991",
                          "updatedAt": "2022-07-05T17:57:34Z",
                          "publishedAt": "2022-01-20T01:00:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "amosaha"
                  },
                  "bodyText": "But the sidesets I get directly using 3D block are not really 2D faces, just an index of a 3D block.\n\n\u53d1\u81ea\u6211\u7684iPhone\n\u2026\n------------------ Original ------------------\nFrom: Guillaume Giudicelli ***@***.***&gt;\nDate: Thu,Jan 20,2022 9:00 AM\nTo: idaholab/moose ***@***.***&gt;\nCc: amosaha ***@***.***&gt;, Author ***@***.***&gt;\nSubject: Re: [idaholab/moose] how to change the dimension of sidesets\uff1f (Discussion #20080)\n\n\n\n\n\n\nthe use the sideset generators on the 3D mesh directly, not the lowerDblock...generator\n\n\u2014\nReply to this email directly, view it on GitHub, or unsubscribe.\nTriage notifications on the go with GitHub Mobile for iOS or Android.\nYou are receiving this because you authored the thread.Message ID: ***@***.***&gt;",
                  "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-2001997",
                  "updatedAt": "2022-07-05T17:57:36Z",
                  "publishedAt": "2022-01-20T01:02:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not sure what you mean by an index of a 3D block.\nThey are a collection of a 2D elements, which are faces of 3D elements.",
                          "url": "https://github.com/idaholab/moose/discussions/20080#discussioncomment-2002117",
                          "updatedAt": "2022-07-05T17:57:35Z",
                          "publishedAt": "2022-01-20T01:39:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Measuring FEP time",
          "author": {
            "login": "jinca"
          },
          "bodyText": "Hello dear MOOSE group,\nI found documentation of PETSc with regards to the performance in the output file.\nSee here.\nHowever, it seems quite outdated to me. Could you please enlighten me on this?\nHaving the following Performance Graph:\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n|                  Section                  | Calls |   Self(s)  |   Avg(s)   |    %   | Children(s) |   Avg(s)   |    %   |  Total(s)  |   Avg(s)   |    %   |\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n| pookaTestApp (main)                       |     1 |      0.015 |      0.015 |   0.00 |    1145.325 |   1145.325 | 100.00 |   1145.340 |   1145.340 | 100.00 |\n|   FEProblem::outputStep                   |     2 |      0.448 |      0.224 |   0.04 |       0.505 |      0.252 |   0.04 |      0.953 |      0.476 |   0.08 |\n|   Steady::PicardSolve                     |     1 |      0.000 |      0.000 |   0.00 |    1061.416 |   1061.416 |  92.67 |   1061.416 |   1061.416 |  92.67 |\n|     FEProblem::solve                      |     1 |   1000.687 |   1000.687 |  87.37 |      59.227 |     59.227 |   5.17 |   1059.914 |   1059.914 |  92.54 |\n|       FEProblem::computeResidualInternal  |     4 |      0.000 |      0.000 |   0.00 |       9.506 |      2.376 |   0.83 |      9.506 |      2.376 |   0.83 |\n|       FEProblem::computeJacobianInternal  |     2 |      0.000 |      0.000 |   0.00 |      49.711 |     24.856 |   4.34 |     49.711 |     24.856 |   4.34 |\n|     FEProblem::outputStep                 |     1 |      0.205 |      0.205 |   0.02 |       0.004 |      0.004 |   0.00 |      0.209 |      0.209 |   0.02 |\n|     AuxiliarySystem::computeElementalVars |     1 |      1.002 |      1.002 |   0.09 |       0.291 |      0.291 |   0.03 |      1.293 |      1.293 |   0.11 |\n|   Steady::final                           |     1 |      0.001 |      0.001 |   0.00 |       0.049 |      0.049 |   0.00 |      0.051 |      0.051 |   0.00 |\n|     FEProblem::outputStep                 |     1 |      0.043 |      0.043 |   0.00 |       0.006 |      0.006 |   0.00 |      0.049 |      0.049 |   0.00 |\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n1- Is it OK to consider the  'Avg(s)' column (penultimate column) of the raw 'FEProblem::solve' to plot my benchmarking?\n2- There is another block that determine performance and timing:\nSummary of Stages:   ----- Time ------  ----- Flop ------  --- Messages ---  -- Message Lengths --  -- Reductions --\n                        Avg     %Total     Avg     %Total    Count   %Total     Avg         %Total    Count   %Total\n 0:      Main Stage: 1.1462e+03 100.0%  2.8356e+12 100.0%  5.721e+05 100.0%  9.959e+04      100.0%  8.080e+02  99.1%\n\n------------------------------------------------------------------------------------------------------------------------\n\nIs the column after 'Main Stage:' the total time of my simulation?\nThanks in advance for the help!\nJulita",
          "url": "https://github.com/idaholab/moose/discussions/20083",
          "updatedAt": "2025-02-13T22:14:42Z",
          "publishedAt": "2022-01-19T21:25:53Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is the MOOSE perf graph, not the PETSc one. Documentation is here:\nhttps://mooseframework.inl.gov/source/outputs/PerfGraphOutput.html\n1- yes, since it's only called once for your case. Otherwise Total (s) is usually the better one.\n2- this does like a different perf graph. Is this the PETSc one? I've never seen that one.\nI reckon since you want to look at moose performance, you should stick to the moose one.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20083#discussioncomment-2001522",
                  "updatedAt": "2025-02-13T22:14:49Z",
                  "publishedAt": "2022-01-19T23:14:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Changing input file parameter from command line",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nIn an optimization problem, I am using Matlab script to run moose on wsl. I am using Matlab only to perform optimization while the actual simulation is done through moose. This is fine as long as the input file/s is not changing during the optimization process. Now, I need to loop over a parameter that requires changing kernel parameters as well as the boundary condition parameters within the input file.  For example, here is an example of what parameter do I need to modify in kernel and boundary conditions. Here, rate and coef are the parameters. As a note, let assume that the parameter that is changing is freq, then, coef= some factor * freq and rate = freq^2\n[reaction_imagy]\n        type = Reaction\n        variable = uyi\n        rate = -10000 this is the **(parameter)^2.**\n    []\n\n  [uxr_left]\n        type = CoupledVarNeumannBC\n        variable = uxr\n        boundary = '3'\n        v = uxi\n        coef=-100 this is the parameter or a some scaling of the parameter\n  []\n\nSo, how can I achieve this? Can I change an input parameter from the command line? Do I have other options? Also, How can I relate a parameter in the kernels section to a parameter in the boundary condition section?\nAny suggestions?",
          "url": "https://github.com/idaholab/moose/discussions/20085",
          "updatedAt": "2022-06-04T14:42:17Z",
          "publishedAt": "2022-01-19T22:23:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can change input parameters from the command line.\nfor example here: ./app-opt -i input_file.i reaction_imagy/rate=-10002 uxr_left/coef=-101\nYou can do the second thing by defining it at the top of the input file:\nvalue_to_use = 45\nand then in the kernel and in the BC:\n[reaction_imagy]\n        type = Reaction\n        variable = uyi\n        rate = ${value_to_use}\n    []\n\n  [uxr_left]\n        type = CoupledVarNeumannBC\n        variable = uxr\n        boundary = '3'\n        v = uxi\n        coef=${value_to_use}\n  []",
                  "url": "https://github.com/idaholab/moose/discussions/20085#discussioncomment-2001348",
                  "updatedAt": "2022-06-17T13:54:59Z",
                  "publishedAt": "2022-01-19T22:33:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Hello\nYou can change input parameters from the command line. for example here: ./app-opt -i input_file.i reaction_imagy/rate=-10002 uxr_left/coef=-101\nYou can do the second thing by defining it at the top of the input file:\nvalue_to_use = 45 and then in the kernel and in the BC:\n[reaction_imagy]\n        type = Reaction\n        variable = uyi\n        rate = ${value_to_use}\n    []\n\n  [uxr_left]\n        type = CoupledVarNeumannBC\n        variable = uxr\n        boundary = '3'\n        v = uxi\n        coef=${value_to_use}\n  []\n\n\nThank you, @GiudGiud .\nAnd I assume that I can multiply the value_to_use by some number to scale it or raise it to a power, Am I correct?\nsomething like:\n rate=(${value_to_use})^2\nand\ncoef=0.76 * ${value_to_use}",
                          "url": "https://github.com/idaholab/moose/discussions/20085#discussioncomment-2001370",
                          "updatedAt": "2022-06-17T13:55:41Z",
                          "publishedAt": "2022-01-19T22:39:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can but it takes a different syntax.\n${fparse value_to_use*value_to_use}",
                          "url": "https://github.com/idaholab/moose/discussions/20085#discussioncomment-2001401",
                          "updatedAt": "2022-08-26T23:08:37Z",
                          "publishedAt": "2022-01-19T22:46:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "here's the doc page for all this:\nhttps://mooseframework.inl.gov/application_usage/input_syntax.html",
                          "url": "https://github.com/idaholab/moose/discussions/20085#discussioncomment-2001409",
                          "updatedAt": "2022-08-26T23:08:37Z",
                          "publishedAt": "2022-01-19T22:48:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mixing AD kernels",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "Hey,\nI was wondering if someone could tell me what happens if I mix AD and non-AD kernels? My guess is that the jacobian would not be correct and cause convergence problems. Would this also cause MOOSE to converge to a different solution? Is there anything else that would happen? Obviously this is not recommended, but im trying to understand what happens under the hood of MOOSE.\nThanks,\nZack",
          "url": "https://github.com/idaholab/moose/discussions/20075",
          "updatedAt": "2022-06-14T14:52:32Z",
          "publishedAt": "2022-01-18T23:04:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFirst, if you are not using Newton's method, then nothing will change . (P) JFNK does not make use of AD because we don't have to form a Jacobian.\nEDIT: see discussion below for PJFNK\nThen if you are using Newton's method,\nIf your non-AD kernels have the Jacobian (diagonal and off-diagonal) contributions coded exactly, then it will not change anything. The Jacobian will still be exact, and will still be used the same way.\nIf the Jacobian is only coded partially or approximately, then it may or may not cause convergence problems that would not have been there when using AD. There's really no certainty though.\ndocs on AD:\nhttps://mooseframework.inl.gov/automatic_differentiation/#!\nIt'll not converge to a different solution though. The residual has not changed, and we're still converging to the (usually unique) solution that zeroes it out.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20075#discussioncomment-1994081",
                  "updatedAt": "2022-06-14T14:52:32Z",
                  "publishedAt": "2022-01-18T23:51:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@GiudGiud Is it accurate to say PJFNK doesn't use AD? I thought it still uses jacobian for preconditioning (well, it apparently depends on the specific preconditioner). I'm just curious.",
                          "url": "https://github.com/idaholab/moose/discussions/20075#discussioncomment-1994703",
                          "updatedAt": "2022-06-14T14:52:38Z",
                          "publishedAt": "2022-01-19T02:56:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Umm that could be.\nLet's tag @lindsayad to be sure",
                          "url": "https://github.com/idaholab/moose/discussions/20075#discussioncomment-1994804",
                          "updatedAt": "2022-06-14T14:52:38Z",
                          "publishedAt": "2022-01-19T03:24:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We use the diagonal of the Jacobian for preconditioning",
                          "url": "https://github.com/idaholab/moose/discussions/20075#discussioncomment-1995095",
                          "updatedAt": "2022-06-14T14:52:38Z",
                          "publishedAt": "2022-01-19T05:15:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yeah, that's the default I believe. If you use smp and specify full = true it'll use the entire Jacobian, in which case the incorrect Jacobian might affect convergence.",
                          "url": "https://github.com/idaholab/moose/discussions/20075#discussioncomment-1997596",
                          "updatedAt": "2022-07-09T09:54:23Z",
                          "publishedAt": "2022-01-19T12:58:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "@hugary1995 So if we change the default preconditioner for PJFNK to one what doesn't use the jacobian then we should be fine right?",
                          "url": "https://github.com/idaholab/moose/discussions/20075#discussioncomment-1998415",
                          "updatedAt": "2022-07-09T09:54:24Z",
                          "publishedAt": "2022-01-19T14:48:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "That's JFNK then. It depends on what you mean by \"should be fine\". It would be fine in the sense that mixing AD and nonAD kernels makes no difference. But I've had limited success with JFNK in practice.",
                          "url": "https://github.com/idaholab/moose/discussions/20075#discussioncomment-1999523",
                          "updatedAt": "2022-07-09T09:54:28Z",
                          "publishedAt": "2022-01-19T17:03:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Jacobian-free methods typically require preconditioning in order to be efficient. In theory you could converge to a solution in n-dof GMRES iterations without any preconditioning but there are some caveats there in practice I believe.\n@hugary1995 whether a kernel is AD or not doesn't make a difference with respect to whether a computeJacobian function will get called. If you have any solve method that constructs a matrix (NEWTON or PJFNK for example) then computeJacobian methods will get called for both non-AD and AD kernels. You really should not think of ADKernels and Kernels as being any different with the exception that you can be quite confident that the former will produce a 100% accurate Jacobian while the latter may or may not. If the latter is 100% accurate, then with respect to the solver the ADKernel and Kernel will appear completely equivalent.\nThere is one tricky thing that AD triggers for PJFNK. For the default AD container type, we compute the object Jacobian all at once and we add to the system Jacobian all at once. It is impossible (or it would be very difficult and slow) to filter out Jacobian contributions from specific variables. Consequently if you have any AD objects and you are using our default MOOSE configuration, you will be implicitly getting a full = true matrix all the time, e.g. if you requested only a diagonal matrix or if you asked for specific row-column coupling, we would ignore your request.\nPerhaps I should also note that if you specify solve_type = NEWTON then we also set full = true behind the scenes and this is true irrespective of whether there are any AD objects in the simulation. We do this because it only makes sense to use NEWTON if you are supplying all the variable couplings (e.g. complete and hopefully accurate Jacobian). A differenc here is that I believe we still honor requests for specific row-column couplings ... but it would be to your detriment.",
                          "url": "https://github.com/idaholab/moose/discussions/20075#discussioncomment-2000059",
                          "updatedAt": "2022-07-09T09:54:28Z",
                          "publishedAt": "2022-01-19T18:35:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You really should not think of ADKernels and Kernels as being any different with the exception that you can be quite confident that the former will produce a 100% accurate Jacobian while the latter may or may not. If the latter is 100% accurate, then with respect to the solver the ADKernel and Kernel will appear completely equivalent.\n\nThe op was assuming incorrect non-AD Jacobian.\nI agree with you otherwise.",
                          "url": "https://github.com/idaholab/moose/discussions/20075#discussioncomment-2000142",
                          "updatedAt": "2022-07-09T09:54:39Z",
                          "publishedAt": "2022-01-19T18:52:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Custom InterfaceKernel for permeation flux",
          "author": {
            "login": "lanzam213"
          },
          "bodyText": "My question relates to constructing a DGresidual and Jacobian for a custom interface kernel. I developed the interface kernel to satisfy a permeation flux model at a gas-solid interface. A summary of the problem approach and interface kernel is included below. Currently I'm stuck after looking at examples of interface kernels with DGresidual, including conjugateHeatTransfer, and attempting to solve this problem.  The solution converges but does not appear correct.\npermeation_example.i Input\npermeation_example.txt\nProblem summary\nPermeation_approach.pptx\nPermeationFLuxKernel.h\nPermeationFluxKernel.h.txt\n-Mark",
          "url": "https://github.com/idaholab/moose/discussions/20044",
          "updatedAt": "2023-02-06T20:29:33Z",
          "publishedAt": "2022-01-13T21:15:09Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf it converges but the result is incorrect, then the formula for the residual must be wrong.\nIf you replace the interface by boundary conditions, do you get acceptable results?\nIf so then there must be an issue with the interface kernel. What kind of fluxes do you have across the interface? Just diffusion? Looks like there is a constant term too?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20044#discussioncomment-1987229",
                  "updatedAt": "2023-02-06T20:29:39Z",
                  "publishedAt": "2022-01-18T01:47:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}