{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wMi0xMlQwMToyODoxOS0wNzowMM4AJ9RE"
    },
    "edges": [
      {
        "node": {
          "title": "Problem in analyzing the check point file",
          "author": {
            "login": "KamalnathOSU"
          },
          "bodyText": "Hi,\nI performed a KKS model based phase-field simulation. My simulation crashed after a few thousand numerical iterations due to numerical problems, i.e., solve did not converge. Hence, I wanted to view the checkpoint file to check the status of the non-linear variables just before the failed iteration. As paraview can't open *.xdr format, I wrote a dummy restart file which will read the *.xdr file and create a exodus file from it (shown below).  I followed the Variable Initialization approach given in  Restart and Recovery page .\nBut I am getting a error (\"ERROR: Unknown element type 2\") while trying to run it.\nMy input script:\n[GlobalParams]\n        initial_from_file_timestep = 'LATEST'\n[]\n\n[Mesh]\n        file = 'sub_111_out_cp/5726.xdr'\n        distribution = 'parallel'\n[]\n\n\n[Variables]\n\n  # order parameter\n  [./eta]\n    order = FIRST\n    family = LAGRANGE\n    initial_from_file_var = 'eta'\n  [../]\n\n  # solute concentration\n  [./c]\n    order = FIRST\n    family = LAGRANGE\n    initial_from_file_var = 'c'\n  [../]\n\n  # chemical potential\n  [./w]\n    order = FIRST\n    family = LAGRANGE\n    initial_from_file_var = 'w'\n  [../]\n\n  # Liquid phase solute concentration\n  [./cl]\n    order = FIRST\n    family = LAGRANGE\n    initial_from_file_var = 'cl'\n  [../]\n  # Solid phase solute concentration\n  [./cs]\n    order = FIRST\n    family = LAGRANGE\n    initial_from_file_var = 'cs'\n  [../]\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = 'PJFNK'\n  automatic_scaling = true\n\n  petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      ilu          nonzero'\n\n  l_max_its = 100\n  nl_max_its = 100\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-50\n[]\n\n[Outputs]\n  [./exo]\n      type = Exodus\n  [../]\n[]\n\n[Preconditioning]\n  [./full]\n    type = SMP\n    full = true\n  [../]\n[]\n[Kernels]\n\n        [./cl]\n                type = NullKernel\n                variable = cl\n        [../]\n        [./cs]\n                type = NullKernel\n                variable = cs\n        [../]\n        [./c]\n                type = NullKernel\n                variable = c\n        [../]\n        [./eta]\n                type = NullKernel\n                variable = eta\n        [../]\n        [./w]\n                type = NullKernel\n                variable = w\n        [../]\n\n[]\n\nError Message:\nBuilding mesh ......................................                                       [ 39.12 s]\nERROR: Unknown element type 2\nStack frames: 19\n0: libMesh::print_trace(std::ostream&)\n1: libMesh::MacroFunctions::report_error(char const*, int, char const*, char const*)\n2: libMesh::FEAbstract::get_refspace_nodes(libMesh::ElemType, std::vector<libMesh::Point, std::allocator<libMesh::Point> >&)\n3: libMesh::FE<1u, (libMesh::FEFamily)0>::side_map(libMesh::Elem const*, libMesh::Elem const*, unsigned int, std::vector<libMesh::Point, std::allocator<libMesh::Point> > const&, std::vector<libMesh::Point, std::allocator<libMesh::Point> >&)\n4: libMesh::FE<1u, (libMesh::FEFamily)0>::reinit(libMesh::Elem const*, unsigned int, double, std::vector<libMesh::Point, std::allocator<libMesh::Point> > const*, std::vector<double, std::allocator<double> > const*)\n5: MaxQpsThread::operator()(libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> const&)\n6: /users/PAS1784/sarita/projects/moose/framework/libmoose-opt.so.0(+0xed8fe7) [0x2ad98616ffe7]\n7: GOMP_parallel\n8: void libMesh::Threads::parallel_reduce<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*>, MaxQpsThread>(libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> const&, MaxQpsThread&)\n9: FEProblemBase::updateMaxQps()\n10: SetupQuadratureAction::act()\n11: Action::timedAct()\n12: ActionWarehouse::executeActionsWithAction(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)\n13: ActionWarehouse::executeAllActions()\n14: MooseApp::runInputFile()\n15: MooseApp::run()\n16: /users/PAS1784/sarita/projects/horse/problems/Pitting_corrosion_data/batch_ori_t04/horse-opt() [0x4024d5]\n17: __libc_start_main\n18: /users/PAS1784/sarita/projects/horse/problems/Pitting_corrosion_data/batch_ori_t04/horse-opt() [0x4026fe]\n[0] /opt/moose/scripts/../libmesh/src/fe/fe_abstract.C, line 610, compiled Oct 14 2020 at 05:18:05\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\n\nAny help will be appreciated.\nThank you,\nKamal",
          "url": "https://github.com/idaholab/moose/discussions/16910",
          "updatedAt": "2022-06-23T20:10:45Z",
          "publishedAt": "2021-02-06T23:50:12Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Kamal,\nCan you try with '  distribution = serial' in the mesh block?\nDid you use the same element type in the first run?\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16910#discussioncomment-366641",
                  "updatedAt": "2022-06-23T20:10:59Z",
                  "publishedAt": "2021-02-13T20:55:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "KamalnathOSU"
                  },
                  "bodyText": "With distribution = 'serial' also I am getting the same error. What is the meaning of \"distribution \" parameter ? I am running the input script with 10 MPI processes with each 4 thread. Does serial mean, that the entire mesh will be saved in each of the 40 sub-process ?\nBuilding mesh .................................................................            [ 66.54 s]\nERROR: Unknown element type 2\n[1] /opt/moose/scripts/../libmesh/src/fe/fe_abstract.C, line 610, compiled Oct 14 2020 at 05:18:05\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 1\nsrun: Job step aborted: Waiting up to 32 seconds for job step to finish.\nslurmstepd: error: *** STEP 2970931.2 ON p0004 CANCELLED AT 2021-02-14T13:14:58 ***\nsrun: error: p0004: tasks 0-9: Killed\n\nYes. I always use Linear Lagrange elements.\nIs there a way to view the checkpoint files directly ?",
                  "url": "https://github.com/idaholab/moose/discussions/16910#discussioncomment-368134",
                  "updatedAt": "2022-06-23T20:11:01Z",
                  "publishedAt": "2021-02-14T18:30:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "For what you want to do, you could simply add execute_on = 'LINEAR NONLINEAR' to your exodus block, so that all variables will be written to exodus at every linear and nonlinear iteration.",
                  "url": "https://github.com/idaholab/moose/discussions/16910#discussioncomment-368299",
                  "updatedAt": "2022-06-23T20:11:01Z",
                  "publishedAt": "2021-02-14T19:45:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "But my problem is not with the exodus file. During my simulation, at some time, my solve is not converging. Hence, I want to view the checkpoint file in paraview to see which non-linear variable caused the crash.\nDo you know of any way to print all the non-linear variables in my simulation  just before the  failed convergence ?",
                          "url": "https://github.com/idaholab/moose/discussions/16910#discussioncomment-368377",
                          "updatedAt": "2022-06-23T20:11:01Z",
                          "publishedAt": "2021-02-14T20:23:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "A couple of suggestions:\n-If you suspect one particular variable is causing the convergence problems, you will probably have better luck isolating it by looking at the variable contributions to the residual rather than actually trying to visualize the variables during the solve. You can track this by adding the following Debug block:\n[Debug]\n   show_var_residual_norms = true\n[]\n\n-Are you sure that the simulation has not reached steady-state? If you use the default absolute convergence criterion of nl_abs_tol = 1e-50 and don't turn on steady-state detection, the solve can fail if you reach steady state because the solver cannot meet either the absolute or relative convergence tolerance. Have a look at your microstructure prior to the point and which you get the failed solve and see if there is any microstructure evolution happening.\n-If neither of these helps you might try the new automatic variable scaling option. Set automatic_scaling = true in the Executioner block.",
                  "url": "https://github.com/idaholab/moose/discussions/16910#discussioncomment-371833",
                  "updatedAt": "2022-06-23T20:11:01Z",
                  "publishedAt": "2021-02-15T21:33:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problems with make after using stork.",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "After using stork to create an application I get the following error after using the command make -j4:\nIn member function 'virtual void PhysicsBasedPreconditioner::init()':\n/home/twise/projects/moose/framework/src/preconditioners/PhysicsBasedPreconditioner.C:209:41: error: 'class libMesh::LinearImplicitSystem' has no member named 'get_system_matrix'; did you mean 'add_system_matrix'?\npreconditioner->set_matrix(u_system.get_system_matrix());\n^~~~~~~~~~~~~~~~~\nWhat should I do to fix this problem.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/16988",
          "updatedAt": "2022-11-02T10:03:18Z",
          "publishedAt": "2021-02-13T19:39:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nMost libmesh-related compilation issues are usually resolved by updating libmesh.\nIf you installed with ana/miniconda just run 'conda update --all' in the moose environment\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-366611",
                  "updatedAt": "2022-11-02T10:03:18Z",
                  "publishedAt": "2021-02-13T20:34:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for the advice on this issue. I ran the 'conda update --all' and the software informed me that all the updates were current. I also ran 'conda update -n base -c defaults conda', which did some additional installs, but still results in the same errors with the 'make -j4' command.",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-366632",
                          "updatedAt": "2021-02-13T20:50:29Z",
                          "publishedAt": "2021-02-13T20:50:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Did you have a previous moose install before this one? Any chance a LIBMESH_DIR environment variable is set to a previously installed libmesh?\nAre you on the latest moose master commit?",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-366656",
                          "updatedAt": "2021-02-13T21:02:43Z",
                          "publishedAt": "2021-02-13T21:02:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "I did have a previous install that I believed was totally uninstalled, but may not have been properly done. What can I do to ensure there are not remnants of a previous install, outside of reinstalling Ubuntu?",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-366665",
                          "updatedAt": "2021-02-13T21:05:53Z",
                          "publishedAt": "2021-02-13T21:05:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would check MOOSE_DIR and LIBMESH_DIR (echo $MOOSE_DIR, echo ..) to see if they are not pointing somewhere from the previous installation.\nJust to check, you ran 'conda update --all' after having activated the moose conda environment right?",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-366680",
                          "updatedAt": "2022-11-02T10:03:21Z",
                          "publishedAt": "2021-02-13T21:19:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Also maybe check CPATH, C_INCLUDE_PATH, CPLUS_INCLUDE_PATH if you had set those (I dont think you would have) at the time",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-366684",
                          "updatedAt": "2023-01-27T19:28:09Z",
                          "publishedAt": "2021-02-13T21:20:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Yes. I ran each command after having executed \"conda activate moose\". I will check each of the files you indicated to see if the are pointing to a previous install.\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-366685",
                          "updatedAt": "2023-01-27T19:28:09Z",
                          "publishedAt": "2021-02-13T21:21:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "echo $LIBMESH_DIR results in this:\n/home/twise/miniconda3/envs/moose/libmesh\necho $MOOSE_DIR results in a null result. I believe this indicates the working directory is the directory.",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-366697",
                          "updatedAt": "2023-01-27T19:28:09Z",
                          "publishedAt": "2021-02-13T21:29:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This all seems normal to me. I don't know what's wrong then. Someone else will have to weigh in.",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-366758",
                          "updatedAt": "2023-01-27T19:28:09Z",
                          "publishedAt": "2021-02-13T22:16:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "You\u2019ve updated libmesh but you haven\u2019t updated moose. The libmesh you\u2019ve updated to within conda is no longer with the moose you have.\nIf you need help with this using git - let us know.",
                  "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-367652",
                  "updatedAt": "2023-01-27T19:28:10Z",
                  "publishedAt": "2021-02-14T14:22:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you. Where can I find the directions to remove an old installation of moose?",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-371308",
                          "updatedAt": "2023-01-27T19:28:11Z",
                          "publishedAt": "2021-02-15T18:01:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "The following should work:\ncd /home/twise/projects/moose\ngit pull\n\nThis should work if the origin remote of your moose installation is idaholab/moose, which will be the case if you used the getting started pages on mooseframework.org. git pull will fetch the new commits from idaholab, and merge them into the branch that you are currently on.",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-371386",
                          "updatedAt": "2023-01-27T19:28:11Z",
                          "publishedAt": "2021-02-15T18:35:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "TLWise"
                  },
                  "bodyText": "Thank you for advising me on how to solve this issue. Prior to your last bit of advise, I had already executed the conda uninstall of moose. I then attempted to reinstall moose via conda create. That did not go so well. In the end I went back to the mooseframework web page and went down the list of instructions for installing moose. After the install  Make -j4 and run_test executed with no problems.\n\n\nGet Outlook for iOS<https://aka.ms/o0ukef>\n\u2026\n________________________________\nFrom: Logan Harbour <notifications@github.com>\nSent: Monday, February 15, 2021 1:35:51 PM\nTo: idaholab/moose <moose@noreply.github.com>\nCc: WISE, TAMMY <wisetl@email.sc.edu>; Author <author@noreply.github.com>\nSubject: Re: [idaholab/moose] Problems with make after using stork. (#16988)\n\n\nThe following should work:\n\ncd /home/twise/projects/moose\ngit pull\n\n\nThis should work if the origin remote of your moose installation is idaholab/moose, which will be the case if you used the getting started pages on mooseframework.org. git pull will fetch the new commits from idaholab, and merge them into the branch that you are currently on.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub<https://protect2.fireeye.com/v1/url?k=874fffa9-d8d4c6aa-874fb168-86aa398f0cb5-ed253c1bfa8c56d6&q=1&e=550d3252-adf8-424f-aeed-3b05d25aad20&u=https%3A%2F%2Fgithub.com%2Fidaholab%2Fmoose%2Fdiscussions%2F16988%23discussioncomment-371386>, or unsubscribe<https://protect2.fireeye.com/v1/url?k=5254c457-0dcffd54-52548a96-86aa398f0cb5-679e7e865596f210&q=1&e=550d3252-adf8-424f-aeed-3b05d25aad20&u=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAJQ6AYROU66NYH3DLQE2GIDS7FSQPANCNFSM4XSOENGQ>.",
                  "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-371652",
                  "updatedAt": "2023-01-27T19:28:11Z",
                  "publishedAt": "2021-02-15T20:18:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "Glad to help!\nHere, it's important to note that our default conda instructions provide an environment for compiling moose (by providing its dependencies and a compiled version of libmesh). To update, you do not need to remove and \"re-install\" everything. You simply need to update conda with conda update --all and update your moose repository (typically with git pull).",
                          "url": "https://github.com/idaholab/moose/discussions/16988#discussioncomment-371721",
                          "updatedAt": "2023-01-27T19:28:13Z",
                          "publishedAt": "2021-02-15T20:49:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "controlling inheritance between auxkernels",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nI was sure my question have been already asked (therefore I do apologize for the multiple posting), but I could not find anything similar in the discussion forum ...\nMy question: Is there any way to control the order of inheritance among different auxkernels/variables?\nProblem: I have an auxkernel (aux_1) that computes the difference between the value of an auxvariable over time (u-u_old) where the auxvariable is provided by a different auxkernel (aux_0). This said, I need to force the computation of the latter (aux_0) to be done before I am calling it inside aux_1.\nThe main issue I see is that both kernels must be computed  at timestep_end since aux_0 requires the values of a material property and I want to pass the final value of the same quantity. I know I could do the same computation at a material level, but still I would love it to be done at the auxkernel level if possible.\nAny help would be highly appreciated,\nMauro",
          "url": "https://github.com/idaholab/moose/discussions/16996",
          "updatedAt": "2023-08-21T14:11:41Z",
          "publishedAt": "2021-02-15T12:31:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "You mean \"order of execution\". MOOSE has a basic \"dependency resolution\" system built in to compute things that it knows about in the right order. As long as your execute_on matches and you use normal coupling syntax to link to variables that you depend on, objects will be computed in the right order. You can find several tests in our suite that demonstrate that execution order is handled:\nhttps://github.com/idaholab/moose/tree/next/test/tests/auxkernels/element_aux_var",
                  "url": "https://github.com/idaholab/moose/discussions/16996#discussioncomment-370910",
                  "updatedAt": "2023-08-21T14:11:41Z",
                  "publishedAt": "2021-02-15T15:45:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Thanks, and of course \"execution order\" is the right word. Will test my auxkernels and let you know in case I have any problems.\nThanks again,\nMauro",
                          "url": "https://github.com/idaholab/moose/discussions/16996#discussioncomment-371286",
                          "updatedAt": "2023-08-21T14:11:51Z",
                          "publishedAt": "2021-02-15T17:54:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "(De)Insertion of species into domain - boundary flux",
          "author": {
            "login": "souzanha"
          },
          "bodyText": "Hello Moose community,\nI have a few questions regarding boundary conditions - species flux.\nI've been looking at this paper: https://pubs.rsc.org/en/content/articlehtml/2020/ta/c9ta11697d\nwhere they define the reaction rate at one boundary using the Butler-Volmer equation (6). This flux of ions depends on the chemical potential variable which is solved from the Cahn-Hilliard equation.\nIn short, I want to define a function at a boundary using the variable values at that boundary. Any hints on how to move forward? Looking forward to some inputs! :)",
          "url": "https://github.com/idaholab/moose/discussions/16984",
          "updatedAt": "2022-06-23T14:34:14Z",
          "publishedAt": "2021-02-12T17:10:07Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf this boundary condition is not in the phase field module already, it looks like you want to be creating a new boundary condition.\nYou can look at CoupledVarNeumannBC for inspiration. Someone with more experience with the phase field module and the Butler-Volmer equation may be able to recommend a better example or a boundary condition class your new one could inherit from.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16984#discussioncomment-366624",
                  "updatedAt": "2022-06-23T14:34:16Z",
                  "publishedAt": "2021-02-13T20:40:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "srinath-chakravarthy"
                          },
                          "bodyText": "Butler-volmer is sort of like a RobinBc .. see if this will serve as inspiration for you.\n/*\n * Copyright (C) 2020 srinath\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/* \n * File:   ADButlerVolmerBC.C\n * Author: srinath\n * \n * Created on October 20, 2020, 8:25 AM\n */\n\n#include \"ADButlerVolmerBC.h\"\n\n#include \"Function.h\"\n\n\nregisterMooseObject(\"electro_chemo_mechApp\", ADButlerVolmerBC);\n\nInputParameters\nADButlerVolmerBC::validParams()\n{\n    InputParameters params = ADIntegratedBC::validParams();\n    params.addRequiredParam<Real>(\"exchange_current_density\", \"Value of exchange\"\n            \"current density\");\n    params.addParam<Real>(\"faraday\", 96485.3329, \"Faraday's Constant\");\n    params.addParam<Real>(\"R\", 8.3145, \"Universal Gas Constant\");\n    params.addParam<Real>(\"Temperature\", 298, \"Value of temperature to use\");\n    params.addParam<Real>(\"current_density\", \"Applied Current Density\");\n    params.addParam<FunctionName>(\"current_density_function\", \"\", \"Function for current density\");\n    return params;\n}\n\nADButlerVolmerBC::ADButlerVolmerBC(const InputParameters & parameters)\n        : ADIntegratedBC(parameters),\n        _i0(getParam<Real>(\"exchange_current_density\")),\n        _faraday(getParam<Real>(\"faraday\")),\n        _gas_constant(getParam<Real>(\"R\")),\n        _temp(getParam<Real>(\"Temperature\")),\n        _current(isParamValid(\"current_density\") ? getParam<Real>(\"current_density\") : 0), \n        _equilibrium_potential(&getADMaterialProperty<Real>(\"equilibrium_potential\") ? &getADMaterialProperty<Real>(\"equilibrium_potential\") : NULL), \n        _func(getParam<FunctionName>(\"current_density_function\") != \"\" \n                            ? &getFunction(\"current_density_function\") : NULL)\n{\n    if (isParamValid(\"current_density\") && _func)\n    {\n        mooseError(\"Cannot define both current density and current density function\");\n    }\n}\n\nADReal\nADButlerVolmerBC::computeQpResidual()\n{\n    auto prefac = 0.5*_faraday/(_gas_constant * _temp);\n    auto deltaPhi = prefac * _u[_qp];\n    if (_equilibrium_potential)\n        deltaPhi -= prefac * (*_equilibrium_potential)[_qp];\n    auto fac = std::exp(deltaPhi) - std::exp(-deltaPhi);\n    ADReal i = 0;\n    if (isParamValid(\"current_density\"))\n        i = _current;\n    if (_func)\n        i = _func->value(_t, _q_point[_qp]);\n    return (i - _i0 * fac) * _test[_i][_qp];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/16984#discussioncomment-366631",
                          "updatedAt": "2022-06-23T14:34:19Z",
                          "publishedAt": "2021-02-13T20:49:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Thank you! This is a great push towards the right direction.",
                          "url": "https://github.com/idaholab/moose/discussions/16984#discussioncomment-369524",
                          "updatedAt": "2022-06-23T14:34:21Z",
                          "publishedAt": "2021-02-15T07:41:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Initializing the _hist material property for the phase field fracture model from the input file",
          "author": {
            "login": "Aoiosamas"
          },
          "bodyText": "Hello all,\nI have a question regarding the history variable approach used in the phase field fracture model in MOOSE, when I have a distribution of preexisting cracks. The question is about the initialization of the _hist material property. According to this post (https://groups.google.com/g/moose-users/c/Bf_nkvs-j3k/m/yXib3yPMBwAJ), I have to hard code ComputeIsotropicLinearElasticPFFractureStress::initQpStatefulProperties() function, if I'm not interested in creating the cracks in the mesh itself (real cracks). I was wondering if it has become possible somehow to initialize this history variable in the input time, e.g., using an Auxillary variable or a material property. Any insights/suggestions are really appreciated.\nThank you,\nAhmed",
          "url": "https://github.com/idaholab/moose/discussions/16991",
          "updatedAt": "2023-02-10T17:48:43Z",
          "publishedAt": "2021-02-14T13:34:04Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Do you have to use a history field? I recommend against it. Instead, it's better to apply initial condition on c, and enforce the irreversibility using VariableOldValueBoundsAux.\nNow, if you insist on using history to initialize the crack, you can take a look at this PR: #15102 which tried to do what you are describing here. It seems to me that PR was really close to be merged, I don't know why it got closed in the end. Like I said there, I'm not a big fan of the history approach, but I also have no objection in us supporting that capability.",
                  "url": "https://github.com/idaholab/moose/discussions/16991#discussioncomment-367650",
                  "updatedAt": "2023-02-10T17:48:55Z",
                  "publishedAt": "2021-02-14T14:21:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Aoiosamas"
                          },
                          "bodyText": "This is very helpful. Thank you so much.",
                          "url": "https://github.com/idaholab/moose/discussions/16991#discussioncomment-367818",
                          "updatedAt": "2023-02-10T17:48:56Z",
                          "publishedAt": "2021-02-14T15:47:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Discrepancy in analytic solution",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi All\nGot a weird one here, sure its a simple one but I can't seem to figure it. Im trying to reproduce a validation from Code_Aster EDF's thermo-mechanical code, which can easily be viewed here - https://www.simscale.com/docs/validation-cases/hollow-sphere-convection-radiation/\nI reproduced the geometry in Trelis, applied the same boundary conditions, and setup the problem, correctly as far as I can tell.\nHowever, running the simulation with 1st and 2nd order hexes, I see a consistent difference between the analytic solution from - https://www.code-aster.org/doc/default/fr/man_v/v4/v4.43.001.pdf - of about 3 degrees on the hot surface and 2 degrees on the cooler surface. Ive done this with a tabualated and explicit function to describe the heat flux on the radiative surface but give very similar results.\nAny tips/suggestions appreciated.\nreactor.zip\nThanks\nAndy",
          "url": "https://github.com/idaholab/moose/discussions/16979",
          "updatedAt": "2022-09-06T18:28:45Z",
          "publishedAt": "2021-02-12T14:44:32Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Your radiation BC is wrong. I modified your input and it works:\n[Mesh]\n  type = FileMesh\n  file = '../mesh/reactor.e'\n[]\n\n[Variables]\n  [temp]\n  []\n[]\n\n[AuxVariables]\n  [temp_in_C]\n  []\n  [radiation_flux]\n  []\n[]\n\n[Kernels]\n  [heat]\n    type = HeatConduction\n    variable = temp\n  []\n[]\n\n[AuxKernels]\n  [K_to_C]\n    type = ParsedAux\n    variable = 'temp_in_C'\n    function = 'temp-273.15'\n    args = 'temp'\n  []\n  [radiation]\n    type = ParsedAux\n    variable = radiation_flux\n    args = 'temp'\n    function = 'sigma*epsilon*(start_t^4 - temp^4)'\n    constant_names = 'sigma epsilon start_t'\n    constant_expressions = '5.73e-8 0.6 773.15'\n  []\n[]\n\n[BCs]\n  [abcd]\n    type = CoupledConvectiveHeatFluxBC\n    boundary = 'abcd'\n    variable = temp\n    htc = '133.5'\n    T_infinity = 293.15\n  []\n  [efgh]\n    type = CoupledNeumannBC\n    variable = temp\n    boundary = 'efgh'\n    coupled_var = 'radiation_flux'\n  []\n[]\n\n[Materials]\n  [density]\n    type = GenericConstantMaterial\n    prop_names = 'density  thermal_conductivity cp'\n    prop_values = '1 40 1'\n  []\n[]\n\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  automatic_scaling = true\n  type = Steady\n  petsc_options = '-snes_converged_reason'\n  petsc_options_iname = '-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart'\n  petsc_options_value = 'asm lu 1 101'\n  line_search = none\n[]\n\n[Postprocessors]\n  [external_surf_ave]\n    type = SideAverageValue\n    variable = temp_in_C\n    boundary = 'abcd'\n  []\n  [internal_surf_ave]\n    type = SideAverageValue\n    variable = temp_in_C\n    boundary = 'efgh'\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/16979#discussioncomment-363295",
                  "updatedAt": "2022-09-06T18:28:48Z",
                  "publishedAt": "2021-02-12T16:25:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Thanks @hugary1995 thats what I needed! I need to make one change to your input, for whatever reason I dont see that BC type being available, neither does the documentation. I had to use\n    type = CoupledVarNeumannBC\n    v = 'radiation_flux'\n\nBut other than that, can confirm that this gives what I was after! Superb!\nOnly one question really, what was incorrect about my original functionneumanbc, shouldn't it behave the same way? What am I missing?",
                          "url": "https://github.com/idaholab/moose/discussions/16979#discussioncomment-364180",
                          "updatedAt": "2022-09-06T18:28:57Z",
                          "publishedAt": "2021-02-12T22:22:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Oh my bad, that CoupledNeumannBC is something from my app, sorry for the confusion.\nI'm on my phone so cannot confirm this, but I remember you originally used sigma epsilon (T0^4 - x^4), but the equation should really be sigma epsilon (T0^4 - T^4). This is a robin BC strictly speaking.",
                          "url": "https://github.com/idaholab/moose/discussions/16979#discussioncomment-364248",
                          "updatedAt": "2022-09-06T18:28:58Z",
                          "publishedAt": "2021-02-12T22:47:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to change an element inside a RankTwoTensor?",
          "author": {
            "login": "pharshaad"
          },
          "bodyText": "Hi all,\nI was wondering how I can change a particular element inside a RankTwoTensor. To give a little perspective,  I have a material that computes an ADRankTwoTensor consisting of the gradient of some variable. More specifically,\nvoid\nADComputeSomeQuantity::computeQpProperties()\n{\n  ADRankTwoTensor A((*_grad_ref[0])[_qp], (*_grad_ref[1])[_qp], (*_grad_ref[2])[_qp]);\n}\n\nThe goal is to inverse this tensor to get something like _some_quantity[_qp] = A.inverse();\nSince I'm working in 2-D at the moment, the 3rd row and the 3rd column of tensor A is zero which makes it singular. I was wondering if there's a way to access a particular element to change for example A_33 to something non-zero.\nThanks,\nLeon",
          "url": "https://github.com/idaholab/moose/discussions/16981",
          "updatedAt": "2022-11-04T07:03:34Z",
          "publishedAt": "2021-02-12T16:14:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can do\nA(2, 2) = 1;\nMOOSE RankTwoTensor doxygen can be found here: https://mooseframework.inl.gov/docs/doxygen/moose/classRankTwoTensorTempl.html.\nRankTwoTensor extends libMesh's TypeTensor:\nhttps://libmesh.github.io/doxygen/classlibMesh_1_1TypeTensor.html.\nIn your case, what you are looking for is the operator() in TypeTensor.",
                  "url": "https://github.com/idaholab/moose/discussions/16981#discussioncomment-363342",
                  "updatedAt": "2022-11-04T07:03:35Z",
                  "publishedAt": "2021-02-12T16:35:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pharshaad"
                          },
                          "bodyText": "Thanks for the tip Gary! Much appreciated.",
                          "url": "https://github.com/idaholab/moose/discussions/16981#discussioncomment-363840",
                          "updatedAt": "2022-11-04T07:03:41Z",
                          "publishedAt": "2021-02-12T19:27:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Creating a circular sideset",
          "author": {
            "login": "KamalnathOSU"
          },
          "bodyText": "Dear all,\nI am trying to define to define a circular sideset called 'exterior' at the front boundary. I am using ParsedGenerateSideset to do it. But I am getting only a square sideset. I am guessing that \"ParsedGenerateSideset\" is performed before refinement.  Can we make it happen after refinement ?\nBelow is my input mesh script\nxcenter=0\nycenter=0\nradius_oxide=5\n\n[Mesh]\nuniform_refine = 3\n        [./gmg]\n  type = GeneratedMeshGenerator\n  dim = 3\n  nx = 16\n  ny = 16\n  nz = 8\n  xmin = -32\n  xmax = 32\n  ymin = -32\n  ymax = 32\n  zmin = 0\n  zmax = 32\n  elem_type = HEX8\n        [../]\n        [./sideset]\n   type = ParsedGenerateSideset\n   input = gmg\n   combinatorial_geometry = ' (x-${xcenter})^2+(y-${ycenter})^2<=${radius_oxide}*${radius_oxide} & z<1 '\n   normal = '0 0 -1'\n   new_sideset_name = exterior\n        [../]\n[]\n\n\nThis is the 'exterior' sideset I got .\n\nRegards,\nKamal",
          "url": "https://github.com/idaholab/moose/discussions/16980",
          "updatedAt": "2022-10-20T19:13:26Z",
          "publishedAt": "2021-02-12T16:03:11Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Kamal,\nNot that I know of. In the future I think the refinement may become its own mesh generator, since there is definitely a valid use case for refining in between generation steps, or refining blocks selectively (though some of that overlaps with what adaptivity can provide).\nFor your problem, I would speficy : nx, ny and nz with ${fparse int(8 * 2^factor)} and just set factor at the beginning of the input file.\nHope this helps,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16980#discussioncomment-363601",
                  "updatedAt": "2022-10-20T19:13:33Z",
                  "publishedAt": "2021-02-12T18:04:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "KamalnathOSU"
                  },
                  "bodyText": "Thank you.",
                  "url": "https://github.com/idaholab/moose/discussions/16980#discussioncomment-363675",
                  "updatedAt": "2022-10-20T19:13:35Z",
                  "publishedAt": "2021-02-12T18:34:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Output the energy contribution for different terms",
          "author": {
            "login": "emmelines"
          },
          "bodyText": "Hi,\nI set up a simulation base on the Phase-field model which combines the Cahn-Hillard and Allen-Cahn equation.\nAnd now I would like to see the free energy change for only one term(Like composition only) How should I set it up?\nThank you.\nbest,\nEmmeline",
          "url": "https://github.com/idaholab/moose/discussions/16977",
          "updatedAt": "2024-05-29T23:39:43Z",
          "publishedAt": "2021-02-12T03:15:01Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "Perhaps you could use the TotalFreeEnergy AuxKernel and just pass it your concentration variable and its gradient coefficient. Then integrate the AuxVariable with a postprocessor to see the total energy change.",
                  "url": "https://github.com/idaholab/moose/discussions/16977#discussioncomment-362997",
                  "updatedAt": "2024-05-29T23:40:44Z",
                  "publishedAt": "2021-02-12T14:54:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem on grain growth during free sintering: non-uniform domain shrinkage with periodicity",
          "author": {
            "login": "JingShuShi"
          },
          "bodyText": "Dear Moose experts,\nI want to study the sintering using phase field + tensor mechanics modules. The key outputs I am looking for are the volume shrinkage during sintering and evaluate the effective properties (e.g. elastic stress state) from the whole simulation domain.\nMy initial idea is to setup a RVE with periodic boundary conditions and randomly fill the grains to certain volume fraction (or import from existing packing file), then assign only one order parameter to solve the interface evolution. Then adding rigid body motion, and coupled to tensor mechanics to get the stress/strain fields.\nIf I now consider free sintering with gravity in y-direction, during sintering the pores are closed and grains will shrink in y-direction due to gravity, but the top boundary will still be the same as t=0, so the domain volume is constant, thus the effective volume fraction in the whole domain remains constant. Is it possible to set the domain to move and follow the shrinkage of top layer of grains?\nI also have a second question on how to apply gravity onto the material:\noption1: add it through force density in Rigid Body Motion on each grain (or maybe on elements with concentration > 0.95).\noption2: add it as body force term into tensor mechanics module, so the extra strain energy from gravity will go into total free energy.\nCould you please tell me which option would be better and why?\nThanks for the help.\nBest Regards,\nHao",
          "url": "https://github.com/idaholab/moose/discussions/16860",
          "updatedAt": "2022-07-02T23:59:33Z",
          "publishedAt": "2021-02-02T21:41:27Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "I believe we don't yet have the capability to change the domain size with the shrinking particles. You can use the RVE based analysis to apply load and capture the associated deformation behavior including volume/shape change. https://www.sciencedirect.com/science/article/pii/S0168874X20301165\nIf you want to model initial powder stacking, you can apply the gravitational force to each of the particles but you will need a way to detect contact between particles to avoid any overlap.",
                  "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-342972",
                  "updatedAt": "2022-07-03T00:13:40Z",
                  "publishedAt": "2021-02-05T20:57:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "JingShuShi"
                          },
                          "bodyText": "Thanks for the paper, I had a look at it and got the idea of the global strain periodicity.  In this method, you need to specify the reference point that has no deformation. If the reference point is set at the center of the bottom boundary, then apply load on the top boundary, this will result only in top boundary moving, the displacements on top/bottom boundaries are not periodic but all the other quantities (stress, concentration, etc.) are still kept periodic?\nFor the initial powder stacking, by avoiding overlap, do you mean avoiding this only for the initial conditions, or during the whole simulation? Will the rigid body motion already ensure the particles without overlapping with each other?",
                          "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-349202",
                          "updatedAt": "2022-07-03T00:13:40Z",
                          "publishedAt": "2021-02-08T12:10:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "For a periodic domain, I often consider the center of the domain as the reference point. With this, you would allow both the boundaries to deform and your stress-strain would be periodic.\nThe whole simulation, if you apply external forces. Rigid body motion under externally applied force will not be sufficient for this.",
                          "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-353613",
                          "updatedAt": "2022-07-03T00:13:47Z",
                          "publishedAt": "2021-02-09T16:26:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JingShuShi"
                          },
                          "bodyText": "Thanks for the answer, I see, in order to maintain both stress and strain periodicity, the reference point has to be in the center, otherwise the final result will be asymmetric.\nAs you pointed out, if the external force is applied, the rigid body motion could not prevent the particles get into contact, then it is more like the pressurized sintering case, where the diffusion at interface will be enhanced by the interface pushed towards each other. I don't see the problem with interface getting close/overlap, will mass not be conserved in this case? What about the two centroids getting too close then? Will they merge into one centroid?",
                          "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-359254",
                          "updatedAt": "2022-07-03T00:13:47Z",
                          "publishedAt": "2021-02-11T11:25:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "It would depend on how you apply the force and how you resolve the contact between particles. You just have to make sure nothing un-physical happens.",
                          "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-360172",
                          "updatedAt": "2022-07-03T00:14:06Z",
                          "publishedAt": "2021-02-11T16:54:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JingShuShi"
                          },
                          "bodyText": "thanks, I will try some simple test cases to see if any un-physical happens.",
                          "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-362020",
                          "updatedAt": "2022-07-03T00:14:07Z",
                          "publishedAt": "2021-02-12T08:28:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}