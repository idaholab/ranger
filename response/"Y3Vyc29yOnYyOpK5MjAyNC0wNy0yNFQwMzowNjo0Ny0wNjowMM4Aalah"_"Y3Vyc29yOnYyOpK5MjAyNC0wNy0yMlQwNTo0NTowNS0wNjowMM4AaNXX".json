{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wNy0yMlQwNTo0NTowNS0wNjowMM4AaNXX"
    },
    "edges": [
      {
        "node": {
          "title": "SplitCHCRes",
          "author": {
            "login": "rnpratoori"
          },
          "bodyText": "Hello team,\nI am looking at the source file of the kernel SplitCHCRes and want to know what are the equations based on which it was modeled. I could not find any documentation for it. Can anyone give me these equations?",
          "url": "https://github.com/idaholab/moose/discussions/28197",
          "updatedAt": "2024-07-23T20:13:51Z",
          "publishedAt": "2024-07-23T14:17:28Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sourabhkadambi"
                  },
                  "bodyText": "Have a look at this documentation page: https://mooseframework.inl.gov/modules/phase_field/Phase_Field_Equations.html",
                  "url": "https://github.com/idaholab/moose/discussions/28197#discussioncomment-10130311",
                  "updatedAt": "2024-07-23T19:26:51Z",
                  "publishedAt": "2024-07-23T19:26:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rnpratoori"
                          },
                          "bodyText": "@sourabhkadambi I did have a look at it, but it only shows for SplitCHWRes and not for SplitCHCRes.",
                          "url": "https://github.com/idaholab/moose/discussions/28197#discussioncomment-10130624",
                          "updatedAt": "2024-07-23T20:13:51Z",
                          "publishedAt": "2024-07-23T20:13:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cannot get visualizer installed onto school HPC",
          "author": {
            "login": "jackeggemeyer"
          },
          "bodyText": "",
          "url": "https://github.com/idaholab/moose/discussions/28198",
          "updatedAt": "2024-07-23T17:02:03Z",
          "publishedAt": "2024-07-23T14:35:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "List of RankTwoTensors for AuxKernal Calculations",
          "author": {
            "login": "shrituntunroy"
          },
          "bodyText": "Hi MOOSE Team,\nI am a new MOOSE user and am currently learning to use MOOSE.\nI have a question regarding the RankTwoAux auxkernel calculations. According to the documentation (Ref: https://mooseframework.inl.gov/source/auxkernels/RankTwoAux.html), the valid symbols for Rank Two Aux are given below:\n[./stress_xy]\n  type = RankTwoAux\n  rank_two_tensor = stress\n  variable = stress_xy\n  index_i = 0\n  index_j = 1\n[../]\nMy question is: where can I find the valid names for different rank two tensors, such as plastic strain and total strain, for these auxkernel calculations? Is there a link or resource that provides a full list?\nThank you for your help.",
          "url": "https://github.com/idaholab/moose/discussions/28194",
          "updatedAt": "2024-07-23T13:44:19Z",
          "publishedAt": "2024-07-23T12:23:19Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUse Debug/show_material_props=true to show all material properties, and then you should know which ones are tensors\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28194#discussioncomment-10126041",
                  "updatedAt": "2024-07-23T12:27:20Z",
                  "publishedAt": "2024-07-23T12:27:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The following error occurred in the Problem 'MOOSE Problem' of type FEProblem.",
          "author": {
            "login": "engrmessi"
          },
          "bodyText": "my scripts was running very well untill i updated my moose. I encounter this challange. Can anyone help me fix it\n*** ERROR ***\nThe following error occurred in the Problem 'MOOSE Problem' of type FEProblem.\nMaterial property 'acc_slip', requested by 'accslip' is not defined on block 0\nMaterial property 'lage', requested by 'e_xx' is not defined on block 0\nMaterial property 'fp', requested by 'fp_xx' is not defined on block 0\nMaterial property 'gss', requested by 'gss1' is not defined on block 0\n\ufffd[39m\n\ufffd[31m\n*** ERROR ***\nThe following error occurred in the Problem 'MOOSE Problem' of type FEProblem.\nMaterial property 'acc_slip', requested by 'accslip' is not defined on block 0\nMaterial property 'lage', requested by 'e_xx' is not defined on block 0\nMaterial property 'fp', requested by 'fp_xx' is not defined on block 0\nMaterial property 'gss', requested by 'gss1' is not defined on block 0\n\ufffd[39m\n** here is my script which was working before the update\n[GlobalParams]\ndisplacements = 'disp_x disp_y'\n[]\n[Mesh]\ntype = GeneratedMesh\ndim = 2\nnx = 40\nny = 20\nxmin = 0\nxmax = 20\nymin = 0\nymax = 10\n[]\n[Variables]\n[./eta1]\norder = FIRST\nfamily = LAGRANGE\n[../]\n[./disp_x]\nblock = 0\n[../]\n[./disp_y]\nblock = 0\n[../]\n[]\n[AuxVariables]\n[./bounds_dummy]\norder = FIRST\nfamily = LAGRANGE\n[../]\n[./accslip]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./vonmises]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./stress_xx]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./fp_xx]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./e_xx]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./gss1]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[]\n[Bounds]\n[./eta_upper_bound]\ntype = ConstantBoundsAux\nvariable = bounds_dummy\nbounded_variable = eta1\nbound_type = upper\nbound_value = 1\n[../]\n[./eta_lower_bound]\ntype = ConstantBoundsAux\nvariable = bounds_dummy\nbounded_variable = eta1\nbound_type = lower\nbound_value = 0\n[../]\n[]\n[ICs]\n[./eta1]\nvariable = eta1\ntype = SmoothCircleIC\nx1 = 10\ny1 = 10\nint_width = 0.05\nradius = 0.5\ninvalue = 0\noutvalue = 1\n#int_width = 1\n[../]\n[]\n[Functions]\n[./tdisp]\ntype = ParsedFunction\nexpression = 0.005*t\n[../]\n[]\n[Modules/TensorMechanics/Master/all]\nstrain = FINITE\nadd_variables = true\nplanar_formulation = PLANE_STRAIN\ngenerate_output = stress_zz\nstrain_base_name = uncracked\n[]\n[Kernels]\nAllen-Cahn Equation for eta1\n[./detadt_eta1]\ntype = TimeDerivative\nvariable = eta1\n[../]\n[./ACinterface_eta1]\ntype = ACInterface\nvariable = eta1\nmob_name = L_inf\nkappa_name = kappa\n[../]\n[./ACBulkF_eta1]\ntype = AllenCahn\nvariable  = eta1\nf_name = g1\nmob_name = L_inf\nargs = T\n[../]\n[./AllenCahn1]\ntype = AllenCahn\nvariable = eta1\nmob_name = L_pot\nf_name = f1\nargs = T\n[../]\n[]\n[AuxKernels]\n[./accslip]\ntype = MaterialRealAux\nvariable = accslip\nproperty = acc_slip\nexecute_on = timestep_end\nblock = 0\n[../]\n[./vonmises]\ntype = RankTwoScalarAux\nrank_two_tensor = stress\nvariable = vonmises\nscalar_type = VonMisesStress\nexecute_on = timestep_end\nblock = 0\n[../]\n[./stress_xx]\ntype = RankTwoAux\nrank_two_tensor = stress\nvariable = stress_xx\nindex_j = 0\nindex_i = 0\nexecute_on = timestep_end\nblock = 0\n[../]\n[./fp_xx]\ntype = RankTwoAux\nvariable = fp_xx\nrank_two_tensor = fp\nindex_j = 0\nindex_i = 0\nexecute_on = timestep_end\nblock = 0\n[../]\n[./e_xx]\ntype = RankTwoAux\nvariable = e_xx\nrank_two_tensor = lage\nindex_j = 0\nindex_i = 0\nexecute_on = timestep_end\nblock = 0\n[../]\n[./gss1]\ntype = MaterialStdVectorAux\nvariable = gss1\nproperty = gss\nindex = 0\nexecute_on = timestep_end\nblock = 0\n[../]\n[]\n[BCs]\n[./eta_bottom]\ntype =  DirichletBC\nvariable = 'eta1'\nboundary = 'bottom'\nvalue = 1.0\n[../]\n[./eta_lr]\ntype =  NeumannBC\nvariable = 'eta1'\nboundary = 'top left right'\nvalue = 0.0\n[../]\n[./Pressure]\n[./stressfree_boundary]\n#Applies the pressure\nboundary = top\nfactor = 0.0\ndisp_x = disp_x\ndisp_y = disp_y\n[../]\n\n[../]\n[./dispy]\ntype = DirichletBC\nvariable = disp_y\nboundary = bottom\nvalue = 0\n[../]\n[./dispx]\ntype = DirichletBC\nvariable = disp_x\nboundary = left\nvalue = 0\n[../]\n[./tdisp]\ntype = FunctionDirichletBC\nvariable = disp_x\nboundary = right\nfunction = tdisp\n[../]\n[]\n[Materials]\n[./crysp]\ntype = FiniteStrainCPSlipRateRes\nblock = 0\nslip_sys_file_name = input_slip_sys.txt\nnss = 12\nnum_slip_sys_flowrate_props = 2 #Number of properties in a slip system\nflowprops = '1 4 0.5 0.05 5 8 0.5 0.05 9 12 0.5 0.05'\nhprops = '1.0 215 78.6 200.0 1.75'\ngprops = '1 4 78.6 5 8 78.6 9 12 78.6'\ntan_mod_type = exact\nslip_incr_tol = 1\nmaximum_substep_iteration = 12\n\nuse_line_search = true\nline_search_method = 'BISECTION'\nrtol = 1e-7\nabs_tol = 1e-8\nbase_name = uncracked\n\n[../]\n[./elasticity_tensor]\ntype = ComputeElasticityTensorCP\nblock = 0\nC_ijkl = '2.04e5 1.37e5 1.37e5 2.044e5 1.37e5 2.04e5 1.26e5 1.26e5 1.26e5'\nfill_method = symmetric9\nread_prop_user_object = prop_read\neuler_angle_1 = 0\neuler_angle_2 = 0\neuler_angle_3 = 0\noutput_properties = 'Euler_angles'\noutputs = exodus\nbase_name = uncracked\n\n[../]\n[./cracked_stress]\ntype = ComputeCrackedStressmod\nc = eta1\nproperty_name = E_el\nuse_current_history_variable = false\nuncracked_base_name = uncracked\nfinite_strain_model = false\n\n[../]\n[./degradation]\ntype = DerivativeParsedMaterial\nproperty_name = degradation\ncoupled_variables = 'eta1'\nfunction = '1'\nexpression = 'eta1^3*(6*eta1^2-15*eta1+10)*(1.0 - c) + c'\nconstant_names       = 'c'\nconstant_expressions = '1e-6'\nderivative_order = 2\n\n[../]\n[./f1]\ntype = DerivativeParsedMaterial\nproperty_name = f1\ncoupled_variables = 'eta1'\nmaterial_property_names = 'h0'\ndiff_factor:=if(c>c_b,exp(alpha*log(c/c_b)),1);\nconstant_names = 'overpotential  R     z     alpha beta F_const T '\nconstant_expressions = '0.1    8.31    2.19  0.65  0.35  96485.33 298'\nexpression = 'h1:=eta1^3*(6*eta1^2-15*eta1+10);\nh1*(exp(z*alpha*F_const*overpotential/(R*T))-exp(-z*beta*F_const*overpotential/(R*T)))'\n\noutputs = exodus\nderivative_order = 1\n\n[../]\n[./h1]\ntype = SwitchingFunctionMaterial\nh_order = HIGH\neta = 'eta1'\nfunction_name = h1\n[../]\n[./g1]\ntype = BarrierFunctionMaterial\ng_order = SIMPLE\neta = 'eta1'\nfunction_name = g1\n[../]\n[./constants]\ntype = GenericConstantMaterial\nprop_names  = 'kappa     L_inf0    L_pot0      W'\nprop_values = '0.05      0.0009   0.00415      1.0'  #0.99e-4  4.15e-4\n[../]\n[./reaction_mob]\ntype = ParsedMaterial\nproperty_name = L_inf\ncoupled_variables = 'accslip'\nmaterial_property_names = 'L_inf0'\nfunction = 'L_inf0'\nexpression = 'L_inf0*(1+accslip/0.001)'\n\n[../]\n[./reaction_mob2]\ntype = ParsedMaterial\nproperty_name = L_pot\ncoupled_variables = 'accslip'\nmaterial_property_names = 'L_pot0'\nfunction = 'L_pot0'\nexpression = 'L_pot0*(1+accslip/0.001)'\n\n[../]\n[]\n[Postprocessors]\n[./vonmises]\ntype = ElementAverageValue\nvariable = vonmises\nblock = 'ANY_BLOCK_ID 0'\n[../]\n[./stress_xx]\ntype = ElementAverageValue\nvariable = stress_xx\nblock = 'ANY_BLOCK_ID 0'\n[../]\n[./fp_xx]\ntype = ElementAverageValue\nvariable = fp_xx\nblock = 'ANY_BLOCK_ID 0'\n[../]\n[./e_xx]\ntype = ElementAverageValue\nvariable = e_xx\nblock = 'ANY_BLOCK_ID 0'\n[../]\n[./gss1]\ntype = ElementAverageValue\nvariable = gss1\nblock = 'ANY_BLOCK_ID 0'\n[../]\n[]\n[Preconditioning]\n[./smp]\ntype = SMP\nfull = true\n[../]\n[]\n[Executioner]\ntype = Transient\n#Preconditioned JFNK (default)\nsolve_type = 'PJFNK'\npetsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\npetsc_options_value = 'lu            superlu_dist            vinewtonrsls'\nautomatic_scaling = true\nl_max_its = 20\nnl_max_its = 10\nnl_abs_tol = 1e-9\npetsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -ksp_type -ksp_gmres_restart'\npetsc_options_value = ' asm      1              lu            gmres     200'\ndt = 0.0025\ndtmax = 0.01\n[./TimeStepper]\ntype = IterationAdaptiveDT\ndt = 0.0025 # Initial time step.  In this simulation it changes.\noptimal_iterations = 8 # Time step will adapt to maintain this number of nonlinear# iterations\n[../]\n[./Adaptivity]\ninitial_adaptivity = 2 # Number of times mesh is adapted to initial condition\nrefine_fraction = 0.6 # Fraction of high error that will be refined\ncoarsen_fraction = 0.2 # Fraction of low error that will coarsened\nmax_h_level = 2 # Max number of refinements used, starting from initial mesh (befo# uniform refinement)\n[../]\nend_time = 5\n[]\n[VectorPostprocessors]\n[eta1]\ntype = LineValueSampler\nstart_point = '10 0 0'\nend_point = '10 10 0'\nnum_points = 200\nsort_by = y\nvariable = eta1\n[]\n[]\n[Outputs]\nexodus = true\ninterval = 2\n[./console]\ntype = Console\ninterval = 2\n[../]\n[./csv]\ntype = CSV\ninterval = 2\n[../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/27266",
          "updatedAt": "2024-07-23T13:12:38Z",
          "publishedAt": "2024-04-02T20:01:52Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nplease use Debug/show_material_props to see a summary of producers and consumers of material properties and make sure they match\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27266#discussioncomment-8989810",
                  "updatedAt": "2024-04-02T21:57:05Z",
                  "publishedAt": "2024-04-02T21:57:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "engrmessi"
                  },
                  "bodyText": "sorry, i did not understand what you mean. where should implement this \" Debug/show_material_props\"? in my input script or bash file?\nBest!",
                  "url": "https://github.com/idaholab/moose/discussions/27266#discussioncomment-8989862",
                  "updatedAt": "2024-04-02T22:01:24Z",
                  "publishedAt": "2024-04-02T22:01:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The Debug block is a block you can add to the input file\nsee the SetupDebugAction documentation for more info on the parameters",
                          "url": "https://github.com/idaholab/moose/discussions/27266#discussioncomment-8989901",
                          "updatedAt": "2024-04-02T22:05:31Z",
                          "publishedAt": "2024-04-02T22:05:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Nonlinear solve did not converge due to DIVERGED_FNORM_NAN.",
          "author": {
            "login": "RbmIjpb"
          },
          "bodyText": "Hello,\nI'm hoping someone can help me with my problem.\nI have a recurrent error from this code coming from\n195       double _d_phi_d_J1 = theta * theta / (2 * phi * std::pow(_Y1[_qp] * _Y1[_qp] - theta, 2)) ;\nthe intermediate messages i added to the code show the following :\nBefore solveForTheta - J1: 0, J2: 0, _Y1[_qp]: 3e+06, _Y2[_qp]: 2e+06, _h[_qp]: 300\nAfter solveForTheta - theta: 9e+12\nWarning: theta exceeded maximum allowed value. Capping at 3.96e+12\nf_dev calculation: 0\nf_dev calculation: 0\nBefore solveForTheta - J1: 0, J2: 0, _Y1[_qp]: 3e+06, _Y2[_qp]: 2e+06, _h[_qp]: 300\nAfter solveForTheta - theta: 9e+12\nWarning: theta exceeded maximum allowed value. Capping at 3.96e+12\nf_dev calculation: 0\nf_dev calculation: 0\n\nand i'm still getting\n Nonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0\nthe dbg message is this :\nThread 1 \"lollipop-dbg\" received signal SIGFPE, Arithmetic exception. 0x00007ffff38f9fb0 in NoGrowthCW::computeQpPK1Stress (this=0x555555c4a280) at /home/antilope/projects/lollipop/src/kernels/NoGrowthCW.C:195 195       double _d_phi_d_J1 = theta * theta / (2 * phi * std::pow(_Y1[_qp] * _Y1[_qp] - theta, 2)) ;\nIt seems also that all the vectors created with multiply_vector_tensor have memory allocation problem, even after initializing std::vector<double> a_bar(3) :\na_bar = {<std::_Vector_base<double, std::allocator<double> >> = {\n    _M_impl = {<std::allocator<double>> = {<__gnu_cxx::new_allocator<double>> = {<No data fields>}, <No data fields>}, <std::_Vector_base<double, std::allocator<double> >::_Vector_impl_data> = {_M_start = 0x555555d98f40,\n        _M_finish = 0x555555d98f58, _M_end_of_storage = 0x555555d98f58}, <No data fields>}}, <No data fields>}\n\nAny help will be more than welcome and greately appreciated !!\nI added the header and source file here, in .txt.\nNoGrowthCWh.txt\nNoGrowthCW .txt",
          "url": "https://github.com/idaholab/moose/discussions/28192",
          "updatedAt": "2024-07-22T19:03:00Z",
          "publishedAt": "2024-07-22T18:49:22Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou could follow these instructions\nhttps://mooseframework.inl.gov/application_development/debugging.html\nand in the debugger print to screen each variable in\n double _d_phi_d_J1 = theta * theta / (2 * phi * std::pow(_Y1[_qp] * _Y1[_qp] - theta, 2)) ;\nuntil you find the one causing the exception\nThe debugger can use a breakpoint on that exception\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28192#discussioncomment-10118206",
                  "updatedAt": "2024-07-22T19:03:01Z",
                  "publishedAt": "2024-07-22T19:03:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlowFullySaturated seems to ignore block parameter?",
          "author": {
            "login": "jmeier"
          },
          "bodyText": "Dear Moose Community,\nI've setup a Moose model with [Physics/SolidMechanics/QuasiStatic] and [PorousFlowFullySaturated]. The Model works until I start to add additional subdomains using add_subdomain_names and try to block-restrict my physis. If I understand the error I get correctly, Moose tries to assign PorousFlowFullySaturated_1PhaseP_qp to my added subdomains.\n*** ERROR ***\nThe 'block' parameter of the object 'PorousFlowFullySaturated_1PhaseP_qp' must be a subset of the 'block' parameter of the variable 'porepressure':\n    Object 'PorousFlowFullySaturated_1PhaseP_qp': 0, 1, 2, 3, 4\n    Variable 'porepressure': 0, 1, 2\n\n\nDid I understand the error correctly? If yes, how to restrict PorousFlowFullySaturated properly?\nThis is my PorousFlowFullySaturated block:\n[PorousFlowFullySaturated]\n  coupling_type = HydroMechanical\n  porepressure = porepressure\n  biot_coefficient = 1\n  fp = simple_fluid\n  stabilization = FULL\n  gravity = '0 0 0'\n  add_darcy_aux = false\n  dictator_name = ${PorousFlowDictatorName}\n  block =  '${active_block_names}'\n[]\n\nMy full input file reads:\nPorousFlowDictatorName = 'dictator'\n\n[GlobalParams]\n  time_unit = days\n  displacements = 'disp_x disp_y disp_z'\n  use_displaced_mesh = false\n[]\n\ninactive_block_names = 'Box1_Inactive Box2_Inactive'\n\n[Mesh]\n  [BaseMesh]\n    type = GeneratedMeshGenerator\n    subdomain_id = 0\n    subdomain_name = \"BaseMesh\"\n    elem_type = \"TET10\"\n    dim = 3\n    nx = 20\n    ny = 20\n    nz = 2\n    xmin = -10\n    xmax = +10\n    ymin = -10\n    ymax = +10\n    zmin = -2\n    zmax = +2\n  []\n\n  [Box1]\n    type = SubdomainBoundingBoxGenerator\n    input = \"BaseMesh\"\n    block_id = 1\n    block_name = \"Box1\"\n    location = \"INSIDE\"\n    bottom_left = \"-2 -2 +2\"\n    top_right   = \"0 +2 0\"\n  []\n\n  [Box2]\n    type = SubdomainBoundingBoxGenerator\n    input = \"Box1\"\n    block_id = 2\n    block_name = \"Box2\"\n    location = \"INSIDE\"\n    bottom_left = \"0 -2 +2\"\n    top_right   = \"+2 +2 0\"\n  []\n\n  add_subdomain_names = '${inactive_block_names}'\n[]\n\nactive_block_names = 'BaseMesh Box1 Box2'\n\n[Physics]\n  [SolidMechanics]\n    [QuasiStatic]\n      [./all]\n        strain = SMALL\n        incremental = true\n        add_variables = true\n        generate_output = 'stress_xx stress_yy stress_zz'\n        block = ${active_block_names}\n      []\n    []\n  []\n[]\n\n[PorousFlowFullySaturated]\n  coupling_type = HydroMechanical\n  porepressure = porepressure\n  biot_coefficient = 1\n  fp = simple_fluid\n  stabilization = FULL\n  gravity = '0 0 0'\n  add_darcy_aux = false\n  dictator_name = ${PorousFlowDictatorName}\n  block =  '${active_block_names}'\n[]\n\n[Variables]\n  [porepressure]\n    order = SECOND\n    family = LAGRANGE\n    scaling = 1e-5\n    block =  '${active_block_names}'\n  []\n[]\n\n# ===== Kernels: Inactive Domains =====\n[Kernels]\n  [./inactive_x]\n    type = MatDiffusion\n    block = ${inactive_block_names}\n    variable = disp_x\n    diffusivity = 1e-7\n  []\n  [./inactive_y]\n    type = MatDiffusion\n    block = ${inactive_block_names}\n    variable = disp_y\n    diffusivity = 1e-7\n  []\n  [./inactive_z]\n    type = MatDiffusion\n    block = ${inactive_block_names}\n    variable = disp_z\n    diffusivity = 1e-7\n  []\n[]\n\n[ICs]\n  [porepressure]\n    type = FunctionIC\n    variable = porepressure\n    function = '2'\n    block = ${active_block_names}\n  []\n[]\n\n[AuxVariables]\n  [p]\n    order = CONSTANT\n    family = MONOMIAL\n    block = ${active_block_names}\n  []\n  [q]\n    order = CONSTANT\n    family = MONOMIAL\n    block = ${active_block_names}\n  []\n[]\n\n[AuxKernels]\n  [p]\n    type = RankTwoScalarAux\n    rank_two_tensor = stress\n    variable = p\n    scalar_type = Hydrostatic\n    block = ${active_block_names}\n  []\n  [q]\n    type = RankTwoScalarAux\n    rank_two_tensor = stress\n    variable = q\n    scalar_type = VonMisesStress\n    block = ${active_block_names}\n  []\n[]\n\n[BCs]\n\n  [fix_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left right'\n    value = 0.0\n  []\n\n  [fix_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'front back'\n    value = 0.0\n  []\n\n  [fix_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    value = 0.0\n  []\n\n  # Pressure applied on the top surface\n  [Pressure]\n    [pressure_zmax]\n      boundary = 'top'\n      function = 1000    #Newtons\n    []\n  []\n[]\n\n[Functions]\n  [inner_pressure_method1]\n    type = ParsedFunction\n    symbol_names = 'ymin ymax v'\n    symbol_values = '-2 15 1'\n    expression = 'if(y<ymin+v*t,1e5,0)'\n  []\n  [permeability_prefactor_method1]\n    type = ParsedFunction\n    symbol_names = 'ymin ymax v'\n    symbol_values = '-2   15   1'\n    expression = 'if(y<ymin+v*t, 1e5, 1)'\n  []\n[]\n\n[FluidProperties]\n  [simple_fluid]\n    type = SimpleFluidProperties\n    bulk_modulus = 2E3\n    density0 = 1000\n    thermal_expansion = 0\n    viscosity = 9.0E-10\n    block = ${active_block_names}\n  []\n[]\n\n[Materials]\n\n  [porosity_bulk]\n    type = PorousFlowPorosityConst\n    block = ${active_block_names}\n    porosity = 0.15\n    PorousFlowDictator = ${PorousFlowDictatorName}\n  []\n\n  [undrained_density_0]\n    type = GenericConstantMaterial\n    block = ${active_block_names}\n    prop_names = density\n    prop_values = 2500\n  []\n\n  [BaseMesh_permeability_bulk]\n    type = PorousFlowPermeabilityConst\n    block = 'BaseMesh'\n    permeability = '1e-19 0 0 0 1e-19 0 0 0 1e-19'\n    PorousFlowDictator = ${PorousFlowDictatorName}\n  []\n\n  [BaseMesh_elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    block = 'BaseMesh'\n    youngs_modulus = 2500\n    poissons_ratio = 0.15\n  []\n\n\n  [Box1_permeability_bulk]\n    type = PorousFlowPermeabilityConst\n    block = 'Box1'\n    permeability = '1e-19 0 0 0 1e-19 0 0 0 1e-19'\n    PorousFlowDictator = ${PorousFlowDictatorName}\n  []\n\n  [Box1_elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    block = 'Box1'\n    youngs_modulus = 2500\n    poissons_ratio = 0.15\n  []\n\n  [BoxXX_permeability_bulk]\n    type = PorousFlowPermeabilityConst\n    block = 'Box2'\n    permeability = '1e-19 0 0 0 1e-19 0 0 0 1e-19'\n    PorousFlowDictator = ${PorousFlowDictatorName}\n  []\n\n  [BoxXX_elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    block = 'Box2'\n    youngs_modulus = 2500\n    poissons_ratio = 0.15\n  []\n\n[]\n\n\n[Preconditioning]\n  [.\\SMP]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = PJFNK\n\n  petsc_options = '-snes_converged_reason'\n\n  # best overall\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = ' lu       mumps'\n\n  line_search = none\n\n  nl_abs_tol = 1e-4\n  nl_rel_tol = 1e-6\n\n  l_max_its = 20\n  nl_max_its = 8\n\n  start_time = 0.0\n  end_time = 1.0 #17\n  [TimeSteppers]\n    [ConstantDT1]\n      type = ConstantDT\n      dt = 0.25\n    []\n  []\n\n  [Quadrature]\n    type = SIMPSON\n    order = SECOND\n  []\n[]\n\n[Outputs]\n  perf_graph = true\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/28030",
          "updatedAt": "2024-07-22T17:19:01Z",
          "publishedAt": "2024-07-01T07:40:53Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou did not block restrict the porous media action so it includes the subdomains in add_subdomain_names.\nHowever you did block restrict the porepressure Variable so it does not include them.\nThey must match. Either increase the block restriction of the Variable or block-restrict the porous media action\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9926717",
                  "updatedAt": "2024-07-01T15:00:37Z",
                  "publishedAt": "2024-07-01T15:00:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Guillaume,\nThanks for your answer. I tried to block-restrict my porous media action [PorousFlowFullySaturated] by block =  '${active_block_names}'. What else is needed to block-restrict the porous media action? Using _active = 'porepressure'_ in my [PorousFlowFullySaturated] does not help either.\nKind regards,\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9927993",
                          "updatedAt": "2024-07-01T17:04:24Z",
                          "publishedAt": "2024-07-01T17:04:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "there is no block parameters in PorousFlowFullySaturated\nhttps://mooseframework.inl.gov/source/actions/PorousFlowFullySaturated.html\nI think this might have been an omission when making these actions.",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9928430",
                          "updatedAt": "2024-07-01T17:52:32Z",
                          "publishedAt": "2024-07-01T17:52:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "there is no block parameters in PorousFlowFullySaturated\nhttps://mooseframework.inl.gov/source/actions/PorousFlowFullySaturated.html\n\nOk. Good point.\nFrom the description, the parameter \"active\" seems to do a block-restriction?\n\nIf specified only the blocks named will be visited and made active\n\nBut I get an error using active = '${active_block_names}':\nvariables listed as active (${active_block_names}) in section 'PorousFlowFullySaturated' not found in input\nSo Moose seems to expect an variable name in \"active\". But using active = 'porepressure' seems to have no effect: I'm back with my initial error message.\nSo do I understand this correctly and Moose does currently not support a block-restriction for [PorousFlowFullySaturated]?",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9928625",
                          "updatedAt": "2024-07-01T18:13:09Z",
                          "publishedAt": "2024-07-01T18:13:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok I re-read the thread. You were right! It ignores it. It is not a parameter of that action.\nIt should not be too hard to add.\nIn fact if that action was derived from PhysicsBase like we prefer now, you would not have to do it individually ;)\nbut that's a larger rework",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9928655",
                          "updatedAt": "2024-07-01T18:15:26Z",
                          "publishedAt": "2024-07-01T18:15:26Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "'active' and 'inactive' are for the parser btw, to decide which objects to create or not create in a simulation. this is mostly for debugging purposes",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9928806",
                          "updatedAt": "2024-07-01T18:26:40Z",
                          "publishedAt": "2024-07-01T18:26:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Guillaume,\nThanks for your answer and your time. If I'm reading the code correctly, PorousFlowFullySaturated is currently not inheriting from PhysicsBase. So I have to abandon PorousFlowFullySaturated for now.\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9928866",
                          "updatedAt": "2024-07-01T18:33:04Z",
                          "publishedAt": "2024-07-01T18:33:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Thanks for your answer and your time. If I'm reading the code correctly, PorousFlowFullySaturated is currently not inheriting from PhysicsBase. So I have to abandon PorousFlowFullySaturated for now.\n\nwhy is that exactly?\nYou could add the 'block' parameter without inheriting from PhysicsBase. You were very capable at modifying moose on your previous PRs :)",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9929039",
                          "updatedAt": "2024-07-01T18:53:24Z",
                          "publishedAt": "2024-07-01T18:53:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Guillaume,\nI'll have a look. But I can't promise anything.\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9932264",
                          "updatedAt": "2024-07-02T05:41:09Z",
                          "publishedAt": "2024-07-02T05:41:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "You can add all of the kernels by hand, and these will respect the block parameter in the meantime.",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9962971",
                          "updatedAt": "2024-07-05T00:01:05Z",
                          "publishedAt": "2024-07-05T00:01:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Also, thanks for finding this out! I'll fix it when I get a chance",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9962976",
                          "updatedAt": "2024-07-05T00:01:54Z",
                          "publishedAt": "2024-07-05T00:01:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jmeier"
                  },
                  "bodyText": "If this discussion is found in the future: With #28070 the PorousFlow actions now allow block-restriction.",
                  "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-10117395",
                  "updatedAt": "2024-07-22T17:19:02Z",
                  "publishedAt": "2024-07-22T17:19:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Dynamics/ActuallyExplicitEuler/LUMPED] is much slower than Abaqus due to computeJacobianTag and computeResidual?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi guys,\nI know that MOOSE explicit isnt optimised, but is there a way to make computeJacobianTag and computeResidual faster for lumped case? where it is just solved by direct inversion\nI looked into ActuallyExplicitEuler.C and ExplicitTimeIntegrator.C\nActuallyExplicitEuler::solve() prepares matrix into solver for all cases and feed to ExplicitTimeIntegrator::performExplicitSolve() (CONSISTENT/LUMPED/LUMP_PRECONDITIONED) via computeJacobianTag and computeResidual\nvoid\nActuallyExplicitEuler::solve()\n{\n\n  // Reset iteration counts\n  _n_nonlinear_iterations = 0;\n  _n_linear_iterations = 0;\n\n  _current_time = _fe_problem.time();\n\n  // Set time to the time at which to evaluate the residual\n  _fe_problem.time() = _fe_problem.timeOld();\n  _nonlinear_implicit_system->update();\n\n  // Compute the residual\n  _explicit_residual.zero();\n  _fe_problem.computeResidual(\n      *_nonlinear_implicit_system->current_local_solution, _explicit_residual, _nl.number());\n\n  // Move the residual to the RHS\n  _explicit_residual *= -1.0;\n\n  // Compute the mass matrix\n  auto & mass_matrix = _nonlinear_implicit_system->get_system_matrix();\n  if (!_constant_mass || (_constant_mass && _t_step == 1))\n    _fe_problem.computeJacobianTag(\n        *_nonlinear_implicit_system->current_local_solution, mass_matrix, _Ke_time_tag);\n\n  // Perform the linear solve\n  bool converged = performExplicitSolve(mass_matrix);\n\nI just wondering, is it necessary for LUMPED? Note that, i checked ExplicitTimeIntegrator::performExplicitSolve() , it's very fast, i dont think this is a problem at all.\nAt the moment, from our comparison, MOOSE explicit is 10x slower than Abaqus with the same number of cores for exactly the same case (LUMPED), I think if we make computeJacobianTag and computeResidual more efficient, MOOSE will be much faster.\nbelow are all the kernels i am currently using (which will be more complicated in the future), it should be fast and simple\n  [Kernels]\n    [./DynamicSolidMechanics] # zeta*K*vel + K * disp\n      displacements = 'disp_x disp_y disp_z'\n      use_displaced_mesh=false\n      eigenstrain_names = ini_stress\n      strain = SMALL\n      incremental = true\n      # decomposition_method = HughesWinget\n    [../]\n\n    [./inertia_x]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_x\n      density_scaling = density_scaling\n    [../]\n    [./inertia_y]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_y\n      density_scaling = density_scaling\n    [../]\n    [./inertia_z]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_z\n      density_scaling = density_scaling\n    [../]\n\n    [./gravity]\n        type = Gravity\n        use_displaced_mesh=false\n        variable = disp_z\n        function = '-9.81*if(t=0, 0, if(t>=30, 1, (t) / 30))'\n        value = 1\n    [../]\n  []\n\nThank you!\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/28105",
          "updatedAt": "2024-07-22T15:36:50Z",
          "publishedAt": "2024-07-11T14:02:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPlease follow these instructions to get us a profile of your simulation\nhttps://mooseframework.inl.gov/application_development/profiling.html\nFrom there can see if there is a hot spot we should look to improve\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10022016",
                  "updatedAt": "2024-07-11T14:30:38Z",
                  "publishedAt": "2024-07-11T14:30:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "Hey @Traiwit sorry I haven't responded in the previous discussion. If performance is the main concern, I think Derek Gaston looked at this very comparison a while ago (don't think he went too deep) and AFAIK the conclusion was that there were several little optimizations required to compete with ABAQUS or LS-DYNA. Note that these commercial codes are extremely optimized for this problem. Whereas MOOSE wasn't originally envisioned for even implicit dynamics; explicit is even newer. Given this I don't think it's a quick solution to increase the speed. It might take a consistent effort to optimize at multiple levels in the system. @recuero @dschwen are you guys planning to improve performance of the explicit solver in any of your projects?",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10023865",
                          "updatedAt": "2024-07-11T17:41:36Z",
                          "publishedAt": "2024-07-11T17:41:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @cbolisetti,\nI feel like for ActuallyExplicitEuler + LUMPED case we are close as we don't even need to use solver. we probs just need to change the way that we build matrix for this particular case before feeding into performExplicitSolve(mass_matrix).\nI can start looking into this, but not exactly sure where.\nI see @friedmud and @hugary1995 have also involved with Explicit quite a fair bit as well.\nThank you guys! we got this :)",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10030993",
                          "updatedAt": "2024-07-12T11:42:47Z",
                          "publishedAt": "2024-07-12T11:42:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Hi @GiudGiud\ni'm having hard time following the instruction there, first stupid question: do I do all that profiling inside conda moose environment or outside?\nat the moment, i cannot run\nscripts/update_and_rebuild_petsc.sh --CFLAGS=-fno-omit-frame-pointer --CXX_CXXFLAGS=-fno-omit-frame-pointer outside conda\nand I cannot run scripts/update_and_rebuild_libmesh.sh inside conda",
                  "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10027064",
                  "updatedAt": "2024-07-12T03:54:22Z",
                  "publishedAt": "2024-07-12T03:23:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "for now let's just profile moose so start from inside a conda environment, and build the oprof version of moose\nif needed you can try to profile the whole stack. in that case, why cannot you run this outside of conda?\n\nscripts/update_and_rebuild_petsc.sh --CFLAGS=-fno-omit-frame-pointer --CXX_CXXFLAGS=-fno-omit-frame-pointer outside conda",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10027491",
                          "updatedAt": "2024-07-12T05:02:14Z",
                          "publishedAt": "2024-07-12T05:02:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud\ni'm pushing it through this part now\nexport GPERF_DIR=$HOME/gperftools/installed\nexport METHOD=oprof\ncd [your-moose-app-repository]\nmake -j$MOOSE_JOBS\n\nand got this error\nLinking Library /home/moose/project/moose/framework/contrib/pcre/libpcre-oprof.la...\nLinking Library /home/moose/project/moose/framework/contrib/gtest/libgtest.la...\n/usr/bin/ld: cannot find -lmesh_oprof: No such file or directory\n/usr/bin/ld: cannot find -ltimpi_oprof: No such file or directory\ncollect2: error: ld returned 1 exit status\nmake: *** [/home/moose/project/moose/framework/moose.mk:404: /home/moose/project/moose/framework/contrib/pcre/libpcre-oprof.la] Error 1\nmake: *** Waiting for unfinished jobs....\nmake[1]: Entering directory '/home/moose/project/moose/framework/contrib/hit'\nBuilding hit for python with python3-config\nmake[1]: 'hit' is up to date.\nmake[1]: Leaving directory '/home/moose/project/moose/framework/contrib/hit'\n(base) moose@moose-AS-5014A-TT:~/project/mech_be$ \n\nI will try again on Monday, otherwise, my input file is very simple, if you have time could you please do the profiling for me?\nat the moment 1 timestep take ~5-10 sec for full scale problem, but the problem is that we need to run more than 100k steps for each run, and this will take days\n# mpiexec -n 4 ./mech_be-opt -i ./mech_be/BE_EXAMPLE/central_diff_massscaling.i\n\n# Test for the central difference time integrator in 3D.\n[GlobalParams]\nuse_displaced_mesh=false\n[]\n\n[Mesh]\n  parallel_type = distributed\n[gen]\n  type = GeneratedMeshGenerator\n  dim = 3 # Dimension of the mesh\n  nx = 10 # Number of elements in the x direction\n  ny = 10 # Number of elements in the y direction\n  nz = 20 # Number of elements in the z direction\n  xmin = 0.0\n  xmax = 1000\n  ymin = 0.0\n  ymax = 1000\n  zmin = 0.0\n  zmax = 1000\n  # allow_renumbering = false # So NodalVariableValue can index by id\n  show_info = true\n  # elem_type = HEX8\n  elem_type = TET10\n[]\n[]\n\n  \n  [Variables]\n    [./disp_x]\n    [../]\n    [./disp_y]\n    [../]\n    [./disp_z]\n    [../]\n  []\n  \n  [AuxVariables]\n    [./vel_x]\n    [../]\n    [./accel_x]\n    [../]\n    [./vel_y]\n    [../]\n    [./accel_y]\n    [../]\n    [./vel_z]\n    [../]\n    [./accel_z]\n    [../]\n  []\n  \n  [AuxKernels]\n    [./accel_x]\n      type = TestNewmarkTI\n      variable = accel_x\n      displacement = disp_x\n      first = true\n    [../]\n    [./vel_x]\n      type = TestNewmarkTI\n      variable = vel_x\n      displacement = disp_x\n      first = true\n    [../]\n\n    [./accel_y]\n      type = TestNewmarkTI\n      variable = accel_y\n      displacement = disp_y\n      first = true\n    [../]\n    [./vel_y]\n      type = TestNewmarkTI\n      variable = vel_y\n      displacement = disp_y\n      first = true\n    [../]\n\n    [./accel_z]\n      type = TestNewmarkTI\n      variable = accel_z\n      displacement = disp_z\n      first = true\n    [../]\n    [./vel_z]\n      type = TestNewmarkTI\n      variable = vel_z\n      displacement = disp_z\n      first = true\n    [../]\n  []\n\n  [Kernels]\n    [./DynamicSolidMechanics] # zeta*K*vel + K * disp\n      displacements = 'disp_x disp_y disp_z'\n      use_displaced_mesh=false\n      eigenstrain_names = ini_stress\n      strain = SMALL\n      incremental = true\n      # decomposition_method = HughesWinget\n    [../]\n\n    [./inertia_x]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_x\n      density_scaling = density_scaling\n    [../]\n    [./inertia_y]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_y\n      density_scaling = density_scaling\n    [../]\n    [./inertia_z]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_z\n      density_scaling = density_scaling\n    [../]\n\n    [./gravity]\n        type = Gravity\n        use_displaced_mesh=false\n        variable = disp_z\n        function = '-9.81*if(t=0, 0, if(t>=30, 1, (t) / 30))'\n        value = 1\n    [../]\n  []\n\n\n  \n  [BCs]\n\n    [./no_x_back]\n      type = DirichletBC\n          preset = false\n      variable = disp_x\n      boundary = 'back'\n      value = 0.0\n    [../]\n    [./no_y_back]\n      type = DirichletBC\n          preset = false\n      variable = disp_y\n      boundary = 'back'\n      value = 0.0\n    [../]\n    [./no_z_back]\n      type = DirichletBC\n          preset = false\n      variable = disp_z\n      boundary = 'back'\n      value = 0.0\n    [../]\n\n   # fixed x left\n    [./no_x_left]\n      type = DirichletBC\n          preset = false\n      variable = disp_x\n      boundary = 'left'\n      value = 0.0\n    [../]\n    [./no_y_left]\n      type = DirichletBC\n          preset = false\n      variable = disp_y\n      boundary = 'left'\n      value = 0.0\n    [../]\n      \n\n    # fixed x right\n     [./no_x_right]\n       type = DirichletBC\n          preset = false\n       variable = disp_x\n       boundary = 'right'\n       value = 0.0\n     [../]\n     [./no_y_right]\n       type = DirichletBC\n          preset = false\n       variable = disp_y\n       boundary = 'right'\n       value = 0.0\n     [../]\n\n     # fixed y top\n      [./no_x_top]\n        type = DirichletBC\n          preset = false\n        variable = disp_x\n        boundary = 'top'\n        value = 0.0\n      [../]\n      [./no_y_top]\n        type = DirichletBC\n          preset = false\n        variable = disp_y\n        boundary = 'top'\n        value = 0.0\n      [../]\n\n      # fixed y bottom\n       [./no_x_bottom]\n         type = DirichletBC\n          preset = false\n         variable = disp_x\n         boundary = 'bottom'\n         value = 0.0\n       [../]\n       [./no_y_bottom]\n         type = DirichletBC\n          preset = false\n         variable = disp_y\n         boundary = 'bottom'\n         value = 0.0\n       [../]\n  []\n\n  \n   # * if(t=0, 0, if(t>=(target_time), 1, (t) / (target_time) ))\n  [Functions]\n    [./ini_xx]\n        type = ParsedFunction\n        expression = '-1.5*9.81*2700*(1000-z)*if(t=0, 0, if(t>=30, 1, (t) / 305))'\n      [../]\n      [./ini_yy]\n        type = ParsedFunction\n        expression = '-1.5*9.81*2700*(1000-z)*if(t=0, 0, if(t>=30, 1, (t) / 30))'\n      [../]\n      [./ini_zz]\n        type = ParsedFunction\n        expression = '-9.81*2700*(1000-z)*if(t=0, 0, if(t>=30, 1, (t) / 30))'\n      [../]\n  []\n  \n  [Materials]\n    [./elasticity_tensor]\n      youngs_modulus = 20e9 #Pa\n      poissons_ratio = 0.25\n      type = ComputeIsotropicElasticityTensor\n    [../]\n    [./strain]\n    #   type = ComputeFiniteStrain\n      type = ComputeIncrementalStrain\n      eigenstrain_names = ini_stress\n      displacements = 'disp_x disp_y disp_z'\n      implicit = false\n    [../]\n    [./stress]\n      type = ComputeFiniteStrainElasticStress\n    #   type = ComputeLinearElasticStress\n    [../]\n    [./density]\n      type = GenericConstantMaterial\n      prop_names = density\n      prop_values = 2700 #kg/m3\n    [../]\n    [./ini_stress]\n      type = ComputeEigenstrainFromInitialStress\n      eigenstrain_name = ini_stress\n      initial_stress = 'ini_xx 0 0 0 ini_yy 0 0 0 ini_zz'\n    [../]\n    [density_scaling]\n      type = DensityScaling\n      density = density\n      desired_time_step = 0.0005\n      output_properties = density_scaling\n      # outputs = 'exodus'\n      factor = 0.2\n    []\n  []\n  \n  [Executioner]\n    type = Transient\n    start_time = 0\n    end_time = 40\n    num_steps = 20\n    dt = 0.0005\n    [./TimeIntegrator]\n      type = CentralDifference\n      use_constant_mass = true\n      solve_type = lumped\n    [../]\n    # [TimeStepper]\n    #   type = PostprocessorDT\n    #   postprocessor = time_step\n    # []\n  []\n  \n  \n  [Outputs]\n    # exodus = true\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10028071",
                          "updatedAt": "2024-07-12T06:36:42Z",
                          "publishedAt": "2024-07-12T06:36:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "/usr/bin/ld: cannot find -lmesh_oprof: No such file or directory\n/usr/bin/ld: cannot find -ltimpi_oprof: No such file or directory\n\nok the conda path is not going to work. I thought we were shipping oprof libraries too.\nMaybe try conda info moose to see if there is a 'prof' named package",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10032607",
                          "updatedAt": "2024-07-12T14:38:17Z",
                          "publishedAt": "2024-07-12T14:38:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I won't have time to look this weekend, it looks like building from source outside the conda environment, or inside a reduced conda environment with just moose-mpich is going to be the way to build this",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10032616",
                          "updatedAt": "2024-07-12T14:39:12Z",
                          "publishedAt": "2024-07-12T14:39:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Hi guys, a quick update:\nI tried to optimise MOOSE source code today (mostly all cleaned up the kernels)\na mesh with 5,873,043 nodes and 4,361,842 elements 2nd order,  40s (dt = 0.005) took ~ 24 hrs before now down to ~15 hrs (this is for 32 cores pc)\nI still think the major issue is where they put together all the kernels and build the matrix via computeResidual() - I still couldnt understand this part of their code, very complicated\nI tried to have all the kernels off (commented all of them out and run with kernel_coverage_check = false), the simulation run super fast, and when i tried to have a fake kernel, for example\nGravityTempl<is_ad>::computeQpResidual()\n{\n  return 0;\n}\n\nthe simulation become as slow as before, so i guess the problem is pretty much come down to the way MOOSE put together the kernels and build the matrix",
                  "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10050594",
                  "updatedAt": "2024-07-15T12:16:28Z",
                  "publishedAt": "2024-07-15T12:16:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think your intuition is correct. Here's my suggestion as I think you are basically doing profiling the hard way, i.e., by recording wall time from huge runs with different configurations. Here is the easy way, as @GiudGiud suggested at the beginning:\n\nCompile your MOOSE with gperftools following the instructions.\nRun a small-ish problem and with gperftools cpuprofiler. Only a few thousand dofs is fine, just make sure the total wall time is at least a few seconds (the longer the better, apparently, as the cpuprofiler is a sampling based profiler).\nUse pprof to list hot spots, from where we can identify code regions that could be optimized.",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10050953",
                          "updatedAt": "2024-07-15T12:59:39Z",
                          "publishedAt": "2024-07-15T12:59:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Regardless, the last time I looked at this, I noticed a few ways of speeding things up at the framework level:\n\nMatrix contribution from linear kernels can be entirely skipped. We just need to compute them once at the beginning of the entire simulation. These kernels include inertial force, gravity, linear damping, and even the stress-divergence kernel in the case of linear elasticity. This will result in huge savings. Implementing this would require the tagging system, which wasn't mature at the time we looked at this issue, but this should be doable nowadays.\nMOOSE materials are evaluated on-the-fly -- meaning that they are computed along with the element loop. Ideally, we only need to reinit materials that are consumed by the kernels (together with the first bullet point, we can skip many material evaluations), but currently we always reinit all materials. This wasn't a big issue for implicit (which is what MOOSE was originally designed for), but this dominates explicit dynamics wall time.\nThe auxkernels for accelerations and velocities only need to be executed at LINEAR.\n\nIIRC, we have a constant_mass option which is basically a specialized case for the first bullet point.",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10051106",
                          "updatedAt": "2024-07-15T13:17:15Z",
                          "publishedAt": "2024-07-15T13:17:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'd also like to add that resolving the second bullet point also benefits MOOSE implicit.",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10051129",
                          "updatedAt": "2024-07-15T13:18:49Z",
                          "publishedAt": "2024-07-15T13:18:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @hugary1995\nThank you for you suggestions! they are very helpful.\nI will try to do the profiling again, then I will look into the 2nd bullet point, and the 3rd point should be as simple as just fixing the input file I assume.\nI will keep you guys updated :)",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10051248",
                          "updatedAt": "2024-07-15T13:29:10Z",
                          "publishedAt": "2024-07-15T13:29:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "1 should be the easiest to do.\nFor porous flow you have quite a few linear terms right?\nBUT as you mentioned adding a single term already slows it down too much so 1) is not enough for your case UNLESS all your kernels are linear",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10053358",
                          "updatedAt": "2024-07-15T16:32:12Z",
                          "publishedAt": "2024-07-15T16:32:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi guys\nI've been working on 2) now the run time is ~30% faster\nI have a few questions to ask:\n@GiudGiud\nwhat is FEProblem::outputStep why does it take so long?\neven i turned off the whole [Outputs] block, it's still there, is this related to data exchange after the matrix is solved?\n\nvoid\nFEProblemBase::outputStep(ExecFlagType type)\n{\n  TIME_SECTION(\"outputStep\", 1, \"Outputting\");\n\n  setCurrentExecuteOnFlag(type);\n\n  for (auto & sys : _solver_systems)\n    sys->update();\n  _aux->update();\n  if (_displaced_problem)\n    _displaced_problem->syncSolutions();\n  _app.getOutputWarehouse().outputStep(type);\n\n  setCurrentExecuteOnFlag(EXEC_NONE);\n}\n\n@hugary1995 @cbolisetti I have a question regarding constant_mass, I checked, so when we have that equal to true, we only computeQpJacobian() once at _t_step ==1\nfor example below is InertialForceTempl<false>::computeQpJacobian(), it has _du_dotdot_du and _du_dot_du terms which are updated at every timestep (right?), i'm not sure if this is the right way to do it, shouldnt it be updated at every timestep, or I missed something important here? I remember @recuero mentioned this before, but I didn't understand it back then.\n      return _test[_i][_qp] * _density[_qp] * (*_du_dotdot_du)[_qp] * _phi[this->_j][_qp] +\n             _eta[_qp] * (1 + _alpha) * _test[_i][_qp] * _density[_qp] * (*_du_dot_du)[_qp] *\n                 _phi[this->_j][_qp];\n\nThank you guys!",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10079531",
                          "updatedAt": "2024-07-18T03:15:54Z",
                          "publishedAt": "2024-07-18T03:14:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Even when you turn everything off there is still the automated checkpoint\nset wall_time_checkpoint = false\nhttps://mooseframework.inl.gov/source/outputs/Checkpoint.html\nDid you end up profiling with a profiler?",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10079558",
                          "updatedAt": "2024-07-18T03:23:51Z",
                          "publishedAt": "2024-07-18T03:22:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud\n\nabove is 20 steps version, dont think it helps much, i already set that to false before I posted it. not sure why outputStep is as big as 1/4 of the solver time.\nhere is my [Outputs]\n  [Outputs]\n    checkpoint = false\n    perf_graph = true\n    wall_time_checkpoint = false\n    # console = false\n    # exodus = true\n    # [console]\n    #   type = Console\n    #   output_screen = false\n    # []\n    [Checkpoint_out]\n      type = Checkpoint\n      num_files = 0\n      wall_time_checkpoint = false\n      enable = false\n      execute_on = FINAL\n    []\n  []\n\nRE: profiling, not yet, I can try it again (but i dont have much hope for this)",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10079850",
                          "updatedAt": "2024-07-18T04:15:37Z",
                          "publishedAt": "2024-07-18T04:15:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "void\nFEProblemBase::outputStep(ExecFlagType type)\n{\n  TIME_SECTION(\"outputStep\", 1, \"Outputting\");\n\n  setCurrentExecuteOnFlag(type);\n\n  for (auto & sys : _solver_systems)\n    sys->update();\n  _aux->update();\n  if (_displaced_problem)\n    _displaced_problem->syncSolutions();\n\nthis is probably the slow part (though a profiler will tell you for sure) (or comment them out and see if it gets out of the perf_graph)\nthese sync operations will cost you in parallel and when using the displaced mesh. We would need to detect whether the need is real (probably let the outputWarehouse make that determination based on what outputs have been created)",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10080309",
                          "updatedAt": "2024-07-18T05:47:01Z",
                          "publishedAt": "2024-07-18T05:46:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "RE:  _du_dotdot_du and _du_dot_du\ni just realised they are a constant from CentralDifference::computeTimeDerivatives()\n // used for Jacobian calculations\n  _du_dot_du = 1.0 / (2 * _dt);\n  _du_dotdot_du = 1.0 / (_dt * _dt);\n\n@GiudGiud the problem is from\n_app.getOutputWarehouse().outputStep(type); under FEProblemBase::outputStep(ExecFlagType type)\nyeh not sure what to do, maybe i should call it at a certain interval of time (like every 200 steps something like this) as I guess, it is important to output .e and other stuff",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10084657",
                          "updatedAt": "2024-07-18T13:13:06Z",
                          "publishedAt": "2024-07-18T13:13:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Primary helium to secondary air system (brayton) turbine not working",
          "author": {
            "login": "oh304"
          },
          "bodyText": "Hi there! I hope you are well.\nI have been using some components in moose to create a system where a heat source from some power heats up a primary system with a pressuriser, pump and heat exchanger. This primary system works fine, and I can see a nice heat up through the pipes, and eventually passing through the heat exchanger.\nThe heat exchanger is modelled using the HeatTransferFromHeatStructure1Phase component, connecting the primary and secondary pipes through a cylindrical heat structure:\n[hx]\n        [p_hx_pipe]\n            type = FlowChannel1Phase\n            position = ${p_pos_6}\n            orientation = ${down}\n            length = ${p_L6}\n            n_elems = ${p_n_elems6}\n            A = ${p_A_pipe}\n            D_h = ${p_D_pipe}\n            \n            fp = helium\n            initial_p = ${p_pressure}\n            initial_T = ${temp_out_at_hx}\n            initial_vel = ${p_initial_vel}\n        []\n        [ht1]\n            type = HeatTransferFromHeatStructure1Phase\n            hs = 'hx/heat_structure'\n            hs_side = OUTER\n            flow_channel = 'hx/p_hx_pipe'\n            Hw = 2e3\n            P_hf = ${p_L6}\n        []\n\n        [heat_structure]\n            type = HeatStructureCylindrical\n            position = ${p_pos_6_hs}\n            orientation = ${down}\n            length = ${p_L6}\n            n_elems = ${p_n_elems6}\n            names = 'region1'\n            n_part_elems = 20\n            num_rods = 10000\n            solid_properties = 'region1-mat'\n            solid_properties_T_ref = '300'\n            inner_radius = ${inner_radius}\n            widths = ${fparse s_x1 - 1}\n        []\n\n        [ht2]\n            type = HeatTransferFromHeatStructure1Phase\n            hs = 'hx/heat_structure'\n            hs_side = INNER\n            flow_channel = 'hx/s_hx_pipe'\n            Hw = 2e3\n            P_hf = ${s_L5}\n        []\n\n        [s_hx_pipe]\n            type = FlowChannel1Phase\n            position = '${s_pos_5}'\n            length = ${s_L5}\n            orientation = ${up}\n            n_elems = ${s_n_elems5}\n            A = ${s_A_pipe}\n        []\n    []\n\nThe secondary loop is then almost entirely copied from the closed brayton example in MOOSE:\nhttps://mooseframework.inl.gov/moose/modules/thermal_hydraulics/examples/brayton_cycle/brayton_cycle.html\nI then model the shaft, motor compressor and turbine as in the example above:\n    [shaft]\n        type = Shaft\n        connected_components = 'motor compressor turbine generator'\n        initial_speed = ${speed_initial}\n    [] \n    [motor]\n        type = ShaftConnectedMotor\n        inertia = ${I_motor}\n        torque = 0 # controlled\n    []\n    [generator]\n        type = ShaftConnectedMotor\n        inertia = ${I_generator}\n        torque = generator_torque_fn\n    []\n    [compressor]\n        type = ShaftConnectedCompressor1Phase\n        position = '${s_pos_3}'\n        inlet = 's/pipe2:out'\n        outlet = 's/pipe3:in'\n        A_ref = ${A_ref_comp}\n        volume = ${V_comp}\n        omega_rated = ${speed_rated}\n        mdot_rated = ${rated_mfr}\n        c0_rated = ${c0_rated_comp}\n        rho0_rated = ${rho0_rated_comp}\n        speeds = '0.5208 0.6250 0.7292 0.8333 0.9375'\n        Rp_functions = 'rp_comp1 rp_comp2 rp_comp3 rp_comp4 rp_comp5'\n        eff_functions = 'eff_comp1 eff_comp2 eff_comp3 eff_comp4 eff_comp5'\n        min_pressure_ratio = 1\n        speed_cr_I = 0\n        inertia_const = ${I_comp}\n        inertia_coeff = '${I_comp} 0 0 0'\n        speed_cr_fr = 0\n        tau_fr_const = 0\n        tau_fr_coeff = '0 0 0 0'\n    []\n    [turbine]\n        type = ShaftConnectedCompressor1Phase\n        position = '${s_pos_7}'\n        inlet = 's/pipe6:out'\n        outlet = 's/pipe7:in'\n        A_ref = ${A_ref_turb}\n        volume = ${V_turb}\n        treat_as_turbine = true\n        omega_rated = ${speed_rated}\n        mdot_rated = ${rated_mfr}\n        c0_rated = ${c0_t_rated_comp}\n        rho0_rated = ${rho0_t_rated_comp}\n        speeds = '0 0.5208 0.6250 0.7292 0.8333 0.9375'\n        Rp_functions = 'rp_turb0 rp_turb1 rp_turb2 rp_turb3 rp_turb4 rp_turb5'\n        eff_functions = 'eff_turb1 eff_turb1 eff_turb2 eff_turb3 eff_turb4 eff_turb5'\n        min_pressure_ratio = 1\n        speed_cr_I = 0\n        inertia_const = ${I_turb}\n        inertia_coeff = '${I_turb} 0 0 0'\n        speed_cr_fr = 0\n        tau_fr_const = 0\n        tau_fr_coeff = '0 0 0 0'\n    []\n\nMy issue is, the turbine doesn't seem to be working. The system is initialised through a motor powering the compressor. The motor then rampsdown, however the shaft speed falls with it. The pressure ratio in the turbine increases whilst the motor is on, but as it falls, the turbine then stops working and the pressure ratio returns to 1 for the rest of the simulation. This is not what I expect of course, but cannot understand what I am missing to get past this.\nPlease let me know if I'm missing anything obvious, and thank you for your time! :)\nOscar",
          "url": "https://github.com/idaholab/moose/discussions/28108",
          "updatedAt": "2024-07-22T14:07:22Z",
          "publishedAt": "2024-07-11T15:53:25Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@joshuahansel",
                  "url": "https://github.com/idaholab/moose/discussions/28108#discussioncomment-10024392",
                  "updatedAt": "2024-07-11T18:50:05Z",
                  "publishedAt": "2024-07-11T18:50:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "Can you summarize what you've changed from the example?",
                  "url": "https://github.com/idaholab/moose/discussions/28108#discussioncomment-10115513",
                  "updatedAt": "2024-07-22T14:07:24Z",
                  "publishedAt": "2024-07-22T14:07:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error in NearestNodeThread",
          "author": {
            "login": "jin0123456"
          },
          "bodyText": "Hello,\nI met this when I simulate about gap heat transfer based mortar,\nFailure in NearestNodeThread because solution contains inf or not-a-number entries.  This is likely due to a failed factorization of the Jacobian matrix.\n\nI found it in NearestNodeThread.C,\nif (closest_distance == std::numeric_limits<Real>::max())\n    {\n      for (unsigned int k = 0; k < n_neighbor_nodes; k++)\n      {\n        const Node * cur_node = &_mesh.nodeRef(neighbor_nodes[k]);\n        if (std::isnan((*cur_node)(0)) || std::isinf((*cur_node)(0)) ||\n            std::isnan((*cur_node)(1)) || std::isinf((*cur_node)(1)) ||\n            std::isnan((*cur_node)(2)) || std::isinf((*cur_node)(2)))\n          throw MooseException(\n              \"Failure in NearestNodeThread because solution contains inf or not-a-number \"\n              \"entries.  This is likely due to a failed factorization of the Jacobian \"\n              \"matrix.\");\n      }\n      mooseError(\"Unable to find nearest node!\");\n    }\n\nIf i use Thermalcontact to calculate gap heat transfer it would be ok but went wrong in this way.\nWhat's my problem and why would my coordinate value be nan or inf?\nI'd be grateful to the advice.",
          "url": "https://github.com/idaholab/moose/discussions/28182",
          "updatedAt": "2024-07-22T13:11:01Z",
          "publishedAt": "2024-07-19T06:08:07Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is likely a mesh issue. What do the two surfaces set for the gap heat transfer look like?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28182#discussioncomment-10097493",
                  "updatedAt": "2024-07-19T16:18:24Z",
                  "publishedAt": "2024-07-19T16:18:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "I know where I went wrong,\nI didn't define the constraint related varible lm in specific block.\nIt went well after I changed it.",
                          "url": "https://github.com/idaholab/moose/discussions/28182#discussioncomment-10114908",
                          "updatedAt": "2024-07-22T13:11:02Z",
                          "publishedAt": "2024-07-22T13:11:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "LinearFluidProperties Error",
          "author": {
            "login": "Jake-HW-Miles"
          },
          "bodyText": "Hi there,\nI am experimenting with the thermal hydraulics functionality to hopefully do some system analysis. I have made an input file that seems to work with the fluid properties in simplefluidproperties, so wanted to implement more realistic properties using the linearfluidproperties instead.\nThe implementation is as follows:\n[FluidProperties]\n    # Placeholder fluid property\n    [secondary_loop_fluid]\n        type = LinearFluidProperties\n        T_0 = ${temp_ref}\n        p_0 = ${RTP_pressure}\n        rho_0 = ${rho}\n        cv = ${salt_specific_heat}\n        a2 = 1e7 # Treat as incompressible hence dp/drho approaches infinity:\n        beta = ${coeff_of_thermal_expansion}\n        e_0 = 1.254e10\n        k = ${k}\n        mu = ${mu}\n    []\n[]\n\nHowever am met with the following error:\n*** ERROR ***\nThe following error occurred in the object \"secondary_loop_fluid\", of type \"LinearFluidProperties\".\n\nsecondary_loop_fluid: virtual void SinglePhaseFluidProperties::cv_from_v_e(libMesh::Real, libMesh::Real, libMesh::Real&, libMesh::Real&, libMesh::Real&) const derivatives not implemented.\n\nAt this stage, I require a work around - any suggestions or known fixes?",
          "url": "https://github.com/idaholab/moose/discussions/28010",
          "updatedAt": "2024-07-22T11:45:05Z",
          "publishedAt": "2024-06-27T16:30:56Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe known fixes are:\n\nto implement this routine\nto use a different fluid property UO, for example SimpleFP (I saw you used that already) or one of the generic ones, or one of the specific ones if your field is in the list of the pre-implemented ones already. Which fluid are you using?\n\nHow comfortable are you with C++? For implementing\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9896500",
                  "updatedAt": "2024-06-27T17:06:05Z",
                  "publishedAt": "2024-06-27T16:33:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nI ended up taking a look and finding some mistakes in LinearFP.\nThe missing routine and the routine you needed can be found in this pull request\n#28026\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9920264",
                          "updatedAt": "2024-07-01T01:43:01Z",
                          "publishedAt": "2024-07-01T01:43:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "Thank you very much Guillaume! I will keep an eye out for this",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9923767",
                          "updatedAt": "2024-07-01T09:50:00Z",
                          "publishedAt": "2024-07-01T09:49:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Hi Jake, I'm also interested in which fluid you're using. You say you want to use a more realistic equation of state, but LinearFluidProperties might not fit that description. We've considered removing this class.",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9927301",
                          "updatedAt": "2024-07-01T15:54:01Z",
                          "publishedAt": "2024-07-01T15:54:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "I was originally going to use NaClFluidProperties\nBut the range of validity concerned me, as I want liquid phase, so decided to define it another way. This does not need to perfect at this stage.",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9927355",
                          "updatedAt": "2024-07-01T15:59:31Z",
                          "publishedAt": "2024-07-01T15:59:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes NaClFluidProperties is not designed for THM or the NS module. It s for porous flow applications",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9928772",
                          "updatedAt": "2024-07-01T18:21:26Z",
                          "publishedAt": "2024-07-01T18:21:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "Hi both! I see that #28026 has been merged now! Thank you, this is good to have.\nThe desire to use this FP in the first instance was to get some variation in the FP with temperature. For achieving a more realistic equation of state, I considered using the tabulated approach or TemperaturePressureFunctionFluidProperties. Are both of these available? Should I prioritise one over the other?",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-10113617",
                          "updatedAt": "2024-07-22T10:54:34Z",
                          "publishedAt": "2024-07-22T10:54:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nBoth TabulatedFluidProperties and PressureTemperature...Fp are available\nPlease let me if there are missing properties for either for your application if you try them\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-10114068",
                          "updatedAt": "2024-07-22T11:45:06Z",
                          "publishedAt": "2024-07-22T11:45:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}