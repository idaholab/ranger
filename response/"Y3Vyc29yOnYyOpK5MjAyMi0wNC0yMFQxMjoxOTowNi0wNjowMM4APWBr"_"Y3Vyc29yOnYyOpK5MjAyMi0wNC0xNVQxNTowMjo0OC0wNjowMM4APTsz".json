{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNC0xNVQxNTowMjo0OC0wNjowMM4APTsz"
    },
    "edges": [
      {
        "node": {
          "title": "Combine `PresetDisplacement` with `DirichletBC`",
          "author": {
            "login": "AdrienWehrle"
          },
          "bodyText": "Hi everyone,\nin a MASTODON  application for some simple elastic deformation,  I would like to apply both a DirichletBC and a PresetDisplacement (as e.g here) simultaneously on the same side of my domain as the process I am studying is a combination of direct ground shaking and pressure release.\nHowever, my DirichletBC gets disabled as soon as I enable my PresetDisplacement BC, and that even out of the period where the preset displacement is defined.\nI tried to find examples that would guide me but I couldn't find any so far, so I start wondering if such a situation is even possible/makes sense?\nThank you a lot in advance for your thoughts and help!",
          "url": "https://github.com/idaholab/moose/discussions/20574",
          "updatedAt": "2022-09-14T07:24:40Z",
          "publishedAt": "2022-03-16T14:41:03Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cbolisetti any ideas on this?",
                  "url": "https://github.com/idaholab/moose/discussions/20574#discussioncomment-2482121",
                  "updatedAt": "2022-09-14T07:24:41Z",
                  "publishedAt": "2022-03-31T23:43:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cbolisetti"
                  },
                  "bodyText": "HI @AdrienWehrle are you trying to apply a DirichletBC and PresetDisplacement simultaneously to different dofs? In the MASTODON example that you referenced the BCs are applied to different dofs and that should work just fine. I don't think you can apply them simultaneously to the same dof. Also, if you can share your input file, that would be helpful.",
                  "url": "https://github.com/idaholab/moose/discussions/20574#discussioncomment-2487862",
                  "updatedAt": "2022-09-14T07:24:41Z",
                  "publishedAt": "2022-04-01T18:32:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AdrienWehrle"
                          },
                          "bodyText": "Hi @cbolisetti!\nThank you a lot for your help! I'm trying to constrain the displacement in a given direction with a Dirichlet BC + a variable pressure BC. Both result in a displacement (directly or as a result of, respectively) and I would like to combine them on the same node. In the example I refer to, the only BC for, e.g., accel_x is x_motion, it is not combined with a Dirichlet BC on the same variable. Again, I am not sure this is actually possible/makes sense.\nhttps://github.com/idaholab/mastodon/blob/f11984c9b64481322afff56448d678f19d646cc5/examples/ex14/building_basemat_with_isolators_new.i#L478\nI will share an input file shortly but the idea would be to have the following BCs on one of the sides of a rectangular prism:\n[BCs]\n  [Pressure]\n    [side_pressure]  \n    boundary = side_1\n    function = pressure_release\n    displacements = 'disp_x disp_y disp_z'\n    []\n  []\n\n  [tremor]\n    type = PresetDisplacement\n    boundary = 'side_1'\n    function = disp_BC\n    variable = 'disp_x'\n    beta = 0.25\n    acceleration = 'accel_x'\n    velocity = 'vel_x'\n  []\n[]\n\nwith functions being e.g.:\n[Functions]\n  [pressure_release]\n    type = ParsedFunction\n    value = 'if (t < 0.1, 8829*(1000-z), 8829*(1000-z) - 1*8829*(1000))'   \n  []\n  [disp_BC]\n    type = PiecewiseLinear\n    data_file = Ormsby.csv\n    format = 'columns'\n  []\n[]\n\nThe problem is that I don't obtain a disp_x which is a combination of the two BCs, only side_pressure is applied.\nJust because that might help to understand why I want to do that: the science case behind is to combine a pressure release + tremor (the Ormsby wavelet is used here) on the same side of the domain.\nThank you a lot for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/20574#discussioncomment-2497860",
                          "updatedAt": "2022-09-14T07:24:41Z",
                          "publishedAt": "2022-04-04T06:29:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "Hi @AdrienWehrle, I see what you mean now, thanks for elaborating. PressureBC is an integrated BC and PresetDisplacement is a dirichlet BC, so we should be able to apply them together. I am not sure why it wouldn't work. Perhaps @bwspenc or @GiudGiud would know?",
                          "url": "https://github.com/idaholab/moose/discussions/20574#discussioncomment-2501793",
                          "updatedAt": "2022-09-14T07:24:42Z",
                          "publishedAt": "2022-04-04T16:13:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "Actually, on further thought, I don't applying a pressure and a Dirichlet BC on the same boundary would make a lot of sense. If the DirichletBC is applied, the disp_x is basically prescribed and any other BC on the same boundary and dof will not make any difference. Perhaps that is why Dirichlet BCs are turned off when you apply them together?",
                          "url": "https://github.com/idaholab/moose/discussions/20574#discussioncomment-2501894",
                          "updatedAt": "2022-09-14T07:24:42Z",
                          "publishedAt": "2022-04-04T16:24:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AdrienWehrle"
                          },
                          "bodyText": "Perhaps that is why Dirichlet BCs are turned off when you apply them together?\n\nHi @cbolisetti, that is indeed also my guess... Do you see any other possibility to combine two forcings on the same boundary? Maybe should I combine them in pre-processing and feed the result into a PresetDisplacement... But the tricky part is my pressure release depends on elevation and is therefore not constant across the whole boundary like a PresetDisplacement...\nThank you a lot for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/20574#discussioncomment-2506072",
                          "updatedAt": "2022-09-14T07:24:42Z",
                          "publishedAt": "2022-04-05T07:40:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Where are tensor operations defined?",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "Hi -\nI'm trying to understand more about how MOOSE performs tensor operations but I'm getting lost in all the inheritance stuff going on. Can someone help me find where different methods and operators are defined for tensors? For instance in RankTwoTensor.h, operator overloads are defined in terms of other operator overloads and I can't quite seem to follow the path down to the actual implementation.\nThanks for your help.",
          "url": "https://github.com/idaholab/moose/discussions/20820",
          "updatedAt": "2022-06-11T08:37:10Z",
          "publishedAt": "2022-04-19T17:34:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "RankTwoTensor inherits from RealTensorValue, which inherits from TypeTensor. Both of those are in libmesh. The rank three and four tensors do not inherit from anything and all their operators are implemented in the *Implementation.h files.",
                  "url": "https://github.com/idaholab/moose/discussions/20820#discussioncomment-2595189",
                  "updatedAt": "2022-06-11T08:37:10Z",
                  "publishedAt": "2022-04-19T17:43:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Ah, so for instance it looks like RankTwoTensor * RankTwoTensor would bring you here in type_tensor.h?",
                          "url": "https://github.com/idaholab/moose/discussions/20820#discussioncomment-2595359",
                          "updatedAt": "2022-06-11T08:37:28Z",
                          "publishedAt": "2022-04-19T18:13:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "yes",
                          "url": "https://github.com/idaholab/moose/discussions/20820#discussioncomment-2596503",
                          "updatedAt": "2022-06-11T08:37:28Z",
                          "publishedAt": "2022-04-19T21:33:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "FunctionDirichletBC not being applied when using CentralDifference time integrator",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Hi All,\nI am running a simple test in uniaxial compression. I am applying a function dirichlet BC at the right BC and fixing the left boundary.\nWhen using a NewmarkBeta time integrator, the problem behaves as expected.\nHowever, when I apply a CentralDifference time integrator the function BC is no longer applied.\nI would like some insight as to why this is occurring.\nMy input file is pasted below\nThank you in advance!\n[Mesh]\n  [fmg]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 10\n    ny = 10\n    xmax = 1\n    ymax = 1\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n[]\n\n[Kernels]\n  [DynamicTensorMechanics]\n    displacements = 'disp_x disp_y'\n  []\n  [inertia_x]\n    type = InertialForce\n    variable = disp_x\n  []\n  [inertia_y]\n    type = InertialForce\n    variable = disp_y\n  []\n[]\n\n[BCs]\n  [lefx]\n    type = DirichletBC\n    variable = 'disp_x'\n    value = 0\n    boundary = left\n  []\n  [lefty]\n    type = DirichletBC\n    variable = 'disp_y'\n    value = 0\n    boundary = left\n  []\n  [rightx]\n    type = FunctionDirichletBC\n    variable = 'disp_x'\n    function = '-1e-3*t' # -1e3 1/s to 1/micro s\n    boundary = right\n  []\n  [righty]\n    type = DirichletBC\n    variable = disp_y\n    boundary = right\n    value = 0\n\n  []\n[]\n\n\n[Materials]\n  [elasticity_tensor_block]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 203e3\n    poissons_ratio = 0.25\n  []\n  [strain_block]\n    type = ComputeIncrementalSmallStrain\n    displacements = 'disp_x disp_y'\n    implicit = false\n  []\n  [stress_block]\n    type = ComputeFiniteStrainElasticStress\n  []\n  [density]\n    type = GenericConstantMaterial\n    prop_names = density\n    prop_values = 7900\n  []\n[]\n\n[Executioner]\n  type = Transient\n  end_time = 1e2 #1e-4 sec -> micro sec\n  dt = 0.01#1e-7 sec -> micro sec\n  dtmin = 1e-6 #1e-20 sec -> micro sec\n  [TimeIntegrator]\n    type = CentralDifference\n  []\n[]\n\n\n[Outputs]\n  exodus = true\n  csv = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/20819",
          "updatedAt": "2022-07-08T00:17:06Z",
          "publishedAt": "2022-04-19T15:06:58Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAdd preset = false to the FunctionDirichletBC\nsee explanation here\nhttps://mooseframework.inl.gov/moose/source/bcs/DirichletBC.html\nYou may look at the tests in tensor_mechanics/test/tests/central_difference for examples\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20819#discussioncomment-2595605",
                  "updatedAt": "2022-07-08T00:17:23Z",
                  "publishedAt": "2022-04-19T19:05:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Got it,\nThank you!",
                          "url": "https://github.com/idaholab/moose/discussions/20819#discussioncomment-2595654",
                          "updatedAt": "2022-07-08T00:17:26Z",
                          "publishedAt": "2022-04-19T19:15:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Contact convergence issues with FunctionNeumannBC",
          "author": {
            "login": "Flolaffel"
          },
          "bodyText": "Hello,\nI'm currently working on a simulation where I want to press a wheel onto the road and then let it roll along. Since I have convergence issues I tried to simplify the problem by only using a segment of the wheel to press on the road so the solve is faster. When using a FunctionDirichletBC to press the wheel on the road everything is working fine but as soon as I switch to FunctionNeumannBC by system is not converging at all anymore. What could the reason be for this? My input is:\nwheel.txt",
          "url": "https://github.com/idaholab/moose/discussions/20703",
          "updatedAt": "2022-08-10T05:49:49Z",
          "publishedAt": "2022-04-04T09:57:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "Given your description, I wonder if you could be getting rigid body modes in your solution when using Neumann BCs (If problems with convergence are happening when the bodies come into contact). If this happens to be the case, you could use MOOSE control system to switch between BCs once contact is robustly established.\nOne other thing you could try if the above doesn't work is to lower your contact penalty coefficient in one order of magnitude and assess whether it helps with convergence.\nI have not run your input, these are general ideas.",
                  "url": "https://github.com/idaholab/moose/discussions/20703#discussioncomment-2500166",
                  "updatedAt": "2022-08-10T05:49:49Z",
                  "publishedAt": "2022-04-04T12:56:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Thanks for your answer. I tried both your suggestions but to no success. When I use the TimePeriod-Control to switch from Dirichlet to Neumann the system immediatly loses contact. What am I doing wrong? load_disp is a function establishing contact over time and load_force is just a force that's supposed to hold the contact.\n\n[Controls]\n[loading]\ntype = TimePeriod\nenable_objects = 'BCs::load_disp'\ndisable_objects = 'BCs::load_force'\nstart_time = '0'\nend_time = '1'\n[]\n[]\n\nAdditionally, could you please offer some insight as to why it could be there is no contact detection leading to rigid body movement when using a NeumannBC in the first place? Contact establishes without problems when the simulation is displacement controlled. And I've run tests in MOOSE before where contact detection in force controlled calculations worked too.",
                          "url": "https://github.com/idaholab/moose/discussions/20703#discussioncomment-2506806",
                          "updatedAt": "2022-09-21T12:25:47Z",
                          "publishedAt": "2022-04-05T09:39:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "The way I look at this is to assess whether rigid body modes are likely to occur during the solution process. If you have a square block and take a step using displacement control (as opposed to load control), the intermediate solutions stemming from nonlinear iterations are more likely to have the contact interface to remain in contact. The practical behavior of these effects depends on general boundary conditions applied to the problem and the geometry of it.\n\nAnd I've run tests in MOOSE before where contact detection in force controlled calculations worked too.\n\nYeah, that makes sense to me. My experience with this behavior is that is problem-dependent.\nI think the controls should work in general for this type of problem. Some more suggestions: Use pressure/direct load BCs instead of Neumann BCs, make sure the load you switched to in the Controls correspond to the state of deformation you get from the initial displacement conditions, and/or add more boundary conditions to restrict modes of deformation that you are expecting to be restricted by contact interaction.",
                          "url": "https://github.com/idaholab/moose/discussions/20703#discussioncomment-2507928",
                          "updatedAt": "2022-09-21T12:25:48Z",
                          "publishedAt": "2022-04-05T12:54:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Changing the NeumannBC to Pressure helped my linear convergence. Sadly my nonlinear convergence is still too bad for the simulation to continue.\nIn order to get the value for the Pressure BC I used a TagVectorAux AuxKernel and a NodalSum Postprocessor to give me the reaction force at the boundary where the DirichletBC is placed and an AreaPostprocessor to give me the Area of said boundary. Is that the correct precedure?\nDo you have any ideas why there could be convergence issues still?",
                          "url": "https://github.com/idaholab/moose/discussions/20703#discussioncomment-2515930",
                          "updatedAt": "2022-09-19T23:04:21Z",
                          "publishedAt": "2022-04-06T13:10:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Sadly my nonlinear convergence is still too bad for the simulation to continue.\n\nOne possible alleviating measure is to reduce the penalty coefficient for contact, which would work if that's the root cause.\n\nIs that the correct procedure?\n\nIf you are not using scaling, I think that procedure will give you an approximate value that should be sufficient to make the BC switch. You could of course double check those values by imposing some Dirichlet BCs, instead of contact, on the proper side of the model/mesh.\n\nDo you have any ideas why there could be convergence issues still?\n\nIf you are still using 1e4 as penalty factor, that may be one possible reason. I forgot to mention the use of the normalize_penalty option in the contact action, which would remove the influence of element area when applying the penalty coefficient. I'd definitely play with that.",
                          "url": "https://github.com/idaholab/moose/discussions/20703#discussioncomment-2519303",
                          "updatedAt": "2022-09-19T23:04:22Z",
                          "publishedAt": "2022-04-06T21:24:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "If you are not using scaling, I think that procedure will give you an approximate value that should be sufficient to make the BC switch. You could of course double check those values by imposing some Dirichlet BCs, instead of contact, on the proper side of the model/mesh.\n\nOk thanks.\n\nIf you are still using 1e4 as penalty factor, that may be one possible reason. I forgot to mention the use of the normalize_penalty option in the contact action, which would remove the influence of element area when applying the penalty coefficient. I'd definitely play with that.\n\nReducing the penalty factor doesn't help unluckily. Same goes for the normalize_penalty option.",
                          "url": "https://github.com/idaholab/moose/discussions/20703#discussioncomment-2533277",
                          "updatedAt": "2022-09-19T23:04:22Z",
                          "publishedAt": "2022-04-08T19:50:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@Flolaffel any update on this?\nIf this is scaling issues, you should scale your problem way down (to like 1000 dof) and look at the conditioning of your matrix using petsc's svd monitor",
                          "url": "https://github.com/idaholab/moose/discussions/20703#discussioncomment-2586506",
                          "updatedAt": "2022-09-19T23:04:23Z",
                          "publishedAt": "2022-04-18T15:18:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "@GiudGiud There is!\nI found out that the problem didn't lie in the setup of the physics but rather the mesh. I had to change the number of elements in tangential direction to an even number so there is a set of nodes at the lowest point of the wheel. Only then contact is detected I assume. Furthermore from the displacement controlled simulations there was a 0.001 mm gap between the wheel and the road so there is no initial penetration. That had to be removed, propably for the same reason.\nI added locking correction for accurate results and a predictor for better convergence. The final, converging input file looks like this:\nwheel_new.txt",
                          "url": "https://github.com/idaholab/moose/discussions/20703#discussioncomment-2594038",
                          "updatedAt": "2022-09-19T23:04:23Z",
                          "publishedAt": "2022-04-19T15:13:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Need some hint to implement a \"user finite element\"",
          "author": {
            "login": "Vincent-IUTRS-EOST"
          },
          "bodyText": "Dear MOOSE users,\nI am currently working on a TTHM (thermo-hydro-mechanical) model with 2 temperatures, one for the solid grains of rocks and the other for the saturating fluid. My balance equations are implemented and OK, but I would like now to implement a specific finite element modeling the flow in a fracture, the permeability and the normal/tangential mechanical behavior of which depends on the fracture aperture. Here is a little figure for the sake of clarity:\n\nAs I understand the MOOSE philosophy, I cannot introduce a new HEX element for which I could declare dofs for each nodes, as I did before with another code called Code_Aster (https://www.code-aster.org).\nI was thinking to split my mesh with \"BreakMeshByBlockGenerator\", with \"add_transition_interface=true\", but I am not sure (and in fact, don't see how) I will be able to calculate the normal displacement xi.n in my kernel calculating the 2D flow.\nDoes anyone have some hint or strategy to propose ?",
          "url": "https://github.com/idaholab/moose/discussions/20788",
          "updatedAt": "2022-06-18T18:44:17Z",
          "publishedAt": "2022-04-14T09:49:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nBreakMeshByBlockGenerator is for large scale subdivisions of the mesh. You are showing one element here, is this split a long fracture?\nWithout too much understanding of your problem, you will need to solve an equation for the displacement of the mesh. This solve can be done at the same time as the fluid flow solve. The 2D flow kernels can use the displacement in their definition.\n@WilkAndy any thoughts on this?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20788#discussioncomment-2568241",
                  "updatedAt": "2022-06-29T07:52:18Z",
                  "publishedAt": "2022-04-14T16:45:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Vincent-IUTRS-EOST"
                  },
                  "bodyText": "Dear Guillaume,\nThank you for your answer. The element on the previous figure is a single finite element simulating the flow in a fracture which can be as wide as my mesh. I provide below another figure, trying to clarify the situation:\n\nMy problem is to calculate the displacement jump (xi+) - (xi-) (giving the fracture aperture and then the permeability of it) at the quadrature point of the 2D surface containing the 2D flow.\nA+",
                  "url": "https://github.com/idaholab/moose/discussions/20788#discussioncomment-2569522",
                  "updatedAt": "2022-06-29T07:52:30Z",
                  "publishedAt": "2022-04-14T20:42:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Thanks for the additional explanation.\n@cpgr @RLiu2020 should also be knowledgable",
                          "url": "https://github.com/idaholab/moose/discussions/20788#discussioncomment-2569673",
                          "updatedAt": "2022-06-29T07:52:35Z",
                          "publishedAt": "2022-04-14T21:06:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@roystgnr as well, this is kind of a libmesh question in a way",
                          "url": "https://github.com/idaholab/moose/discussions/20788#discussioncomment-2587894",
                          "updatedAt": "2022-06-29T07:52:35Z",
                          "publishedAt": "2022-04-18T19:16:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "The libMesh answer, I'm afraid, is \"TBD, but not available right now\": libMesh/libmesh#3226\nIn the shorter term, though ... that mesh looks very nicely fracture-aligned.  Would it be sufficient to split it along the fracture, turning each hex containing the fracture into two hexes and a quad?  I'm afraid you'd need some additional data structure too (Our Elem::interior_map() could be used from each quad to access one of the neighboring hexes, but not both.  In hindsight that inadequacy of our boundary elements for internal boundaries has been a problem forever, not sure why I never noticed before.) but then you'd just evaluate the internal boundary condition (as well as the fracture flow) on a kernel on the quads.",
                          "url": "https://github.com/idaholab/moose/discussions/20788#discussioncomment-2588428",
                          "updatedAt": "2022-06-29T07:52:35Z",
                          "publishedAt": "2022-04-18T21:04:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "JerryLiu2023"
                  },
                  "bodyText": "Sorry for late response. As Roy discussed, there are a lot development work. But at least, you can have the jump of displacement across the interface. Since you use  BreakMeshByBlockGenerator, your kernel is an interface kernel. In your interface kernel, use getmaterialproperty(displacement) (something likes this) to get displacement on the primary element side, and getneighbornaterialproperty(displacement) to get u for the corresponding other side. No matter you use displaced mesh or not, you Always get displacements. So, jump of u is understood. You already did this before using other codes, but just a reminder that If we don't apply pore pressure on these split two surfaces as appled surface pressure loadings(driving force for fracturing) from the solid equation of view), we may get zero gaps or even negative apertures. Thanks!",
                  "url": "https://github.com/idaholab/moose/discussions/20788#discussioncomment-2588709",
                  "updatedAt": "2022-06-29T07:52:45Z",
                  "publishedAt": "2022-04-18T22:02:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Vincent-IUTRS-EOST"
                  },
                  "bodyText": "Dear all,\nThanks a lot for your answers. As @roystgnr wrote, I have a tiny Python library that meshes my reservoir with HEX elements and apply a function to nodes coordinates afterwards, so that HEX elements are approximately aligned along the fracture. It is then rather easy to implement a small function that would split - as he suggests- by doing : HEX along fracture --> 2 x HEX+ 1 x QUAD. For the moment BreakMeshByBlockGenerator is only an option that I don't exclude.\nNevertheless, as @RLiu2020 noticed, one difficulty is to properly write the mechanical equilibrium of the fracture boundary since the pore pressure appears in the traction vector of the fracture boundaries. After some days of holiday, and to avoid entering deeply in the libmesh library, I was thinking to a new global strategy using the already-implemented features of MOOSE (or features that could be easily implemented in the MOOSE C++ \"high\" layer rather than the libmesh \"down\" layer which would cost me a lot of time). This strategy consists in creating a kind of \"copy\" of the fracture boundary variables, so that the entire fracture behavior (mechanical normal and tangential behaviors + 2D fluid flow) can be solved in the QUAD elements. I provide another scheme for the sake of clarity, and the global strategy written in a kind of MOOSE pseudocode:\n\nI would like to know, based on your experience and since I am using MOOSE only for 2 months (but with some numerical skills from the use of other FE codes before), if this approach may be interesting and may have a chance to work. I noticed that some difficulties may still arise since LinearNodalConstraint is - unfortunately - written for only one variable.... but I hope libmesh is friendly enough ;-) to provide me some interface like mesh.getDof(id,jvar) , giving me the (jvar)^th degree of freedom of node \"id\" , so that I can implement my own NodalConstraint object.\nVincent.",
                  "url": "https://github.com/idaholab/moose/discussions/20788#discussioncomment-2591482",
                  "updatedAt": "2022-06-29T07:52:47Z",
                  "publishedAt": "2022-04-19T09:05:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "mesh.node_ref(id).dof_number(system_number,variable_number,component_number) will give you the global degree of freedom number for a particular component (some FE types have multiple) of a particular variable on a particular system.  Usually if you find yourself using that directly it means there's a better way to do things that you're missing.  I'm not sure what the better way might be at the Moose level here, though.",
                          "url": "https://github.com/idaholab/moose/discussions/20788#discussioncomment-2593968",
                          "updatedAt": "2022-07-25T09:01:38Z",
                          "publishedAt": "2022-04-19T15:03:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to make grid static-PorousFlow",
          "author": {
            "login": "rksin8"
          },
          "bodyText": "Hi\nI am using PorousFlow module and solving a single-phase hydromechanical problem. Grid dimension increases in each time step with the fluid injection. I want to fix the gird for the whole simulation time. I have used use_displaced_mesh = false but still no effect on grid dimension.\nGeometry at t=0: xmax=200\n\nGeometry at some other time: xmax=280\n\nHere is my Input file\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/20789",
          "updatedAt": "2022-11-28T06:09:50Z",
          "publishedAt": "2022-04-14T12:41:50Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "josebastiase"
                  },
                  "bodyText": "Hi,\nMaybe I got you need to fix the displacement at the boundaries. Try this\n  [no_x_disp]\n    type = DirichletBC\n    variable = disp_x\n    value = 0\n    boundary = 'left right'\n  []\n  [no_y_disp]\n    type = DirichletBC\n    variable = disp_z\n    value = 0\n    boundary = 'bottom top'\n  []\n\nCheers",
                  "url": "https://github.com/idaholab/moose/discussions/20789#discussioncomment-2567080",
                  "updatedAt": "2023-07-25T16:57:49Z",
                  "publishedAt": "2022-04-14T13:45:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rksin8"
                          },
                          "bodyText": "Thank you for your reply. I am working on a benchmark problem 5.1.1Test Case 1 where the right face is allowed to move freely.\n\nI always struggle when I validate published problems. I think Young's modules for sandstone (10MPa) used is too less, which results in high displacements.",
                          "url": "https://github.com/idaholab/moose/discussions/20789#discussioncomment-2589309",
                          "updatedAt": "2023-07-25T16:57:54Z",
                          "publishedAt": "2022-04-19T01:10:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "Without actually running this to check, I think that you are injecting ~1000 times more than you think as you are using multiply_by_density = false (so fluxes are volumetric, not mass) in the kernels but then injecting a mass flux, which is a factor of water density greater than you want. Commenting out the multiply_by_density parameters should correct this.",
                  "url": "https://github.com/idaholab/moose/discussions/20789#discussioncomment-2592364",
                  "updatedAt": "2023-07-25T16:57:55Z",
                  "publishedAt": "2022-04-19T11:19:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "Also, thanks for the paper with these benchmark problems. When you get this working, these would make nice examples to add to the documentation if you like.",
                  "url": "https://github.com/idaholab/moose/discussions/20789#discussioncomment-2592375",
                  "updatedAt": "2023-07-25T16:57:57Z",
                  "publishedAt": "2022-04-19T11:21:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Compilation error in AuxKernel.C when new function is added",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Hi,\nI am working towards implementing the new transfer scheme (MultiAppVariableVectorSamplePostprocessorTransfer) as part of building my multi-scale model. Towards this end i wish to add a new function get_selected_qp in RankTwoAux.C that just return the quadrature point number and this has to be called from within AuxKernel.C. The compiler however does not allow this simple addition  and throws the following error.\n\nThis has to be done in the same manner as computeValue which is defined and used in RankTwoAux.h and AuxKernel.C respectively. Unfortunately the addition of new function is not known to the compiler, mainly due to the fact that its templated. The inclusion of computeValue suggests that dependencies required from RankTwoAux is already satisfied. I welcome any suggestion/pointers on a possible fix for this error. The related modifications for get_selected_qp can be seen here.\n-------From RankTwoAux.C-----------\ntemplate <bool is_ad>\nunsigned int RankTwoAuxTempl<is_ad>::get_selected_qp()\n{\nreturn _selected_qp;\n}\n\n\n-------From RankTwoAux.h-----------\ntemplate \nclass RankTwoAuxTempl : public NodalPatchRecovery\n{\npublic:\n  static InputParameters validParams();\n\n  RankTwoAuxTempl(const InputParameters & parameters);\n\npublic:\n  virtual Real computeValue();\n  virtual unsigned int get_selected_qp(); \n\nprivate:\n  const GenericMaterialProperty & _tensor;\n  const unsigned int _i;\n  const unsigned int _j;\n\n  /// whether or not selected_qp has been set\n  const bool _has_selected_qp;\n\n  /// The std::vector will be evaluated at this quadpoint only if defined\n  const unsigned int _selected_qp;\n};\n\n\n--------- From AuxKernel.C -----------------\nelse /* elemental variables /\n{\n_n_local_dofs = _var.numberOfDofs();\nif (_n_local_dofs == 1) / p0 */\n{\nComputeValueType value = 0;\nfor (_qp = 0; _qp < _qrule->n_points(); _qp++){\nvalue += _JxW[_qp] * _coord[_qp] * computeValue();\n}\nvalue /= (_bnd ? _current_side_volume : _current_elem_volume);\nif (_var.isFV())\nsetDofValueHelper(value);\nelse\n// update the variable data referenced by other kernels.\n// Note that this will update the values at the quadrature points too\n// (because this is an Elemental variable)\n_var.setNodalValue(value);\n printf(\"get_selected_qp:%d\\n\",get_selected_qp());",
          "url": "https://github.com/idaholab/moose/discussions/20792",
          "updatedAt": "2022-07-05T06:10:21Z",
          "publishedAt": "2022-04-14T17:48:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "So get_selected_qp() is defined in RankTwoAux but you want to use it in AuxKernel?\nBut RankTwoAux derives from AuxKernel not the other way around, so it must be defined in AuxKernel if it s used there",
                  "url": "https://github.com/idaholab/moose/discussions/20792#discussioncomment-2569533",
                  "updatedAt": "2022-07-05T06:10:24Z",
                  "publishedAt": "2022-04-14T20:43:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Yes get_selected_qp() is defined in RankTwoAux and i want to call this from AuxKernel.C. I tried defining this in AuxKernel.C through the introduction of header file \"RankTwoAux.h\". But it did not help. Its quite tricky to call a derived class function inside a parent class. I tried several other options and kind of stuck at this. I wonder how computeValue() is called in AuxKernel.C without going through all the complicated stuffs. I am doing very similar here.",
                          "url": "https://github.com/idaholab/moose/discussions/20792#discussioncomment-2586395",
                          "updatedAt": "2022-07-05T06:10:29Z",
                          "publishedAt": "2022-04-18T14:57:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It's because you should not do this. A function needed by a parent class needs to be defined in the parent class, not in the derived class.\nIf you REALLY want to do this the other way, do this (pseudo code):\nif (dynamic_cast<RankTwoAux *>(this))\n{\n  dynamic_cast<RankTwoAux *>(this)->get_selected_qp();\n }",
                          "url": "https://github.com/idaholab/moose/discussions/20792#discussioncomment-2586542",
                          "updatedAt": "2022-07-05T06:10:29Z",
                          "publishedAt": "2022-04-18T15:22:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "That's an excellent suggestion. It works OK. I wonder how this block of code works in AuxKernel.C without this downcasting procedure\nfor (_qp = 0; _qp < _qrule->n_points(); _qp++){\n        value += _JxW[_qp] * _coord[_qp] * computeValue();\n}",
                          "url": "https://github.com/idaholab/moose/discussions/20792#discussioncomment-2586947",
                          "updatedAt": "2022-07-05T06:10:35Z",
                          "publishedAt": "2022-04-18T16:28:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Second Order Lagrange Divergence",
          "author": {
            "login": "jinca"
          },
          "bodyText": "Hello dear MOOSE team\nI have a question about the convergence status in a simulation that calculates the temperature and displacement in 3D.\n\nWhen I am using 2 cores and the FIRST LAGRANGE ORDER, it converged!\nWhen I am using 32 cores and the SECOND LAGRANGE ORDER, it does not!\nI am attaching the output file for both cases.\nI cannot provide the mesh by applying the second lagrange order because the simulation was stopped at 12 hours.\n(I set my script for 12 hours)\nThanks in advance,\nJulita\nhypre_2_FIRST.txt\nhypre_32_SECOND.txt",
          "url": "https://github.com/idaholab/moose/discussions/20808",
          "updatedAt": "2022-05-15T19:16:21Z",
          "publishedAt": "2022-04-18T11:08:37Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nThe residual keeps decreasing, it is converging. You need to play with the convergence criteria to give it more chance to converge (increase l_max_its and nl_max_its) or to accept a less-converged solution (increase l_tol and nl_abs/rel_tol)\nSee this page for all the parameters.\nhttps://mooseframework.inl.gov/source/executioners/Steady.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20808#discussioncomment-2585914",
                  "updatedAt": "2022-04-18T13:28:53Z",
                  "publishedAt": "2022-04-18T13:28:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Configuration of Second Lagrange Order",
          "author": {
            "login": "jinca"
          },
          "bodyText": "Hello dear MOOSE group\nCould you please provide some link with the Second Lagrange configuration?\nI have run a simulation with the first Lagrange order using only 8 cores. It converged!\nWhen I tried with the second lagrange order, I spent 16 cores instead, and it did not converged.\nMaybe it is needed an additional configuration?\nThanks in advance for your help!\nJulita",
          "url": "https://github.com/idaholab/moose/discussions/20758",
          "updatedAt": "2022-06-21T21:34:04Z",
          "publishedAt": "2022-04-09T18:14:33Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you try with a single core and with 8 cores? Adding more cores does change how the problem is preconditioned.\nWhat kind of simulation is it?\nCould you please attach the convergence history log for the first order and second order cases.\nThank you\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20758#discussioncomment-2537866",
                  "updatedAt": "2022-06-21T21:34:04Z",
                  "publishedAt": "2022-04-10T02:17:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jinca"
                          },
                          "bodyText": "Thank you dear Guillaume for the nice and quick answer.\nIt is about a transient simulation that calculates the temperature as well as the displacement in 3D.\nFor the FIRST LAGRANGE order, when I tried using one core in a node with 192GB of memory, the simulation was killed.\nIt converged successfully by using 2 cores across 2 nodes,  4 cores across 4 nodes, and 8 cores across 8 nodes.\nI am attaching the output file of the test: 4 cores across 4 nodes. I used the same input file for these tests. The first order is by default.\nFor the SECOND LAGRANGE order, I tried with 16 cores across 16 nodes, 32 cores across 32 nodes, and 64 cores across 64 nodes.\nAll of them were killed. I am attaching the slurm file that shows the error by setting the second order which indicates that it is not supported. My setting for the second order in the input file as follows:\n[GlobalParams]\norder = SECOND\nfamily = LAGRANGE\ndisplacements = 'disp_x disp_y disp_z'\n[]\n[Variables]\n[temperature]\norder = SECOND\nfamily = LAGRANGE\n[InitialCondition]\ntype = ConstantIC\nvalue = 293\n[]\n[]\n[]\nbench_4cores_4nodes.txt\nslurm-58665149.txt",
                          "url": "https://github.com/idaholab/moose/discussions/20758#discussioncomment-2539537",
                          "updatedAt": "2022-06-21T21:34:13Z",
                          "publishedAt": "2022-04-10T13:59:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nyou need to pass \u2018second_order = true\u2019 in the Mesh block\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/20758#discussioncomment-2539632",
                          "updatedAt": "2022-06-21T21:34:11Z",
                          "publishedAt": "2022-04-10T14:29:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Opened an issue #20759\nWe ll fix it in the near future, in the mean time please see my post above",
                          "url": "https://github.com/idaholab/moose/discussions/20758#discussioncomment-2545006",
                          "updatedAt": "2022-06-21T21:34:11Z",
                          "publishedAt": "2022-04-11T14:04:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jinca"
                          },
                          "bodyText": "Hi dear Guillaume\nIt run with this output:\nNonlinear System:\nAD size required:        40\nNum DOFs:                14379581\nNum Local DOFs:          423001\nVariables:               \"temperature\" { \"disp_x\" \"disp_y\" \"disp_z\" }\nFinite Element Types:    \"LAGRANGE\" \"LAGRANGE\"\nApproximation Orders:    \"FIRST\" \"SECOND\"\nI will try to set SECOND as well in the variable part :)",
                          "url": "https://github.com/idaholab/moose/discussions/20758#discussioncomment-2545074",
                          "updatedAt": "2022-06-21T21:34:20Z",
                          "publishedAt": "2022-04-11T14:10:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jinca"
                          },
                          "bodyText": "Thank you so much GuidGuid :)\nI run successfully my simulation in SECOND ORDER after setting this configuration:\n[Mesh]\nsecond_order = true\n[FileMesh]\ntype = FileMeshGenerator\nfile = 'mesh.e'\n[]\n[Scale]\ntype = TransformGenerator\ninput = FileMesh\ntransform = SCALE\nvector_value = '0.01 0.01 0.01'\n[]\n...\n[Variables]\n[temperature]\norder = SECOND\n[InitialCondition]\ntype = ConstantIC\nvalue = 293\n[]\n[]\n[]\n...\nYou might close this ticket.\nReally appreciate your kind help.\nJulita Inca",
                          "url": "https://github.com/idaholab/moose/discussions/20758#discussioncomment-2585242",
                          "updatedAt": "2022-06-21T21:34:21Z",
                          "publishedAt": "2022-04-18T10:35:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solve failed when reading a mesh with assigning an individual grain ID for each grid",
          "author": {
            "login": "xchengood"
          },
          "bodyText": "Hi Moose experts or Users,\nRecently, I developed a custom class inherited from CrystalPlasticityStressUpdateBase to study creep behavior. For the mesh with 1x1x1, the program can be smoothly performed according to the setting in the Executioner module. But for the mesh with 4x4x4 in which each grid is assigned an individual grain ID with the help of ElementSubdomainIDGenerator, the test file just can be run for a short time and then said \"Solve failed and timestep already at or below dtmin, cannot continue!\" I try to adjust the timestep but that problem still happened. Any ideas for this? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/20800",
          "updatedAt": "2024-02-01T17:02:18Z",
          "publishedAt": "2022-04-15T15:52:48Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCould you please attach the whole output log?\nAnd the input as well.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20800#discussioncomment-2575032",
                  "updatedAt": "2024-02-01T17:02:18Z",
                  "publishedAt": "2022-04-15T15:58:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @GiudGiu, thank you for your reply. The output log, test file, and input_file used in ElementPropertyReadFile are here.\noutput log.txt\ntest.txt\ninput_file.txt",
                          "url": "https://github.com/idaholab/moose/discussions/20800#discussioncomment-2576486",
                          "updatedAt": "2022-07-04T13:44:10Z",
                          "publishedAt": "2022-04-15T19:51:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "@xchengood, Please make sure that the slip systems and unit cell lengths are consistent with the crystal lattice type modeled in the crystal plasticity material class you have selected:\n\nYou have used CrystalPlasticityHCPDislocationSlipBeyerleinUpdate as the material class in your input file, which assumes an HCP lattice (unless you have modified the code locally)\nIn contrast, your input slip systems have the name for a BCC crystal, and the unit cell dimensions used in your input file are all equal, as is appropriate for a cubic crystal but not a HCP crystal\n\nBeyond these potential issues, the recommendations from @ngrilli to check your Euler angles and your convergence criteria are steps I would also recommend",
                          "url": "https://github.com/idaholab/moose/discussions/20800#discussioncomment-2576707",
                          "updatedAt": "2022-07-04T13:44:10Z",
                          "publishedAt": "2022-04-15T20:44:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @sapitts. Thank you for your advice. Actually, I did modify the code locally and changed the crystal type to BCC. I will follow your and @ngrilli's advice to do more attempts.",
                          "url": "https://github.com/idaholab/moose/discussions/20800#discussioncomment-2576782",
                          "updatedAt": "2022-07-04T13:44:11Z",
                          "publishedAt": "2022-04-15T21:00:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Oh good, I'm glad that you had locally modified the code. The original code should have had error checks that would prevent accidental mixing of crystal lattice types--I was a bit worried that those checks had failed!",
                          "url": "https://github.com/idaholab/moose/discussions/20800#discussioncomment-2576820",
                          "updatedAt": "2024-02-01T17:02:36Z",
                          "publishedAt": "2022-04-15T21:02:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@xchengood  I cannot see anything obviously wrong in your input file,\nbut my suggestion is to plot the Euler angles and see if they correspond to what you expect.\nSecond, my experience with the crystal plasticity model is that when you start adding\nmore elements and grains, the convergence becomes more difficult,\ntherefore I think the criterion: nl_rel_tol = 1e-10 may be too strict, just leave default.\nAlso, definitely allow more non-linear iterations.\nAlso, use the substepping option of the class ComputeMultipleCrystalPlasticityStress\nand increase the number of iterations for stress and state variables.\nThird, there seems to be a pressure boundary condition with a jump in stress,\ndon't do that, increase the pressure gradually from zero to the maximum value.\nAlso, try displacement control instead.\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/20800#discussioncomment-2576616",
                  "updatedAt": "2022-07-04T13:43:24Z",
                  "publishedAt": "2022-04-15T20:23:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @ngrilli. Thank you for your advice. I will follow up to do some modifications and do more attempts.",
                          "url": "https://github.com/idaholab/moose/discussions/20800#discussioncomment-2576638",
                          "updatedAt": "2022-07-04T13:43:23Z",
                          "publishedAt": "2022-04-15T20:30:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}